// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/views/site_types.proto

package views

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AWS VPC Parameters
//
// x-displayName: "AWS VPC Parameters"
// Parameters to create new AWS VPC
type AWSVPCParamsType struct {
	// AWS VPC Name
	//
	// x-displayName: "AWS VPC Name"
	// x-required
	// x-example: "MyVpc"
	// Name for your AWS VPC
	//
	// Types that are valid to be assigned to NameChoice:
	//	*AWSVPCParamsType_NameTag
	//	*AWSVPCParamsType_Autogenerate
	NameChoice isAWSVPCParamsType_NameChoice `protobuf_oneof:"name_choice"`
	// Primary IPv4 CIDR block
	//
	// x-displayName: "Primary IPv4 CIDR block"
	// x-required
	// x-example: "10.1.0.0/16"
	// IPv4 CIDR block for this VPC. It has to be private address space.
	// The Primary IPv4 block cannot be modified. All subnets prefixes in this VPC must be part of this CIDR block.
	PrimaryIpv4 string `protobuf:"bytes,3,opt,name=primary_ipv4,json=primaryIpv4,proto3" json:"primary_ipv4,omitempty"`
	// Allocate IPv6 CIDR block
	//
	// x-displayName: "Allocate IPv6 CIDR block from AWS"
	// Allocate IPv6 CIDR block from AWS
	AllocateIpv6 bool `protobuf:"varint,6,opt,name=allocate_ipv6,json=allocateIpv6,proto3" json:"allocate_ipv6,omitempty"`
}

func (m *AWSVPCParamsType) Reset()      { *m = AWSVPCParamsType{} }
func (*AWSVPCParamsType) ProtoMessage() {}
func (*AWSVPCParamsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{0}
}
func (m *AWSVPCParamsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSVPCParamsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSVPCParamsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSVPCParamsType.Merge(m, src)
}
func (m *AWSVPCParamsType) XXX_Size() int {
	return m.Size()
}
func (m *AWSVPCParamsType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSVPCParamsType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSVPCParamsType proto.InternalMessageInfo

type isAWSVPCParamsType_NameChoice interface {
	isAWSVPCParamsType_NameChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AWSVPCParamsType_NameTag struct {
	NameTag string `protobuf:"bytes,2,opt,name=name_tag,json=nameTag,proto3,oneof" json:"name_tag,omitempty"`
}
type AWSVPCParamsType_Autogenerate struct {
	Autogenerate *schema.Empty `protobuf:"bytes,8,opt,name=autogenerate,proto3,oneof" json:"autogenerate,omitempty"`
}

func (*AWSVPCParamsType_NameTag) isAWSVPCParamsType_NameChoice()      {}
func (*AWSVPCParamsType_Autogenerate) isAWSVPCParamsType_NameChoice() {}

func (m *AWSVPCParamsType) GetNameChoice() isAWSVPCParamsType_NameChoice {
	if m != nil {
		return m.NameChoice
	}
	return nil
}

func (m *AWSVPCParamsType) GetNameTag() string {
	if x, ok := m.GetNameChoice().(*AWSVPCParamsType_NameTag); ok {
		return x.NameTag
	}
	return ""
}

func (m *AWSVPCParamsType) GetAutogenerate() *schema.Empty {
	if x, ok := m.GetNameChoice().(*AWSVPCParamsType_Autogenerate); ok {
		return x.Autogenerate
	}
	return nil
}

func (m *AWSVPCParamsType) GetPrimaryIpv4() string {
	if m != nil {
		return m.PrimaryIpv4
	}
	return ""
}

func (m *AWSVPCParamsType) GetAllocateIpv6() bool {
	if m != nil {
		return m.AllocateIpv6
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AWSVPCParamsType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AWSVPCParamsType_NameTag)(nil),
		(*AWSVPCParamsType_Autogenerate)(nil),
	}
}

// AWS VPC choice
//
// x-displayName: "AWS VPC choice"
// This defines choice about AWS VPC for a view
type AWSVPCchoiceType struct {
	// Choice of existing or new VPC
	//
	// x-displayName: "Select existing VPC or create new VPC"
	// x-required
	// This is choice of existing VPC or new VPC
	//
	// Types that are valid to be assigned to Choice:
	//	*AWSVPCchoiceType_NewVpc
	//	*AWSVPCchoiceType_VpcId
	Choice isAWSVPCchoiceType_Choice `protobuf_oneof:"choice"`
}

func (m *AWSVPCchoiceType) Reset()      { *m = AWSVPCchoiceType{} }
func (*AWSVPCchoiceType) ProtoMessage() {}
func (*AWSVPCchoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{1}
}
func (m *AWSVPCchoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSVPCchoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSVPCchoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSVPCchoiceType.Merge(m, src)
}
func (m *AWSVPCchoiceType) XXX_Size() int {
	return m.Size()
}
func (m *AWSVPCchoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSVPCchoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSVPCchoiceType proto.InternalMessageInfo

type isAWSVPCchoiceType_Choice interface {
	isAWSVPCchoiceType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AWSVPCchoiceType_NewVpc struct {
	NewVpc *AWSVPCParamsType `protobuf:"bytes,1,opt,name=new_vpc,json=newVpc,proto3,oneof" json:"new_vpc,omitempty"`
}
type AWSVPCchoiceType_VpcId struct {
	VpcId string `protobuf:"bytes,2,opt,name=vpc_id,json=vpcId,proto3,oneof" json:"vpc_id,omitempty"`
}

func (*AWSVPCchoiceType_NewVpc) isAWSVPCchoiceType_Choice() {}
func (*AWSVPCchoiceType_VpcId) isAWSVPCchoiceType_Choice()  {}

func (m *AWSVPCchoiceType) GetChoice() isAWSVPCchoiceType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *AWSVPCchoiceType) GetNewVpc() *AWSVPCParamsType {
	if x, ok := m.GetChoice().(*AWSVPCchoiceType_NewVpc); ok {
		return x.NewVpc
	}
	return nil
}

func (m *AWSVPCchoiceType) GetVpcId() string {
	if x, ok := m.GetChoice().(*AWSVPCchoiceType_VpcId); ok {
		return x.VpcId
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AWSVPCchoiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AWSVPCchoiceType_NewVpc)(nil),
		(*AWSVPCchoiceType_VpcId)(nil),
	}
}

// Cloud Subnet Param
//
// x-displayName: "New Cloud Subnet Parameters"
// Parameters for creating a new cloud subnet
type CloudSubnetParamType struct {
	// IPv4 Subnet
	//
	// x-displayName: "IPv4 Subnet"
	// x-required
	// x-example: "10.1.2.0/24"
	// IPv4 subnet prefix for this subnet
	Ipv4 string `protobuf:"bytes,1,opt,name=ipv4,proto3" json:"ipv4,omitempty"`
	// IPv6 Subnet
	//
	// x-displayName: "IPv6 Subnet"
	// x-example: "1234:568:abcd:9100::/64"
	// IPv6 subnet prefix for this subnet
	Ipv6 string `protobuf:"bytes,2,opt,name=ipv6,proto3" json:"ipv6,omitempty"`
}

func (m *CloudSubnetParamType) Reset()      { *m = CloudSubnetParamType{} }
func (*CloudSubnetParamType) ProtoMessage() {}
func (*CloudSubnetParamType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{2}
}
func (m *CloudSubnetParamType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudSubnetParamType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CloudSubnetParamType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudSubnetParamType.Merge(m, src)
}
func (m *CloudSubnetParamType) XXX_Size() int {
	return m.Size()
}
func (m *CloudSubnetParamType) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudSubnetParamType.DiscardUnknown(m)
}

var xxx_messageInfo_CloudSubnetParamType proto.InternalMessageInfo

func (m *CloudSubnetParamType) GetIpv4() string {
	if m != nil {
		return m.Ipv4
	}
	return ""
}

func (m *CloudSubnetParamType) GetIpv6() string {
	if m != nil {
		return m.Ipv6
	}
	return ""
}

// Cloud Subnet
//
// x-displayName: "AWS Subnet"
// Parameters for AWS subnet
type CloudSubnetType struct {
	// Choice of subnet
	//
	// x-displayName: "Select Existing Subnet or Create New"
	// x-required
	// Subnet for the Single interface of the site
	//
	// Types that are valid to be assigned to Choice:
	//	*CloudSubnetType_SubnetParam
	//	*CloudSubnetType_ExistingSubnetId
	Choice isCloudSubnetType_Choice `protobuf_oneof:"choice"`
}

func (m *CloudSubnetType) Reset()      { *m = CloudSubnetType{} }
func (*CloudSubnetType) ProtoMessage() {}
func (*CloudSubnetType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{3}
}
func (m *CloudSubnetType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudSubnetType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CloudSubnetType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudSubnetType.Merge(m, src)
}
func (m *CloudSubnetType) XXX_Size() int {
	return m.Size()
}
func (m *CloudSubnetType) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudSubnetType.DiscardUnknown(m)
}

var xxx_messageInfo_CloudSubnetType proto.InternalMessageInfo

type isCloudSubnetType_Choice interface {
	isCloudSubnetType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CloudSubnetType_SubnetParam struct {
	SubnetParam *CloudSubnetParamType `protobuf:"bytes,1,opt,name=subnet_param,json=subnetParam,proto3,oneof" json:"subnet_param,omitempty"`
}
type CloudSubnetType_ExistingSubnetId struct {
	ExistingSubnetId string `protobuf:"bytes,2,opt,name=existing_subnet_id,json=existingSubnetId,proto3,oneof" json:"existing_subnet_id,omitempty"`
}

func (*CloudSubnetType_SubnetParam) isCloudSubnetType_Choice()      {}
func (*CloudSubnetType_ExistingSubnetId) isCloudSubnetType_Choice() {}

func (m *CloudSubnetType) GetChoice() isCloudSubnetType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *CloudSubnetType) GetSubnetParam() *CloudSubnetParamType {
	if x, ok := m.GetChoice().(*CloudSubnetType_SubnetParam); ok {
		return x.SubnetParam
	}
	return nil
}

func (m *CloudSubnetType) GetExistingSubnetId() string {
	if x, ok := m.GetChoice().(*CloudSubnetType_ExistingSubnetId); ok {
		return x.ExistingSubnetId
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CloudSubnetType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CloudSubnetType_SubnetParam)(nil),
		(*CloudSubnetType_ExistingSubnetId)(nil),
	}
}

// AWS Subnets Ids
//
// x-displayName: "AWS Subnets Ids"
// AWS Subnet Ids used by volterra site
type AWSSubnetIdsType struct {
	// AZ Name
	//
	// x-displayName: "AZ Name"
	// x-example: "us-west-2a"
	// AWS availability zone, must be consistent with the selected AWS region.
	AzName string `protobuf:"bytes,1,opt,name=az_name,json=azName,proto3" json:"az_name,omitempty"` // Deprecated: Do not use.
	// Outside Subnet ID
	//
	// x-displayName: "Outside Subnet ID"
	// x-example: "subnet-12345678901234567"
	// Outside subnet ID used by volterra site
	OutsideSubnetId string `protobuf:"bytes,2,opt,name=outside_subnet_id,json=outsideSubnetId,proto3" json:"outside_subnet_id,omitempty"` // Deprecated: Do not use.
	// Inside Subnet ID
	//
	// x-displayName: "Inside Subnet ID"
	// x-example: "subnet-12345678901234567"
	// Inside subnet ID used by volterra site
	InsideSubnetId string `protobuf:"bytes,3,opt,name=inside_subnet_id,json=insideSubnetId,proto3" json:"inside_subnet_id,omitempty"` // Deprecated: Do not use.
	// Workload Subnet ID
	//
	// x-displayName: "Workload Subnet ID"
	// x-example: "subnet-12345678901234567"
	// Workload subnet ID used by volterra site
	WorkloadSubnetId string `protobuf:"bytes,4,opt,name=workload_subnet_id,json=workloadSubnetId,proto3" json:"workload_subnet_id,omitempty"` // Deprecated: Do not use.
	// Outside Subnet Info
	//
	// x-displayName: "Outside Subnet Info"
	// Outside subnet Info
	OutsideSubnet *AWSSubnetInfoType `protobuf:"bytes,5,opt,name=outside_subnet,json=outsideSubnet,proto3" json:"outside_subnet,omitempty"`
	// Inside Subnet Info
	//
	// x-displayName: "Inside Subnet Info"
	// Inside subnet Info
	InsideSubnet *AWSSubnetInfoType `protobuf:"bytes,6,opt,name=inside_subnet,json=insideSubnet,proto3" json:"inside_subnet,omitempty"`
	// Workload Subnet Info
	//
	// x-displayName: "Workload Subnet Info"
	// Workload subnet Info
	WorkloadSubnet *AWSSubnetInfoType `protobuf:"bytes,7,opt,name=workload_subnet,json=workloadSubnet,proto3" json:"workload_subnet,omitempty"`
}

func (m *AWSSubnetIdsType) Reset()      { *m = AWSSubnetIdsType{} }
func (*AWSSubnetIdsType) ProtoMessage() {}
func (*AWSSubnetIdsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{4}
}
func (m *AWSSubnetIdsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSSubnetIdsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSSubnetIdsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSSubnetIdsType.Merge(m, src)
}
func (m *AWSSubnetIdsType) XXX_Size() int {
	return m.Size()
}
func (m *AWSSubnetIdsType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSSubnetIdsType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSSubnetIdsType proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *AWSSubnetIdsType) GetAzName() string {
	if m != nil {
		return m.AzName
	}
	return ""
}

// Deprecated: Do not use.
func (m *AWSSubnetIdsType) GetOutsideSubnetId() string {
	if m != nil {
		return m.OutsideSubnetId
	}
	return ""
}

// Deprecated: Do not use.
func (m *AWSSubnetIdsType) GetInsideSubnetId() string {
	if m != nil {
		return m.InsideSubnetId
	}
	return ""
}

// Deprecated: Do not use.
func (m *AWSSubnetIdsType) GetWorkloadSubnetId() string {
	if m != nil {
		return m.WorkloadSubnetId
	}
	return ""
}

func (m *AWSSubnetIdsType) GetOutsideSubnet() *AWSSubnetInfoType {
	if m != nil {
		return m.OutsideSubnet
	}
	return nil
}

func (m *AWSSubnetIdsType) GetInsideSubnet() *AWSSubnetInfoType {
	if m != nil {
		return m.InsideSubnet
	}
	return nil
}

func (m *AWSSubnetIdsType) GetWorkloadSubnet() *AWSSubnetInfoType {
	if m != nil {
		return m.WorkloadSubnet
	}
	return nil
}

// AWS Subnets Info Type
//
// x-displayName: "AWS Subnets Info Type"
// AWS Subnets Info Type
type AWSSubnetInfoType struct {
	// AZ Name
	//
	// x-displayName: "AZ Name"
	// x-required
	// x-example: "us-west-2a"
	// AWS availability zone, must be consistent with the selected AWS region.
	AzName string `protobuf:"bytes,1,opt,name=az_name,json=azName,proto3" json:"az_name,omitempty"`
	// Subnet ID
	//
	// x-displayName: "Subnet ID"
	// x-example: "subnet-12345678901234567"
	// Subnet ID
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// Subnet CIDR block
	//
	// x-displayName: "Subnet CIDR block"
	// x-required
	// x-example: "10.1.0.0/16"
	// Subnet CIDR block. It has to be private address space.
	Ipv4Prefix string `protobuf:"bytes,3,opt,name=ipv4_prefix,json=ipv4Prefix,proto3" json:"ipv4_prefix,omitempty"`
}

func (m *AWSSubnetInfoType) Reset()      { *m = AWSSubnetInfoType{} }
func (*AWSSubnetInfoType) ProtoMessage() {}
func (*AWSSubnetInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{5}
}
func (m *AWSSubnetInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSSubnetInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSSubnetInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSSubnetInfoType.Merge(m, src)
}
func (m *AWSSubnetInfoType) XXX_Size() int {
	return m.Size()
}
func (m *AWSSubnetInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSSubnetInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSSubnetInfoType proto.InternalMessageInfo

func (m *AWSSubnetInfoType) GetAzName() string {
	if m != nil {
		return m.AzName
	}
	return ""
}

func (m *AWSSubnetInfoType) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AWSSubnetInfoType) GetIpv4Prefix() string {
	if m != nil {
		return m.Ipv4Prefix
	}
	return ""
}

// Single Interface Node
//
// x-displayName: "Single Interface Node"
// Parameters for creating Single interface Node in one AZ
type AWSVPCOneInterfaceNodeType struct {
	// AWS AZ
	//
	// x-displayName: "AWS AZ Name"
	// x-required
	// x-example: "us-west-2a"
	// AWS availability zone, must be consistent with the selected AWS region.
	AwsAzName string `protobuf:"bytes,1,opt,name=aws_az_name,json=awsAzName,proto3" json:"aws_az_name,omitempty"`
	// Subnet
	//
	// x-displayName: "Subnet for local Interface"
	// Subnets for the site local interface of the node
	LocalSubnet *CloudSubnetType `protobuf:"bytes,2,opt,name=local_subnet,json=localSubnet,proto3" json:"local_subnet,omitempty"`
	// Cloud Disk size
	//
	// x-displayName: "Cloud Disk Size"
	// x-example: "80"
	// Disk size to be used for this instance in GiB. 80 is 80 GiB
	DiskSize uint32 `protobuf:"varint,4,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
}

func (m *AWSVPCOneInterfaceNodeType) Reset()      { *m = AWSVPCOneInterfaceNodeType{} }
func (*AWSVPCOneInterfaceNodeType) ProtoMessage() {}
func (*AWSVPCOneInterfaceNodeType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{6}
}
func (m *AWSVPCOneInterfaceNodeType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSVPCOneInterfaceNodeType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSVPCOneInterfaceNodeType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSVPCOneInterfaceNodeType.Merge(m, src)
}
func (m *AWSVPCOneInterfaceNodeType) XXX_Size() int {
	return m.Size()
}
func (m *AWSVPCOneInterfaceNodeType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSVPCOneInterfaceNodeType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSVPCOneInterfaceNodeType proto.InternalMessageInfo

func (m *AWSVPCOneInterfaceNodeType) GetAwsAzName() string {
	if m != nil {
		return m.AwsAzName
	}
	return ""
}

func (m *AWSVPCOneInterfaceNodeType) GetLocalSubnet() *CloudSubnetType {
	if m != nil {
		return m.LocalSubnet
	}
	return nil
}

func (m *AWSVPCOneInterfaceNodeType) GetDiskSize() uint32 {
	if m != nil {
		return m.DiskSize
	}
	return 0
}

// Two Interface Node
//
// x-displayName: "Two Interface Node"
// Parameters for creating two interface Node in one AZ
type AWSVPCTwoInterfaceNodeType struct {
	// AWS AZ
	//
	// x-displayName: "AWS AZ Name"
	// x-required
	// x-example: "us-west-2a"
	// AWS availability zone, must be consistent with the selected AWS region.
	AwsAzName string `protobuf:"bytes,1,opt,name=aws_az_name,json=awsAzName,proto3" json:"aws_az_name,omitempty"`
	// Inside Subnet Choices
	//
	// x-displayName: "Subnet for Inside Interface"
	// x-required
	// Subnet for the inside interface of the node
	//
	// Types that are valid to be assigned to Choice:
	//	*AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet
	//	*AWSVPCTwoInterfaceNodeType_InsideSubnet
	Choice isAWSVPCTwoInterfaceNodeType_Choice `protobuf_oneof:"choice"`
	// Outside Subnet
	//
	// x-displayName: "Subnet for Outside Interface"
	// x-required
	// Subnet for the outside interface of the node
	OutsideSubnet *CloudSubnetType `protobuf:"bytes,3,opt,name=outside_subnet,json=outsideSubnet,proto3" json:"outside_subnet,omitempty"`
	// Workload Subnet
	//
	// x-displayName: "Workload Subnet"
	// Subnet in which workloads are launched
	WorkloadSubnet *CloudSubnetType `protobuf:"bytes,7,opt,name=workload_subnet,json=workloadSubnet,proto3" json:"workload_subnet,omitempty"`
	// Cloud Disk size
	//
	// x-displayName: "Cloud Disk Size"
	// x-example: "80"
	// Disk size to be used for this instance in GiB. 80 is 80 GiB
	DiskSize uint32 `protobuf:"varint,8,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
}

func (m *AWSVPCTwoInterfaceNodeType) Reset()      { *m = AWSVPCTwoInterfaceNodeType{} }
func (*AWSVPCTwoInterfaceNodeType) ProtoMessage() {}
func (*AWSVPCTwoInterfaceNodeType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{7}
}
func (m *AWSVPCTwoInterfaceNodeType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSVPCTwoInterfaceNodeType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSVPCTwoInterfaceNodeType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSVPCTwoInterfaceNodeType.Merge(m, src)
}
func (m *AWSVPCTwoInterfaceNodeType) XXX_Size() int {
	return m.Size()
}
func (m *AWSVPCTwoInterfaceNodeType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSVPCTwoInterfaceNodeType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSVPCTwoInterfaceNodeType proto.InternalMessageInfo

type isAWSVPCTwoInterfaceNodeType_Choice interface {
	isAWSVPCTwoInterfaceNodeType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet struct {
	ReservedInsideSubnet *schema.Empty `protobuf:"bytes,6,opt,name=reserved_inside_subnet,json=reservedInsideSubnet,proto3,oneof" json:"reserved_inside_subnet,omitempty"`
}
type AWSVPCTwoInterfaceNodeType_InsideSubnet struct {
	InsideSubnet *CloudSubnetType `protobuf:"bytes,2,opt,name=inside_subnet,json=insideSubnet,proto3,oneof" json:"inside_subnet,omitempty"`
}

func (*AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet) isAWSVPCTwoInterfaceNodeType_Choice() {}
func (*AWSVPCTwoInterfaceNodeType_InsideSubnet) isAWSVPCTwoInterfaceNodeType_Choice()         {}

func (m *AWSVPCTwoInterfaceNodeType) GetChoice() isAWSVPCTwoInterfaceNodeType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *AWSVPCTwoInterfaceNodeType) GetAwsAzName() string {
	if m != nil {
		return m.AwsAzName
	}
	return ""
}

func (m *AWSVPCTwoInterfaceNodeType) GetReservedInsideSubnet() *schema.Empty {
	if x, ok := m.GetChoice().(*AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet); ok {
		return x.ReservedInsideSubnet
	}
	return nil
}

func (m *AWSVPCTwoInterfaceNodeType) GetInsideSubnet() *CloudSubnetType {
	if x, ok := m.GetChoice().(*AWSVPCTwoInterfaceNodeType_InsideSubnet); ok {
		return x.InsideSubnet
	}
	return nil
}

func (m *AWSVPCTwoInterfaceNodeType) GetOutsideSubnet() *CloudSubnetType {
	if m != nil {
		return m.OutsideSubnet
	}
	return nil
}

func (m *AWSVPCTwoInterfaceNodeType) GetWorkloadSubnet() *CloudSubnetType {
	if m != nil {
		return m.WorkloadSubnet
	}
	return nil
}

func (m *AWSVPCTwoInterfaceNodeType) GetDiskSize() uint32 {
	if m != nil {
		return m.DiskSize
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AWSVPCTwoInterfaceNodeType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet)(nil),
		(*AWSVPCTwoInterfaceNodeType_InsideSubnet)(nil),
	}
}

// Azure Vnet Parameters
//
// x-displayName: "Azure Vnet Parameters"
// Parameters to create a new Azure Vnet
type AzureVnetParamsType struct {
	// Azure Vnet Name
	//
	// x-displayName: "Azure Vnet Name"
	// x-required
	// x-example: "MyVnet"
	// Name for your Azure Vnet
	//
	// Types that are valid to be assigned to NameChoice:
	//	*AzureVnetParamsType_Name
	//	*AzureVnetParamsType_Autogenerate
	NameChoice isAzureVnetParamsType_NameChoice `protobuf_oneof:"name_choice"`
	// IPv4 CIDR block
	//
	// x-displayName: "IPv4 CIDR block"
	// x-required
	// x-example: "10.1.0.0/16"
	// IPv4 CIDR block for this Vnet. It has to be private address space.
	PrimaryIpv4 string `protobuf:"bytes,2,opt,name=primary_ipv4,json=primaryIpv4,proto3" json:"primary_ipv4,omitempty"`
}

func (m *AzureVnetParamsType) Reset()      { *m = AzureVnetParamsType{} }
func (*AzureVnetParamsType) ProtoMessage() {}
func (*AzureVnetParamsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{8}
}
func (m *AzureVnetParamsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureVnetParamsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureVnetParamsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureVnetParamsType.Merge(m, src)
}
func (m *AzureVnetParamsType) XXX_Size() int {
	return m.Size()
}
func (m *AzureVnetParamsType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureVnetParamsType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureVnetParamsType proto.InternalMessageInfo

type isAzureVnetParamsType_NameChoice interface {
	isAzureVnetParamsType_NameChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AzureVnetParamsType_Name struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3,oneof" json:"name,omitempty"`
}
type AzureVnetParamsType_Autogenerate struct {
	Autogenerate *schema.Empty `protobuf:"bytes,4,opt,name=autogenerate,proto3,oneof" json:"autogenerate,omitempty"`
}

func (*AzureVnetParamsType_Name) isAzureVnetParamsType_NameChoice()         {}
func (*AzureVnetParamsType_Autogenerate) isAzureVnetParamsType_NameChoice() {}

func (m *AzureVnetParamsType) GetNameChoice() isAzureVnetParamsType_NameChoice {
	if m != nil {
		return m.NameChoice
	}
	return nil
}

func (m *AzureVnetParamsType) GetName() string {
	if x, ok := m.GetNameChoice().(*AzureVnetParamsType_Name); ok {
		return x.Name
	}
	return ""
}

func (m *AzureVnetParamsType) GetAutogenerate() *schema.Empty {
	if x, ok := m.GetNameChoice().(*AzureVnetParamsType_Autogenerate); ok {
		return x.Autogenerate
	}
	return nil
}

func (m *AzureVnetParamsType) GetPrimaryIpv4() string {
	if m != nil {
		return m.PrimaryIpv4
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AzureVnetParamsType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AzureVnetParamsType_Name)(nil),
		(*AzureVnetParamsType_Autogenerate)(nil),
	}
}

// Azure Existing Vnet Type
//
// x-displayName: "Azure Existing Vnet Type"
// Resource group and name of existing Azure Vnet
type AzureVnetType struct {
	// Existing Vnet Resource Group
	//
	// x-displayName: "Existing Vnet Resource Group"
	// x-required
	// x-example: "MyResourceGroup"
	// Resource group of existing Vnet
	ResourceGroup string `protobuf:"bytes,1,opt,name=resource_group,json=resourceGroup,proto3" json:"resource_group,omitempty"`
	// Existing Vnet Name
	//
	// x-displayName: "Existing Vnet Name"
	// x-required
	// x-example: "MyVnet"
	// Name of existing Vnet
	VnetName string `protobuf:"bytes,2,opt,name=vnet_name,json=vnetName,proto3" json:"vnet_name,omitempty"`
}

func (m *AzureVnetType) Reset()      { *m = AzureVnetType{} }
func (*AzureVnetType) ProtoMessage() {}
func (*AzureVnetType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{9}
}
func (m *AzureVnetType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureVnetType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureVnetType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureVnetType.Merge(m, src)
}
func (m *AzureVnetType) XXX_Size() int {
	return m.Size()
}
func (m *AzureVnetType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureVnetType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureVnetType proto.InternalMessageInfo

func (m *AzureVnetType) GetResourceGroup() string {
	if m != nil {
		return m.ResourceGroup
	}
	return ""
}

func (m *AzureVnetType) GetVnetName() string {
	if m != nil {
		return m.VnetName
	}
	return ""
}

// Azure Vnet choice
//
// x-displayName: "Azure Vnet choice"
// This defines choice about Azure Vnet for a view
type AzureVnetChoiceType struct {
	// Choice of existing or new Vnet
	//
	// x-displayName: "Select existing Vnet or create new Vnet"
	// x-required
	// This is choice of existing Vnet or new Vnet
	//
	// Types that are valid to be assigned to Choice:
	//	*AzureVnetChoiceType_NewVnet
	//	*AzureVnetChoiceType_ExistingVnet
	Choice isAzureVnetChoiceType_Choice `protobuf_oneof:"choice"`
}

func (m *AzureVnetChoiceType) Reset()      { *m = AzureVnetChoiceType{} }
func (*AzureVnetChoiceType) ProtoMessage() {}
func (*AzureVnetChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{10}
}
func (m *AzureVnetChoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureVnetChoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureVnetChoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureVnetChoiceType.Merge(m, src)
}
func (m *AzureVnetChoiceType) XXX_Size() int {
	return m.Size()
}
func (m *AzureVnetChoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureVnetChoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureVnetChoiceType proto.InternalMessageInfo

type isAzureVnetChoiceType_Choice interface {
	isAzureVnetChoiceType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AzureVnetChoiceType_NewVnet struct {
	NewVnet *AzureVnetParamsType `protobuf:"bytes,2,opt,name=new_vnet,json=newVnet,proto3,oneof" json:"new_vnet,omitempty"`
}
type AzureVnetChoiceType_ExistingVnet struct {
	ExistingVnet *AzureVnetType `protobuf:"bytes,3,opt,name=existing_vnet,json=existingVnet,proto3,oneof" json:"existing_vnet,omitempty"`
}

func (*AzureVnetChoiceType_NewVnet) isAzureVnetChoiceType_Choice()      {}
func (*AzureVnetChoiceType_ExistingVnet) isAzureVnetChoiceType_Choice() {}

func (m *AzureVnetChoiceType) GetChoice() isAzureVnetChoiceType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *AzureVnetChoiceType) GetNewVnet() *AzureVnetParamsType {
	if x, ok := m.GetChoice().(*AzureVnetChoiceType_NewVnet); ok {
		return x.NewVnet
	}
	return nil
}

func (m *AzureVnetChoiceType) GetExistingVnet() *AzureVnetType {
	if x, ok := m.GetChoice().(*AzureVnetChoiceType_ExistingVnet); ok {
		return x.ExistingVnet
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AzureVnetChoiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AzureVnetChoiceType_NewVnet)(nil),
		(*AzureVnetChoiceType_ExistingVnet)(nil),
	}
}

// Azure Cloud Subnet
//
// x-displayName: "Azure Subnet"
// Parameters for Azure subnet
type AzureSubnetType struct {
	// Existing Subnet Name
	//
	// x-displayName: "Subnet Name"
	// x-example: "MySubnet"
	// x-required
	// Name of existing subnet.
	SubnetName string `protobuf:"bytes,1,opt,name=subnet_name,json=subnetName,proto3" json:"subnet_name,omitempty"`
	// Existing Subnet Resource Group
	//
	// x-displayName: "Subnet Resource Group"
	// x-example: "MySubnet"
	// Resource group for this subnet.
	//
	// Types that are valid to be assigned to ResourceGroupChoice:
	//	*AzureSubnetType_SubnetResourceGrp
	//	*AzureSubnetType_VnetResourceGroup
	ResourceGroupChoice isAzureSubnetType_ResourceGroupChoice `protobuf_oneof:"resource_group_choice"`
}

func (m *AzureSubnetType) Reset()      { *m = AzureSubnetType{} }
func (*AzureSubnetType) ProtoMessage() {}
func (*AzureSubnetType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{11}
}
func (m *AzureSubnetType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureSubnetType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureSubnetType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureSubnetType.Merge(m, src)
}
func (m *AzureSubnetType) XXX_Size() int {
	return m.Size()
}
func (m *AzureSubnetType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureSubnetType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureSubnetType proto.InternalMessageInfo

type isAzureSubnetType_ResourceGroupChoice interface {
	isAzureSubnetType_ResourceGroupChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AzureSubnetType_SubnetResourceGrp struct {
	SubnetResourceGrp string `protobuf:"bytes,2,opt,name=subnet_resource_grp,json=subnetResourceGrp,proto3,oneof" json:"subnet_resource_grp,omitempty"`
}
type AzureSubnetType_VnetResourceGroup struct {
	VnetResourceGroup *schema.Empty `protobuf:"bytes,4,opt,name=vnet_resource_group,json=vnetResourceGroup,proto3,oneof" json:"vnet_resource_group,omitempty"`
}

func (*AzureSubnetType_SubnetResourceGrp) isAzureSubnetType_ResourceGroupChoice() {}
func (*AzureSubnetType_VnetResourceGroup) isAzureSubnetType_ResourceGroupChoice() {}

func (m *AzureSubnetType) GetResourceGroupChoice() isAzureSubnetType_ResourceGroupChoice {
	if m != nil {
		return m.ResourceGroupChoice
	}
	return nil
}

func (m *AzureSubnetType) GetSubnetName() string {
	if m != nil {
		return m.SubnetName
	}
	return ""
}

func (m *AzureSubnetType) GetSubnetResourceGrp() string {
	if x, ok := m.GetResourceGroupChoice().(*AzureSubnetType_SubnetResourceGrp); ok {
		return x.SubnetResourceGrp
	}
	return ""
}

func (m *AzureSubnetType) GetVnetResourceGroup() *schema.Empty {
	if x, ok := m.GetResourceGroupChoice().(*AzureSubnetType_VnetResourceGroup); ok {
		return x.VnetResourceGroup
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AzureSubnetType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AzureSubnetType_SubnetResourceGrp)(nil),
		(*AzureSubnetType_VnetResourceGroup)(nil),
	}
}

// Azure Cloud Special Subnet
//
// x-displayName: "Azure Cloud Special Subnet"
// Parameters for Azure special subnet which name is reserved. (i.e GatewaySubnet or RouteServerSubnet)
type AzureSpecialSubnetType struct {
	// Existing Subnet Resource Group
	//
	// x-displayName: "Subnet Resource Group"
	// x-example: "MySubnet"
	// Resource group for this subnet.
	//
	// Types that are valid to be assigned to ResourceGroupChoice:
	//	*AzureSpecialSubnetType_SubnetResourceGrp
	//	*AzureSpecialSubnetType_VnetResourceGroup
	ResourceGroupChoice isAzureSpecialSubnetType_ResourceGroupChoice `protobuf_oneof:"resource_group_choice"`
}

func (m *AzureSpecialSubnetType) Reset()      { *m = AzureSpecialSubnetType{} }
func (*AzureSpecialSubnetType) ProtoMessage() {}
func (*AzureSpecialSubnetType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{12}
}
func (m *AzureSpecialSubnetType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureSpecialSubnetType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureSpecialSubnetType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureSpecialSubnetType.Merge(m, src)
}
func (m *AzureSpecialSubnetType) XXX_Size() int {
	return m.Size()
}
func (m *AzureSpecialSubnetType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureSpecialSubnetType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureSpecialSubnetType proto.InternalMessageInfo

type isAzureSpecialSubnetType_ResourceGroupChoice interface {
	isAzureSpecialSubnetType_ResourceGroupChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AzureSpecialSubnetType_SubnetResourceGrp struct {
	SubnetResourceGrp string `protobuf:"bytes,2,opt,name=subnet_resource_grp,json=subnetResourceGrp,proto3,oneof" json:"subnet_resource_grp,omitempty"`
}
type AzureSpecialSubnetType_VnetResourceGroup struct {
	VnetResourceGroup *schema.Empty `protobuf:"bytes,3,opt,name=vnet_resource_group,json=vnetResourceGroup,proto3,oneof" json:"vnet_resource_group,omitempty"`
}

func (*AzureSpecialSubnetType_SubnetResourceGrp) isAzureSpecialSubnetType_ResourceGroupChoice() {}
func (*AzureSpecialSubnetType_VnetResourceGroup) isAzureSpecialSubnetType_ResourceGroupChoice() {}

func (m *AzureSpecialSubnetType) GetResourceGroupChoice() isAzureSpecialSubnetType_ResourceGroupChoice {
	if m != nil {
		return m.ResourceGroupChoice
	}
	return nil
}

func (m *AzureSpecialSubnetType) GetSubnetResourceGrp() string {
	if x, ok := m.GetResourceGroupChoice().(*AzureSpecialSubnetType_SubnetResourceGrp); ok {
		return x.SubnetResourceGrp
	}
	return ""
}

func (m *AzureSpecialSubnetType) GetVnetResourceGroup() *schema.Empty {
	if x, ok := m.GetResourceGroupChoice().(*AzureSpecialSubnetType_VnetResourceGroup); ok {
		return x.VnetResourceGroup
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AzureSpecialSubnetType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AzureSpecialSubnetType_SubnetResourceGrp)(nil),
		(*AzureSpecialSubnetType_VnetResourceGroup)(nil),
	}
}

// Azure Cloud Subnet
//
// x-displayName: "Azure Subnet"
// Parameters for Azure subnet
type AzureSubnetChoiceType struct {
	// Choice of subnet
	//
	// x-displayName: "Select Existing Subnet or Create New"
	// x-required
	// Subnet for the Single interface of the site
	//
	// Types that are valid to be assigned to Choice:
	//	*AzureSubnetChoiceType_SubnetParam
	//	*AzureSubnetChoiceType_Subnet
	Choice isAzureSubnetChoiceType_Choice `protobuf_oneof:"choice"`
}

func (m *AzureSubnetChoiceType) Reset()      { *m = AzureSubnetChoiceType{} }
func (*AzureSubnetChoiceType) ProtoMessage() {}
func (*AzureSubnetChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{13}
}
func (m *AzureSubnetChoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureSubnetChoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureSubnetChoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureSubnetChoiceType.Merge(m, src)
}
func (m *AzureSubnetChoiceType) XXX_Size() int {
	return m.Size()
}
func (m *AzureSubnetChoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureSubnetChoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureSubnetChoiceType proto.InternalMessageInfo

type isAzureSubnetChoiceType_Choice interface {
	isAzureSubnetChoiceType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AzureSubnetChoiceType_SubnetParam struct {
	SubnetParam *CloudSubnetParamType `protobuf:"bytes,2,opt,name=subnet_param,json=subnetParam,proto3,oneof" json:"subnet_param,omitempty"`
}
type AzureSubnetChoiceType_Subnet struct {
	Subnet *AzureSubnetType `protobuf:"bytes,3,opt,name=subnet,proto3,oneof" json:"subnet,omitempty"`
}

func (*AzureSubnetChoiceType_SubnetParam) isAzureSubnetChoiceType_Choice() {}
func (*AzureSubnetChoiceType_Subnet) isAzureSubnetChoiceType_Choice()      {}

func (m *AzureSubnetChoiceType) GetChoice() isAzureSubnetChoiceType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *AzureSubnetChoiceType) GetSubnetParam() *CloudSubnetParamType {
	if x, ok := m.GetChoice().(*AzureSubnetChoiceType_SubnetParam); ok {
		return x.SubnetParam
	}
	return nil
}

func (m *AzureSubnetChoiceType) GetSubnet() *AzureSubnetType {
	if x, ok := m.GetChoice().(*AzureSubnetChoiceType_Subnet); ok {
		return x.Subnet
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AzureSubnetChoiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AzureSubnetChoiceType_SubnetParam)(nil),
		(*AzureSubnetChoiceType_Subnet)(nil),
	}
}

// Azure Cloud Subnet
//
// x-displayName: "Azure Subnet"
// Parameters for Azure subnet
type AzureSubnetChoiceWithAutoType struct {
	// Choice of subnet
	//
	// x-displayName: "Select Auto Subnet, Existing Subnet or Create New"
	// x-required
	// Select Auto Subnet, Existing Subnet or Create New
	//
	// Types that are valid to be assigned to Choice:
	//	*AzureSubnetChoiceWithAutoType_Auto
	//	*AzureSubnetChoiceWithAutoType_SubnetParam
	//	*AzureSubnetChoiceWithAutoType_Subnet
	Choice isAzureSubnetChoiceWithAutoType_Choice `protobuf_oneof:"choice"`
}

func (m *AzureSubnetChoiceWithAutoType) Reset()      { *m = AzureSubnetChoiceWithAutoType{} }
func (*AzureSubnetChoiceWithAutoType) ProtoMessage() {}
func (*AzureSubnetChoiceWithAutoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{14}
}
func (m *AzureSubnetChoiceWithAutoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureSubnetChoiceWithAutoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureSubnetChoiceWithAutoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureSubnetChoiceWithAutoType.Merge(m, src)
}
func (m *AzureSubnetChoiceWithAutoType) XXX_Size() int {
	return m.Size()
}
func (m *AzureSubnetChoiceWithAutoType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureSubnetChoiceWithAutoType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureSubnetChoiceWithAutoType proto.InternalMessageInfo

type isAzureSubnetChoiceWithAutoType_Choice interface {
	isAzureSubnetChoiceWithAutoType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AzureSubnetChoiceWithAutoType_Auto struct {
	Auto *schema.Empty `protobuf:"bytes,2,opt,name=auto,proto3,oneof" json:"auto,omitempty"`
}
type AzureSubnetChoiceWithAutoType_SubnetParam struct {
	SubnetParam *CloudSubnetParamType `protobuf:"bytes,3,opt,name=subnet_param,json=subnetParam,proto3,oneof" json:"subnet_param,omitempty"`
}
type AzureSubnetChoiceWithAutoType_Subnet struct {
	Subnet *AzureSpecialSubnetType `protobuf:"bytes,4,opt,name=subnet,proto3,oneof" json:"subnet,omitempty"`
}

func (*AzureSubnetChoiceWithAutoType_Auto) isAzureSubnetChoiceWithAutoType_Choice()        {}
func (*AzureSubnetChoiceWithAutoType_SubnetParam) isAzureSubnetChoiceWithAutoType_Choice() {}
func (*AzureSubnetChoiceWithAutoType_Subnet) isAzureSubnetChoiceWithAutoType_Choice()      {}

func (m *AzureSubnetChoiceWithAutoType) GetChoice() isAzureSubnetChoiceWithAutoType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *AzureSubnetChoiceWithAutoType) GetAuto() *schema.Empty {
	if x, ok := m.GetChoice().(*AzureSubnetChoiceWithAutoType_Auto); ok {
		return x.Auto
	}
	return nil
}

func (m *AzureSubnetChoiceWithAutoType) GetSubnetParam() *CloudSubnetParamType {
	if x, ok := m.GetChoice().(*AzureSubnetChoiceWithAutoType_SubnetParam); ok {
		return x.SubnetParam
	}
	return nil
}

func (m *AzureSubnetChoiceWithAutoType) GetSubnet() *AzureSpecialSubnetType {
	if x, ok := m.GetChoice().(*AzureSubnetChoiceWithAutoType_Subnet); ok {
		return x.Subnet
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AzureSubnetChoiceWithAutoType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AzureSubnetChoiceWithAutoType_Auto)(nil),
		(*AzureSubnetChoiceWithAutoType_SubnetParam)(nil),
		(*AzureSubnetChoiceWithAutoType_Subnet)(nil),
	}
}

// Single Interface Node
//
// x-displayName: "Single Interface Node"
// Parameters for creating Single interface Node in one AZ
type AzureVnetOneInterfaceNodeType struct {
	// Azure AZ
	//
	// x-displayName: "Azure AZ name"
	// x-required
	// x-example: "1"
	// Azure availability zone.
	AzureAz string `protobuf:"bytes,1,opt,name=azure_az,json=azureAz,proto3" json:"azure_az,omitempty"`
	// Subnet
	//
	// x-displayName: "Subnet for local Interface"
	// Subnets for the site local interface of the node
	LocalSubnet *AzureSubnetChoiceType `protobuf:"bytes,2,opt,name=local_subnet,json=localSubnet,proto3" json:"local_subnet,omitempty"`
	// Cloud Disk size
	//
	// x-displayName: "Cloud Disk Size"
	// x-example: "80"
	// Disk size to be used for this instance in GiB. 80 is 80 GiB
	DiskSize uint32 `protobuf:"varint,4,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
}

func (m *AzureVnetOneInterfaceNodeType) Reset()      { *m = AzureVnetOneInterfaceNodeType{} }
func (*AzureVnetOneInterfaceNodeType) ProtoMessage() {}
func (*AzureVnetOneInterfaceNodeType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{15}
}
func (m *AzureVnetOneInterfaceNodeType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureVnetOneInterfaceNodeType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureVnetOneInterfaceNodeType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureVnetOneInterfaceNodeType.Merge(m, src)
}
func (m *AzureVnetOneInterfaceNodeType) XXX_Size() int {
	return m.Size()
}
func (m *AzureVnetOneInterfaceNodeType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureVnetOneInterfaceNodeType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureVnetOneInterfaceNodeType proto.InternalMessageInfo

func (m *AzureVnetOneInterfaceNodeType) GetAzureAz() string {
	if m != nil {
		return m.AzureAz
	}
	return ""
}

func (m *AzureVnetOneInterfaceNodeType) GetLocalSubnet() *AzureSubnetChoiceType {
	if m != nil {
		return m.LocalSubnet
	}
	return nil
}

func (m *AzureVnetOneInterfaceNodeType) GetDiskSize() uint32 {
	if m != nil {
		return m.DiskSize
	}
	return 0
}

// Single Interface Node for Alternate Region
//
// x-displayName: "Single Interface Node for Alternate Region"
// Parameters for creating Single interface Node for Alternate Region
type AzureVnetOneInterfaceNodeARType struct {
	// Number of main nodes
	//
	// x-displayName: "Number of main nodes"
	// x-example: "1"
	// x-required
	// Number of main nodes to create, either 1 or 3.
	NodeNumber uint32 `protobuf:"varint,1,opt,name=node_number,json=nodeNumber,proto3" json:"node_number,omitempty"`
	// Subnet
	//
	// x-displayName: "Subnet for local Interface"
	// Subnets for the site local interface of the node
	LocalSubnet *AzureSubnetChoiceType `protobuf:"bytes,2,opt,name=local_subnet,json=localSubnet,proto3" json:"local_subnet,omitempty"`
	// Number of fault domains
	//
	// x-displayName: "Number of fault domains"
	// x-example: "1"
	// Namuber of fault domains to be used while creating the availability set
	FaultDomain uint32 `protobuf:"varint,3,opt,name=fault_domain,json=faultDomain,proto3" json:"fault_domain,omitempty"`
	// Number of update domains
	//
	// x-displayName: "Number of update domains"
	// x-example: "1"
	// Namuber of update domains to be used while creating the availability set
	UpdateDomain uint32 `protobuf:"varint,4,opt,name=update_domain,json=updateDomain,proto3" json:"update_domain,omitempty"`
}

func (m *AzureVnetOneInterfaceNodeARType) Reset()      { *m = AzureVnetOneInterfaceNodeARType{} }
func (*AzureVnetOneInterfaceNodeARType) ProtoMessage() {}
func (*AzureVnetOneInterfaceNodeARType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{16}
}
func (m *AzureVnetOneInterfaceNodeARType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureVnetOneInterfaceNodeARType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureVnetOneInterfaceNodeARType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureVnetOneInterfaceNodeARType.Merge(m, src)
}
func (m *AzureVnetOneInterfaceNodeARType) XXX_Size() int {
	return m.Size()
}
func (m *AzureVnetOneInterfaceNodeARType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureVnetOneInterfaceNodeARType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureVnetOneInterfaceNodeARType proto.InternalMessageInfo

func (m *AzureVnetOneInterfaceNodeARType) GetNodeNumber() uint32 {
	if m != nil {
		return m.NodeNumber
	}
	return 0
}

func (m *AzureVnetOneInterfaceNodeARType) GetLocalSubnet() *AzureSubnetChoiceType {
	if m != nil {
		return m.LocalSubnet
	}
	return nil
}

func (m *AzureVnetOneInterfaceNodeARType) GetFaultDomain() uint32 {
	if m != nil {
		return m.FaultDomain
	}
	return 0
}

func (m *AzureVnetOneInterfaceNodeARType) GetUpdateDomain() uint32 {
	if m != nil {
		return m.UpdateDomain
	}
	return 0
}

// Two Interface Node
//
// x-displayName: "Two Interface Node"
// Parameters for creating two interface Node in one AZ
type AzureVnetTwoInterfaceNodeType struct {
	// Azure AZ
	//
	// x-displayName: "Azure AZ Name"
	// x-required
	// x-example: "1"
	// Azure availability zone.
	AzureAz string `protobuf:"bytes,1,opt,name=azure_az,json=azureAz,proto3" json:"azure_az,omitempty"`
	// Subnet
	//
	// x-displayName: "Subnet for Inside Interface"
	// Subnets for the inside interface of the node
	InsideSubnet *AzureSubnetChoiceType `protobuf:"bytes,2,opt,name=inside_subnet,json=insideSubnet,proto3" json:"inside_subnet,omitempty"`
	// Subnet
	//
	// x-displayName: "Subnet for Outside Interface"
	// Subnets for the outside interface of the node
	OutsideSubnet *AzureSubnetChoiceType `protobuf:"bytes,3,opt,name=outside_subnet,json=outsideSubnet,proto3" json:"outside_subnet,omitempty"`
	// Cloud Disk size
	//
	// x-displayName: "Cloud Disk Size"
	// x-example: "80"
	// Disk size to be used for this instance in GiB. 80 is 80 GiB
	DiskSize uint32 `protobuf:"varint,5,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
}

func (m *AzureVnetTwoInterfaceNodeType) Reset()      { *m = AzureVnetTwoInterfaceNodeType{} }
func (*AzureVnetTwoInterfaceNodeType) ProtoMessage() {}
func (*AzureVnetTwoInterfaceNodeType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{17}
}
func (m *AzureVnetTwoInterfaceNodeType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureVnetTwoInterfaceNodeType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureVnetTwoInterfaceNodeType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureVnetTwoInterfaceNodeType.Merge(m, src)
}
func (m *AzureVnetTwoInterfaceNodeType) XXX_Size() int {
	return m.Size()
}
func (m *AzureVnetTwoInterfaceNodeType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureVnetTwoInterfaceNodeType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureVnetTwoInterfaceNodeType proto.InternalMessageInfo

func (m *AzureVnetTwoInterfaceNodeType) GetAzureAz() string {
	if m != nil {
		return m.AzureAz
	}
	return ""
}

func (m *AzureVnetTwoInterfaceNodeType) GetInsideSubnet() *AzureSubnetChoiceType {
	if m != nil {
		return m.InsideSubnet
	}
	return nil
}

func (m *AzureVnetTwoInterfaceNodeType) GetOutsideSubnet() *AzureSubnetChoiceType {
	if m != nil {
		return m.OutsideSubnet
	}
	return nil
}

func (m *AzureVnetTwoInterfaceNodeType) GetDiskSize() uint32 {
	if m != nil {
		return m.DiskSize
	}
	return 0
}

// Two Interface Node
//
// x-displayName: "Two Interface Node"
// Parameters for creating two interface Node in one AZ
type AzureVnetTwoInterfaceNodeARType struct {
	// Number of main nodes
	//
	// x-displayName: "Number of main nodes"
	// x-example: "1"
	// x-required
	// Number of main nodes to create, either 1 or 3.
	NodeNumber uint32 `protobuf:"varint,1,opt,name=node_number,json=nodeNumber,proto3" json:"node_number,omitempty"`
	// Subnet
	//
	// x-displayName: "Subnet for Inside Interface"
	// Subnets for the inside interface of the node
	InsideSubnet *AzureSubnetChoiceType `protobuf:"bytes,2,opt,name=inside_subnet,json=insideSubnet,proto3" json:"inside_subnet,omitempty"`
	// Subnet
	//
	// x-displayName: "Subnet for Outside Interface"
	// Subnets for the outside interface of the node
	OutsideSubnet *AzureSubnetChoiceType `protobuf:"bytes,3,opt,name=outside_subnet,json=outsideSubnet,proto3" json:"outside_subnet,omitempty"`
	// Number of fault domains
	//
	// x-displayName: "Number of fault domains"
	// x-example: "1"
	// Namuber of fault domains to be used while creating the availability set
	FaultDomain uint32 `protobuf:"varint,4,opt,name=fault_domain,json=faultDomain,proto3" json:"fault_domain,omitempty"`
	// Number of update domains
	//
	// x-displayName: "Number of update domains"
	// x-example: "1"
	// Namuber of update domains to be used while creating the availability set
	UpdateDomain uint32 `protobuf:"varint,5,opt,name=update_domain,json=updateDomain,proto3" json:"update_domain,omitempty"`
}

func (m *AzureVnetTwoInterfaceNodeARType) Reset()      { *m = AzureVnetTwoInterfaceNodeARType{} }
func (*AzureVnetTwoInterfaceNodeARType) ProtoMessage() {}
func (*AzureVnetTwoInterfaceNodeARType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{18}
}
func (m *AzureVnetTwoInterfaceNodeARType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureVnetTwoInterfaceNodeARType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureVnetTwoInterfaceNodeARType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureVnetTwoInterfaceNodeARType.Merge(m, src)
}
func (m *AzureVnetTwoInterfaceNodeARType) XXX_Size() int {
	return m.Size()
}
func (m *AzureVnetTwoInterfaceNodeARType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureVnetTwoInterfaceNodeARType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureVnetTwoInterfaceNodeARType proto.InternalMessageInfo

func (m *AzureVnetTwoInterfaceNodeARType) GetNodeNumber() uint32 {
	if m != nil {
		return m.NodeNumber
	}
	return 0
}

func (m *AzureVnetTwoInterfaceNodeARType) GetInsideSubnet() *AzureSubnetChoiceType {
	if m != nil {
		return m.InsideSubnet
	}
	return nil
}

func (m *AzureVnetTwoInterfaceNodeARType) GetOutsideSubnet() *AzureSubnetChoiceType {
	if m != nil {
		return m.OutsideSubnet
	}
	return nil
}

func (m *AzureVnetTwoInterfaceNodeARType) GetFaultDomain() uint32 {
	if m != nil {
		return m.FaultDomain
	}
	return 0
}

func (m *AzureVnetTwoInterfaceNodeARType) GetUpdateDomain() uint32 {
	if m != nil {
		return m.UpdateDomain
	}
	return 0
}

// GCP VPC Network Parameters
//
// x-displayName: "GCP VPC Network Manual Parameters"
// Parameters to create a new GCP VPC Network
type GCPVPCNetworkParamsType struct {
	// GCP VPC Network Name
	//
	// x-displayName: "GCP VPC Network Name"
	// x-required
	// x-example: "network1"
	// Name for your GCP VPC Network
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GCPVPCNetworkParamsType) Reset()      { *m = GCPVPCNetworkParamsType{} }
func (*GCPVPCNetworkParamsType) ProtoMessage() {}
func (*GCPVPCNetworkParamsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{19}
}
func (m *GCPVPCNetworkParamsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPVPCNetworkParamsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPVPCNetworkParamsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPVPCNetworkParamsType.Merge(m, src)
}
func (m *GCPVPCNetworkParamsType) XXX_Size() int {
	return m.Size()
}
func (m *GCPVPCNetworkParamsType) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPVPCNetworkParamsType.DiscardUnknown(m)
}

var xxx_messageInfo_GCPVPCNetworkParamsType proto.InternalMessageInfo

func (m *GCPVPCNetworkParamsType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// GCP VPC Network Parameters Autogenerate
//
// x-displayName: "GCP VPC Network Autogenerated Parameters"
// Create a new GCP VPC Network with autogenerated name
type GCPVPCNetworkAutogenerateParamsType struct {
	// Autogenerate GCP VPC Network Name
	//
	// x-displayName: "Autogenerate GCP VPC Network Name"
	// Name for your GCP VPC Network will be autogenerated
	Autogenerate bool `protobuf:"varint,1,opt,name=autogenerate,proto3" json:"autogenerate,omitempty"`
}

func (m *GCPVPCNetworkAutogenerateParamsType) Reset()      { *m = GCPVPCNetworkAutogenerateParamsType{} }
func (*GCPVPCNetworkAutogenerateParamsType) ProtoMessage() {}
func (*GCPVPCNetworkAutogenerateParamsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{20}
}
func (m *GCPVPCNetworkAutogenerateParamsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPVPCNetworkAutogenerateParamsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPVPCNetworkAutogenerateParamsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPVPCNetworkAutogenerateParamsType.Merge(m, src)
}
func (m *GCPVPCNetworkAutogenerateParamsType) XXX_Size() int {
	return m.Size()
}
func (m *GCPVPCNetworkAutogenerateParamsType) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPVPCNetworkAutogenerateParamsType.DiscardUnknown(m)
}

var xxx_messageInfo_GCPVPCNetworkAutogenerateParamsType proto.InternalMessageInfo

func (m *GCPVPCNetworkAutogenerateParamsType) GetAutogenerate() bool {
	if m != nil {
		return m.Autogenerate
	}
	return false
}

// GCP existing VPC network Type
//
// x-displayName: "GCP existing VPC network Type"
// Name of existing VPC network
type GCPVPCNetworkType struct {
	// GCP VPC Network Name
	//
	// x-displayName: "GCP VPC Network Name"
	// x-required
	// x-example: "network1"
	// Name for your GCP VPC Network
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GCPVPCNetworkType) Reset()      { *m = GCPVPCNetworkType{} }
func (*GCPVPCNetworkType) ProtoMessage() {}
func (*GCPVPCNetworkType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{21}
}
func (m *GCPVPCNetworkType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPVPCNetworkType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPVPCNetworkType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPVPCNetworkType.Merge(m, src)
}
func (m *GCPVPCNetworkType) XXX_Size() int {
	return m.Size()
}
func (m *GCPVPCNetworkType) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPVPCNetworkType.DiscardUnknown(m)
}

var xxx_messageInfo_GCPVPCNetworkType proto.InternalMessageInfo

func (m *GCPVPCNetworkType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// GCP existing subnet Type
//
// x-displayName: "GCP existing subnet Type"
// Name of existing gcp subnet
type GCPSubnetType struct {
	// GCP VPC Subnet Name
	//
	// x-displayName: "VPC Subnet Name"
	// x-required
	// x-example: "subnet1-in-network1"
	// Name of your subnet in VPC network
	SubnetName string `protobuf:"bytes,1,opt,name=subnet_name,json=subnetName,proto3" json:"subnet_name,omitempty"`
}

func (m *GCPSubnetType) Reset()      { *m = GCPSubnetType{} }
func (*GCPSubnetType) ProtoMessage() {}
func (*GCPSubnetType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{22}
}
func (m *GCPSubnetType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPSubnetType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPSubnetType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPSubnetType.Merge(m, src)
}
func (m *GCPSubnetType) XXX_Size() int {
	return m.Size()
}
func (m *GCPSubnetType) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPSubnetType.DiscardUnknown(m)
}

var xxx_messageInfo_GCPSubnetType proto.InternalMessageInfo

func (m *GCPSubnetType) GetSubnetName() string {
	if m != nil {
		return m.SubnetName
	}
	return ""
}

// GCP subnet parameters Type
//
// x-displayName: "GCP subnet parameters Type"
// Parameters for gcp subnet
type GCPSubnetParamsType struct {
	// GCP VPC Subnet Name
	//
	// x-displayName: "VPC Subnet Name"
	// x-example: "subnet1-in-network1"
	// Name of new VPC Subnet, will be autogenerated if empty
	SubnetName string `protobuf:"bytes,1,opt,name=subnet_name,json=subnetName,proto3" json:"subnet_name,omitempty"`
	// IPv4 CIDR block
	//
	// x-displayName: "IPv4 Subnet Prefix"
	// x-required
	// x-example: "10.1.0.0/16"
	// IPv4 prefix for this Subnet. It has to be private address space.
	PrimaryIpv4 string `protobuf:"bytes,2,opt,name=primary_ipv4,json=primaryIpv4,proto3" json:"primary_ipv4,omitempty"`
}

func (m *GCPSubnetParamsType) Reset()      { *m = GCPSubnetParamsType{} }
func (*GCPSubnetParamsType) ProtoMessage() {}
func (*GCPSubnetParamsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{23}
}
func (m *GCPSubnetParamsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPSubnetParamsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPSubnetParamsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPSubnetParamsType.Merge(m, src)
}
func (m *GCPSubnetParamsType) XXX_Size() int {
	return m.Size()
}
func (m *GCPSubnetParamsType) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPSubnetParamsType.DiscardUnknown(m)
}

var xxx_messageInfo_GCPSubnetParamsType proto.InternalMessageInfo

func (m *GCPSubnetParamsType) GetSubnetName() string {
	if m != nil {
		return m.SubnetName
	}
	return ""
}

func (m *GCPSubnetParamsType) GetPrimaryIpv4() string {
	if m != nil {
		return m.PrimaryIpv4
	}
	return ""
}

// GCP VPC network choice
//
// x-displayName: "GCP VPC network choice"
// This defines choice about GCP VPC network for a view
type GCPVPCNetworkChoiceType struct {
	// Choice of existing or new VPC network
	//
	// x-displayName: "Select existing VPC network or create new VPC network"
	// x-required
	// Create a new VPC Network or select an existing one.
	//
	// Types that are valid to be assigned to Choice:
	//	*GCPVPCNetworkChoiceType_NewNetworkAutogenerate
	//	*GCPVPCNetworkChoiceType_NewNetwork
	//	*GCPVPCNetworkChoiceType_ExistingNetwork
	Choice isGCPVPCNetworkChoiceType_Choice `protobuf_oneof:"choice"`
}

func (m *GCPVPCNetworkChoiceType) Reset()      { *m = GCPVPCNetworkChoiceType{} }
func (*GCPVPCNetworkChoiceType) ProtoMessage() {}
func (*GCPVPCNetworkChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{24}
}
func (m *GCPVPCNetworkChoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPVPCNetworkChoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPVPCNetworkChoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPVPCNetworkChoiceType.Merge(m, src)
}
func (m *GCPVPCNetworkChoiceType) XXX_Size() int {
	return m.Size()
}
func (m *GCPVPCNetworkChoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPVPCNetworkChoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_GCPVPCNetworkChoiceType proto.InternalMessageInfo

type isGCPVPCNetworkChoiceType_Choice interface {
	isGCPVPCNetworkChoiceType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GCPVPCNetworkChoiceType_NewNetworkAutogenerate struct {
	NewNetworkAutogenerate *GCPVPCNetworkAutogenerateParamsType `protobuf:"bytes,4,opt,name=new_network_autogenerate,json=newNetworkAutogenerate,proto3,oneof" json:"new_network_autogenerate,omitempty"`
}
type GCPVPCNetworkChoiceType_NewNetwork struct {
	NewNetwork *GCPVPCNetworkParamsType `protobuf:"bytes,2,opt,name=new_network,json=newNetwork,proto3,oneof" json:"new_network,omitempty"`
}
type GCPVPCNetworkChoiceType_ExistingNetwork struct {
	ExistingNetwork *GCPVPCNetworkType `protobuf:"bytes,3,opt,name=existing_network,json=existingNetwork,proto3,oneof" json:"existing_network,omitempty"`
}

func (*GCPVPCNetworkChoiceType_NewNetworkAutogenerate) isGCPVPCNetworkChoiceType_Choice() {}
func (*GCPVPCNetworkChoiceType_NewNetwork) isGCPVPCNetworkChoiceType_Choice()             {}
func (*GCPVPCNetworkChoiceType_ExistingNetwork) isGCPVPCNetworkChoiceType_Choice()        {}

func (m *GCPVPCNetworkChoiceType) GetChoice() isGCPVPCNetworkChoiceType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *GCPVPCNetworkChoiceType) GetNewNetworkAutogenerate() *GCPVPCNetworkAutogenerateParamsType {
	if x, ok := m.GetChoice().(*GCPVPCNetworkChoiceType_NewNetworkAutogenerate); ok {
		return x.NewNetworkAutogenerate
	}
	return nil
}

func (m *GCPVPCNetworkChoiceType) GetNewNetwork() *GCPVPCNetworkParamsType {
	if x, ok := m.GetChoice().(*GCPVPCNetworkChoiceType_NewNetwork); ok {
		return x.NewNetwork
	}
	return nil
}

func (m *GCPVPCNetworkChoiceType) GetExistingNetwork() *GCPVPCNetworkType {
	if x, ok := m.GetChoice().(*GCPVPCNetworkChoiceType_ExistingNetwork); ok {
		return x.ExistingNetwork
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GCPVPCNetworkChoiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GCPVPCNetworkChoiceType_NewNetworkAutogenerate)(nil),
		(*GCPVPCNetworkChoiceType_NewNetwork)(nil),
		(*GCPVPCNetworkChoiceType_ExistingNetwork)(nil),
	}
}

// GCP VPC network choice
//
// x-displayName: "GCP VPC network choice"
// This defines choice about GCP VPC network for a view
type GCPVPCSubnetChoiceType struct {
	// Choice of existing or new subnet
	//
	// x-displayName: "Select existing subnet or create new subnet"
	// x-required
	// Create a new VPC Subnet or select an existing one.
	//
	// Types that are valid to be assigned to Choice:
	//	*GCPVPCSubnetChoiceType_NewSubnet
	//	*GCPVPCSubnetChoiceType_ExistingSubnet
	Choice isGCPVPCSubnetChoiceType_Choice `protobuf_oneof:"choice"`
}

func (m *GCPVPCSubnetChoiceType) Reset()      { *m = GCPVPCSubnetChoiceType{} }
func (*GCPVPCSubnetChoiceType) ProtoMessage() {}
func (*GCPVPCSubnetChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{25}
}
func (m *GCPVPCSubnetChoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GCPVPCSubnetChoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GCPVPCSubnetChoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCPVPCSubnetChoiceType.Merge(m, src)
}
func (m *GCPVPCSubnetChoiceType) XXX_Size() int {
	return m.Size()
}
func (m *GCPVPCSubnetChoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_GCPVPCSubnetChoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_GCPVPCSubnetChoiceType proto.InternalMessageInfo

type isGCPVPCSubnetChoiceType_Choice interface {
	isGCPVPCSubnetChoiceType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GCPVPCSubnetChoiceType_NewSubnet struct {
	NewSubnet *GCPSubnetParamsType `protobuf:"bytes,2,opt,name=new_subnet,json=newSubnet,proto3,oneof" json:"new_subnet,omitempty"`
}
type GCPVPCSubnetChoiceType_ExistingSubnet struct {
	ExistingSubnet *GCPSubnetType `protobuf:"bytes,3,opt,name=existing_subnet,json=existingSubnet,proto3,oneof" json:"existing_subnet,omitempty"`
}

func (*GCPVPCSubnetChoiceType_NewSubnet) isGCPVPCSubnetChoiceType_Choice()      {}
func (*GCPVPCSubnetChoiceType_ExistingSubnet) isGCPVPCSubnetChoiceType_Choice() {}

func (m *GCPVPCSubnetChoiceType) GetChoice() isGCPVPCSubnetChoiceType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *GCPVPCSubnetChoiceType) GetNewSubnet() *GCPSubnetParamsType {
	if x, ok := m.GetChoice().(*GCPVPCSubnetChoiceType_NewSubnet); ok {
		return x.NewSubnet
	}
	return nil
}

func (m *GCPVPCSubnetChoiceType) GetExistingSubnet() *GCPSubnetType {
	if x, ok := m.GetChoice().(*GCPVPCSubnetChoiceType_ExistingSubnet); ok {
		return x.ExistingSubnet
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GCPVPCSubnetChoiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GCPVPCSubnetChoiceType_NewSubnet)(nil),
		(*GCPVPCSubnetChoiceType_ExistingSubnet)(nil),
	}
}

// Site Static Route Config Modes
//
// x-displayName: "Site Static Route Config Modes"
// Different ways to configure static routes
type SiteStaticRoutesType struct {
	// Static Route Config Mode
	//
	// x-displayName: "Static Route Config Mode"
	// x-required
	// Select method for configuring the route
	//
	// Types that are valid to be assigned to ConfigModeChoice:
	//	*SiteStaticRoutesType_SimpleStaticRoute
	//	*SiteStaticRoutesType_CustomStaticRoute
	ConfigModeChoice isSiteStaticRoutesType_ConfigModeChoice `protobuf_oneof:"config_mode_choice"`
}

func (m *SiteStaticRoutesType) Reset()      { *m = SiteStaticRoutesType{} }
func (*SiteStaticRoutesType) ProtoMessage() {}
func (*SiteStaticRoutesType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{26}
}
func (m *SiteStaticRoutesType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SiteStaticRoutesType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SiteStaticRoutesType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SiteStaticRoutesType.Merge(m, src)
}
func (m *SiteStaticRoutesType) XXX_Size() int {
	return m.Size()
}
func (m *SiteStaticRoutesType) XXX_DiscardUnknown() {
	xxx_messageInfo_SiteStaticRoutesType.DiscardUnknown(m)
}

var xxx_messageInfo_SiteStaticRoutesType proto.InternalMessageInfo

type isSiteStaticRoutesType_ConfigModeChoice interface {
	isSiteStaticRoutesType_ConfigModeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SiteStaticRoutesType_SimpleStaticRoute struct {
	SimpleStaticRoute string `protobuf:"bytes,2,opt,name=simple_static_route,json=simpleStaticRoute,proto3,oneof" json:"simple_static_route,omitempty"`
}
type SiteStaticRoutesType_CustomStaticRoute struct {
	CustomStaticRoute *schema.StaticRouteType `protobuf:"bytes,3,opt,name=custom_static_route,json=customStaticRoute,proto3,oneof" json:"custom_static_route,omitempty"`
}

func (*SiteStaticRoutesType_SimpleStaticRoute) isSiteStaticRoutesType_ConfigModeChoice() {}
func (*SiteStaticRoutesType_CustomStaticRoute) isSiteStaticRoutesType_ConfigModeChoice() {}

func (m *SiteStaticRoutesType) GetConfigModeChoice() isSiteStaticRoutesType_ConfigModeChoice {
	if m != nil {
		return m.ConfigModeChoice
	}
	return nil
}

func (m *SiteStaticRoutesType) GetSimpleStaticRoute() string {
	if x, ok := m.GetConfigModeChoice().(*SiteStaticRoutesType_SimpleStaticRoute); ok {
		return x.SimpleStaticRoute
	}
	return ""
}

func (m *SiteStaticRoutesType) GetCustomStaticRoute() *schema.StaticRouteType {
	if x, ok := m.GetConfigModeChoice().(*SiteStaticRoutesType_CustomStaticRoute); ok {
		return x.CustomStaticRoute
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SiteStaticRoutesType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SiteStaticRoutesType_SimpleStaticRoute)(nil),
		(*SiteStaticRoutesType_CustomStaticRoute)(nil),
	}
}

// Static Route List Type
//
// x-displayName: "Static Route List Type"
// List of static routes
type SiteStaticRoutesListType struct {
	// List of Static Routes
	//
	// x-displayName: "List of Static Routes"
	// x-required
	// List of Static routes
	StaticRouteList []*SiteStaticRoutesType `protobuf:"bytes,1,rep,name=static_route_list,json=staticRouteList,proto3" json:"static_route_list,omitempty"`
}

func (m *SiteStaticRoutesListType) Reset()      { *m = SiteStaticRoutesListType{} }
func (*SiteStaticRoutesListType) ProtoMessage() {}
func (*SiteStaticRoutesListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{27}
}
func (m *SiteStaticRoutesListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SiteStaticRoutesListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SiteStaticRoutesListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SiteStaticRoutesListType.Merge(m, src)
}
func (m *SiteStaticRoutesListType) XXX_Size() int {
	return m.Size()
}
func (m *SiteStaticRoutesListType) XXX_DiscardUnknown() {
	xxx_messageInfo_SiteStaticRoutesListType.DiscardUnknown(m)
}

var xxx_messageInfo_SiteStaticRoutesListType proto.InternalMessageInfo

func (m *SiteStaticRoutesListType) GetStaticRouteList() []*SiteStaticRoutesType {
	if m != nil {
		return m.StaticRouteList
	}
	return nil
}

// Global Network Connection
//
// x-displayName: "Global Network Connection"
// Global network connection
type GlobalNetworkConnectionType struct {
	// Connector Choice
	//
	// x-displayName: "Select Network Connection Type"
	// x-required
	// Select the networks and method in which they are connected.
	//
	// Types that are valid to be assigned to ConnectionChoice:
	//	*GlobalNetworkConnectionType_SliToGlobalDr
	//	*GlobalNetworkConnectionType_SloToGlobalDr
	ConnectionChoice isGlobalNetworkConnectionType_ConnectionChoice `protobuf_oneof:"connection_choice"`
	// Select Forward Proxy
	//
	// x-displayName: "Select Forward Proxy"
	// Select to enable forward proxy
	//
	// Types that are valid to be assigned to ForwardProxyChoice:
	//	*GlobalNetworkConnectionType_DisableForwardProxy
	//	*GlobalNetworkConnectionType_EnableForwardProxy
	ForwardProxyChoice isGlobalNetworkConnectionType_ForwardProxyChoice `protobuf_oneof:"forward_proxy_choice"`
}

func (m *GlobalNetworkConnectionType) Reset()      { *m = GlobalNetworkConnectionType{} }
func (*GlobalNetworkConnectionType) ProtoMessage() {}
func (*GlobalNetworkConnectionType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{28}
}
func (m *GlobalNetworkConnectionType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalNetworkConnectionType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalNetworkConnectionType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalNetworkConnectionType.Merge(m, src)
}
func (m *GlobalNetworkConnectionType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalNetworkConnectionType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalNetworkConnectionType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalNetworkConnectionType proto.InternalMessageInfo

type isGlobalNetworkConnectionType_ConnectionChoice interface {
	isGlobalNetworkConnectionType_ConnectionChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalNetworkConnectionType_ForwardProxyChoice interface {
	isGlobalNetworkConnectionType_ForwardProxyChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalNetworkConnectionType_SliToGlobalDr struct {
	SliToGlobalDr *GlobalConnectorType `protobuf:"bytes,2,opt,name=sli_to_global_dr,json=sliToGlobalDr,proto3,oneof" json:"sli_to_global_dr,omitempty"`
}
type GlobalNetworkConnectionType_SloToGlobalDr struct {
	SloToGlobalDr *GlobalConnectorType `protobuf:"bytes,3,opt,name=slo_to_global_dr,json=sloToGlobalDr,proto3,oneof" json:"slo_to_global_dr,omitempty"`
}
type GlobalNetworkConnectionType_DisableForwardProxy struct {
	DisableForwardProxy *schema.Empty `protobuf:"bytes,5,opt,name=disable_forward_proxy,json=disableForwardProxy,proto3,oneof" json:"disable_forward_proxy,omitempty"`
}
type GlobalNetworkConnectionType_EnableForwardProxy struct {
	EnableForwardProxy *schema.ForwardProxyConfigType `protobuf:"bytes,6,opt,name=enable_forward_proxy,json=enableForwardProxy,proto3,oneof" json:"enable_forward_proxy,omitempty"`
}

func (*GlobalNetworkConnectionType_SliToGlobalDr) isGlobalNetworkConnectionType_ConnectionChoice() {}
func (*GlobalNetworkConnectionType_SloToGlobalDr) isGlobalNetworkConnectionType_ConnectionChoice() {}
func (*GlobalNetworkConnectionType_DisableForwardProxy) isGlobalNetworkConnectionType_ForwardProxyChoice() {
}
func (*GlobalNetworkConnectionType_EnableForwardProxy) isGlobalNetworkConnectionType_ForwardProxyChoice() {
}

func (m *GlobalNetworkConnectionType) GetConnectionChoice() isGlobalNetworkConnectionType_ConnectionChoice {
	if m != nil {
		return m.ConnectionChoice
	}
	return nil
}
func (m *GlobalNetworkConnectionType) GetForwardProxyChoice() isGlobalNetworkConnectionType_ForwardProxyChoice {
	if m != nil {
		return m.ForwardProxyChoice
	}
	return nil
}

func (m *GlobalNetworkConnectionType) GetSliToGlobalDr() *GlobalConnectorType {
	if x, ok := m.GetConnectionChoice().(*GlobalNetworkConnectionType_SliToGlobalDr); ok {
		return x.SliToGlobalDr
	}
	return nil
}

func (m *GlobalNetworkConnectionType) GetSloToGlobalDr() *GlobalConnectorType {
	if x, ok := m.GetConnectionChoice().(*GlobalNetworkConnectionType_SloToGlobalDr); ok {
		return x.SloToGlobalDr
	}
	return nil
}

func (m *GlobalNetworkConnectionType) GetDisableForwardProxy() *schema.Empty {
	if x, ok := m.GetForwardProxyChoice().(*GlobalNetworkConnectionType_DisableForwardProxy); ok {
		return x.DisableForwardProxy
	}
	return nil
}

func (m *GlobalNetworkConnectionType) GetEnableForwardProxy() *schema.ForwardProxyConfigType {
	if x, ok := m.GetForwardProxyChoice().(*GlobalNetworkConnectionType_EnableForwardProxy); ok {
		return x.EnableForwardProxy
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalNetworkConnectionType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalNetworkConnectionType_SliToGlobalDr)(nil),
		(*GlobalNetworkConnectionType_SloToGlobalDr)(nil),
		(*GlobalNetworkConnectionType_DisableForwardProxy)(nil),
		(*GlobalNetworkConnectionType_EnableForwardProxy)(nil),
	}
}

// Global Network Connection List
//
// x-displayName: "Global Network Connection List"
// List of global network connections
type GlobalNetworkConnectionListType struct {
	// Global Network Connections
	//
	// x-displayName: "Global Network Connections"
	// x-required
	// Global network connections
	GlobalNetworkConnections []*GlobalNetworkConnectionType `protobuf:"bytes,1,rep,name=global_network_connections,json=globalNetworkConnections,proto3" json:"global_network_connections,omitempty"`
}

func (m *GlobalNetworkConnectionListType) Reset()      { *m = GlobalNetworkConnectionListType{} }
func (*GlobalNetworkConnectionListType) ProtoMessage() {}
func (*GlobalNetworkConnectionListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{29}
}
func (m *GlobalNetworkConnectionListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalNetworkConnectionListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalNetworkConnectionListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalNetworkConnectionListType.Merge(m, src)
}
func (m *GlobalNetworkConnectionListType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalNetworkConnectionListType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalNetworkConnectionListType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalNetworkConnectionListType proto.InternalMessageInfo

func (m *GlobalNetworkConnectionListType) GetGlobalNetworkConnections() []*GlobalNetworkConnectionType {
	if m != nil {
		return m.GlobalNetworkConnections
	}
	return nil
}

// Allowed VIP Ports
//
// x-displayName: "Allowed VIP Ports"
// This defines the TCP port(s) which will be opened on the cloud loadbalancer.
// Such that the client can use the cloud VIP IP and port combination
// to reach TCP/HTTP lb configured on the F5XC Site
type AllowedVIPPorts struct {
	// VIP Port Choice
	//
	// x-displayName: "Select Which Ports will be Allowed"
	// This defines various port which can be used to connect to the http/tcp loadbalancer using the VIP
	//
	// Types that are valid to be assigned to PortChoice:
	//	*AllowedVIPPorts_DisableAllowedVipPort
	//	*AllowedVIPPorts_UseHttpPort
	//	*AllowedVIPPorts_UseHttpsPort
	//	*AllowedVIPPorts_UseHttpHttpsPort
	//	*AllowedVIPPorts_CustomPorts
	PortChoice isAllowedVIPPorts_PortChoice `protobuf_oneof:"port_choice"`
}

func (m *AllowedVIPPorts) Reset()      { *m = AllowedVIPPorts{} }
func (*AllowedVIPPorts) ProtoMessage() {}
func (*AllowedVIPPorts) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{30}
}
func (m *AllowedVIPPorts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllowedVIPPorts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AllowedVIPPorts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllowedVIPPorts.Merge(m, src)
}
func (m *AllowedVIPPorts) XXX_Size() int {
	return m.Size()
}
func (m *AllowedVIPPorts) XXX_DiscardUnknown() {
	xxx_messageInfo_AllowedVIPPorts.DiscardUnknown(m)
}

var xxx_messageInfo_AllowedVIPPorts proto.InternalMessageInfo

type isAllowedVIPPorts_PortChoice interface {
	isAllowedVIPPorts_PortChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AllowedVIPPorts_DisableAllowedVipPort struct {
	DisableAllowedVipPort *schema.Empty `protobuf:"bytes,6,opt,name=disable_allowed_vip_port,json=disableAllowedVipPort,proto3,oneof" json:"disable_allowed_vip_port,omitempty"`
}
type AllowedVIPPorts_UseHttpPort struct {
	UseHttpPort *schema.Empty `protobuf:"bytes,2,opt,name=use_http_port,json=useHttpPort,proto3,oneof" json:"use_http_port,omitempty"`
}
type AllowedVIPPorts_UseHttpsPort struct {
	UseHttpsPort *schema.Empty `protobuf:"bytes,3,opt,name=use_https_port,json=useHttpsPort,proto3,oneof" json:"use_https_port,omitempty"`
}
type AllowedVIPPorts_UseHttpHttpsPort struct {
	UseHttpHttpsPort *schema.Empty `protobuf:"bytes,4,opt,name=use_http_https_port,json=useHttpHttpsPort,proto3,oneof" json:"use_http_https_port,omitempty"`
}
type AllowedVIPPorts_CustomPorts struct {
	CustomPorts *CustomPorts `protobuf:"bytes,5,opt,name=custom_ports,json=customPorts,proto3,oneof" json:"custom_ports,omitempty"`
}

func (*AllowedVIPPorts_DisableAllowedVipPort) isAllowedVIPPorts_PortChoice() {}
func (*AllowedVIPPorts_UseHttpPort) isAllowedVIPPorts_PortChoice()           {}
func (*AllowedVIPPorts_UseHttpsPort) isAllowedVIPPorts_PortChoice()          {}
func (*AllowedVIPPorts_UseHttpHttpsPort) isAllowedVIPPorts_PortChoice()      {}
func (*AllowedVIPPorts_CustomPorts) isAllowedVIPPorts_PortChoice()           {}

func (m *AllowedVIPPorts) GetPortChoice() isAllowedVIPPorts_PortChoice {
	if m != nil {
		return m.PortChoice
	}
	return nil
}

func (m *AllowedVIPPorts) GetDisableAllowedVipPort() *schema.Empty {
	if x, ok := m.GetPortChoice().(*AllowedVIPPorts_DisableAllowedVipPort); ok {
		return x.DisableAllowedVipPort
	}
	return nil
}

func (m *AllowedVIPPorts) GetUseHttpPort() *schema.Empty {
	if x, ok := m.GetPortChoice().(*AllowedVIPPorts_UseHttpPort); ok {
		return x.UseHttpPort
	}
	return nil
}

func (m *AllowedVIPPorts) GetUseHttpsPort() *schema.Empty {
	if x, ok := m.GetPortChoice().(*AllowedVIPPorts_UseHttpsPort); ok {
		return x.UseHttpsPort
	}
	return nil
}

func (m *AllowedVIPPorts) GetUseHttpHttpsPort() *schema.Empty {
	if x, ok := m.GetPortChoice().(*AllowedVIPPorts_UseHttpHttpsPort); ok {
		return x.UseHttpHttpsPort
	}
	return nil
}

func (m *AllowedVIPPorts) GetCustomPorts() *CustomPorts {
	if x, ok := m.GetPortChoice().(*AllowedVIPPorts_CustomPorts); ok {
		return x.CustomPorts
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AllowedVIPPorts) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AllowedVIPPorts_DisableAllowedVipPort)(nil),
		(*AllowedVIPPorts_UseHttpPort)(nil),
		(*AllowedVIPPorts_UseHttpsPort)(nil),
		(*AllowedVIPPorts_UseHttpHttpsPort)(nil),
		(*AllowedVIPPorts_CustomPorts)(nil),
	}
}

// Custom Ports
//
// x-displayName: "Custom Ports"
// List of Custom port
type CustomPorts struct {
	// Port Ranges
	//
	// x-displayName: "Port Ranges"
	// x-required
	// x-example: "80, 8080-8085"
	// Port Ranges
	PortRanges string `protobuf:"bytes,2,opt,name=port_ranges,json=portRanges,proto3" json:"port_ranges,omitempty"`
}

func (m *CustomPorts) Reset()      { *m = CustomPorts{} }
func (*CustomPorts) ProtoMessage() {}
func (*CustomPorts) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{31}
}
func (m *CustomPorts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CustomPorts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CustomPorts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CustomPorts.Merge(m, src)
}
func (m *CustomPorts) XXX_Size() int {
	return m.Size()
}
func (m *CustomPorts) XXX_DiscardUnknown() {
	xxx_messageInfo_CustomPorts.DiscardUnknown(m)
}

var xxx_messageInfo_CustomPorts proto.InternalMessageInfo

func (m *CustomPorts) GetPortRanges() string {
	if m != nil {
		return m.PortRanges
	}
	return ""
}

// Offline Survivability Mode
//
// x-displayName: "Offline Survivability Mode"
// Offline Survivability Mode
type OfflineSurvivabilityModeType struct {
	// offline_survivability_mode_choice
	//
	// x-displayName: "Offline Survivability Mode"
	// x-required
	// Enable/Disable offline survivability mode.
	// When this feature is enabled/disabled on an existing site, the pods/services on this site will be restarted.
	//
	// Types that are valid to be assigned to OfflineSurvivabilityModeChoice:
	//	*OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode
	//	*OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode
	OfflineSurvivabilityModeChoice isOfflineSurvivabilityModeType_OfflineSurvivabilityModeChoice `protobuf_oneof:"offline_survivability_mode_choice"`
}

func (m *OfflineSurvivabilityModeType) Reset()      { *m = OfflineSurvivabilityModeType{} }
func (*OfflineSurvivabilityModeType) ProtoMessage() {}
func (*OfflineSurvivabilityModeType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{32}
}
func (m *OfflineSurvivabilityModeType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OfflineSurvivabilityModeType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OfflineSurvivabilityModeType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OfflineSurvivabilityModeType.Merge(m, src)
}
func (m *OfflineSurvivabilityModeType) XXX_Size() int {
	return m.Size()
}
func (m *OfflineSurvivabilityModeType) XXX_DiscardUnknown() {
	xxx_messageInfo_OfflineSurvivabilityModeType.DiscardUnknown(m)
}

var xxx_messageInfo_OfflineSurvivabilityModeType proto.InternalMessageInfo

type isOfflineSurvivabilityModeType_OfflineSurvivabilityModeChoice interface {
	isOfflineSurvivabilityModeType_OfflineSurvivabilityModeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode struct {
	NoOfflineSurvivabilityMode *schema.Empty `protobuf:"bytes,2,opt,name=no_offline_survivability_mode,json=noOfflineSurvivabilityMode,proto3,oneof" json:"no_offline_survivability_mode,omitempty"`
}
type OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode struct {
	EnableOfflineSurvivabilityMode *schema.Empty `protobuf:"bytes,3,opt,name=enable_offline_survivability_mode,json=enableOfflineSurvivabilityMode,proto3,oneof" json:"enable_offline_survivability_mode,omitempty"`
}

func (*OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode) isOfflineSurvivabilityModeType_OfflineSurvivabilityModeChoice() {
}
func (*OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode) isOfflineSurvivabilityModeType_OfflineSurvivabilityModeChoice() {
}

func (m *OfflineSurvivabilityModeType) GetOfflineSurvivabilityModeChoice() isOfflineSurvivabilityModeType_OfflineSurvivabilityModeChoice {
	if m != nil {
		return m.OfflineSurvivabilityModeChoice
	}
	return nil
}

func (m *OfflineSurvivabilityModeType) GetNoOfflineSurvivabilityMode() *schema.Empty {
	if x, ok := m.GetOfflineSurvivabilityModeChoice().(*OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode); ok {
		return x.NoOfflineSurvivabilityMode
	}
	return nil
}

func (m *OfflineSurvivabilityModeType) GetEnableOfflineSurvivabilityMode() *schema.Empty {
	if x, ok := m.GetOfflineSurvivabilityModeChoice().(*OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode); ok {
		return x.EnableOfflineSurvivabilityMode
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*OfflineSurvivabilityModeType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode)(nil),
		(*OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode)(nil),
	}
}

// BGPPeerType
//
// x-displayName: "BGP Peer Config"
// BGP Peer Config
type DCGWBGPPeerType struct {
	// Amazon Address
	//
	// x-displayName: "Amazon Address"
	// x-example: ""
	// x-required
	// The IP address assigned to the Amazon interface
	AmazonAddress string `protobuf:"bytes,1,opt,name=amazon_address,json=amazonAddress,proto3" json:"amazon_address,omitempty"`
	// Customer Address
	//
	// x-displayName: "Customer Address"
	// x-example: ""
	// x-required
	// The IP address assigned to the customer interface
	CustomerAddress string `protobuf:"bytes,2,opt,name=customer_address,json=customerAddress,proto3" json:"customer_address,omitempty"`
	// ASN
	//
	// x-displayName: "ASN"
	// x-example: ""
	// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration
	Asn uint32 `protobuf:"varint,3,opt,name=asn,proto3" json:"asn,omitempty"`
	// Auth Key
	//
	// x-displayName: "Auth Key"
	// x-example: ""
	// x-required
	// The authentication key for BGP configuration.
	// This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
	AuthKey *schema.SecretType `protobuf:"bytes,4,opt,name=auth_key,json=authKey,proto3" json:"auth_key,omitempty"`
}

func (m *DCGWBGPPeerType) Reset()      { *m = DCGWBGPPeerType{} }
func (*DCGWBGPPeerType) ProtoMessage() {}
func (*DCGWBGPPeerType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{33}
}
func (m *DCGWBGPPeerType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DCGWBGPPeerType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DCGWBGPPeerType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DCGWBGPPeerType.Merge(m, src)
}
func (m *DCGWBGPPeerType) XXX_Size() int {
	return m.Size()
}
func (m *DCGWBGPPeerType) XXX_DiscardUnknown() {
	xxx_messageInfo_DCGWBGPPeerType.DiscardUnknown(m)
}

var xxx_messageInfo_DCGWBGPPeerType proto.InternalMessageInfo

func (m *DCGWBGPPeerType) GetAmazonAddress() string {
	if m != nil {
		return m.AmazonAddress
	}
	return ""
}

func (m *DCGWBGPPeerType) GetCustomerAddress() string {
	if m != nil {
		return m.CustomerAddress
	}
	return ""
}

func (m *DCGWBGPPeerType) GetAsn() uint32 {
	if m != nil {
		return m.Asn
	}
	return 0
}

func (m *DCGWBGPPeerType) GetAuthKey() *schema.SecretType {
	if m != nil {
		return m.AuthKey
	}
	return nil
}

// HostedVIFRegionObject
//
// x-displayName: "Hosted VIF Config Per Region Object"
// x-example: "value"
// AWS Direct Connect Hosted VIF Config Per Region Object
type VifRegionConfig struct {
	// Region of the VIF
	//
	// x-displayName: "Region of the VIF"
	// x-required
	// Region of the VIF
	//
	// Types that are valid to be assigned to VifRegionChoice:
	//	*VifRegionConfig_SameAsSiteRegion
	//	*VifRegionConfig_OtherRegion
	VifRegionChoice isVifRegionConfig_VifRegionChoice `protobuf_oneof:"vif_region_choice"`
	// VIF ID
	//
	// x-displayName: "VIF ID"
	// x-example: "dxvif-fgwtckim"
	// x-required
	// AWS Direct Connect VIF ID that needs to be connected to the site
	VifId string `protobuf:"bytes,5,opt,name=vif_id,json=vifId,proto3" json:"vif_id,omitempty"`
}

func (m *VifRegionConfig) Reset()      { *m = VifRegionConfig{} }
func (*VifRegionConfig) ProtoMessage() {}
func (*VifRegionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{34}
}
func (m *VifRegionConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VifRegionConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VifRegionConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VifRegionConfig.Merge(m, src)
}
func (m *VifRegionConfig) XXX_Size() int {
	return m.Size()
}
func (m *VifRegionConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_VifRegionConfig.DiscardUnknown(m)
}

var xxx_messageInfo_VifRegionConfig proto.InternalMessageInfo

type isVifRegionConfig_VifRegionChoice interface {
	isVifRegionConfig_VifRegionChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type VifRegionConfig_SameAsSiteRegion struct {
	SameAsSiteRegion *schema.Empty `protobuf:"bytes,3,opt,name=same_as_site_region,json=sameAsSiteRegion,proto3,oneof" json:"same_as_site_region,omitempty"`
}
type VifRegionConfig_OtherRegion struct {
	OtherRegion string `protobuf:"bytes,4,opt,name=other_region,json=otherRegion,proto3,oneof" json:"other_region,omitempty"`
}

func (*VifRegionConfig_SameAsSiteRegion) isVifRegionConfig_VifRegionChoice() {}
func (*VifRegionConfig_OtherRegion) isVifRegionConfig_VifRegionChoice()      {}

func (m *VifRegionConfig) GetVifRegionChoice() isVifRegionConfig_VifRegionChoice {
	if m != nil {
		return m.VifRegionChoice
	}
	return nil
}

func (m *VifRegionConfig) GetSameAsSiteRegion() *schema.Empty {
	if x, ok := m.GetVifRegionChoice().(*VifRegionConfig_SameAsSiteRegion); ok {
		return x.SameAsSiteRegion
	}
	return nil
}

func (m *VifRegionConfig) GetOtherRegion() string {
	if x, ok := m.GetVifRegionChoice().(*VifRegionConfig_OtherRegion); ok {
		return x.OtherRegion
	}
	return ""
}

func (m *VifRegionConfig) GetVifId() string {
	if m != nil {
		return m.VifId
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VifRegionConfig) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VifRegionConfig_SameAsSiteRegion)(nil),
		(*VifRegionConfig_OtherRegion)(nil),
	}
}

// AWS Direct Connect Hosted VIF Config
//
// x-displayName: "AWS Direct Connect Hosted VIF Config"
// x-example: "value"
// AWS Direct Connect Hosted VIF Configuration
type HostedVIFConfigType struct {
	// Hosted VIFs
	//
	// x-displayName: "List of VIF IDs"
	// x-example: "value"
	// VIFs
	Vifs []string `protobuf:"bytes,1,rep,name=vifs,proto3" json:"vifs,omitempty"` // Deprecated: Do not use.
	// List of Hosted VIF Config
	//
	// x-displayName: "List of Hosted VIF Config"
	// List of Hosted VIF Config
	VifList []*VifRegionConfig `protobuf:"bytes,2,rep,name=vif_list,json=vifList,proto3" json:"vif_list,omitempty"`
	// Site Registration & Connectivity to RE
	//
	// x-displayName: "Site Registration & Connectivity to RE"
	//
	// Types that are valid to be assigned to ConnectivityOptions:
	//	*HostedVIFConfigType_SiteRegistrationOverInternet
	//	*HostedVIFConfigType_SiteRegistrationOverDirectConnect
	ConnectivityOptions isHostedVIFConfigType_ConnectivityOptions `protobuf_oneof:"connectivity_options"`
}

func (m *HostedVIFConfigType) Reset()      { *m = HostedVIFConfigType{} }
func (*HostedVIFConfigType) ProtoMessage() {}
func (*HostedVIFConfigType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{35}
}
func (m *HostedVIFConfigType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HostedVIFConfigType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HostedVIFConfigType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostedVIFConfigType.Merge(m, src)
}
func (m *HostedVIFConfigType) XXX_Size() int {
	return m.Size()
}
func (m *HostedVIFConfigType) XXX_DiscardUnknown() {
	xxx_messageInfo_HostedVIFConfigType.DiscardUnknown(m)
}

var xxx_messageInfo_HostedVIFConfigType proto.InternalMessageInfo

type isHostedVIFConfigType_ConnectivityOptions interface {
	isHostedVIFConfigType_ConnectivityOptions()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type HostedVIFConfigType_SiteRegistrationOverInternet struct {
	SiteRegistrationOverInternet *schema.Empty `protobuf:"bytes,4,opt,name=site_registration_over_internet,json=siteRegistrationOverInternet,proto3,oneof" json:"site_registration_over_internet,omitempty"`
}
type HostedVIFConfigType_SiteRegistrationOverDirectConnect struct {
	SiteRegistrationOverDirectConnect *CloudLinkADNType `protobuf:"bytes,5,opt,name=site_registration_over_direct_connect,json=siteRegistrationOverDirectConnect,proto3,oneof" json:"site_registration_over_direct_connect,omitempty"`
}

func (*HostedVIFConfigType_SiteRegistrationOverInternet) isHostedVIFConfigType_ConnectivityOptions() {
}
func (*HostedVIFConfigType_SiteRegistrationOverDirectConnect) isHostedVIFConfigType_ConnectivityOptions() {
}

func (m *HostedVIFConfigType) GetConnectivityOptions() isHostedVIFConfigType_ConnectivityOptions {
	if m != nil {
		return m.ConnectivityOptions
	}
	return nil
}

// Deprecated: Do not use.
func (m *HostedVIFConfigType) GetVifs() []string {
	if m != nil {
		return m.Vifs
	}
	return nil
}

func (m *HostedVIFConfigType) GetVifList() []*VifRegionConfig {
	if m != nil {
		return m.VifList
	}
	return nil
}

func (m *HostedVIFConfigType) GetSiteRegistrationOverInternet() *schema.Empty {
	if x, ok := m.GetConnectivityOptions().(*HostedVIFConfigType_SiteRegistrationOverInternet); ok {
		return x.SiteRegistrationOverInternet
	}
	return nil
}

func (m *HostedVIFConfigType) GetSiteRegistrationOverDirectConnect() *CloudLinkADNType {
	if x, ok := m.GetConnectivityOptions().(*HostedVIFConfigType_SiteRegistrationOverDirectConnect); ok {
		return x.SiteRegistrationOverDirectConnect
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HostedVIFConfigType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HostedVIFConfigType_SiteRegistrationOverInternet)(nil),
		(*HostedVIFConfigType_SiteRegistrationOverDirectConnect)(nil),
	}
}

// DirectConnectConfigType
//
// x-displayName: "Direct Connect Configuration"
// Direct Connect Configuration
type DirectConnectConfigType struct {
	// Cloud Aggregated Prefix
	//
	// x-displayName: "Cloud Aggregated Prefix"
	// x-example: "10.0.0.0/20"
	// Aggregated prefix from cloud to be advertised for DC side
	CloudAggregatedPrefix []string `protobuf:"bytes,1,rep,name=cloud_aggregated_prefix,json=cloudAggregatedPrefix,proto3" json:"cloud_aggregated_prefix,omitempty"`
	// Direct Connect Aggregate Prefixes
	//
	// x-displayName: "Direct Connect Aggregate Prefixes"
	// x-example: "20.0.0.0/20"
	// Aggregated prefix from direct connect to be advertised for Cloud side
	DcConnectAggregatedPrefix []string `protobuf:"bytes,2,rep,name=dc_connect_aggregated_prefix,json=dcConnectAggregatedPrefix,proto3" json:"dc_connect_aggregated_prefix,omitempty"`
	// AWS Direct Connect VIF Configuration
	//
	// x-displayName: "AWS Direct Connect VIF Configuration"
	// x-required
	// AWS Direct Connect VIF Configuration
	//
	// Types that are valid to be assigned to VifChoice:
	//	*DirectConnectConfigType_HostedVifs
	//	*DirectConnectConfigType_StandardVifs
	//	*DirectConnectConfigType_ManualGw
	VifChoice isDirectConnectConfigType_VifChoice `protobuf_oneof:"vif_choice"`
	// ASN Configuration
	//
	// x-displayName: "ASN Configuration"
	// x-required
	// ASN Configuration
	//
	// Types that are valid to be assigned to AsnChoice:
	//	*DirectConnectConfigType_AutoAsn
	//	*DirectConnectConfigType_CustomAsn
	AsnChoice isDirectConnectConfigType_AsnChoice `protobuf_oneof:"asn_choice"`
}

func (m *DirectConnectConfigType) Reset()      { *m = DirectConnectConfigType{} }
func (*DirectConnectConfigType) ProtoMessage() {}
func (*DirectConnectConfigType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{36}
}
func (m *DirectConnectConfigType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DirectConnectConfigType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DirectConnectConfigType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectConnectConfigType.Merge(m, src)
}
func (m *DirectConnectConfigType) XXX_Size() int {
	return m.Size()
}
func (m *DirectConnectConfigType) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectConnectConfigType.DiscardUnknown(m)
}

var xxx_messageInfo_DirectConnectConfigType proto.InternalMessageInfo

type isDirectConnectConfigType_VifChoice interface {
	isDirectConnectConfigType_VifChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isDirectConnectConfigType_AsnChoice interface {
	isDirectConnectConfigType_AsnChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DirectConnectConfigType_HostedVifs struct {
	HostedVifs *HostedVIFConfigType `protobuf:"bytes,4,opt,name=hosted_vifs,json=hostedVifs,proto3,oneof" json:"hosted_vifs,omitempty"`
}
type DirectConnectConfigType_StandardVifs struct {
	StandardVifs *schema.Empty `protobuf:"bytes,5,opt,name=standard_vifs,json=standardVifs,proto3,oneof" json:"standard_vifs,omitempty"`
}
type DirectConnectConfigType_ManualGw struct {
	ManualGw *schema.Empty `protobuf:"bytes,6,opt,name=manual_gw,json=manualGw,proto3,oneof" json:"manual_gw,omitempty"`
}
type DirectConnectConfigType_AutoAsn struct {
	AutoAsn *schema.Empty `protobuf:"bytes,8,opt,name=auto_asn,json=autoAsn,proto3,oneof" json:"auto_asn,omitempty"`
}
type DirectConnectConfigType_CustomAsn struct {
	CustomAsn uint32 `protobuf:"varint,9,opt,name=custom_asn,json=customAsn,proto3,oneof" json:"custom_asn,omitempty"`
}

func (*DirectConnectConfigType_HostedVifs) isDirectConnectConfigType_VifChoice()   {}
func (*DirectConnectConfigType_StandardVifs) isDirectConnectConfigType_VifChoice() {}
func (*DirectConnectConfigType_ManualGw) isDirectConnectConfigType_VifChoice()     {}
func (*DirectConnectConfigType_AutoAsn) isDirectConnectConfigType_AsnChoice()      {}
func (*DirectConnectConfigType_CustomAsn) isDirectConnectConfigType_AsnChoice()    {}

func (m *DirectConnectConfigType) GetVifChoice() isDirectConnectConfigType_VifChoice {
	if m != nil {
		return m.VifChoice
	}
	return nil
}
func (m *DirectConnectConfigType) GetAsnChoice() isDirectConnectConfigType_AsnChoice {
	if m != nil {
		return m.AsnChoice
	}
	return nil
}

func (m *DirectConnectConfigType) GetCloudAggregatedPrefix() []string {
	if m != nil {
		return m.CloudAggregatedPrefix
	}
	return nil
}

func (m *DirectConnectConfigType) GetDcConnectAggregatedPrefix() []string {
	if m != nil {
		return m.DcConnectAggregatedPrefix
	}
	return nil
}

func (m *DirectConnectConfigType) GetHostedVifs() *HostedVIFConfigType {
	if x, ok := m.GetVifChoice().(*DirectConnectConfigType_HostedVifs); ok {
		return x.HostedVifs
	}
	return nil
}

func (m *DirectConnectConfigType) GetStandardVifs() *schema.Empty {
	if x, ok := m.GetVifChoice().(*DirectConnectConfigType_StandardVifs); ok {
		return x.StandardVifs
	}
	return nil
}

func (m *DirectConnectConfigType) GetManualGw() *schema.Empty {
	if x, ok := m.GetVifChoice().(*DirectConnectConfigType_ManualGw); ok {
		return x.ManualGw
	}
	return nil
}

func (m *DirectConnectConfigType) GetAutoAsn() *schema.Empty {
	if x, ok := m.GetAsnChoice().(*DirectConnectConfigType_AutoAsn); ok {
		return x.AutoAsn
	}
	return nil
}

func (m *DirectConnectConfigType) GetCustomAsn() uint32 {
	if x, ok := m.GetAsnChoice().(*DirectConnectConfigType_CustomAsn); ok {
		return x.CustomAsn
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DirectConnectConfigType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DirectConnectConfigType_HostedVifs)(nil),
		(*DirectConnectConfigType_StandardVifs)(nil),
		(*DirectConnectConfigType_ManualGw)(nil),
		(*DirectConnectConfigType_AutoAsn)(nil),
		(*DirectConnectConfigType_CustomAsn)(nil),
	}
}

// Cloud Link ADN Network Config
//
// x-displayName: "Cloud Link ADN Network Config"
type CloudLinkADNType struct {
	// Cloud Link ADN Network Name
	//
	// x-displayName: "Cloud Link ADN Network Name"
	// x-example: "private-cloud-ntw"
	// x-required
	// Cloud Link ADN Network Name for private access connectivity to F5XC ADN.
	CloudlinkNetworkName string `protobuf:"bytes,1,opt,name=cloudlink_network_name,json=cloudlinkNetworkName,proto3" json:"cloudlink_network_name,omitempty"`
}

func (m *CloudLinkADNType) Reset()      { *m = CloudLinkADNType{} }
func (*CloudLinkADNType) ProtoMessage() {}
func (*CloudLinkADNType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{37}
}
func (m *CloudLinkADNType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudLinkADNType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CloudLinkADNType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudLinkADNType.Merge(m, src)
}
func (m *CloudLinkADNType) XXX_Size() int {
	return m.Size()
}
func (m *CloudLinkADNType) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudLinkADNType.DiscardUnknown(m)
}

var xxx_messageInfo_CloudLinkADNType proto.InternalMessageInfo

func (m *CloudLinkADNType) GetCloudlinkNetworkName() string {
	if m != nil {
		return m.CloudlinkNetworkName
	}
	return ""
}

// DirectConnect Info
//
// x-displayName: "DirectConnect Info"
// DirectConnect Info
type DirectConnectInfo struct {
	// DirectConnect Gateway ID
	//
	// x-displayName: "DirectConnect Gateway ID"
	// x-example: "f2a50c04-xxxx-yyyy-zzzz-00000000a043"
	// x-required
	// DirectConnect Gateway ID
	DirectConnectGatewayId string `protobuf:"bytes,1,opt,name=direct_connect_gateway_id,json=directConnectGatewayId,proto3" json:"direct_connect_gateway_id,omitempty"`
	// Virtual Private Gateway ID
	//
	// x-displayName: "Virtual Private Gateway ID"
	// x-example: "vgw-12345678"
	// x-required
	// Virtual Private Gateway ID
	VgwId string `protobuf:"bytes,2,opt,name=vgw_id,json=vgwId,proto3" json:"vgw_id,omitempty"`
	// AWS Side ASN
	//
	// x-displayName: "AWS Side ASN"
	// x-example: ""
	// The autonomous system (AS) number on the AWS side for Border Gateway Protocol (BGP) configuration
	Asn uint32 `protobuf:"varint,3,opt,name=asn,proto3" json:"asn,omitempty"`
}

func (m *DirectConnectInfo) Reset()      { *m = DirectConnectInfo{} }
func (*DirectConnectInfo) ProtoMessage() {}
func (*DirectConnectInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{38}
}
func (m *DirectConnectInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DirectConnectInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DirectConnectInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectConnectInfo.Merge(m, src)
}
func (m *DirectConnectInfo) XXX_Size() int {
	return m.Size()
}
func (m *DirectConnectInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectConnectInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DirectConnectInfo proto.InternalMessageInfo

func (m *DirectConnectInfo) GetDirectConnectGatewayId() string {
	if m != nil {
		return m.DirectConnectGatewayId
	}
	return ""
}

func (m *DirectConnectInfo) GetVgwId() string {
	if m != nil {
		return m.VgwId
	}
	return ""
}

func (m *DirectConnectInfo) GetAsn() uint32 {
	if m != nil {
		return m.Asn
	}
	return 0
}

// AWS NAT Gateway choice
//
// x-displayName: "AWS NAT Gateway choice"
// With this option, egress site traffic will be routed through an Network Address Translation(NAT) Gateway.
type AWSNATGatewaychoiceType struct {
	// Choice of existing or new NAT Gateway
	//
	// x-displayName: "Select existing NAT Gateway or create new NAT Gateway"
	// x-required
	// This is choice of existing NAT Gateway or new NAT Gateway
	//
	// Types that are valid to be assigned to Choice:
	//	*AWSNATGatewaychoiceType_NatGwId
	Choice isAWSNATGatewaychoiceType_Choice `protobuf_oneof:"choice"`
}

func (m *AWSNATGatewaychoiceType) Reset()      { *m = AWSNATGatewaychoiceType{} }
func (*AWSNATGatewaychoiceType) ProtoMessage() {}
func (*AWSNATGatewaychoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{39}
}
func (m *AWSNATGatewaychoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSNATGatewaychoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSNATGatewaychoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSNATGatewaychoiceType.Merge(m, src)
}
func (m *AWSNATGatewaychoiceType) XXX_Size() int {
	return m.Size()
}
func (m *AWSNATGatewaychoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSNATGatewaychoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSNATGatewaychoiceType proto.InternalMessageInfo

type isAWSNATGatewaychoiceType_Choice interface {
	isAWSNATGatewaychoiceType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AWSNATGatewaychoiceType_NatGwId struct {
	NatGwId string `protobuf:"bytes,1,opt,name=nat_gw_id,json=natGwId,proto3,oneof" json:"nat_gw_id,omitempty"`
}

func (*AWSNATGatewaychoiceType_NatGwId) isAWSNATGatewaychoiceType_Choice() {}

func (m *AWSNATGatewaychoiceType) GetChoice() isAWSNATGatewaychoiceType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *AWSNATGatewaychoiceType) GetNatGwId() string {
	if x, ok := m.GetChoice().(*AWSNATGatewaychoiceType_NatGwId); ok {
		return x.NatGwId
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AWSNATGatewaychoiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AWSNATGatewaychoiceType_NatGwId)(nil),
	}
}

// AWS Virtual Private Gateway choice
//
// x-displayName: "AWS Virtual Private Gateway choice"
// With this option, egress site traffic will be routed through an Virtual Private Gateway.
type AWSVirtualPrivateGatewaychoiceType struct {
	// Choice of existing or new Virtual Private Gateway
	//
	// x-displayName: "Select existing Virtual Private Gateway or create new Virtual Private Gateway"
	// x-required
	// This is choice of existing Virtual Private Gateway or new Virtual Private Gateway
	//
	// Types that are valid to be assigned to Choice:
	//	*AWSVirtualPrivateGatewaychoiceType_VgwId
	Choice isAWSVirtualPrivateGatewaychoiceType_Choice `protobuf_oneof:"choice"`
}

func (m *AWSVirtualPrivateGatewaychoiceType) Reset()      { *m = AWSVirtualPrivateGatewaychoiceType{} }
func (*AWSVirtualPrivateGatewaychoiceType) ProtoMessage() {}
func (*AWSVirtualPrivateGatewaychoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5debf32965df805e, []int{40}
}
func (m *AWSVirtualPrivateGatewaychoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSVirtualPrivateGatewaychoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSVirtualPrivateGatewaychoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSVirtualPrivateGatewaychoiceType.Merge(m, src)
}
func (m *AWSVirtualPrivateGatewaychoiceType) XXX_Size() int {
	return m.Size()
}
func (m *AWSVirtualPrivateGatewaychoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSVirtualPrivateGatewaychoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSVirtualPrivateGatewaychoiceType proto.InternalMessageInfo

type isAWSVirtualPrivateGatewaychoiceType_Choice interface {
	isAWSVirtualPrivateGatewaychoiceType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AWSVirtualPrivateGatewaychoiceType_VgwId struct {
	VgwId string `protobuf:"bytes,1,opt,name=vgw_id,json=vgwId,proto3,oneof" json:"vgw_id,omitempty"`
}

func (*AWSVirtualPrivateGatewaychoiceType_VgwId) isAWSVirtualPrivateGatewaychoiceType_Choice() {}

func (m *AWSVirtualPrivateGatewaychoiceType) GetChoice() isAWSVirtualPrivateGatewaychoiceType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *AWSVirtualPrivateGatewaychoiceType) GetVgwId() string {
	if x, ok := m.GetChoice().(*AWSVirtualPrivateGatewaychoiceType_VgwId); ok {
		return x.VgwId
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AWSVirtualPrivateGatewaychoiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AWSVirtualPrivateGatewaychoiceType_VgwId)(nil),
	}
}

func init() {
	proto.RegisterType((*AWSVPCParamsType)(nil), "ves.io.schema.views.AWSVPCParamsType")
	golang_proto.RegisterType((*AWSVPCParamsType)(nil), "ves.io.schema.views.AWSVPCParamsType")
	proto.RegisterType((*AWSVPCchoiceType)(nil), "ves.io.schema.views.AWSVPCchoiceType")
	golang_proto.RegisterType((*AWSVPCchoiceType)(nil), "ves.io.schema.views.AWSVPCchoiceType")
	proto.RegisterType((*CloudSubnetParamType)(nil), "ves.io.schema.views.CloudSubnetParamType")
	golang_proto.RegisterType((*CloudSubnetParamType)(nil), "ves.io.schema.views.CloudSubnetParamType")
	proto.RegisterType((*CloudSubnetType)(nil), "ves.io.schema.views.CloudSubnetType")
	golang_proto.RegisterType((*CloudSubnetType)(nil), "ves.io.schema.views.CloudSubnetType")
	proto.RegisterType((*AWSSubnetIdsType)(nil), "ves.io.schema.views.AWSSubnetIdsType")
	golang_proto.RegisterType((*AWSSubnetIdsType)(nil), "ves.io.schema.views.AWSSubnetIdsType")
	proto.RegisterType((*AWSSubnetInfoType)(nil), "ves.io.schema.views.AWSSubnetInfoType")
	golang_proto.RegisterType((*AWSSubnetInfoType)(nil), "ves.io.schema.views.AWSSubnetInfoType")
	proto.RegisterType((*AWSVPCOneInterfaceNodeType)(nil), "ves.io.schema.views.AWSVPCOneInterfaceNodeType")
	golang_proto.RegisterType((*AWSVPCOneInterfaceNodeType)(nil), "ves.io.schema.views.AWSVPCOneInterfaceNodeType")
	proto.RegisterType((*AWSVPCTwoInterfaceNodeType)(nil), "ves.io.schema.views.AWSVPCTwoInterfaceNodeType")
	golang_proto.RegisterType((*AWSVPCTwoInterfaceNodeType)(nil), "ves.io.schema.views.AWSVPCTwoInterfaceNodeType")
	proto.RegisterType((*AzureVnetParamsType)(nil), "ves.io.schema.views.AzureVnetParamsType")
	golang_proto.RegisterType((*AzureVnetParamsType)(nil), "ves.io.schema.views.AzureVnetParamsType")
	proto.RegisterType((*AzureVnetType)(nil), "ves.io.schema.views.AzureVnetType")
	golang_proto.RegisterType((*AzureVnetType)(nil), "ves.io.schema.views.AzureVnetType")
	proto.RegisterType((*AzureVnetChoiceType)(nil), "ves.io.schema.views.AzureVnetChoiceType")
	golang_proto.RegisterType((*AzureVnetChoiceType)(nil), "ves.io.schema.views.AzureVnetChoiceType")
	proto.RegisterType((*AzureSubnetType)(nil), "ves.io.schema.views.AzureSubnetType")
	golang_proto.RegisterType((*AzureSubnetType)(nil), "ves.io.schema.views.AzureSubnetType")
	proto.RegisterType((*AzureSpecialSubnetType)(nil), "ves.io.schema.views.AzureSpecialSubnetType")
	golang_proto.RegisterType((*AzureSpecialSubnetType)(nil), "ves.io.schema.views.AzureSpecialSubnetType")
	proto.RegisterType((*AzureSubnetChoiceType)(nil), "ves.io.schema.views.AzureSubnetChoiceType")
	golang_proto.RegisterType((*AzureSubnetChoiceType)(nil), "ves.io.schema.views.AzureSubnetChoiceType")
	proto.RegisterType((*AzureSubnetChoiceWithAutoType)(nil), "ves.io.schema.views.AzureSubnetChoiceWithAutoType")
	golang_proto.RegisterType((*AzureSubnetChoiceWithAutoType)(nil), "ves.io.schema.views.AzureSubnetChoiceWithAutoType")
	proto.RegisterType((*AzureVnetOneInterfaceNodeType)(nil), "ves.io.schema.views.AzureVnetOneInterfaceNodeType")
	golang_proto.RegisterType((*AzureVnetOneInterfaceNodeType)(nil), "ves.io.schema.views.AzureVnetOneInterfaceNodeType")
	proto.RegisterType((*AzureVnetOneInterfaceNodeARType)(nil), "ves.io.schema.views.AzureVnetOneInterfaceNodeARType")
	golang_proto.RegisterType((*AzureVnetOneInterfaceNodeARType)(nil), "ves.io.schema.views.AzureVnetOneInterfaceNodeARType")
	proto.RegisterType((*AzureVnetTwoInterfaceNodeType)(nil), "ves.io.schema.views.AzureVnetTwoInterfaceNodeType")
	golang_proto.RegisterType((*AzureVnetTwoInterfaceNodeType)(nil), "ves.io.schema.views.AzureVnetTwoInterfaceNodeType")
	proto.RegisterType((*AzureVnetTwoInterfaceNodeARType)(nil), "ves.io.schema.views.AzureVnetTwoInterfaceNodeARType")
	golang_proto.RegisterType((*AzureVnetTwoInterfaceNodeARType)(nil), "ves.io.schema.views.AzureVnetTwoInterfaceNodeARType")
	proto.RegisterType((*GCPVPCNetworkParamsType)(nil), "ves.io.schema.views.GCPVPCNetworkParamsType")
	golang_proto.RegisterType((*GCPVPCNetworkParamsType)(nil), "ves.io.schema.views.GCPVPCNetworkParamsType")
	proto.RegisterType((*GCPVPCNetworkAutogenerateParamsType)(nil), "ves.io.schema.views.GCPVPCNetworkAutogenerateParamsType")
	golang_proto.RegisterType((*GCPVPCNetworkAutogenerateParamsType)(nil), "ves.io.schema.views.GCPVPCNetworkAutogenerateParamsType")
	proto.RegisterType((*GCPVPCNetworkType)(nil), "ves.io.schema.views.GCPVPCNetworkType")
	golang_proto.RegisterType((*GCPVPCNetworkType)(nil), "ves.io.schema.views.GCPVPCNetworkType")
	proto.RegisterType((*GCPSubnetType)(nil), "ves.io.schema.views.GCPSubnetType")
	golang_proto.RegisterType((*GCPSubnetType)(nil), "ves.io.schema.views.GCPSubnetType")
	proto.RegisterType((*GCPSubnetParamsType)(nil), "ves.io.schema.views.GCPSubnetParamsType")
	golang_proto.RegisterType((*GCPSubnetParamsType)(nil), "ves.io.schema.views.GCPSubnetParamsType")
	proto.RegisterType((*GCPVPCNetworkChoiceType)(nil), "ves.io.schema.views.GCPVPCNetworkChoiceType")
	golang_proto.RegisterType((*GCPVPCNetworkChoiceType)(nil), "ves.io.schema.views.GCPVPCNetworkChoiceType")
	proto.RegisterType((*GCPVPCSubnetChoiceType)(nil), "ves.io.schema.views.GCPVPCSubnetChoiceType")
	golang_proto.RegisterType((*GCPVPCSubnetChoiceType)(nil), "ves.io.schema.views.GCPVPCSubnetChoiceType")
	proto.RegisterType((*SiteStaticRoutesType)(nil), "ves.io.schema.views.SiteStaticRoutesType")
	golang_proto.RegisterType((*SiteStaticRoutesType)(nil), "ves.io.schema.views.SiteStaticRoutesType")
	proto.RegisterType((*SiteStaticRoutesListType)(nil), "ves.io.schema.views.SiteStaticRoutesListType")
	golang_proto.RegisterType((*SiteStaticRoutesListType)(nil), "ves.io.schema.views.SiteStaticRoutesListType")
	proto.RegisterType((*GlobalNetworkConnectionType)(nil), "ves.io.schema.views.GlobalNetworkConnectionType")
	golang_proto.RegisterType((*GlobalNetworkConnectionType)(nil), "ves.io.schema.views.GlobalNetworkConnectionType")
	proto.RegisterType((*GlobalNetworkConnectionListType)(nil), "ves.io.schema.views.GlobalNetworkConnectionListType")
	golang_proto.RegisterType((*GlobalNetworkConnectionListType)(nil), "ves.io.schema.views.GlobalNetworkConnectionListType")
	proto.RegisterType((*AllowedVIPPorts)(nil), "ves.io.schema.views.AllowedVIPPorts")
	golang_proto.RegisterType((*AllowedVIPPorts)(nil), "ves.io.schema.views.AllowedVIPPorts")
	proto.RegisterType((*CustomPorts)(nil), "ves.io.schema.views.CustomPorts")
	golang_proto.RegisterType((*CustomPorts)(nil), "ves.io.schema.views.CustomPorts")
	proto.RegisterType((*OfflineSurvivabilityModeType)(nil), "ves.io.schema.views.OfflineSurvivabilityModeType")
	golang_proto.RegisterType((*OfflineSurvivabilityModeType)(nil), "ves.io.schema.views.OfflineSurvivabilityModeType")
	proto.RegisterType((*DCGWBGPPeerType)(nil), "ves.io.schema.views.DCGWBGPPeerType")
	golang_proto.RegisterType((*DCGWBGPPeerType)(nil), "ves.io.schema.views.DCGWBGPPeerType")
	proto.RegisterType((*VifRegionConfig)(nil), "ves.io.schema.views.VifRegionConfig")
	golang_proto.RegisterType((*VifRegionConfig)(nil), "ves.io.schema.views.VifRegionConfig")
	proto.RegisterType((*HostedVIFConfigType)(nil), "ves.io.schema.views.HostedVIFConfigType")
	golang_proto.RegisterType((*HostedVIFConfigType)(nil), "ves.io.schema.views.HostedVIFConfigType")
	proto.RegisterType((*DirectConnectConfigType)(nil), "ves.io.schema.views.DirectConnectConfigType")
	golang_proto.RegisterType((*DirectConnectConfigType)(nil), "ves.io.schema.views.DirectConnectConfigType")
	proto.RegisterType((*CloudLinkADNType)(nil), "ves.io.schema.views.CloudLinkADNType")
	golang_proto.RegisterType((*CloudLinkADNType)(nil), "ves.io.schema.views.CloudLinkADNType")
	proto.RegisterType((*DirectConnectInfo)(nil), "ves.io.schema.views.DirectConnectInfo")
	golang_proto.RegisterType((*DirectConnectInfo)(nil), "ves.io.schema.views.DirectConnectInfo")
	proto.RegisterType((*AWSNATGatewaychoiceType)(nil), "ves.io.schema.views.AWSNATGatewaychoiceType")
	golang_proto.RegisterType((*AWSNATGatewaychoiceType)(nil), "ves.io.schema.views.AWSNATGatewaychoiceType")
	proto.RegisterType((*AWSVirtualPrivateGatewaychoiceType)(nil), "ves.io.schema.views.AWSVirtualPrivateGatewaychoiceType")
	golang_proto.RegisterType((*AWSVirtualPrivateGatewaychoiceType)(nil), "ves.io.schema.views.AWSVirtualPrivateGatewaychoiceType")
}

func init() {
	proto.RegisterFile("ves.io/schema/views/site_types.proto", fileDescriptor_5debf32965df805e)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/views/site_types.proto", fileDescriptor_5debf32965df805e)
}

var fileDescriptor_5debf32965df805e = []byte{
	// 4480 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x5b, 0x5f, 0x6c, 0x1b, 0x67,
	0x72, 0xd7, 0x47, 0xae, 0x28, 0x6a, 0x44, 0x4a, 0xd4, 0x4a, 0xb6, 0x69, 0x39, 0xa1, 0x68, 0xda,
	0x4e, 0x64, 0x99, 0xa2, 0x2c, 0x4a, 0xd6, 0x39, 0xba, 0xc2, 0x35, 0x29, 0xd9, 0x16, 0x15, 0x5b,
	0x56, 0x56, 0x89, 0xdc, 0xf3, 0x35, 0xd9, 0xae, 0xc8, 0x8f, 0xd4, 0xc2, 0xd4, 0xee, 0x62, 0x77,
	0x49, 0xda, 0xbe, 0x06, 0x75, 0x8b, 0x03, 0xae, 0xbd, 0x2b, 0x7a, 0x87, 0x14, 0x45, 0x0f, 0x57,
	0x14, 0xed, 0xe3, 0x21, 0xed, 0xc3, 0xa1, 0xe8, 0xbd, 0x44, 0x46, 0x61, 0xf4, 0xa1, 0x48, 0x5d,
	0xe0, 0xe0, 0x6b, 0x81, 0x22, 0x28, 0x70, 0x45, 0xe2, 0xbc, 0xe4, 0x1e, 0x0e, 0x0d, 0x8c, 0x02,
	0xbd, 0xa7, 0xba, 0xf8, 0xfe, 0x2c, 0xb9, 0x4b, 0x2e, 0x29, 0x29, 0x4e, 0x1e, 0xfa, 0xc4, 0x8f,
	0xfb, 0xcd, 0xfc, 0xbe, 0x99, 0xf9, 0x66, 0xe6, 0x9b, 0xd9, 0x3f, 0x70, 0xba, 0x8e, 0xad, 0x8c,
	0xaa, 0xcf, 0x5a, 0xc5, 0x1d, 0xbc, 0xab, 0xcc, 0xd6, 0x55, 0xdc, 0xb0, 0x66, 0x2d, 0xd5, 0xc6,
	0xb2, 0x7d, 0xcf, 0xc0, 0x56, 0xc6, 0x30, 0x75, 0x5b, 0x17, 0xc7, 0x18, 0x55, 0x86, 0x51, 0x65,
	0x28, 0xd5, 0xc4, 0x4c, 0x45, 0xb5, 0x77, 0x6a, 0xdb, 0x99, 0xa2, 0xbe, 0x3b, 0x5b, 0xd1, 0x2b,
	0xfa, 0x2c, 0xa5, 0xdd, 0xae, 0x95, 0xe9, 0x3f, 0xfa, 0x87, 0x8e, 0x18, 0xc6, 0xc4, 0x31, 0xef,
	0x4a, 0x1a, 0xb6, 0xf9, 0xc4, 0x09, 0xef, 0x84, 0x6e, 0xd8, 0xaa, 0xae, 0xf1, 0x95, 0x27, 0x8e,
	0x7b, 0x27, 0x5d, 0x42, 0x4d, 0xbc, 0xd4, 0x26, 0xba, 0x52, 0x55, 0x4b, 0x8a, 0x8d, 0xf9, 0x6c,
	0xb2, 0x53, 0x31, 0xd9, 0x0b, 0x3d, 0xe9, 0xa7, 0xba, 0x6b, 0x81, 0xd4, 0xdf, 0x05, 0x20, 0x96,
	0xbb, 0xb5, 0xb9, 0xb5, 0xb1, 0xbc, 0xa1, 0x98, 0xca, 0xae, 0xf5, 0xe6, 0x3d, 0x03, 0x8b, 0xd3,
	0x10, 0xd6, 0x94, 0x5d, 0x2c, 0xdb, 0x4a, 0x25, 0x1e, 0x48, 0xa2, 0xa9, 0xc1, 0x7c, 0xf4, 0xd7,
	0x7b, 0xa8, 0xef, 0x83, 0x5f, 0x3e, 0x0a, 0x0a, 0x66, 0x20, 0x7e, 0x79, 0xb5, 0x4f, 0x1a, 0x20,
	0x04, 0x6f, 0x2a, 0x15, 0x71, 0x09, 0x22, 0x4a, 0xcd, 0xd6, 0x2b, 0x58, 0xc3, 0xa6, 0x62, 0xe3,
	0x78, 0x38, 0x89, 0xa6, 0x86, 0xb2, 0xe3, 0x19, 0xaf, 0x35, 0xaf, 0xec, 0x1a, 0xf6, 0xbd, 0xd5,
	0x3e, 0xc9, 0x43, 0x2b, 0x5e, 0x81, 0x88, 0x61, 0xaa, 0xbb, 0x8a, 0x79, 0x4f, 0x56, 0x8d, 0xfa,
	0x42, 0x3c, 0x48, 0xd7, 0x4a, 0x39, 0x6b, 0xf5, 0x9b, 0xc1, 0x5f, 0x23, 0xc4, 0x47, 0x3f, 0x0c,
	0xbc, 0xc4, 0x47, 0x3f, 0x08, 0xc4, 0xa4, 0x21, 0xce, 0x57, 0x30, 0xea, 0x0b, 0xe2, 0x0c, 0x44,
	0x95, 0x6a, 0x55, 0x2f, 0x2a, 0x36, 0x26, 0x38, 0x8b, 0xf1, 0x50, 0x12, 0x4d, 0x85, 0xf3, 0xe1,
	0xcf, 0xf6, 0x10, 0x22, 0x58, 0x52, 0xc4, 0x99, 0x2e, 0x18, 0xf5, 0xc5, 0xa5, 0xf0, 0xb3, 0x4b,
	0xfd, 0x5f, 0x4b, 0xcf, 0xa7, 0x17, 0xf3, 0x09, 0x18, 0xa2, 0x7a, 0x16, 0x77, 0x74, 0xb5, 0x88,
	0xc5, 0x91, 0x47, 0x7b, 0x28, 0xfc, 0x64, 0x0f, 0x0d, 0x3c, 0xdd, 0x43, 0xc1, 0x8b, 0xe9, 0xec,
	0x9a, 0x10, 0x46, 0xb1, 0xc0, 0x9a, 0x10, 0x16, 0x62, 0xfd, 0x6b, 0x42, 0xb8, 0x3f, 0x16, 0x5a,
	0x13, 0xc2, 0x03, 0xb1, 0x70, 0xea, 0x43, 0xe4, 0x18, 0x8d, 0x71, 0x52, 0xa3, 0x5d, 0x86, 0x01,
	0x0d, 0x37, 0xe4, 0xba, 0x51, 0x8c, 0x23, 0x6a, 0x83, 0x33, 0x19, 0x1f, 0x8f, 0xca, 0xb4, 0x1b,
	0x7b, 0xb5, 0x4f, 0x0a, 0x69, 0xb8, 0xb1, 0x65, 0x14, 0xc5, 0x37, 0x20, 0x54, 0x37, 0x8a, 0xb2,
	0x5a, 0xe2, 0x46, 0xbf, 0xe8, 0x31, 0x3a, 0x19, 0xbc, 0x62, 0x9e, 0xce, 0xa6, 0xde, 0x99, 0xaa,
	0x1b, 0xc5, 0x99, 0xb3, 0x53, 0xdf, 0x54, 0x66, 0xee, 0x9f, 0x9f, 0x79, 0xed, 0xed, 0x6f, 0x5d,
	0x7c, 0xf7, 0x77, 0x9b, 0xe3, 0xb9, 0xaf, 0xbd, 0x7b, 0xf6, 0xf4, 0x6a, 0x9f, 0xd4, 0x5f, 0x37,
	0x8a, 0x85, 0x52, 0xfe, 0x38, 0x84, 0x5c, 0xca, 0xa1, 0x27, 0x7b, 0x28, 0x48, 0x94, 0x9b, 0xa3,
	0xca, 0x05, 0x63, 0x42, 0xca, 0x86, 0xf1, 0xe5, 0xaa, 0x5e, 0x2b, 0x6d, 0xd6, 0xb6, 0x35, 0x6c,
	0x53, 0xb1, 0xa8, 0x36, 0x69, 0x10, 0xe8, 0x96, 0x20, 0x2a, 0x49, 0xbc, 0xdb, 0x96, 0x48, 0x94,
	0x4a, 0x7c, 0x85, 0x52, 0x2f, 0x72, 0xb9, 0x45, 0xc7, 0xf0, 0x9c, 0xee, 0x41, 0x00, 0x51, 0xba,
	0xc5, 0xa5, 0xd0, 0xb3, 0x4b, 0x64, 0xed, 0xd4, 0x7f, 0x21, 0x18, 0x71, 0x2d, 0x4b, 0x57, 0x5c,
	0x87, 0x88, 0x45, 0xff, 0xc9, 0x06, 0x91, 0x82, 0x1b, 0xf1, 0xac, 0xaf, 0x11, 0xfd, 0x44, 0x5e,
	0xed, 0x93, 0x86, 0xac, 0xd6, 0x25, 0xf1, 0x0e, 0x88, 0xf8, 0xae, 0x6a, 0xd9, 0xaa, 0x56, 0x91,
	0x39, 0x70, 0xd3, 0xb2, 0x5f, 0xef, 0xb0, 0xec, 0x59, 0xf3, 0xd5, 0xec, 0x99, 0x77, 0xa6, 0x18,
	0xe1, 0x7e, 0xc6, 0x8d, 0x39, 0xc0, 0x4c, 0x84, 0x83, 0xd8, 0xf9, 0x67, 0x02, 0x75, 0x19, 0x87,
	0x81, 0xc5, 0xd9, 0x09, 0x18, 0x50, 0xee, 0xcb, 0xc4, 0x05, 0xb9, 0x9d, 0x03, 0x71, 0x24, 0x85,
	0x94, 0xfb, 0xeb, 0xca, 0x2e, 0x16, 0x33, 0x30, 0xaa, 0xd7, 0x6c, 0x4b, 0x2d, 0xe1, 0x0e, 0xf1,
	0x09, 0xd9, 0x08, 0x9f, 0x74, 0x10, 0xc5, 0x34, 0xc4, 0x54, 0xad, 0x8d, 0x3c, 0xd8, 0x24, 0x1f,
	0x66, 0x73, 0x4d, 0xea, 0xf3, 0x20, 0x36, 0x74, 0xf3, 0x4e, 0x55, 0x57, 0x4a, 0x2e, 0x7a, 0xa1,
	0x49, 0x1f, 0x73, 0x66, 0x9b, 0x1c, 0x37, 0x60, 0xd8, 0x2b, 0x4f, 0xbc, 0x9f, 0xee, 0xd0, 0x2b,
	0xdd, 0xdc, 0x9c, 0x73, 0x6a, 0x65, 0x9d, 0x28, 0x2b, 0x45, 0x3d, 0x02, 0x8b, 0xaf, 0x43, 0xd4,
	0x23, 0x2e, 0x0d, 0xda, 0x83, 0xa3, 0x45, 0xdc, 0xfa, 0x88, 0x37, 0x61, 0xa4, 0x4d, 0x9b, 0xf8,
	0xc0, 0xa1, 0xe0, 0x86, 0xbd, 0xea, 0x2e, 0xfd, 0x15, 0x7a, 0xbc, 0x87, 0x7e, 0x84, 0xe0, 0x14,
	0x0c, 0xe4, 0x6e, 0x27, 0xc9, 0x7e, 0x4c, 0xc4, 0xe1, 0xa8, 0x57, 0xff, 0x0c, 0xdf, 0x3b, 0x38,
	0x05, 0xd1, 0x02, 0x95, 0x26, 0xc9, 0xb8, 0x27, 0xc4, 0xb6, 0xad, 0xc8, 0xa8, 0x25, 0x38, 0x03,
	0xc3, 0x37, 0x19, 0xbb, 0x43, 0x35, 0xd6, 0xbe, 0xc1, 0x84, 0xec, 0x55, 0x18, 0xb9, 0xc5, 0x45,
	0x71, 0xe8, 0xc6, 0x3b, 0xb6, 0x2a, 0xa3, 0x96, 0x52, 0xff, 0x8d, 0x60, 0xb4, 0x43, 0x0f, 0xf1,
	0x46, 0xbb, 0x47, 0x2d, 0x10, 0xe7, 0x9e, 0x35, 0x67, 0xb2, 0xe7, 0xde, 0xa1, 0x3e, 0xfd, 0xf6,
	0xb7, 0xb2, 0xef, 0x9e, 0x9d, 0x69, 0xb9, 0xf7, 0x42, 0x3a, 0x7b, 0xde, 0x73, 0x21, 0xfb, 0xee,
	0xd9, 0xd3, 0x4d, 0x1f, 0x7c, 0x1d, 0x02, 0x5f, 0x4a, 0xcc, 0x48, 0x01, 0xb5, 0x24, 0x2e, 0xc3,
	0x10, 0x49, 0x16, 0xb2, 0x61, 0xe2, 0xb2, 0x7a, 0xf7, 0xc0, 0xc9, 0x3e, 0x2c, 0x01, 0x61, 0xdb,
	0xa0, 0x5c, 0xa9, 0x7f, 0x09, 0xc2, 0x04, 0x4b, 0xa1, 0x37, 0x35, 0x5c, 0xd0, 0x6c, 0x6c, 0x96,
	0x95, 0x22, 0x5e, 0xd7, 0x4b, 0x2c, 0x09, 0x2f, 0xc0, 0x90, 0xd2, 0xb0, 0x64, 0xaf, 0x0d, 0xc6,
	0xe9, 0x1a, 0x0f, 0x51, 0x24, 0x8c, 0xce, 0xa3, 0xa5, 0x50, 0x51, 0xd7, 0xca, 0x6a, 0x45, 0x1a,
	0x54, 0x1a, 0x56, 0x8e, 0xa9, 0x79, 0x03, 0x22, 0xe4, 0x7c, 0xa8, 0x3a, 0xbe, 0x13, 0xa0, 0xbe,
	0x73, 0x7a, 0xbf, 0xd4, 0x43, 0x56, 0xcc, 0x0b, 0x3f, 0x79, 0x88, 0x90, 0x34, 0x44, 0xf9, 0xb9,
	0x37, 0x66, 0x61, 0xb0, 0xa4, 0x5a, 0x77, 0x64, 0x4b, 0xbd, 0x8f, 0x69, 0x48, 0x45, 0xf3, 0x47,
	0x3e, 0x7a, 0x17, 0x91, 0xac, 0xf8, 0x87, 0x0f, 0xd1, 0x28, 0xd5, 0x6c, 0x3a, 0x18, 0x7f, 0x10,
	0x93, 0xc2, 0x84, 0x6e, 0x53, 0xbd, 0x8f, 0x97, 0x7e, 0x85, 0x9e, 0x5d, 0xea, 0x9f, 0x4b, 0xcf,
	0xa7, 0xb3, 0x8f, 0xf7, 0xd0, 0xc7, 0x08, 0x52, 0x30, 0x9a, 0xab, 0x2b, 0x6a, 0x55, 0xd9, 0x56,
	0xab, 0xaa, 0x7d, 0x2f, 0x79, 0x5b, 0xd7, 0xf0, 0x44, 0xd4, 0xa3, 0x1d, 0x54, 0x60, 0x88, 0xad,
	0x98, 0x24, 0x92, 0x4c, 0xff, 0x16, 0x6c, 0xc1, 0xab, 0x70, 0xdc, 0xad, 0x49, 0xc6, 0x9d, 0x51,
	0xb3, 0xb0, 0x4c, 0x35, 0xaf, 0x99, 0xb8, 0x04, 0xe7, 0x60, 0xd2, 0x43, 0xd8, 0x99, 0x2a, 0xb3,
	0xe1, 0x2b, 0xfc, 0x1a, 0xbc, 0x01, 0x11, 0xbe, 0xd0, 0x96, 0x52, 0xad, 0xe1, 0x6c, 0x0e, 0x12,
	0x5d, 0x57, 0xc9, 0x90, 0xcd, 0xda, 0x17, 0x9c, 0x67, 0xc5, 0x7f, 0x0f, 0x3b, 0xbb, 0xf9, 0x66,
	0x43, 0xff, 0xb2, 0x76, 0xf3, 0x3a, 0x1c, 0x35, 0xb1, 0x85, 0xcd, 0x3a, 0x2e, 0xc9, 0x7e, 0x29,
	0xa6, 0x5b, 0x6d, 0x32, 0xee, 0x70, 0x15, 0xdc, 0xa9, 0xe5, 0x8d, 0xf6, 0x3c, 0x75, 0x68, 0xe7,
	0x20, 0x65, 0x8f, 0xea, 0x85, 0x6c, 0xcf, 0xa4, 0xc1, 0x43, 0x3b, 0x5c, 0x5b, 0x36, 0xdd, 0xec,
	0x96, 0x00, 0x0f, 0x83, 0xd9, 0x96, 0x04, 0xbd, 0x7e, 0x1c, 0x3e, 0x98, 0x1f, 0xff, 0x42, 0x78,
	0x76, 0x69, 0x60, 0x2e, 0x4d, 0xea, 0xab, 0x0b, 0x8f, 0xf7, 0xd0, 0xcf, 0x84, 0x03, 0x79, 0xf2,
	0x5f, 0x20, 0x10, 0x3d, 0x29, 0x94, 0x79, 0xf4, 0xb7, 0x11, 0xfc, 0x3e, 0x82, 0x57, 0xbb, 0xed,
	0x67, 0x36, 0x9a, 0x73, 0x55, 0x93, 0x25, 0x98, 0x82, 0x09, 0x6f, 0xda, 0xed, 0xea, 0xfd, 0x69,
	0x48, 0x7a, 0x29, 0x7b, 0xba, 0xff, 0x6d, 0x18, 0xf3, 0x0a, 0xc7, 0xa2, 0x60, 0x19, 0x26, 0xbb,
	0x2f, 0xc7, 0xc2, 0x60, 0xdf, 0x55, 0xc0, 0x82, 0x31, 0xef, 0xb1, 0xc0, 0x34, 0xff, 0x6d, 0xb8,
	0x0d, 0x67, 0xe1, 0x44, 0xdb, 0xf9, 0xd0, 0x55, 0x9f, 0x19, 0x38, 0xd9, 0x46, 0xda, 0x53, 0xa1,
	0xb7, 0x61, 0xbc, 0x6d, 0x51, 0xa6, 0xd1, 0x15, 0x48, 0xf6, 0x58, 0x91, 0xa9, 0xb4, 0xff, 0x42,
	0x70, 0xbb, 0xe3, 0x0c, 0xcb, 0x5e, 0x83, 0x93, 0xed, 0x67, 0x58, 0x27, 0x74, 0xaa, 0x9d, 0xa4,
	0x13, 0xbb, 0xad, 0xd0, 0x0a, 0x3d, 0xd9, 0x43, 0xfd, 0xa4, 0xd0, 0x5a, 0xa4, 0x85, 0x16, 0xab,
	0xd0, 0x85, 0x58, 0x7f, 0xea, 0x57, 0x08, 0xc6, 0x72, 0xf7, 0x6b, 0x26, 0xde, 0x72, 0xea, 0x41,
	0x56, 0x71, 0x9d, 0x01, 0xc1, 0x95, 0x4a, 0x46, 0x9c, 0xc3, 0x27, 0x64, 0x0a, 0x31, 0x44, 0xfb,
	0x1a, 0x3a, 0xdd, 0xd1, 0xd4, 0x08, 0x2f, 0xd0, 0xd4, 0x04, 0x0e, 0x7c, 0xce, 0xb9, 0x9b, 0x1a,
	0x5a, 0x2a, 0xcf, 0xa7, 0xb3, 0x7e, 0x3d, 0x8a, 0xe0, 0x94, 0x97, 0x0b, 0xe9, 0x39, 0x9e, 0x48,
	0x6b, 0x10, 0x6d, 0xaa, 0x4b, 0x15, 0x5d, 0x84, 0x61, 0x13, 0x5b, 0x7a, 0xcd, 0x2c, 0x62, 0xb9,
	0x62, 0xea, 0x35, 0xa3, 0x8b, 0xca, 0x52, 0xd4, 0x21, 0xbb, 0x46, 0xa8, 0xc4, 0x34, 0x0c, 0xd6,
	0x89, 0xa9, 0xa9, 0x95, 0x02, 0xfe, 0x2c, 0x61, 0x42, 0x41, 0x52, 0x2d, 0x69, 0x84, 0x5a, 0x66,
	0x5e, 0x6e, 0xf5, 0x42, 0x57, 0x20, 0x4c, 0x7b, 0xa1, 0x56, 0xbe, 0x9c, 0xf2, 0x2f, 0xc4, 0x3a,
	0xb7, 0x88, 0xf6, 0x96, 0xb8, 0x41, 0x2e, 0x8a, 0x05, 0x88, 0x36, 0x5d, 0xa0, 0xde, 0xca, 0x93,
	0xa9, 0xde, 0x58, 0x1c, 0x25, 0xe2, 0xb0, 0x92, 0x6b, 0x6d, 0x7e, 0x13, 0x78, 0xb2, 0x87, 0x10,
	0xb1, 0x60, 0x36, 0x3d, 0xcf, 0xba, 0xbc, 0xd4, 0x1f, 0x04, 0x60, 0x84, 0x42, 0xb8, 0x5a, 0x92,
	0x0c, 0xf0, 0x8e, 0xc2, 0x7d, 0xfe, 0x78, 0x5b, 0x61, 0x09, 0x18, 0x05, 0x3d, 0x79, 0x7e, 0x13,
	0xc6, 0x38, 0xbd, 0xcb, 0xf6, 0x46, 0xb7, 0x16, 0x7a, 0x94, 0xd1, 0x4a, 0x4d, 0xfb, 0x1b, 0xe2,
	0x55, 0x18, 0xab, 0xb7, 0xb1, 0x93, 0xad, 0xeb, 0xed, 0x7e, 0xa3, 0x75, 0x0f, 0x8a, 0x5e, 0x33,
	0xb8, 0xf3, 0xcc, 0xe5, 0xa7, 0xe0, 0x88, 0x17, 0xaa, 0x8b, 0x1b, 0x39, 0x5d, 0xca, 0xcf, 0x11,
	0x1c, 0x65, 0x46, 0x30, 0x70, 0x51, 0x75, 0x0a, 0x1a, 0x6a, 0x8b, 0xaf, 0x4a, 0xb7, 0xe0, 0x21,
	0x75, 0xeb, 0xad, 0x93, 0xcf, 0xc6, 0x7e, 0x8c, 0xe0, 0x88, 0x6b, 0x63, 0x5d, 0x5e, 0x7a, 0xbb,
	0xad, 0xe3, 0x0c, 0x1c, 0xb2, 0xe3, 0xcc, 0x03, 0x0d, 0xde, 0xef, 0xa2, 0x40, 0x0c, 0xb5, 0x77,
	0x9f, 0x6b, 0x10, 0x3a, 0xc0, 0xd9, 0xde, 0xe6, 0x70, 0x6d, 0x80, 0x1c, 0x61, 0x7f, 0xdf, 0xfd,
	0xa3, 0x00, 0xbc, 0xdc, 0xa1, 0xe2, 0x2d, 0xd5, 0xde, 0x21, 0xe7, 0x23, 0xbf, 0xa3, 0x23, 0x90,
	0x24, 0xc5, 0x55, 0xec, 0x66, 0x6d, 0x4a, 0xd3, 0xd1, 0x88, 0x07, 0x5f, 0xb0, 0x11, 0xbf, 0xd2,
	0x34, 0x05, 0xf3, 0xe3, 0x73, 0x3d, 0x4c, 0xd1, 0xee, 0x76, 0x2e, 0x2b, 0x4c, 0x36, 0xad, 0x70,
	0xc4, 0x65, 0x85, 0xfe, 0x6c, 0x7a, 0x3e, 0xbd, 0x40, 0x4a, 0x12, 0x6e, 0x8b, 0x47, 0x41, 0x6e,
	0x0b, 0x12, 0xf6, 0xbe, 0x3d, 0xc2, 0x2c, 0x84, 0x15, 0x42, 0x20, 0x2b, 0xf7, 0x3d, 0x25, 0xe5,
	0x2f, 0x1f, 0x05, 0x87, 0xcc, 0x41, 0x09, 0xcd, 0x49, 0x28, 0x2b, 0xa1, 0x79, 0x69, 0x80, 0x52,
	0xe5, 0xee, 0x8b, 0x9b, 0xbe, 0xed, 0xc1, 0xf4, 0x7e, 0x3b, 0xda, 0xf2, 0xb4, 0x17, 0x68, 0x12,
	0x9e, 0x4f, 0xba, 0x8a, 0xab, 0xff, 0x64, 0x4d, 0xc2, 0x02, 0x6d, 0x12, 0x7e, 0x8e, 0x60, 0xd2,
	0xaf, 0xb4, 0x82, 0x96, 0x7a, 0xf0, 0x4d, 0x6f, 0x87, 0x70, 0x1d, 0xd6, 0x0e, 0xde, 0x21, 0x4c,
	0xc2, 0x98, 0x0f, 0xe1, 0x97, 0xd8, 0x15, 0x78, 0xc9, 0x48, 0x86, 0xe5, 0x59, 0xe8, 0x83, 0x00,
	0x4c, 0x76, 0xdd, 0xc2, 0x9c, 0xc4, 0xef, 0x4f, 0x0d, 0x69, 0x7a, 0x09, 0xcb, 0x5a, 0x6d, 0x77,
	0x1b, 0x9b, 0x74, 0x1f, 0xa3, 0xf9, 0x21, 0x7a, 0x4a, 0x4d, 0x0b, 0xd9, 0x00, 0x0a, 0x4a, 0x40,
	0xe6, 0xd7, 0xe9, 0xf4, 0x57, 0xb3, 0x83, 0x79, 0x88, 0x94, 0x95, 0x5a, 0xd5, 0x96, 0x4b, 0xfa,
	0xae, 0xa2, 0x6a, 0x34, 0x4e, 0xa2, 0xf9, 0xc9, 0x47, 0x7b, 0x08, 0xfd, 0xc7, 0x1e, 0x42, 0xf3,
	0xcd, 0x9c, 0x38, 0x1d, 0x98, 0x42, 0x7c, 0x10, 0x0f, 0x4a, 0x43, 0x94, 0x69, 0x85, 0xf2, 0x88,
	0x2b, 0x10, 0xad, 0x19, 0x25, 0xc5, 0xc6, 0x0e, 0x88, 0xe0, 0x05, 0xb9, 0xe0, 0x0b, 0x32, 0x2e,
	0x45, 0x18, 0x17, 0x43, 0x59, 0x02, 0x5a, 0x73, 0xd3, 0x48, 0x48, 0xfd, 0x4f, 0xbf, 0xcb, 0xff,
	0x7d, 0xbb, 0xaa, 0x43, 0xfb, 0xff, 0x5b, 0xfe, 0x2d, 0xd0, 0xe1, 0xcd, 0xe7, 0x6d, 0x83, 0x6e,
	0x75, 0x69, 0x83, 0x0e, 0x8f, 0xdb, 0xd6, 0x0c, 0x79, 0x42, 0xab, 0xff, 0x60, 0xa1, 0xf5, 0x41,
	0x90, 0xdb, 0xf0, 0x42, 0x7a, 0xfe, 0xf1, 0x1e, 0xfa, 0x9b, 0xe0, 0xfe, 0xc1, 0x55, 0xf2, 0xed,
	0x59, 0xd6, 0xe1, 0xfa, 0x21, 0x1a, 0x91, 0x24, 0x8c, 0xfb, 0x51, 0x7e, 0x15, 0xcd, 0x47, 0x67,
	0xb8, 0x41, 0xc5, 0xbf, 0xf9, 0xd8, 0x80, 0xf5, 0xc3, 0x34, 0x1f, 0x27, 0xe1, 0x88, 0x2f, 0xe9,
	0x57, 0xd4, 0x70, 0xf8, 0xa6, 0x0d, 0x52, 0xf3, 0xff, 0x79, 0xd0, 0x95, 0x36, 0xda, 0x3d, 0xff,
	0x0b, 0xa5, 0x8d, 0xff, 0x6f, 0x8e, 0xdf, 0x9e, 0x91, 0x84, 0x2f, 0x23, 0x23, 0xf5, 0x7f, 0x91,
	0x8c, 0x14, 0x79, 0x76, 0x69, 0x90, 0x67, 0xa4, 0xf4, 0x85, 0xd4, 0x0a, 0x1c, 0xbb, 0xb6, 0xbc,
	0xb1, 0xb5, 0xb1, 0xbc, 0x8e, 0x6d, 0xd2, 0xe3, 0xb9, 0x1a, 0xb2, 0x53, 0x3d, 0x1b, 0x32, 0xd6,
	0x8e, 0x2d, 0x09, 0xcf, 0x2e, 0xa1, 0xb9, 0xd4, 0x5b, 0x70, 0xca, 0x83, 0xe2, 0x6e, 0xfe, 0x5d,
	0x88, 0x53, 0x6d, 0xbd, 0x1b, 0xa2, 0x0f, 0x83, 0x04, 0x12, 0xfd, 0xde, 0x4e, 0x8d, 0xc3, 0x5e,
	0x84, 0x51, 0x0f, 0xec, 0x81, 0xc5, 0x4a, 0xe5, 0x20, 0x7a, 0x6d, 0x79, 0xc3, 0x55, 0x23, 0x9f,
	0xf7, 0xeb, 0x17, 0x3a, 0x98, 0x5d, 0x1d, 0x43, 0xea, 0x8f, 0x11, 0x8c, 0x35, 0x31, 0x5c, 0x4a,
	0x1c, 0xb6, 0xf3, 0xf8, 0x72, 0x9a, 0xce, 0xd4, 0x47, 0x81, 0xb6, 0x9d, 0x72, 0x55, 0xcb, 0x36,
	0xc4, 0x49, 0x4f, 0xa7, 0xb1, 0x09, 0xd9, 0xa7, 0x3f, 0xbe, 0xe8, 0xeb, 0xbf, 0x07, 0xd8, 0xb3,
	0xd5, 0x3e, 0xe9, 0xa8, 0x86, 0x1b, 0x3e, 0x34, 0xe2, 0x4d, 0x18, 0x72, 0xad, 0xca, 0x03, 0x30,
	0xbd, 0xff, 0x42, 0x1e, 0x70, 0x68, 0x81, 0x8b, 0x9b, 0xd0, 0x7c, 0x7a, 0xd3, 0x44, 0x0d, 0xf6,
	0x78, 0x56, 0xd0, 0xe1, 0x1b, 0xab, 0x7d, 0xd2, 0x88, 0x83, 0xc0, 0x2f, 0xe7, 0x4f, 0x34, 0x6b,
	0xd3, 0x51, 0xde, 0x58, 0xd1, 0xda, 0x74, 0x21, 0xdd, 0xaa, 0xd1, 0xff, 0x0d, 0xc1, 0x51, 0x86,
	0xd5, 0xd1, 0x87, 0x14, 0x80, 0x08, 0xe8, 0xcd, 0x31, 0x53, 0xdd, 0x84, 0x69, 0x77, 0x95, 0xd5,
	0x3e, 0x69, 0x50, 0xc3, 0x0d, 0x9e, 0x01, 0x6e, 0xc0, 0x48, 0xdb, 0x4d, 0x93, 0x9e, 0x3d, 0xb3,
	0xc7, 0x7d, 0x57, 0xfb, 0xa4, 0x61, 0xef, 0x83, 0xad, 0xfd, 0x3b, 0x8f, 0xf7, 0x42, 0x30, 0xbe,
	0xa9, 0xda, 0x78, 0xd3, 0x56, 0x6c, 0xb5, 0x28, 0xe9, 0x35, 0x1b, 0x33, 0x07, 0xfe, 0x3e, 0x82,
	0x31, 0x4b, 0xdd, 0x35, 0xaa, 0x58, 0xb6, 0xe8, 0x9c, 0x6c, 0x92, 0x49, 0xee, 0x98, 0x6f, 0xbf,
	0xff, 0x10, 0xdd, 0x9c, 0xb8, 0xc1, 0x8e, 0x52, 0xda, 0x15, 0x5a, 0xaa, 0x8d, 0x33, 0x96, 0x81,
	0x8b, 0x19, 0x55, 0xab, 0x98, 0xd8, 0xb2, 0x64, 0xcc, 0x7e, 0x2a, 0x8d, 0x8c, 0x93, 0x83, 0x5d,
	0x38, 0x56, 0xc6, 0xfd, 0x4f, 0xae, 0xaa, 0x96, 0xdd, 0xf2, 0x73, 0xda, 0x7f, 0xd2, 0xb5, 0x5d,
	0x62, 0x89, 0x5b, 0x30, 0x56, 0xac, 0x59, 0xb6, 0xbe, 0xeb, 0x15, 0x88, 0x99, 0x27, 0xd1, 0x66,
	0x1e, 0x17, 0x23, 0x4b, 0xb7, 0x44, 0x75, 0x82, 0xcb, 0x20, 0x5c, 0xd3, 0x4b, 0x4f, 0x83, 0x8f,
	0xf7, 0xd0, 0x2f, 0x82, 0xb0, 0x0e, 0x40, 0x2f, 0xb0, 0x33, 0xf4, 0x32, 0x5c, 0x82, 0x97, 0x7d,
	0x4d, 0x90, 0x0d, 0x6d, 0xd2, 0x8b, 0x64, 0xda, 0x47, 0xa0, 0x6c, 0x68, 0x99, 0x5e, 0x84, 0x02,
	0x0c, 0x16, 0x36, 0x92, 0xec, 0xb1, 0xc7, 0xf4, 0x6f, 0xc0, 0x12, 0x1c, 0xf1, 0x85, 0x83, 0x93,
	0x70, 0xc2, 0x07, 0x86, 0x9f, 0x8f, 0x56, 0x2a, 0x10, 0x13, 0xe0, 0x7d, 0x04, 0xe1, 0x75, 0x7c,
	0xd7, 0x4e, 0xae, 0xea, 0xc6, 0xf4, 0x5f, 0x22, 0xf8, 0x11, 0x82, 0xaf, 0xc1, 0x05, 0x3f, 0x2e,
	0x0d, 0xdf, 0xb5, 0x77, 0x74, 0xc3, 0xf9, 0x95, 0x95, 0x52, 0x89, 0xec, 0x02, 0x3d, 0x89, 0x33,
	0xe4, 0xcf, 0x17, 0x60, 0x5c, 0x64, 0x8c, 0xaf, 0x40, 0xb2, 0x17, 0xa3, 0x4d, 0xbc, 0x26, 0x90,
	0x44, 0xb0, 0x08, 0x83, 0xcd, 0x93, 0x3b, 0x7f, 0x16, 0xce, 0xf4, 0x62, 0x52, 0x1d, 0xc2, 0x18,
	0x82, 0x59, 0x80, 0x9c, 0x6d, 0x9b, 0xea, 0x36, 0x71, 0x8f, 0x18, 0xca, 0x4f, 0xc2, 0x71, 0x3f,
	0x56, 0xc5, 0xb6, 0x4d, 0x2b, 0x26, 0x9c, 0x47, 0x30, 0x0d, 0xa1, 0xeb, 0xca, 0x36, 0xae, 0x5a,
	0x31, 0xb4, 0x96, 0x80, 0x09, 0x3f, 0xe2, 0x2a, 0x9b, 0x17, 0xf2, 0x67, 0x40, 0x64, 0x0f, 0x1a,
	0xe4, 0x5d, 0x52, 0x3e, 0xf4, 0x0e, 0x8a, 0xef, 0x20, 0x88, 0xb7, 0x07, 0xc5, 0x75, 0xd5, 0x62,
	0x67, 0xc4, 0x1d, 0x18, 0xed, 0x70, 0xdd, 0x38, 0x4a, 0x06, 0xbb, 0xb6, 0xd8, 0x7e, 0xe1, 0x95,
	0x1f, 0xa7, 0xde, 0xfe, 0x1e, 0x0a, 0xc4, 0x2e, 0x3b, 0xa3, 0x30, 0x92, 0x46, 0xac, 0x16, 0x1d,
	0x59, 0x30, 0xf5, 0xcf, 0x00, 0x27, 0xae, 0x55, 0xf5, 0x6d, 0xa5, 0xea, 0xe4, 0x73, 0x5d, 0xd3,
	0x70, 0xd1, 0x56, 0x75, 0x8d, 0x0a, 0xf3, 0xbd, 0x7e, 0x88, 0x59, 0x55, 0x55, 0xb6, 0x75, 0xb9,
	0x42, 0xc9, 0xe4, 0x92, 0xd9, 0x3b, 0x01, 0x51, 0x2a, 0x8e, 0xa2, 0x9b, 0x54, 0x96, 0x9f, 0x0a,
	0xef, 0x3f, 0x44, 0x3f, 0x11, 0x60, 0xb8, 0xae, 0x57, 0x6d, 0xcb, 0x56, 0x8a, 0x77, 0x68, 0x34,
	0x8b, 0x5f, 0xf7, 0x03, 0x50, 0x1a, 0x96, 0x5c, 0x37, 0x8a, 0x2c, 0xde, 0xd9, 0xa3, 0x9f, 0x2d,
	0x87, 0x6d, 0xb9, 0x5a, 0xb3, 0x6c, 0x4c, 0x41, 0xc5, 0xfc, 0x17, 0x64, 0x96, 0xb0, 0x51, 0x55,
	0x78, 0x5e, 0xcd, 0xf9, 0x62, 0xb4, 0xe5, 0x9c, 0x66, 0xc5, 0xe8, 0x2b, 0xc6, 0xf2, 0x0b, 0x41,
	0xf0, 0xa2, 0x73, 0xf5, 0x85, 0x40, 0xdc, 0x1a, 0xad, 0xbd, 0xa0, 0x38, 0x6e, 0x2c, 0xdf, 0xed,
	0xa9, 0x14, 0x8d, 0x96, 0x85, 0xd9, 0x71, 0x75, 0xf0, 0xed, 0x39, 0x00, 0xb3, 0x4b, 0x80, 0xd5,
	0x3e, 0x29, 0x6a, 0x55, 0xd5, 0x37, 0x75, 0xe6, 0x53, 0x2b, 0xa4, 0x4b, 0x8f, 0x59, 0x55, 0xdd,
	0xeb, 0x8c, 0xc1, 0xc3, 0x39, 0x23, 0x03, 0xd5, 0x5d, 0xa0, 0x1b, 0x70, 0xa4, 0xa4, 0x5a, 0xca,
	0x76, 0x15, 0xcb, 0x65, 0xdd, 0x6c, 0x28, 0x66, 0x49, 0x36, 0x4c, 0xfd, 0xee, 0x3d, 0xfe, 0xf6,
	0x82, 0xef, 0xad, 0x30, 0x56, 0x2d, 0xae, 0x22, 0x69, 0x8c, 0xb3, 0x5e, 0x65, 0x9c, 0x1b, 0x84,
	0x51, 0x2c, 0xc2, 0x38, 0xd6, 0x7c, 0x00, 0x43, 0xbe, 0x6f, 0xfd, 0xb8, 0x59, 0x59, 0xd3, 0x44,
	0x83, 0x26, 0x4c, 0xd2, 0x06, 0x5f, 0x45, 0x64, 0x70, 0x6e, 0xca, 0xa5, 0xbf, 0x0d, 0xfc, 0xe3,
	0x1e, 0x3a, 0x05, 0x27, 0x61, 0x82, 0x69, 0x92, 0xe4, 0x01, 0x9c, 0x6c, 0x45, 0xb0, 0x25, 0x06,
	0xe7, 0xd2, 0x0b, 0x8f, 0xf7, 0xd0, 0x83, 0x00, 0xdc, 0x02, 0x81, 0x1e, 0x3b, 0x37, 0xe1, 0x06,
	0x9c, 0xee, 0x8c, 0xe9, 0x6c, 0x8c, 0xf7, 0x90, 0xb6, 0x9e, 0x64, 0x78, 0x70, 0xa6, 0xd3, 0xd8,
	0xd9, 0x51, 0xa7, 0x49, 0x6b, 0x91, 0xad, 0xc1, 0xb0, 0x57, 0x80, 0xec, 0x45, 0x98, 0x68, 0x87,
	0xcf, 0xf0, 0x51, 0x5d, 0x23, 0x73, 0x7a, 0xb7, 0xb9, 0x6f, 0x40, 0x94, 0xeb, 0x98, 0xa4, 0x4a,
	0xc6, 0xd0, 0xf4, 0x55, 0x58, 0x21, 0xfd, 0xa3, 0xef, 0x0e, 0x65, 0xc3, 0x2b, 0xec, 0x72, 0x09,
	0x26, 0xfd, 0x4d, 0x9e, 0x1d, 0xb8, 0x42, 0xaf, 0x96, 0xf2, 0xa7, 0x61, 0xb4, 0xd8, 0x34, 0x4c,
	0xb7, 0xf4, 0x9c, 0x9f, 0x85, 0x71, 0x0f, 0xbf, 0x43, 0x78, 0xec, 0xd1, 0x1e, 0xea, 0xff, 0x90,
	0xbd, 0xb7, 0x23, 0x10, 0xe2, 0x0b, 0xe9, 0xc5, 0xcf, 0x9b, 0xb7, 0x14, 0x79, 0x7b, 0xf9, 0x63,
	0x04, 0x93, 0x5d, 0x72, 0x69, 0x33, 0xb9, 0x7f, 0x1b, 0xc1, 0x04, 0xd7, 0xd7, 0xa9, 0x93, 0x5b,
	0x62, 0x59, 0x3c, 0xcd, 0x9f, 0xef, 0xe1, 0xcc, 0xbe, 0x69, 0xda, 0x95, 0xed, 0xc3, 0xae, 0x6c,
	0x1f, 0xaf, 0xf8, 0xb3, 0x58, 0xa9, 0xbf, 0x0f, 0xc2, 0x48, 0xae, 0x5a, 0xd5, 0x1b, 0xb8, 0xb4,
	0x55, 0xd8, 0xd8, 0xd0, 0x4d, 0xdb, 0x12, 0xdf, 0x82, 0xb8, 0x63, 0x65, 0x85, 0x4d, 0xc9, 0x75,
	0xd5, 0x90, 0x0d, 0xdd, 0xec, 0xf9, 0x5c, 0x3c, 0x2f, 0x90, 0x1e, 0x62, 0xb5, 0x4f, 0x72, 0xf6,
	0xc8, 0xc1, 0x55, 0x0d, 0x82, 0x2b, 0x5e, 0x86, 0x68, 0xcd, 0xc2, 0xf2, 0x8e, 0x6d, 0x73, 0xac,
	0xc0, 0x01, 0xb0, 0x86, 0x6a, 0x16, 0x5e, 0xb5, 0x6d, 0x86, 0x90, 0x87, 0x61, 0x07, 0xc1, 0x62,
	0x10, 0xc1, 0x03, 0x40, 0x44, 0x38, 0x84, 0x45, 0x31, 0x5e, 0x87, 0xb1, 0xa6, 0x14, 0x2e, 0x20,
	0xe1, 0x00, 0x40, 0x31, 0x0e, 0xe4, 0x06, 0x8b, 0xf0, 0x5a, 0x80, 0x80, 0x58, 0x3c, 0x51, 0x24,
	0xfd, 0xef, 0x7f, 0x53, 0x42, 0x6a, 0xe1, 0xbc, 0xf0, 0x39, 0xab, 0x11, 0x87, 0x8a, 0xae, 0x8b,
	0xa7, 0x61, 0x88, 0xa0, 0xc8, 0xae, 0x5b, 0xd7, 0x21, 0xee, 0x92, 0x83, 0x8b, 0x4e, 0x83, 0xcc,
	0xeb, 0x86, 0x4d, 0x18, 0x72, 0xe1, 0x89, 0x97, 0x38, 0xab, 0xa9, 0x68, 0x15, 0x6c, 0xf1, 0xca,
	0xf9, 0x65, 0x5e, 0xe6, 0xc6, 0x1f, 0x08, 0xbc, 0x13, 0x8c, 0x39, 0x7d, 0xdd, 0x87, 0x01, 0x24,
	0x01, 0xe1, 0x90, 0x28, 0x03, 0x07, 0xfd, 0x61, 0x00, 0x5e, 0xba, 0x59, 0x2e, 0x57, 0x55, 0x0d,
	0x6f, 0xd6, 0xcc, 0xba, 0x5a, 0xe7, 0xf7, 0xb3, 0x6e, 0x38, 0xb7, 0x03, 0xbf, 0x01, 0x2f, 0x6b,
	0xba, 0xac, 0x33, 0x12, 0xd9, 0x72, 0xd3, 0xd0, 0x62, 0x67, 0x9f, 0x67, 0x06, 0x13, 0x9a, 0xde,
	0x0d, 0x5e, 0x54, 0xe0, 0x24, 0x0f, 0xdb, 0x1e, 0xf0, 0xbd, 0x1f, 0x00, 0x25, 0x18, 0x40, 0xb7,
	0x25, 0xf2, 0x0b, 0x70, 0xb2, 0x3b, 0xf6, 0x3e, 0x75, 0xda, 0xbf, 0x22, 0x18, 0x59, 0x59, 0xbe,
	0x76, 0x2b, 0x7f, 0x6d, 0x63, 0x03, 0xf3, 0x83, 0xed, 0x3c, 0x0c, 0x2b, 0xbb, 0xca, 0x7d, 0x5d,
	0x73, 0x2a, 0x58, 0xde, 0x7b, 0x0f, 0x72, 0x6b, 0x1b, 0x48, 0x8a, 0x32, 0x82, 0x1c, 0x9b, 0x17,
	0x17, 0x20, 0xc6, 0x36, 0x1c, 0x9b, 0x4d, 0x9e, 0x40, 0x3b, 0xcf, 0x88, 0x43, 0xe2, 0x70, 0x9d,
	0x84, 0xa0, 0x62, 0x39, 0xf7, 0x8c, 0x47, 0x08, 0x21, 0x4c, 0x87, 0xe3, 0xcf, 0x9f, 0x3f, 0x7f,
	0x3e, 0x30, 0x85, 0x24, 0x32, 0x27, 0x2e, 0x40, 0x58, 0xa9, 0xd9, 0x3b, 0xf2, 0x1d, 0x7c, 0x8f,
	0x7b, 0xf2, 0xf1, 0xf6, 0x2e, 0x05, 0x17, 0x4d, 0xd6, 0xbb, 0x49, 0x03, 0x84, 0xf4, 0x75, 0x7c,
	0x2f, 0xf5, 0xa0, 0x1f, 0x46, 0xb6, 0xd4, 0xb2, 0x84, 0x2b, 0xaa, 0xae, 0xb1, 0x03, 0x47, 0xbc,
	0x02, 0x63, 0x96, 0xb2, 0x8b, 0x65, 0xc5, 0xa2, 0x67, 0xb3, 0x6c, 0xd2, 0xc9, 0x7d, 0x2c, 0x1f,
	0x23, 0x2c, 0x39, 0x8b, 0x94, 0x9f, 0x0c, 0x4c, 0xfc, 0x87, 0x00, 0x44, 0x74, 0x7b, 0x07, 0x9b,
	0x0e, 0x00, 0x7b, 0x5d, 0xf0, 0x87, 0x01, 0xe7, 0x36, 0xc3, 0x9f, 0x04, 0xcc, 0xef, 0x05, 0x24,
	0x50, 0xca, 0x33, 0x96, 0x5e, 0xb3, 0x77, 0x66, 0xe6, 0xa4, 0x41, 0xc5, 0x98, 0xc1, 0x8a, 0x65,
	0xcf, 0xcc, 0x49, 0xc3, 0x8a, 0x31, 0xa3, 0xe9, 0xa6, 0xbd, 0xe3, 0xfb, 0x3f, 0x2b, 0x81, 0x62,
	0x34, 0xd9, 0x86, 0x9d, 0xb1, 0x8b, 0xb6, 0xf5, 0x3f, 0xdb, 0xf6, 0x7f, 0x5e, 0x8a, 0x14, 0x95,
	0x99, 0x22, 0xd6, 0x6c, 0x53, 0xa9, 0xce, 0xcc, 0x49, 0x11, 0x5c, 0x73, 0xfd, 0x03, 0x5c, 0x63,
	0xeb, 0xf0, 0x71, 0x53, 0x34, 0x5c, 0x9b, 0x69, 0x60, 0x0a, 0xdf, 0x1c, 0x66, 0x5b, 0xc3, 0x79,
	0x09, 0x76, 0x71, 0x8b, 0xd8, 0x52, 0x1c, 0x3d, 0x06, 0x6b, 0x56, 0xc7, 0x30, 0x4b, 0x87, 0x0e,
	0x9a, 0x33, 0xcc, 0x92, 0x64, 0x40, 0x0d, 0xc6, 0x0d, 0xb8, 0x02, 0xa1, 0xba, 0x5a, 0x96, 0xd5,
	0x12, 0xcd, 0x29, 0x83, 0xf9, 0x19, 0x62, 0xb4, 0x29, 0xf3, 0x95, 0xec, 0xe9, 0x77, 0xa6, 0x4a,
	0x77, 0xeb, 0x6a, 0xb9, 0xf7, 0x4b, 0x74, 0xfd, 0x75, 0xb5, 0x5c, 0x28, 0x2d, 0xa9, 0xcf, 0x2e,
	0x05, 0x2f, 0xd0, 0x47, 0x40, 0x32, 0x14, 0x20, 0xca, 0xb0, 0x93, 0x7a, 0x39, 0xb9, 0x55, 0xb8,
	0x9a, 0xba, 0xe8, 0xbb, 0xd5, 0xe2, 0xd8, 0xa6, 0xb2, 0x8b, 0x93, 0x9c, 0x34, 0x67, 0x25, 0xc9,
	0xae, 0x4e, 0x44, 0x6e, 0x12, 0xd9, 0xf8, 0x55, 0x10, 0x21, 0xb4, 0x55, 0xb8, 0x9a, 0x2c, 0xac,
	0x4c, 0x84, 0x1d, 0x31, 0xf3, 0x53, 0x30, 0x4a, 0x46, 0x0c, 0xc4, 0x89, 0xa6, 0xb1, 0x47, 0x7b,
	0x28, 0xf8, 0x64, 0x0f, 0x05, 0x48, 0x34, 0x79, 0x1e, 0xbe, 0xad, 0x09, 0xe1, 0x40, 0x2c, 0x98,
	0xfa, 0x24, 0x08, 0x63, 0xab, 0xba, 0x65, 0x93, 0xd3, 0xe7, 0x6a, 0xab, 0xe6, 0x11, 0x7f, 0x07,
	0x84, 0xba, 0x5a, 0x66, 0xc7, 0xe0, 0x60, 0xfe, 0x3a, 0xe1, 0x23, 0x06, 0x98, 0x79, 0x0f, 0x4d,
	0xa7, 0x0e, 0x6c, 0x85, 0xe6, 0x51, 0x98, 0x70, 0x46, 0x71, 0x14, 0x47, 0x12, 0x45, 0x16, 0xdf,
	0x82, 0x30, 0x91, 0x97, 0xf6, 0x54, 0x01, 0x7a, 0xd8, 0xfa, 0x3f, 0x77, 0x6d, 0x0b, 0x10, 0xd7,
	0x01, 0xeb, 0x42, 0x95, 0x06, 0xea, 0x6a, 0x99, 0x1c, 0xed, 0xe2, 0xdb, 0x30, 0xd9, 0x34, 0xa6,
	0x65, 0x9b, 0x0a, 0x2d, 0x32, 0xf4, 0x3a, 0x36, 0x65, 0xda, 0x80, 0xb6, 0x1e, 0x6d, 0x76, 0x8b,
	0xa5, 0x97, 0x2c, 0x1e, 0x45, 0x0e, 0xf7, 0xcd, 0x3a, 0x36, 0x0b, 0x9c, 0x57, 0xfc, 0x3d, 0x38,
	0xd3, 0x05, 0xbe, 0xa4, 0x9a, 0xb8, 0x68, 0x3b, 0x35, 0x04, 0x3f, 0x89, 0xce, 0x74, 0x7f, 0x12,
	0x7b, 0x5d, 0xd5, 0xee, 0xe4, 0x56, 0xd6, 0x3d, 0xef, 0x9e, 0x9d, 0xf4, 0x5b, 0x7b, 0x85, 0x02,
	0xf3, 0x9a, 0x21, 0x7f, 0x0e, 0xc6, 0x9d, 0x32, 0xa5, 0x4e, 0x72, 0x27, 0xff, 0x86, 0x80, 0xee,
	0xb4, 0xeb, 0x2d, 0x81, 0x0b, 0x7c, 0xa7, 0x83, 0x31, 0x21, 0xf5, 0x4f, 0xfd, 0x70, 0xcc, 0x03,
	0xe2, 0xda, 0xe7, 0xef, 0x22, 0x38, 0x56, 0x24, 0xe2, 0xc8, 0x4a, 0xa5, 0x62, 0xe2, 0x8a, 0x62,
	0xe3, 0x92, 0xf3, 0xd6, 0x27, 0xdb, 0x7b, 0xe9, 0xfd, 0x87, 0xe8, 0xdc, 0x74, 0xb0, 0x68, 0xda,
	0xd3, 0x03, 0x96, 0xad, 0x54, 0x54, 0xad, 0x32, 0x2d, 0x18, 0xa6, 0x5e, 0x9a, 0x8e, 0x58, 0x7a,
	0xd9, 0xde, 0x56, 0xb4, 0x3b, 0xf2, 0x2e, 0x2e, 0x4e, 0x0f, 0x94, 0x71, 0xc9, 0x54, 0x76, 0x0d,
	0x9a, 0x1f, 0xdf, 0x43, 0x03, 0x29, 0xd7, 0x8d, 0x4c, 0xb2, 0x5b, 0x31, 0xd7, 0x6e, 0x1d, 0xa1,
	0x4b, 0xe6, 0x9a, 0x2b, 0xb2, 0x3b, 0x27, 0xe2, 0x9f, 0x22, 0x78, 0xa9, 0x54, 0x74, 0x4c, 0xe8,
	0x23, 0x51, 0xe0, 0x2b, 0x93, 0xe8, 0x78, 0xa9, 0xc8, 0x8d, 0xd3, 0x21, 0xd5, 0xeb, 0x30, 0xb4,
	0x43, 0x23, 0x44, 0xa6, 0x11, 0x21, 0xf4, 0xe8, 0x72, 0x7c, 0x22, 0x69, 0xb5, 0x4f, 0x02, 0xc6,
	0xbe, 0x45, 0xbc, 0xfe, 0xeb, 0x10, 0xb5, 0x6c, 0x45, 0x2b, 0x91, 0xba, 0x96, 0xc2, 0xf5, 0xf7,
	0x7e, 0x5d, 0xc9, 0x21, 0xa6, 0xcc, 0xaf, 0xc1, 0xe0, 0xae, 0xa2, 0xd5, 0x94, 0xaa, 0x5c, 0x69,
	0xf4, 0x2e, 0x04, 0x3f, 0x63, 0xe5, 0x4d, 0x98, 0x91, 0x5f, 0x6b, 0x88, 0x73, 0xf4, 0x80, 0xd2,
	0x65, 0x72, 0x90, 0xf5, 0xfa, 0xec, 0x03, 0xd1, 0xd3, 0x49, 0xcf, 0x59, 0x9a, 0x38, 0x0d, 0xc0,
	0x6b, 0x2b, 0xc2, 0x34, 0x48, 0x4f, 0xbf, 0xc1, 0xe6, 0xd3, 0x84, 0x55, 0x24, 0x0d, 0xb2, 0xe9,
	0x9c, 0xa5, 0xe5, 0x4f, 0x01, 0x90, 0x60, 0x76, 0x55, 0x4e, 0x8e, 0x2f, 0xf6, 0x2f, 0xa4, 0x2f,
	0xa4, 0x17, 0x89, 0x3c, 0xf9, 0x93, 0x00, 0x8a, 0xe5, 0x49, 0x4d, 0xae, 0x2f, 0x38, 0x5e, 0x6b,
	0x39, 0x2c, 0xfb, 0x72, 0x63, 0x4d, 0x08, 0x43, 0x6c, 0x68, 0x4d, 0x08, 0x0f, 0xc5, 0x22, 0x6b,
	0x42, 0x38, 0x12, 0x8b, 0xa6, 0x30, 0xc4, 0xda, 0x43, 0x47, 0x7c, 0x03, 0x8e, 0x52, 0x67, 0xaa,
	0xaa, 0xda, 0x9d, 0x66, 0x21, 0xef, 0xba, 0x11, 0x7f, 0xe2, 0x83, 0x87, 0x68, 0x38, 0x1c, 0x98,
	0x72, 0xbd, 0x80, 0xca, 0x8f, 0xfa, 0xa9, 0xcb, 0xd2, 0x78, 0x93, 0x95, 0x57, 0xe6, 0xf4, 0x46,
	0xff, 0x4f, 0x11, 0x8c, 0x7a, 0xe2, 0xa5, 0xa0, 0x95, 0x75, 0xf1, 0x35, 0x38, 0xee, 0x0d, 0x71,
	0x99, 0x38, 0x49, 0x43, 0xb9, 0x47, 0xce, 0x08, 0xba, 0x96, 0x74, 0xb4, 0xe4, 0xe6, 0xba, 0xc6,
	0xa6, 0x0b, 0x25, 0x31, 0x0f, 0xa1, 0x7a, 0xa5, 0xd1, 0xfa, 0x26, 0xe0, 0x9c, 0xfb, 0xfb, 0x90,
	0x4a, 0x63, 0xbf, 0x93, 0xa4, 0xd2, 0x28, 0x94, 0xba, 0x14, 0x21, 0xff, 0xfb, 0xfc, 0xf9, 0xf3,
	0x11, 0x5e, 0x84, 0xa4, 0xbe, 0x8f, 0xe0, 0x58, 0xee, 0xd6, 0xe6, 0x7a, 0xee, 0x4d, 0xbe, 0xb4,
	0xeb, 0x8b, 0x97, 0x2d, 0x18, 0xd4, 0x14, 0x5b, 0x66, 0x52, 0xa0, 0xce, 0x4f, 0x56, 0x8e, 0xb8,
	0x44, 0xd2, 0x94, 0x7d, 0xbf, 0xaa, 0x18, 0xd0, 0x14, 0xfb, 0x5a, 0xa3, 0x50, 0xca, 0x1f, 0x6d,
	0xde, 0x75, 0x8e, 0x38, 0x1f, 0x53, 0xfc, 0xf5, 0xc3, 0x66, 0xe6, 0xf9, 0x33, 0x04, 0xa9, 0xdc,
	0xad, 0xcd, 0x2d, 0xd5, 0xb4, 0x6b, 0x4a, 0x75, 0xc3, 0x54, 0xeb, 0x8a, 0x8d, 0x3b, 0x85, 0x7b,
	0xa3, 0x69, 0x9f, 0x7d, 0x24, 0xdb, 0xcf, 0x58, 0xf4, 0x63, 0x9a, 0xca, 0xbe, 0x72, 0xe5, 0xbf,
	0x83, 0x9e, 0x7c, 0x92, 0xe8, 0xfb, 0xe8, 0x93, 0x44, 0xdf, 0xe7, 0x9f, 0x24, 0xd0, 0x83, 0xa7,
	0x09, 0xf4, 0xe3, 0xa7, 0x09, 0xf4, 0xe1, 0xd3, 0x04, 0x7a, 0xf2, 0x34, 0x81, 0x3e, 0x7a, 0x9a,
	0x40, 0x1f, 0x3f, 0x4d, 0xa0, 0xcf, 0x9e, 0x26, 0xfa, 0x3e, 0x7f, 0x9a, 0x40, 0x3f, 0xf8, 0x34,
	0xd1, 0xf7, 0xe8, 0xd3, 0x04, 0x7a, 0xf2, 0x69, 0xa2, 0xef, 0xa3, 0x4f, 0x13, 0x7d, 0xb7, 0x0b,
	0x15, 0xdd, 0xb8, 0x53, 0xc9, 0xd4, 0xf5, 0xaa, 0x8d, 0x4d, 0x53, 0xc9, 0xd4, 0xac, 0x59, 0x3a,
	0x28, 0xeb, 0xe6, 0xee, 0x8c, 0x61, 0xea, 0x75, 0xb5, 0x84, 0xcd, 0x19, 0x67, 0x7a, 0xd6, 0xd8,
	0xae, 0xe8, 0xb3, 0xf8, 0xae, 0xcd, 0x3f, 0xec, 0x72, 0x7f, 0xdf, 0xb5, 0x1d, 0xa2, 0x9f, 0x76,
	0xcd, 0xff, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x63, 0xb5, 0x0f, 0xb7, 0xf8, 0x36, 0x00, 0x00,
}

func (this *AWSVPCParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCParamsType)
	if !ok {
		that2, ok := that.(AWSVPCParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.NameChoice == nil {
		if this.NameChoice != nil {
			return false
		}
	} else if this.NameChoice == nil {
		return false
	} else if !this.NameChoice.Equal(that1.NameChoice) {
		return false
	}
	if this.PrimaryIpv4 != that1.PrimaryIpv4 {
		return false
	}
	if this.AllocateIpv6 != that1.AllocateIpv6 {
		return false
	}
	return true
}
func (this *AWSVPCParamsType_NameTag) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCParamsType_NameTag)
	if !ok {
		that2, ok := that.(AWSVPCParamsType_NameTag)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NameTag != that1.NameTag {
		return false
	}
	return true
}
func (this *AWSVPCParamsType_Autogenerate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCParamsType_Autogenerate)
	if !ok {
		that2, ok := that.(AWSVPCParamsType_Autogenerate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Autogenerate.Equal(that1.Autogenerate) {
		return false
	}
	return true
}
func (this *AWSVPCchoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCchoiceType)
	if !ok {
		that2, ok := that.(AWSVPCchoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *AWSVPCchoiceType_NewVpc) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCchoiceType_NewVpc)
	if !ok {
		that2, ok := that.(AWSVPCchoiceType_NewVpc)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NewVpc.Equal(that1.NewVpc) {
		return false
	}
	return true
}
func (this *AWSVPCchoiceType_VpcId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCchoiceType_VpcId)
	if !ok {
		that2, ok := that.(AWSVPCchoiceType_VpcId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VpcId != that1.VpcId {
		return false
	}
	return true
}
func (this *CloudSubnetParamType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudSubnetParamType)
	if !ok {
		that2, ok := that.(CloudSubnetParamType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ipv4 != that1.Ipv4 {
		return false
	}
	if this.Ipv6 != that1.Ipv6 {
		return false
	}
	return true
}
func (this *CloudSubnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudSubnetType)
	if !ok {
		that2, ok := that.(CloudSubnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *CloudSubnetType_SubnetParam) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudSubnetType_SubnetParam)
	if !ok {
		that2, ok := that.(CloudSubnetType_SubnetParam)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SubnetParam.Equal(that1.SubnetParam) {
		return false
	}
	return true
}
func (this *CloudSubnetType_ExistingSubnetId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudSubnetType_ExistingSubnetId)
	if !ok {
		that2, ok := that.(CloudSubnetType_ExistingSubnetId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExistingSubnetId != that1.ExistingSubnetId {
		return false
	}
	return true
}
func (this *AWSSubnetIdsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSSubnetIdsType)
	if !ok {
		that2, ok := that.(AWSSubnetIdsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AzName != that1.AzName {
		return false
	}
	if this.OutsideSubnetId != that1.OutsideSubnetId {
		return false
	}
	if this.InsideSubnetId != that1.InsideSubnetId {
		return false
	}
	if this.WorkloadSubnetId != that1.WorkloadSubnetId {
		return false
	}
	if !this.OutsideSubnet.Equal(that1.OutsideSubnet) {
		return false
	}
	if !this.InsideSubnet.Equal(that1.InsideSubnet) {
		return false
	}
	if !this.WorkloadSubnet.Equal(that1.WorkloadSubnet) {
		return false
	}
	return true
}
func (this *AWSSubnetInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSSubnetInfoType)
	if !ok {
		that2, ok := that.(AWSSubnetInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AzName != that1.AzName {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Ipv4Prefix != that1.Ipv4Prefix {
		return false
	}
	return true
}
func (this *AWSVPCOneInterfaceNodeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCOneInterfaceNodeType)
	if !ok {
		that2, ok := that.(AWSVPCOneInterfaceNodeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AwsAzName != that1.AwsAzName {
		return false
	}
	if !this.LocalSubnet.Equal(that1.LocalSubnet) {
		return false
	}
	if this.DiskSize != that1.DiskSize {
		return false
	}
	return true
}
func (this *AWSVPCTwoInterfaceNodeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCTwoInterfaceNodeType)
	if !ok {
		that2, ok := that.(AWSVPCTwoInterfaceNodeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AwsAzName != that1.AwsAzName {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	if !this.OutsideSubnet.Equal(that1.OutsideSubnet) {
		return false
	}
	if !this.WorkloadSubnet.Equal(that1.WorkloadSubnet) {
		return false
	}
	if this.DiskSize != that1.DiskSize {
		return false
	}
	return true
}
func (this *AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet)
	if !ok {
		that2, ok := that.(AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ReservedInsideSubnet.Equal(that1.ReservedInsideSubnet) {
		return false
	}
	return true
}
func (this *AWSVPCTwoInterfaceNodeType_InsideSubnet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCTwoInterfaceNodeType_InsideSubnet)
	if !ok {
		that2, ok := that.(AWSVPCTwoInterfaceNodeType_InsideSubnet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InsideSubnet.Equal(that1.InsideSubnet) {
		return false
	}
	return true
}
func (this *AzureVnetParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetParamsType)
	if !ok {
		that2, ok := that.(AzureVnetParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.NameChoice == nil {
		if this.NameChoice != nil {
			return false
		}
	} else if this.NameChoice == nil {
		return false
	} else if !this.NameChoice.Equal(that1.NameChoice) {
		return false
	}
	if this.PrimaryIpv4 != that1.PrimaryIpv4 {
		return false
	}
	return true
}
func (this *AzureVnetParamsType_Name) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetParamsType_Name)
	if !ok {
		that2, ok := that.(AzureVnetParamsType_Name)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *AzureVnetParamsType_Autogenerate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetParamsType_Autogenerate)
	if !ok {
		that2, ok := that.(AzureVnetParamsType_Autogenerate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Autogenerate.Equal(that1.Autogenerate) {
		return false
	}
	return true
}
func (this *AzureVnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetType)
	if !ok {
		that2, ok := that.(AzureVnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ResourceGroup != that1.ResourceGroup {
		return false
	}
	if this.VnetName != that1.VnetName {
		return false
	}
	return true
}
func (this *AzureVnetChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetChoiceType)
	if !ok {
		that2, ok := that.(AzureVnetChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *AzureVnetChoiceType_NewVnet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetChoiceType_NewVnet)
	if !ok {
		that2, ok := that.(AzureVnetChoiceType_NewVnet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NewVnet.Equal(that1.NewVnet) {
		return false
	}
	return true
}
func (this *AzureVnetChoiceType_ExistingVnet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetChoiceType_ExistingVnet)
	if !ok {
		that2, ok := that.(AzureVnetChoiceType_ExistingVnet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExistingVnet.Equal(that1.ExistingVnet) {
		return false
	}
	return true
}
func (this *AzureSubnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetType)
	if !ok {
		that2, ok := that.(AzureSubnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubnetName != that1.SubnetName {
		return false
	}
	if that1.ResourceGroupChoice == nil {
		if this.ResourceGroupChoice != nil {
			return false
		}
	} else if this.ResourceGroupChoice == nil {
		return false
	} else if !this.ResourceGroupChoice.Equal(that1.ResourceGroupChoice) {
		return false
	}
	return true
}
func (this *AzureSubnetType_SubnetResourceGrp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetType_SubnetResourceGrp)
	if !ok {
		that2, ok := that.(AzureSubnetType_SubnetResourceGrp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubnetResourceGrp != that1.SubnetResourceGrp {
		return false
	}
	return true
}
func (this *AzureSubnetType_VnetResourceGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetType_VnetResourceGroup)
	if !ok {
		that2, ok := that.(AzureSubnetType_VnetResourceGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VnetResourceGroup.Equal(that1.VnetResourceGroup) {
		return false
	}
	return true
}
func (this *AzureSpecialSubnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSpecialSubnetType)
	if !ok {
		that2, ok := that.(AzureSpecialSubnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ResourceGroupChoice == nil {
		if this.ResourceGroupChoice != nil {
			return false
		}
	} else if this.ResourceGroupChoice == nil {
		return false
	} else if !this.ResourceGroupChoice.Equal(that1.ResourceGroupChoice) {
		return false
	}
	return true
}
func (this *AzureSpecialSubnetType_SubnetResourceGrp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSpecialSubnetType_SubnetResourceGrp)
	if !ok {
		that2, ok := that.(AzureSpecialSubnetType_SubnetResourceGrp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubnetResourceGrp != that1.SubnetResourceGrp {
		return false
	}
	return true
}
func (this *AzureSpecialSubnetType_VnetResourceGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSpecialSubnetType_VnetResourceGroup)
	if !ok {
		that2, ok := that.(AzureSpecialSubnetType_VnetResourceGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VnetResourceGroup.Equal(that1.VnetResourceGroup) {
		return false
	}
	return true
}
func (this *AzureSubnetChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetChoiceType)
	if !ok {
		that2, ok := that.(AzureSubnetChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *AzureSubnetChoiceType_SubnetParam) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetChoiceType_SubnetParam)
	if !ok {
		that2, ok := that.(AzureSubnetChoiceType_SubnetParam)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SubnetParam.Equal(that1.SubnetParam) {
		return false
	}
	return true
}
func (this *AzureSubnetChoiceType_Subnet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetChoiceType_Subnet)
	if !ok {
		that2, ok := that.(AzureSubnetChoiceType_Subnet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Subnet.Equal(that1.Subnet) {
		return false
	}
	return true
}
func (this *AzureSubnetChoiceWithAutoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetChoiceWithAutoType)
	if !ok {
		that2, ok := that.(AzureSubnetChoiceWithAutoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *AzureSubnetChoiceWithAutoType_Auto) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetChoiceWithAutoType_Auto)
	if !ok {
		that2, ok := that.(AzureSubnetChoiceWithAutoType_Auto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Auto.Equal(that1.Auto) {
		return false
	}
	return true
}
func (this *AzureSubnetChoiceWithAutoType_SubnetParam) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetChoiceWithAutoType_SubnetParam)
	if !ok {
		that2, ok := that.(AzureSubnetChoiceWithAutoType_SubnetParam)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SubnetParam.Equal(that1.SubnetParam) {
		return false
	}
	return true
}
func (this *AzureSubnetChoiceWithAutoType_Subnet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureSubnetChoiceWithAutoType_Subnet)
	if !ok {
		that2, ok := that.(AzureSubnetChoiceWithAutoType_Subnet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Subnet.Equal(that1.Subnet) {
		return false
	}
	return true
}
func (this *AzureVnetOneInterfaceNodeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetOneInterfaceNodeType)
	if !ok {
		that2, ok := that.(AzureVnetOneInterfaceNodeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AzureAz != that1.AzureAz {
		return false
	}
	if !this.LocalSubnet.Equal(that1.LocalSubnet) {
		return false
	}
	if this.DiskSize != that1.DiskSize {
		return false
	}
	return true
}
func (this *AzureVnetOneInterfaceNodeARType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetOneInterfaceNodeARType)
	if !ok {
		that2, ok := that.(AzureVnetOneInterfaceNodeARType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NodeNumber != that1.NodeNumber {
		return false
	}
	if !this.LocalSubnet.Equal(that1.LocalSubnet) {
		return false
	}
	if this.FaultDomain != that1.FaultDomain {
		return false
	}
	if this.UpdateDomain != that1.UpdateDomain {
		return false
	}
	return true
}
func (this *AzureVnetTwoInterfaceNodeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetTwoInterfaceNodeType)
	if !ok {
		that2, ok := that.(AzureVnetTwoInterfaceNodeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AzureAz != that1.AzureAz {
		return false
	}
	if !this.InsideSubnet.Equal(that1.InsideSubnet) {
		return false
	}
	if !this.OutsideSubnet.Equal(that1.OutsideSubnet) {
		return false
	}
	if this.DiskSize != that1.DiskSize {
		return false
	}
	return true
}
func (this *AzureVnetTwoInterfaceNodeARType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetTwoInterfaceNodeARType)
	if !ok {
		that2, ok := that.(AzureVnetTwoInterfaceNodeARType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NodeNumber != that1.NodeNumber {
		return false
	}
	if !this.InsideSubnet.Equal(that1.InsideSubnet) {
		return false
	}
	if !this.OutsideSubnet.Equal(that1.OutsideSubnet) {
		return false
	}
	if this.FaultDomain != that1.FaultDomain {
		return false
	}
	if this.UpdateDomain != that1.UpdateDomain {
		return false
	}
	return true
}
func (this *GCPVPCNetworkParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCNetworkParamsType)
	if !ok {
		that2, ok := that.(GCPVPCNetworkParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *GCPVPCNetworkAutogenerateParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCNetworkAutogenerateParamsType)
	if !ok {
		that2, ok := that.(GCPVPCNetworkAutogenerateParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Autogenerate != that1.Autogenerate {
		return false
	}
	return true
}
func (this *GCPVPCNetworkType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCNetworkType)
	if !ok {
		that2, ok := that.(GCPVPCNetworkType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *GCPSubnetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPSubnetType)
	if !ok {
		that2, ok := that.(GCPSubnetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubnetName != that1.SubnetName {
		return false
	}
	return true
}
func (this *GCPSubnetParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPSubnetParamsType)
	if !ok {
		that2, ok := that.(GCPSubnetParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubnetName != that1.SubnetName {
		return false
	}
	if this.PrimaryIpv4 != that1.PrimaryIpv4 {
		return false
	}
	return true
}
func (this *GCPVPCNetworkChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCNetworkChoiceType)
	if !ok {
		that2, ok := that.(GCPVPCNetworkChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *GCPVPCNetworkChoiceType_NewNetworkAutogenerate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCNetworkChoiceType_NewNetworkAutogenerate)
	if !ok {
		that2, ok := that.(GCPVPCNetworkChoiceType_NewNetworkAutogenerate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NewNetworkAutogenerate.Equal(that1.NewNetworkAutogenerate) {
		return false
	}
	return true
}
func (this *GCPVPCNetworkChoiceType_NewNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCNetworkChoiceType_NewNetwork)
	if !ok {
		that2, ok := that.(GCPVPCNetworkChoiceType_NewNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NewNetwork.Equal(that1.NewNetwork) {
		return false
	}
	return true
}
func (this *GCPVPCNetworkChoiceType_ExistingNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCNetworkChoiceType_ExistingNetwork)
	if !ok {
		that2, ok := that.(GCPVPCNetworkChoiceType_ExistingNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExistingNetwork.Equal(that1.ExistingNetwork) {
		return false
	}
	return true
}
func (this *GCPVPCSubnetChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCSubnetChoiceType)
	if !ok {
		that2, ok := that.(GCPVPCSubnetChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *GCPVPCSubnetChoiceType_NewSubnet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCSubnetChoiceType_NewSubnet)
	if !ok {
		that2, ok := that.(GCPVPCSubnetChoiceType_NewSubnet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NewSubnet.Equal(that1.NewSubnet) {
		return false
	}
	return true
}
func (this *GCPVPCSubnetChoiceType_ExistingSubnet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GCPVPCSubnetChoiceType_ExistingSubnet)
	if !ok {
		that2, ok := that.(GCPVPCSubnetChoiceType_ExistingSubnet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExistingSubnet.Equal(that1.ExistingSubnet) {
		return false
	}
	return true
}
func (this *SiteStaticRoutesType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteStaticRoutesType)
	if !ok {
		that2, ok := that.(SiteStaticRoutesType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ConfigModeChoice == nil {
		if this.ConfigModeChoice != nil {
			return false
		}
	} else if this.ConfigModeChoice == nil {
		return false
	} else if !this.ConfigModeChoice.Equal(that1.ConfigModeChoice) {
		return false
	}
	return true
}
func (this *SiteStaticRoutesType_SimpleStaticRoute) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteStaticRoutesType_SimpleStaticRoute)
	if !ok {
		that2, ok := that.(SiteStaticRoutesType_SimpleStaticRoute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SimpleStaticRoute != that1.SimpleStaticRoute {
		return false
	}
	return true
}
func (this *SiteStaticRoutesType_CustomStaticRoute) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteStaticRoutesType_CustomStaticRoute)
	if !ok {
		that2, ok := that.(SiteStaticRoutesType_CustomStaticRoute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CustomStaticRoute.Equal(that1.CustomStaticRoute) {
		return false
	}
	return true
}
func (this *SiteStaticRoutesListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteStaticRoutesListType)
	if !ok {
		that2, ok := that.(SiteStaticRoutesListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.StaticRouteList) != len(that1.StaticRouteList) {
		return false
	}
	for i := range this.StaticRouteList {
		if !this.StaticRouteList[i].Equal(that1.StaticRouteList[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalNetworkConnectionType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalNetworkConnectionType)
	if !ok {
		that2, ok := that.(GlobalNetworkConnectionType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ConnectionChoice == nil {
		if this.ConnectionChoice != nil {
			return false
		}
	} else if this.ConnectionChoice == nil {
		return false
	} else if !this.ConnectionChoice.Equal(that1.ConnectionChoice) {
		return false
	}
	if that1.ForwardProxyChoice == nil {
		if this.ForwardProxyChoice != nil {
			return false
		}
	} else if this.ForwardProxyChoice == nil {
		return false
	} else if !this.ForwardProxyChoice.Equal(that1.ForwardProxyChoice) {
		return false
	}
	return true
}
func (this *GlobalNetworkConnectionType_SliToGlobalDr) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalNetworkConnectionType_SliToGlobalDr)
	if !ok {
		that2, ok := that.(GlobalNetworkConnectionType_SliToGlobalDr)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SliToGlobalDr.Equal(that1.SliToGlobalDr) {
		return false
	}
	return true
}
func (this *GlobalNetworkConnectionType_SloToGlobalDr) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalNetworkConnectionType_SloToGlobalDr)
	if !ok {
		that2, ok := that.(GlobalNetworkConnectionType_SloToGlobalDr)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SloToGlobalDr.Equal(that1.SloToGlobalDr) {
		return false
	}
	return true
}
func (this *GlobalNetworkConnectionType_DisableForwardProxy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalNetworkConnectionType_DisableForwardProxy)
	if !ok {
		that2, ok := that.(GlobalNetworkConnectionType_DisableForwardProxy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableForwardProxy.Equal(that1.DisableForwardProxy) {
		return false
	}
	return true
}
func (this *GlobalNetworkConnectionType_EnableForwardProxy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalNetworkConnectionType_EnableForwardProxy)
	if !ok {
		that2, ok := that.(GlobalNetworkConnectionType_EnableForwardProxy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableForwardProxy.Equal(that1.EnableForwardProxy) {
		return false
	}
	return true
}
func (this *GlobalNetworkConnectionListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalNetworkConnectionListType)
	if !ok {
		that2, ok := that.(GlobalNetworkConnectionListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.GlobalNetworkConnections) != len(that1.GlobalNetworkConnections) {
		return false
	}
	for i := range this.GlobalNetworkConnections {
		if !this.GlobalNetworkConnections[i].Equal(that1.GlobalNetworkConnections[i]) {
			return false
		}
	}
	return true
}
func (this *AllowedVIPPorts) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AllowedVIPPorts)
	if !ok {
		that2, ok := that.(AllowedVIPPorts)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PortChoice == nil {
		if this.PortChoice != nil {
			return false
		}
	} else if this.PortChoice == nil {
		return false
	} else if !this.PortChoice.Equal(that1.PortChoice) {
		return false
	}
	return true
}
func (this *AllowedVIPPorts_DisableAllowedVipPort) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AllowedVIPPorts_DisableAllowedVipPort)
	if !ok {
		that2, ok := that.(AllowedVIPPorts_DisableAllowedVipPort)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableAllowedVipPort.Equal(that1.DisableAllowedVipPort) {
		return false
	}
	return true
}
func (this *AllowedVIPPorts_UseHttpPort) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AllowedVIPPorts_UseHttpPort)
	if !ok {
		that2, ok := that.(AllowedVIPPorts_UseHttpPort)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UseHttpPort.Equal(that1.UseHttpPort) {
		return false
	}
	return true
}
func (this *AllowedVIPPorts_UseHttpsPort) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AllowedVIPPorts_UseHttpsPort)
	if !ok {
		that2, ok := that.(AllowedVIPPorts_UseHttpsPort)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UseHttpsPort.Equal(that1.UseHttpsPort) {
		return false
	}
	return true
}
func (this *AllowedVIPPorts_UseHttpHttpsPort) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AllowedVIPPorts_UseHttpHttpsPort)
	if !ok {
		that2, ok := that.(AllowedVIPPorts_UseHttpHttpsPort)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UseHttpHttpsPort.Equal(that1.UseHttpHttpsPort) {
		return false
	}
	return true
}
func (this *AllowedVIPPorts_CustomPorts) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AllowedVIPPorts_CustomPorts)
	if !ok {
		that2, ok := that.(AllowedVIPPorts_CustomPorts)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CustomPorts.Equal(that1.CustomPorts) {
		return false
	}
	return true
}
func (this *CustomPorts) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CustomPorts)
	if !ok {
		that2, ok := that.(CustomPorts)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PortRanges != that1.PortRanges {
		return false
	}
	return true
}
func (this *OfflineSurvivabilityModeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OfflineSurvivabilityModeType)
	if !ok {
		that2, ok := that.(OfflineSurvivabilityModeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.OfflineSurvivabilityModeChoice == nil {
		if this.OfflineSurvivabilityModeChoice != nil {
			return false
		}
	} else if this.OfflineSurvivabilityModeChoice == nil {
		return false
	} else if !this.OfflineSurvivabilityModeChoice.Equal(that1.OfflineSurvivabilityModeChoice) {
		return false
	}
	return true
}
func (this *OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode)
	if !ok {
		that2, ok := that.(OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoOfflineSurvivabilityMode.Equal(that1.NoOfflineSurvivabilityMode) {
		return false
	}
	return true
}
func (this *OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode)
	if !ok {
		that2, ok := that.(OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableOfflineSurvivabilityMode.Equal(that1.EnableOfflineSurvivabilityMode) {
		return false
	}
	return true
}
func (this *DCGWBGPPeerType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DCGWBGPPeerType)
	if !ok {
		that2, ok := that.(DCGWBGPPeerType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AmazonAddress != that1.AmazonAddress {
		return false
	}
	if this.CustomerAddress != that1.CustomerAddress {
		return false
	}
	if this.Asn != that1.Asn {
		return false
	}
	if !this.AuthKey.Equal(that1.AuthKey) {
		return false
	}
	return true
}
func (this *VifRegionConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VifRegionConfig)
	if !ok {
		that2, ok := that.(VifRegionConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.VifRegionChoice == nil {
		if this.VifRegionChoice != nil {
			return false
		}
	} else if this.VifRegionChoice == nil {
		return false
	} else if !this.VifRegionChoice.Equal(that1.VifRegionChoice) {
		return false
	}
	if this.VifId != that1.VifId {
		return false
	}
	return true
}
func (this *VifRegionConfig_SameAsSiteRegion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VifRegionConfig_SameAsSiteRegion)
	if !ok {
		that2, ok := that.(VifRegionConfig_SameAsSiteRegion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SameAsSiteRegion.Equal(that1.SameAsSiteRegion) {
		return false
	}
	return true
}
func (this *VifRegionConfig_OtherRegion) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VifRegionConfig_OtherRegion)
	if !ok {
		that2, ok := that.(VifRegionConfig_OtherRegion)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OtherRegion != that1.OtherRegion {
		return false
	}
	return true
}
func (this *HostedVIFConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HostedVIFConfigType)
	if !ok {
		that2, ok := that.(HostedVIFConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Vifs) != len(that1.Vifs) {
		return false
	}
	for i := range this.Vifs {
		if this.Vifs[i] != that1.Vifs[i] {
			return false
		}
	}
	if len(this.VifList) != len(that1.VifList) {
		return false
	}
	for i := range this.VifList {
		if !this.VifList[i].Equal(that1.VifList[i]) {
			return false
		}
	}
	if that1.ConnectivityOptions == nil {
		if this.ConnectivityOptions != nil {
			return false
		}
	} else if this.ConnectivityOptions == nil {
		return false
	} else if !this.ConnectivityOptions.Equal(that1.ConnectivityOptions) {
		return false
	}
	return true
}
func (this *HostedVIFConfigType_SiteRegistrationOverInternet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HostedVIFConfigType_SiteRegistrationOverInternet)
	if !ok {
		that2, ok := that.(HostedVIFConfigType_SiteRegistrationOverInternet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteRegistrationOverInternet.Equal(that1.SiteRegistrationOverInternet) {
		return false
	}
	return true
}
func (this *HostedVIFConfigType_SiteRegistrationOverDirectConnect) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HostedVIFConfigType_SiteRegistrationOverDirectConnect)
	if !ok {
		that2, ok := that.(HostedVIFConfigType_SiteRegistrationOverDirectConnect)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteRegistrationOverDirectConnect.Equal(that1.SiteRegistrationOverDirectConnect) {
		return false
	}
	return true
}
func (this *DirectConnectConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DirectConnectConfigType)
	if !ok {
		that2, ok := that.(DirectConnectConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.CloudAggregatedPrefix) != len(that1.CloudAggregatedPrefix) {
		return false
	}
	for i := range this.CloudAggregatedPrefix {
		if this.CloudAggregatedPrefix[i] != that1.CloudAggregatedPrefix[i] {
			return false
		}
	}
	if len(this.DcConnectAggregatedPrefix) != len(that1.DcConnectAggregatedPrefix) {
		return false
	}
	for i := range this.DcConnectAggregatedPrefix {
		if this.DcConnectAggregatedPrefix[i] != that1.DcConnectAggregatedPrefix[i] {
			return false
		}
	}
	if that1.VifChoice == nil {
		if this.VifChoice != nil {
			return false
		}
	} else if this.VifChoice == nil {
		return false
	} else if !this.VifChoice.Equal(that1.VifChoice) {
		return false
	}
	if that1.AsnChoice == nil {
		if this.AsnChoice != nil {
			return false
		}
	} else if this.AsnChoice == nil {
		return false
	} else if !this.AsnChoice.Equal(that1.AsnChoice) {
		return false
	}
	return true
}
func (this *DirectConnectConfigType_HostedVifs) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DirectConnectConfigType_HostedVifs)
	if !ok {
		that2, ok := that.(DirectConnectConfigType_HostedVifs)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HostedVifs.Equal(that1.HostedVifs) {
		return false
	}
	return true
}
func (this *DirectConnectConfigType_StandardVifs) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DirectConnectConfigType_StandardVifs)
	if !ok {
		that2, ok := that.(DirectConnectConfigType_StandardVifs)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StandardVifs.Equal(that1.StandardVifs) {
		return false
	}
	return true
}
func (this *DirectConnectConfigType_ManualGw) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DirectConnectConfigType_ManualGw)
	if !ok {
		that2, ok := that.(DirectConnectConfigType_ManualGw)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ManualGw.Equal(that1.ManualGw) {
		return false
	}
	return true
}
func (this *DirectConnectConfigType_AutoAsn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DirectConnectConfigType_AutoAsn)
	if !ok {
		that2, ok := that.(DirectConnectConfigType_AutoAsn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AutoAsn.Equal(that1.AutoAsn) {
		return false
	}
	return true
}
func (this *DirectConnectConfigType_CustomAsn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DirectConnectConfigType_CustomAsn)
	if !ok {
		that2, ok := that.(DirectConnectConfigType_CustomAsn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CustomAsn != that1.CustomAsn {
		return false
	}
	return true
}
func (this *CloudLinkADNType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudLinkADNType)
	if !ok {
		that2, ok := that.(CloudLinkADNType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CloudlinkNetworkName != that1.CloudlinkNetworkName {
		return false
	}
	return true
}
func (this *DirectConnectInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DirectConnectInfo)
	if !ok {
		that2, ok := that.(DirectConnectInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DirectConnectGatewayId != that1.DirectConnectGatewayId {
		return false
	}
	if this.VgwId != that1.VgwId {
		return false
	}
	if this.Asn != that1.Asn {
		return false
	}
	return true
}
func (this *AWSNATGatewaychoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSNATGatewaychoiceType)
	if !ok {
		that2, ok := that.(AWSNATGatewaychoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *AWSNATGatewaychoiceType_NatGwId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSNATGatewaychoiceType_NatGwId)
	if !ok {
		that2, ok := that.(AWSNATGatewaychoiceType_NatGwId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NatGwId != that1.NatGwId {
		return false
	}
	return true
}
func (this *AWSVirtualPrivateGatewaychoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVirtualPrivateGatewaychoiceType)
	if !ok {
		that2, ok := that.(AWSVirtualPrivateGatewaychoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *AWSVirtualPrivateGatewaychoiceType_VgwId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVirtualPrivateGatewaychoiceType_VgwId)
	if !ok {
		that2, ok := that.(AWSVirtualPrivateGatewaychoiceType_VgwId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VgwId != that1.VgwId {
		return false
	}
	return true
}
func (this *AWSVPCParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&views.AWSVPCParamsType{")
	if this.NameChoice != nil {
		s = append(s, "NameChoice: "+fmt.Sprintf("%#v", this.NameChoice)+",\n")
	}
	s = append(s, "PrimaryIpv4: "+fmt.Sprintf("%#v", this.PrimaryIpv4)+",\n")
	s = append(s, "AllocateIpv6: "+fmt.Sprintf("%#v", this.AllocateIpv6)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCParamsType_NameTag) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AWSVPCParamsType_NameTag{` +
		`NameTag:` + fmt.Sprintf("%#v", this.NameTag) + `}`}, ", ")
	return s
}
func (this *AWSVPCParamsType_Autogenerate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AWSVPCParamsType_Autogenerate{` +
		`Autogenerate:` + fmt.Sprintf("%#v", this.Autogenerate) + `}`}, ", ")
	return s
}
func (this *AWSVPCchoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.AWSVPCchoiceType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCchoiceType_NewVpc) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AWSVPCchoiceType_NewVpc{` +
		`NewVpc:` + fmt.Sprintf("%#v", this.NewVpc) + `}`}, ", ")
	return s
}
func (this *AWSVPCchoiceType_VpcId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AWSVPCchoiceType_VpcId{` +
		`VpcId:` + fmt.Sprintf("%#v", this.VpcId) + `}`}, ", ")
	return s
}
func (this *CloudSubnetParamType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.CloudSubnetParamType{")
	s = append(s, "Ipv4: "+fmt.Sprintf("%#v", this.Ipv4)+",\n")
	s = append(s, "Ipv6: "+fmt.Sprintf("%#v", this.Ipv6)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudSubnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.CloudSubnetType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudSubnetType_SubnetParam) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.CloudSubnetType_SubnetParam{` +
		`SubnetParam:` + fmt.Sprintf("%#v", this.SubnetParam) + `}`}, ", ")
	return s
}
func (this *CloudSubnetType_ExistingSubnetId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.CloudSubnetType_ExistingSubnetId{` +
		`ExistingSubnetId:` + fmt.Sprintf("%#v", this.ExistingSubnetId) + `}`}, ", ")
	return s
}
func (this *AWSSubnetIdsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&views.AWSSubnetIdsType{")
	s = append(s, "AzName: "+fmt.Sprintf("%#v", this.AzName)+",\n")
	s = append(s, "OutsideSubnetId: "+fmt.Sprintf("%#v", this.OutsideSubnetId)+",\n")
	s = append(s, "InsideSubnetId: "+fmt.Sprintf("%#v", this.InsideSubnetId)+",\n")
	s = append(s, "WorkloadSubnetId: "+fmt.Sprintf("%#v", this.WorkloadSubnetId)+",\n")
	if this.OutsideSubnet != nil {
		s = append(s, "OutsideSubnet: "+fmt.Sprintf("%#v", this.OutsideSubnet)+",\n")
	}
	if this.InsideSubnet != nil {
		s = append(s, "InsideSubnet: "+fmt.Sprintf("%#v", this.InsideSubnet)+",\n")
	}
	if this.WorkloadSubnet != nil {
		s = append(s, "WorkloadSubnet: "+fmt.Sprintf("%#v", this.WorkloadSubnet)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSSubnetInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&views.AWSSubnetInfoType{")
	s = append(s, "AzName: "+fmt.Sprintf("%#v", this.AzName)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Ipv4Prefix: "+fmt.Sprintf("%#v", this.Ipv4Prefix)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCOneInterfaceNodeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&views.AWSVPCOneInterfaceNodeType{")
	s = append(s, "AwsAzName: "+fmt.Sprintf("%#v", this.AwsAzName)+",\n")
	if this.LocalSubnet != nil {
		s = append(s, "LocalSubnet: "+fmt.Sprintf("%#v", this.LocalSubnet)+",\n")
	}
	s = append(s, "DiskSize: "+fmt.Sprintf("%#v", this.DiskSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCTwoInterfaceNodeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&views.AWSVPCTwoInterfaceNodeType{")
	s = append(s, "AwsAzName: "+fmt.Sprintf("%#v", this.AwsAzName)+",\n")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	if this.OutsideSubnet != nil {
		s = append(s, "OutsideSubnet: "+fmt.Sprintf("%#v", this.OutsideSubnet)+",\n")
	}
	if this.WorkloadSubnet != nil {
		s = append(s, "WorkloadSubnet: "+fmt.Sprintf("%#v", this.WorkloadSubnet)+",\n")
	}
	s = append(s, "DiskSize: "+fmt.Sprintf("%#v", this.DiskSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet{` +
		`ReservedInsideSubnet:` + fmt.Sprintf("%#v", this.ReservedInsideSubnet) + `}`}, ", ")
	return s
}
func (this *AWSVPCTwoInterfaceNodeType_InsideSubnet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AWSVPCTwoInterfaceNodeType_InsideSubnet{` +
		`InsideSubnet:` + fmt.Sprintf("%#v", this.InsideSubnet) + `}`}, ", ")
	return s
}
func (this *AzureVnetParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&views.AzureVnetParamsType{")
	if this.NameChoice != nil {
		s = append(s, "NameChoice: "+fmt.Sprintf("%#v", this.NameChoice)+",\n")
	}
	s = append(s, "PrimaryIpv4: "+fmt.Sprintf("%#v", this.PrimaryIpv4)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureVnetParamsType_Name) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureVnetParamsType_Name{` +
		`Name:` + fmt.Sprintf("%#v", this.Name) + `}`}, ", ")
	return s
}
func (this *AzureVnetParamsType_Autogenerate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureVnetParamsType_Autogenerate{` +
		`Autogenerate:` + fmt.Sprintf("%#v", this.Autogenerate) + `}`}, ", ")
	return s
}
func (this *AzureVnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.AzureVnetType{")
	s = append(s, "ResourceGroup: "+fmt.Sprintf("%#v", this.ResourceGroup)+",\n")
	s = append(s, "VnetName: "+fmt.Sprintf("%#v", this.VnetName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureVnetChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.AzureVnetChoiceType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureVnetChoiceType_NewVnet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureVnetChoiceType_NewVnet{` +
		`NewVnet:` + fmt.Sprintf("%#v", this.NewVnet) + `}`}, ", ")
	return s
}
func (this *AzureVnetChoiceType_ExistingVnet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureVnetChoiceType_ExistingVnet{` +
		`ExistingVnet:` + fmt.Sprintf("%#v", this.ExistingVnet) + `}`}, ", ")
	return s
}
func (this *AzureSubnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&views.AzureSubnetType{")
	s = append(s, "SubnetName: "+fmt.Sprintf("%#v", this.SubnetName)+",\n")
	if this.ResourceGroupChoice != nil {
		s = append(s, "ResourceGroupChoice: "+fmt.Sprintf("%#v", this.ResourceGroupChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureSubnetType_SubnetResourceGrp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureSubnetType_SubnetResourceGrp{` +
		`SubnetResourceGrp:` + fmt.Sprintf("%#v", this.SubnetResourceGrp) + `}`}, ", ")
	return s
}
func (this *AzureSubnetType_VnetResourceGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureSubnetType_VnetResourceGroup{` +
		`VnetResourceGroup:` + fmt.Sprintf("%#v", this.VnetResourceGroup) + `}`}, ", ")
	return s
}
func (this *AzureSpecialSubnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.AzureSpecialSubnetType{")
	if this.ResourceGroupChoice != nil {
		s = append(s, "ResourceGroupChoice: "+fmt.Sprintf("%#v", this.ResourceGroupChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureSpecialSubnetType_SubnetResourceGrp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureSpecialSubnetType_SubnetResourceGrp{` +
		`SubnetResourceGrp:` + fmt.Sprintf("%#v", this.SubnetResourceGrp) + `}`}, ", ")
	return s
}
func (this *AzureSpecialSubnetType_VnetResourceGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureSpecialSubnetType_VnetResourceGroup{` +
		`VnetResourceGroup:` + fmt.Sprintf("%#v", this.VnetResourceGroup) + `}`}, ", ")
	return s
}
func (this *AzureSubnetChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.AzureSubnetChoiceType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureSubnetChoiceType_SubnetParam) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureSubnetChoiceType_SubnetParam{` +
		`SubnetParam:` + fmt.Sprintf("%#v", this.SubnetParam) + `}`}, ", ")
	return s
}
func (this *AzureSubnetChoiceType_Subnet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureSubnetChoiceType_Subnet{` +
		`Subnet:` + fmt.Sprintf("%#v", this.Subnet) + `}`}, ", ")
	return s
}
func (this *AzureSubnetChoiceWithAutoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&views.AzureSubnetChoiceWithAutoType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureSubnetChoiceWithAutoType_Auto) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureSubnetChoiceWithAutoType_Auto{` +
		`Auto:` + fmt.Sprintf("%#v", this.Auto) + `}`}, ", ")
	return s
}
func (this *AzureSubnetChoiceWithAutoType_SubnetParam) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureSubnetChoiceWithAutoType_SubnetParam{` +
		`SubnetParam:` + fmt.Sprintf("%#v", this.SubnetParam) + `}`}, ", ")
	return s
}
func (this *AzureSubnetChoiceWithAutoType_Subnet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AzureSubnetChoiceWithAutoType_Subnet{` +
		`Subnet:` + fmt.Sprintf("%#v", this.Subnet) + `}`}, ", ")
	return s
}
func (this *AzureVnetOneInterfaceNodeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&views.AzureVnetOneInterfaceNodeType{")
	s = append(s, "AzureAz: "+fmt.Sprintf("%#v", this.AzureAz)+",\n")
	if this.LocalSubnet != nil {
		s = append(s, "LocalSubnet: "+fmt.Sprintf("%#v", this.LocalSubnet)+",\n")
	}
	s = append(s, "DiskSize: "+fmt.Sprintf("%#v", this.DiskSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureVnetOneInterfaceNodeARType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&views.AzureVnetOneInterfaceNodeARType{")
	s = append(s, "NodeNumber: "+fmt.Sprintf("%#v", this.NodeNumber)+",\n")
	if this.LocalSubnet != nil {
		s = append(s, "LocalSubnet: "+fmt.Sprintf("%#v", this.LocalSubnet)+",\n")
	}
	s = append(s, "FaultDomain: "+fmt.Sprintf("%#v", this.FaultDomain)+",\n")
	s = append(s, "UpdateDomain: "+fmt.Sprintf("%#v", this.UpdateDomain)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureVnetTwoInterfaceNodeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&views.AzureVnetTwoInterfaceNodeType{")
	s = append(s, "AzureAz: "+fmt.Sprintf("%#v", this.AzureAz)+",\n")
	if this.InsideSubnet != nil {
		s = append(s, "InsideSubnet: "+fmt.Sprintf("%#v", this.InsideSubnet)+",\n")
	}
	if this.OutsideSubnet != nil {
		s = append(s, "OutsideSubnet: "+fmt.Sprintf("%#v", this.OutsideSubnet)+",\n")
	}
	s = append(s, "DiskSize: "+fmt.Sprintf("%#v", this.DiskSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureVnetTwoInterfaceNodeARType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&views.AzureVnetTwoInterfaceNodeARType{")
	s = append(s, "NodeNumber: "+fmt.Sprintf("%#v", this.NodeNumber)+",\n")
	if this.InsideSubnet != nil {
		s = append(s, "InsideSubnet: "+fmt.Sprintf("%#v", this.InsideSubnet)+",\n")
	}
	if this.OutsideSubnet != nil {
		s = append(s, "OutsideSubnet: "+fmt.Sprintf("%#v", this.OutsideSubnet)+",\n")
	}
	s = append(s, "FaultDomain: "+fmt.Sprintf("%#v", this.FaultDomain)+",\n")
	s = append(s, "UpdateDomain: "+fmt.Sprintf("%#v", this.UpdateDomain)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPVPCNetworkParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&views.GCPVPCNetworkParamsType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPVPCNetworkAutogenerateParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&views.GCPVPCNetworkAutogenerateParamsType{")
	s = append(s, "Autogenerate: "+fmt.Sprintf("%#v", this.Autogenerate)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPVPCNetworkType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&views.GCPVPCNetworkType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPSubnetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&views.GCPSubnetType{")
	s = append(s, "SubnetName: "+fmt.Sprintf("%#v", this.SubnetName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPSubnetParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.GCPSubnetParamsType{")
	s = append(s, "SubnetName: "+fmt.Sprintf("%#v", this.SubnetName)+",\n")
	s = append(s, "PrimaryIpv4: "+fmt.Sprintf("%#v", this.PrimaryIpv4)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPVPCNetworkChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&views.GCPVPCNetworkChoiceType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPVPCNetworkChoiceType_NewNetworkAutogenerate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GCPVPCNetworkChoiceType_NewNetworkAutogenerate{` +
		`NewNetworkAutogenerate:` + fmt.Sprintf("%#v", this.NewNetworkAutogenerate) + `}`}, ", ")
	return s
}
func (this *GCPVPCNetworkChoiceType_NewNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GCPVPCNetworkChoiceType_NewNetwork{` +
		`NewNetwork:` + fmt.Sprintf("%#v", this.NewNetwork) + `}`}, ", ")
	return s
}
func (this *GCPVPCNetworkChoiceType_ExistingNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GCPVPCNetworkChoiceType_ExistingNetwork{` +
		`ExistingNetwork:` + fmt.Sprintf("%#v", this.ExistingNetwork) + `}`}, ", ")
	return s
}
func (this *GCPVPCSubnetChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.GCPVPCSubnetChoiceType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GCPVPCSubnetChoiceType_NewSubnet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GCPVPCSubnetChoiceType_NewSubnet{` +
		`NewSubnet:` + fmt.Sprintf("%#v", this.NewSubnet) + `}`}, ", ")
	return s
}
func (this *GCPVPCSubnetChoiceType_ExistingSubnet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GCPVPCSubnetChoiceType_ExistingSubnet{` +
		`ExistingSubnet:` + fmt.Sprintf("%#v", this.ExistingSubnet) + `}`}, ", ")
	return s
}
func (this *SiteStaticRoutesType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.SiteStaticRoutesType{")
	if this.ConfigModeChoice != nil {
		s = append(s, "ConfigModeChoice: "+fmt.Sprintf("%#v", this.ConfigModeChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteStaticRoutesType_SimpleStaticRoute) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.SiteStaticRoutesType_SimpleStaticRoute{` +
		`SimpleStaticRoute:` + fmt.Sprintf("%#v", this.SimpleStaticRoute) + `}`}, ", ")
	return s
}
func (this *SiteStaticRoutesType_CustomStaticRoute) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.SiteStaticRoutesType_CustomStaticRoute{` +
		`CustomStaticRoute:` + fmt.Sprintf("%#v", this.CustomStaticRoute) + `}`}, ", ")
	return s
}
func (this *SiteStaticRoutesListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&views.SiteStaticRoutesListType{")
	if this.StaticRouteList != nil {
		s = append(s, "StaticRouteList: "+fmt.Sprintf("%#v", this.StaticRouteList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalNetworkConnectionType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&views.GlobalNetworkConnectionType{")
	if this.ConnectionChoice != nil {
		s = append(s, "ConnectionChoice: "+fmt.Sprintf("%#v", this.ConnectionChoice)+",\n")
	}
	if this.ForwardProxyChoice != nil {
		s = append(s, "ForwardProxyChoice: "+fmt.Sprintf("%#v", this.ForwardProxyChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalNetworkConnectionType_SliToGlobalDr) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GlobalNetworkConnectionType_SliToGlobalDr{` +
		`SliToGlobalDr:` + fmt.Sprintf("%#v", this.SliToGlobalDr) + `}`}, ", ")
	return s
}
func (this *GlobalNetworkConnectionType_SloToGlobalDr) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GlobalNetworkConnectionType_SloToGlobalDr{` +
		`SloToGlobalDr:` + fmt.Sprintf("%#v", this.SloToGlobalDr) + `}`}, ", ")
	return s
}
func (this *GlobalNetworkConnectionType_DisableForwardProxy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GlobalNetworkConnectionType_DisableForwardProxy{` +
		`DisableForwardProxy:` + fmt.Sprintf("%#v", this.DisableForwardProxy) + `}`}, ", ")
	return s
}
func (this *GlobalNetworkConnectionType_EnableForwardProxy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.GlobalNetworkConnectionType_EnableForwardProxy{` +
		`EnableForwardProxy:` + fmt.Sprintf("%#v", this.EnableForwardProxy) + `}`}, ", ")
	return s
}
func (this *GlobalNetworkConnectionListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&views.GlobalNetworkConnectionListType{")
	if this.GlobalNetworkConnections != nil {
		s = append(s, "GlobalNetworkConnections: "+fmt.Sprintf("%#v", this.GlobalNetworkConnections)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AllowedVIPPorts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&views.AllowedVIPPorts{")
	if this.PortChoice != nil {
		s = append(s, "PortChoice: "+fmt.Sprintf("%#v", this.PortChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AllowedVIPPorts_DisableAllowedVipPort) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AllowedVIPPorts_DisableAllowedVipPort{` +
		`DisableAllowedVipPort:` + fmt.Sprintf("%#v", this.DisableAllowedVipPort) + `}`}, ", ")
	return s
}
func (this *AllowedVIPPorts_UseHttpPort) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AllowedVIPPorts_UseHttpPort{` +
		`UseHttpPort:` + fmt.Sprintf("%#v", this.UseHttpPort) + `}`}, ", ")
	return s
}
func (this *AllowedVIPPorts_UseHttpsPort) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AllowedVIPPorts_UseHttpsPort{` +
		`UseHttpsPort:` + fmt.Sprintf("%#v", this.UseHttpsPort) + `}`}, ", ")
	return s
}
func (this *AllowedVIPPorts_UseHttpHttpsPort) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AllowedVIPPorts_UseHttpHttpsPort{` +
		`UseHttpHttpsPort:` + fmt.Sprintf("%#v", this.UseHttpHttpsPort) + `}`}, ", ")
	return s
}
func (this *AllowedVIPPorts_CustomPorts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AllowedVIPPorts_CustomPorts{` +
		`CustomPorts:` + fmt.Sprintf("%#v", this.CustomPorts) + `}`}, ", ")
	return s
}
func (this *CustomPorts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&views.CustomPorts{")
	s = append(s, "PortRanges: "+fmt.Sprintf("%#v", this.PortRanges)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OfflineSurvivabilityModeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&views.OfflineSurvivabilityModeType{")
	if this.OfflineSurvivabilityModeChoice != nil {
		s = append(s, "OfflineSurvivabilityModeChoice: "+fmt.Sprintf("%#v", this.OfflineSurvivabilityModeChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode{` +
		`NoOfflineSurvivabilityMode:` + fmt.Sprintf("%#v", this.NoOfflineSurvivabilityMode) + `}`}, ", ")
	return s
}
func (this *OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode{` +
		`EnableOfflineSurvivabilityMode:` + fmt.Sprintf("%#v", this.EnableOfflineSurvivabilityMode) + `}`}, ", ")
	return s
}
func (this *DCGWBGPPeerType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&views.DCGWBGPPeerType{")
	s = append(s, "AmazonAddress: "+fmt.Sprintf("%#v", this.AmazonAddress)+",\n")
	s = append(s, "CustomerAddress: "+fmt.Sprintf("%#v", this.CustomerAddress)+",\n")
	s = append(s, "Asn: "+fmt.Sprintf("%#v", this.Asn)+",\n")
	if this.AuthKey != nil {
		s = append(s, "AuthKey: "+fmt.Sprintf("%#v", this.AuthKey)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VifRegionConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&views.VifRegionConfig{")
	if this.VifRegionChoice != nil {
		s = append(s, "VifRegionChoice: "+fmt.Sprintf("%#v", this.VifRegionChoice)+",\n")
	}
	s = append(s, "VifId: "+fmt.Sprintf("%#v", this.VifId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VifRegionConfig_SameAsSiteRegion) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.VifRegionConfig_SameAsSiteRegion{` +
		`SameAsSiteRegion:` + fmt.Sprintf("%#v", this.SameAsSiteRegion) + `}`}, ", ")
	return s
}
func (this *VifRegionConfig_OtherRegion) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.VifRegionConfig_OtherRegion{` +
		`OtherRegion:` + fmt.Sprintf("%#v", this.OtherRegion) + `}`}, ", ")
	return s
}
func (this *HostedVIFConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&views.HostedVIFConfigType{")
	s = append(s, "Vifs: "+fmt.Sprintf("%#v", this.Vifs)+",\n")
	if this.VifList != nil {
		s = append(s, "VifList: "+fmt.Sprintf("%#v", this.VifList)+",\n")
	}
	if this.ConnectivityOptions != nil {
		s = append(s, "ConnectivityOptions: "+fmt.Sprintf("%#v", this.ConnectivityOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HostedVIFConfigType_SiteRegistrationOverInternet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.HostedVIFConfigType_SiteRegistrationOverInternet{` +
		`SiteRegistrationOverInternet:` + fmt.Sprintf("%#v", this.SiteRegistrationOverInternet) + `}`}, ", ")
	return s
}
func (this *HostedVIFConfigType_SiteRegistrationOverDirectConnect) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.HostedVIFConfigType_SiteRegistrationOverDirectConnect{` +
		`SiteRegistrationOverDirectConnect:` + fmt.Sprintf("%#v", this.SiteRegistrationOverDirectConnect) + `}`}, ", ")
	return s
}
func (this *DirectConnectConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&views.DirectConnectConfigType{")
	s = append(s, "CloudAggregatedPrefix: "+fmt.Sprintf("%#v", this.CloudAggregatedPrefix)+",\n")
	s = append(s, "DcConnectAggregatedPrefix: "+fmt.Sprintf("%#v", this.DcConnectAggregatedPrefix)+",\n")
	if this.VifChoice != nil {
		s = append(s, "VifChoice: "+fmt.Sprintf("%#v", this.VifChoice)+",\n")
	}
	if this.AsnChoice != nil {
		s = append(s, "AsnChoice: "+fmt.Sprintf("%#v", this.AsnChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DirectConnectConfigType_HostedVifs) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.DirectConnectConfigType_HostedVifs{` +
		`HostedVifs:` + fmt.Sprintf("%#v", this.HostedVifs) + `}`}, ", ")
	return s
}
func (this *DirectConnectConfigType_StandardVifs) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.DirectConnectConfigType_StandardVifs{` +
		`StandardVifs:` + fmt.Sprintf("%#v", this.StandardVifs) + `}`}, ", ")
	return s
}
func (this *DirectConnectConfigType_ManualGw) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.DirectConnectConfigType_ManualGw{` +
		`ManualGw:` + fmt.Sprintf("%#v", this.ManualGw) + `}`}, ", ")
	return s
}
func (this *DirectConnectConfigType_AutoAsn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.DirectConnectConfigType_AutoAsn{` +
		`AutoAsn:` + fmt.Sprintf("%#v", this.AutoAsn) + `}`}, ", ")
	return s
}
func (this *DirectConnectConfigType_CustomAsn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.DirectConnectConfigType_CustomAsn{` +
		`CustomAsn:` + fmt.Sprintf("%#v", this.CustomAsn) + `}`}, ", ")
	return s
}
func (this *CloudLinkADNType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&views.CloudLinkADNType{")
	s = append(s, "CloudlinkNetworkName: "+fmt.Sprintf("%#v", this.CloudlinkNetworkName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DirectConnectInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&views.DirectConnectInfo{")
	s = append(s, "DirectConnectGatewayId: "+fmt.Sprintf("%#v", this.DirectConnectGatewayId)+",\n")
	s = append(s, "VgwId: "+fmt.Sprintf("%#v", this.VgwId)+",\n")
	s = append(s, "Asn: "+fmt.Sprintf("%#v", this.Asn)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSNATGatewaychoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&views.AWSNATGatewaychoiceType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSNATGatewaychoiceType_NatGwId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AWSNATGatewaychoiceType_NatGwId{` +
		`NatGwId:` + fmt.Sprintf("%#v", this.NatGwId) + `}`}, ", ")
	return s
}
func (this *AWSVirtualPrivateGatewaychoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&views.AWSVirtualPrivateGatewaychoiceType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVirtualPrivateGatewaychoiceType_VgwId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&views.AWSVirtualPrivateGatewaychoiceType_VgwId{` +
		`VgwId:` + fmt.Sprintf("%#v", this.VgwId) + `}`}, ", ")
	return s
}
func valueToGoStringSiteTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *AWSVPCParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSVPCParamsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCParamsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NameChoice != nil {
		{
			size := m.NameChoice.Size()
			i -= size
			if _, err := m.NameChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AllocateIpv6 {
		i--
		if m.AllocateIpv6 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.PrimaryIpv4) > 0 {
		i -= len(m.PrimaryIpv4)
		copy(dAtA[i:], m.PrimaryIpv4)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.PrimaryIpv4)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *AWSVPCParamsType_NameTag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCParamsType_NameTag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.NameTag)
	copy(dAtA[i:], m.NameTag)
	i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.NameTag)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *AWSVPCParamsType_Autogenerate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCParamsType_Autogenerate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Autogenerate != nil {
		{
			size, err := m.Autogenerate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *AWSVPCchoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSVPCchoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCchoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSVPCchoiceType_NewVpc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCchoiceType_NewVpc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NewVpc != nil {
		{
			size, err := m.NewVpc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AWSVPCchoiceType_VpcId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCchoiceType_VpcId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.VpcId)
	copy(dAtA[i:], m.VpcId)
	i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.VpcId)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *CloudSubnetParamType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudSubnetParamType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudSubnetParamType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ipv6) > 0 {
		i -= len(m.Ipv6)
		copy(dAtA[i:], m.Ipv6)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.Ipv6)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Ipv4) > 0 {
		i -= len(m.Ipv4)
		copy(dAtA[i:], m.Ipv4)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.Ipv4)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloudSubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudSubnetType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudSubnetType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CloudSubnetType_SubnetParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudSubnetType_SubnetParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SubnetParam != nil {
		{
			size, err := m.SubnetParam.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *CloudSubnetType_ExistingSubnetId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudSubnetType_ExistingSubnetId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ExistingSubnetId)
	copy(dAtA[i:], m.ExistingSubnetId)
	i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.ExistingSubnetId)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *AWSSubnetIdsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSSubnetIdsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSSubnetIdsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WorkloadSubnet != nil {
		{
			size, err := m.WorkloadSubnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.InsideSubnet != nil {
		{
			size, err := m.InsideSubnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.OutsideSubnet != nil {
		{
			size, err := m.OutsideSubnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.WorkloadSubnetId) > 0 {
		i -= len(m.WorkloadSubnetId)
		copy(dAtA[i:], m.WorkloadSubnetId)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.WorkloadSubnetId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.InsideSubnetId) > 0 {
		i -= len(m.InsideSubnetId)
		copy(dAtA[i:], m.InsideSubnetId)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.InsideSubnetId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OutsideSubnetId) > 0 {
		i -= len(m.OutsideSubnetId)
		copy(dAtA[i:], m.OutsideSubnetId)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.OutsideSubnetId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AzName) > 0 {
		i -= len(m.AzName)
		copy(dAtA[i:], m.AzName)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.AzName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWSSubnetInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSSubnetInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSSubnetInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ipv4Prefix) > 0 {
		i -= len(m.Ipv4Prefix)
		copy(dAtA[i:], m.Ipv4Prefix)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.Ipv4Prefix)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AzName) > 0 {
		i -= len(m.AzName)
		copy(dAtA[i:], m.AzName)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.AzName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWSVPCOneInterfaceNodeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSVPCOneInterfaceNodeType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCOneInterfaceNodeType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DiskSize != 0 {
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.DiskSize))
		i--
		dAtA[i] = 0x20
	}
	if m.LocalSubnet != nil {
		{
			size, err := m.LocalSubnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.AwsAzName) > 0 {
		i -= len(m.AwsAzName)
		copy(dAtA[i:], m.AwsAzName)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.AwsAzName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWSVPCTwoInterfaceNodeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSVPCTwoInterfaceNodeType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCTwoInterfaceNodeType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DiskSize != 0 {
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.DiskSize))
		i--
		dAtA[i] = 0x40
	}
	if m.WorkloadSubnet != nil {
		{
			size, err := m.WorkloadSubnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.OutsideSubnet != nil {
		{
			size, err := m.OutsideSubnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AwsAzName) > 0 {
		i -= len(m.AwsAzName)
		copy(dAtA[i:], m.AwsAzName)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.AwsAzName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWSVPCTwoInterfaceNodeType_InsideSubnet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCTwoInterfaceNodeType_InsideSubnet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InsideSubnet != nil {
		{
			size, err := m.InsideSubnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ReservedInsideSubnet != nil {
		{
			size, err := m.ReservedInsideSubnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *AzureVnetParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetParamsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVnetParamsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NameChoice != nil {
		{
			size := m.NameChoice.Size()
			i -= size
			if _, err := m.NameChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.PrimaryIpv4) > 0 {
		i -= len(m.PrimaryIpv4)
		copy(dAtA[i:], m.PrimaryIpv4)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.PrimaryIpv4)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *AzureVnetParamsType_Name) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVnetParamsType_Name) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Name)
	copy(dAtA[i:], m.Name)
	i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.Name)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *AzureVnetParamsType_Autogenerate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVnetParamsType_Autogenerate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Autogenerate != nil {
		{
			size, err := m.Autogenerate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AzureVnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVnetType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VnetName) > 0 {
		i -= len(m.VnetName)
		copy(dAtA[i:], m.VnetName)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.VnetName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ResourceGroup) > 0 {
		i -= len(m.ResourceGroup)
		copy(dAtA[i:], m.ResourceGroup)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.ResourceGroup)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureVnetChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetChoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVnetChoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AzureVnetChoiceType_NewVnet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVnetChoiceType_NewVnet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NewVnet != nil {
		{
			size, err := m.NewVnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AzureVnetChoiceType_ExistingVnet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVnetChoiceType_ExistingVnet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ExistingVnet != nil {
		{
			size, err := m.ExistingVnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AzureSubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureSubnetType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSubnetType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResourceGroupChoice != nil {
		{
			size := m.ResourceGroupChoice.Size()
			i -= size
			if _, err := m.ResourceGroupChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.SubnetName) > 0 {
		i -= len(m.SubnetName)
		copy(dAtA[i:], m.SubnetName)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.SubnetName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureSubnetType_SubnetResourceGrp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSubnetType_SubnetResourceGrp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.SubnetResourceGrp)
	copy(dAtA[i:], m.SubnetResourceGrp)
	i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.SubnetResourceGrp)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *AzureSubnetType_VnetResourceGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSubnetType_VnetResourceGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VnetResourceGroup != nil {
		{
			size, err := m.VnetResourceGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AzureSpecialSubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureSpecialSubnetType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSpecialSubnetType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResourceGroupChoice != nil {
		{
			size := m.ResourceGroupChoice.Size()
			i -= size
			if _, err := m.ResourceGroupChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AzureSpecialSubnetType_SubnetResourceGrp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSpecialSubnetType_SubnetResourceGrp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.SubnetResourceGrp)
	copy(dAtA[i:], m.SubnetResourceGrp)
	i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.SubnetResourceGrp)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *AzureSpecialSubnetType_VnetResourceGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSpecialSubnetType_VnetResourceGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VnetResourceGroup != nil {
		{
			size, err := m.VnetResourceGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AzureSubnetChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureSubnetChoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSubnetChoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AzureSubnetChoiceType_SubnetParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSubnetChoiceType_SubnetParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SubnetParam != nil {
		{
			size, err := m.SubnetParam.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AzureSubnetChoiceType_Subnet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSubnetChoiceType_Subnet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Subnet != nil {
		{
			size, err := m.Subnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AzureSubnetChoiceWithAutoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureSubnetChoiceWithAutoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSubnetChoiceWithAutoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AzureSubnetChoiceWithAutoType_Auto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSubnetChoiceWithAutoType_Auto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Auto != nil {
		{
			size, err := m.Auto.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AzureSubnetChoiceWithAutoType_SubnetParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSubnetChoiceWithAutoType_SubnetParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SubnetParam != nil {
		{
			size, err := m.SubnetParam.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AzureSubnetChoiceWithAutoType_Subnet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureSubnetChoiceWithAutoType_Subnet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Subnet != nil {
		{
			size, err := m.Subnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AzureVnetOneInterfaceNodeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetOneInterfaceNodeType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVnetOneInterfaceNodeType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DiskSize != 0 {
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.DiskSize))
		i--
		dAtA[i] = 0x20
	}
	if m.LocalSubnet != nil {
		{
			size, err := m.LocalSubnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.AzureAz) > 0 {
		i -= len(m.AzureAz)
		copy(dAtA[i:], m.AzureAz)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.AzureAz)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureVnetOneInterfaceNodeARType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetOneInterfaceNodeARType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVnetOneInterfaceNodeARType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateDomain != 0 {
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.UpdateDomain))
		i--
		dAtA[i] = 0x20
	}
	if m.FaultDomain != 0 {
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.FaultDomain))
		i--
		dAtA[i] = 0x18
	}
	if m.LocalSubnet != nil {
		{
			size, err := m.LocalSubnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NodeNumber != 0 {
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.NodeNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AzureVnetTwoInterfaceNodeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetTwoInterfaceNodeType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVnetTwoInterfaceNodeType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DiskSize != 0 {
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.DiskSize))
		i--
		dAtA[i] = 0x28
	}
	if m.OutsideSubnet != nil {
		{
			size, err := m.OutsideSubnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.InsideSubnet != nil {
		{
			size, err := m.InsideSubnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.AzureAz) > 0 {
		i -= len(m.AzureAz)
		copy(dAtA[i:], m.AzureAz)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.AzureAz)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureVnetTwoInterfaceNodeARType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetTwoInterfaceNodeARType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVnetTwoInterfaceNodeARType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateDomain != 0 {
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.UpdateDomain))
		i--
		dAtA[i] = 0x28
	}
	if m.FaultDomain != 0 {
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.FaultDomain))
		i--
		dAtA[i] = 0x20
	}
	if m.OutsideSubnet != nil {
		{
			size, err := m.OutsideSubnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.InsideSubnet != nil {
		{
			size, err := m.InsideSubnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NodeNumber != 0 {
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.NodeNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GCPVPCNetworkParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPVPCNetworkParamsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPVPCNetworkParamsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCPVPCNetworkAutogenerateParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPVPCNetworkAutogenerateParamsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPVPCNetworkAutogenerateParamsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Autogenerate {
		i--
		if m.Autogenerate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GCPVPCNetworkType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPVPCNetworkType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPVPCNetworkType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCPSubnetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPSubnetType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPSubnetType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubnetName) > 0 {
		i -= len(m.SubnetName)
		copy(dAtA[i:], m.SubnetName)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.SubnetName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCPSubnetParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPSubnetParamsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPSubnetParamsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PrimaryIpv4) > 0 {
		i -= len(m.PrimaryIpv4)
		copy(dAtA[i:], m.PrimaryIpv4)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.PrimaryIpv4)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SubnetName) > 0 {
		i -= len(m.SubnetName)
		copy(dAtA[i:], m.SubnetName)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.SubnetName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GCPVPCNetworkChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPVPCNetworkChoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPVPCNetworkChoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GCPVPCNetworkChoiceType_NewNetwork) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPVPCNetworkChoiceType_NewNetwork) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NewNetwork != nil {
		{
			size, err := m.NewNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GCPVPCNetworkChoiceType_ExistingNetwork) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPVPCNetworkChoiceType_ExistingNetwork) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ExistingNetwork != nil {
		{
			size, err := m.ExistingNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GCPVPCNetworkChoiceType_NewNetworkAutogenerate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPVPCNetworkChoiceType_NewNetworkAutogenerate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NewNetworkAutogenerate != nil {
		{
			size, err := m.NewNetworkAutogenerate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *GCPVPCSubnetChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GCPVPCSubnetChoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPVPCSubnetChoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GCPVPCSubnetChoiceType_NewSubnet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPVPCSubnetChoiceType_NewSubnet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NewSubnet != nil {
		{
			size, err := m.NewSubnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GCPVPCSubnetChoiceType_ExistingSubnet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GCPVPCSubnetChoiceType_ExistingSubnet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ExistingSubnet != nil {
		{
			size, err := m.ExistingSubnet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SiteStaticRoutesType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteStaticRoutesType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteStaticRoutesType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConfigModeChoice != nil {
		{
			size := m.ConfigModeChoice.Size()
			i -= size
			if _, err := m.ConfigModeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SiteStaticRoutesType_SimpleStaticRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteStaticRoutesType_SimpleStaticRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.SimpleStaticRoute)
	copy(dAtA[i:], m.SimpleStaticRoute)
	i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.SimpleStaticRoute)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *SiteStaticRoutesType_CustomStaticRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteStaticRoutesType_CustomStaticRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CustomStaticRoute != nil {
		{
			size, err := m.CustomStaticRoute.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SiteStaticRoutesListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteStaticRoutesListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteStaticRoutesListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StaticRouteList) > 0 {
		for iNdEx := len(m.StaticRouteList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StaticRouteList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSiteTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalNetworkConnectionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalNetworkConnectionType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalNetworkConnectionType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ForwardProxyChoice != nil {
		{
			size := m.ForwardProxyChoice.Size()
			i -= size
			if _, err := m.ForwardProxyChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ConnectionChoice != nil {
		{
			size := m.ConnectionChoice.Size()
			i -= size
			if _, err := m.ConnectionChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalNetworkConnectionType_SliToGlobalDr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalNetworkConnectionType_SliToGlobalDr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SliToGlobalDr != nil {
		{
			size, err := m.SliToGlobalDr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GlobalNetworkConnectionType_SloToGlobalDr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalNetworkConnectionType_SloToGlobalDr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SloToGlobalDr != nil {
		{
			size, err := m.SloToGlobalDr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalNetworkConnectionType_DisableForwardProxy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalNetworkConnectionType_DisableForwardProxy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableForwardProxy != nil {
		{
			size, err := m.DisableForwardProxy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalNetworkConnectionType_EnableForwardProxy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalNetworkConnectionType_EnableForwardProxy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableForwardProxy != nil {
		{
			size, err := m.EnableForwardProxy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *GlobalNetworkConnectionListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalNetworkConnectionListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalNetworkConnectionListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GlobalNetworkConnections) > 0 {
		for iNdEx := len(m.GlobalNetworkConnections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GlobalNetworkConnections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSiteTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AllowedVIPPorts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllowedVIPPorts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllowedVIPPorts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PortChoice != nil {
		{
			size := m.PortChoice.Size()
			i -= size
			if _, err := m.PortChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AllowedVIPPorts_UseHttpPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllowedVIPPorts_UseHttpPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UseHttpPort != nil {
		{
			size, err := m.UseHttpPort.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AllowedVIPPorts_UseHttpsPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllowedVIPPorts_UseHttpsPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UseHttpsPort != nil {
		{
			size, err := m.UseHttpsPort.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AllowedVIPPorts_UseHttpHttpsPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllowedVIPPorts_UseHttpHttpsPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UseHttpHttpsPort != nil {
		{
			size, err := m.UseHttpHttpsPort.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AllowedVIPPorts_CustomPorts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllowedVIPPorts_CustomPorts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CustomPorts != nil {
		{
			size, err := m.CustomPorts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *AllowedVIPPorts_DisableAllowedVipPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllowedVIPPorts_DisableAllowedVipPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableAllowedVipPort != nil {
		{
			size, err := m.DisableAllowedVipPort.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *CustomPorts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomPorts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CustomPorts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PortRanges) > 0 {
		i -= len(m.PortRanges)
		copy(dAtA[i:], m.PortRanges)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.PortRanges)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *OfflineSurvivabilityModeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OfflineSurvivabilityModeType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OfflineSurvivabilityModeType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OfflineSurvivabilityModeChoice != nil {
		{
			size := m.OfflineSurvivabilityModeChoice.Size()
			i -= size
			if _, err := m.OfflineSurvivabilityModeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoOfflineSurvivabilityMode != nil {
		{
			size, err := m.NoOfflineSurvivabilityMode.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableOfflineSurvivabilityMode != nil {
		{
			size, err := m.EnableOfflineSurvivabilityMode.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DCGWBGPPeerType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DCGWBGPPeerType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DCGWBGPPeerType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthKey != nil {
		{
			size, err := m.AuthKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Asn != 0 {
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.Asn))
		i--
		dAtA[i] = 0x18
	}
	if len(m.CustomerAddress) > 0 {
		i -= len(m.CustomerAddress)
		copy(dAtA[i:], m.CustomerAddress)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.CustomerAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AmazonAddress) > 0 {
		i -= len(m.AmazonAddress)
		copy(dAtA[i:], m.AmazonAddress)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.AmazonAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VifRegionConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VifRegionConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VifRegionConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VifId) > 0 {
		i -= len(m.VifId)
		copy(dAtA[i:], m.VifId)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.VifId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.VifRegionChoice != nil {
		{
			size := m.VifRegionChoice.Size()
			i -= size
			if _, err := m.VifRegionChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *VifRegionConfig_SameAsSiteRegion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VifRegionConfig_SameAsSiteRegion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SameAsSiteRegion != nil {
		{
			size, err := m.SameAsSiteRegion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *VifRegionConfig_OtherRegion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VifRegionConfig_OtherRegion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.OtherRegion)
	copy(dAtA[i:], m.OtherRegion)
	i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.OtherRegion)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *HostedVIFConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostedVIFConfigType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HostedVIFConfigType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConnectivityOptions != nil {
		{
			size := m.ConnectivityOptions.Size()
			i -= size
			if _, err := m.ConnectivityOptions.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.VifList) > 0 {
		for iNdEx := len(m.VifList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VifList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSiteTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Vifs) > 0 {
		for iNdEx := len(m.Vifs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Vifs[iNdEx])
			copy(dAtA[i:], m.Vifs[iNdEx])
			i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.Vifs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *HostedVIFConfigType_SiteRegistrationOverInternet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HostedVIFConfigType_SiteRegistrationOverInternet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteRegistrationOverInternet != nil {
		{
			size, err := m.SiteRegistrationOverInternet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *HostedVIFConfigType_SiteRegistrationOverDirectConnect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HostedVIFConfigType_SiteRegistrationOverDirectConnect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteRegistrationOverDirectConnect != nil {
		{
			size, err := m.SiteRegistrationOverDirectConnect.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *DirectConnectConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectConnectConfigType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DirectConnectConfigType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AsnChoice != nil {
		{
			size := m.AsnChoice.Size()
			i -= size
			if _, err := m.AsnChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.VifChoice != nil {
		{
			size := m.VifChoice.Size()
			i -= size
			if _, err := m.VifChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.DcConnectAggregatedPrefix) > 0 {
		for iNdEx := len(m.DcConnectAggregatedPrefix) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DcConnectAggregatedPrefix[iNdEx])
			copy(dAtA[i:], m.DcConnectAggregatedPrefix[iNdEx])
			i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.DcConnectAggregatedPrefix[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CloudAggregatedPrefix) > 0 {
		for iNdEx := len(m.CloudAggregatedPrefix) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CloudAggregatedPrefix[iNdEx])
			copy(dAtA[i:], m.CloudAggregatedPrefix[iNdEx])
			i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.CloudAggregatedPrefix[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DirectConnectConfigType_HostedVifs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DirectConnectConfigType_HostedVifs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HostedVifs != nil {
		{
			size, err := m.HostedVifs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DirectConnectConfigType_StandardVifs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DirectConnectConfigType_StandardVifs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StandardVifs != nil {
		{
			size, err := m.StandardVifs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *DirectConnectConfigType_ManualGw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DirectConnectConfigType_ManualGw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ManualGw != nil {
		{
			size, err := m.ManualGw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *DirectConnectConfigType_AutoAsn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DirectConnectConfigType_AutoAsn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AutoAsn != nil {
		{
			size, err := m.AutoAsn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSiteTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *DirectConnectConfigType_CustomAsn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DirectConnectConfigType_CustomAsn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintSiteTypes(dAtA, i, uint64(m.CustomAsn))
	i--
	dAtA[i] = 0x48
	return len(dAtA) - i, nil
}
func (m *CloudLinkADNType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudLinkADNType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudLinkADNType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CloudlinkNetworkName) > 0 {
		i -= len(m.CloudlinkNetworkName)
		copy(dAtA[i:], m.CloudlinkNetworkName)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.CloudlinkNetworkName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DirectConnectInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectConnectInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DirectConnectInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Asn != 0 {
		i = encodeVarintSiteTypes(dAtA, i, uint64(m.Asn))
		i--
		dAtA[i] = 0x18
	}
	if len(m.VgwId) > 0 {
		i -= len(m.VgwId)
		copy(dAtA[i:], m.VgwId)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.VgwId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DirectConnectGatewayId) > 0 {
		i -= len(m.DirectConnectGatewayId)
		copy(dAtA[i:], m.DirectConnectGatewayId)
		i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.DirectConnectGatewayId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWSNATGatewaychoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSNATGatewaychoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSNATGatewaychoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSNATGatewaychoiceType_NatGwId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSNATGatewaychoiceType_NatGwId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.NatGwId)
	copy(dAtA[i:], m.NatGwId)
	i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.NatGwId)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *AWSVirtualPrivateGatewaychoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSVirtualPrivateGatewaychoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVirtualPrivateGatewaychoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSVirtualPrivateGatewaychoiceType_VgwId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVirtualPrivateGatewaychoiceType_VgwId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.VgwId)
	copy(dAtA[i:], m.VgwId)
	i = encodeVarintSiteTypes(dAtA, i, uint64(len(m.VgwId)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func encodeVarintSiteTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovSiteTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AWSVPCParamsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NameChoice != nil {
		n += m.NameChoice.Size()
	}
	l = len(m.PrimaryIpv4)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.AllocateIpv6 {
		n += 2
	}
	return n
}

func (m *AWSVPCParamsType_NameTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NameTag)
	n += 1 + l + sovSiteTypes(uint64(l))
	return n
}
func (m *AWSVPCParamsType_Autogenerate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Autogenerate != nil {
		l = m.Autogenerate.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AWSVPCchoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *AWSVPCchoiceType_NewVpc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewVpc != nil {
		l = m.NewVpc.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AWSVPCchoiceType_VpcId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VpcId)
	n += 1 + l + sovSiteTypes(uint64(l))
	return n
}
func (m *CloudSubnetParamType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ipv4)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	l = len(m.Ipv6)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *CloudSubnetType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *CloudSubnetType_SubnetParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubnetParam != nil {
		l = m.SubnetParam.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *CloudSubnetType_ExistingSubnetId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExistingSubnetId)
	n += 1 + l + sovSiteTypes(uint64(l))
	return n
}
func (m *AWSSubnetIdsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AzName)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	l = len(m.OutsideSubnetId)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	l = len(m.InsideSubnetId)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	l = len(m.WorkloadSubnetId)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.OutsideSubnet != nil {
		l = m.OutsideSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.InsideSubnet != nil {
		l = m.InsideSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.WorkloadSubnet != nil {
		l = m.WorkloadSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *AWSSubnetInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AzName)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	l = len(m.Ipv4Prefix)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *AWSVPCOneInterfaceNodeType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AwsAzName)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.LocalSubnet != nil {
		l = m.LocalSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.DiskSize != 0 {
		n += 1 + sovSiteTypes(uint64(m.DiskSize))
	}
	return n
}

func (m *AWSVPCTwoInterfaceNodeType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AwsAzName)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	if m.OutsideSubnet != nil {
		l = m.OutsideSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.WorkloadSubnet != nil {
		l = m.WorkloadSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.DiskSize != 0 {
		n += 1 + sovSiteTypes(uint64(m.DiskSize))
	}
	return n
}

func (m *AWSVPCTwoInterfaceNodeType_InsideSubnet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InsideSubnet != nil {
		l = m.InsideSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReservedInsideSubnet != nil {
		l = m.ReservedInsideSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AzureVnetParamsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NameChoice != nil {
		n += m.NameChoice.Size()
	}
	l = len(m.PrimaryIpv4)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *AzureVnetParamsType_Name) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovSiteTypes(uint64(l))
	return n
}
func (m *AzureVnetParamsType_Autogenerate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Autogenerate != nil {
		l = m.Autogenerate.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AzureVnetType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceGroup)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	l = len(m.VnetName)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *AzureVnetChoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *AzureVnetChoiceType_NewVnet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewVnet != nil {
		l = m.NewVnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AzureVnetChoiceType_ExistingVnet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExistingVnet != nil {
		l = m.ExistingVnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AzureSubnetType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubnetName)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.ResourceGroupChoice != nil {
		n += m.ResourceGroupChoice.Size()
	}
	return n
}

func (m *AzureSubnetType_SubnetResourceGrp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubnetResourceGrp)
	n += 1 + l + sovSiteTypes(uint64(l))
	return n
}
func (m *AzureSubnetType_VnetResourceGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VnetResourceGroup != nil {
		l = m.VnetResourceGroup.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AzureSpecialSubnetType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResourceGroupChoice != nil {
		n += m.ResourceGroupChoice.Size()
	}
	return n
}

func (m *AzureSpecialSubnetType_SubnetResourceGrp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubnetResourceGrp)
	n += 1 + l + sovSiteTypes(uint64(l))
	return n
}
func (m *AzureSpecialSubnetType_VnetResourceGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VnetResourceGroup != nil {
		l = m.VnetResourceGroup.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AzureSubnetChoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *AzureSubnetChoiceType_SubnetParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubnetParam != nil {
		l = m.SubnetParam.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AzureSubnetChoiceType_Subnet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subnet != nil {
		l = m.Subnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AzureSubnetChoiceWithAutoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *AzureSubnetChoiceWithAutoType_Auto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Auto != nil {
		l = m.Auto.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AzureSubnetChoiceWithAutoType_SubnetParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubnetParam != nil {
		l = m.SubnetParam.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AzureSubnetChoiceWithAutoType_Subnet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subnet != nil {
		l = m.Subnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AzureVnetOneInterfaceNodeType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AzureAz)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.LocalSubnet != nil {
		l = m.LocalSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.DiskSize != 0 {
		n += 1 + sovSiteTypes(uint64(m.DiskSize))
	}
	return n
}

func (m *AzureVnetOneInterfaceNodeARType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeNumber != 0 {
		n += 1 + sovSiteTypes(uint64(m.NodeNumber))
	}
	if m.LocalSubnet != nil {
		l = m.LocalSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.FaultDomain != 0 {
		n += 1 + sovSiteTypes(uint64(m.FaultDomain))
	}
	if m.UpdateDomain != 0 {
		n += 1 + sovSiteTypes(uint64(m.UpdateDomain))
	}
	return n
}

func (m *AzureVnetTwoInterfaceNodeType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AzureAz)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.InsideSubnet != nil {
		l = m.InsideSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.OutsideSubnet != nil {
		l = m.OutsideSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.DiskSize != 0 {
		n += 1 + sovSiteTypes(uint64(m.DiskSize))
	}
	return n
}

func (m *AzureVnetTwoInterfaceNodeARType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeNumber != 0 {
		n += 1 + sovSiteTypes(uint64(m.NodeNumber))
	}
	if m.InsideSubnet != nil {
		l = m.InsideSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.OutsideSubnet != nil {
		l = m.OutsideSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.FaultDomain != 0 {
		n += 1 + sovSiteTypes(uint64(m.FaultDomain))
	}
	if m.UpdateDomain != 0 {
		n += 1 + sovSiteTypes(uint64(m.UpdateDomain))
	}
	return n
}

func (m *GCPVPCNetworkParamsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *GCPVPCNetworkAutogenerateParamsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Autogenerate {
		n += 2
	}
	return n
}

func (m *GCPVPCNetworkType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *GCPSubnetType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubnetName)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *GCPSubnetParamsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubnetName)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	l = len(m.PrimaryIpv4)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *GCPVPCNetworkChoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *GCPVPCNetworkChoiceType_NewNetwork) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewNetwork != nil {
		l = m.NewNetwork.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *GCPVPCNetworkChoiceType_ExistingNetwork) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExistingNetwork != nil {
		l = m.ExistingNetwork.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *GCPVPCNetworkChoiceType_NewNetworkAutogenerate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewNetworkAutogenerate != nil {
		l = m.NewNetworkAutogenerate.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *GCPVPCSubnetChoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *GCPVPCSubnetChoiceType_NewSubnet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewSubnet != nil {
		l = m.NewSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *GCPVPCSubnetChoiceType_ExistingSubnet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExistingSubnet != nil {
		l = m.ExistingSubnet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *SiteStaticRoutesType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfigModeChoice != nil {
		n += m.ConfigModeChoice.Size()
	}
	return n
}

func (m *SiteStaticRoutesType_SimpleStaticRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SimpleStaticRoute)
	n += 1 + l + sovSiteTypes(uint64(l))
	return n
}
func (m *SiteStaticRoutesType_CustomStaticRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CustomStaticRoute != nil {
		l = m.CustomStaticRoute.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *SiteStaticRoutesListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StaticRouteList) > 0 {
		for _, e := range m.StaticRouteList {
			l = e.Size()
			n += 1 + l + sovSiteTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalNetworkConnectionType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConnectionChoice != nil {
		n += m.ConnectionChoice.Size()
	}
	if m.ForwardProxyChoice != nil {
		n += m.ForwardProxyChoice.Size()
	}
	return n
}

func (m *GlobalNetworkConnectionType_SliToGlobalDr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SliToGlobalDr != nil {
		l = m.SliToGlobalDr.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *GlobalNetworkConnectionType_SloToGlobalDr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SloToGlobalDr != nil {
		l = m.SloToGlobalDr.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *GlobalNetworkConnectionType_DisableForwardProxy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableForwardProxy != nil {
		l = m.DisableForwardProxy.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *GlobalNetworkConnectionType_EnableForwardProxy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableForwardProxy != nil {
		l = m.EnableForwardProxy.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *GlobalNetworkConnectionListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.GlobalNetworkConnections) > 0 {
		for _, e := range m.GlobalNetworkConnections {
			l = e.Size()
			n += 1 + l + sovSiteTypes(uint64(l))
		}
	}
	return n
}

func (m *AllowedVIPPorts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortChoice != nil {
		n += m.PortChoice.Size()
	}
	return n
}

func (m *AllowedVIPPorts_UseHttpPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseHttpPort != nil {
		l = m.UseHttpPort.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AllowedVIPPorts_UseHttpsPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseHttpsPort != nil {
		l = m.UseHttpsPort.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AllowedVIPPorts_UseHttpHttpsPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseHttpHttpsPort != nil {
		l = m.UseHttpHttpsPort.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AllowedVIPPorts_CustomPorts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CustomPorts != nil {
		l = m.CustomPorts.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *AllowedVIPPorts_DisableAllowedVipPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableAllowedVipPort != nil {
		l = m.DisableAllowedVipPort.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *CustomPorts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortRanges)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *OfflineSurvivabilityModeType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OfflineSurvivabilityModeChoice != nil {
		n += m.OfflineSurvivabilityModeChoice.Size()
	}
	return n
}

func (m *OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoOfflineSurvivabilityMode != nil {
		l = m.NoOfflineSurvivabilityMode.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableOfflineSurvivabilityMode != nil {
		l = m.EnableOfflineSurvivabilityMode.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *DCGWBGPPeerType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AmazonAddress)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	l = len(m.CustomerAddress)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.Asn != 0 {
		n += 1 + sovSiteTypes(uint64(m.Asn))
	}
	if m.AuthKey != nil {
		l = m.AuthKey.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *VifRegionConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VifRegionChoice != nil {
		n += m.VifRegionChoice.Size()
	}
	l = len(m.VifId)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *VifRegionConfig_SameAsSiteRegion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SameAsSiteRegion != nil {
		l = m.SameAsSiteRegion.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *VifRegionConfig_OtherRegion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OtherRegion)
	n += 1 + l + sovSiteTypes(uint64(l))
	return n
}
func (m *HostedVIFConfigType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Vifs) > 0 {
		for _, s := range m.Vifs {
			l = len(s)
			n += 1 + l + sovSiteTypes(uint64(l))
		}
	}
	if len(m.VifList) > 0 {
		for _, e := range m.VifList {
			l = e.Size()
			n += 1 + l + sovSiteTypes(uint64(l))
		}
	}
	if m.ConnectivityOptions != nil {
		n += m.ConnectivityOptions.Size()
	}
	return n
}

func (m *HostedVIFConfigType_SiteRegistrationOverInternet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteRegistrationOverInternet != nil {
		l = m.SiteRegistrationOverInternet.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *HostedVIFConfigType_SiteRegistrationOverDirectConnect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteRegistrationOverDirectConnect != nil {
		l = m.SiteRegistrationOverDirectConnect.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *DirectConnectConfigType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CloudAggregatedPrefix) > 0 {
		for _, s := range m.CloudAggregatedPrefix {
			l = len(s)
			n += 1 + l + sovSiteTypes(uint64(l))
		}
	}
	if len(m.DcConnectAggregatedPrefix) > 0 {
		for _, s := range m.DcConnectAggregatedPrefix {
			l = len(s)
			n += 1 + l + sovSiteTypes(uint64(l))
		}
	}
	if m.VifChoice != nil {
		n += m.VifChoice.Size()
	}
	if m.AsnChoice != nil {
		n += m.AsnChoice.Size()
	}
	return n
}

func (m *DirectConnectConfigType_HostedVifs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HostedVifs != nil {
		l = m.HostedVifs.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *DirectConnectConfigType_StandardVifs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StandardVifs != nil {
		l = m.StandardVifs.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *DirectConnectConfigType_ManualGw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ManualGw != nil {
		l = m.ManualGw.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *DirectConnectConfigType_AutoAsn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AutoAsn != nil {
		l = m.AutoAsn.Size()
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}
func (m *DirectConnectConfigType_CustomAsn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSiteTypes(uint64(m.CustomAsn))
	return n
}
func (m *CloudLinkADNType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CloudlinkNetworkName)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	return n
}

func (m *DirectConnectInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DirectConnectGatewayId)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	l = len(m.VgwId)
	if l > 0 {
		n += 1 + l + sovSiteTypes(uint64(l))
	}
	if m.Asn != 0 {
		n += 1 + sovSiteTypes(uint64(m.Asn))
	}
	return n
}

func (m *AWSNATGatewaychoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *AWSNATGatewaychoiceType_NatGwId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NatGwId)
	n += 1 + l + sovSiteTypes(uint64(l))
	return n
}
func (m *AWSVirtualPrivateGatewaychoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *AWSVirtualPrivateGatewaychoiceType_VgwId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VgwId)
	n += 1 + l + sovSiteTypes(uint64(l))
	return n
}

func sovSiteTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSiteTypes(x uint64) (n int) {
	return sovSiteTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AWSVPCParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCParamsType{`,
		`NameChoice:` + fmt.Sprintf("%v", this.NameChoice) + `,`,
		`PrimaryIpv4:` + fmt.Sprintf("%v", this.PrimaryIpv4) + `,`,
		`AllocateIpv6:` + fmt.Sprintf("%v", this.AllocateIpv6) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCParamsType_NameTag) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCParamsType_NameTag{`,
		`NameTag:` + fmt.Sprintf("%v", this.NameTag) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCParamsType_Autogenerate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCParamsType_Autogenerate{`,
		`Autogenerate:` + strings.Replace(fmt.Sprintf("%v", this.Autogenerate), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCchoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCchoiceType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCchoiceType_NewVpc) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCchoiceType_NewVpc{`,
		`NewVpc:` + strings.Replace(fmt.Sprintf("%v", this.NewVpc), "AWSVPCParamsType", "AWSVPCParamsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCchoiceType_VpcId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCchoiceType_VpcId{`,
		`VpcId:` + fmt.Sprintf("%v", this.VpcId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudSubnetParamType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudSubnetParamType{`,
		`Ipv4:` + fmt.Sprintf("%v", this.Ipv4) + `,`,
		`Ipv6:` + fmt.Sprintf("%v", this.Ipv6) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudSubnetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudSubnetType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudSubnetType_SubnetParam) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudSubnetType_SubnetParam{`,
		`SubnetParam:` + strings.Replace(fmt.Sprintf("%v", this.SubnetParam), "CloudSubnetParamType", "CloudSubnetParamType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudSubnetType_ExistingSubnetId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudSubnetType_ExistingSubnetId{`,
		`ExistingSubnetId:` + fmt.Sprintf("%v", this.ExistingSubnetId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSSubnetIdsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSSubnetIdsType{`,
		`AzName:` + fmt.Sprintf("%v", this.AzName) + `,`,
		`OutsideSubnetId:` + fmt.Sprintf("%v", this.OutsideSubnetId) + `,`,
		`InsideSubnetId:` + fmt.Sprintf("%v", this.InsideSubnetId) + `,`,
		`WorkloadSubnetId:` + fmt.Sprintf("%v", this.WorkloadSubnetId) + `,`,
		`OutsideSubnet:` + strings.Replace(this.OutsideSubnet.String(), "AWSSubnetInfoType", "AWSSubnetInfoType", 1) + `,`,
		`InsideSubnet:` + strings.Replace(this.InsideSubnet.String(), "AWSSubnetInfoType", "AWSSubnetInfoType", 1) + `,`,
		`WorkloadSubnet:` + strings.Replace(this.WorkloadSubnet.String(), "AWSSubnetInfoType", "AWSSubnetInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSSubnetInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSSubnetInfoType{`,
		`AzName:` + fmt.Sprintf("%v", this.AzName) + `,`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Ipv4Prefix:` + fmt.Sprintf("%v", this.Ipv4Prefix) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCOneInterfaceNodeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCOneInterfaceNodeType{`,
		`AwsAzName:` + fmt.Sprintf("%v", this.AwsAzName) + `,`,
		`LocalSubnet:` + strings.Replace(this.LocalSubnet.String(), "CloudSubnetType", "CloudSubnetType", 1) + `,`,
		`DiskSize:` + fmt.Sprintf("%v", this.DiskSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCTwoInterfaceNodeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCTwoInterfaceNodeType{`,
		`AwsAzName:` + fmt.Sprintf("%v", this.AwsAzName) + `,`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`OutsideSubnet:` + strings.Replace(this.OutsideSubnet.String(), "CloudSubnetType", "CloudSubnetType", 1) + `,`,
		`WorkloadSubnet:` + strings.Replace(this.WorkloadSubnet.String(), "CloudSubnetType", "CloudSubnetType", 1) + `,`,
		`DiskSize:` + fmt.Sprintf("%v", this.DiskSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCTwoInterfaceNodeType_InsideSubnet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCTwoInterfaceNodeType_InsideSubnet{`,
		`InsideSubnet:` + strings.Replace(fmt.Sprintf("%v", this.InsideSubnet), "CloudSubnetType", "CloudSubnetType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet{`,
		`ReservedInsideSubnet:` + strings.Replace(fmt.Sprintf("%v", this.ReservedInsideSubnet), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetParamsType{`,
		`NameChoice:` + fmt.Sprintf("%v", this.NameChoice) + `,`,
		`PrimaryIpv4:` + fmt.Sprintf("%v", this.PrimaryIpv4) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetParamsType_Name) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetParamsType_Name{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetParamsType_Autogenerate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetParamsType_Autogenerate{`,
		`Autogenerate:` + strings.Replace(fmt.Sprintf("%v", this.Autogenerate), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetType{`,
		`ResourceGroup:` + fmt.Sprintf("%v", this.ResourceGroup) + `,`,
		`VnetName:` + fmt.Sprintf("%v", this.VnetName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetChoiceType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetChoiceType_NewVnet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetChoiceType_NewVnet{`,
		`NewVnet:` + strings.Replace(fmt.Sprintf("%v", this.NewVnet), "AzureVnetParamsType", "AzureVnetParamsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetChoiceType_ExistingVnet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetChoiceType_ExistingVnet{`,
		`ExistingVnet:` + strings.Replace(fmt.Sprintf("%v", this.ExistingVnet), "AzureVnetType", "AzureVnetType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetType{`,
		`SubnetName:` + fmt.Sprintf("%v", this.SubnetName) + `,`,
		`ResourceGroupChoice:` + fmt.Sprintf("%v", this.ResourceGroupChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetType_SubnetResourceGrp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetType_SubnetResourceGrp{`,
		`SubnetResourceGrp:` + fmt.Sprintf("%v", this.SubnetResourceGrp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetType_VnetResourceGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetType_VnetResourceGroup{`,
		`VnetResourceGroup:` + strings.Replace(fmt.Sprintf("%v", this.VnetResourceGroup), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSpecialSubnetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSpecialSubnetType{`,
		`ResourceGroupChoice:` + fmt.Sprintf("%v", this.ResourceGroupChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSpecialSubnetType_SubnetResourceGrp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSpecialSubnetType_SubnetResourceGrp{`,
		`SubnetResourceGrp:` + fmt.Sprintf("%v", this.SubnetResourceGrp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSpecialSubnetType_VnetResourceGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSpecialSubnetType_VnetResourceGroup{`,
		`VnetResourceGroup:` + strings.Replace(fmt.Sprintf("%v", this.VnetResourceGroup), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetChoiceType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetChoiceType_SubnetParam) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetChoiceType_SubnetParam{`,
		`SubnetParam:` + strings.Replace(fmt.Sprintf("%v", this.SubnetParam), "CloudSubnetParamType", "CloudSubnetParamType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetChoiceType_Subnet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetChoiceType_Subnet{`,
		`Subnet:` + strings.Replace(fmt.Sprintf("%v", this.Subnet), "AzureSubnetType", "AzureSubnetType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetChoiceWithAutoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetChoiceWithAutoType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetChoiceWithAutoType_Auto) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetChoiceWithAutoType_Auto{`,
		`Auto:` + strings.Replace(fmt.Sprintf("%v", this.Auto), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetChoiceWithAutoType_SubnetParam) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetChoiceWithAutoType_SubnetParam{`,
		`SubnetParam:` + strings.Replace(fmt.Sprintf("%v", this.SubnetParam), "CloudSubnetParamType", "CloudSubnetParamType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureSubnetChoiceWithAutoType_Subnet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureSubnetChoiceWithAutoType_Subnet{`,
		`Subnet:` + strings.Replace(fmt.Sprintf("%v", this.Subnet), "AzureSpecialSubnetType", "AzureSpecialSubnetType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetOneInterfaceNodeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetOneInterfaceNodeType{`,
		`AzureAz:` + fmt.Sprintf("%v", this.AzureAz) + `,`,
		`LocalSubnet:` + strings.Replace(this.LocalSubnet.String(), "AzureSubnetChoiceType", "AzureSubnetChoiceType", 1) + `,`,
		`DiskSize:` + fmt.Sprintf("%v", this.DiskSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetOneInterfaceNodeARType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetOneInterfaceNodeARType{`,
		`NodeNumber:` + fmt.Sprintf("%v", this.NodeNumber) + `,`,
		`LocalSubnet:` + strings.Replace(this.LocalSubnet.String(), "AzureSubnetChoiceType", "AzureSubnetChoiceType", 1) + `,`,
		`FaultDomain:` + fmt.Sprintf("%v", this.FaultDomain) + `,`,
		`UpdateDomain:` + fmt.Sprintf("%v", this.UpdateDomain) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetTwoInterfaceNodeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetTwoInterfaceNodeType{`,
		`AzureAz:` + fmt.Sprintf("%v", this.AzureAz) + `,`,
		`InsideSubnet:` + strings.Replace(this.InsideSubnet.String(), "AzureSubnetChoiceType", "AzureSubnetChoiceType", 1) + `,`,
		`OutsideSubnet:` + strings.Replace(this.OutsideSubnet.String(), "AzureSubnetChoiceType", "AzureSubnetChoiceType", 1) + `,`,
		`DiskSize:` + fmt.Sprintf("%v", this.DiskSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetTwoInterfaceNodeARType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVnetTwoInterfaceNodeARType{`,
		`NodeNumber:` + fmt.Sprintf("%v", this.NodeNumber) + `,`,
		`InsideSubnet:` + strings.Replace(this.InsideSubnet.String(), "AzureSubnetChoiceType", "AzureSubnetChoiceType", 1) + `,`,
		`OutsideSubnet:` + strings.Replace(this.OutsideSubnet.String(), "AzureSubnetChoiceType", "AzureSubnetChoiceType", 1) + `,`,
		`FaultDomain:` + fmt.Sprintf("%v", this.FaultDomain) + `,`,
		`UpdateDomain:` + fmt.Sprintf("%v", this.UpdateDomain) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCNetworkParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCNetworkParamsType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCNetworkAutogenerateParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCNetworkAutogenerateParamsType{`,
		`Autogenerate:` + fmt.Sprintf("%v", this.Autogenerate) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCNetworkType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCNetworkType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPSubnetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPSubnetType{`,
		`SubnetName:` + fmt.Sprintf("%v", this.SubnetName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPSubnetParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPSubnetParamsType{`,
		`SubnetName:` + fmt.Sprintf("%v", this.SubnetName) + `,`,
		`PrimaryIpv4:` + fmt.Sprintf("%v", this.PrimaryIpv4) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCNetworkChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCNetworkChoiceType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCNetworkChoiceType_NewNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCNetworkChoiceType_NewNetwork{`,
		`NewNetwork:` + strings.Replace(fmt.Sprintf("%v", this.NewNetwork), "GCPVPCNetworkParamsType", "GCPVPCNetworkParamsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCNetworkChoiceType_ExistingNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCNetworkChoiceType_ExistingNetwork{`,
		`ExistingNetwork:` + strings.Replace(fmt.Sprintf("%v", this.ExistingNetwork), "GCPVPCNetworkType", "GCPVPCNetworkType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCNetworkChoiceType_NewNetworkAutogenerate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCNetworkChoiceType_NewNetworkAutogenerate{`,
		`NewNetworkAutogenerate:` + strings.Replace(fmt.Sprintf("%v", this.NewNetworkAutogenerate), "GCPVPCNetworkAutogenerateParamsType", "GCPVPCNetworkAutogenerateParamsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCSubnetChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCSubnetChoiceType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCSubnetChoiceType_NewSubnet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCSubnetChoiceType_NewSubnet{`,
		`NewSubnet:` + strings.Replace(fmt.Sprintf("%v", this.NewSubnet), "GCPSubnetParamsType", "GCPSubnetParamsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GCPVPCSubnetChoiceType_ExistingSubnet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GCPVPCSubnetChoiceType_ExistingSubnet{`,
		`ExistingSubnet:` + strings.Replace(fmt.Sprintf("%v", this.ExistingSubnet), "GCPSubnetType", "GCPSubnetType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteStaticRoutesType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteStaticRoutesType{`,
		`ConfigModeChoice:` + fmt.Sprintf("%v", this.ConfigModeChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteStaticRoutesType_SimpleStaticRoute) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteStaticRoutesType_SimpleStaticRoute{`,
		`SimpleStaticRoute:` + fmt.Sprintf("%v", this.SimpleStaticRoute) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteStaticRoutesType_CustomStaticRoute) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteStaticRoutesType_CustomStaticRoute{`,
		`CustomStaticRoute:` + strings.Replace(fmt.Sprintf("%v", this.CustomStaticRoute), "StaticRouteType", "schema.StaticRouteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteStaticRoutesListType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForStaticRouteList := "[]*SiteStaticRoutesType{"
	for _, f := range this.StaticRouteList {
		repeatedStringForStaticRouteList += strings.Replace(f.String(), "SiteStaticRoutesType", "SiteStaticRoutesType", 1) + ","
	}
	repeatedStringForStaticRouteList += "}"
	s := strings.Join([]string{`&SiteStaticRoutesListType{`,
		`StaticRouteList:` + repeatedStringForStaticRouteList + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalNetworkConnectionType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalNetworkConnectionType{`,
		`ConnectionChoice:` + fmt.Sprintf("%v", this.ConnectionChoice) + `,`,
		`ForwardProxyChoice:` + fmt.Sprintf("%v", this.ForwardProxyChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalNetworkConnectionType_SliToGlobalDr) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalNetworkConnectionType_SliToGlobalDr{`,
		`SliToGlobalDr:` + strings.Replace(fmt.Sprintf("%v", this.SliToGlobalDr), "GlobalConnectorType", "GlobalConnectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalNetworkConnectionType_SloToGlobalDr) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalNetworkConnectionType_SloToGlobalDr{`,
		`SloToGlobalDr:` + strings.Replace(fmt.Sprintf("%v", this.SloToGlobalDr), "GlobalConnectorType", "GlobalConnectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalNetworkConnectionType_DisableForwardProxy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalNetworkConnectionType_DisableForwardProxy{`,
		`DisableForwardProxy:` + strings.Replace(fmt.Sprintf("%v", this.DisableForwardProxy), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalNetworkConnectionType_EnableForwardProxy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalNetworkConnectionType_EnableForwardProxy{`,
		`EnableForwardProxy:` + strings.Replace(fmt.Sprintf("%v", this.EnableForwardProxy), "ForwardProxyConfigType", "schema.ForwardProxyConfigType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalNetworkConnectionListType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForGlobalNetworkConnections := "[]*GlobalNetworkConnectionType{"
	for _, f := range this.GlobalNetworkConnections {
		repeatedStringForGlobalNetworkConnections += strings.Replace(f.String(), "GlobalNetworkConnectionType", "GlobalNetworkConnectionType", 1) + ","
	}
	repeatedStringForGlobalNetworkConnections += "}"
	s := strings.Join([]string{`&GlobalNetworkConnectionListType{`,
		`GlobalNetworkConnections:` + repeatedStringForGlobalNetworkConnections + `,`,
		`}`,
	}, "")
	return s
}
func (this *AllowedVIPPorts) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AllowedVIPPorts{`,
		`PortChoice:` + fmt.Sprintf("%v", this.PortChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AllowedVIPPorts_UseHttpPort) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AllowedVIPPorts_UseHttpPort{`,
		`UseHttpPort:` + strings.Replace(fmt.Sprintf("%v", this.UseHttpPort), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AllowedVIPPorts_UseHttpsPort) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AllowedVIPPorts_UseHttpsPort{`,
		`UseHttpsPort:` + strings.Replace(fmt.Sprintf("%v", this.UseHttpsPort), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AllowedVIPPorts_UseHttpHttpsPort) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AllowedVIPPorts_UseHttpHttpsPort{`,
		`UseHttpHttpsPort:` + strings.Replace(fmt.Sprintf("%v", this.UseHttpHttpsPort), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AllowedVIPPorts_CustomPorts) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AllowedVIPPorts_CustomPorts{`,
		`CustomPorts:` + strings.Replace(fmt.Sprintf("%v", this.CustomPorts), "CustomPorts", "CustomPorts", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AllowedVIPPorts_DisableAllowedVipPort) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AllowedVIPPorts_DisableAllowedVipPort{`,
		`DisableAllowedVipPort:` + strings.Replace(fmt.Sprintf("%v", this.DisableAllowedVipPort), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CustomPorts) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CustomPorts{`,
		`PortRanges:` + fmt.Sprintf("%v", this.PortRanges) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OfflineSurvivabilityModeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OfflineSurvivabilityModeType{`,
		`OfflineSurvivabilityModeChoice:` + fmt.Sprintf("%v", this.OfflineSurvivabilityModeChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode{`,
		`NoOfflineSurvivabilityMode:` + strings.Replace(fmt.Sprintf("%v", this.NoOfflineSurvivabilityMode), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode{`,
		`EnableOfflineSurvivabilityMode:` + strings.Replace(fmt.Sprintf("%v", this.EnableOfflineSurvivabilityMode), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DCGWBGPPeerType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DCGWBGPPeerType{`,
		`AmazonAddress:` + fmt.Sprintf("%v", this.AmazonAddress) + `,`,
		`CustomerAddress:` + fmt.Sprintf("%v", this.CustomerAddress) + `,`,
		`Asn:` + fmt.Sprintf("%v", this.Asn) + `,`,
		`AuthKey:` + strings.Replace(fmt.Sprintf("%v", this.AuthKey), "SecretType", "schema.SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VifRegionConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VifRegionConfig{`,
		`VifRegionChoice:` + fmt.Sprintf("%v", this.VifRegionChoice) + `,`,
		`VifId:` + fmt.Sprintf("%v", this.VifId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VifRegionConfig_SameAsSiteRegion) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VifRegionConfig_SameAsSiteRegion{`,
		`SameAsSiteRegion:` + strings.Replace(fmt.Sprintf("%v", this.SameAsSiteRegion), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VifRegionConfig_OtherRegion) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VifRegionConfig_OtherRegion{`,
		`OtherRegion:` + fmt.Sprintf("%v", this.OtherRegion) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HostedVIFConfigType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForVifList := "[]*VifRegionConfig{"
	for _, f := range this.VifList {
		repeatedStringForVifList += strings.Replace(f.String(), "VifRegionConfig", "VifRegionConfig", 1) + ","
	}
	repeatedStringForVifList += "}"
	s := strings.Join([]string{`&HostedVIFConfigType{`,
		`Vifs:` + fmt.Sprintf("%v", this.Vifs) + `,`,
		`VifList:` + repeatedStringForVifList + `,`,
		`ConnectivityOptions:` + fmt.Sprintf("%v", this.ConnectivityOptions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HostedVIFConfigType_SiteRegistrationOverInternet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HostedVIFConfigType_SiteRegistrationOverInternet{`,
		`SiteRegistrationOverInternet:` + strings.Replace(fmt.Sprintf("%v", this.SiteRegistrationOverInternet), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HostedVIFConfigType_SiteRegistrationOverDirectConnect) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HostedVIFConfigType_SiteRegistrationOverDirectConnect{`,
		`SiteRegistrationOverDirectConnect:` + strings.Replace(fmt.Sprintf("%v", this.SiteRegistrationOverDirectConnect), "CloudLinkADNType", "CloudLinkADNType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DirectConnectConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DirectConnectConfigType{`,
		`CloudAggregatedPrefix:` + fmt.Sprintf("%v", this.CloudAggregatedPrefix) + `,`,
		`DcConnectAggregatedPrefix:` + fmt.Sprintf("%v", this.DcConnectAggregatedPrefix) + `,`,
		`VifChoice:` + fmt.Sprintf("%v", this.VifChoice) + `,`,
		`AsnChoice:` + fmt.Sprintf("%v", this.AsnChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DirectConnectConfigType_HostedVifs) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DirectConnectConfigType_HostedVifs{`,
		`HostedVifs:` + strings.Replace(fmt.Sprintf("%v", this.HostedVifs), "HostedVIFConfigType", "HostedVIFConfigType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DirectConnectConfigType_StandardVifs) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DirectConnectConfigType_StandardVifs{`,
		`StandardVifs:` + strings.Replace(fmt.Sprintf("%v", this.StandardVifs), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DirectConnectConfigType_ManualGw) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DirectConnectConfigType_ManualGw{`,
		`ManualGw:` + strings.Replace(fmt.Sprintf("%v", this.ManualGw), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DirectConnectConfigType_AutoAsn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DirectConnectConfigType_AutoAsn{`,
		`AutoAsn:` + strings.Replace(fmt.Sprintf("%v", this.AutoAsn), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DirectConnectConfigType_CustomAsn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DirectConnectConfigType_CustomAsn{`,
		`CustomAsn:` + fmt.Sprintf("%v", this.CustomAsn) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudLinkADNType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudLinkADNType{`,
		`CloudlinkNetworkName:` + fmt.Sprintf("%v", this.CloudlinkNetworkName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DirectConnectInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DirectConnectInfo{`,
		`DirectConnectGatewayId:` + fmt.Sprintf("%v", this.DirectConnectGatewayId) + `,`,
		`VgwId:` + fmt.Sprintf("%v", this.VgwId) + `,`,
		`Asn:` + fmt.Sprintf("%v", this.Asn) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSNATGatewaychoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSNATGatewaychoiceType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSNATGatewaychoiceType_NatGwId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSNATGatewaychoiceType_NatGwId{`,
		`NatGwId:` + fmt.Sprintf("%v", this.NatGwId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVirtualPrivateGatewaychoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVirtualPrivateGatewaychoiceType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVirtualPrivateGatewaychoiceType_VgwId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVirtualPrivateGatewaychoiceType_VgwId{`,
		`VgwId:` + fmt.Sprintf("%v", this.VgwId) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringSiteTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AWSVPCParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSVPCParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSVPCParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameChoice = &AWSVPCParamsType_NameTag{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryIpv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryIpv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocateIpv6", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllocateIpv6 = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Autogenerate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NameChoice = &AWSVPCParamsType_Autogenerate{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSVPCchoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSVPCchoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSVPCchoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewVpc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSVPCParamsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AWSVPCchoiceType_NewVpc{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Choice = &AWSVPCchoiceType_VpcId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudSubnetParamType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudSubnetParamType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudSubnetParamType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv6 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudSubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudSubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudSubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CloudSubnetParamType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &CloudSubnetType_SubnetParam{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingSubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Choice = &CloudSubnetType_ExistingSubnetId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSSubnetIdsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSSubnetIdsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSSubnetIdsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AzName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideSubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideSubnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideSubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideSubnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadSubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkloadSubnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutsideSubnet == nil {
				m.OutsideSubnet = &AWSSubnetInfoType{}
			}
			if err := m.OutsideSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InsideSubnet == nil {
				m.InsideSubnet = &AWSSubnetInfoType{}
			}
			if err := m.InsideSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorkloadSubnet == nil {
				m.WorkloadSubnet = &AWSSubnetInfoType{}
			}
			if err := m.WorkloadSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSSubnetInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSSubnetInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSSubnetInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AzName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ipv4Prefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSVPCOneInterfaceNodeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSVPCOneInterfaceNodeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSVPCOneInterfaceNodeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsAzName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsAzName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalSubnet == nil {
				m.LocalSubnet = &CloudSubnetType{}
			}
			if err := m.LocalSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSize", wireType)
			}
			m.DiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSVPCTwoInterfaceNodeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSVPCTwoInterfaceNodeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSVPCTwoInterfaceNodeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsAzName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AwsAzName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CloudSubnetType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AWSVPCTwoInterfaceNodeType_InsideSubnet{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutsideSubnet == nil {
				m.OutsideSubnet = &CloudSubnetType{}
			}
			if err := m.OutsideSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservedInsideSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AWSVPCTwoInterfaceNodeType_ReservedInsideSubnet{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorkloadSubnet == nil {
				m.WorkloadSubnet = &CloudSubnetType{}
			}
			if err := m.WorkloadSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSize", wireType)
			}
			m.DiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameChoice = &AzureVnetParamsType_Name{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryIpv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryIpv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Autogenerate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NameChoice = &AzureVnetParamsType_Autogenerate{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VnetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewVnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureVnetParamsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AzureVnetChoiceType_NewVnet{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingVnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureVnetType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AzureVnetChoiceType_ExistingVnet{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureSubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureSubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureSubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetResourceGrp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceGroupChoice = &AzureSubnetType_SubnetResourceGrp{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnetResourceGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceGroupChoice = &AzureSubnetType_VnetResourceGroup{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureSpecialSubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureSpecialSubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureSpecialSubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetResourceGrp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceGroupChoice = &AzureSpecialSubnetType_SubnetResourceGrp{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnetResourceGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResourceGroupChoice = &AzureSpecialSubnetType_VnetResourceGroup{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureSubnetChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureSubnetChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureSubnetChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CloudSubnetParamType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AzureSubnetChoiceType_SubnetParam{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureSubnetType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AzureSubnetChoiceType_Subnet{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureSubnetChoiceWithAutoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureSubnetChoiceWithAutoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureSubnetChoiceWithAutoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auto", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AzureSubnetChoiceWithAutoType_Auto{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CloudSubnetParamType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AzureSubnetChoiceWithAutoType_SubnetParam{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureSpecialSubnetType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &AzureSubnetChoiceWithAutoType_Subnet{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetOneInterfaceNodeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetOneInterfaceNodeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetOneInterfaceNodeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureAz", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AzureAz = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalSubnet == nil {
				m.LocalSubnet = &AzureSubnetChoiceType{}
			}
			if err := m.LocalSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSize", wireType)
			}
			m.DiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetOneInterfaceNodeARType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetOneInterfaceNodeARType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetOneInterfaceNodeARType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeNumber", wireType)
			}
			m.NodeNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalSubnet == nil {
				m.LocalSubnet = &AzureSubnetChoiceType{}
			}
			if err := m.LocalSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaultDomain", wireType)
			}
			m.FaultDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FaultDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateDomain", wireType)
			}
			m.UpdateDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetTwoInterfaceNodeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetTwoInterfaceNodeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetTwoInterfaceNodeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureAz", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AzureAz = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InsideSubnet == nil {
				m.InsideSubnet = &AzureSubnetChoiceType{}
			}
			if err := m.InsideSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutsideSubnet == nil {
				m.OutsideSubnet = &AzureSubnetChoiceType{}
			}
			if err := m.OutsideSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSize", wireType)
			}
			m.DiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetTwoInterfaceNodeARType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetTwoInterfaceNodeARType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetTwoInterfaceNodeARType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeNumber", wireType)
			}
			m.NodeNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InsideSubnet == nil {
				m.InsideSubnet = &AzureSubnetChoiceType{}
			}
			if err := m.InsideSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutsideSubnet == nil {
				m.OutsideSubnet = &AzureSubnetChoiceType{}
			}
			if err := m.OutsideSubnet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaultDomain", wireType)
			}
			m.FaultDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FaultDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateDomain", wireType)
			}
			m.UpdateDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPVPCNetworkParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPVPCNetworkParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPVPCNetworkParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPVPCNetworkAutogenerateParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPVPCNetworkAutogenerateParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPVPCNetworkAutogenerateParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Autogenerate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Autogenerate = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPVPCNetworkType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPVPCNetworkType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPVPCNetworkType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPSubnetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPSubnetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPSubnetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPSubnetParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPSubnetParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPSubnetParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryIpv4", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrimaryIpv4 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPVPCNetworkChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPVPCNetworkChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPVPCNetworkChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GCPVPCNetworkParamsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &GCPVPCNetworkChoiceType_NewNetwork{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GCPVPCNetworkType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &GCPVPCNetworkChoiceType_ExistingNetwork{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewNetworkAutogenerate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GCPVPCNetworkAutogenerateParamsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &GCPVPCNetworkChoiceType_NewNetworkAutogenerate{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCPVPCSubnetChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCPVPCSubnetChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCPVPCSubnetChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GCPSubnetParamsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &GCPVPCSubnetChoiceType_NewSubnet{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingSubnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GCPSubnetType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &GCPVPCSubnetChoiceType_ExistingSubnet{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteStaticRoutesType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteStaticRoutesType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteStaticRoutesType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SimpleStaticRoute", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigModeChoice = &SiteStaticRoutesType_SimpleStaticRoute{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomStaticRoute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.StaticRouteType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConfigModeChoice = &SiteStaticRoutesType_CustomStaticRoute{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteStaticRoutesListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteStaticRoutesListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteStaticRoutesListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticRouteList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaticRouteList = append(m.StaticRouteList, &SiteStaticRoutesType{})
			if err := m.StaticRouteList[len(m.StaticRouteList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalNetworkConnectionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalNetworkConnectionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalNetworkConnectionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SliToGlobalDr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GlobalConnectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConnectionChoice = &GlobalNetworkConnectionType_SliToGlobalDr{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SloToGlobalDr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GlobalConnectorType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConnectionChoice = &GlobalNetworkConnectionType_SloToGlobalDr{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableForwardProxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ForwardProxyChoice = &GlobalNetworkConnectionType_DisableForwardProxy{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableForwardProxy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.ForwardProxyConfigType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ForwardProxyChoice = &GlobalNetworkConnectionType_EnableForwardProxy{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalNetworkConnectionListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalNetworkConnectionListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalNetworkConnectionListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalNetworkConnections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GlobalNetworkConnections = append(m.GlobalNetworkConnections, &GlobalNetworkConnectionType{})
			if err := m.GlobalNetworkConnections[len(m.GlobalNetworkConnections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllowedVIPPorts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllowedVIPPorts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllowedVIPPorts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseHttpPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PortChoice = &AllowedVIPPorts_UseHttpPort{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseHttpsPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PortChoice = &AllowedVIPPorts_UseHttpsPort{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseHttpHttpsPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PortChoice = &AllowedVIPPorts_UseHttpHttpsPort{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CustomPorts{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PortChoice = &AllowedVIPPorts_CustomPorts{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableAllowedVipPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PortChoice = &AllowedVIPPorts_DisableAllowedVipPort{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomPorts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomPorts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomPorts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortRanges = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OfflineSurvivabilityModeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OfflineSurvivabilityModeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OfflineSurvivabilityModeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoOfflineSurvivabilityMode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OfflineSurvivabilityModeChoice = &OfflineSurvivabilityModeType_NoOfflineSurvivabilityMode{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableOfflineSurvivabilityMode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OfflineSurvivabilityModeChoice = &OfflineSurvivabilityModeType_EnableOfflineSurvivabilityMode{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DCGWBGPPeerType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DCGWBGPPeerType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DCGWBGPPeerType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmazonAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmazonAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asn", wireType)
			}
			m.Asn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Asn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthKey == nil {
				m.AuthKey = &schema.SecretType{}
			}
			if err := m.AuthKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VifRegionConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VifRegionConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VifRegionConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SameAsSiteRegion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VifRegionChoice = &VifRegionConfig_SameAsSiteRegion{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VifRegionChoice = &VifRegionConfig_OtherRegion{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VifId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VifId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostedVIFConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostedVIFConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostedVIFConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vifs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vifs = append(m.Vifs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VifList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VifList = append(m.VifList, &VifRegionConfig{})
			if err := m.VifList[len(m.VifList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteRegistrationOverInternet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConnectivityOptions = &HostedVIFConfigType_SiteRegistrationOverInternet{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteRegistrationOverDirectConnect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CloudLinkADNType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConnectivityOptions = &HostedVIFConfigType_SiteRegistrationOverDirectConnect{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectConnectConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectConnectConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectConnectConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudAggregatedPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudAggregatedPrefix = append(m.CloudAggregatedPrefix, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcConnectAggregatedPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DcConnectAggregatedPrefix = append(m.DcConnectAggregatedPrefix, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostedVifs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HostedVIFConfigType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VifChoice = &DirectConnectConfigType_HostedVifs{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardVifs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VifChoice = &DirectConnectConfigType_StandardVifs{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualGw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VifChoice = &DirectConnectConfigType_ManualGw{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoAsn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AsnChoice = &DirectConnectConfigType_AutoAsn{v}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomAsn", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AsnChoice = &DirectConnectConfigType_CustomAsn{v}
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudLinkADNType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudLinkADNType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudLinkADNType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudlinkNetworkName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudlinkNetworkName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectConnectInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectConnectInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectConnectInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectConnectGatewayId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirectConnectGatewayId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VgwId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VgwId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asn", wireType)
			}
			m.Asn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Asn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSNATGatewaychoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSNATGatewaychoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSNATGatewaychoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NatGwId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Choice = &AWSNATGatewaychoiceType_NatGwId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSVirtualPrivateGatewaychoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSVirtualPrivateGatewaychoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSVirtualPrivateGatewaychoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VgwId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSiteTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Choice = &AWSVirtualPrivateGatewaychoiceType_VgwId{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSiteTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSiteTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSiteTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSiteTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSiteTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSiteTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSiteTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSiteTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSiteTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSiteTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSiteTypes = fmt.Errorf("proto: unexpected end of group")
)
