// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package report

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AttackImpact) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AttackImpact) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AttackImpact) DeepCopy() *AttackImpact {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AttackImpact{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AttackImpact) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AttackImpact) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AttackImpactValidator().Validate(ctx, m, opts...)
}

type ValidateAttackImpact struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAttackImpact) HeaderValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for header")
	}

	return validatorFn, nil
}

func (v *ValidateAttackImpact) DataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for data")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*AttackImpactData, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := AttackImpactDataValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for data")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*AttackImpactData)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*AttackImpactData, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated data")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items data")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAttackImpact) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AttackImpact)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AttackImpact got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["data"]; exists {
		vOpts := append(opts, db.WithValidateField("data"))
		if err := fv(ctx, m.GetData(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["header"]; exists {

		vOpts := append(opts, db.WithValidateField("header"))
		if err := fv(ctx, m.GetHeader(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAttackImpactValidator = func() *ValidateAttackImpact {
	v := &ValidateAttackImpact{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHeader := v.HeaderValidationRuleHandler
	rulesHeader := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhHeader(rulesHeader)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AttackImpact.header: %s", err)
		panic(errMsg)
	}
	v.FldValidators["header"] = vFn

	vrhData := v.DataValidationRuleHandler
	rulesData := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhData(rulesData)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AttackImpact.data: %s", err)
		panic(errMsg)
	}
	v.FldValidators["data"] = vFn

	return v
}()

func AttackImpactValidator() db.Validator {
	return DefaultAttackImpactValidator
}

// augmented methods on protoc/std generated struct

func (m *AttackImpactData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AttackImpactData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AttackImpactData) DeepCopy() *AttackImpactData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AttackImpactData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AttackImpactData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AttackImpactData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AttackImpactDataValidator().Validate(ctx, m, opts...)
}

type ValidateAttackImpactData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAttackImpactData) KeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(AttackImpactKey)
		return int32(i)
	}
	// AttackImpactKey_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, AttackImpactKey_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for key")
	}

	return validatorFn, nil
}

func (v *ValidateAttackImpactData) ValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for value")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := WaapReportFieldDataListValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAttackImpactData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AttackImpactData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AttackImpactData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["key"]; exists {

		vOpts := append(opts, db.WithValidateField("key"))
		if err := fv(ctx, m.GetKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAttackImpactDataValidator = func() *ValidateAttackImpactData {
	v := &ValidateAttackImpactData{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhKey := v.KeyValidationRuleHandler
	rulesKey := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhKey(rulesKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AttackImpactData.key: %s", err)
		panic(errMsg)
	}
	v.FldValidators["key"] = vFn

	vrhValue := v.ValueValidationRuleHandler
	rulesValue := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhValue(rulesValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AttackImpactData.value: %s", err)
		panic(errMsg)
	}
	v.FldValidators["value"] = vFn

	return v
}()

func AttackImpactDataValidator() db.Validator {
	return DefaultAttackImpactDataValidator
}

// augmented methods on protoc/std generated struct

func (m *AttackSources) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AttackSources) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AttackSources) DeepCopy() *AttackSources {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AttackSources{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AttackSources) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AttackSources) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AttackSourcesValidator().Validate(ctx, m, opts...)
}

type ValidateAttackSources struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAttackSources) HeaderValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for header")
	}

	return validatorFn, nil
}

func (v *ValidateAttackSources) DataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for data")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*AttackSourcesData, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := AttackSourcesDataValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for data")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*AttackSourcesData)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*AttackSourcesData, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated data")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items data")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAttackSources) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AttackSources)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AttackSources got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["data"]; exists {
		vOpts := append(opts, db.WithValidateField("data"))
		if err := fv(ctx, m.GetData(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["header"]; exists {

		vOpts := append(opts, db.WithValidateField("header"))
		if err := fv(ctx, m.GetHeader(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAttackSourcesValidator = func() *ValidateAttackSources {
	v := &ValidateAttackSources{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHeader := v.HeaderValidationRuleHandler
	rulesHeader := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhHeader(rulesHeader)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AttackSources.header: %s", err)
		panic(errMsg)
	}
	v.FldValidators["header"] = vFn

	vrhData := v.DataValidationRuleHandler
	rulesData := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhData(rulesData)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AttackSources.data: %s", err)
		panic(errMsg)
	}
	v.FldValidators["data"] = vFn

	return v
}()

func AttackSourcesValidator() db.Validator {
	return DefaultAttackSourcesValidator
}

// augmented methods on protoc/std generated struct

func (m *AttackSourcesData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AttackSourcesData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AttackSourcesData) DeepCopy() *AttackSourcesData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AttackSourcesData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AttackSourcesData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AttackSourcesData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AttackSourcesDataValidator().Validate(ctx, m, opts...)
}

type ValidateAttackSourcesData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAttackSourcesData) KeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(AttackSourcesKey)
		return int32(i)
	}
	// AttackSourcesKey_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, AttackSourcesKey_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for key")
	}

	return validatorFn, nil
}

func (v *ValidateAttackSourcesData) ValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for value")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := WaapReportFieldDataListValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAttackSourcesData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AttackSourcesData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AttackSourcesData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["key"]; exists {

		vOpts := append(opts, db.WithValidateField("key"))
		if err := fv(ctx, m.GetKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAttackSourcesDataValidator = func() *ValidateAttackSourcesData {
	v := &ValidateAttackSourcesData{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhKey := v.KeyValidationRuleHandler
	rulesKey := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhKey(rulesKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AttackSourcesData.key: %s", err)
		panic(errMsg)
	}
	v.FldValidators["key"] = vFn

	vrhValue := v.ValueValidationRuleHandler
	rulesValue := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhValue(rulesValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AttackSourcesData.value: %s", err)
		panic(errMsg)
	}
	v.FldValidators["value"] = vFn

	return v
}()

func AttackSourcesDataValidator() db.Validator {
	return DefaultAttackSourcesDataValidator
}

// augmented methods on protoc/std generated struct

func (m *ProtectedLBCount) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ProtectedLBCount) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ProtectedLBCount) DeepCopy() *ProtectedLBCount {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ProtectedLBCount{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ProtectedLBCount) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ProtectedLBCount) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ProtectedLBCountValidator().Validate(ctx, m, opts...)
}

type ValidateProtectedLBCount struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateProtectedLBCount) ProtectedLbCountValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint64ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for protected_lb_count")
	}

	return validatorFn, nil
}

func (v *ValidateProtectedLBCount) TotalLbCountValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint64ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for total_lb_count")
	}

	return validatorFn, nil
}

func (v *ValidateProtectedLBCount) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ProtectedLBCount)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ProtectedLBCount got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["protected_lb_count"]; exists {

		vOpts := append(opts, db.WithValidateField("protected_lb_count"))
		if err := fv(ctx, m.GetProtectedLbCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["total_lb_count"]; exists {

		vOpts := append(opts, db.WithValidateField("total_lb_count"))
		if err := fv(ctx, m.GetTotalLbCount(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultProtectedLBCountValidator = func() *ValidateProtectedLBCount {
	v := &ValidateProtectedLBCount{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhProtectedLbCount := v.ProtectedLbCountValidationRuleHandler
	rulesProtectedLbCount := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhProtectedLbCount(rulesProtectedLbCount)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProtectedLBCount.protected_lb_count: %s", err)
		panic(errMsg)
	}
	v.FldValidators["protected_lb_count"] = vFn

	vrhTotalLbCount := v.TotalLbCountValidationRuleHandler
	rulesTotalLbCount := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhTotalLbCount(rulesTotalLbCount)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ProtectedLBCount.total_lb_count: %s", err)
		panic(errMsg)
	}
	v.FldValidators["total_lb_count"] = vFn

	return v
}()

func ProtectedLBCountValidator() db.Validator {
	return DefaultProtectedLBCountValidator
}

// augmented methods on protoc/std generated struct

func (m *ReportDataWAAP) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReportDataWAAP) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReportDataWAAP) DeepCopy() *ReportDataWAAP {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReportDataWAAP{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReportDataWAAP) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReportDataWAAP) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReportDataWAAPValidator().Validate(ctx, m, opts...)
}

type ValidateReportDataWAAP struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReportDataWAAP) ReportHeaderValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for report_header")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ReportHeaderValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReportDataWAAP) ReportFooterValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for report_footer")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReportDataWAAP) LbCountValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for lb_count")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ProtectedLBCountValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReportDataWAAP) SecurityEventsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for security_events")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := SecurityEventsValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReportDataWAAP) ThreatDetailsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for threat_details")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ThreatDetailsValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReportDataWAAP) AttackSourcesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for attack_sources")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := AttackSourcesValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReportDataWAAP) AttackImpactValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for attack_impact")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := AttackImpactValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateReportDataWAAP) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReportDataWAAP)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReportDataWAAP got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["attack_impact"]; exists {

		vOpts := append(opts, db.WithValidateField("attack_impact"))
		if err := fv(ctx, m.GetAttackImpact(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["attack_sources"]; exists {

		vOpts := append(opts, db.WithValidateField("attack_sources"))
		if err := fv(ctx, m.GetAttackSources(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["lb_count"]; exists {

		vOpts := append(opts, db.WithValidateField("lb_count"))
		if err := fv(ctx, m.GetLbCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["report_footer"]; exists {

		vOpts := append(opts, db.WithValidateField("report_footer"))
		if err := fv(ctx, m.GetReportFooter(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["report_header"]; exists {

		vOpts := append(opts, db.WithValidateField("report_header"))
		if err := fv(ctx, m.GetReportHeader(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["security_events"]; exists {

		vOpts := append(opts, db.WithValidateField("security_events"))
		if err := fv(ctx, m.GetSecurityEvents(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["threat_details"]; exists {

		vOpts := append(opts, db.WithValidateField("threat_details"))
		if err := fv(ctx, m.GetThreatDetails(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReportDataWAAPValidator = func() *ValidateReportDataWAAP {
	v := &ValidateReportDataWAAP{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhReportHeader := v.ReportHeaderValidationRuleHandler
	rulesReportHeader := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhReportHeader(rulesReportHeader)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReportDataWAAP.report_header: %s", err)
		panic(errMsg)
	}
	v.FldValidators["report_header"] = vFn

	vrhReportFooter := v.ReportFooterValidationRuleHandler
	rulesReportFooter := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhReportFooter(rulesReportFooter)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReportDataWAAP.report_footer: %s", err)
		panic(errMsg)
	}
	v.FldValidators["report_footer"] = vFn

	vrhLbCount := v.LbCountValidationRuleHandler
	rulesLbCount := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhLbCount(rulesLbCount)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReportDataWAAP.lb_count: %s", err)
		panic(errMsg)
	}
	v.FldValidators["lb_count"] = vFn

	vrhSecurityEvents := v.SecurityEventsValidationRuleHandler
	rulesSecurityEvents := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSecurityEvents(rulesSecurityEvents)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReportDataWAAP.security_events: %s", err)
		panic(errMsg)
	}
	v.FldValidators["security_events"] = vFn

	vrhThreatDetails := v.ThreatDetailsValidationRuleHandler
	rulesThreatDetails := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhThreatDetails(rulesThreatDetails)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReportDataWAAP.threat_details: %s", err)
		panic(errMsg)
	}
	v.FldValidators["threat_details"] = vFn

	vrhAttackSources := v.AttackSourcesValidationRuleHandler
	rulesAttackSources := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAttackSources(rulesAttackSources)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReportDataWAAP.attack_sources: %s", err)
		panic(errMsg)
	}
	v.FldValidators["attack_sources"] = vFn

	vrhAttackImpact := v.AttackImpactValidationRuleHandler
	rulesAttackImpact := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAttackImpact(rulesAttackImpact)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReportDataWAAP.attack_impact: %s", err)
		panic(errMsg)
	}
	v.FldValidators["attack_impact"] = vFn

	return v
}()

func ReportDataWAAPValidator() db.Validator {
	return DefaultReportDataWAAPValidator
}

// augmented methods on protoc/std generated struct

func (m *SecurityEvents) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecurityEvents) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SecurityEvents) DeepCopy() *SecurityEvents {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecurityEvents{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecurityEvents) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecurityEvents) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecurityEventsValidator().Validate(ctx, m, opts...)
}

type ValidateSecurityEvents struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecurityEvents) HeaderValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for header")
	}

	return validatorFn, nil
}

func (v *ValidateSecurityEvents) DataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for data")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*SecurityEventsData, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := SecurityEventsDataValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for data")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*SecurityEventsData)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*SecurityEventsData, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated data")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items data")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSecurityEvents) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecurityEvents)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecurityEvents got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["data"]; exists {
		vOpts := append(opts, db.WithValidateField("data"))
		if err := fv(ctx, m.GetData(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["header"]; exists {

		vOpts := append(opts, db.WithValidateField("header"))
		if err := fv(ctx, m.GetHeader(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecurityEventsValidator = func() *ValidateSecurityEvents {
	v := &ValidateSecurityEvents{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHeader := v.HeaderValidationRuleHandler
	rulesHeader := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhHeader(rulesHeader)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityEvents.header: %s", err)
		panic(errMsg)
	}
	v.FldValidators["header"] = vFn

	vrhData := v.DataValidationRuleHandler
	rulesData := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhData(rulesData)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityEvents.data: %s", err)
		panic(errMsg)
	}
	v.FldValidators["data"] = vFn

	return v
}()

func SecurityEventsValidator() db.Validator {
	return DefaultSecurityEventsValidator
}

// augmented methods on protoc/std generated struct

func (m *SecurityEventsData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecurityEventsData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SecurityEventsData) DeepCopy() *SecurityEventsData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecurityEventsData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecurityEventsData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecurityEventsData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecurityEventsDataValidator().Validate(ctx, m, opts...)
}

type ValidateSecurityEventsData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecurityEventsData) KeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(SecurityEventsKey)
		return int32(i)
	}
	// SecurityEventsKey_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, SecurityEventsKey_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for key")
	}

	return validatorFn, nil
}

func (v *ValidateSecurityEventsData) ValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for value")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := WaapReportFieldDataValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSecurityEventsData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecurityEventsData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecurityEventsData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["key"]; exists {

		vOpts := append(opts, db.WithValidateField("key"))
		if err := fv(ctx, m.GetKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecurityEventsDataValidator = func() *ValidateSecurityEventsData {
	v := &ValidateSecurityEventsData{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhKey := v.KeyValidationRuleHandler
	rulesKey := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhKey(rulesKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityEventsData.key: %s", err)
		panic(errMsg)
	}
	v.FldValidators["key"] = vFn

	vrhValue := v.ValueValidationRuleHandler
	rulesValue := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhValue(rulesValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityEventsData.value: %s", err)
		panic(errMsg)
	}
	v.FldValidators["value"] = vFn

	return v
}()

func SecurityEventsDataValidator() db.Validator {
	return DefaultSecurityEventsDataValidator
}

// augmented methods on protoc/std generated struct

func (m *ThreatDetails) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ThreatDetails) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ThreatDetails) DeepCopy() *ThreatDetails {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ThreatDetails{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ThreatDetails) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ThreatDetails) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ThreatDetailsValidator().Validate(ctx, m, opts...)
}

type ValidateThreatDetails struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateThreatDetails) HeaderValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for header")
	}

	return validatorFn, nil
}

func (v *ValidateThreatDetails) DataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for data")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ThreatDetailsData, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ThreatDetailsDataValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for data")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ThreatDetailsData)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ThreatDetailsData, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated data")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items data")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateThreatDetails) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ThreatDetails)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ThreatDetails got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["data"]; exists {
		vOpts := append(opts, db.WithValidateField("data"))
		if err := fv(ctx, m.GetData(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["header"]; exists {

		vOpts := append(opts, db.WithValidateField("header"))
		if err := fv(ctx, m.GetHeader(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultThreatDetailsValidator = func() *ValidateThreatDetails {
	v := &ValidateThreatDetails{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHeader := v.HeaderValidationRuleHandler
	rulesHeader := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhHeader(rulesHeader)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ThreatDetails.header: %s", err)
		panic(errMsg)
	}
	v.FldValidators["header"] = vFn

	vrhData := v.DataValidationRuleHandler
	rulesData := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhData(rulesData)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ThreatDetails.data: %s", err)
		panic(errMsg)
	}
	v.FldValidators["data"] = vFn

	return v
}()

func ThreatDetailsValidator() db.Validator {
	return DefaultThreatDetailsValidator
}

// augmented methods on protoc/std generated struct

func (m *ThreatDetailsData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ThreatDetailsData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ThreatDetailsData) DeepCopy() *ThreatDetailsData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ThreatDetailsData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ThreatDetailsData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ThreatDetailsData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ThreatDetailsDataValidator().Validate(ctx, m, opts...)
}

type ValidateThreatDetailsData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateThreatDetailsData) KeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ThreatDetailsKey)
		return int32(i)
	}
	// ThreatDetailsKey_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ThreatDetailsKey_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for key")
	}

	return validatorFn, nil
}

func (v *ValidateThreatDetailsData) ValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for value")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := WaapReportFieldDataValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateThreatDetailsData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ThreatDetailsData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ThreatDetailsData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["key"]; exists {

		vOpts := append(opts, db.WithValidateField("key"))
		if err := fv(ctx, m.GetKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultThreatDetailsDataValidator = func() *ValidateThreatDetailsData {
	v := &ValidateThreatDetailsData{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhKey := v.KeyValidationRuleHandler
	rulesKey := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhKey(rulesKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ThreatDetailsData.key: %s", err)
		panic(errMsg)
	}
	v.FldValidators["key"] = vFn

	vrhValue := v.ValueValidationRuleHandler
	rulesValue := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhValue(rulesValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ThreatDetailsData.value: %s", err)
		panic(errMsg)
	}
	v.FldValidators["value"] = vFn

	return v
}()

func ThreatDetailsDataValidator() db.Validator {
	return DefaultThreatDetailsDataValidator
}

// augmented methods on protoc/std generated struct

func (m *WaapReportFieldData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WaapReportFieldData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WaapReportFieldData) DeepCopy() *WaapReportFieldData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WaapReportFieldData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WaapReportFieldData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WaapReportFieldData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WaapReportFieldDataValidator().Validate(ctx, m, opts...)
}

type ValidateWaapReportFieldData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWaapReportFieldData) CurrentValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewDoubleValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for current_value")
	}

	return validatorFn, nil
}

func (v *ValidateWaapReportFieldData) CurrentValueTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(FieldValueType)
		return int32(i)
	}
	// FieldValueType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, FieldValueType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for current_value_type")
	}

	return validatorFn, nil
}

func (v *ValidateWaapReportFieldData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WaapReportFieldData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WaapReportFieldData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["current_value"]; exists {

		vOpts := append(opts, db.WithValidateField("current_value"))
		if err := fv(ctx, m.GetCurrentValue(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["current_value_header"]; exists {

		vOpts := append(opts, db.WithValidateField("current_value_header"))
		if err := fv(ctx, m.GetCurrentValueHeader(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["current_value_sub_values"]; exists {

		vOpts := append(opts, db.WithValidateField("current_value_sub_values"))
		for key, value := range m.GetCurrentValueSubValues() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["current_value_type"]; exists {

		vOpts := append(opts, db.WithValidateField("current_value_type"))
		if err := fv(ctx, m.GetCurrentValueType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["prev_value"]; exists {

		vOpts := append(opts, db.WithValidateField("prev_value"))
		if err := fv(ctx, m.GetPrevValue(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["prev_value_header"]; exists {

		vOpts := append(opts, db.WithValidateField("prev_value_header"))
		if err := fv(ctx, m.GetPrevValueHeader(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["trend_value"]; exists {

		vOpts := append(opts, db.WithValidateField("trend_value"))
		if err := fv(ctx, m.GetTrendValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWaapReportFieldDataValidator = func() *ValidateWaapReportFieldData {
	v := &ValidateWaapReportFieldData{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCurrentValue := v.CurrentValueValidationRuleHandler
	rulesCurrentValue := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhCurrentValue(rulesCurrentValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WaapReportFieldData.current_value: %s", err)
		panic(errMsg)
	}
	v.FldValidators["current_value"] = vFn

	vrhCurrentValueType := v.CurrentValueTypeValidationRuleHandler
	rulesCurrentValueType := map[string]string{
		"ves.io.schema.rules.enum.not_in":      "0",
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhCurrentValueType(rulesCurrentValueType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WaapReportFieldData.current_value_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["current_value_type"] = vFn

	return v
}()

func WaapReportFieldDataValidator() db.Validator {
	return DefaultWaapReportFieldDataValidator
}

// augmented methods on protoc/std generated struct

func (m *WaapReportFieldDataList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *WaapReportFieldDataList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *WaapReportFieldDataList) DeepCopy() *WaapReportFieldDataList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &WaapReportFieldDataList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *WaapReportFieldDataList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *WaapReportFieldDataList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return WaapReportFieldDataListValidator().Validate(ctx, m, opts...)
}

type ValidateWaapReportFieldDataList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateWaapReportFieldDataList) DataValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for data")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*WaapReportFieldData, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := WaapReportFieldDataValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for data")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*WaapReportFieldData)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*WaapReportFieldData, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated data")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items data")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateWaapReportFieldDataList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*WaapReportFieldDataList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *WaapReportFieldDataList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["data"]; exists {
		vOpts := append(opts, db.WithValidateField("data"))
		if err := fv(ctx, m.GetData(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultWaapReportFieldDataListValidator = func() *ValidateWaapReportFieldDataList {
	v := &ValidateWaapReportFieldDataList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhData := v.DataValidationRuleHandler
	rulesData := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhData(rulesData)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for WaapReportFieldDataList.data: %s", err)
		panic(errMsg)
	}
	v.FldValidators["data"] = vFn

	return v
}()

func WaapReportFieldDataListValidator() db.Validator {
	return DefaultWaapReportFieldDataListValidator
}
