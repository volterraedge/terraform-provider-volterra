// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/ike2/types.proto

package ike2

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	ike_phase1_profile "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/ike_phase1_profile"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GlobalSpecType
//
// x-displayName: "Global Specification"
// Shape of the External connector configuration specification
type GlobalSpecType struct {
	// Encryption Algorithms
	//
	// x-displayName: "Encryption Algorithms"
	// Choose one or more encryption algorithms.
	EncryptionAlgos []schema.EncryptionAlgorithm `protobuf:"varint,1,rep,packed,name=encryption_algos,json=encryptionAlgos,proto3,enum=ves.io.schema.EncryptionAlgorithm" json:"encryption_algos,omitempty"`
	// Authentication Algorithms
	//
	// x-displayName: "Authentication Algorithms"
	// Choose one or more Authentication Algorithm. Use None option when using the aes-gcm or aes-ccm encryption algorithms.
	AuthenticationAlgos []schema.AuthenticationAlgorithm `protobuf:"varint,2,rep,packed,name=authentication_algos,json=authenticationAlgos,proto3,enum=ves.io.schema.AuthenticationAlgorithm" json:"authentication_algos,omitempty"`
	// Perfect Forward Secrecy (PFS)
	//
	// x-displayName: "Perfect Forward Secrecy (PFS)"
	// Configure Perfect Forward Secrecy for this tunnel
	//
	// Types that are valid to be assigned to PfsMode:
	//	*GlobalSpecType_DisablePfs
	//	*GlobalSpecType_DhGroupSet
	PfsMode isGlobalSpecType_PfsMode `protobuf_oneof:"pfs_mode"`
	// Key LifeTime
	//
	// x-displayName: "Key LifeTime"
	// x-required
	// Amount of time before the IKE Security Association (SA) key needs to be renegotiated
	//
	// Types that are valid to be assigned to IkeKeyLifetime:
	//	*GlobalSpecType_UseDefaultKeylifetime
	//	*GlobalSpecType_IkeKeylifetimeMinutes
	//	*GlobalSpecType_IkeKeylifetimeHours
	IkeKeyLifetime isGlobalSpecType_IkeKeyLifetime `protobuf_oneof:"ike_key_lifetime"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_b1830f638c1c7c2e, []int{0}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_PfsMode interface {
	isGlobalSpecType_PfsMode()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_IkeKeyLifetime interface {
	isGlobalSpecType_IkeKeyLifetime()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_DisablePfs struct {
	DisablePfs *schema.Empty `protobuf:"bytes,11,opt,name=disable_pfs,json=disablePfs,proto3,oneof" json:"disable_pfs,omitempty"`
}
type GlobalSpecType_DhGroupSet struct {
	DhGroupSet *DHGroups `protobuf:"bytes,12,opt,name=dh_group_set,json=dhGroupSet,proto3,oneof" json:"dh_group_set,omitempty"`
}
type GlobalSpecType_UseDefaultKeylifetime struct {
	UseDefaultKeylifetime *schema.Empty `protobuf:"bytes,21,opt,name=use_default_keylifetime,json=useDefaultKeylifetime,proto3,oneof" json:"use_default_keylifetime,omitempty"`
}
type GlobalSpecType_IkeKeylifetimeMinutes struct {
	IkeKeylifetimeMinutes *ike_phase1_profile.InputMinutes `protobuf:"bytes,22,opt,name=ike_keylifetime_minutes,json=ikeKeylifetimeMinutes,proto3,oneof" json:"ike_keylifetime_minutes,omitempty"`
}
type GlobalSpecType_IkeKeylifetimeHours struct {
	IkeKeylifetimeHours *ike_phase1_profile.InputHours `protobuf:"bytes,23,opt,name=ike_keylifetime_hours,json=ikeKeylifetimeHours,proto3,oneof" json:"ike_keylifetime_hours,omitempty"`
}

func (*GlobalSpecType_DisablePfs) isGlobalSpecType_PfsMode()                   {}
func (*GlobalSpecType_DhGroupSet) isGlobalSpecType_PfsMode()                   {}
func (*GlobalSpecType_UseDefaultKeylifetime) isGlobalSpecType_IkeKeyLifetime() {}
func (*GlobalSpecType_IkeKeylifetimeMinutes) isGlobalSpecType_IkeKeyLifetime() {}
func (*GlobalSpecType_IkeKeylifetimeHours) isGlobalSpecType_IkeKeyLifetime()   {}

func (m *GlobalSpecType) GetPfsMode() isGlobalSpecType_PfsMode {
	if m != nil {
		return m.PfsMode
	}
	return nil
}
func (m *GlobalSpecType) GetIkeKeyLifetime() isGlobalSpecType_IkeKeyLifetime {
	if m != nil {
		return m.IkeKeyLifetime
	}
	return nil
}

func (m *GlobalSpecType) GetEncryptionAlgos() []schema.EncryptionAlgorithm {
	if m != nil {
		return m.EncryptionAlgos
	}
	return nil
}

func (m *GlobalSpecType) GetAuthenticationAlgos() []schema.AuthenticationAlgorithm {
	if m != nil {
		return m.AuthenticationAlgos
	}
	return nil
}

func (m *GlobalSpecType) GetDisablePfs() *schema.Empty {
	if x, ok := m.GetPfsMode().(*GlobalSpecType_DisablePfs); ok {
		return x.DisablePfs
	}
	return nil
}

func (m *GlobalSpecType) GetDhGroupSet() *DHGroups {
	if x, ok := m.GetPfsMode().(*GlobalSpecType_DhGroupSet); ok {
		return x.DhGroupSet
	}
	return nil
}

func (m *GlobalSpecType) GetUseDefaultKeylifetime() *schema.Empty {
	if x, ok := m.GetIkeKeyLifetime().(*GlobalSpecType_UseDefaultKeylifetime); ok {
		return x.UseDefaultKeylifetime
	}
	return nil
}

func (m *GlobalSpecType) GetIkeKeylifetimeMinutes() *ike_phase1_profile.InputMinutes {
	if x, ok := m.GetIkeKeyLifetime().(*GlobalSpecType_IkeKeylifetimeMinutes); ok {
		return x.IkeKeylifetimeMinutes
	}
	return nil
}

func (m *GlobalSpecType) GetIkeKeylifetimeHours() *ike_phase1_profile.InputHours {
	if x, ok := m.GetIkeKeyLifetime().(*GlobalSpecType_IkeKeylifetimeHours); ok {
		return x.IkeKeylifetimeHours
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_DisablePfs)(nil),
		(*GlobalSpecType_DhGroupSet)(nil),
		(*GlobalSpecType_UseDefaultKeylifetime)(nil),
		(*GlobalSpecType_IkeKeylifetimeMinutes)(nil),
		(*GlobalSpecType_IkeKeylifetimeHours)(nil),
	}
}

// Diffie Hellman Groups
//
// x-displayName: "Diffie Hellman Groups"
// Choose the acceptable Diffie Hellman(DH) Group or Groups that you are willing to accept as part of this profile.
type DHGroups struct {
	// Diffie Hellman Groups
	//
	// x-displayName: "Diffie Hellman Groups"
	DhGroups []schema.DHGroup `protobuf:"varint,1,rep,packed,name=dh_groups,json=dhGroups,proto3,enum=ves.io.schema.DHGroup" json:"dh_groups,omitempty"`
}

func (m *DHGroups) Reset()      { *m = DHGroups{} }
func (*DHGroups) ProtoMessage() {}
func (*DHGroups) Descriptor() ([]byte, []int) {
	return fileDescriptor_b1830f638c1c7c2e, []int{1}
}
func (m *DHGroups) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHGroups) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DHGroups) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHGroups.Merge(m, src)
}
func (m *DHGroups) XXX_Size() int {
	return m.Size()
}
func (m *DHGroups) XXX_DiscardUnknown() {
	xxx_messageInfo_DHGroups.DiscardUnknown(m)
}

var xxx_messageInfo_DHGroups proto.InternalMessageInfo

func (m *DHGroups) GetDhGroups() []schema.DHGroup {
	if m != nil {
		return m.DhGroups
	}
	return nil
}

// CreateSpecType
//
// x-displayName: "Create IKE Phase2 Profile"
// Shape of the IKE Phase2 profile specification
type CreateSpecType struct {
	EncryptionAlgos     []schema.EncryptionAlgorithm     `protobuf:"varint,1,rep,packed,name=encryption_algos,json=encryptionAlgos,proto3,enum=ves.io.schema.EncryptionAlgorithm" json:"encryption_algos,omitempty"`
	AuthenticationAlgos []schema.AuthenticationAlgorithm `protobuf:"varint,2,rep,packed,name=authentication_algos,json=authenticationAlgos,proto3,enum=ves.io.schema.AuthenticationAlgorithm" json:"authentication_algos,omitempty"`
	// Types that are valid to be assigned to PfsMode:
	//	*CreateSpecType_DisablePfs
	//	*CreateSpecType_DhGroupSet
	PfsMode isCreateSpecType_PfsMode `protobuf_oneof:"pfs_mode"`
	// Types that are valid to be assigned to IkeKeyLifetime:
	//	*CreateSpecType_UseDefaultKeylifetime
	//	*CreateSpecType_IkeKeylifetimeMinutes
	//	*CreateSpecType_IkeKeylifetimeHours
	IkeKeyLifetime isCreateSpecType_IkeKeyLifetime `protobuf_oneof:"ike_key_lifetime"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_b1830f638c1c7c2e, []int{2}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_PfsMode interface {
	isCreateSpecType_PfsMode()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCreateSpecType_IkeKeyLifetime interface {
	isCreateSpecType_IkeKeyLifetime()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_DisablePfs struct {
	DisablePfs *schema.Empty `protobuf:"bytes,11,opt,name=disable_pfs,json=disablePfs,proto3,oneof" json:"disable_pfs,omitempty"`
}
type CreateSpecType_DhGroupSet struct {
	DhGroupSet *DHGroups `protobuf:"bytes,12,opt,name=dh_group_set,json=dhGroupSet,proto3,oneof" json:"dh_group_set,omitempty"`
}
type CreateSpecType_UseDefaultKeylifetime struct {
	UseDefaultKeylifetime *schema.Empty `protobuf:"bytes,21,opt,name=use_default_keylifetime,json=useDefaultKeylifetime,proto3,oneof" json:"use_default_keylifetime,omitempty"`
}
type CreateSpecType_IkeKeylifetimeMinutes struct {
	IkeKeylifetimeMinutes *ike_phase1_profile.InputMinutes `protobuf:"bytes,22,opt,name=ike_keylifetime_minutes,json=ikeKeylifetimeMinutes,proto3,oneof" json:"ike_keylifetime_minutes,omitempty"`
}
type CreateSpecType_IkeKeylifetimeHours struct {
	IkeKeylifetimeHours *ike_phase1_profile.InputHours `protobuf:"bytes,23,opt,name=ike_keylifetime_hours,json=ikeKeylifetimeHours,proto3,oneof" json:"ike_keylifetime_hours,omitempty"`
}

func (*CreateSpecType_DisablePfs) isCreateSpecType_PfsMode()                   {}
func (*CreateSpecType_DhGroupSet) isCreateSpecType_PfsMode()                   {}
func (*CreateSpecType_UseDefaultKeylifetime) isCreateSpecType_IkeKeyLifetime() {}
func (*CreateSpecType_IkeKeylifetimeMinutes) isCreateSpecType_IkeKeyLifetime() {}
func (*CreateSpecType_IkeKeylifetimeHours) isCreateSpecType_IkeKeyLifetime()   {}

func (m *CreateSpecType) GetPfsMode() isCreateSpecType_PfsMode {
	if m != nil {
		return m.PfsMode
	}
	return nil
}
func (m *CreateSpecType) GetIkeKeyLifetime() isCreateSpecType_IkeKeyLifetime {
	if m != nil {
		return m.IkeKeyLifetime
	}
	return nil
}

func (m *CreateSpecType) GetEncryptionAlgos() []schema.EncryptionAlgorithm {
	if m != nil {
		return m.EncryptionAlgos
	}
	return nil
}

func (m *CreateSpecType) GetAuthenticationAlgos() []schema.AuthenticationAlgorithm {
	if m != nil {
		return m.AuthenticationAlgos
	}
	return nil
}

func (m *CreateSpecType) GetDisablePfs() *schema.Empty {
	if x, ok := m.GetPfsMode().(*CreateSpecType_DisablePfs); ok {
		return x.DisablePfs
	}
	return nil
}

func (m *CreateSpecType) GetDhGroupSet() *DHGroups {
	if x, ok := m.GetPfsMode().(*CreateSpecType_DhGroupSet); ok {
		return x.DhGroupSet
	}
	return nil
}

func (m *CreateSpecType) GetUseDefaultKeylifetime() *schema.Empty {
	if x, ok := m.GetIkeKeyLifetime().(*CreateSpecType_UseDefaultKeylifetime); ok {
		return x.UseDefaultKeylifetime
	}
	return nil
}

func (m *CreateSpecType) GetIkeKeylifetimeMinutes() *ike_phase1_profile.InputMinutes {
	if x, ok := m.GetIkeKeyLifetime().(*CreateSpecType_IkeKeylifetimeMinutes); ok {
		return x.IkeKeylifetimeMinutes
	}
	return nil
}

func (m *CreateSpecType) GetIkeKeylifetimeHours() *ike_phase1_profile.InputHours {
	if x, ok := m.GetIkeKeyLifetime().(*CreateSpecType_IkeKeylifetimeHours); ok {
		return x.IkeKeylifetimeHours
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_DisablePfs)(nil),
		(*CreateSpecType_DhGroupSet)(nil),
		(*CreateSpecType_UseDefaultKeylifetime)(nil),
		(*CreateSpecType_IkeKeylifetimeMinutes)(nil),
		(*CreateSpecType_IkeKeylifetimeHours)(nil),
	}
}

// ReplaceSpecType
//
// x-displayName: "Replace IKE Phase2 Profile  configuration"
// Shape of the IKE Phase2 profile  configuration specification
type ReplaceSpecType struct {
	EncryptionAlgos     []schema.EncryptionAlgorithm     `protobuf:"varint,1,rep,packed,name=encryption_algos,json=encryptionAlgos,proto3,enum=ves.io.schema.EncryptionAlgorithm" json:"encryption_algos,omitempty"`
	AuthenticationAlgos []schema.AuthenticationAlgorithm `protobuf:"varint,2,rep,packed,name=authentication_algos,json=authenticationAlgos,proto3,enum=ves.io.schema.AuthenticationAlgorithm" json:"authentication_algos,omitempty"`
	// Types that are valid to be assigned to PfsMode:
	//	*ReplaceSpecType_DisablePfs
	//	*ReplaceSpecType_DhGroupSet
	PfsMode isReplaceSpecType_PfsMode `protobuf_oneof:"pfs_mode"`
	// Types that are valid to be assigned to IkeKeyLifetime:
	//	*ReplaceSpecType_UseDefaultKeylifetime
	//	*ReplaceSpecType_IkeKeylifetimeMinutes
	//	*ReplaceSpecType_IkeKeylifetimeHours
	IkeKeyLifetime isReplaceSpecType_IkeKeyLifetime `protobuf_oneof:"ike_key_lifetime"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_b1830f638c1c7c2e, []int{3}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_PfsMode interface {
	isReplaceSpecType_PfsMode()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isReplaceSpecType_IkeKeyLifetime interface {
	isReplaceSpecType_IkeKeyLifetime()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_DisablePfs struct {
	DisablePfs *schema.Empty `protobuf:"bytes,11,opt,name=disable_pfs,json=disablePfs,proto3,oneof" json:"disable_pfs,omitempty"`
}
type ReplaceSpecType_DhGroupSet struct {
	DhGroupSet *DHGroups `protobuf:"bytes,12,opt,name=dh_group_set,json=dhGroupSet,proto3,oneof" json:"dh_group_set,omitempty"`
}
type ReplaceSpecType_UseDefaultKeylifetime struct {
	UseDefaultKeylifetime *schema.Empty `protobuf:"bytes,21,opt,name=use_default_keylifetime,json=useDefaultKeylifetime,proto3,oneof" json:"use_default_keylifetime,omitempty"`
}
type ReplaceSpecType_IkeKeylifetimeMinutes struct {
	IkeKeylifetimeMinutes *ike_phase1_profile.InputMinutes `protobuf:"bytes,22,opt,name=ike_keylifetime_minutes,json=ikeKeylifetimeMinutes,proto3,oneof" json:"ike_keylifetime_minutes,omitempty"`
}
type ReplaceSpecType_IkeKeylifetimeHours struct {
	IkeKeylifetimeHours *ike_phase1_profile.InputHours `protobuf:"bytes,23,opt,name=ike_keylifetime_hours,json=ikeKeylifetimeHours,proto3,oneof" json:"ike_keylifetime_hours,omitempty"`
}

func (*ReplaceSpecType_DisablePfs) isReplaceSpecType_PfsMode()                   {}
func (*ReplaceSpecType_DhGroupSet) isReplaceSpecType_PfsMode()                   {}
func (*ReplaceSpecType_UseDefaultKeylifetime) isReplaceSpecType_IkeKeyLifetime() {}
func (*ReplaceSpecType_IkeKeylifetimeMinutes) isReplaceSpecType_IkeKeyLifetime() {}
func (*ReplaceSpecType_IkeKeylifetimeHours) isReplaceSpecType_IkeKeyLifetime()   {}

func (m *ReplaceSpecType) GetPfsMode() isReplaceSpecType_PfsMode {
	if m != nil {
		return m.PfsMode
	}
	return nil
}
func (m *ReplaceSpecType) GetIkeKeyLifetime() isReplaceSpecType_IkeKeyLifetime {
	if m != nil {
		return m.IkeKeyLifetime
	}
	return nil
}

func (m *ReplaceSpecType) GetEncryptionAlgos() []schema.EncryptionAlgorithm {
	if m != nil {
		return m.EncryptionAlgos
	}
	return nil
}

func (m *ReplaceSpecType) GetAuthenticationAlgos() []schema.AuthenticationAlgorithm {
	if m != nil {
		return m.AuthenticationAlgos
	}
	return nil
}

func (m *ReplaceSpecType) GetDisablePfs() *schema.Empty {
	if x, ok := m.GetPfsMode().(*ReplaceSpecType_DisablePfs); ok {
		return x.DisablePfs
	}
	return nil
}

func (m *ReplaceSpecType) GetDhGroupSet() *DHGroups {
	if x, ok := m.GetPfsMode().(*ReplaceSpecType_DhGroupSet); ok {
		return x.DhGroupSet
	}
	return nil
}

func (m *ReplaceSpecType) GetUseDefaultKeylifetime() *schema.Empty {
	if x, ok := m.GetIkeKeyLifetime().(*ReplaceSpecType_UseDefaultKeylifetime); ok {
		return x.UseDefaultKeylifetime
	}
	return nil
}

func (m *ReplaceSpecType) GetIkeKeylifetimeMinutes() *ike_phase1_profile.InputMinutes {
	if x, ok := m.GetIkeKeyLifetime().(*ReplaceSpecType_IkeKeylifetimeMinutes); ok {
		return x.IkeKeylifetimeMinutes
	}
	return nil
}

func (m *ReplaceSpecType) GetIkeKeylifetimeHours() *ike_phase1_profile.InputHours {
	if x, ok := m.GetIkeKeyLifetime().(*ReplaceSpecType_IkeKeylifetimeHours); ok {
		return x.IkeKeylifetimeHours
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_DisablePfs)(nil),
		(*ReplaceSpecType_DhGroupSet)(nil),
		(*ReplaceSpecType_UseDefaultKeylifetime)(nil),
		(*ReplaceSpecType_IkeKeylifetimeMinutes)(nil),
		(*ReplaceSpecType_IkeKeylifetimeHours)(nil),
	}
}

// GetSpecType
//
// x-displayName: "Get IKE Phase2 profile  configuration"
// Shape of the IKE Phase2 Profile  configuration specification
type GetSpecType struct {
	EncryptionAlgos     []schema.EncryptionAlgorithm     `protobuf:"varint,1,rep,packed,name=encryption_algos,json=encryptionAlgos,proto3,enum=ves.io.schema.EncryptionAlgorithm" json:"encryption_algos,omitempty"`
	AuthenticationAlgos []schema.AuthenticationAlgorithm `protobuf:"varint,2,rep,packed,name=authentication_algos,json=authenticationAlgos,proto3,enum=ves.io.schema.AuthenticationAlgorithm" json:"authentication_algos,omitempty"`
	// Types that are valid to be assigned to PfsMode:
	//	*GetSpecType_DisablePfs
	//	*GetSpecType_DhGroupSet
	PfsMode isGetSpecType_PfsMode `protobuf_oneof:"pfs_mode"`
	// Types that are valid to be assigned to IkeKeyLifetime:
	//	*GetSpecType_UseDefaultKeylifetime
	//	*GetSpecType_IkeKeylifetimeMinutes
	//	*GetSpecType_IkeKeylifetimeHours
	IkeKeyLifetime isGetSpecType_IkeKeyLifetime `protobuf_oneof:"ike_key_lifetime"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_b1830f638c1c7c2e, []int{4}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_PfsMode interface {
	isGetSpecType_PfsMode()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_IkeKeyLifetime interface {
	isGetSpecType_IkeKeyLifetime()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_DisablePfs struct {
	DisablePfs *schema.Empty `protobuf:"bytes,11,opt,name=disable_pfs,json=disablePfs,proto3,oneof" json:"disable_pfs,omitempty"`
}
type GetSpecType_DhGroupSet struct {
	DhGroupSet *DHGroups `protobuf:"bytes,12,opt,name=dh_group_set,json=dhGroupSet,proto3,oneof" json:"dh_group_set,omitempty"`
}
type GetSpecType_UseDefaultKeylifetime struct {
	UseDefaultKeylifetime *schema.Empty `protobuf:"bytes,21,opt,name=use_default_keylifetime,json=useDefaultKeylifetime,proto3,oneof" json:"use_default_keylifetime,omitempty"`
}
type GetSpecType_IkeKeylifetimeMinutes struct {
	IkeKeylifetimeMinutes *ike_phase1_profile.InputMinutes `protobuf:"bytes,22,opt,name=ike_keylifetime_minutes,json=ikeKeylifetimeMinutes,proto3,oneof" json:"ike_keylifetime_minutes,omitempty"`
}
type GetSpecType_IkeKeylifetimeHours struct {
	IkeKeylifetimeHours *ike_phase1_profile.InputHours `protobuf:"bytes,23,opt,name=ike_keylifetime_hours,json=ikeKeylifetimeHours,proto3,oneof" json:"ike_keylifetime_hours,omitempty"`
}

func (*GetSpecType_DisablePfs) isGetSpecType_PfsMode()                   {}
func (*GetSpecType_DhGroupSet) isGetSpecType_PfsMode()                   {}
func (*GetSpecType_UseDefaultKeylifetime) isGetSpecType_IkeKeyLifetime() {}
func (*GetSpecType_IkeKeylifetimeMinutes) isGetSpecType_IkeKeyLifetime() {}
func (*GetSpecType_IkeKeylifetimeHours) isGetSpecType_IkeKeyLifetime()   {}

func (m *GetSpecType) GetPfsMode() isGetSpecType_PfsMode {
	if m != nil {
		return m.PfsMode
	}
	return nil
}
func (m *GetSpecType) GetIkeKeyLifetime() isGetSpecType_IkeKeyLifetime {
	if m != nil {
		return m.IkeKeyLifetime
	}
	return nil
}

func (m *GetSpecType) GetEncryptionAlgos() []schema.EncryptionAlgorithm {
	if m != nil {
		return m.EncryptionAlgos
	}
	return nil
}

func (m *GetSpecType) GetAuthenticationAlgos() []schema.AuthenticationAlgorithm {
	if m != nil {
		return m.AuthenticationAlgos
	}
	return nil
}

func (m *GetSpecType) GetDisablePfs() *schema.Empty {
	if x, ok := m.GetPfsMode().(*GetSpecType_DisablePfs); ok {
		return x.DisablePfs
	}
	return nil
}

func (m *GetSpecType) GetDhGroupSet() *DHGroups {
	if x, ok := m.GetPfsMode().(*GetSpecType_DhGroupSet); ok {
		return x.DhGroupSet
	}
	return nil
}

func (m *GetSpecType) GetUseDefaultKeylifetime() *schema.Empty {
	if x, ok := m.GetIkeKeyLifetime().(*GetSpecType_UseDefaultKeylifetime); ok {
		return x.UseDefaultKeylifetime
	}
	return nil
}

func (m *GetSpecType) GetIkeKeylifetimeMinutes() *ike_phase1_profile.InputMinutes {
	if x, ok := m.GetIkeKeyLifetime().(*GetSpecType_IkeKeylifetimeMinutes); ok {
		return x.IkeKeylifetimeMinutes
	}
	return nil
}

func (m *GetSpecType) GetIkeKeylifetimeHours() *ike_phase1_profile.InputHours {
	if x, ok := m.GetIkeKeyLifetime().(*GetSpecType_IkeKeylifetimeHours); ok {
		return x.IkeKeylifetimeHours
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_DisablePfs)(nil),
		(*GetSpecType_DhGroupSet)(nil),
		(*GetSpecType_UseDefaultKeylifetime)(nil),
		(*GetSpecType_IkeKeylifetimeMinutes)(nil),
		(*GetSpecType_IkeKeylifetimeHours)(nil),
	}
}

func init() {
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.ike2.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.ike2.GlobalSpecType")
	proto.RegisterType((*DHGroups)(nil), "ves.io.schema.ike2.DHGroups")
	golang_proto.RegisterType((*DHGroups)(nil), "ves.io.schema.ike2.DHGroups")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.ike2.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.ike2.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.ike2.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.ike2.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.ike2.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.ike2.GetSpecType")
}

func init() { proto.RegisterFile("ves.io/schema/ike2/types.proto", fileDescriptor_b1830f638c1c7c2e) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/ike2/types.proto", fileDescriptor_b1830f638c1c7c2e)
}

var fileDescriptor_b1830f638c1c7c2e = []byte{
	// 764 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0xb1, 0x6f, 0xeb, 0x44,
	0x1c, 0xce, 0xc1, 0x0b, 0x84, 0x4b, 0xd4, 0x17, 0xfc, 0x92, 0x57, 0x13, 0x9e, 0x8e, 0x92, 0x01,
	0x75, 0x48, 0x6d, 0xc5, 0x45, 0x42, 0x62, 0x00, 0x5e, 0x28, 0x6a, 0x28, 0x2a, 0x42, 0x29, 0x42,
	0x82, 0xc5, 0x72, 0x92, 0x9f, 0xed, 0x53, 0xec, 0xdc, 0xc9, 0x77, 0x0e, 0x64, 0x40, 0x42, 0x1d,
	0x98, 0xf9, 0x33, 0xf8, 0x1f, 0x3c, 0x50, 0xc1, 0x82, 0x18, 0x50, 0xc6, 0x8c, 0xd4, 0x59, 0x3a,
	0x76, 0xee, 0x84, 0xe2, 0x38, 0x21, 0x4e, 0x2a, 0x24, 0xc4, 0x5b, 0x2a, 0x65, 0xbb, 0xf3, 0xf7,
	0xfd, 0xbe, 0xef, 0xce, 0xbf, 0xef, 0x17, 0x39, 0x98, 0x8c, 0x40, 0x68, 0x94, 0xe9, 0xa2, 0xe7,
	0x82, 0x6f, 0xe9, 0x74, 0x00, 0x86, 0x2e, 0xc7, 0x1c, 0x84, 0xc6, 0x03, 0x26, 0x99, 0xa2, 0x2c,
	0x70, 0x6d, 0x81, 0x6b, 0x73, 0xbc, 0x76, 0xe4, 0x50, 0xe9, 0x86, 0x5d, 0xad, 0xc7, 0x7c, 0xdd,
	0x61, 0x0e, 0xd3, 0x13, 0x6a, 0x37, 0xb4, 0x93, 0x5d, 0xb2, 0x49, 0x56, 0x0b, 0x89, 0x5a, 0x2d,
	0x6b, 0xd1, 0x0b, 0xc6, 0x5c, 0x2e, 0xb1, 0x37, 0xb3, 0x18, 0xe3, 0x92, 0xb2, 0x61, 0xea, 0x5d,
	0x7b, 0x23, 0x0b, 0xae, 0x1d, 0xab, 0xf6, 0x2c, 0x0b, 0x8d, 0x2c, 0x8f, 0xf6, 0x2d, 0x09, 0x29,
	0x7a, 0xb0, 0x81, 0x52, 0xf8, 0xd6, 0xcc, 0x4a, 0x1b, 0xdb, 0x0c, 0x31, 0xbf, 0xbc, 0xc9, 0x5d,
	0x4b, 0x40, 0xd3, 0xe4, 0x01, 0xb3, 0xa9, 0x07, 0x19, 0xcf, 0xb7, 0xee, 0xab, 0x59, 0x23, 0xd4,
	0xff, 0xcc, 0xe3, 0xbd, 0x53, 0x8f, 0x75, 0x2d, 0xef, 0x82, 0x43, 0xef, 0xcb, 0x31, 0x07, 0xe5,
	0x2b, 0x5c, 0x86, 0x61, 0x72, 0x63, 0xca, 0x86, 0xa6, 0xe5, 0x39, 0x4c, 0xa8, 0xe8, 0xe0, 0xe5,
	0xc3, 0x3d, 0xa3, 0xae, 0x65, 0xdf, 0xec, 0x27, 0x2b, 0xda, 0x73, 0xcf, 0x61, 0x01, 0x95, 0xae,
	0xdf, 0x7a, 0x75, 0xfa, 0x3d, 0xba, 0x89, 0x10, 0xea, 0x3c, 0x86, 0x0c, 0x2a, 0x94, 0x2e, 0xae,
	0x58, 0xa1, 0x74, 0x61, 0x28, 0x69, 0xcf, 0x5a, 0xd3, 0x7e, 0x29, 0xd1, 0x7e, 0x67, 0x43, 0xfb,
	0x79, 0x86, 0x7a, 0x8f, 0xfe, 0x13, 0x6b, 0x8b, 0x21, 0x94, 0xf7, 0x70, 0xb1, 0x4f, 0x85, 0xd5,
	0xf5, 0xc0, 0xe4, 0xb6, 0x50, 0x8b, 0x07, 0xe8, 0xb0, 0x68, 0x54, 0x36, 0x8f, 0xed, 0x73, 0x39,
	0x6e, 0xe7, 0x3a, 0x38, 0xa5, 0x7e, 0x61, 0x0b, 0xe5, 0x23, 0x5c, 0xea, 0xbb, 0xa6, 0x13, 0xb0,
	0x90, 0x9b, 0x02, 0xa4, 0x5a, 0x4a, 0x2a, 0x9f, 0x69, 0xdb, 0x51, 0xd2, 0x4e, 0xda, 0xa7, 0x73,
	0x9a, 0x48, 0x14, 0xdc, 0x64, 0x7d, 0x01, 0x52, 0xf9, 0x1c, 0xef, 0x87, 0x02, 0xcc, 0x3e, 0xd8,
	0x56, 0xe8, 0x49, 0x73, 0x00, 0x63, 0x8f, 0xda, 0x20, 0xa9, 0x0f, 0x6a, 0xf5, 0x5f, 0x8e, 0x81,
	0x3a, 0xd5, 0x50, 0xc0, 0xc9, 0xa2, 0xea, 0xb3, 0x7f, 0x8a, 0x94, 0x21, 0xde, 0x9f, 0x37, 0x77,
	0x4d, 0xc7, 0xf4, 0xe9, 0x30, 0x94, 0x20, 0xd4, 0xa7, 0x89, 0xde, 0xbb, 0x1b, 0x7a, 0x49, 0x73,
	0xb5, 0xed, 0x40, 0x68, 0x9f, 0x0e, 0x79, 0x28, 0xcf, 0x17, 0xb5, 0x73, 0x3f, 0x3a, 0x80, 0x35,
	0xa3, 0x14, 0x50, 0x5c, 0x5c, 0xdd, 0xf4, 0x73, 0x59, 0x18, 0x08, 0x75, 0x3f, 0x71, 0x33, 0xfe,
	0x93, 0x5b, 0x7b, 0x5e, 0xd9, 0x46, 0x9d, 0x27, 0x59, 0xaf, 0xe4, 0x71, 0xeb, 0x6d, 0x5c, 0xe0,
	0xb6, 0x30, 0x7d, 0xd6, 0x07, 0xa5, 0x7a, 0x15, 0xa1, 0xd2, 0x24, 0x42, 0x38, 0x8e, 0x50, 0xbe,
	0xd9, 0x6c, 0x34, 0x8d, 0xdb, 0x08, 0xa1, 0x56, 0x03, 0x97, 0xd3, 0xc3, 0x98, 0xab, 0x17, 0xa2,
	0x5e, 0x45, 0xa8, 0x3a, 0x89, 0x50, 0x25, 0x8e, 0x50, 0xc1, 0x68, 0x36, 0x0c, 0xa3, 0x61, 0x1c,
	0xcf, 0xd9, 0x67, 0x8f, 0x0a, 0xb8, 0x5c, 0x3c, 0x7b, 0x54, 0xa8, 0x94, 0xab, 0xf5, 0x0f, 0x71,
	0x61, 0xd9, 0x20, 0xe5, 0x18, 0xbf, 0xb6, 0x6c, 0xea, 0x32, 0xc2, 0x4f, 0x37, 0xae, 0x91, 0x72,
	0x3b, 0x85, 0xb4, 0x93, 0xa2, 0xfe, 0x6b, 0x1e, 0xef, 0x7d, 0x1c, 0x80, 0x25, 0x61, 0x35, 0x11,
	0xe7, 0xff, 0x67, 0x22, 0xb6, 0x07, 0xe1, 0xeb, 0x17, 0x31, 0x08, 0xbb, 0xfc, 0x3f, 0xd4, 0xfc,
	0xbf, 0xff, 0xfa, 0x1f, 0x1f, 0x6c, 0xfc, 0xe6, 0xb6, 0xd4, 0xb5, 0x91, 0x28, 0x5d, 0xde, 0xa1,
	0xd5, 0xae, 0x75, 0x78, 0xcf, 0x24, 0x54, 0x2e, 0xef, 0xd0, 0xd6, 0xd3, 0xcc, 0x14, 0xfc, 0x96,
	0xc7, 0x8f, 0x3b, 0xc0, 0x3d, 0xab, 0xb7, 0x4b, 0xf1, 0x2e, 0xc5, 0x0f, 0x35, 0xc5, 0xbf, 0xe4,
	0x71, 0xf1, 0x14, 0xe4, 0x2e, 0xc1, 0xbb, 0x04, 0x3f, 0xcc, 0x04, 0xb7, 0x7e, 0x44, 0x93, 0x6b,
	0x92, 0x9b, 0x5e, 0x93, 0xdc, 0xed, 0x35, 0x41, 0x3f, 0xc4, 0x04, 0xfd, 0x1c, 0x13, 0xf4, 0x7b,
	0x4c, 0xd0, 0x24, 0x26, 0x68, 0x1a, 0x13, 0xf4, 0x57, 0x4c, 0xd0, 0x4d, 0x4c, 0x72, 0xb7, 0x31,
	0x41, 0x3f, 0xcd, 0x48, 0xee, 0x6a, 0x46, 0xd0, 0x64, 0x46, 0x72, 0xd3, 0x19, 0xc9, 0x7d, 0xd3,
	0x76, 0x18, 0x1f, 0x38, 0xda, 0x88, 0x79, 0x12, 0x82, 0xc0, 0xd2, 0x42, 0xa1, 0x27, 0x0b, 0x9b,
	0x05, 0xfe, 0x11, 0x0f, 0xd8, 0x88, 0xf6, 0x21, 0x38, 0x5a, 0xc2, 0x3a, 0xef, 0x3a, 0x4c, 0x87,
	0xef, 0x64, 0xfa, 0xb5, 0xbf, 0xf6, 0xff, 0xa8, 0xfb, 0x4a, 0xf2, 0xb9, 0x7f, 0xfc, 0x77, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x25, 0xd2, 0x74, 0x67, 0x3c, 0x0d, 0x00, 0x00,
}

func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.EncryptionAlgos) != len(that1.EncryptionAlgos) {
		return false
	}
	for i := range this.EncryptionAlgos {
		if this.EncryptionAlgos[i] != that1.EncryptionAlgos[i] {
			return false
		}
	}
	if len(this.AuthenticationAlgos) != len(that1.AuthenticationAlgos) {
		return false
	}
	for i := range this.AuthenticationAlgos {
		if this.AuthenticationAlgos[i] != that1.AuthenticationAlgos[i] {
			return false
		}
	}
	if that1.PfsMode == nil {
		if this.PfsMode != nil {
			return false
		}
	} else if this.PfsMode == nil {
		return false
	} else if !this.PfsMode.Equal(that1.PfsMode) {
		return false
	}
	if that1.IkeKeyLifetime == nil {
		if this.IkeKeyLifetime != nil {
			return false
		}
	} else if this.IkeKeyLifetime == nil {
		return false
	} else if !this.IkeKeyLifetime.Equal(that1.IkeKeyLifetime) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DisablePfs) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DisablePfs)
	if !ok {
		that2, ok := that.(GlobalSpecType_DisablePfs)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisablePfs.Equal(that1.DisablePfs) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DhGroupSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DhGroupSet)
	if !ok {
		that2, ok := that.(GlobalSpecType_DhGroupSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DhGroupSet.Equal(that1.DhGroupSet) {
		return false
	}
	return true
}
func (this *GlobalSpecType_UseDefaultKeylifetime) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_UseDefaultKeylifetime)
	if !ok {
		that2, ok := that.(GlobalSpecType_UseDefaultKeylifetime)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UseDefaultKeylifetime.Equal(that1.UseDefaultKeylifetime) {
		return false
	}
	return true
}
func (this *GlobalSpecType_IkeKeylifetimeMinutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_IkeKeylifetimeMinutes)
	if !ok {
		that2, ok := that.(GlobalSpecType_IkeKeylifetimeMinutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IkeKeylifetimeMinutes.Equal(that1.IkeKeylifetimeMinutes) {
		return false
	}
	return true
}
func (this *GlobalSpecType_IkeKeylifetimeHours) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_IkeKeylifetimeHours)
	if !ok {
		that2, ok := that.(GlobalSpecType_IkeKeylifetimeHours)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IkeKeylifetimeHours.Equal(that1.IkeKeylifetimeHours) {
		return false
	}
	return true
}
func (this *DHGroups) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHGroups)
	if !ok {
		that2, ok := that.(DHGroups)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.DhGroups) != len(that1.DhGroups) {
		return false
	}
	for i := range this.DhGroups {
		if this.DhGroups[i] != that1.DhGroups[i] {
			return false
		}
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.EncryptionAlgos) != len(that1.EncryptionAlgos) {
		return false
	}
	for i := range this.EncryptionAlgos {
		if this.EncryptionAlgos[i] != that1.EncryptionAlgos[i] {
			return false
		}
	}
	if len(this.AuthenticationAlgos) != len(that1.AuthenticationAlgos) {
		return false
	}
	for i := range this.AuthenticationAlgos {
		if this.AuthenticationAlgos[i] != that1.AuthenticationAlgos[i] {
			return false
		}
	}
	if that1.PfsMode == nil {
		if this.PfsMode != nil {
			return false
		}
	} else if this.PfsMode == nil {
		return false
	} else if !this.PfsMode.Equal(that1.PfsMode) {
		return false
	}
	if that1.IkeKeyLifetime == nil {
		if this.IkeKeyLifetime != nil {
			return false
		}
	} else if this.IkeKeyLifetime == nil {
		return false
	} else if !this.IkeKeyLifetime.Equal(that1.IkeKeyLifetime) {
		return false
	}
	return true
}
func (this *CreateSpecType_DisablePfs) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DisablePfs)
	if !ok {
		that2, ok := that.(CreateSpecType_DisablePfs)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisablePfs.Equal(that1.DisablePfs) {
		return false
	}
	return true
}
func (this *CreateSpecType_DhGroupSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DhGroupSet)
	if !ok {
		that2, ok := that.(CreateSpecType_DhGroupSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DhGroupSet.Equal(that1.DhGroupSet) {
		return false
	}
	return true
}
func (this *CreateSpecType_UseDefaultKeylifetime) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_UseDefaultKeylifetime)
	if !ok {
		that2, ok := that.(CreateSpecType_UseDefaultKeylifetime)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UseDefaultKeylifetime.Equal(that1.UseDefaultKeylifetime) {
		return false
	}
	return true
}
func (this *CreateSpecType_IkeKeylifetimeMinutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_IkeKeylifetimeMinutes)
	if !ok {
		that2, ok := that.(CreateSpecType_IkeKeylifetimeMinutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IkeKeylifetimeMinutes.Equal(that1.IkeKeylifetimeMinutes) {
		return false
	}
	return true
}
func (this *CreateSpecType_IkeKeylifetimeHours) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_IkeKeylifetimeHours)
	if !ok {
		that2, ok := that.(CreateSpecType_IkeKeylifetimeHours)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IkeKeylifetimeHours.Equal(that1.IkeKeylifetimeHours) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.EncryptionAlgos) != len(that1.EncryptionAlgos) {
		return false
	}
	for i := range this.EncryptionAlgos {
		if this.EncryptionAlgos[i] != that1.EncryptionAlgos[i] {
			return false
		}
	}
	if len(this.AuthenticationAlgos) != len(that1.AuthenticationAlgos) {
		return false
	}
	for i := range this.AuthenticationAlgos {
		if this.AuthenticationAlgos[i] != that1.AuthenticationAlgos[i] {
			return false
		}
	}
	if that1.PfsMode == nil {
		if this.PfsMode != nil {
			return false
		}
	} else if this.PfsMode == nil {
		return false
	} else if !this.PfsMode.Equal(that1.PfsMode) {
		return false
	}
	if that1.IkeKeyLifetime == nil {
		if this.IkeKeyLifetime != nil {
			return false
		}
	} else if this.IkeKeyLifetime == nil {
		return false
	} else if !this.IkeKeyLifetime.Equal(that1.IkeKeyLifetime) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DisablePfs) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DisablePfs)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DisablePfs)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisablePfs.Equal(that1.DisablePfs) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DhGroupSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DhGroupSet)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DhGroupSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DhGroupSet.Equal(that1.DhGroupSet) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_UseDefaultKeylifetime) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_UseDefaultKeylifetime)
	if !ok {
		that2, ok := that.(ReplaceSpecType_UseDefaultKeylifetime)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UseDefaultKeylifetime.Equal(that1.UseDefaultKeylifetime) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_IkeKeylifetimeMinutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_IkeKeylifetimeMinutes)
	if !ok {
		that2, ok := that.(ReplaceSpecType_IkeKeylifetimeMinutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IkeKeylifetimeMinutes.Equal(that1.IkeKeylifetimeMinutes) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_IkeKeylifetimeHours) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_IkeKeylifetimeHours)
	if !ok {
		that2, ok := that.(ReplaceSpecType_IkeKeylifetimeHours)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IkeKeylifetimeHours.Equal(that1.IkeKeylifetimeHours) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.EncryptionAlgos) != len(that1.EncryptionAlgos) {
		return false
	}
	for i := range this.EncryptionAlgos {
		if this.EncryptionAlgos[i] != that1.EncryptionAlgos[i] {
			return false
		}
	}
	if len(this.AuthenticationAlgos) != len(that1.AuthenticationAlgos) {
		return false
	}
	for i := range this.AuthenticationAlgos {
		if this.AuthenticationAlgos[i] != that1.AuthenticationAlgos[i] {
			return false
		}
	}
	if that1.PfsMode == nil {
		if this.PfsMode != nil {
			return false
		}
	} else if this.PfsMode == nil {
		return false
	} else if !this.PfsMode.Equal(that1.PfsMode) {
		return false
	}
	if that1.IkeKeyLifetime == nil {
		if this.IkeKeyLifetime != nil {
			return false
		}
	} else if this.IkeKeyLifetime == nil {
		return false
	} else if !this.IkeKeyLifetime.Equal(that1.IkeKeyLifetime) {
		return false
	}
	return true
}
func (this *GetSpecType_DisablePfs) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DisablePfs)
	if !ok {
		that2, ok := that.(GetSpecType_DisablePfs)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisablePfs.Equal(that1.DisablePfs) {
		return false
	}
	return true
}
func (this *GetSpecType_DhGroupSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DhGroupSet)
	if !ok {
		that2, ok := that.(GetSpecType_DhGroupSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DhGroupSet.Equal(that1.DhGroupSet) {
		return false
	}
	return true
}
func (this *GetSpecType_UseDefaultKeylifetime) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_UseDefaultKeylifetime)
	if !ok {
		that2, ok := that.(GetSpecType_UseDefaultKeylifetime)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UseDefaultKeylifetime.Equal(that1.UseDefaultKeylifetime) {
		return false
	}
	return true
}
func (this *GetSpecType_IkeKeylifetimeMinutes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_IkeKeylifetimeMinutes)
	if !ok {
		that2, ok := that.(GetSpecType_IkeKeylifetimeMinutes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IkeKeylifetimeMinutes.Equal(that1.IkeKeylifetimeMinutes) {
		return false
	}
	return true
}
func (this *GetSpecType_IkeKeylifetimeHours) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_IkeKeylifetimeHours)
	if !ok {
		that2, ok := that.(GetSpecType_IkeKeylifetimeHours)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IkeKeylifetimeHours.Equal(that1.IkeKeylifetimeHours) {
		return false
	}
	return true
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&ike2.GlobalSpecType{")
	s = append(s, "EncryptionAlgos: "+fmt.Sprintf("%#v", this.EncryptionAlgos)+",\n")
	s = append(s, "AuthenticationAlgos: "+fmt.Sprintf("%#v", this.AuthenticationAlgos)+",\n")
	if this.PfsMode != nil {
		s = append(s, "PfsMode: "+fmt.Sprintf("%#v", this.PfsMode)+",\n")
	}
	if this.IkeKeyLifetime != nil {
		s = append(s, "IkeKeyLifetime: "+fmt.Sprintf("%#v", this.IkeKeyLifetime)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_DisablePfs) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ike2.GlobalSpecType_DisablePfs{` +
		`DisablePfs:` + fmt.Sprintf("%#v", this.DisablePfs) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DhGroupSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ike2.GlobalSpecType_DhGroupSet{` +
		`DhGroupSet:` + fmt.Sprintf("%#v", this.DhGroupSet) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_UseDefaultKeylifetime) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ike2.GlobalSpecType_UseDefaultKeylifetime{` +
		`UseDefaultKeylifetime:` + fmt.Sprintf("%#v", this.UseDefaultKeylifetime) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_IkeKeylifetimeMinutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ike2.GlobalSpecType_IkeKeylifetimeMinutes{` +
		`IkeKeylifetimeMinutes:` + fmt.Sprintf("%#v", this.IkeKeylifetimeMinutes) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_IkeKeylifetimeHours) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ike2.GlobalSpecType_IkeKeylifetimeHours{` +
		`IkeKeylifetimeHours:` + fmt.Sprintf("%#v", this.IkeKeylifetimeHours) + `}`}, ", ")
	return s
}
func (this *DHGroups) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&ike2.DHGroups{")
	s = append(s, "DhGroups: "+fmt.Sprintf("%#v", this.DhGroups)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&ike2.CreateSpecType{")
	s = append(s, "EncryptionAlgos: "+fmt.Sprintf("%#v", this.EncryptionAlgos)+",\n")
	s = append(s, "AuthenticationAlgos: "+fmt.Sprintf("%#v", this.AuthenticationAlgos)+",\n")
	if this.PfsMode != nil {
		s = append(s, "PfsMode: "+fmt.Sprintf("%#v", this.PfsMode)+",\n")
	}
	if this.IkeKeyLifetime != nil {
		s = append(s, "IkeKeyLifetime: "+fmt.Sprintf("%#v", this.IkeKeyLifetime)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_DisablePfs) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ike2.CreateSpecType_DisablePfs{` +
		`DisablePfs:` + fmt.Sprintf("%#v", this.DisablePfs) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DhGroupSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ike2.CreateSpecType_DhGroupSet{` +
		`DhGroupSet:` + fmt.Sprintf("%#v", this.DhGroupSet) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_UseDefaultKeylifetime) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ike2.CreateSpecType_UseDefaultKeylifetime{` +
		`UseDefaultKeylifetime:` + fmt.Sprintf("%#v", this.UseDefaultKeylifetime) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_IkeKeylifetimeMinutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ike2.CreateSpecType_IkeKeylifetimeMinutes{` +
		`IkeKeylifetimeMinutes:` + fmt.Sprintf("%#v", this.IkeKeylifetimeMinutes) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_IkeKeylifetimeHours) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ike2.CreateSpecType_IkeKeylifetimeHours{` +
		`IkeKeylifetimeHours:` + fmt.Sprintf("%#v", this.IkeKeylifetimeHours) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&ike2.ReplaceSpecType{")
	s = append(s, "EncryptionAlgos: "+fmt.Sprintf("%#v", this.EncryptionAlgos)+",\n")
	s = append(s, "AuthenticationAlgos: "+fmt.Sprintf("%#v", this.AuthenticationAlgos)+",\n")
	if this.PfsMode != nil {
		s = append(s, "PfsMode: "+fmt.Sprintf("%#v", this.PfsMode)+",\n")
	}
	if this.IkeKeyLifetime != nil {
		s = append(s, "IkeKeyLifetime: "+fmt.Sprintf("%#v", this.IkeKeyLifetime)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_DisablePfs) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ike2.ReplaceSpecType_DisablePfs{` +
		`DisablePfs:` + fmt.Sprintf("%#v", this.DisablePfs) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DhGroupSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ike2.ReplaceSpecType_DhGroupSet{` +
		`DhGroupSet:` + fmt.Sprintf("%#v", this.DhGroupSet) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_UseDefaultKeylifetime) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ike2.ReplaceSpecType_UseDefaultKeylifetime{` +
		`UseDefaultKeylifetime:` + fmt.Sprintf("%#v", this.UseDefaultKeylifetime) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_IkeKeylifetimeMinutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ike2.ReplaceSpecType_IkeKeylifetimeMinutes{` +
		`IkeKeylifetimeMinutes:` + fmt.Sprintf("%#v", this.IkeKeylifetimeMinutes) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_IkeKeylifetimeHours) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ike2.ReplaceSpecType_IkeKeylifetimeHours{` +
		`IkeKeylifetimeHours:` + fmt.Sprintf("%#v", this.IkeKeylifetimeHours) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&ike2.GetSpecType{")
	s = append(s, "EncryptionAlgos: "+fmt.Sprintf("%#v", this.EncryptionAlgos)+",\n")
	s = append(s, "AuthenticationAlgos: "+fmt.Sprintf("%#v", this.AuthenticationAlgos)+",\n")
	if this.PfsMode != nil {
		s = append(s, "PfsMode: "+fmt.Sprintf("%#v", this.PfsMode)+",\n")
	}
	if this.IkeKeyLifetime != nil {
		s = append(s, "IkeKeyLifetime: "+fmt.Sprintf("%#v", this.IkeKeyLifetime)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_DisablePfs) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ike2.GetSpecType_DisablePfs{` +
		`DisablePfs:` + fmt.Sprintf("%#v", this.DisablePfs) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DhGroupSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ike2.GetSpecType_DhGroupSet{` +
		`DhGroupSet:` + fmt.Sprintf("%#v", this.DhGroupSet) + `}`}, ", ")
	return s
}
func (this *GetSpecType_UseDefaultKeylifetime) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ike2.GetSpecType_UseDefaultKeylifetime{` +
		`UseDefaultKeylifetime:` + fmt.Sprintf("%#v", this.UseDefaultKeylifetime) + `}`}, ", ")
	return s
}
func (this *GetSpecType_IkeKeylifetimeMinutes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ike2.GetSpecType_IkeKeylifetimeMinutes{` +
		`IkeKeylifetimeMinutes:` + fmt.Sprintf("%#v", this.IkeKeylifetimeMinutes) + `}`}, ", ")
	return s
}
func (this *GetSpecType_IkeKeylifetimeHours) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ike2.GetSpecType_IkeKeylifetimeHours{` +
		`IkeKeylifetimeHours:` + fmt.Sprintf("%#v", this.IkeKeylifetimeHours) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IkeKeyLifetime != nil {
		{
			size := m.IkeKeyLifetime.Size()
			i -= size
			if _, err := m.IkeKeyLifetime.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PfsMode != nil {
		{
			size := m.PfsMode.Size()
			i -= size
			if _, err := m.PfsMode.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.AuthenticationAlgos) > 0 {
		dAtA2 := make([]byte, len(m.AuthenticationAlgos)*10)
		var j1 int
		for _, num := range m.AuthenticationAlgos {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintTypes(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EncryptionAlgos) > 0 {
		dAtA4 := make([]byte, len(m.EncryptionAlgos)*10)
		var j3 int
		for _, num := range m.EncryptionAlgos {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintTypes(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_DisablePfs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DisablePfs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisablePfs != nil {
		{
			size, err := m.DisablePfs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DhGroupSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DhGroupSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DhGroupSet != nil {
		{
			size, err := m.DhGroupSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_UseDefaultKeylifetime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_UseDefaultKeylifetime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UseDefaultKeylifetime != nil {
		{
			size, err := m.UseDefaultKeylifetime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_IkeKeylifetimeMinutes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_IkeKeylifetimeMinutes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IkeKeylifetimeMinutes != nil {
		{
			size, err := m.IkeKeylifetimeMinutes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_IkeKeylifetimeHours) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_IkeKeylifetimeHours) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IkeKeylifetimeHours != nil {
		{
			size, err := m.IkeKeylifetimeHours.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *DHGroups) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHGroups) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHGroups) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DhGroups) > 0 {
		dAtA11 := make([]byte, len(m.DhGroups)*10)
		var j10 int
		for _, num := range m.DhGroups {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintTypes(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IkeKeyLifetime != nil {
		{
			size := m.IkeKeyLifetime.Size()
			i -= size
			if _, err := m.IkeKeyLifetime.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PfsMode != nil {
		{
			size := m.PfsMode.Size()
			i -= size
			if _, err := m.PfsMode.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.AuthenticationAlgos) > 0 {
		dAtA13 := make([]byte, len(m.AuthenticationAlgos)*10)
		var j12 int
		for _, num := range m.AuthenticationAlgos {
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintTypes(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EncryptionAlgos) > 0 {
		dAtA15 := make([]byte, len(m.EncryptionAlgos)*10)
		var j14 int
		for _, num := range m.EncryptionAlgos {
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		i -= j14
		copy(dAtA[i:], dAtA15[:j14])
		i = encodeVarintTypes(dAtA, i, uint64(j14))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_DisablePfs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DisablePfs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisablePfs != nil {
		{
			size, err := m.DisablePfs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DhGroupSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DhGroupSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DhGroupSet != nil {
		{
			size, err := m.DhGroupSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_UseDefaultKeylifetime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_UseDefaultKeylifetime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UseDefaultKeylifetime != nil {
		{
			size, err := m.UseDefaultKeylifetime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_IkeKeylifetimeMinutes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_IkeKeylifetimeMinutes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IkeKeylifetimeMinutes != nil {
		{
			size, err := m.IkeKeylifetimeMinutes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_IkeKeylifetimeHours) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_IkeKeylifetimeHours) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IkeKeylifetimeHours != nil {
		{
			size, err := m.IkeKeylifetimeHours.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IkeKeyLifetime != nil {
		{
			size := m.IkeKeyLifetime.Size()
			i -= size
			if _, err := m.IkeKeyLifetime.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PfsMode != nil {
		{
			size := m.PfsMode.Size()
			i -= size
			if _, err := m.PfsMode.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.AuthenticationAlgos) > 0 {
		dAtA22 := make([]byte, len(m.AuthenticationAlgos)*10)
		var j21 int
		for _, num := range m.AuthenticationAlgos {
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		i -= j21
		copy(dAtA[i:], dAtA22[:j21])
		i = encodeVarintTypes(dAtA, i, uint64(j21))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EncryptionAlgos) > 0 {
		dAtA24 := make([]byte, len(m.EncryptionAlgos)*10)
		var j23 int
		for _, num := range m.EncryptionAlgos {
			for num >= 1<<7 {
				dAtA24[j23] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j23++
			}
			dAtA24[j23] = uint8(num)
			j23++
		}
		i -= j23
		copy(dAtA[i:], dAtA24[:j23])
		i = encodeVarintTypes(dAtA, i, uint64(j23))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_DisablePfs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DisablePfs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisablePfs != nil {
		{
			size, err := m.DisablePfs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DhGroupSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DhGroupSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DhGroupSet != nil {
		{
			size, err := m.DhGroupSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_UseDefaultKeylifetime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_UseDefaultKeylifetime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UseDefaultKeylifetime != nil {
		{
			size, err := m.UseDefaultKeylifetime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_IkeKeylifetimeMinutes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_IkeKeylifetimeMinutes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IkeKeylifetimeMinutes != nil {
		{
			size, err := m.IkeKeylifetimeMinutes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_IkeKeylifetimeHours) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_IkeKeylifetimeHours) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IkeKeylifetimeHours != nil {
		{
			size, err := m.IkeKeylifetimeHours.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IkeKeyLifetime != nil {
		{
			size := m.IkeKeyLifetime.Size()
			i -= size
			if _, err := m.IkeKeyLifetime.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PfsMode != nil {
		{
			size := m.PfsMode.Size()
			i -= size
			if _, err := m.PfsMode.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.AuthenticationAlgos) > 0 {
		dAtA31 := make([]byte, len(m.AuthenticationAlgos)*10)
		var j30 int
		for _, num := range m.AuthenticationAlgos {
			for num >= 1<<7 {
				dAtA31[j30] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j30++
			}
			dAtA31[j30] = uint8(num)
			j30++
		}
		i -= j30
		copy(dAtA[i:], dAtA31[:j30])
		i = encodeVarintTypes(dAtA, i, uint64(j30))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EncryptionAlgos) > 0 {
		dAtA33 := make([]byte, len(m.EncryptionAlgos)*10)
		var j32 int
		for _, num := range m.EncryptionAlgos {
			for num >= 1<<7 {
				dAtA33[j32] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j32++
			}
			dAtA33[j32] = uint8(num)
			j32++
		}
		i -= j32
		copy(dAtA[i:], dAtA33[:j32])
		i = encodeVarintTypes(dAtA, i, uint64(j32))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_DisablePfs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DisablePfs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisablePfs != nil {
		{
			size, err := m.DisablePfs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DhGroupSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DhGroupSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DhGroupSet != nil {
		{
			size, err := m.DhGroupSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_UseDefaultKeylifetime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_UseDefaultKeylifetime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UseDefaultKeylifetime != nil {
		{
			size, err := m.UseDefaultKeylifetime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_IkeKeylifetimeMinutes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_IkeKeylifetimeMinutes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IkeKeylifetimeMinutes != nil {
		{
			size, err := m.IkeKeylifetimeMinutes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_IkeKeylifetimeHours) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_IkeKeylifetimeHours) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IkeKeylifetimeHours != nil {
		{
			size, err := m.IkeKeylifetimeHours.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EncryptionAlgos) > 0 {
		l = 0
		for _, e := range m.EncryptionAlgos {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.AuthenticationAlgos) > 0 {
		l = 0
		for _, e := range m.AuthenticationAlgos {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.PfsMode != nil {
		n += m.PfsMode.Size()
	}
	if m.IkeKeyLifetime != nil {
		n += m.IkeKeyLifetime.Size()
	}
	return n
}

func (m *GlobalSpecType_DisablePfs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisablePfs != nil {
		l = m.DisablePfs.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DhGroupSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DhGroupSet != nil {
		l = m.DhGroupSet.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_UseDefaultKeylifetime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseDefaultKeylifetime != nil {
		l = m.UseDefaultKeylifetime.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_IkeKeylifetimeMinutes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IkeKeylifetimeMinutes != nil {
		l = m.IkeKeylifetimeMinutes.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_IkeKeylifetimeHours) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IkeKeylifetimeHours != nil {
		l = m.IkeKeylifetimeHours.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DHGroups) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DhGroups) > 0 {
		l = 0
		for _, e := range m.DhGroups {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EncryptionAlgos) > 0 {
		l = 0
		for _, e := range m.EncryptionAlgos {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.AuthenticationAlgos) > 0 {
		l = 0
		for _, e := range m.AuthenticationAlgos {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.PfsMode != nil {
		n += m.PfsMode.Size()
	}
	if m.IkeKeyLifetime != nil {
		n += m.IkeKeyLifetime.Size()
	}
	return n
}

func (m *CreateSpecType_DisablePfs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisablePfs != nil {
		l = m.DisablePfs.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DhGroupSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DhGroupSet != nil {
		l = m.DhGroupSet.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_UseDefaultKeylifetime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseDefaultKeylifetime != nil {
		l = m.UseDefaultKeylifetime.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_IkeKeylifetimeMinutes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IkeKeylifetimeMinutes != nil {
		l = m.IkeKeylifetimeMinutes.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_IkeKeylifetimeHours) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IkeKeylifetimeHours != nil {
		l = m.IkeKeylifetimeHours.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EncryptionAlgos) > 0 {
		l = 0
		for _, e := range m.EncryptionAlgos {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.AuthenticationAlgos) > 0 {
		l = 0
		for _, e := range m.AuthenticationAlgos {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.PfsMode != nil {
		n += m.PfsMode.Size()
	}
	if m.IkeKeyLifetime != nil {
		n += m.IkeKeyLifetime.Size()
	}
	return n
}

func (m *ReplaceSpecType_DisablePfs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisablePfs != nil {
		l = m.DisablePfs.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DhGroupSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DhGroupSet != nil {
		l = m.DhGroupSet.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_UseDefaultKeylifetime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseDefaultKeylifetime != nil {
		l = m.UseDefaultKeylifetime.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_IkeKeylifetimeMinutes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IkeKeylifetimeMinutes != nil {
		l = m.IkeKeylifetimeMinutes.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_IkeKeylifetimeHours) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IkeKeylifetimeHours != nil {
		l = m.IkeKeylifetimeHours.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EncryptionAlgos) > 0 {
		l = 0
		for _, e := range m.EncryptionAlgos {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.AuthenticationAlgos) > 0 {
		l = 0
		for _, e := range m.AuthenticationAlgos {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.PfsMode != nil {
		n += m.PfsMode.Size()
	}
	if m.IkeKeyLifetime != nil {
		n += m.IkeKeyLifetime.Size()
	}
	return n
}

func (m *GetSpecType_DisablePfs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisablePfs != nil {
		l = m.DisablePfs.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DhGroupSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DhGroupSet != nil {
		l = m.DhGroupSet.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_UseDefaultKeylifetime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseDefaultKeylifetime != nil {
		l = m.UseDefaultKeylifetime.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_IkeKeylifetimeMinutes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IkeKeylifetimeMinutes != nil {
		l = m.IkeKeylifetimeMinutes.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_IkeKeylifetimeHours) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IkeKeylifetimeHours != nil {
		l = m.IkeKeylifetimeHours.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`EncryptionAlgos:` + fmt.Sprintf("%v", this.EncryptionAlgos) + `,`,
		`AuthenticationAlgos:` + fmt.Sprintf("%v", this.AuthenticationAlgos) + `,`,
		`PfsMode:` + fmt.Sprintf("%v", this.PfsMode) + `,`,
		`IkeKeyLifetime:` + fmt.Sprintf("%v", this.IkeKeyLifetime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DisablePfs) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DisablePfs{`,
		`DisablePfs:` + strings.Replace(fmt.Sprintf("%v", this.DisablePfs), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DhGroupSet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DhGroupSet{`,
		`DhGroupSet:` + strings.Replace(fmt.Sprintf("%v", this.DhGroupSet), "DHGroups", "DHGroups", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_UseDefaultKeylifetime) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_UseDefaultKeylifetime{`,
		`UseDefaultKeylifetime:` + strings.Replace(fmt.Sprintf("%v", this.UseDefaultKeylifetime), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_IkeKeylifetimeMinutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_IkeKeylifetimeMinutes{`,
		`IkeKeylifetimeMinutes:` + strings.Replace(fmt.Sprintf("%v", this.IkeKeylifetimeMinutes), "InputMinutes", "ike_phase1_profile.InputMinutes", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_IkeKeylifetimeHours) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_IkeKeylifetimeHours{`,
		`IkeKeylifetimeHours:` + strings.Replace(fmt.Sprintf("%v", this.IkeKeylifetimeHours), "InputHours", "ike_phase1_profile.InputHours", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHGroups) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHGroups{`,
		`DhGroups:` + fmt.Sprintf("%v", this.DhGroups) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`EncryptionAlgos:` + fmt.Sprintf("%v", this.EncryptionAlgos) + `,`,
		`AuthenticationAlgos:` + fmt.Sprintf("%v", this.AuthenticationAlgos) + `,`,
		`PfsMode:` + fmt.Sprintf("%v", this.PfsMode) + `,`,
		`IkeKeyLifetime:` + fmt.Sprintf("%v", this.IkeKeyLifetime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DisablePfs) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DisablePfs{`,
		`DisablePfs:` + strings.Replace(fmt.Sprintf("%v", this.DisablePfs), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DhGroupSet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DhGroupSet{`,
		`DhGroupSet:` + strings.Replace(fmt.Sprintf("%v", this.DhGroupSet), "DHGroups", "DHGroups", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_UseDefaultKeylifetime) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_UseDefaultKeylifetime{`,
		`UseDefaultKeylifetime:` + strings.Replace(fmt.Sprintf("%v", this.UseDefaultKeylifetime), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_IkeKeylifetimeMinutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_IkeKeylifetimeMinutes{`,
		`IkeKeylifetimeMinutes:` + strings.Replace(fmt.Sprintf("%v", this.IkeKeylifetimeMinutes), "InputMinutes", "ike_phase1_profile.InputMinutes", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_IkeKeylifetimeHours) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_IkeKeylifetimeHours{`,
		`IkeKeylifetimeHours:` + strings.Replace(fmt.Sprintf("%v", this.IkeKeylifetimeHours), "InputHours", "ike_phase1_profile.InputHours", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`EncryptionAlgos:` + fmt.Sprintf("%v", this.EncryptionAlgos) + `,`,
		`AuthenticationAlgos:` + fmt.Sprintf("%v", this.AuthenticationAlgos) + `,`,
		`PfsMode:` + fmt.Sprintf("%v", this.PfsMode) + `,`,
		`IkeKeyLifetime:` + fmt.Sprintf("%v", this.IkeKeyLifetime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DisablePfs) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DisablePfs{`,
		`DisablePfs:` + strings.Replace(fmt.Sprintf("%v", this.DisablePfs), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DhGroupSet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DhGroupSet{`,
		`DhGroupSet:` + strings.Replace(fmt.Sprintf("%v", this.DhGroupSet), "DHGroups", "DHGroups", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_UseDefaultKeylifetime) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_UseDefaultKeylifetime{`,
		`UseDefaultKeylifetime:` + strings.Replace(fmt.Sprintf("%v", this.UseDefaultKeylifetime), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_IkeKeylifetimeMinutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_IkeKeylifetimeMinutes{`,
		`IkeKeylifetimeMinutes:` + strings.Replace(fmt.Sprintf("%v", this.IkeKeylifetimeMinutes), "InputMinutes", "ike_phase1_profile.InputMinutes", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_IkeKeylifetimeHours) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_IkeKeylifetimeHours{`,
		`IkeKeylifetimeHours:` + strings.Replace(fmt.Sprintf("%v", this.IkeKeylifetimeHours), "InputHours", "ike_phase1_profile.InputHours", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`EncryptionAlgos:` + fmt.Sprintf("%v", this.EncryptionAlgos) + `,`,
		`AuthenticationAlgos:` + fmt.Sprintf("%v", this.AuthenticationAlgos) + `,`,
		`PfsMode:` + fmt.Sprintf("%v", this.PfsMode) + `,`,
		`IkeKeyLifetime:` + fmt.Sprintf("%v", this.IkeKeyLifetime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DisablePfs) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DisablePfs{`,
		`DisablePfs:` + strings.Replace(fmt.Sprintf("%v", this.DisablePfs), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DhGroupSet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DhGroupSet{`,
		`DhGroupSet:` + strings.Replace(fmt.Sprintf("%v", this.DhGroupSet), "DHGroups", "DHGroups", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_UseDefaultKeylifetime) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_UseDefaultKeylifetime{`,
		`UseDefaultKeylifetime:` + strings.Replace(fmt.Sprintf("%v", this.UseDefaultKeylifetime), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_IkeKeylifetimeMinutes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_IkeKeylifetimeMinutes{`,
		`IkeKeylifetimeMinutes:` + strings.Replace(fmt.Sprintf("%v", this.IkeKeylifetimeMinutes), "InputMinutes", "ike_phase1_profile.InputMinutes", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_IkeKeylifetimeHours) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_IkeKeylifetimeHours{`,
		`IkeKeylifetimeHours:` + strings.Replace(fmt.Sprintf("%v", this.IkeKeylifetimeHours), "InputHours", "ike_phase1_profile.InputHours", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v schema.EncryptionAlgorithm
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= schema.EncryptionAlgorithm(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EncryptionAlgos = append(m.EncryptionAlgos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.EncryptionAlgos) == 0 {
					m.EncryptionAlgos = make([]schema.EncryptionAlgorithm, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v schema.EncryptionAlgorithm
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= schema.EncryptionAlgorithm(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EncryptionAlgos = append(m.EncryptionAlgos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionAlgos", wireType)
			}
		case 2:
			if wireType == 0 {
				var v schema.AuthenticationAlgorithm
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= schema.AuthenticationAlgorithm(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AuthenticationAlgos = append(m.AuthenticationAlgos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.AuthenticationAlgos) == 0 {
					m.AuthenticationAlgos = make([]schema.AuthenticationAlgorithm, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v schema.AuthenticationAlgorithm
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= schema.AuthenticationAlgorithm(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AuthenticationAlgos = append(m.AuthenticationAlgos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationAlgos", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisablePfs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PfsMode = &GlobalSpecType_DisablePfs{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhGroupSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DHGroups{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PfsMode = &GlobalSpecType_DhGroupSet{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseDefaultKeylifetime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IkeKeyLifetime = &GlobalSpecType_UseDefaultKeylifetime{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IkeKeylifetimeMinutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ike_phase1_profile.InputMinutes{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IkeKeyLifetime = &GlobalSpecType_IkeKeylifetimeMinutes{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IkeKeylifetimeHours", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ike_phase1_profile.InputHours{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IkeKeyLifetime = &GlobalSpecType_IkeKeylifetimeHours{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHGroups) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHGroups: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHGroups: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v schema.DHGroup
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= schema.DHGroup(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DhGroups = append(m.DhGroups, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.DhGroups) == 0 {
					m.DhGroups = make([]schema.DHGroup, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v schema.DHGroup
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= schema.DHGroup(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DhGroups = append(m.DhGroups, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DhGroups", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v schema.EncryptionAlgorithm
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= schema.EncryptionAlgorithm(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EncryptionAlgos = append(m.EncryptionAlgos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.EncryptionAlgos) == 0 {
					m.EncryptionAlgos = make([]schema.EncryptionAlgorithm, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v schema.EncryptionAlgorithm
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= schema.EncryptionAlgorithm(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EncryptionAlgos = append(m.EncryptionAlgos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionAlgos", wireType)
			}
		case 2:
			if wireType == 0 {
				var v schema.AuthenticationAlgorithm
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= schema.AuthenticationAlgorithm(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AuthenticationAlgos = append(m.AuthenticationAlgos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.AuthenticationAlgos) == 0 {
					m.AuthenticationAlgos = make([]schema.AuthenticationAlgorithm, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v schema.AuthenticationAlgorithm
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= schema.AuthenticationAlgorithm(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AuthenticationAlgos = append(m.AuthenticationAlgos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationAlgos", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisablePfs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PfsMode = &CreateSpecType_DisablePfs{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhGroupSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DHGroups{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PfsMode = &CreateSpecType_DhGroupSet{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseDefaultKeylifetime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IkeKeyLifetime = &CreateSpecType_UseDefaultKeylifetime{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IkeKeylifetimeMinutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ike_phase1_profile.InputMinutes{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IkeKeyLifetime = &CreateSpecType_IkeKeylifetimeMinutes{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IkeKeylifetimeHours", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ike_phase1_profile.InputHours{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IkeKeyLifetime = &CreateSpecType_IkeKeylifetimeHours{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v schema.EncryptionAlgorithm
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= schema.EncryptionAlgorithm(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EncryptionAlgos = append(m.EncryptionAlgos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.EncryptionAlgos) == 0 {
					m.EncryptionAlgos = make([]schema.EncryptionAlgorithm, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v schema.EncryptionAlgorithm
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= schema.EncryptionAlgorithm(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EncryptionAlgos = append(m.EncryptionAlgos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionAlgos", wireType)
			}
		case 2:
			if wireType == 0 {
				var v schema.AuthenticationAlgorithm
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= schema.AuthenticationAlgorithm(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AuthenticationAlgos = append(m.AuthenticationAlgos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.AuthenticationAlgos) == 0 {
					m.AuthenticationAlgos = make([]schema.AuthenticationAlgorithm, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v schema.AuthenticationAlgorithm
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= schema.AuthenticationAlgorithm(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AuthenticationAlgos = append(m.AuthenticationAlgos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationAlgos", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisablePfs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PfsMode = &ReplaceSpecType_DisablePfs{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhGroupSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DHGroups{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PfsMode = &ReplaceSpecType_DhGroupSet{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseDefaultKeylifetime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IkeKeyLifetime = &ReplaceSpecType_UseDefaultKeylifetime{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IkeKeylifetimeMinutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ike_phase1_profile.InputMinutes{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IkeKeyLifetime = &ReplaceSpecType_IkeKeylifetimeMinutes{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IkeKeylifetimeHours", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ike_phase1_profile.InputHours{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IkeKeyLifetime = &ReplaceSpecType_IkeKeylifetimeHours{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v schema.EncryptionAlgorithm
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= schema.EncryptionAlgorithm(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EncryptionAlgos = append(m.EncryptionAlgos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.EncryptionAlgos) == 0 {
					m.EncryptionAlgos = make([]schema.EncryptionAlgorithm, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v schema.EncryptionAlgorithm
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= schema.EncryptionAlgorithm(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EncryptionAlgos = append(m.EncryptionAlgos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionAlgos", wireType)
			}
		case 2:
			if wireType == 0 {
				var v schema.AuthenticationAlgorithm
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= schema.AuthenticationAlgorithm(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AuthenticationAlgos = append(m.AuthenticationAlgos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.AuthenticationAlgos) == 0 {
					m.AuthenticationAlgos = make([]schema.AuthenticationAlgorithm, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v schema.AuthenticationAlgorithm
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= schema.AuthenticationAlgorithm(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AuthenticationAlgos = append(m.AuthenticationAlgos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationAlgos", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisablePfs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PfsMode = &GetSpecType_DisablePfs{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhGroupSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DHGroups{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PfsMode = &GetSpecType_DhGroupSet{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseDefaultKeylifetime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IkeKeyLifetime = &GetSpecType_UseDefaultKeylifetime{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IkeKeylifetimeMinutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ike_phase1_profile.InputMinutes{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IkeKeyLifetime = &GetSpecType_IkeKeylifetimeMinutes{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IkeKeylifetimeHours", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ike_phase1_profile.InputHours{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.IkeKeyLifetime = &GetSpecType_IkeKeylifetimeHours{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
