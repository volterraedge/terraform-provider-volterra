// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/cloud_connect/types.proto

package cloud_connect

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	cloud_re_region "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/cloud_re_region"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// CloudConnect State
//
// x-displayName: "CloudConnect State"
// State of the CloudConnect connections
type CloudConnectState int32

const (
	// Down
	//
	// x-displayName: "Down"
	// CloudConnect and their corresponding vpc attachments are down
	DOWN CloudConnectState = 0
	// Degraded
	//
	// x-displayName: "Degraded"
	// Some of vpc attachments with the CloudConnect are down
	DEGRADED CloudConnectState = 1
	// Up
	//
	// x-displayName: "Up"
	// CloudConnect and their corresponding vpc attachments are available and healthy
	UP CloudConnectState = 2
)

var CloudConnectState_name = map[int32]string{
	0: "DOWN",
	1: "DEGRADED",
	2: "UP",
}

var CloudConnectState_value = map[string]int32{
	"DOWN":     0,
	"DEGRADED": 1,
	"UP":       2,
}

func (CloudConnectState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{0}
}

// Cloud Connect AWS Type
//
// x-displayName: "AWS"
type AWSREType struct {
	// Region
	//
	// x-displayName: "Cloud Edge"
	// x-required
	Region *views.ObjectRefType `protobuf:"bytes,1,opt,name=region,proto3" json:"region,omitempty"`
	// Cloud Credential
	//
	// x-displayName: "Credential"
	// Select a cloud credential to begin onboarding VPCs
	// x-required
	Cred *views.ObjectRefType `protobuf:"bytes,2,opt,name=cred,proto3" json:"cred,omitempty"`
	// VPC Attachement List
	//
	// x-displayName: "VPC Attachement List"
	VpcAttachments *AWSVPCAttachmentListType `protobuf:"bytes,3,opt,name=vpc_attachments,json=vpcAttachments,proto3" json:"vpc_attachments,omitempty"`
	// Cloud Links
	//
	// x-displayName: "CloudLink"
	// Reference to cloud link
	CloudLinks *CloudLinkListType `protobuf:"bytes,4,opt,name=cloud_links,json=cloudLinks,proto3" json:"cloud_links,omitempty"`
	// TGW Name
	//
	// x-displayName: "TGW Name"
	Tgw string `protobuf:"bytes,5,opt,name=tgw,proto3" json:"tgw,omitempty"`
	// Peers
	//
	// x-displayName: "Peers"
	// Peers
	Peers []*PeerType `protobuf:"bytes,9,rep,name=peers,proto3" json:"peers,omitempty"`
}

func (m *AWSREType) Reset()      { *m = AWSREType{} }
func (*AWSREType) ProtoMessage() {}
func (*AWSREType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{0}
}
func (m *AWSREType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSREType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSREType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSREType.Merge(m, src)
}
func (m *AWSREType) XXX_Size() int {
	return m.Size()
}
func (m *AWSREType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSREType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSREType proto.InternalMessageInfo

func (m *AWSREType) GetRegion() *views.ObjectRefType {
	if m != nil {
		return m.Region
	}
	return nil
}

func (m *AWSREType) GetCred() *views.ObjectRefType {
	if m != nil {
		return m.Cred
	}
	return nil
}

func (m *AWSREType) GetVpcAttachments() *AWSVPCAttachmentListType {
	if m != nil {
		return m.VpcAttachments
	}
	return nil
}

func (m *AWSREType) GetCloudLinks() *CloudLinkListType {
	if m != nil {
		return m.CloudLinks
	}
	return nil
}

func (m *AWSREType) GetTgw() string {
	if m != nil {
		return m.Tgw
	}
	return ""
}

func (m *AWSREType) GetPeers() []*PeerType {
	if m != nil {
		return m.Peers
	}
	return nil
}

// Cloud Links
//
// x-displayName: "Cloud Links"
// List of Cloud Link references to be attached
type PeerType struct {
	// TGW Address
	//
	// x-displayName: "TGW Address"
	TgwAddress string `protobuf:"bytes,1,opt,name=tgw_address,json=tgwAddress,proto3" json:"tgw_address,omitempty"`
	// Peer ASN
	//
	// x-displayName: "Peer ASN"
	PeerAsn int64 `protobuf:"varint,2,opt,name=peer_asn,json=peerAsn,proto3" json:"peer_asn,omitempty"`
	// Node
	//
	// x-displayName: "Node"
	Node *cloud_re_region.NodeType `protobuf:"bytes,3,opt,name=node,proto3" json:"node,omitempty"`
	// Inside GRE Subnet
	//
	// x-displayName: "Inside GRE Subnet"
	InsideGreSubnet string `protobuf:"bytes,4,opt,name=inside_gre_subnet,json=insideGreSubnet,proto3" json:"inside_gre_subnet,omitempty"`
}

func (m *PeerType) Reset()      { *m = PeerType{} }
func (*PeerType) ProtoMessage() {}
func (*PeerType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{1}
}
func (m *PeerType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PeerType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerType.Merge(m, src)
}
func (m *PeerType) XXX_Size() int {
	return m.Size()
}
func (m *PeerType) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerType.DiscardUnknown(m)
}

var xxx_messageInfo_PeerType proto.InternalMessageInfo

func (m *PeerType) GetTgwAddress() string {
	if m != nil {
		return m.TgwAddress
	}
	return ""
}

func (m *PeerType) GetPeerAsn() int64 {
	if m != nil {
		return m.PeerAsn
	}
	return 0
}

func (m *PeerType) GetNode() *cloud_re_region.NodeType {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *PeerType) GetInsideGreSubnet() string {
	if m != nil {
		return m.InsideGreSubnet
	}
	return ""
}

// CloudLinks
//
// x-displayName: "CloudLink"
// List of CloudLink references to be attached
type CloudLinkListType struct {
	// CloudLink
	//
	// x-displayName: "CloudLink"
	// Attach a CloudLink to this Cloud Connect
	CloudLink []*views.ObjectRefType `protobuf:"bytes,1,rep,name=cloud_link,json=cloudLink,proto3" json:"cloud_link,omitempty"`
}

func (m *CloudLinkListType) Reset()      { *m = CloudLinkListType{} }
func (*CloudLinkListType) ProtoMessage() {}
func (*CloudLinkListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{2}
}
func (m *CloudLinkListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudLinkListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CloudLinkListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudLinkListType.Merge(m, src)
}
func (m *CloudLinkListType) XXX_Size() int {
	return m.Size()
}
func (m *CloudLinkListType) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudLinkListType.DiscardUnknown(m)
}

var xxx_messageInfo_CloudLinkListType proto.InternalMessageInfo

func (m *CloudLinkListType) GetCloudLink() []*views.ObjectRefType {
	if m != nil {
		return m.CloudLink
	}
	return nil
}

// VPC Attachments
//
// x-displayName: "VPC Attachments"
type AWSVPCAttachmentListType struct {
	// vpc_list
	//
	// x-displayName: "VPC List"
	VpcList []*AWSVPCAttachmentType `protobuf:"bytes,1,rep,name=vpc_list,json=vpcList,proto3" json:"vpc_list,omitempty"`
}

func (m *AWSVPCAttachmentListType) Reset()      { *m = AWSVPCAttachmentListType{} }
func (*AWSVPCAttachmentListType) ProtoMessage() {}
func (*AWSVPCAttachmentListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{3}
}
func (m *AWSVPCAttachmentListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSVPCAttachmentListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSVPCAttachmentListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSVPCAttachmentListType.Merge(m, src)
}
func (m *AWSVPCAttachmentListType) XXX_Size() int {
	return m.Size()
}
func (m *AWSVPCAttachmentListType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSVPCAttachmentListType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSVPCAttachmentListType proto.InternalMessageInfo

func (m *AWSVPCAttachmentListType) GetVpcList() []*AWSVPCAttachmentType {
	if m != nil {
		return m.VpcList
	}
	return nil
}

// AWS VPC attachment
//
// x-displayName: "VPC Attachment"
type AWSVPCAttachmentType struct {
	// VPC ID
	//
	// x-displayName: "VPC ID"
	// x-example: "vpc-12345678901234567"
	// x-required
	// Enter the VPC ID of the VPC to be attached
	VpcId string `protobuf:"bytes,1,opt,name=vpc_id,json=vpcId,proto3" json:"vpc_id,omitempty"`
	// Routing Choice
	//
	// x-displayName: "Routing Choice"
	// x-required
	// Select which traffic should be routed towards the CE
	//
	// Types that are valid to be assigned to RoutingChoice:
	//	*AWSVPCAttachmentType_ManualRouting
	//	*AWSVPCAttachmentType_DefaultRoute
	//	*AWSVPCAttachmentType_CustomRouting
	RoutingChoice isAWSVPCAttachmentType_RoutingChoice `protobuf_oneof:"routing_choice"`
}

func (m *AWSVPCAttachmentType) Reset()      { *m = AWSVPCAttachmentType{} }
func (*AWSVPCAttachmentType) ProtoMessage() {}
func (*AWSVPCAttachmentType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{4}
}
func (m *AWSVPCAttachmentType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSVPCAttachmentType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSVPCAttachmentType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSVPCAttachmentType.Merge(m, src)
}
func (m *AWSVPCAttachmentType) XXX_Size() int {
	return m.Size()
}
func (m *AWSVPCAttachmentType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSVPCAttachmentType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSVPCAttachmentType proto.InternalMessageInfo

type isAWSVPCAttachmentType_RoutingChoice interface {
	isAWSVPCAttachmentType_RoutingChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AWSVPCAttachmentType_ManualRouting struct {
	ManualRouting *schema.Empty `protobuf:"bytes,6,opt,name=manual_routing,json=manualRouting,proto3,oneof" json:"manual_routing,omitempty"`
}
type AWSVPCAttachmentType_DefaultRoute struct {
	DefaultRoute *DefaultRoute `protobuf:"bytes,9,opt,name=default_route,json=defaultRoute,proto3,oneof" json:"default_route,omitempty"`
}
type AWSVPCAttachmentType_CustomRouting struct {
	CustomRouting *AWSRouteTableListType `protobuf:"bytes,10,opt,name=custom_routing,json=customRouting,proto3,oneof" json:"custom_routing,omitempty"`
}

func (*AWSVPCAttachmentType_ManualRouting) isAWSVPCAttachmentType_RoutingChoice() {}
func (*AWSVPCAttachmentType_DefaultRoute) isAWSVPCAttachmentType_RoutingChoice()  {}
func (*AWSVPCAttachmentType_CustomRouting) isAWSVPCAttachmentType_RoutingChoice() {}

func (m *AWSVPCAttachmentType) GetRoutingChoice() isAWSVPCAttachmentType_RoutingChoice {
	if m != nil {
		return m.RoutingChoice
	}
	return nil
}

func (m *AWSVPCAttachmentType) GetVpcId() string {
	if m != nil {
		return m.VpcId
	}
	return ""
}

func (m *AWSVPCAttachmentType) GetManualRouting() *schema.Empty {
	if x, ok := m.GetRoutingChoice().(*AWSVPCAttachmentType_ManualRouting); ok {
		return x.ManualRouting
	}
	return nil
}

func (m *AWSVPCAttachmentType) GetDefaultRoute() *DefaultRoute {
	if x, ok := m.GetRoutingChoice().(*AWSVPCAttachmentType_DefaultRoute); ok {
		return x.DefaultRoute
	}
	return nil
}

func (m *AWSVPCAttachmentType) GetCustomRouting() *AWSRouteTableListType {
	if x, ok := m.GetRoutingChoice().(*AWSVPCAttachmentType_CustomRouting); ok {
		return x.CustomRouting
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AWSVPCAttachmentType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AWSVPCAttachmentType_ManualRouting)(nil),
		(*AWSVPCAttachmentType_DefaultRoute)(nil),
		(*AWSVPCAttachmentType_CustomRouting)(nil),
	}
}

// Default Route Override Choice
//
// x-displayName: "Override Default Route Choice"
// Select Override Default Route Choice
type DefaultRoute struct {
	// Default Route Override Choice
	//
	// x-displayName: "Override Default Route Choice"
	// Select Override Default Route Choice
	//
	// Types that are valid to be assigned to DefaultRouteChoice:
	//	*DefaultRoute_AllRouteTables
	//	*DefaultRoute_SelectiveRouteTables
	DefaultRouteChoice isDefaultRoute_DefaultRouteChoice `protobuf_oneof:"default_route_choice"`
}

func (m *DefaultRoute) Reset()      { *m = DefaultRoute{} }
func (*DefaultRoute) ProtoMessage() {}
func (*DefaultRoute) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{5}
}
func (m *DefaultRoute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DefaultRoute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DefaultRoute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DefaultRoute.Merge(m, src)
}
func (m *DefaultRoute) XXX_Size() int {
	return m.Size()
}
func (m *DefaultRoute) XXX_DiscardUnknown() {
	xxx_messageInfo_DefaultRoute.DiscardUnknown(m)
}

var xxx_messageInfo_DefaultRoute proto.InternalMessageInfo

type isDefaultRoute_DefaultRouteChoice interface {
	isDefaultRoute_DefaultRouteChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DefaultRoute_AllRouteTables struct {
	AllRouteTables *schema.Empty `protobuf:"bytes,1,opt,name=all_route_tables,json=allRouteTables,proto3,oneof" json:"all_route_tables,omitempty"`
}
type DefaultRoute_SelectiveRouteTables struct {
	SelectiveRouteTables *AWSDefaultRoutesRouteTable `protobuf:"bytes,4,opt,name=selective_route_tables,json=selectiveRouteTables,proto3,oneof" json:"selective_route_tables,omitempty"`
}

func (*DefaultRoute_AllRouteTables) isDefaultRoute_DefaultRouteChoice()       {}
func (*DefaultRoute_SelectiveRouteTables) isDefaultRoute_DefaultRouteChoice() {}

func (m *DefaultRoute) GetDefaultRouteChoice() isDefaultRoute_DefaultRouteChoice {
	if m != nil {
		return m.DefaultRouteChoice
	}
	return nil
}

func (m *DefaultRoute) GetAllRouteTables() *schema.Empty {
	if x, ok := m.GetDefaultRouteChoice().(*DefaultRoute_AllRouteTables); ok {
		return x.AllRouteTables
	}
	return nil
}

func (m *DefaultRoute) GetSelectiveRouteTables() *AWSDefaultRoutesRouteTable {
	if x, ok := m.GetDefaultRouteChoice().(*DefaultRoute_SelectiveRouteTables); ok {
		return x.SelectiveRouteTables
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DefaultRoute) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DefaultRoute_AllRouteTables)(nil),
		(*DefaultRoute_SelectiveRouteTables)(nil),
	}
}

// AWS Subnet IDs
//
// x-displayName: "AWS Subnet IDs"
// AWS Subnet IDs
type AWSSubnetIDListType struct {
	// List of subnet IDs
	//
	// x-displayName: "List of subnet IDs"
	// x-required
	// x-example: "subnet-12345678901234567"
	// List of subnet IDs
	SubnetIds []string `protobuf:"bytes,1,rep,name=subnet_ids,json=subnetIds,proto3" json:"subnet_ids,omitempty"`
}

func (m *AWSSubnetIDListType) Reset()      { *m = AWSSubnetIDListType{} }
func (*AWSSubnetIDListType) ProtoMessage() {}
func (*AWSSubnetIDListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{6}
}
func (m *AWSSubnetIDListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSSubnetIDListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSSubnetIDListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSSubnetIDListType.Merge(m, src)
}
func (m *AWSSubnetIDListType) XXX_Size() int {
	return m.Size()
}
func (m *AWSSubnetIDListType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSSubnetIDListType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSSubnetIDListType proto.InternalMessageInfo

func (m *AWSSubnetIDListType) GetSubnetIds() []string {
	if m != nil {
		return m.SubnetIds
	}
	return nil
}

// AWS Route Table List
//
// x-displayName: "AWS Route Table List"
// AWS Route Table List
type AWSRouteTableListType struct {
	// List of route tables
	//
	// x-required
	// x-displayName: "List of route tables"
	// Route Tables
	RouteTables []*AWSRouteTableType `protobuf:"bytes,1,rep,name=route_tables,json=routeTables,proto3" json:"route_tables,omitempty"`
}

func (m *AWSRouteTableListType) Reset()      { *m = AWSRouteTableListType{} }
func (*AWSRouteTableListType) ProtoMessage() {}
func (*AWSRouteTableListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{7}
}
func (m *AWSRouteTableListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSRouteTableListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSRouteTableListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSRouteTableListType.Merge(m, src)
}
func (m *AWSRouteTableListType) XXX_Size() int {
	return m.Size()
}
func (m *AWSRouteTableListType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSRouteTableListType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSRouteTableListType proto.InternalMessageInfo

func (m *AWSRouteTableListType) GetRouteTables() []*AWSRouteTableType {
	if m != nil {
		return m.RouteTables
	}
	return nil
}

// AWS Route Table
//
// x-displayName: "AWS Route Table"
// AWS Route Table
type AWSDefaultRoutesRouteTable struct {
	// Route table ID
	//
	// x-displayName: "Route table ID"
	// x-example: "rtb-12345678901234567"
	// Route table ID
	RouteTableId []string `protobuf:"bytes,1,rep,name=route_table_id,json=routeTableId,proto3" json:"route_table_id,omitempty"`
}

func (m *AWSDefaultRoutesRouteTable) Reset()      { *m = AWSDefaultRoutesRouteTable{} }
func (*AWSDefaultRoutesRouteTable) ProtoMessage() {}
func (*AWSDefaultRoutesRouteTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{8}
}
func (m *AWSDefaultRoutesRouteTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSDefaultRoutesRouteTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSDefaultRoutesRouteTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSDefaultRoutesRouteTable.Merge(m, src)
}
func (m *AWSDefaultRoutesRouteTable) XXX_Size() int {
	return m.Size()
}
func (m *AWSDefaultRoutesRouteTable) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSDefaultRoutesRouteTable.DiscardUnknown(m)
}

var xxx_messageInfo_AWSDefaultRoutesRouteTable proto.InternalMessageInfo

func (m *AWSDefaultRoutesRouteTable) GetRouteTableId() []string {
	if m != nil {
		return m.RouteTableId
	}
	return nil
}

// AWS Route Table
//
// x-displayName: "AWS Route Table"
// AWS Route Table
type AWSRouteTableType struct {
	// Route table ID
	//
	// x-displayName: "Route table ID"
	// x-example: "rtb-12345678901234567"
	// Route table ID
	RouteTableId string `protobuf:"bytes,1,opt,name=route_table_id,json=routeTableId,proto3" json:"route_table_id,omitempty"`
	// static_routes
	//
	// x-displayName: "Static Routes"
	// x-example: "10.1.1.0/24"
	// x-required
	// List of Static Routes
	StaticRoutes []string `protobuf:"bytes,108,rep,name=static_routes,json=staticRoutes,proto3" json:"static_routes,omitempty"`
}

func (m *AWSRouteTableType) Reset()      { *m = AWSRouteTableType{} }
func (*AWSRouteTableType) ProtoMessage() {}
func (*AWSRouteTableType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{9}
}
func (m *AWSRouteTableType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSRouteTableType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSRouteTableType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSRouteTableType.Merge(m, src)
}
func (m *AWSRouteTableType) XXX_Size() int {
	return m.Size()
}
func (m *AWSRouteTableType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSRouteTableType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSRouteTableType proto.InternalMessageInfo

func (m *AWSRouteTableType) GetRouteTableId() string {
	if m != nil {
		return m.RouteTableId
	}
	return ""
}

func (m *AWSRouteTableType) GetStaticRoutes() []string {
	if m != nil {
		return m.StaticRoutes
	}
	return nil
}

// Cloud Connect ReplaceAWSREType Type
//
// x-displayName: "AWS RE Type"
// Cloud Connect AWS RE Type
type ReplaceAWSREType struct {
	// VPC Attachments
	//
	// x-displayName: "VPC Attachments"
	VpcAttachments *AWSVPCAttachmentListType `protobuf:"bytes,3,opt,name=vpc_attachments,json=vpcAttachments,proto3" json:"vpc_attachments,omitempty"`
}

func (m *ReplaceAWSREType) Reset()      { *m = ReplaceAWSREType{} }
func (*ReplaceAWSREType) ProtoMessage() {}
func (*ReplaceAWSREType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{10}
}
func (m *ReplaceAWSREType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceAWSREType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceAWSREType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceAWSREType.Merge(m, src)
}
func (m *ReplaceAWSREType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceAWSREType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceAWSREType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceAWSREType proto.InternalMessageInfo

func (m *ReplaceAWSREType) GetVpcAttachments() *AWSVPCAttachmentListType {
	if m != nil {
		return m.VpcAttachments
	}
	return nil
}

// Cloud Connect AWS TGW Site Type
//
// x-displayName: "AWS TGW Site Type"
// Cloud Connect AWS TGW Site Type
type AWSTGWSiteType struct {
	// AWS TGW Site Reference
	//
	// x-displayName: "AWS TGW Site Reference"
	// AWS TGW Site Reference
	// x-required
	Site *views.ObjectRefType `protobuf:"bytes,1,opt,name=site,proto3" json:"site,omitempty"`
	// Cloud Credential
	//
	// x-displayName: "Credential Reference"
	// Reference to cloud credential to deploy resources
	// x-required
	Cred *views.ObjectRefType `protobuf:"bytes,2,opt,name=cred,proto3" json:"cred,omitempty"`
	// Spoke VPCs
	//
	// x-displayName: "Spoke VPCs"
	// Spoke VPCs to be attached to the AWS TGW Site
	// x-required
	VpcAttachments *AWSVPCAttachmentListType `protobuf:"bytes,3,opt,name=vpc_attachments,json=vpcAttachments,proto3" json:"vpc_attachments,omitempty"`
}

func (m *AWSTGWSiteType) Reset()      { *m = AWSTGWSiteType{} }
func (*AWSTGWSiteType) ProtoMessage() {}
func (*AWSTGWSiteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{11}
}
func (m *AWSTGWSiteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSTGWSiteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSTGWSiteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSTGWSiteType.Merge(m, src)
}
func (m *AWSTGWSiteType) XXX_Size() int {
	return m.Size()
}
func (m *AWSTGWSiteType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSTGWSiteType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSTGWSiteType proto.InternalMessageInfo

func (m *AWSTGWSiteType) GetSite() *views.ObjectRefType {
	if m != nil {
		return m.Site
	}
	return nil
}

func (m *AWSTGWSiteType) GetCred() *views.ObjectRefType {
	if m != nil {
		return m.Cred
	}
	return nil
}

func (m *AWSTGWSiteType) GetVpcAttachments() *AWSVPCAttachmentListType {
	if m != nil {
		return m.VpcAttachments
	}
	return nil
}

// Replace Cloud Connect AWS TGW Site Type
//
// x-displayName: "AWS TGW Site Type"
// Cloud Connect AWS TGW Site Type
type ReplaceAWSTGWSiteType struct {
	// Spoke VPCs
	//
	// x-displayName: "Spoke VPCs"
	// Spoke VPCs to be attached to the AWS TGW Site
	VpcAttachments *AWSVPCAttachmentListType `protobuf:"bytes,3,opt,name=vpc_attachments,json=vpcAttachments,proto3" json:"vpc_attachments,omitempty"`
}

func (m *ReplaceAWSTGWSiteType) Reset()      { *m = ReplaceAWSTGWSiteType{} }
func (*ReplaceAWSTGWSiteType) ProtoMessage() {}
func (*ReplaceAWSTGWSiteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{12}
}
func (m *ReplaceAWSTGWSiteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceAWSTGWSiteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceAWSTGWSiteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceAWSTGWSiteType.Merge(m, src)
}
func (m *ReplaceAWSTGWSiteType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceAWSTGWSiteType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceAWSTGWSiteType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceAWSTGWSiteType proto.InternalMessageInfo

func (m *ReplaceAWSTGWSiteType) GetVpcAttachments() *AWSVPCAttachmentListType {
	if m != nil {
		return m.VpcAttachments
	}
	return nil
}

// Cloud Connect Status
//
// x-displayName: "Status"
// Cloud Connect Status
type CloudConnectStatusType struct {
	// Cloud Connect Status
	//
	// x-displayName: "Status"
	// Cloud Connect Status
	//
	// Types that are valid to be assigned to CloudConnectDeployment:
	//	*CloudConnectStatusType_CloudConnectAwsSite
	CloudConnectDeployment isCloudConnectStatusType_CloudConnectDeployment `protobuf_oneof:"cloud_connect_deployment"`
}

func (m *CloudConnectStatusType) Reset()      { *m = CloudConnectStatusType{} }
func (*CloudConnectStatusType) ProtoMessage() {}
func (*CloudConnectStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{13}
}
func (m *CloudConnectStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudConnectStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CloudConnectStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudConnectStatusType.Merge(m, src)
}
func (m *CloudConnectStatusType) XXX_Size() int {
	return m.Size()
}
func (m *CloudConnectStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudConnectStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_CloudConnectStatusType proto.InternalMessageInfo

type isCloudConnectStatusType_CloudConnectDeployment interface {
	isCloudConnectStatusType_CloudConnectDeployment()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CloudConnectStatusType_CloudConnectAwsSite struct {
	CloudConnectAwsSite *AWSAttachmentsListStatusType `protobuf:"bytes,2,opt,name=cloud_connect_aws_site,json=cloudConnectAwsSite,proto3,oneof" json:"cloud_connect_aws_site,omitempty"`
}

func (*CloudConnectStatusType_CloudConnectAwsSite) isCloudConnectStatusType_CloudConnectDeployment() {
}

func (m *CloudConnectStatusType) GetCloudConnectDeployment() isCloudConnectStatusType_CloudConnectDeployment {
	if m != nil {
		return m.CloudConnectDeployment
	}
	return nil
}

func (m *CloudConnectStatusType) GetCloudConnectAwsSite() *AWSAttachmentsListStatusType {
	if x, ok := m.GetCloudConnectDeployment().(*CloudConnectStatusType_CloudConnectAwsSite); ok {
		return x.CloudConnectAwsSite
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CloudConnectStatusType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CloudConnectStatusType_CloudConnectAwsSite)(nil),
	}
}

// AWS VPC Attachment List Status Type
//
// x-displayName: "AWS VPC Attachment List Status Type"
// AWS VPC Attachment List Status Type
type AWSAttachmentsListStatusType struct {
	// AWS VPC Attachment Status Type
	//
	// x-displayName: "AWS VPC Attachment Status"
	// AWS Attachment Status Type
	AttachmentStatus []*AWSAttachmentsStatusType `protobuf:"bytes,1,rep,name=attachment_status,json=attachmentStatus,proto3" json:"attachment_status,omitempty"`
}

func (m *AWSAttachmentsListStatusType) Reset()      { *m = AWSAttachmentsListStatusType{} }
func (*AWSAttachmentsListStatusType) ProtoMessage() {}
func (*AWSAttachmentsListStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{14}
}
func (m *AWSAttachmentsListStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSAttachmentsListStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSAttachmentsListStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSAttachmentsListStatusType.Merge(m, src)
}
func (m *AWSAttachmentsListStatusType) XXX_Size() int {
	return m.Size()
}
func (m *AWSAttachmentsListStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSAttachmentsListStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSAttachmentsListStatusType proto.InternalMessageInfo

func (m *AWSAttachmentsListStatusType) GetAttachmentStatus() []*AWSAttachmentsStatusType {
	if m != nil {
		return m.AttachmentStatus
	}
	return nil
}

// AWS VPC Attachment Status Type
//
// x-displayName: "AWS Attachment Status Type"
// AWS Attachment Status Type
type AWSAttachmentsStatusType struct {
	// TGW Attachment ID
	//
	// x-displayName: "TGW Attachment ID"
	// TGW Attachment ID
	TgwAttachmentId string `protobuf:"bytes,2,opt,name=tgw_attachment_id,json=tgwAttachmentId,proto3" json:"tgw_attachment_id,omitempty"`
	// Attachment Creation Time
	//
	// x-displayName: "Attachment Creation Time"
	// Attachment Creation Time
	CreationTime *types.Timestamp `protobuf:"bytes,1,opt,name=creation_time,json=creationTime,proto3" json:"creation_time,omitempty"`
	// VPC ID
	//
	// x-displayName: "VPC ID"
	// VPC ID
	VpcId string `protobuf:"bytes,4,opt,name=vpc_id,json=vpcId,proto3" json:"vpc_id,omitempty"`
	// VPC Owner Account
	//
	// x-displayName: "VPC Owner Account"
	// VPC Owner Account
	VpcOwnerId string `protobuf:"bytes,5,opt,name=vpc_owner_id,json=vpcOwnerId,proto3" json:"vpc_owner_id,omitempty"`
	// Attachment State
	//
	// x-displayName: "Attachment State"
	// Attachment State
	State string `protobuf:"bytes,6,opt,name=state,proto3" json:"state,omitempty"`
	// Attachment Deployment Status
	//
	// x-displayName: "Attachment Deployment Status"
	// Attachment Deployment Status
	DeploymentStatus string `protobuf:"bytes,7,opt,name=deployment_status,json=deploymentStatus,proto3" json:"deployment_status,omitempty"`
	// Attachment Tags
	//
	// x-displayName: "Attachment Tags"
	// Attachment Tags
	Tags map[string]string `protobuf:"bytes,8,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Subnets
	//
	// x-displayName: "Network Interfaces"
	// Network Interfaces created along with the attachment
	Subnets []*SubnetStatusType `protobuf:"bytes,10,rep,name=subnets,proto3" json:"subnets,omitempty"`
	// Routes
	//
	// x-displayName: "Installed Routes"
	// Routes
	InstalledRoutes *AWSRouteTableListType `protobuf:"bytes,9,opt,name=installed_routes,json=installedRoutes,proto3" json:"installed_routes,omitempty"`
}

func (m *AWSAttachmentsStatusType) Reset()      { *m = AWSAttachmentsStatusType{} }
func (*AWSAttachmentsStatusType) ProtoMessage() {}
func (*AWSAttachmentsStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{15}
}
func (m *AWSAttachmentsStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSAttachmentsStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSAttachmentsStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSAttachmentsStatusType.Merge(m, src)
}
func (m *AWSAttachmentsStatusType) XXX_Size() int {
	return m.Size()
}
func (m *AWSAttachmentsStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSAttachmentsStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSAttachmentsStatusType proto.InternalMessageInfo

func (m *AWSAttachmentsStatusType) GetTgwAttachmentId() string {
	if m != nil {
		return m.TgwAttachmentId
	}
	return ""
}

func (m *AWSAttachmentsStatusType) GetCreationTime() *types.Timestamp {
	if m != nil {
		return m.CreationTime
	}
	return nil
}

func (m *AWSAttachmentsStatusType) GetVpcId() string {
	if m != nil {
		return m.VpcId
	}
	return ""
}

func (m *AWSAttachmentsStatusType) GetVpcOwnerId() string {
	if m != nil {
		return m.VpcOwnerId
	}
	return ""
}

func (m *AWSAttachmentsStatusType) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *AWSAttachmentsStatusType) GetDeploymentStatus() string {
	if m != nil {
		return m.DeploymentStatus
	}
	return ""
}

func (m *AWSAttachmentsStatusType) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *AWSAttachmentsStatusType) GetSubnets() []*SubnetStatusType {
	if m != nil {
		return m.Subnets
	}
	return nil
}

func (m *AWSAttachmentsStatusType) GetInstalledRoutes() *AWSRouteTableListType {
	if m != nil {
		return m.InstalledRoutes
	}
	return nil
}

// SubnetStatusType for AWS VPC Attachment
//
// x-displayName: "Network Interface Status"
// Network Interface Status
type SubnetStatusType struct {
	// Network Interface ID
	//
	// x-displayName: "Network Interface ID"
	// Network Interface ID
	NetworkInterfaceId string `protobuf:"bytes,1,opt,name=network_interface_id,json=networkInterfaceId,proto3" json:"network_interface_id,omitempty"`
	// Interface Type
	// x-displayName: "Interface Type"
	//
	// Interface Type
	InterfaceType string `protobuf:"bytes,2,opt,name=interface_type,json=interfaceType,proto3" json:"interface_type,omitempty"`
	// Private IPV4 Address
	// x-displayName: "Private IPV4 Address"
	//
	// Private IPV4 Address
	PrivateIpv4Address string `protobuf:"bytes,3,opt,name=private_ipv4_address,json=privateIpv4Address,proto3" json:"private_ipv4_address,omitempty"`
	// Availability Zone
	// x-displayName: "Availability Zone"
	//
	// Availability Zone
	AvailabilityZone string `protobuf:"bytes,4,opt,name=availability_zone,json=availabilityZone,proto3" json:"availability_zone,omitempty"`
	// Subnet ID
	// x-displayName: "Subnet ID"
	//
	// Subnet ID
	SubnetId string `protobuf:"bytes,5,opt,name=subnet_id,json=subnetId,proto3" json:"subnet_id,omitempty"`
	// Status
	// x-displayName: "Status"
	//
	// Status
	Status string `protobuf:"bytes,6,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *SubnetStatusType) Reset()      { *m = SubnetStatusType{} }
func (*SubnetStatusType) ProtoMessage() {}
func (*SubnetStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{16}
}
func (m *SubnetStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubnetStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SubnetStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubnetStatusType.Merge(m, src)
}
func (m *SubnetStatusType) XXX_Size() int {
	return m.Size()
}
func (m *SubnetStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_SubnetStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_SubnetStatusType proto.InternalMessageInfo

func (m *SubnetStatusType) GetNetworkInterfaceId() string {
	if m != nil {
		return m.NetworkInterfaceId
	}
	return ""
}

func (m *SubnetStatusType) GetInterfaceType() string {
	if m != nil {
		return m.InterfaceType
	}
	return ""
}

func (m *SubnetStatusType) GetPrivateIpv4Address() string {
	if m != nil {
		return m.PrivateIpv4Address
	}
	return ""
}

func (m *SubnetStatusType) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

func (m *SubnetStatusType) GetSubnetId() string {
	if m != nil {
		return m.SubnetId
	}
	return ""
}

func (m *SubnetStatusType) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// Cloud Connect specification
//
// x-displayName: "Specification"
// Desired state for Cloud Connect
type GlobalSpecType struct {
	// Provider choice
	//
	// x-displayName: "Provider"
	// x-required
	//
	// Types that are valid to be assigned to Cloud:
	//	*GlobalSpecType_AwsRe
	//	*GlobalSpecType_AwsTgwSite
	Cloud isGlobalSpecType_Cloud `protobuf_oneof:"cloud"`
	// Segment
	//
	// x-displayName: "Segment"
	// x-required
	Segment *views.ObjectRefType `protobuf:"bytes,13,opt,name=segment,proto3" json:"segment,omitempty"`
	// Bandwidth option
	//
	// x-displayName: "Bandwidth Option"
	// x-required
	// Supported bandwidth
	//
	// Types that are valid to be assigned to BandwidthOption:
	//	*GlobalSpecType_Bandwidth_500Mbs
	BandwidthOption isGlobalSpecType_BandwidthOption `protobuf_oneof:"bandwidth_option"`
	// Site Reference
	//
	// x-displayName: "Site"
	Sites []*schema.ObjectRefType `protobuf:"bytes,12,rep,name=sites,proto3" json:"sites,omitempty"`
	// Virtual Network Reference
	//
	// x-displayName: "Virtual Network"
	VirtualNetwork []*schema.ObjectRefType `protobuf:"bytes,14,rep,name=virtual_network,json=virtualNetwork,proto3" json:"virtual_network,omitempty"`
	// Cloud Connect State
	//
	// x-displayName: "Cloud Connect State"
	// State of the vpc attachments with the Cloud Connect deployment
	State CloudConnectState `protobuf:"varint,15,opt,name=state,proto3,enum=ves.io.schema.cloud_connect.CloudConnectState" json:"state,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{17}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_Cloud interface {
	isGlobalSpecType_Cloud()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_BandwidthOption interface {
	isGlobalSpecType_BandwidthOption()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_AwsRe struct {
	AwsRe *AWSREType `protobuf:"bytes,2,opt,name=aws_re,json=awsRe,proto3,oneof" json:"aws_re,omitempty"`
}
type GlobalSpecType_AwsTgwSite struct {
	AwsTgwSite *AWSTGWSiteType `protobuf:"bytes,7,opt,name=aws_tgw_site,json=awsTgwSite,proto3,oneof" json:"aws_tgw_site,omitempty"`
}
type GlobalSpecType_Bandwidth_500Mbs struct {
	Bandwidth_500Mbs *schema.Empty `protobuf:"bytes,9,opt,name=bandwidth_500mbs,json=bandwidth500mbs,proto3,oneof" json:"bandwidth_500mbs,omitempty"`
}

func (*GlobalSpecType_AwsRe) isGlobalSpecType_Cloud()                      {}
func (*GlobalSpecType_AwsTgwSite) isGlobalSpecType_Cloud()                 {}
func (*GlobalSpecType_Bandwidth_500Mbs) isGlobalSpecType_BandwidthOption() {}

func (m *GlobalSpecType) GetCloud() isGlobalSpecType_Cloud {
	if m != nil {
		return m.Cloud
	}
	return nil
}
func (m *GlobalSpecType) GetBandwidthOption() isGlobalSpecType_BandwidthOption {
	if m != nil {
		return m.BandwidthOption
	}
	return nil
}

func (m *GlobalSpecType) GetAwsRe() *AWSREType {
	if x, ok := m.GetCloud().(*GlobalSpecType_AwsRe); ok {
		return x.AwsRe
	}
	return nil
}

func (m *GlobalSpecType) GetAwsTgwSite() *AWSTGWSiteType {
	if x, ok := m.GetCloud().(*GlobalSpecType_AwsTgwSite); ok {
		return x.AwsTgwSite
	}
	return nil
}

func (m *GlobalSpecType) GetSegment() *views.ObjectRefType {
	if m != nil {
		return m.Segment
	}
	return nil
}

func (m *GlobalSpecType) GetBandwidth_500Mbs() *schema.Empty {
	if x, ok := m.GetBandwidthOption().(*GlobalSpecType_Bandwidth_500Mbs); ok {
		return x.Bandwidth_500Mbs
	}
	return nil
}

func (m *GlobalSpecType) GetSites() []*schema.ObjectRefType {
	if m != nil {
		return m.Sites
	}
	return nil
}

func (m *GlobalSpecType) GetVirtualNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.VirtualNetwork
	}
	return nil
}

func (m *GlobalSpecType) GetState() CloudConnectState {
	if m != nil {
		return m.State
	}
	return DOWN
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_AwsRe)(nil),
		(*GlobalSpecType_AwsTgwSite)(nil),
		(*GlobalSpecType_Bandwidth_500Mbs)(nil),
	}
}

// Create Cloud Connect
//
// x-displayName: "Create Cloud Connect"
// Shape of the Cloud Connect specification
type CreateSpecType struct {
	// Types that are valid to be assigned to Cloud:
	//	*CreateSpecType_AwsRe
	//	*CreateSpecType_AwsTgwSite
	Cloud   isCreateSpecType_Cloud `protobuf_oneof:"cloud"`
	Segment *views.ObjectRefType   `protobuf:"bytes,13,opt,name=segment,proto3" json:"segment,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{18}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_Cloud interface {
	isCreateSpecType_Cloud()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_AwsRe struct {
	AwsRe *AWSREType `protobuf:"bytes,2,opt,name=aws_re,json=awsRe,proto3,oneof" json:"aws_re,omitempty"`
}
type CreateSpecType_AwsTgwSite struct {
	AwsTgwSite *AWSTGWSiteType `protobuf:"bytes,7,opt,name=aws_tgw_site,json=awsTgwSite,proto3,oneof" json:"aws_tgw_site,omitempty"`
}

func (*CreateSpecType_AwsRe) isCreateSpecType_Cloud()      {}
func (*CreateSpecType_AwsTgwSite) isCreateSpecType_Cloud() {}

func (m *CreateSpecType) GetCloud() isCreateSpecType_Cloud {
	if m != nil {
		return m.Cloud
	}
	return nil
}

func (m *CreateSpecType) GetAwsRe() *AWSREType {
	if x, ok := m.GetCloud().(*CreateSpecType_AwsRe); ok {
		return x.AwsRe
	}
	return nil
}

func (m *CreateSpecType) GetAwsTgwSite() *AWSTGWSiteType {
	if x, ok := m.GetCloud().(*CreateSpecType_AwsTgwSite); ok {
		return x.AwsTgwSite
	}
	return nil
}

func (m *CreateSpecType) GetSegment() *views.ObjectRefType {
	if m != nil {
		return m.Segment
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_AwsRe)(nil),
		(*CreateSpecType_AwsTgwSite)(nil),
	}
}

// Replace Cloud Connect
//
// x-displayName: "Replace Cloud Connect"
// Shape of the Cloud Connect specification
type ReplaceSpecType struct {
	// Types that are valid to be assigned to Cloud:
	//	*ReplaceSpecType_AwsRe
	//	*ReplaceSpecType_AwsTgwSite
	Cloud   isReplaceSpecType_Cloud `protobuf_oneof:"cloud"`
	Segment *views.ObjectRefType    `protobuf:"bytes,13,opt,name=segment,proto3" json:"segment,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{19}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_Cloud interface {
	isReplaceSpecType_Cloud()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_AwsRe struct {
	AwsRe *ReplaceAWSREType `protobuf:"bytes,2,opt,name=aws_re,json=awsRe,proto3,oneof" json:"aws_re,omitempty"`
}
type ReplaceSpecType_AwsTgwSite struct {
	AwsTgwSite *ReplaceAWSTGWSiteType `protobuf:"bytes,7,opt,name=aws_tgw_site,json=awsTgwSite,proto3,oneof" json:"aws_tgw_site,omitempty"`
}

func (*ReplaceSpecType_AwsRe) isReplaceSpecType_Cloud()      {}
func (*ReplaceSpecType_AwsTgwSite) isReplaceSpecType_Cloud() {}

func (m *ReplaceSpecType) GetCloud() isReplaceSpecType_Cloud {
	if m != nil {
		return m.Cloud
	}
	return nil
}

func (m *ReplaceSpecType) GetAwsRe() *ReplaceAWSREType {
	if x, ok := m.GetCloud().(*ReplaceSpecType_AwsRe); ok {
		return x.AwsRe
	}
	return nil
}

func (m *ReplaceSpecType) GetAwsTgwSite() *ReplaceAWSTGWSiteType {
	if x, ok := m.GetCloud().(*ReplaceSpecType_AwsTgwSite); ok {
		return x.AwsTgwSite
	}
	return nil
}

func (m *ReplaceSpecType) GetSegment() *views.ObjectRefType {
	if m != nil {
		return m.Segment
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_AwsRe)(nil),
		(*ReplaceSpecType_AwsTgwSite)(nil),
	}
}

// Get Cloud Connect
//
// x-displayName: "Get Cloud Connect"
// Shape of the Cloud Connect specification
type GetSpecType struct {
	// Types that are valid to be assigned to Cloud:
	//	*GetSpecType_AwsRe
	//	*GetSpecType_AwsTgwSite
	Cloud   isGetSpecType_Cloud  `protobuf_oneof:"cloud"`
	Segment *views.ObjectRefType `protobuf:"bytes,13,opt,name=segment,proto3" json:"segment,omitempty"`
	State   CloudConnectState    `protobuf:"varint,15,opt,name=state,proto3,enum=ves.io.schema.cloud_connect.CloudConnectState" json:"state,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{20}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_Cloud interface {
	isGetSpecType_Cloud()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_AwsRe struct {
	AwsRe *AWSREType `protobuf:"bytes,2,opt,name=aws_re,json=awsRe,proto3,oneof" json:"aws_re,omitempty"`
}
type GetSpecType_AwsTgwSite struct {
	AwsTgwSite *AWSTGWSiteType `protobuf:"bytes,7,opt,name=aws_tgw_site,json=awsTgwSite,proto3,oneof" json:"aws_tgw_site,omitempty"`
}

func (*GetSpecType_AwsRe) isGetSpecType_Cloud()      {}
func (*GetSpecType_AwsTgwSite) isGetSpecType_Cloud() {}

func (m *GetSpecType) GetCloud() isGetSpecType_Cloud {
	if m != nil {
		return m.Cloud
	}
	return nil
}

func (m *GetSpecType) GetAwsRe() *AWSREType {
	if x, ok := m.GetCloud().(*GetSpecType_AwsRe); ok {
		return x.AwsRe
	}
	return nil
}

func (m *GetSpecType) GetAwsTgwSite() *AWSTGWSiteType {
	if x, ok := m.GetCloud().(*GetSpecType_AwsTgwSite); ok {
		return x.AwsTgwSite
	}
	return nil
}

func (m *GetSpecType) GetSegment() *views.ObjectRefType {
	if m != nil {
		return m.Segment
	}
	return nil
}

func (m *GetSpecType) GetState() CloudConnectState {
	if m != nil {
		return m.State
	}
	return DOWN
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_AwsRe)(nil),
		(*GetSpecType_AwsTgwSite)(nil),
	}
}

func init() {
	proto.RegisterEnum("ves.io.schema.cloud_connect.CloudConnectState", CloudConnectState_name, CloudConnectState_value)
	golang_proto.RegisterEnum("ves.io.schema.cloud_connect.CloudConnectState", CloudConnectState_name, CloudConnectState_value)
	proto.RegisterType((*AWSREType)(nil), "ves.io.schema.cloud_connect.AWSREType")
	golang_proto.RegisterType((*AWSREType)(nil), "ves.io.schema.cloud_connect.AWSREType")
	proto.RegisterType((*PeerType)(nil), "ves.io.schema.cloud_connect.PeerType")
	golang_proto.RegisterType((*PeerType)(nil), "ves.io.schema.cloud_connect.PeerType")
	proto.RegisterType((*CloudLinkListType)(nil), "ves.io.schema.cloud_connect.CloudLinkListType")
	golang_proto.RegisterType((*CloudLinkListType)(nil), "ves.io.schema.cloud_connect.CloudLinkListType")
	proto.RegisterType((*AWSVPCAttachmentListType)(nil), "ves.io.schema.cloud_connect.AWSVPCAttachmentListType")
	golang_proto.RegisterType((*AWSVPCAttachmentListType)(nil), "ves.io.schema.cloud_connect.AWSVPCAttachmentListType")
	proto.RegisterType((*AWSVPCAttachmentType)(nil), "ves.io.schema.cloud_connect.AWSVPCAttachmentType")
	golang_proto.RegisterType((*AWSVPCAttachmentType)(nil), "ves.io.schema.cloud_connect.AWSVPCAttachmentType")
	proto.RegisterType((*DefaultRoute)(nil), "ves.io.schema.cloud_connect.DefaultRoute")
	golang_proto.RegisterType((*DefaultRoute)(nil), "ves.io.schema.cloud_connect.DefaultRoute")
	proto.RegisterType((*AWSSubnetIDListType)(nil), "ves.io.schema.cloud_connect.AWSSubnetIDListType")
	golang_proto.RegisterType((*AWSSubnetIDListType)(nil), "ves.io.schema.cloud_connect.AWSSubnetIDListType")
	proto.RegisterType((*AWSRouteTableListType)(nil), "ves.io.schema.cloud_connect.AWSRouteTableListType")
	golang_proto.RegisterType((*AWSRouteTableListType)(nil), "ves.io.schema.cloud_connect.AWSRouteTableListType")
	proto.RegisterType((*AWSDefaultRoutesRouteTable)(nil), "ves.io.schema.cloud_connect.AWSDefaultRoutesRouteTable")
	golang_proto.RegisterType((*AWSDefaultRoutesRouteTable)(nil), "ves.io.schema.cloud_connect.AWSDefaultRoutesRouteTable")
	proto.RegisterType((*AWSRouteTableType)(nil), "ves.io.schema.cloud_connect.AWSRouteTableType")
	golang_proto.RegisterType((*AWSRouteTableType)(nil), "ves.io.schema.cloud_connect.AWSRouteTableType")
	proto.RegisterType((*ReplaceAWSREType)(nil), "ves.io.schema.cloud_connect.ReplaceAWSREType")
	golang_proto.RegisterType((*ReplaceAWSREType)(nil), "ves.io.schema.cloud_connect.ReplaceAWSREType")
	proto.RegisterType((*AWSTGWSiteType)(nil), "ves.io.schema.cloud_connect.AWSTGWSiteType")
	golang_proto.RegisterType((*AWSTGWSiteType)(nil), "ves.io.schema.cloud_connect.AWSTGWSiteType")
	proto.RegisterType((*ReplaceAWSTGWSiteType)(nil), "ves.io.schema.cloud_connect.ReplaceAWSTGWSiteType")
	golang_proto.RegisterType((*ReplaceAWSTGWSiteType)(nil), "ves.io.schema.cloud_connect.ReplaceAWSTGWSiteType")
	proto.RegisterType((*CloudConnectStatusType)(nil), "ves.io.schema.cloud_connect.CloudConnectStatusType")
	golang_proto.RegisterType((*CloudConnectStatusType)(nil), "ves.io.schema.cloud_connect.CloudConnectStatusType")
	proto.RegisterType((*AWSAttachmentsListStatusType)(nil), "ves.io.schema.cloud_connect.AWSAttachmentsListStatusType")
	golang_proto.RegisterType((*AWSAttachmentsListStatusType)(nil), "ves.io.schema.cloud_connect.AWSAttachmentsListStatusType")
	proto.RegisterType((*AWSAttachmentsStatusType)(nil), "ves.io.schema.cloud_connect.AWSAttachmentsStatusType")
	golang_proto.RegisterType((*AWSAttachmentsStatusType)(nil), "ves.io.schema.cloud_connect.AWSAttachmentsStatusType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_connect.AWSAttachmentsStatusType.TagsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_connect.AWSAttachmentsStatusType.TagsEntry")
	proto.RegisterType((*SubnetStatusType)(nil), "ves.io.schema.cloud_connect.SubnetStatusType")
	golang_proto.RegisterType((*SubnetStatusType)(nil), "ves.io.schema.cloud_connect.SubnetStatusType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.cloud_connect.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.cloud_connect.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.cloud_connect.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.cloud_connect.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.cloud_connect.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.cloud_connect.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.cloud_connect.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.cloud_connect.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/cloud_connect/types.proto", fileDescriptor_245b6fb3a531fd11)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/cloud_connect/types.proto", fileDescriptor_245b6fb3a531fd11)
}

var fileDescriptor_245b6fb3a531fd11 = []byte{
	// 2521 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x59, 0x4d, 0x6c, 0x1b, 0xc7,
	0x15, 0xe6, 0xf0, 0x4f, 0xe4, 0x93, 0x44, 0xad, 0xc6, 0xb2, 0x43, 0xcb, 0x06, 0xbd, 0xdd, 0xda,
	0x89, 0x6c, 0x4b, 0x94, 0x44, 0x3b, 0x75, 0xac, 0xb6, 0x49, 0x48, 0x51, 0xb5, 0x28, 0x18, 0xb6,
	0xba, 0x72, 0xec, 0x26, 0x41, 0xcc, 0x2e, 0x77, 0x47, 0xf4, 0xd6, 0xab, 0xdd, 0xc5, 0xee, 0x92,
	0xac, 0xd2, 0xaa, 0x70, 0x73, 0xc8, 0x21, 0x97, 0x06, 0x3e, 0xf7, 0x50, 0x14, 0x28, 0x10, 0x18,
	0x28, 0x7a, 0x69, 0x03, 0xd4, 0x74, 0x01, 0x23, 0xa7, 0xc0, 0xe8, 0x41, 0x47, 0x1f, 0x7a, 0xa8,
	0xe5, 0x8b, 0x7b, 0x0b, 0x7a, 0x0a, 0x72, 0x2a, 0x66, 0x66, 0x77, 0xf9, 0x63, 0x9a, 0xfe, 0xa9,
	0x0b, 0x14, 0xb9, 0xed, 0xee, 0xcc, 0xfb, 0xde, 0x7b, 0xdf, 0x7b, 0xf3, 0xe6, 0x3d, 0x12, 0x5e,
	0x6b, 0x12, 0x37, 0xaf, 0x5b, 0xf3, 0xae, 0x7a, 0x8d, 0x6c, 0x29, 0xf3, 0xaa, 0x61, 0x35, 0xb4,
	0xaa, 0x6a, 0x99, 0x26, 0x51, 0xbd, 0x79, 0x6f, 0xdb, 0x26, 0x6e, 0xde, 0x76, 0x2c, 0xcf, 0xc2,
	0x87, 0xf8, 0xc6, 0x3c, 0xdf, 0x98, 0xef, 0xd9, 0x38, 0x3d, 0x57, 0xd7, 0xbd, 0x6b, 0x8d, 0x5a,
	0x5e, 0xb5, 0xb6, 0xe6, 0xeb, 0x56, 0xdd, 0x9a, 0x67, 0x32, 0xb5, 0xc6, 0x26, 0x7b, 0x63, 0x2f,
	0xec, 0x89, 0x63, 0x4d, 0x1f, 0xa9, 0x5b, 0x56, 0xdd, 0x20, 0x9d, 0x5d, 0x9e, 0xbe, 0x45, 0x5c,
	0x4f, 0xd9, 0xb2, 0xfd, 0x0d, 0xc7, 0x07, 0x59, 0xe5, 0x90, 0xaa, 0x43, 0xea, 0xba, 0x65, 0x76,
	0xdb, 0x35, 0x7d, 0xa8, 0x77, 0xab, 0x65, 0x7b, 0xba, 0x65, 0x06, 0x8b, 0x07, 0x7b, 0x17, 0xbb,
	0xe5, 0x0e, 0xf7, 0x2e, 0x35, 0x15, 0x43, 0xd7, 0x14, 0x8f, 0xf8, 0xab, 0x62, 0xdf, 0xaa, 0x4e,
	0x5a, 0xd5, 0x5e, 0xe8, 0x23, 0x8f, 0xef, 0x70, 0xbb, 0x15, 0x48, 0x9f, 0xc4, 0x21, 0x5d, 0xbc,
	0xb2, 0x21, 0xaf, 0x5c, 0xda, 0xb6, 0x09, 0x56, 0x20, 0xc9, 0x8d, 0xcf, 0x22, 0x11, 0xcd, 0x8c,
	0x16, 0xa4, 0x7c, 0x2f, 0x9f, 0x4c, 0x3e, 0x7f, 0xb1, 0xf6, 0x33, 0xa2, 0x7a, 0x32, 0xd9, 0xa4,
	0x32, 0xa5, 0x63, 0xb7, 0x76, 0xc6, 0x02, 0xd7, 0xa9, 0xe8, 0x8d, 0x3b, 0x08, 0xdd, 0xbe, 0x83,
	0x32, 0x29, 0x34, 0x83, 0x16, 0xd0, 0x52, 0x52, 0xb5, 0xcc, 0x4d, 0xbd, 0x2e, 0xfb, 0xc0, 0xf8,
	0x2a, 0xc4, 0x55, 0x87, 0x68, 0xd9, 0xe8, 0x33, 0x2b, 0x78, 0xf5, 0xd6, 0xce, 0xa4, 0x1f, 0x48,
	0x87, 0x68, 0xc4, 0xf4, 0x74, 0xc5, 0x70, 0x07, 0x68, 0x60, 0xb8, 0x58, 0x83, 0x89, 0xa6, 0xad,
	0x56, 0x15, 0xcf, 0x53, 0xd4, 0x6b, 0x5b, 0xc4, 0xf4, 0xdc, 0x6c, 0x8c, 0xa9, 0x7a, 0x3d, 0x3f,
	0x24, 0x37, 0xf2, 0xc5, 0x2b, 0x1b, 0x97, 0xd7, 0x97, 0x8b, 0xa1, 0xd4, 0x79, 0xdd, 0xf5, 0x98,
	0xf6, 0xf8, 0x57, 0x6d, 0x84, 0xe4, 0x4c, 0xd3, 0x56, 0x3b, 0x8b, 0x2e, 0x7e, 0x07, 0x46, 0xb9,
	0xbc, 0xa1, 0x9b, 0xd7, 0xdd, 0x6c, 0x9c, 0x69, 0xc8, 0x0f, 0xd5, 0xb0, 0x4c, 0xdf, 0xce, 0xeb,
	0xe6, 0xf5, 0x3e, 0x68, 0x50, 0x83, 0x05, 0x17, 0x1f, 0x84, 0x98, 0x57, 0x6f, 0x65, 0x13, 0x22,
	0x9a, 0x49, 0x97, 0x46, 0xee, 0xef, 0xa0, 0x47, 0x74, 0x07, 0xfd, 0x86, 0xcb, 0x90, 0xb0, 0x09,
	0x71, 0xdc, 0x6c, 0x5a, 0x8c, 0xcd, 0x8c, 0x16, 0x8e, 0x0d, 0xd5, 0xb5, 0x4e, 0x88, 0xc3, 0x54,
	0x84, 0x18, 0x5c, 0x78, 0x09, 0xfe, 0xfd, 0xe6, 0xc8, 0xe2, 0x6c, 0x61, 0xf6, 0xd4, 0xec, 0xe9,
	0xb5, 0x78, 0x2a, 0x29, 0x8c, 0xac, 0xc5, 0x53, 0x23, 0x42, 0x6a, 0x2d, 0x9e, 0x4a, 0x09, 0x69,
	0xe9, 0x4f, 0x08, 0x52, 0x81, 0x28, 0x3e, 0x02, 0xa3, 0x5e, 0xbd, 0x55, 0x55, 0x34, 0xcd, 0x21,
	0xae, 0xcb, 0x12, 0x22, 0x2d, 0x83, 0x57, 0x6f, 0x15, 0xf9, 0x17, 0x7c, 0x10, 0x52, 0x14, 0xb4,
	0xaa, 0xb8, 0x26, 0x8b, 0x66, 0x4c, 0x1e, 0xa1, 0xef, 0x45, 0xd7, 0xc4, 0xdf, 0x87, 0xb8, 0x69,
	0x69, 0xc4, 0x67, 0xfe, 0xb5, 0x81, 0xb6, 0x86, 0x07, 0x25, 0x7f, 0xc1, 0xd2, 0x08, 0x55, 0x29,
	0x33, 0x21, 0x7c, 0x02, 0x26, 0x75, 0xd3, 0xd5, 0x35, 0x52, 0xad, 0x3b, 0xa4, 0xea, 0x36, 0x6a,
	0x26, 0xf1, 0x18, 0xc3, 0x69, 0x79, 0x82, 0x2f, 0x9c, 0x73, 0xc8, 0x06, 0xfb, 0x2c, 0xfd, 0x1a,
	0xc1, 0xe4, 0x63, 0xc4, 0x62, 0x03, 0xa0, 0x13, 0x9d, 0x2c, 0x62, 0x84, 0x3d, 0x4b, 0xa6, 0x1d,
	0xbf, 0xb5, 0xd3, 0x25, 0xf8, 0x78, 0x8a, 0xdd, 0xfe, 0xd7, 0xdd, 0x58, 0xe2, 0x26, 0x8a, 0x0a,
	0x48, 0x4e, 0x87, 0x51, 0x93, 0x1a, 0x90, 0x7d, 0x52, 0xf6, 0xe0, 0x77, 0x21, 0x45, 0xb3, 0xd1,
	0xd0, 0x5d, 0xcf, 0xb7, 0x63, 0xf1, 0xb9, 0xd2, 0x90, 0x99, 0x35, 0x4a, 0xf5, 0x26, 0x6f, 0xa2,
	0x98, 0x70, 0x03, 0xc9, 0x23, 0x4d, 0x5b, 0xa5, 0xf0, 0xd2, 0xef, 0x93, 0x30, 0x35, 0x68, 0x3b,
	0x56, 0x21, 0x49, 0x75, 0xea, 0x1a, 0x8f, 0x59, 0xe9, 0xfc, 0xd7, 0x6d, 0x14, 0xb9, 0x7d, 0x07,
	0x09, 0x29, 0xea, 0x0a, 0x77, 0x70, 0x4e, 0x53, 0x3c, 0x85, 0xc2, 0xc6, 0x9d, 0x68, 0xf6, 0x6d,
	0xfa, 0xf0, 0xaa, 0x73, 0xb4, 0x20, 0x5d, 0x9d, 0x69, 0xda, 0xea, 0xdc, 0xf1, 0x99, 0xf7, 0x95,
	0xb9, 0x0f, 0x17, 0xe6, 0xce, 0x7e, 0xf0, 0x8b, 0x37, 0x76, 0x7e, 0x19, 0x3e, 0x2f, 0x9e, 0xd9,
	0x39, 0x7e, 0x54, 0x4e, 0x34, 0x6d, 0xb5, 0xa2, 0xe1, 0x1f, 0x42, 0x66, 0x4b, 0x31, 0x1b, 0x8a,
	0x51, 0x75, 0xac, 0x86, 0xa7, 0x9b, 0xf5, 0x6c, 0x92, 0xc5, 0x7a, 0xaa, 0xcf, 0xbd, 0x95, 0x2d,
	0xdb, 0xdb, 0x5e, 0x8d, 0xc8, 0xe3, 0x7c, 0xb7, 0xcc, 0x37, 0xe3, 0x75, 0x18, 0xd7, 0xc8, 0xa6,
	0xd2, 0x30, 0x3c, 0x26, 0x4f, 0xb2, 0x69, 0x26, 0x7d, 0x7c, 0x28, 0x39, 0x65, 0x2e, 0x41, 0x31,
	0xc8, 0x6a, 0x44, 0x1e, 0xd3, 0xba, 0xde, 0xf1, 0xfb, 0x90, 0x51, 0x1b, 0xae, 0x67, 0x6d, 0x85,
	0x06, 0x01, 0x83, 0x2c, 0x3c, 0x8d, 0x6f, 0x26, 0x7e, 0x49, 0xa9, 0x19, 0x24, 0x88, 0x1a, 0x35,
	0x97, 0x63, 0xf9, 0xe6, 0x2e, 0x3d, 0x8a, 0xde, 0x6b, 0xa3, 0x87, 0x51, 0xc0, 0x90, 0xbc, 0xbc,
	0xbe, 0x2c, 0x56, 0xca, 0xd3, 0xa9, 0x80, 0x64, 0xf8, 0x7b, 0x14, 0x32, 0xfe, 0x3e, 0x71, 0xf9,
	0x9a, 0xa5, 0xab, 0xe4, 0xc4, 0x5f, 0xa3, 0xf0, 0x79, 0x14, 0xe6, 0xfa, 0x29, 0x2a, 0x1c, 0xba,
	0x60, 0x89, 0xcc, 0x5d, 0x57, 0x6c, 0xe9, 0x86, 0x21, 0xd6, 0x88, 0xa8, 0x9b, 0xae, 0xa7, 0x18,
	0x06, 0xd1, 0xe0, 0x3c, 0xe4, 0x7a, 0x28, 0xc9, 0x2b, 0x06, 0x97, 0x24, 0x55, 0x8f, 0x5a, 0xe7,
	0x16, 0x4e, 0x5c, 0x6c, 0x12, 0xc7, 0xd1, 0x35, 0x22, 0xfa, 0x4c, 0x88, 0xcc, 0x76, 0x71, 0xd3,
	0x72, 0x44, 0xc5, 0x30, 0xc4, 0x8e, 0x27, 0x2e, 0x5c, 0x87, 0x53, 0xbd, 0x68, 0x2e, 0x31, 0x88,
	0xea, 0xe9, 0x4d, 0xd2, 0x83, 0x99, 0xef, 0x7a, 0xa9, 0xea, 0x9a, 0x74, 0x5a, 0x48, 0x9c, 0x58,
	0x18, 0xa2, 0x66, 0x23, 0x40, 0xe9, 0x51, 0xb6, 0x06, 0x87, 0x7a, 0xb9, 0xef, 0x86, 0x75, 0xa5,
	0x93, 0x42, 0x42, 0xca, 0xf4, 0x2a, 0x3a, 0xf1, 0xca, 0x32, 0x13, 0x10, 0x97, 0x2b, 0x65, 0xd9,
	0xed, 0x02, 0x2b, 0xcd, 0x40, 0xc6, 0x07, 0xa9, 0xaa, 0x8c, 0x4d, 0x7c, 0xe0, 0x6e, 0x1b, 0x25,
	0x77, 0xdb, 0x28, 0xb1, 0xd7, 0x46, 0xc9, 0xef, 0xcd, 0x9e, 0x9d, 0x5d, 0x5c, 0xf8, 0xdd, 0x1d,
	0x84, 0xd6, 0xe2, 0xa9, 0xa8, 0x10, 0x5b, 0x8b, 0xa7, 0x62, 0x42, 0x7c, 0x2d, 0x9e, 0x8a, 0x0b,
	0x89, 0xb5, 0x78, 0x2a, 0x21, 0x24, 0x7b, 0x2a, 0xda, 0x37, 0x08, 0xc6, 0xba, 0xd3, 0x06, 0xbf,
	0x0d, 0x42, 0x3f, 0xaf, 0xfe, 0x5d, 0xf7, 0xa4, 0xcc, 0xcd, 0x28, 0x86, 0xd1, 0xe5, 0x2c, 0xb6,
	0xe0, 0xc0, 0x60, 0x2e, 0xfd, 0x5b, 0xe0, 0xcc, 0xd3, 0x12, 0xae, 0xdb, 0x1e, 0xb7, 0x83, 0xbc,
	0x1a, 0x91, 0xa7, 0x42, 0xe0, 0x2e, 0x85, 0xa5, 0x93, 0x30, 0xd5, 0x13, 0xca, 0x80, 0x97, 0x7d,
	0x77, 0xdb, 0x08, 0xed, 0xb6, 0x51, 0x6c, 0xaf, 0x8d, 0x62, 0x8b, 0xb3, 0xa7, 0xfb, 0x49, 0x91,
	0xfe, 0x82, 0x60, 0x5f, 0xf1, 0xca, 0x06, 0x2f, 0x95, 0x95, 0x72, 0x58, 0x94, 0x3e, 0x46, 0x00,
	0xbc, 0xac, 0x56, 0x75, 0xcd, 0x65, 0x75, 0x29, 0x5d, 0xaa, 0xdf, 0xbe, 0x83, 0xb0, 0x5f, 0xee,
	0xfa, 0x6a, 0x44, 0xfe, 0x26, 0x3a, 0x29, 0x1d, 0x77, 0x5e, 0x2b, 0x1c, 0xbb, 0x3a, 0xc3, 0xe5,
	0x86, 0x96, 0x88, 0xb0, 0x4a, 0xc6, 0x83, 0xa7, 0x14, 0x0a, 0x9e, 0xb2, 0x48, 0x4e, 0x73, 0x88,
	0x8a, 0xe6, 0x2e, 0xed, 0xff, 0xa2, 0x8d, 0x26, 0x61, 0x02, 0x80, 0x9b, 0x28, 0x56, 0xca, 0x2e,
	0x46, 0x8b, 0xd2, 0x67, 0x08, 0xf6, 0x0f, 0x3c, 0x98, 0xd8, 0x81, 0xb1, 0xbe, 0xc8, 0xc5, 0x9e,
	0x7a, 0xef, 0xf6, 0x20, 0xb1, 0x7a, 0x7a, 0x24, 0xac, 0xa7, 0x5f, 0xa2, 0x81, 0x26, 0x8e, 0x3a,
	0x1d, 0xfa, 0x97, 0x0e, 0x7d, 0xd1, 0x46, 0xaf, 0xc0, 0xfe, 0xce, 0x21, 0xf7, 0xf3, 0x00, 0x2d,
	0xce, 0x20, 0xe9, 0xb7, 0x08, 0xa6, 0x9f, 0x1c, 0x52, 0xfc, 0x2b, 0xe8, 0xcb, 0x7b, 0x9f, 0xec,
	0x9f, 0xf8, 0x25, 0xf9, 0x09, 0x84, 0x73, 0x33, 0x06, 0x95, 0x67, 0xc7, 0xab, 0x0d, 0x2f, 0xcf,
	0x63, 0x1d, 0xd3, 0x2b, 0x9a, 0xf4, 0xc7, 0x28, 0x4c, 0x3e, 0xe6, 0x3f, 0xf6, 0x06, 0x58, 0x45,
	0x2f, 0x8a, 0x0b, 0xc3, 0xad, 0xfa, 0xef, 0x6c, 0xc1, 0x32, 0x8c, 0xbb, 0x9e, 0xe2, 0xe9, 0x2a,
	0xcf, 0x62, 0x37, 0x6b, 0x30, 0x2a, 0xe6, 0x28, 0x22, 0xdc, 0x44, 0x23, 0x52, 0xc2, 0x89, 0x7d,
	0x8d, 0xc2, 0x30, 0x08, 0x85, 0x81, 0xa1, 0x19, 0xe3, 0x18, 0x9c, 0xe9, 0xa5, 0x0b, 0xf7, 0xda,
	0x68, 0x0d, 0x8e, 0x82, 0xd0, 0x13, 0x1b, 0x5a, 0x9f, 0x85, 0x7e, 0x1f, 0x41, 0x82, 0xf1, 0x0d,
	0x26, 0xcb, 0xab, 0x8d, 0x5b, 0x9a, 0xec, 0x33, 0x48, 0x00, 0xe9, 0x06, 0x02, 0x41, 0x26, 0xb6,
	0xa1, 0xa8, 0xa4, 0xd3, 0x14, 0x5f, 0x7d, 0xb9, 0x1d, 0x65, 0x7f, 0x2f, 0xb9, 0x34, 0x76, 0xef,
	0xcd, 0x4e, 0x0b, 0x2e, 0xb5, 0xa3, 0x90, 0x29, 0x5e, 0xd9, 0xb8, 0x74, 0xee, 0xca, 0x86, 0xee,
	0xf1, 0x78, 0x7d, 0x00, 0x71, 0x57, 0xf7, 0xc8, 0x73, 0xf6, 0xe4, 0x4a, 0xcb, 0xad, 0xd2, 0x06,
	0x8e, 0x8a, 0x3e, 0xa1, 0x27, 0x67, 0xb0, 0xdf, 0x8e, 0x8e, 0x9c, 0xdf, 0x00, 0xd2, 0xa7, 0x08,
	0xf6, 0x77, 0x02, 0xd8, 0x4d, 0xe2, 0x4b, 0xb7, 0x62, 0x77, 0x80, 0x15, 0x4b, 0x93, 0xf7, 0xde,
	0xec, 0x8b, 0x9e, 0xf4, 0x39, 0x82, 0x03, 0xac, 0x45, 0x5d, 0xe6, 0x90, 0x34, 0x09, 0x1b, 0x2e,
	0xb3, 0xc9, 0x86, 0x03, 0x3d, 0xda, 0xaa, 0x34, 0x66, 0x2c, 0xd4, 0x3c, 0x16, 0x67, 0x9f, 0x66,
	0x5a, 0x97, 0x6a, 0x6a, 0x58, 0x07, 0x7a, 0x35, 0x22, 0xef, 0x53, 0xbb, 0x94, 0x16, 0x5b, 0x2e,
	0x35, 0xa8, 0x74, 0x14, 0xb2, 0xbd, 0x1a, 0x35, 0x62, 0x1b, 0xd6, 0x36, 0x45, 0xc0, 0x29, 0xea,
	0x91, 0x7f, 0x89, 0x20, 0x21, 0x2a, 0x7d, 0x84, 0xe0, 0xf0, 0x30, 0x1d, 0xb8, 0x06, 0x93, 0x1d,
	0x3a, 0xab, 0x2e, 0x5b, 0xf0, 0x4b, 0xf2, 0xeb, 0xcf, 0x61, 0x79, 0x07, 0x51, 0x16, 0x3a, 0x78,
	0xfc, 0xab, 0xf4, 0x49, 0x92, 0x75, 0xd7, 0x03, 0xb7, 0xd3, 0x49, 0x81, 0x8d, 0x28, 0x1d, 0x23,
	0x74, 0x9e, 0xc6, 0x69, 0x79, 0x82, 0x0e, 0x2a, 0xe1, 0xf7, 0x8a, 0x86, 0xdf, 0x82, 0x71, 0xd5,
	0x21, 0x0a, 0x1d, 0x8e, 0xab, 0x74, 0x90, 0xf7, 0x4f, 0xd3, 0x74, 0x9e, 0x4f, 0xf9, 0xf9, 0x60,
	0xca, 0xcf, 0x5f, 0x0a, 0xa6, 0x7c, 0x79, 0x2c, 0x10, 0xa0, 0x9f, 0xf0, 0xfe, 0xb0, 0xad, 0xe6,
	0xb3, 0x88, 0xdf, 0x08, 0x8b, 0x30, 0x46, 0x3f, 0x5b, 0x2d, 0x93, 0x38, 0x74, 0x31, 0xc1, 0xe7,
	0xa4, 0xa6, 0xad, 0x5e, 0xa4, 0x9f, 0x2a, 0x1a, 0x9e, 0x82, 0x04, 0xe5, 0x86, 0xb0, 0x0e, 0x39,
	0x2d, 0xf3, 0x17, 0x7c, 0x12, 0x26, 0x3b, 0xdc, 0x07, 0xe4, 0x8d, 0xb0, 0x1d, 0x42, 0x67, 0x81,
	0x3b, 0x8b, 0xdf, 0x85, 0xb8, 0xa7, 0xd4, 0xdd, 0x6c, 0x8a, 0x91, 0xfb, 0xd6, 0x0b, 0x91, 0x9b,
	0xbf, 0xa4, 0xd4, 0xdd, 0x15, 0xd3, 0x73, 0xb6, 0x4b, 0x71, 0x36, 0x12, 0x32, 0x48, 0x7c, 0x0e,
	0x46, 0xf8, 0x85, 0xec, 0x66, 0x81, 0xa1, 0xcf, 0x0d, 0x45, 0xe7, 0x37, 0x75, 0x57, 0xc8, 0x02,
	0x69, 0xfc, 0x01, 0x08, 0x61, 0x33, 0x1b, 0x94, 0xf8, 0xf4, 0x8b, 0xb6, 0xe0, 0x6c, 0xd2, 0xe3,
	0x58, 0xbc, 0x5a, 0x4f, 0x9f, 0x81, 0x74, 0xe8, 0x00, 0x16, 0x20, 0x76, 0x9d, 0x6c, 0xfb, 0x33,
	0x29, 0x7d, 0xa4, 0x24, 0x37, 0x15, 0xa3, 0x41, 0xfc, 0xf0, 0xf3, 0x97, 0xa5, 0xe8, 0x1b, 0x68,
	0xe9, 0x0b, 0x74, 0xaf, 0x8d, 0xfe, 0x86, 0x06, 0xf6, 0xee, 0x47, 0x61, 0xbc, 0xc3, 0x15, 0x5d,
	0xda, 0x37, 0x20, 0xa3, 0x40, 0x84, 0xf1, 0x65, 0x3f, 0x13, 0x44, 0x9a, 0x0a, 0xd3, 0x13, 0x7d,
	0xb9, 0x04, 0xdf, 0x85, 0x49, 0x8a, 0xcd, 0x22, 0x2e, 0x16, 0x55, 0xd5, 0x6a, 0x98, 0xde, 0x74,
	0xa6, 0x37, 0x33, 0x40, 0x80, 0x04, 0xe5, 0x8d, 0x4c, 0x8f, 0xf8, 0x09, 0x01, 0x33, 0x30, 0x59,
	0x0e, 0x43, 0x2d, 0x72, 0x52, 0xa9, 0x09, 0x8f, 0x25, 0x86, 0xdf, 0xd0, 0x3d, 0x8c, 0x81, 0xd0,
	0x1f, 0x00, 0xbc, 0x00, 0x53, 0x26, 0xf1, 0x5a, 0x96, 0x73, 0xbd, 0xaa, 0x9b, 0x1e, 0x71, 0x36,
	0x15, 0xb5, 0x73, 0xa7, 0xcb, 0xd8, 0x5f, 0xab, 0x04, 0x4b, 0x15, 0x0d, 0x1f, 0x83, 0x4c, 0x67,
	0xa7, 0xb7, 0x6d, 0x07, 0xa4, 0x8d, 0x87, 0x5f, 0x03, 0x60, 0xdb, 0xd1, 0x9b, 0x8a, 0x47, 0xaa,
	0xba, 0xdd, 0x3c, 0x1d, 0xfe, 0x12, 0x10, 0xe3, 0xc0, 0xfe, 0x5a, 0xc5, 0x6e, 0x9e, 0x0e, 0x7e,
	0x11, 0x38, 0x09, 0x93, 0x4a, 0x53, 0xd1, 0x0d, 0xa5, 0xa6, 0x1b, 0xba, 0xb7, 0x5d, 0xfd, 0xd0,
	0x32, 0x89, 0x7f, 0x5a, 0x84, 0xee, 0x85, 0xf7, 0x2c, 0x93, 0xe0, 0x43, 0x90, 0x0e, 0x9b, 0x50,
	0xff, 0xd4, 0xa4, 0x82, 0xd6, 0x10, 0x1f, 0x80, 0xa4, 0x7f, 0x24, 0xf8, 0xa1, 0xf1, 0xdf, 0x96,
	0x1e, 0xd0, 0x60, 0xfe, 0x03, 0x41, 0x1e, 0xa6, 0x2e, 0x70, 0xc7, 0xc4, 0xd0, 0x33, 0x1a, 0xbf,
	0x03, 0x83, 0xc9, 0x00, 0x09, 0x32, 0x9d, 0x7d, 0xd4, 0x3b, 0xda, 0x20, 0xf4, 0x92, 0x40, 0x31,
	0xd7, 0xb9, 0x4f, 0x62, 0x65, 0xfd, 0xf2, 0x69, 0xd1, 0xf7, 0x8a, 0x62, 0x0e, 0xe2, 0x81, 0x46,
	0xaf, 0xd8, 0xe5, 0x94, 0x48, 0xbd, 0xa2, 0xd1, 0x7b, 0x8c, 0x02, 0xc8, 0x42, 0x3a, 0xec, 0x70,
	0xa7, 0x47, 0xbb, 0xfc, 0xa6, 0x49, 0xe9, 0x87, 0x3d, 0x15, 0x78, 0x2c, 0x7d, 0x9c, 0x80, 0xcc,
	0x39, 0xc3, 0xaa, 0x29, 0xc6, 0x86, 0x4d, 0x54, 0x16, 0x8a, 0x15, 0x48, 0xd2, 0xab, 0xc1, 0x09,
	0x2e, 0x86, 0x57, 0x9f, 0x7a, 0xa2, 0x56, 0xf8, 0x25, 0x45, 0x0f, 0xfa, 0x6a, 0x44, 0x4e, 0x28,
	0x2d, 0x57, 0x26, 0xf8, 0x22, 0xf4, 0x74, 0x05, 0xac, 0xdc, 0x8c, 0x16, 0x4e, 0x3e, 0x0d, 0xac,
	0xeb, 0x36, 0x5b, 0x8d, 0xc8, 0xa0, 0xb4, 0xdc, 0x4b, 0xf5, 0x16, 0xfd, 0x82, 0x57, 0x61, 0xc4,
	0x25, 0x75, 0x9a, 0xa8, 0xd9, 0xf1, 0x67, 0xee, 0x1e, 0xe0, 0xd6, 0x4e, 0x20, 0x25, 0x07, 0x0f,
	0xb8, 0x08, 0x42, 0x4d, 0x31, 0xb5, 0x96, 0xae, 0x79, 0xd7, 0xaa, 0xaf, 0x2f, 0x2c, 0x6c, 0xd5,
	0x82, 0xea, 0x31, 0x78, 0x2e, 0x43, 0xf2, 0x44, 0xb8, 0x9f, 0x6f, 0xc7, 0x25, 0x48, 0x50, 0xaf,
	0xdc, 0xec, 0x18, 0xab, 0x63, 0x87, 0xfb, 0xe4, 0x7a, 0x8d, 0xc8, 0xdc, 0xda, 0x61, 0xdd, 0x4f,
	0xf8, 0xfb, 0x18, 0x13, 0xc5, 0x3f, 0x85, 0x89, 0xa6, 0xee, 0x78, 0x74, 0x68, 0xf7, 0xf3, 0x28,
	0x9b, 0x79, 0x06, 0xb4, 0x83, 0xb7, 0x76, 0xfa, 0xe5, 0x02, 0xe0, 0x8c, 0xff, 0xdd, 0x4f, 0x57,
	0x5c, 0x0e, 0x6e, 0x83, 0x09, 0x11, 0xcd, 0x64, 0x9e, 0xe5, 0x37, 0xc3, 0xae, 0xbe, 0x81, 0xf8,
	0xb7, 0x47, 0xe9, 0x30, 0x24, 0xd8, 0x4e, 0x36, 0x04, 0x46, 0xe9, 0xc5, 0x4d, 0x87, 0xc0, 0xc2,
	0xec, 0x19, 0xaa, 0xb3, 0xf4, 0x9d, 0x6e, 0x32, 0xf9, 0x0f, 0xc2, 0x78, 0xfc, 0x6e, 0x1b, 0xa5,
	0x77, 0xdb, 0x28, 0xb5, 0xd7, 0x46, 0xe8, 0x2c, 0xbf, 0xe2, 0x07, 0x0e, 0xcf, 0xfc, 0x47, 0x41,
	0x3a, 0x3c, 0xff, 0x21, 0x0a, 0x19, 0x56, 0xf8, 0x48, 0x98, 0x88, 0x6f, 0xbd, 0x58, 0x22, 0xfe,
	0x0f, 0x53, 0xf0, 0x07, 0x2f, 0x90, 0x82, 0x61, 0xda, 0xb1, 0x7e, 0xad, 0xf7, 0xac, 0x95, 0x70,
	0x40, 0x6d, 0xfa, 0xa3, 0x6f, 0x10, 0x7f, 0x1c, 0xce, 0x96, 0xf4, 0xe7, 0x28, 0x4c, 0xf8, 0x4d,
	0x67, 0x48, 0xd4, 0x8f, 0xfa, 0x88, 0x1a, 0x7e, 0xab, 0xf6, 0xcf, 0x1c, 0x1d, 0xbe, 0x2e, 0x0f,
	0xe4, 0xab, 0xf0, 0x8c, 0x68, 0xff, 0xd7, 0xb4, 0x3d, 0x8a, 0xc2, 0xe8, 0x39, 0xe2, 0x7d, 0x5b,
	0x73, 0xeb, 0xe5, 0x9c, 0xf4, 0x97, 0x42, 0xf5, 0x89, 0x53, 0xfe, 0xaf, 0xe4, 0xdd, 0x0a, 0x70,
	0x0a, 0xe2, 0xe5, 0x8b, 0x57, 0x2e, 0x08, 0x11, 0x3c, 0x06, 0xa9, 0xf2, 0xca, 0x39, 0xb9, 0x58,
	0x5e, 0x29, 0x0b, 0x08, 0x27, 0x21, 0xfa, 0xce, 0xba, 0x10, 0x2d, 0xfd, 0x06, 0xed, 0x3e, 0xc8,
	0x45, 0xee, 0x3f, 0xc8, 0x45, 0xbe, 0x7a, 0x90, 0x43, 0x37, 0xf6, 0x72, 0xe8, 0xb3, 0xbd, 0x1c,
	0xfa, 0x72, 0x2f, 0x87, 0x76, 0xf7, 0x72, 0xe8, 0xfe, 0x5e, 0x0e, 0xfd, 0x73, 0x2f, 0x87, 0x1e,
	0xed, 0xe5, 0x22, 0x5f, 0xed, 0xe5, 0xd0, 0xa7, 0x0f, 0x73, 0x91, 0xbb, 0x0f, 0x73, 0x68, 0xf7,
	0x61, 0x2e, 0x72, 0xff, 0x61, 0x2e, 0xf2, 0xde, 0x8f, 0xeb, 0x96, 0x7d, 0xbd, 0x9e, 0x6f, 0x5a,
	0x86, 0x47, 0x1c, 0x47, 0xc9, 0x37, 0xdc, 0x79, 0xf6, 0xb0, 0x69, 0x39, 0x5b, 0x73, 0xb6, 0x63,
	0x35, 0x75, 0x8d, 0x38, 0x73, 0xc1, 0xf2, 0xbc, 0x5d, 0xab, 0x5b, 0xf3, 0xe4, 0xe7, 0x9e, 0xff,
	0x4f, 0xd5, 0xa0, 0x7f, 0xfa, 0x6a, 0x49, 0xd6, 0xa4, 0x9f, 0xfa, 0x4f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x75, 0x36, 0x94, 0x8a, 0x0f, 0x1c, 0x00, 0x00,
}

func (x CloudConnectState) String() string {
	s, ok := CloudConnectState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *AWSREType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSREType)
	if !ok {
		that2, ok := that.(AWSREType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Region.Equal(that1.Region) {
		return false
	}
	if !this.Cred.Equal(that1.Cred) {
		return false
	}
	if !this.VpcAttachments.Equal(that1.VpcAttachments) {
		return false
	}
	if !this.CloudLinks.Equal(that1.CloudLinks) {
		return false
	}
	if this.Tgw != that1.Tgw {
		return false
	}
	if len(this.Peers) != len(that1.Peers) {
		return false
	}
	for i := range this.Peers {
		if !this.Peers[i].Equal(that1.Peers[i]) {
			return false
		}
	}
	return true
}
func (this *PeerType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PeerType)
	if !ok {
		that2, ok := that.(PeerType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TgwAddress != that1.TgwAddress {
		return false
	}
	if this.PeerAsn != that1.PeerAsn {
		return false
	}
	if !this.Node.Equal(that1.Node) {
		return false
	}
	if this.InsideGreSubnet != that1.InsideGreSubnet {
		return false
	}
	return true
}
func (this *CloudLinkListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudLinkListType)
	if !ok {
		that2, ok := that.(CloudLinkListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.CloudLink) != len(that1.CloudLink) {
		return false
	}
	for i := range this.CloudLink {
		if !this.CloudLink[i].Equal(that1.CloudLink[i]) {
			return false
		}
	}
	return true
}
func (this *AWSVPCAttachmentListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCAttachmentListType)
	if !ok {
		that2, ok := that.(AWSVPCAttachmentListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.VpcList) != len(that1.VpcList) {
		return false
	}
	for i := range this.VpcList {
		if !this.VpcList[i].Equal(that1.VpcList[i]) {
			return false
		}
	}
	return true
}
func (this *AWSVPCAttachmentType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCAttachmentType)
	if !ok {
		that2, ok := that.(AWSVPCAttachmentType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VpcId != that1.VpcId {
		return false
	}
	if that1.RoutingChoice == nil {
		if this.RoutingChoice != nil {
			return false
		}
	} else if this.RoutingChoice == nil {
		return false
	} else if !this.RoutingChoice.Equal(that1.RoutingChoice) {
		return false
	}
	return true
}
func (this *AWSVPCAttachmentType_ManualRouting) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCAttachmentType_ManualRouting)
	if !ok {
		that2, ok := that.(AWSVPCAttachmentType_ManualRouting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ManualRouting.Equal(that1.ManualRouting) {
		return false
	}
	return true
}
func (this *AWSVPCAttachmentType_DefaultRoute) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCAttachmentType_DefaultRoute)
	if !ok {
		that2, ok := that.(AWSVPCAttachmentType_DefaultRoute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultRoute.Equal(that1.DefaultRoute) {
		return false
	}
	return true
}
func (this *AWSVPCAttachmentType_CustomRouting) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCAttachmentType_CustomRouting)
	if !ok {
		that2, ok := that.(AWSVPCAttachmentType_CustomRouting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CustomRouting.Equal(that1.CustomRouting) {
		return false
	}
	return true
}
func (this *DefaultRoute) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DefaultRoute)
	if !ok {
		that2, ok := that.(DefaultRoute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.DefaultRouteChoice == nil {
		if this.DefaultRouteChoice != nil {
			return false
		}
	} else if this.DefaultRouteChoice == nil {
		return false
	} else if !this.DefaultRouteChoice.Equal(that1.DefaultRouteChoice) {
		return false
	}
	return true
}
func (this *DefaultRoute_AllRouteTables) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DefaultRoute_AllRouteTables)
	if !ok {
		that2, ok := that.(DefaultRoute_AllRouteTables)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllRouteTables.Equal(that1.AllRouteTables) {
		return false
	}
	return true
}
func (this *DefaultRoute_SelectiveRouteTables) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DefaultRoute_SelectiveRouteTables)
	if !ok {
		that2, ok := that.(DefaultRoute_SelectiveRouteTables)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SelectiveRouteTables.Equal(that1.SelectiveRouteTables) {
		return false
	}
	return true
}
func (this *AWSSubnetIDListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSSubnetIDListType)
	if !ok {
		that2, ok := that.(AWSSubnetIDListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SubnetIds) != len(that1.SubnetIds) {
		return false
	}
	for i := range this.SubnetIds {
		if this.SubnetIds[i] != that1.SubnetIds[i] {
			return false
		}
	}
	return true
}
func (this *AWSRouteTableListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSRouteTableListType)
	if !ok {
		that2, ok := that.(AWSRouteTableListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.RouteTables) != len(that1.RouteTables) {
		return false
	}
	for i := range this.RouteTables {
		if !this.RouteTables[i].Equal(that1.RouteTables[i]) {
			return false
		}
	}
	return true
}
func (this *AWSDefaultRoutesRouteTable) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSDefaultRoutesRouteTable)
	if !ok {
		that2, ok := that.(AWSDefaultRoutesRouteTable)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.RouteTableId) != len(that1.RouteTableId) {
		return false
	}
	for i := range this.RouteTableId {
		if this.RouteTableId[i] != that1.RouteTableId[i] {
			return false
		}
	}
	return true
}
func (this *AWSRouteTableType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSRouteTableType)
	if !ok {
		that2, ok := that.(AWSRouteTableType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RouteTableId != that1.RouteTableId {
		return false
	}
	if len(this.StaticRoutes) != len(that1.StaticRoutes) {
		return false
	}
	for i := range this.StaticRoutes {
		if this.StaticRoutes[i] != that1.StaticRoutes[i] {
			return false
		}
	}
	return true
}
func (this *ReplaceAWSREType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceAWSREType)
	if !ok {
		that2, ok := that.(ReplaceAWSREType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VpcAttachments.Equal(that1.VpcAttachments) {
		return false
	}
	return true
}
func (this *AWSTGWSiteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSTGWSiteType)
	if !ok {
		that2, ok := that.(AWSTGWSiteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Site.Equal(that1.Site) {
		return false
	}
	if !this.Cred.Equal(that1.Cred) {
		return false
	}
	if !this.VpcAttachments.Equal(that1.VpcAttachments) {
		return false
	}
	return true
}
func (this *ReplaceAWSTGWSiteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceAWSTGWSiteType)
	if !ok {
		that2, ok := that.(ReplaceAWSTGWSiteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VpcAttachments.Equal(that1.VpcAttachments) {
		return false
	}
	return true
}
func (this *CloudConnectStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudConnectStatusType)
	if !ok {
		that2, ok := that.(CloudConnectStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.CloudConnectDeployment == nil {
		if this.CloudConnectDeployment != nil {
			return false
		}
	} else if this.CloudConnectDeployment == nil {
		return false
	} else if !this.CloudConnectDeployment.Equal(that1.CloudConnectDeployment) {
		return false
	}
	return true
}
func (this *CloudConnectStatusType_CloudConnectAwsSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudConnectStatusType_CloudConnectAwsSite)
	if !ok {
		that2, ok := that.(CloudConnectStatusType_CloudConnectAwsSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CloudConnectAwsSite.Equal(that1.CloudConnectAwsSite) {
		return false
	}
	return true
}
func (this *AWSAttachmentsListStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSAttachmentsListStatusType)
	if !ok {
		that2, ok := that.(AWSAttachmentsListStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.AttachmentStatus) != len(that1.AttachmentStatus) {
		return false
	}
	for i := range this.AttachmentStatus {
		if !this.AttachmentStatus[i].Equal(that1.AttachmentStatus[i]) {
			return false
		}
	}
	return true
}
func (this *AWSAttachmentsStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSAttachmentsStatusType)
	if !ok {
		that2, ok := that.(AWSAttachmentsStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TgwAttachmentId != that1.TgwAttachmentId {
		return false
	}
	if !this.CreationTime.Equal(that1.CreationTime) {
		return false
	}
	if this.VpcId != that1.VpcId {
		return false
	}
	if this.VpcOwnerId != that1.VpcOwnerId {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.DeploymentStatus != that1.DeploymentStatus {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if len(this.Subnets) != len(that1.Subnets) {
		return false
	}
	for i := range this.Subnets {
		if !this.Subnets[i].Equal(that1.Subnets[i]) {
			return false
		}
	}
	if !this.InstalledRoutes.Equal(that1.InstalledRoutes) {
		return false
	}
	return true
}
func (this *SubnetStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubnetStatusType)
	if !ok {
		that2, ok := that.(SubnetStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NetworkInterfaceId != that1.NetworkInterfaceId {
		return false
	}
	if this.InterfaceType != that1.InterfaceType {
		return false
	}
	if this.PrivateIpv4Address != that1.PrivateIpv4Address {
		return false
	}
	if this.AvailabilityZone != that1.AvailabilityZone {
		return false
	}
	if this.SubnetId != that1.SubnetId {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Cloud == nil {
		if this.Cloud != nil {
			return false
		}
	} else if this.Cloud == nil {
		return false
	} else if !this.Cloud.Equal(that1.Cloud) {
		return false
	}
	if !this.Segment.Equal(that1.Segment) {
		return false
	}
	if that1.BandwidthOption == nil {
		if this.BandwidthOption != nil {
			return false
		}
	} else if this.BandwidthOption == nil {
		return false
	} else if !this.BandwidthOption.Equal(that1.BandwidthOption) {
		return false
	}
	if len(this.Sites) != len(that1.Sites) {
		return false
	}
	for i := range this.Sites {
		if !this.Sites[i].Equal(that1.Sites[i]) {
			return false
		}
	}
	if len(this.VirtualNetwork) != len(that1.VirtualNetwork) {
		return false
	}
	for i := range this.VirtualNetwork {
		if !this.VirtualNetwork[i].Equal(that1.VirtualNetwork[i]) {
			return false
		}
	}
	if this.State != that1.State {
		return false
	}
	return true
}
func (this *GlobalSpecType_AwsRe) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AwsRe)
	if !ok {
		that2, ok := that.(GlobalSpecType_AwsRe)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsRe.Equal(that1.AwsRe) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AwsTgwSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AwsTgwSite)
	if !ok {
		that2, ok := that.(GlobalSpecType_AwsTgwSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsTgwSite.Equal(that1.AwsTgwSite) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Bandwidth_500Mbs) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Bandwidth_500Mbs)
	if !ok {
		that2, ok := that.(GlobalSpecType_Bandwidth_500Mbs)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Bandwidth_500Mbs.Equal(that1.Bandwidth_500Mbs) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Cloud == nil {
		if this.Cloud != nil {
			return false
		}
	} else if this.Cloud == nil {
		return false
	} else if !this.Cloud.Equal(that1.Cloud) {
		return false
	}
	if !this.Segment.Equal(that1.Segment) {
		return false
	}
	return true
}
func (this *CreateSpecType_AwsRe) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AwsRe)
	if !ok {
		that2, ok := that.(CreateSpecType_AwsRe)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsRe.Equal(that1.AwsRe) {
		return false
	}
	return true
}
func (this *CreateSpecType_AwsTgwSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AwsTgwSite)
	if !ok {
		that2, ok := that.(CreateSpecType_AwsTgwSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsTgwSite.Equal(that1.AwsTgwSite) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Cloud == nil {
		if this.Cloud != nil {
			return false
		}
	} else if this.Cloud == nil {
		return false
	} else if !this.Cloud.Equal(that1.Cloud) {
		return false
	}
	if !this.Segment.Equal(that1.Segment) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AwsRe) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AwsRe)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AwsRe)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsRe.Equal(that1.AwsRe) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AwsTgwSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AwsTgwSite)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AwsTgwSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsTgwSite.Equal(that1.AwsTgwSite) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Cloud == nil {
		if this.Cloud != nil {
			return false
		}
	} else if this.Cloud == nil {
		return false
	} else if !this.Cloud.Equal(that1.Cloud) {
		return false
	}
	if !this.Segment.Equal(that1.Segment) {
		return false
	}
	if this.State != that1.State {
		return false
	}
	return true
}
func (this *GetSpecType_AwsRe) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AwsRe)
	if !ok {
		that2, ok := that.(GetSpecType_AwsRe)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsRe.Equal(that1.AwsRe) {
		return false
	}
	return true
}
func (this *GetSpecType_AwsTgwSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AwsTgwSite)
	if !ok {
		that2, ok := that.(GetSpecType_AwsTgwSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsTgwSite.Equal(that1.AwsTgwSite) {
		return false
	}
	return true
}
func (this *AWSREType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&cloud_connect.AWSREType{")
	if this.Region != nil {
		s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	}
	if this.Cred != nil {
		s = append(s, "Cred: "+fmt.Sprintf("%#v", this.Cred)+",\n")
	}
	if this.VpcAttachments != nil {
		s = append(s, "VpcAttachments: "+fmt.Sprintf("%#v", this.VpcAttachments)+",\n")
	}
	if this.CloudLinks != nil {
		s = append(s, "CloudLinks: "+fmt.Sprintf("%#v", this.CloudLinks)+",\n")
	}
	s = append(s, "Tgw: "+fmt.Sprintf("%#v", this.Tgw)+",\n")
	if this.Peers != nil {
		s = append(s, "Peers: "+fmt.Sprintf("%#v", this.Peers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PeerType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cloud_connect.PeerType{")
	s = append(s, "TgwAddress: "+fmt.Sprintf("%#v", this.TgwAddress)+",\n")
	s = append(s, "PeerAsn: "+fmt.Sprintf("%#v", this.PeerAsn)+",\n")
	if this.Node != nil {
		s = append(s, "Node: "+fmt.Sprintf("%#v", this.Node)+",\n")
	}
	s = append(s, "InsideGreSubnet: "+fmt.Sprintf("%#v", this.InsideGreSubnet)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudLinkListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.CloudLinkListType{")
	if this.CloudLink != nil {
		s = append(s, "CloudLink: "+fmt.Sprintf("%#v", this.CloudLink)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCAttachmentListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.AWSVPCAttachmentListType{")
	if this.VpcList != nil {
		s = append(s, "VpcList: "+fmt.Sprintf("%#v", this.VpcList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCAttachmentType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cloud_connect.AWSVPCAttachmentType{")
	s = append(s, "VpcId: "+fmt.Sprintf("%#v", this.VpcId)+",\n")
	if this.RoutingChoice != nil {
		s = append(s, "RoutingChoice: "+fmt.Sprintf("%#v", this.RoutingChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCAttachmentType_ManualRouting) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.AWSVPCAttachmentType_ManualRouting{` +
		`ManualRouting:` + fmt.Sprintf("%#v", this.ManualRouting) + `}`}, ", ")
	return s
}
func (this *AWSVPCAttachmentType_DefaultRoute) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.AWSVPCAttachmentType_DefaultRoute{` +
		`DefaultRoute:` + fmt.Sprintf("%#v", this.DefaultRoute) + `}`}, ", ")
	return s
}
func (this *AWSVPCAttachmentType_CustomRouting) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.AWSVPCAttachmentType_CustomRouting{` +
		`CustomRouting:` + fmt.Sprintf("%#v", this.CustomRouting) + `}`}, ", ")
	return s
}
func (this *DefaultRoute) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloud_connect.DefaultRoute{")
	if this.DefaultRouteChoice != nil {
		s = append(s, "DefaultRouteChoice: "+fmt.Sprintf("%#v", this.DefaultRouteChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DefaultRoute_AllRouteTables) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.DefaultRoute_AllRouteTables{` +
		`AllRouteTables:` + fmt.Sprintf("%#v", this.AllRouteTables) + `}`}, ", ")
	return s
}
func (this *DefaultRoute_SelectiveRouteTables) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.DefaultRoute_SelectiveRouteTables{` +
		`SelectiveRouteTables:` + fmt.Sprintf("%#v", this.SelectiveRouteTables) + `}`}, ", ")
	return s
}
func (this *AWSSubnetIDListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.AWSSubnetIDListType{")
	s = append(s, "SubnetIds: "+fmt.Sprintf("%#v", this.SubnetIds)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSRouteTableListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.AWSRouteTableListType{")
	if this.RouteTables != nil {
		s = append(s, "RouteTables: "+fmt.Sprintf("%#v", this.RouteTables)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSDefaultRoutesRouteTable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.AWSDefaultRoutesRouteTable{")
	s = append(s, "RouteTableId: "+fmt.Sprintf("%#v", this.RouteTableId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSRouteTableType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloud_connect.AWSRouteTableType{")
	s = append(s, "RouteTableId: "+fmt.Sprintf("%#v", this.RouteTableId)+",\n")
	s = append(s, "StaticRoutes: "+fmt.Sprintf("%#v", this.StaticRoutes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceAWSREType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.ReplaceAWSREType{")
	if this.VpcAttachments != nil {
		s = append(s, "VpcAttachments: "+fmt.Sprintf("%#v", this.VpcAttachments)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSTGWSiteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloud_connect.AWSTGWSiteType{")
	if this.Site != nil {
		s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	}
	if this.Cred != nil {
		s = append(s, "Cred: "+fmt.Sprintf("%#v", this.Cred)+",\n")
	}
	if this.VpcAttachments != nil {
		s = append(s, "VpcAttachments: "+fmt.Sprintf("%#v", this.VpcAttachments)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceAWSTGWSiteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.ReplaceAWSTGWSiteType{")
	if this.VpcAttachments != nil {
		s = append(s, "VpcAttachments: "+fmt.Sprintf("%#v", this.VpcAttachments)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudConnectStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.CloudConnectStatusType{")
	if this.CloudConnectDeployment != nil {
		s = append(s, "CloudConnectDeployment: "+fmt.Sprintf("%#v", this.CloudConnectDeployment)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudConnectStatusType_CloudConnectAwsSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.CloudConnectStatusType_CloudConnectAwsSite{` +
		`CloudConnectAwsSite:` + fmt.Sprintf("%#v", this.CloudConnectAwsSite) + `}`}, ", ")
	return s
}
func (this *AWSAttachmentsListStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.AWSAttachmentsListStatusType{")
	if this.AttachmentStatus != nil {
		s = append(s, "AttachmentStatus: "+fmt.Sprintf("%#v", this.AttachmentStatus)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSAttachmentsStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&cloud_connect.AWSAttachmentsStatusType{")
	s = append(s, "TgwAttachmentId: "+fmt.Sprintf("%#v", this.TgwAttachmentId)+",\n")
	if this.CreationTime != nil {
		s = append(s, "CreationTime: "+fmt.Sprintf("%#v", this.CreationTime)+",\n")
	}
	s = append(s, "VpcId: "+fmt.Sprintf("%#v", this.VpcId)+",\n")
	s = append(s, "VpcOwnerId: "+fmt.Sprintf("%#v", this.VpcOwnerId)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "DeploymentStatus: "+fmt.Sprintf("%#v", this.DeploymentStatus)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	if this.Subnets != nil {
		s = append(s, "Subnets: "+fmt.Sprintf("%#v", this.Subnets)+",\n")
	}
	if this.InstalledRoutes != nil {
		s = append(s, "InstalledRoutes: "+fmt.Sprintf("%#v", this.InstalledRoutes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SubnetStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&cloud_connect.SubnetStatusType{")
	s = append(s, "NetworkInterfaceId: "+fmt.Sprintf("%#v", this.NetworkInterfaceId)+",\n")
	s = append(s, "InterfaceType: "+fmt.Sprintf("%#v", this.InterfaceType)+",\n")
	s = append(s, "PrivateIpv4Address: "+fmt.Sprintf("%#v", this.PrivateIpv4Address)+",\n")
	s = append(s, "AvailabilityZone: "+fmt.Sprintf("%#v", this.AvailabilityZone)+",\n")
	s = append(s, "SubnetId: "+fmt.Sprintf("%#v", this.SubnetId)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&cloud_connect.GlobalSpecType{")
	if this.Cloud != nil {
		s = append(s, "Cloud: "+fmt.Sprintf("%#v", this.Cloud)+",\n")
	}
	if this.Segment != nil {
		s = append(s, "Segment: "+fmt.Sprintf("%#v", this.Segment)+",\n")
	}
	if this.BandwidthOption != nil {
		s = append(s, "BandwidthOption: "+fmt.Sprintf("%#v", this.BandwidthOption)+",\n")
	}
	if this.Sites != nil {
		s = append(s, "Sites: "+fmt.Sprintf("%#v", this.Sites)+",\n")
	}
	if this.VirtualNetwork != nil {
		s = append(s, "VirtualNetwork: "+fmt.Sprintf("%#v", this.VirtualNetwork)+",\n")
	}
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_AwsRe) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.GlobalSpecType_AwsRe{` +
		`AwsRe:` + fmt.Sprintf("%#v", this.AwsRe) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AwsTgwSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.GlobalSpecType_AwsTgwSite{` +
		`AwsTgwSite:` + fmt.Sprintf("%#v", this.AwsTgwSite) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_Bandwidth_500Mbs) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.GlobalSpecType_Bandwidth_500Mbs{` +
		`Bandwidth_500Mbs:` + fmt.Sprintf("%#v", this.Bandwidth_500Mbs) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloud_connect.CreateSpecType{")
	if this.Cloud != nil {
		s = append(s, "Cloud: "+fmt.Sprintf("%#v", this.Cloud)+",\n")
	}
	if this.Segment != nil {
		s = append(s, "Segment: "+fmt.Sprintf("%#v", this.Segment)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_AwsRe) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.CreateSpecType_AwsRe{` +
		`AwsRe:` + fmt.Sprintf("%#v", this.AwsRe) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_AwsTgwSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.CreateSpecType_AwsTgwSite{` +
		`AwsTgwSite:` + fmt.Sprintf("%#v", this.AwsTgwSite) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloud_connect.ReplaceSpecType{")
	if this.Cloud != nil {
		s = append(s, "Cloud: "+fmt.Sprintf("%#v", this.Cloud)+",\n")
	}
	if this.Segment != nil {
		s = append(s, "Segment: "+fmt.Sprintf("%#v", this.Segment)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_AwsRe) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.ReplaceSpecType_AwsRe{` +
		`AwsRe:` + fmt.Sprintf("%#v", this.AwsRe) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_AwsTgwSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.ReplaceSpecType_AwsTgwSite{` +
		`AwsTgwSite:` + fmt.Sprintf("%#v", this.AwsTgwSite) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cloud_connect.GetSpecType{")
	if this.Cloud != nil {
		s = append(s, "Cloud: "+fmt.Sprintf("%#v", this.Cloud)+",\n")
	}
	if this.Segment != nil {
		s = append(s, "Segment: "+fmt.Sprintf("%#v", this.Segment)+",\n")
	}
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_AwsRe) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.GetSpecType_AwsRe{` +
		`AwsRe:` + fmt.Sprintf("%#v", this.AwsRe) + `}`}, ", ")
	return s
}
func (this *GetSpecType_AwsTgwSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.GetSpecType_AwsTgwSite{` +
		`AwsTgwSite:` + fmt.Sprintf("%#v", this.AwsTgwSite) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *AWSREType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSREType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSREType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Peers) > 0 {
		for iNdEx := len(m.Peers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Peers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Tgw) > 0 {
		i -= len(m.Tgw)
		copy(dAtA[i:], m.Tgw)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Tgw)))
		i--
		dAtA[i] = 0x2a
	}
	if m.CloudLinks != nil {
		{
			size, err := m.CloudLinks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.VpcAttachments != nil {
		{
			size, err := m.VpcAttachments.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Cred != nil {
		{
			size, err := m.Cred.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Region != nil {
		{
			size, err := m.Region.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PeerType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InsideGreSubnet) > 0 {
		i -= len(m.InsideGreSubnet)
		copy(dAtA[i:], m.InsideGreSubnet)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InsideGreSubnet)))
		i--
		dAtA[i] = 0x22
	}
	if m.Node != nil {
		{
			size, err := m.Node.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PeerAsn != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PeerAsn))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TgwAddress) > 0 {
		i -= len(m.TgwAddress)
		copy(dAtA[i:], m.TgwAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TgwAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloudLinkListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudLinkListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudLinkListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CloudLink) > 0 {
		for iNdEx := len(m.CloudLink) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CloudLink[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSVPCAttachmentListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSVPCAttachmentListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCAttachmentListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VpcList) > 0 {
		for iNdEx := len(m.VpcList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VpcList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSVPCAttachmentType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSVPCAttachmentType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCAttachmentType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RoutingChoice != nil {
		{
			size := m.RoutingChoice.Size()
			i -= size
			if _, err := m.RoutingChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.VpcId) > 0 {
		i -= len(m.VpcId)
		copy(dAtA[i:], m.VpcId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VpcId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWSVPCAttachmentType_ManualRouting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCAttachmentType_ManualRouting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ManualRouting != nil {
		{
			size, err := m.ManualRouting.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *AWSVPCAttachmentType_DefaultRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCAttachmentType_DefaultRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultRoute != nil {
		{
			size, err := m.DefaultRoute.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *AWSVPCAttachmentType_CustomRouting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCAttachmentType_CustomRouting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CustomRouting != nil {
		{
			size, err := m.CustomRouting.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *DefaultRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefaultRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DefaultRouteChoice != nil {
		{
			size := m.DefaultRouteChoice.Size()
			i -= size
			if _, err := m.DefaultRouteChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DefaultRoute_AllRouteTables) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultRoute_AllRouteTables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllRouteTables != nil {
		{
			size, err := m.AllRouteTables.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DefaultRoute_SelectiveRouteTables) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultRoute_SelectiveRouteTables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SelectiveRouteTables != nil {
		{
			size, err := m.SelectiveRouteTables.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AWSSubnetIDListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSSubnetIDListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSSubnetIDListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubnetIds) > 0 {
		for iNdEx := len(m.SubnetIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SubnetIds[iNdEx])
			copy(dAtA[i:], m.SubnetIds[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.SubnetIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSRouteTableListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSRouteTableListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSRouteTableListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RouteTables) > 0 {
		for iNdEx := len(m.RouteTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RouteTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSDefaultRoutesRouteTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSDefaultRoutesRouteTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSDefaultRoutesRouteTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RouteTableId) > 0 {
		for iNdEx := len(m.RouteTableId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RouteTableId[iNdEx])
			copy(dAtA[i:], m.RouteTableId[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RouteTableId[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSRouteTableType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSRouteTableType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSRouteTableType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StaticRoutes) > 0 {
		for iNdEx := len(m.StaticRoutes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StaticRoutes[iNdEx])
			copy(dAtA[i:], m.StaticRoutes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.StaticRoutes[iNdEx])))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.RouteTableId) > 0 {
		i -= len(m.RouteTableId)
		copy(dAtA[i:], m.RouteTableId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RouteTableId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceAWSREType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceAWSREType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceAWSREType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VpcAttachments != nil {
		{
			size, err := m.VpcAttachments.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *AWSTGWSiteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSTGWSiteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSTGWSiteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VpcAttachments != nil {
		{
			size, err := m.VpcAttachments.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Cred != nil {
		{
			size, err := m.Cred.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Site != nil {
		{
			size, err := m.Site.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceAWSTGWSiteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceAWSTGWSiteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceAWSTGWSiteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VpcAttachments != nil {
		{
			size, err := m.VpcAttachments.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *CloudConnectStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudConnectStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudConnectStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CloudConnectDeployment != nil {
		{
			size := m.CloudConnectDeployment.Size()
			i -= size
			if _, err := m.CloudConnectDeployment.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CloudConnectStatusType_CloudConnectAwsSite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudConnectStatusType_CloudConnectAwsSite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CloudConnectAwsSite != nil {
		{
			size, err := m.CloudConnectAwsSite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AWSAttachmentsListStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSAttachmentsListStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSAttachmentsListStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AttachmentStatus) > 0 {
		for iNdEx := len(m.AttachmentStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AttachmentStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSAttachmentsStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSAttachmentsStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSAttachmentsStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Subnets) > 0 {
		for iNdEx := len(m.Subnets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subnets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.InstalledRoutes != nil {
		{
			size, err := m.InstalledRoutes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Tags) > 0 {
		keysForTags := make([]string, 0, len(m.Tags))
		for k := range m.Tags {
			keysForTags = append(keysForTags, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
		for iNdEx := len(keysForTags) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Tags[string(keysForTags[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForTags[iNdEx])
			copy(dAtA[i:], keysForTags[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForTags[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.DeploymentStatus) > 0 {
		i -= len(m.DeploymentStatus)
		copy(dAtA[i:], m.DeploymentStatus)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DeploymentStatus)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.VpcOwnerId) > 0 {
		i -= len(m.VpcOwnerId)
		copy(dAtA[i:], m.VpcOwnerId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VpcOwnerId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.VpcId) > 0 {
		i -= len(m.VpcId)
		copy(dAtA[i:], m.VpcId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VpcId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TgwAttachmentId) > 0 {
		i -= len(m.TgwAttachmentId)
		copy(dAtA[i:], m.TgwAttachmentId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TgwAttachmentId)))
		i--
		dAtA[i] = 0x12
	}
	if m.CreationTime != nil {
		{
			size, err := m.CreationTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubnetStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubnetStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SubnetId) > 0 {
		i -= len(m.SubnetId)
		copy(dAtA[i:], m.SubnetId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubnetId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AvailabilityZone) > 0 {
		i -= len(m.AvailabilityZone)
		copy(dAtA[i:], m.AvailabilityZone)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AvailabilityZone)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PrivateIpv4Address) > 0 {
		i -= len(m.PrivateIpv4Address)
		copy(dAtA[i:], m.PrivateIpv4Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PrivateIpv4Address)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.InterfaceType) > 0 {
		i -= len(m.InterfaceType)
		copy(dAtA[i:], m.InterfaceType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InterfaceType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NetworkInterfaceId) > 0 {
		i -= len(m.NetworkInterfaceId)
		copy(dAtA[i:], m.NetworkInterfaceId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NetworkInterfaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x78
	}
	if len(m.VirtualNetwork) > 0 {
		for iNdEx := len(m.VirtualNetwork) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VirtualNetwork[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if m.Segment != nil {
		{
			size, err := m.Segment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Sites) > 0 {
		for iNdEx := len(m.Sites) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sites[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.BandwidthOption != nil {
		{
			size := m.BandwidthOption.Size()
			i -= size
			if _, err := m.BandwidthOption.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Cloud != nil {
		{
			size := m.Cloud.Size()
			i -= size
			if _, err := m.Cloud.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_AwsRe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AwsRe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsRe != nil {
		{
			size, err := m.AwsRe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_AwsTgwSite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AwsTgwSite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsTgwSite != nil {
		{
			size, err := m.AwsTgwSite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_Bandwidth_500Mbs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_Bandwidth_500Mbs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Bandwidth_500Mbs != nil {
		{
			size, err := m.Bandwidth_500Mbs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Segment != nil {
		{
			size, err := m.Segment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Cloud != nil {
		{
			size := m.Cloud.Size()
			i -= size
			if _, err := m.Cloud.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_AwsRe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_AwsRe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsRe != nil {
		{
			size, err := m.AwsRe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_AwsTgwSite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_AwsTgwSite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsTgwSite != nil {
		{
			size, err := m.AwsTgwSite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Segment != nil {
		{
			size, err := m.Segment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Cloud != nil {
		{
			size := m.Cloud.Size()
			i -= size
			if _, err := m.Cloud.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_AwsRe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_AwsRe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsRe != nil {
		{
			size, err := m.AwsRe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_AwsTgwSite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_AwsTgwSite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsTgwSite != nil {
		{
			size, err := m.AwsTgwSite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x78
	}
	if m.Segment != nil {
		{
			size, err := m.Segment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.Cloud != nil {
		{
			size := m.Cloud.Size()
			i -= size
			if _, err := m.Cloud.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_AwsRe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_AwsRe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsRe != nil {
		{
			size, err := m.AwsRe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_AwsTgwSite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_AwsTgwSite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsTgwSite != nil {
		{
			size, err := m.AwsTgwSite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AWSREType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Region != nil {
		l = m.Region.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Cred != nil {
		l = m.Cred.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VpcAttachments != nil {
		l = m.VpcAttachments.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CloudLinks != nil {
		l = m.CloudLinks.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Tgw)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Peers) > 0 {
		for _, e := range m.Peers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *PeerType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TgwAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PeerAsn != 0 {
		n += 1 + sovTypes(uint64(m.PeerAsn))
	}
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.InsideGreSubnet)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CloudLinkListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CloudLink) > 0 {
		for _, e := range m.CloudLink {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSVPCAttachmentListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VpcList) > 0 {
		for _, e := range m.VpcList {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSVPCAttachmentType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VpcId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RoutingChoice != nil {
		n += m.RoutingChoice.Size()
	}
	return n
}

func (m *AWSVPCAttachmentType_ManualRouting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ManualRouting != nil {
		l = m.ManualRouting.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AWSVPCAttachmentType_DefaultRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultRoute != nil {
		l = m.DefaultRoute.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AWSVPCAttachmentType_CustomRouting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CustomRouting != nil {
		l = m.CustomRouting.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DefaultRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultRouteChoice != nil {
		n += m.DefaultRouteChoice.Size()
	}
	return n
}

func (m *DefaultRoute_AllRouteTables) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllRouteTables != nil {
		l = m.AllRouteTables.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DefaultRoute_SelectiveRouteTables) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SelectiveRouteTables != nil {
		l = m.SelectiveRouteTables.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AWSSubnetIDListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SubnetIds) > 0 {
		for _, s := range m.SubnetIds {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSRouteTableListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RouteTables) > 0 {
		for _, e := range m.RouteTables {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSDefaultRoutesRouteTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RouteTableId) > 0 {
		for _, s := range m.RouteTableId {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSRouteTableType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RouteTableId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.StaticRoutes) > 0 {
		for _, s := range m.StaticRoutes {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ReplaceAWSREType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VpcAttachments != nil {
		l = m.VpcAttachments.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AWSTGWSiteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Site != nil {
		l = m.Site.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Cred != nil {
		l = m.Cred.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VpcAttachments != nil {
		l = m.VpcAttachments.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceAWSTGWSiteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VpcAttachments != nil {
		l = m.VpcAttachments.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CloudConnectStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloudConnectDeployment != nil {
		n += m.CloudConnectDeployment.Size()
	}
	return n
}

func (m *CloudConnectStatusType_CloudConnectAwsSite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloudConnectAwsSite != nil {
		l = m.CloudConnectAwsSite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AWSAttachmentsListStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AttachmentStatus) > 0 {
		for _, e := range m.AttachmentStatus {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSAttachmentsStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreationTime != nil {
		l = m.CreationTime.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TgwAttachmentId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VpcId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VpcOwnerId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DeploymentStatus)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.InstalledRoutes != nil {
		l = m.InstalledRoutes.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Subnets) > 0 {
		for _, e := range m.Subnets {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *SubnetStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NetworkInterfaceId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.InterfaceType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PrivateIpv4Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AvailabilityZone)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubnetId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cloud != nil {
		n += m.Cloud.Size()
	}
	if m.BandwidthOption != nil {
		n += m.BandwidthOption.Size()
	}
	if len(m.Sites) > 0 {
		for _, e := range m.Sites {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Segment != nil {
		l = m.Segment.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.VirtualNetwork) > 0 {
		for _, e := range m.VirtualNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	return n
}

func (m *GlobalSpecType_AwsRe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsRe != nil {
		l = m.AwsRe.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AwsTgwSite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsTgwSite != nil {
		l = m.AwsTgwSite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_Bandwidth_500Mbs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bandwidth_500Mbs != nil {
		l = m.Bandwidth_500Mbs.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cloud != nil {
		n += m.Cloud.Size()
	}
	if m.Segment != nil {
		l = m.Segment.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType_AwsRe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsRe != nil {
		l = m.AwsRe.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AwsTgwSite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsTgwSite != nil {
		l = m.AwsTgwSite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cloud != nil {
		n += m.Cloud.Size()
	}
	if m.Segment != nil {
		l = m.Segment.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType_AwsRe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsRe != nil {
		l = m.AwsRe.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AwsTgwSite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsTgwSite != nil {
		l = m.AwsTgwSite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cloud != nil {
		n += m.Cloud.Size()
	}
	if m.Segment != nil {
		l = m.Segment.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	return n
}

func (m *GetSpecType_AwsRe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsRe != nil {
		l = m.AwsRe.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AwsTgwSite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsTgwSite != nil {
		l = m.AwsTgwSite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AWSREType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPeers := "[]*PeerType{"
	for _, f := range this.Peers {
		repeatedStringForPeers += strings.Replace(f.String(), "PeerType", "PeerType", 1) + ","
	}
	repeatedStringForPeers += "}"
	s := strings.Join([]string{`&AWSREType{`,
		`Region:` + strings.Replace(fmt.Sprintf("%v", this.Region), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`Cred:` + strings.Replace(fmt.Sprintf("%v", this.Cred), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`VpcAttachments:` + strings.Replace(this.VpcAttachments.String(), "AWSVPCAttachmentListType", "AWSVPCAttachmentListType", 1) + `,`,
		`CloudLinks:` + strings.Replace(this.CloudLinks.String(), "CloudLinkListType", "CloudLinkListType", 1) + `,`,
		`Tgw:` + fmt.Sprintf("%v", this.Tgw) + `,`,
		`Peers:` + repeatedStringForPeers + `,`,
		`}`,
	}, "")
	return s
}
func (this *PeerType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PeerType{`,
		`TgwAddress:` + fmt.Sprintf("%v", this.TgwAddress) + `,`,
		`PeerAsn:` + fmt.Sprintf("%v", this.PeerAsn) + `,`,
		`Node:` + strings.Replace(fmt.Sprintf("%v", this.Node), "NodeType", "cloud_re_region.NodeType", 1) + `,`,
		`InsideGreSubnet:` + fmt.Sprintf("%v", this.InsideGreSubnet) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudLinkListType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCloudLink := "[]*ObjectRefType{"
	for _, f := range this.CloudLink {
		repeatedStringForCloudLink += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "views.ObjectRefType", 1) + ","
	}
	repeatedStringForCloudLink += "}"
	s := strings.Join([]string{`&CloudLinkListType{`,
		`CloudLink:` + repeatedStringForCloudLink + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCAttachmentListType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForVpcList := "[]*AWSVPCAttachmentType{"
	for _, f := range this.VpcList {
		repeatedStringForVpcList += strings.Replace(f.String(), "AWSVPCAttachmentType", "AWSVPCAttachmentType", 1) + ","
	}
	repeatedStringForVpcList += "}"
	s := strings.Join([]string{`&AWSVPCAttachmentListType{`,
		`VpcList:` + repeatedStringForVpcList + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCAttachmentType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCAttachmentType{`,
		`VpcId:` + fmt.Sprintf("%v", this.VpcId) + `,`,
		`RoutingChoice:` + fmt.Sprintf("%v", this.RoutingChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCAttachmentType_ManualRouting) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCAttachmentType_ManualRouting{`,
		`ManualRouting:` + strings.Replace(fmt.Sprintf("%v", this.ManualRouting), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCAttachmentType_DefaultRoute) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCAttachmentType_DefaultRoute{`,
		`DefaultRoute:` + strings.Replace(fmt.Sprintf("%v", this.DefaultRoute), "DefaultRoute", "DefaultRoute", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCAttachmentType_CustomRouting) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCAttachmentType_CustomRouting{`,
		`CustomRouting:` + strings.Replace(fmt.Sprintf("%v", this.CustomRouting), "AWSRouteTableListType", "AWSRouteTableListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DefaultRoute) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DefaultRoute{`,
		`DefaultRouteChoice:` + fmt.Sprintf("%v", this.DefaultRouteChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DefaultRoute_AllRouteTables) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DefaultRoute_AllRouteTables{`,
		`AllRouteTables:` + strings.Replace(fmt.Sprintf("%v", this.AllRouteTables), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DefaultRoute_SelectiveRouteTables) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DefaultRoute_SelectiveRouteTables{`,
		`SelectiveRouteTables:` + strings.Replace(fmt.Sprintf("%v", this.SelectiveRouteTables), "AWSDefaultRoutesRouteTable", "AWSDefaultRoutesRouteTable", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSSubnetIDListType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSSubnetIDListType{`,
		`SubnetIds:` + fmt.Sprintf("%v", this.SubnetIds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSRouteTableListType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRouteTables := "[]*AWSRouteTableType{"
	for _, f := range this.RouteTables {
		repeatedStringForRouteTables += strings.Replace(f.String(), "AWSRouteTableType", "AWSRouteTableType", 1) + ","
	}
	repeatedStringForRouteTables += "}"
	s := strings.Join([]string{`&AWSRouteTableListType{`,
		`RouteTables:` + repeatedStringForRouteTables + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSDefaultRoutesRouteTable) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSDefaultRoutesRouteTable{`,
		`RouteTableId:` + fmt.Sprintf("%v", this.RouteTableId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSRouteTableType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSRouteTableType{`,
		`RouteTableId:` + fmt.Sprintf("%v", this.RouteTableId) + `,`,
		`StaticRoutes:` + fmt.Sprintf("%v", this.StaticRoutes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceAWSREType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceAWSREType{`,
		`VpcAttachments:` + strings.Replace(this.VpcAttachments.String(), "AWSVPCAttachmentListType", "AWSVPCAttachmentListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSTGWSiteType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSTGWSiteType{`,
		`Site:` + strings.Replace(fmt.Sprintf("%v", this.Site), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`Cred:` + strings.Replace(fmt.Sprintf("%v", this.Cred), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`VpcAttachments:` + strings.Replace(this.VpcAttachments.String(), "AWSVPCAttachmentListType", "AWSVPCAttachmentListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceAWSTGWSiteType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceAWSTGWSiteType{`,
		`VpcAttachments:` + strings.Replace(this.VpcAttachments.String(), "AWSVPCAttachmentListType", "AWSVPCAttachmentListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudConnectStatusType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudConnectStatusType{`,
		`CloudConnectDeployment:` + fmt.Sprintf("%v", this.CloudConnectDeployment) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudConnectStatusType_CloudConnectAwsSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudConnectStatusType_CloudConnectAwsSite{`,
		`CloudConnectAwsSite:` + strings.Replace(fmt.Sprintf("%v", this.CloudConnectAwsSite), "AWSAttachmentsListStatusType", "AWSAttachmentsListStatusType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSAttachmentsListStatusType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAttachmentStatus := "[]*AWSAttachmentsStatusType{"
	for _, f := range this.AttachmentStatus {
		repeatedStringForAttachmentStatus += strings.Replace(f.String(), "AWSAttachmentsStatusType", "AWSAttachmentsStatusType", 1) + ","
	}
	repeatedStringForAttachmentStatus += "}"
	s := strings.Join([]string{`&AWSAttachmentsListStatusType{`,
		`AttachmentStatus:` + repeatedStringForAttachmentStatus + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSAttachmentsStatusType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSubnets := "[]*SubnetStatusType{"
	for _, f := range this.Subnets {
		repeatedStringForSubnets += strings.Replace(f.String(), "SubnetStatusType", "SubnetStatusType", 1) + ","
	}
	repeatedStringForSubnets += "}"
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&AWSAttachmentsStatusType{`,
		`CreationTime:` + strings.Replace(fmt.Sprintf("%v", this.CreationTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`TgwAttachmentId:` + fmt.Sprintf("%v", this.TgwAttachmentId) + `,`,
		`VpcId:` + fmt.Sprintf("%v", this.VpcId) + `,`,
		`VpcOwnerId:` + fmt.Sprintf("%v", this.VpcOwnerId) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`DeploymentStatus:` + fmt.Sprintf("%v", this.DeploymentStatus) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`InstalledRoutes:` + strings.Replace(this.InstalledRoutes.String(), "AWSRouteTableListType", "AWSRouteTableListType", 1) + `,`,
		`Subnets:` + repeatedStringForSubnets + `,`,
		`}`,
	}, "")
	return s
}
func (this *SubnetStatusType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SubnetStatusType{`,
		`NetworkInterfaceId:` + fmt.Sprintf("%v", this.NetworkInterfaceId) + `,`,
		`InterfaceType:` + fmt.Sprintf("%v", this.InterfaceType) + `,`,
		`PrivateIpv4Address:` + fmt.Sprintf("%v", this.PrivateIpv4Address) + `,`,
		`AvailabilityZone:` + fmt.Sprintf("%v", this.AvailabilityZone) + `,`,
		`SubnetId:` + fmt.Sprintf("%v", this.SubnetId) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSites := "[]*ObjectRefType{"
	for _, f := range this.Sites {
		repeatedStringForSites += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForSites += "}"
	repeatedStringForVirtualNetwork := "[]*ObjectRefType{"
	for _, f := range this.VirtualNetwork {
		repeatedStringForVirtualNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForVirtualNetwork += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Cloud:` + fmt.Sprintf("%v", this.Cloud) + `,`,
		`BandwidthOption:` + fmt.Sprintf("%v", this.BandwidthOption) + `,`,
		`Sites:` + repeatedStringForSites + `,`,
		`Segment:` + strings.Replace(fmt.Sprintf("%v", this.Segment), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`VirtualNetwork:` + repeatedStringForVirtualNetwork + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AwsRe) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AwsRe{`,
		`AwsRe:` + strings.Replace(fmt.Sprintf("%v", this.AwsRe), "AWSREType", "AWSREType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AwsTgwSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AwsTgwSite{`,
		`AwsTgwSite:` + strings.Replace(fmt.Sprintf("%v", this.AwsTgwSite), "AWSTGWSiteType", "AWSTGWSiteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Bandwidth_500Mbs) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Bandwidth_500Mbs{`,
		`Bandwidth_500Mbs:` + strings.Replace(fmt.Sprintf("%v", this.Bandwidth_500Mbs), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Cloud:` + fmt.Sprintf("%v", this.Cloud) + `,`,
		`Segment:` + strings.Replace(fmt.Sprintf("%v", this.Segment), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AwsRe) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AwsRe{`,
		`AwsRe:` + strings.Replace(fmt.Sprintf("%v", this.AwsRe), "AWSREType", "AWSREType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AwsTgwSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AwsTgwSite{`,
		`AwsTgwSite:` + strings.Replace(fmt.Sprintf("%v", this.AwsTgwSite), "AWSTGWSiteType", "AWSTGWSiteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Cloud:` + fmt.Sprintf("%v", this.Cloud) + `,`,
		`Segment:` + strings.Replace(fmt.Sprintf("%v", this.Segment), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AwsRe) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AwsRe{`,
		`AwsRe:` + strings.Replace(fmt.Sprintf("%v", this.AwsRe), "ReplaceAWSREType", "ReplaceAWSREType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AwsTgwSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AwsTgwSite{`,
		`AwsTgwSite:` + strings.Replace(fmt.Sprintf("%v", this.AwsTgwSite), "ReplaceAWSTGWSiteType", "ReplaceAWSTGWSiteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`Cloud:` + fmt.Sprintf("%v", this.Cloud) + `,`,
		`Segment:` + strings.Replace(fmt.Sprintf("%v", this.Segment), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AwsRe) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AwsRe{`,
		`AwsRe:` + strings.Replace(fmt.Sprintf("%v", this.AwsRe), "AWSREType", "AWSREType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AwsTgwSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AwsTgwSite{`,
		`AwsTgwSite:` + strings.Replace(fmt.Sprintf("%v", this.AwsTgwSite), "AWSTGWSiteType", "AWSTGWSiteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AWSREType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSREType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSREType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Region == nil {
				m.Region = &views.ObjectRefType{}
			}
			if err := m.Region.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cred", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cred == nil {
				m.Cred = &views.ObjectRefType{}
			}
			if err := m.Cred.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcAttachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VpcAttachments == nil {
				m.VpcAttachments = &AWSVPCAttachmentListType{}
			}
			if err := m.VpcAttachments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudLinks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloudLinks == nil {
				m.CloudLinks = &CloudLinkListType{}
			}
			if err := m.CloudLinks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tgw", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tgw = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peers = append(m.Peers, &PeerType{})
			if err := m.Peers[len(m.Peers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TgwAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TgwAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAsn", wireType)
			}
			m.PeerAsn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerAsn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &cloud_re_region.NodeType{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideGreSubnet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideGreSubnet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudLinkListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudLinkListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudLinkListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudLink", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudLink = append(m.CloudLink, &views.ObjectRefType{})
			if err := m.CloudLink[len(m.CloudLink)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSVPCAttachmentListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSVPCAttachmentListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSVPCAttachmentListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcList = append(m.VpcList, &AWSVPCAttachmentType{})
			if err := m.VpcList[len(m.VpcList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSVPCAttachmentType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSVPCAttachmentType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSVPCAttachmentType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualRouting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RoutingChoice = &AWSVPCAttachmentType_ManualRouting{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultRoute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DefaultRoute{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RoutingChoice = &AWSVPCAttachmentType_DefaultRoute{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomRouting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSRouteTableListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RoutingChoice = &AWSVPCAttachmentType_CustomRouting{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefaultRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefaultRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefaultRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllRouteTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DefaultRouteChoice = &DefaultRoute_AllRouteTables{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectiveRouteTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSDefaultRoutesRouteTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DefaultRouteChoice = &DefaultRoute_SelectiveRouteTables{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSSubnetIDListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSSubnetIDListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSSubnetIDListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetIds = append(m.SubnetIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSRouteTableListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSRouteTableListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSRouteTableListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteTables = append(m.RouteTables, &AWSRouteTableType{})
			if err := m.RouteTables[len(m.RouteTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSDefaultRoutesRouteTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSDefaultRoutesRouteTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSDefaultRoutesRouteTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTableId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteTableId = append(m.RouteTableId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSRouteTableType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSRouteTableType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSRouteTableType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTableId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteTableId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 108:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticRoutes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaticRoutes = append(m.StaticRoutes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceAWSREType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceAWSREType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceAWSREType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcAttachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VpcAttachments == nil {
				m.VpcAttachments = &AWSVPCAttachmentListType{}
			}
			if err := m.VpcAttachments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSTGWSiteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSTGWSiteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSTGWSiteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Site == nil {
				m.Site = &views.ObjectRefType{}
			}
			if err := m.Site.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cred", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cred == nil {
				m.Cred = &views.ObjectRefType{}
			}
			if err := m.Cred.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcAttachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VpcAttachments == nil {
				m.VpcAttachments = &AWSVPCAttachmentListType{}
			}
			if err := m.VpcAttachments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceAWSTGWSiteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceAWSTGWSiteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceAWSTGWSiteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcAttachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VpcAttachments == nil {
				m.VpcAttachments = &AWSVPCAttachmentListType{}
			}
			if err := m.VpcAttachments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudConnectStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudConnectStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudConnectStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudConnectAwsSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSAttachmentsListStatusType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudConnectDeployment = &CloudConnectStatusType_CloudConnectAwsSite{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSAttachmentsListStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSAttachmentsListStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSAttachmentsListStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachmentStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttachmentStatus = append(m.AttachmentStatus, &AWSAttachmentsStatusType{})
			if err := m.AttachmentStatus[len(m.AttachmentStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSAttachmentsStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSAttachmentsStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSAttachmentsStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTime == nil {
				m.CreationTime = &types.Timestamp{}
			}
			if err := m.CreationTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TgwAttachmentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TgwAttachmentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcOwnerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcOwnerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstalledRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InstalledRoutes == nil {
				m.InstalledRoutes = &AWSRouteTableListType{}
			}
			if err := m.InstalledRoutes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnets = append(m.Subnets, &SubnetStatusType{})
			if err := m.Subnets[len(m.Subnets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkInterfaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkInterfaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateIpv4Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateIpv4Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilityZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailabilityZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsRe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSREType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &GlobalSpecType_AwsRe{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsTgwSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSTGWSiteType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &GlobalSpecType_AwsTgwSite{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bandwidth_500Mbs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BandwidthOption = &GlobalSpecType_Bandwidth_500Mbs{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sites = append(m.Sites, &schema.ObjectRefType{})
			if err := m.Sites[len(m.Sites)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Segment == nil {
				m.Segment = &views.ObjectRefType{}
			}
			if err := m.Segment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualNetwork = append(m.VirtualNetwork, &schema.ObjectRefType{})
			if err := m.VirtualNetwork[len(m.VirtualNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= CloudConnectState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsRe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSREType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &CreateSpecType_AwsRe{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsTgwSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSTGWSiteType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &CreateSpecType_AwsTgwSite{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Segment == nil {
				m.Segment = &views.ObjectRefType{}
			}
			if err := m.Segment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsRe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReplaceAWSREType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &ReplaceSpecType_AwsRe{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsTgwSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReplaceAWSTGWSiteType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &ReplaceSpecType_AwsTgwSite{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Segment == nil {
				m.Segment = &views.ObjectRefType{}
			}
			if err := m.Segment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsRe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSREType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &GetSpecType_AwsRe{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsTgwSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSTGWSiteType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &GetSpecType_AwsTgwSite{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Segment == nil {
				m.Segment = &views.ObjectRefType{}
			}
			if err := m.Segment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= CloudConnectState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
