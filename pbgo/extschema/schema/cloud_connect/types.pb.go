// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/cloud_connect/types.proto

package cloud_connect

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	cloud_re_region "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/cloud_re_region"
	site "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/site"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// CloudConnect State
//
// x-displayName: "CloudConnect State"
// State of the CloudConnect connections
type CloudConnectState int32

const (
	// Down
	//
	// x-displayName: "Down"
	// CloudConnect and their corresponding vpc attachments are down
	DOWN CloudConnectState = 0
	// Degraded
	//
	// x-displayName: "Degraded"
	// Some of vpc attachments with the CloudConnect are down
	DEGRADED CloudConnectState = 1
	// Up
	//
	// x-displayName: "Up"
	// CloudConnect and their corresponding vpc attachments are available and healthy
	UP CloudConnectState = 2
)

var CloudConnectState_name = map[int32]string{
	0: "DOWN",
	1: "DEGRADED",
	2: "UP",
}

var CloudConnectState_value = map[string]int32{
	"DOWN":     0,
	"DEGRADED": 1,
	"UP":       2,
}

func (CloudConnectState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{0}
}

// Cloud Connect VPC State
//
// x-displayName: "Cloud Connect VPC State"
// Cloud Connect VPC State Type
type CloudConnectVPCStateType int32

const (
	// Available
	//
	// x-displayName: "Available"
	// Cloud Connect vpc attachment is in available state.
	AVAILABLE CloudConnectVPCStateType = 0
	// Pending
	//
	// x-displayName: "Pending"
	// Cloud Connect vpc attachment is in flight.
	PENDING CloudConnectVPCStateType = 1
	// Failed
	//
	// x-displayName: "Failed"
	// Cloud Connect vpc attachment has failed.
	FAILED CloudConnectVPCStateType = 2
	// Deleted
	//
	// x-displayName: "Deleted"
	// Cloud Connect vpc attachment has been deleted.
	DELETED CloudConnectVPCStateType = 3
	// Deleting
	//
	// x-displayName: "Deleting"
	// Cloud Connect vpc attachment is being deleted.
	DELETING CloudConnectVPCStateType = 4
)

var CloudConnectVPCStateType_name = map[int32]string{
	0: "AVAILABLE",
	1: "PENDING",
	2: "FAILED",
	3: "DELETED",
	4: "DELETING",
}

var CloudConnectVPCStateType_value = map[string]int32{
	"AVAILABLE": 0,
	"PENDING":   1,
	"FAILED":    2,
	"DELETED":   3,
	"DELETING":  4,
}

func (CloudConnectVPCStateType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{1}
}

// Cloud Connect Provider
//
// x-displayName: "Cloud Connect Provider"
// Cloud Connect Provider Type
type CloudConnectProviderType int32

const (
	// AWS
	//
	// x-displayName: "AWS"
	// Cloud connects backed by AWS cloud
	AWS CloudConnectProviderType = 0
	// AZURE
	//
	// x-displayName: "AZURE"
	// Cloud connects backed by Azure cloud
	AZURE CloudConnectProviderType = 1
	// GCP
	//
	// x-displayName: "GCP"
	// Cloud connects backed by GCP cloud
	GCP CloudConnectProviderType = 2
)

var CloudConnectProviderType_name = map[int32]string{
	0: "AWS",
	1: "AZURE",
	2: "GCP",
}

var CloudConnectProviderType_value = map[string]int32{
	"AWS":   0,
	"AZURE": 1,
	"GCP":   2,
}

func (CloudConnectProviderType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{2}
}

// Label
//
// x-displayName: "Label"
// Metrics used to construct the cloud connect dara are tagged with these labels and therefore
// the metrics can be sliced and diced based on one or more labels.
type Label int32

const (
	// x-displayName: "None"
	// Indicates the field not being set
	LABEL_NONE Label = 0
	// x-displayName: "Site"
	// Identifies a customer edge
	LABEL_CUSTOMER_EDGE Label = 1
	// x-displayName: "Cloud Connect"
	// Identifies a cloud connect
	LABEL_CLOUD_CONNECT Label = 2
)

var Label_name = map[int32]string{
	0: "LABEL_NONE",
	1: "LABEL_CUSTOMER_EDGE",
	2: "LABEL_CLOUD_CONNECT",
}

var Label_value = map[string]int32{
	"LABEL_NONE":          0,
	"LABEL_CUSTOMER_EDGE": 1,
	"LABEL_CLOUD_CONNECT": 2,
}

func (Label) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{3}
}

// Traffic Type
//
// x-displayName: "Traffic Type"
// TrafficType specifies the type of traffic.
type TrafficType int32

const (
	// x-displayName: "None"
	TRAFFIC_TYPE_NONE TrafficType = 0
	// x-displayName: "Intersegment"
	// Intersegment traffic
	TRAFFIC_TYPE_INTER_SEGMENT TrafficType = 1
	// x-displayName: "Intrasegment"
	// Intrasegment traffic
	TRAFFIC_TYPE_INTRA_SEGMENT TrafficType = 2
	// x-displayName: "Internet"
	// Internet traffic
	TRAFFIC_TYPE_INTERNET TrafficType = 3
)

var TrafficType_name = map[int32]string{
	0: "TRAFFIC_TYPE_NONE",
	1: "TRAFFIC_TYPE_INTER_SEGMENT",
	2: "TRAFFIC_TYPE_INTRA_SEGMENT",
	3: "TRAFFIC_TYPE_INTERNET",
}

var TrafficType_value = map[string]int32{
	"TRAFFIC_TYPE_NONE":          0,
	"TRAFFIC_TYPE_INTER_SEGMENT": 1,
	"TRAFFIC_TYPE_INTRA_SEGMENT": 2,
	"TRAFFIC_TYPE_INTERNET":      3,
}

func (TrafficType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{4}
}

// Cloud Connect Metric Type
//
// x-displayName: "Cloud Connect Metric Type"
// FieldSelector specifies the metrics that can be queried for cloud connect.
type FieldSelector int32

const (
	// x-displayName: "None"
	// Indicates field not being set
	METRIC_TYPE_NONE FieldSelector = 0
	// x-displayName: "Incoming bytes per second"
	// x-unit: "bytes per second (bps)"
	// Throughput of incoming traffic
	METRIC_TYPE_IN_BYTES FieldSelector = 1
	// x-displayName: "Outgoing bytes per second"
	// x-unit: "bytes per second (bps)"
	// Throughput of outgoing traffic
	METRIC_TYPE_OUT_BYTES FieldSelector = 2
	// x-displayName: "Total bytes per second"
	// x-unit: "bytes per second (bps)"
	// Throughput of outgoing traffic
	METRIC_TYPE_TOTAL_BYTES FieldSelector = 3
)

var FieldSelector_name = map[int32]string{
	0: "METRIC_TYPE_NONE",
	1: "METRIC_TYPE_IN_BYTES",
	2: "METRIC_TYPE_OUT_BYTES",
	3: "METRIC_TYPE_TOTAL_BYTES",
}

var FieldSelector_value = map[string]int32{
	"METRIC_TYPE_NONE":        0,
	"METRIC_TYPE_IN_BYTES":    1,
	"METRIC_TYPE_OUT_BYTES":   2,
	"METRIC_TYPE_TOTAL_BYTES": 3,
}

func (FieldSelector) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{5}
}

// Cloud Connect AWS Type
//
// x-displayName: "AWS"
type AWSREType struct {
	// Region
	//
	// x-displayName: "Cloud Edge"
	// x-required
	Region *views.ObjectRefType `protobuf:"bytes,1,opt,name=region,proto3" json:"region,omitempty"`
	// Cloud Credential
	//
	// x-displayName: "Credential"
	// Select a cloud credential to begin onboarding VPCs
	// x-required
	Cred *views.ObjectRefType `protobuf:"bytes,2,opt,name=cred,proto3" json:"cred,omitempty"`
	// VPC Attachement List
	//
	// x-displayName: "VPC Attachement List"
	VpcAttachments *AWSVPCAttachmentListType `protobuf:"bytes,3,opt,name=vpc_attachments,json=vpcAttachments,proto3" json:"vpc_attachments,omitempty"`
	// Cloud Links
	//
	// x-displayName: "CloudLink"
	// Reference to cloud link
	CloudLinks *CloudLinkListType `protobuf:"bytes,4,opt,name=cloud_links,json=cloudLinks,proto3" json:"cloud_links,omitempty"`
	// TGW Name
	//
	// x-displayName: "TGW Name"
	Tgw string `protobuf:"bytes,5,opt,name=tgw,proto3" json:"tgw,omitempty"`
	// Peers
	//
	// x-displayName: "Peers"
	// Peers
	Peers []*PeerType `protobuf:"bytes,9,rep,name=peers,proto3" json:"peers,omitempty"`
}

func (m *AWSREType) Reset()      { *m = AWSREType{} }
func (*AWSREType) ProtoMessage() {}
func (*AWSREType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{0}
}
func (m *AWSREType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSREType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSREType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSREType.Merge(m, src)
}
func (m *AWSREType) XXX_Size() int {
	return m.Size()
}
func (m *AWSREType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSREType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSREType proto.InternalMessageInfo

func (m *AWSREType) GetRegion() *views.ObjectRefType {
	if m != nil {
		return m.Region
	}
	return nil
}

func (m *AWSREType) GetCred() *views.ObjectRefType {
	if m != nil {
		return m.Cred
	}
	return nil
}

func (m *AWSREType) GetVpcAttachments() *AWSVPCAttachmentListType {
	if m != nil {
		return m.VpcAttachments
	}
	return nil
}

func (m *AWSREType) GetCloudLinks() *CloudLinkListType {
	if m != nil {
		return m.CloudLinks
	}
	return nil
}

func (m *AWSREType) GetTgw() string {
	if m != nil {
		return m.Tgw
	}
	return ""
}

func (m *AWSREType) GetPeers() []*PeerType {
	if m != nil {
		return m.Peers
	}
	return nil
}

// Cloud Links
//
// x-displayName: "Cloud Links"
// List of Cloud Link references to be attached
type PeerType struct {
	// TGW Address
	//
	// x-displayName: "TGW Address"
	TgwAddress string `protobuf:"bytes,1,opt,name=tgw_address,json=tgwAddress,proto3" json:"tgw_address,omitempty"`
	// Peer ASN
	//
	// x-displayName: "Peer ASN"
	PeerAsn int64 `protobuf:"varint,2,opt,name=peer_asn,json=peerAsn,proto3" json:"peer_asn,omitempty"`
	// Node
	//
	// x-displayName: "Node"
	Node *cloud_re_region.NodeType `protobuf:"bytes,3,opt,name=node,proto3" json:"node,omitempty"`
	// Inside GRE Subnet
	//
	// x-displayName: "Inside GRE Subnet"
	InsideGreSubnet string `protobuf:"bytes,4,opt,name=inside_gre_subnet,json=insideGreSubnet,proto3" json:"inside_gre_subnet,omitempty"`
}

func (m *PeerType) Reset()      { *m = PeerType{} }
func (*PeerType) ProtoMessage() {}
func (*PeerType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{1}
}
func (m *PeerType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PeerType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerType.Merge(m, src)
}
func (m *PeerType) XXX_Size() int {
	return m.Size()
}
func (m *PeerType) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerType.DiscardUnknown(m)
}

var xxx_messageInfo_PeerType proto.InternalMessageInfo

func (m *PeerType) GetTgwAddress() string {
	if m != nil {
		return m.TgwAddress
	}
	return ""
}

func (m *PeerType) GetPeerAsn() int64 {
	if m != nil {
		return m.PeerAsn
	}
	return 0
}

func (m *PeerType) GetNode() *cloud_re_region.NodeType {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *PeerType) GetInsideGreSubnet() string {
	if m != nil {
		return m.InsideGreSubnet
	}
	return ""
}

// CloudLinks
//
// x-displayName: "CloudLink"
// List of CloudLink references to be attached
type CloudLinkListType struct {
	// CloudLink
	//
	// x-displayName: "CloudLink"
	// Attach a CloudLink to this Cloud Connect
	CloudLink []*views.ObjectRefType `protobuf:"bytes,1,rep,name=cloud_link,json=cloudLink,proto3" json:"cloud_link,omitempty"`
}

func (m *CloudLinkListType) Reset()      { *m = CloudLinkListType{} }
func (*CloudLinkListType) ProtoMessage() {}
func (*CloudLinkListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{2}
}
func (m *CloudLinkListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudLinkListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CloudLinkListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudLinkListType.Merge(m, src)
}
func (m *CloudLinkListType) XXX_Size() int {
	return m.Size()
}
func (m *CloudLinkListType) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudLinkListType.DiscardUnknown(m)
}

var xxx_messageInfo_CloudLinkListType proto.InternalMessageInfo

func (m *CloudLinkListType) GetCloudLink() []*views.ObjectRefType {
	if m != nil {
		return m.CloudLink
	}
	return nil
}

// VPC Attachments
//
// x-displayName: "VPC Attachments"
type AWSVPCAttachmentListType struct {
	// vpc_list
	//
	// x-displayName: "VPC List"
	VpcList []*AWSVPCAttachmentType `protobuf:"bytes,1,rep,name=vpc_list,json=vpcList,proto3" json:"vpc_list,omitempty"`
}

func (m *AWSVPCAttachmentListType) Reset()      { *m = AWSVPCAttachmentListType{} }
func (*AWSVPCAttachmentListType) ProtoMessage() {}
func (*AWSVPCAttachmentListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{3}
}
func (m *AWSVPCAttachmentListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSVPCAttachmentListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSVPCAttachmentListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSVPCAttachmentListType.Merge(m, src)
}
func (m *AWSVPCAttachmentListType) XXX_Size() int {
	return m.Size()
}
func (m *AWSVPCAttachmentListType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSVPCAttachmentListType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSVPCAttachmentListType proto.InternalMessageInfo

func (m *AWSVPCAttachmentListType) GetVpcList() []*AWSVPCAttachmentType {
	if m != nil {
		return m.VpcList
	}
	return nil
}

// AWS VPC attachment
//
// x-displayName: "VPC Attachment"
type AWSVPCAttachmentType struct {
	// VPC ID
	//
	// x-displayName: "VPC ID"
	// x-example: "vpc-12345678901234567"
	// x-required
	// Enter the VPC ID of the VPC to be attached
	VpcId string `protobuf:"bytes,1,opt,name=vpc_id,json=vpcId,proto3" json:"vpc_id,omitempty"`
	// Routing Choice
	//
	// x-displayName: "Routing Choice"
	// x-required
	// Select which traffic should be routed towards the CE
	//
	// Types that are valid to be assigned to RoutingChoice:
	//	*AWSVPCAttachmentType_ManualRouting
	//	*AWSVPCAttachmentType_DefaultRoute
	//	*AWSVPCAttachmentType_CustomRouting
	RoutingChoice isAWSVPCAttachmentType_RoutingChoice `protobuf_oneof:"routing_choice"`
	// Labels
	//
	// x-displayName: "Labels"
	// x-example: "value"
	// Add labels for the VPC attachment. These labels can then be used in policies such as enhanced firewall.
	Labels map[string]string `protobuf:"bytes,11,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *AWSVPCAttachmentType) Reset()      { *m = AWSVPCAttachmentType{} }
func (*AWSVPCAttachmentType) ProtoMessage() {}
func (*AWSVPCAttachmentType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{4}
}
func (m *AWSVPCAttachmentType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSVPCAttachmentType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSVPCAttachmentType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSVPCAttachmentType.Merge(m, src)
}
func (m *AWSVPCAttachmentType) XXX_Size() int {
	return m.Size()
}
func (m *AWSVPCAttachmentType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSVPCAttachmentType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSVPCAttachmentType proto.InternalMessageInfo

type isAWSVPCAttachmentType_RoutingChoice interface {
	isAWSVPCAttachmentType_RoutingChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AWSVPCAttachmentType_ManualRouting struct {
	ManualRouting *schema.Empty `protobuf:"bytes,6,opt,name=manual_routing,json=manualRouting,proto3,oneof" json:"manual_routing,omitempty"`
}
type AWSVPCAttachmentType_DefaultRoute struct {
	DefaultRoute *DefaultRoute `protobuf:"bytes,9,opt,name=default_route,json=defaultRoute,proto3,oneof" json:"default_route,omitempty"`
}
type AWSVPCAttachmentType_CustomRouting struct {
	CustomRouting *AWSRouteTableListType `protobuf:"bytes,10,opt,name=custom_routing,json=customRouting,proto3,oneof" json:"custom_routing,omitempty"`
}

func (*AWSVPCAttachmentType_ManualRouting) isAWSVPCAttachmentType_RoutingChoice() {}
func (*AWSVPCAttachmentType_DefaultRoute) isAWSVPCAttachmentType_RoutingChoice()  {}
func (*AWSVPCAttachmentType_CustomRouting) isAWSVPCAttachmentType_RoutingChoice() {}

func (m *AWSVPCAttachmentType) GetRoutingChoice() isAWSVPCAttachmentType_RoutingChoice {
	if m != nil {
		return m.RoutingChoice
	}
	return nil
}

func (m *AWSVPCAttachmentType) GetVpcId() string {
	if m != nil {
		return m.VpcId
	}
	return ""
}

func (m *AWSVPCAttachmentType) GetManualRouting() *schema.Empty {
	if x, ok := m.GetRoutingChoice().(*AWSVPCAttachmentType_ManualRouting); ok {
		return x.ManualRouting
	}
	return nil
}

func (m *AWSVPCAttachmentType) GetDefaultRoute() *DefaultRoute {
	if x, ok := m.GetRoutingChoice().(*AWSVPCAttachmentType_DefaultRoute); ok {
		return x.DefaultRoute
	}
	return nil
}

func (m *AWSVPCAttachmentType) GetCustomRouting() *AWSRouteTableListType {
	if x, ok := m.GetRoutingChoice().(*AWSVPCAttachmentType_CustomRouting); ok {
		return x.CustomRouting
	}
	return nil
}

func (m *AWSVPCAttachmentType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AWSVPCAttachmentType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AWSVPCAttachmentType_ManualRouting)(nil),
		(*AWSVPCAttachmentType_DefaultRoute)(nil),
		(*AWSVPCAttachmentType_CustomRouting)(nil),
	}
}

// VNET Attachments
//
// x-displayName: "VNET Attachments"
type AzureVnetAttachmentListType struct {
	// vnet_list
	//
	// x-displayName: "VNET List"
	VnetList []*AzureVNETAttachmentType `protobuf:"bytes,1,rep,name=vnet_list,json=vnetList,proto3" json:"vnet_list,omitempty"`
}

func (m *AzureVnetAttachmentListType) Reset()      { *m = AzureVnetAttachmentListType{} }
func (*AzureVnetAttachmentListType) ProtoMessage() {}
func (*AzureVnetAttachmentListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{5}
}
func (m *AzureVnetAttachmentListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureVnetAttachmentListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureVnetAttachmentListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureVnetAttachmentListType.Merge(m, src)
}
func (m *AzureVnetAttachmentListType) XXX_Size() int {
	return m.Size()
}
func (m *AzureVnetAttachmentListType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureVnetAttachmentListType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureVnetAttachmentListType proto.InternalMessageInfo

func (m *AzureVnetAttachmentListType) GetVnetList() []*AzureVNETAttachmentType {
	if m != nil {
		return m.VnetList
	}
	return nil
}

// Azure VNET attachment
//
// x-displayName: "Azure VNET Attachment"
type AzureVNETAttachmentType struct {
	// Subscription ID
	//
	// x-displayName: "Subscription ID"
	// x-required
	// Enter the Subscription ID of the VNET to be attached
	SubscriptionId string `protobuf:"bytes,1,opt,name=subscription_id,json=subscriptionId,proto3" json:"subscription_id,omitempty"`
	// VNET ID
	//
	// x-displayName: "VNET ID"
	// x-required
	// Enter the vnet ID of the VNET to be attached in format /<resource-group-name>/<vnet-name>
	VnetId string `protobuf:"bytes,2,opt,name=vnet_id,json=vnetId,proto3" json:"vnet_id,omitempty"`
	// Routing Choice
	//
	// x-displayName: "Routing Choice"
	// x-required
	// Select which traffic should be routed towards the CE
	//
	// Types that are valid to be assigned to RoutingChoice:
	//	*AzureVNETAttachmentType_ManualRouting
	//	*AzureVNETAttachmentType_DefaultRoute
	//	*AzureVNETAttachmentType_CustomRouting
	RoutingChoice isAzureVNETAttachmentType_RoutingChoice `protobuf_oneof:"routing_choice"`
}

func (m *AzureVNETAttachmentType) Reset()      { *m = AzureVNETAttachmentType{} }
func (*AzureVNETAttachmentType) ProtoMessage() {}
func (*AzureVNETAttachmentType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{6}
}
func (m *AzureVNETAttachmentType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureVNETAttachmentType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureVNETAttachmentType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureVNETAttachmentType.Merge(m, src)
}
func (m *AzureVNETAttachmentType) XXX_Size() int {
	return m.Size()
}
func (m *AzureVNETAttachmentType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureVNETAttachmentType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureVNETAttachmentType proto.InternalMessageInfo

type isAzureVNETAttachmentType_RoutingChoice interface {
	isAzureVNETAttachmentType_RoutingChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AzureVNETAttachmentType_ManualRouting struct {
	ManualRouting *schema.Empty `protobuf:"bytes,4,opt,name=manual_routing,json=manualRouting,proto3,oneof" json:"manual_routing,omitempty"`
}
type AzureVNETAttachmentType_DefaultRoute struct {
	DefaultRoute *AzureDefaultRoute `protobuf:"bytes,9,opt,name=default_route,json=defaultRoute,proto3,oneof" json:"default_route,omitempty"`
}
type AzureVNETAttachmentType_CustomRouting struct {
	CustomRouting *AzureRouteTableWithStaticRouteListType `protobuf:"bytes,6,opt,name=custom_routing,json=customRouting,proto3,oneof" json:"custom_routing,omitempty"`
}

func (*AzureVNETAttachmentType_ManualRouting) isAzureVNETAttachmentType_RoutingChoice() {}
func (*AzureVNETAttachmentType_DefaultRoute) isAzureVNETAttachmentType_RoutingChoice()  {}
func (*AzureVNETAttachmentType_CustomRouting) isAzureVNETAttachmentType_RoutingChoice() {}

func (m *AzureVNETAttachmentType) GetRoutingChoice() isAzureVNETAttachmentType_RoutingChoice {
	if m != nil {
		return m.RoutingChoice
	}
	return nil
}

func (m *AzureVNETAttachmentType) GetSubscriptionId() string {
	if m != nil {
		return m.SubscriptionId
	}
	return ""
}

func (m *AzureVNETAttachmentType) GetVnetId() string {
	if m != nil {
		return m.VnetId
	}
	return ""
}

func (m *AzureVNETAttachmentType) GetManualRouting() *schema.Empty {
	if x, ok := m.GetRoutingChoice().(*AzureVNETAttachmentType_ManualRouting); ok {
		return x.ManualRouting
	}
	return nil
}

func (m *AzureVNETAttachmentType) GetDefaultRoute() *AzureDefaultRoute {
	if x, ok := m.GetRoutingChoice().(*AzureVNETAttachmentType_DefaultRoute); ok {
		return x.DefaultRoute
	}
	return nil
}

func (m *AzureVNETAttachmentType) GetCustomRouting() *AzureRouteTableWithStaticRouteListType {
	if x, ok := m.GetRoutingChoice().(*AzureVNETAttachmentType_CustomRouting); ok {
		return x.CustomRouting
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AzureVNETAttachmentType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AzureVNETAttachmentType_ManualRouting)(nil),
		(*AzureVNETAttachmentType_DefaultRoute)(nil),
		(*AzureVNETAttachmentType_CustomRouting)(nil),
	}
}

// Default Route Override Choice
//
// x-displayName: "Override Default Route Choice"
// Select Override Default Route Choice
type AzureDefaultRoute struct {
	// Default Route Override Choice
	//
	// x-displayName: "Override Default Route Choice"
	// Select Override Default Route Choice
	//
	// Types that are valid to be assigned to DefaultRouteChoice:
	//	*AzureDefaultRoute_AllRouteTables
	//	*AzureDefaultRoute_SelectiveRouteTables
	DefaultRouteChoice isAzureDefaultRoute_DefaultRouteChoice `protobuf_oneof:"default_route_choice"`
}

func (m *AzureDefaultRoute) Reset()      { *m = AzureDefaultRoute{} }
func (*AzureDefaultRoute) ProtoMessage() {}
func (*AzureDefaultRoute) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{7}
}
func (m *AzureDefaultRoute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureDefaultRoute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureDefaultRoute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureDefaultRoute.Merge(m, src)
}
func (m *AzureDefaultRoute) XXX_Size() int {
	return m.Size()
}
func (m *AzureDefaultRoute) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureDefaultRoute.DiscardUnknown(m)
}

var xxx_messageInfo_AzureDefaultRoute proto.InternalMessageInfo

type isAzureDefaultRoute_DefaultRouteChoice interface {
	isAzureDefaultRoute_DefaultRouteChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AzureDefaultRoute_AllRouteTables struct {
	AllRouteTables *schema.Empty `protobuf:"bytes,1,opt,name=all_route_tables,json=allRouteTables,proto3,oneof" json:"all_route_tables,omitempty"`
}
type AzureDefaultRoute_SelectiveRouteTables struct {
	SelectiveRouteTables *AzureRouteTables `protobuf:"bytes,4,opt,name=selective_route_tables,json=selectiveRouteTables,proto3,oneof" json:"selective_route_tables,omitempty"`
}

func (*AzureDefaultRoute_AllRouteTables) isAzureDefaultRoute_DefaultRouteChoice()       {}
func (*AzureDefaultRoute_SelectiveRouteTables) isAzureDefaultRoute_DefaultRouteChoice() {}

func (m *AzureDefaultRoute) GetDefaultRouteChoice() isAzureDefaultRoute_DefaultRouteChoice {
	if m != nil {
		return m.DefaultRouteChoice
	}
	return nil
}

func (m *AzureDefaultRoute) GetAllRouteTables() *schema.Empty {
	if x, ok := m.GetDefaultRouteChoice().(*AzureDefaultRoute_AllRouteTables); ok {
		return x.AllRouteTables
	}
	return nil
}

func (m *AzureDefaultRoute) GetSelectiveRouteTables() *AzureRouteTables {
	if x, ok := m.GetDefaultRouteChoice().(*AzureDefaultRoute_SelectiveRouteTables); ok {
		return x.SelectiveRouteTables
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AzureDefaultRoute) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AzureDefaultRoute_AllRouteTables)(nil),
		(*AzureDefaultRoute_SelectiveRouteTables)(nil),
	}
}

// Default Route Override Choice
//
// x-displayName: "Override Default Route Choice"
// Select Override Default Route Choice
type DefaultRoute struct {
	// Default Route Override Choice
	//
	// x-displayName: "Override Default Route Choice"
	// Select Override Default Route Choice
	//
	// Types that are valid to be assigned to DefaultRouteChoice:
	//	*DefaultRoute_AllRouteTables
	//	*DefaultRoute_SelectiveRouteTables
	DefaultRouteChoice isDefaultRoute_DefaultRouteChoice `protobuf_oneof:"default_route_choice"`
}

func (m *DefaultRoute) Reset()      { *m = DefaultRoute{} }
func (*DefaultRoute) ProtoMessage() {}
func (*DefaultRoute) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{8}
}
func (m *DefaultRoute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DefaultRoute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DefaultRoute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DefaultRoute.Merge(m, src)
}
func (m *DefaultRoute) XXX_Size() int {
	return m.Size()
}
func (m *DefaultRoute) XXX_DiscardUnknown() {
	xxx_messageInfo_DefaultRoute.DiscardUnknown(m)
}

var xxx_messageInfo_DefaultRoute proto.InternalMessageInfo

type isDefaultRoute_DefaultRouteChoice interface {
	isDefaultRoute_DefaultRouteChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DefaultRoute_AllRouteTables struct {
	AllRouteTables *schema.Empty `protobuf:"bytes,1,opt,name=all_route_tables,json=allRouteTables,proto3,oneof" json:"all_route_tables,omitempty"`
}
type DefaultRoute_SelectiveRouteTables struct {
	SelectiveRouteTables *AWSDefaultRoutesRouteTable `protobuf:"bytes,4,opt,name=selective_route_tables,json=selectiveRouteTables,proto3,oneof" json:"selective_route_tables,omitempty"`
}

func (*DefaultRoute_AllRouteTables) isDefaultRoute_DefaultRouteChoice()       {}
func (*DefaultRoute_SelectiveRouteTables) isDefaultRoute_DefaultRouteChoice() {}

func (m *DefaultRoute) GetDefaultRouteChoice() isDefaultRoute_DefaultRouteChoice {
	if m != nil {
		return m.DefaultRouteChoice
	}
	return nil
}

func (m *DefaultRoute) GetAllRouteTables() *schema.Empty {
	if x, ok := m.GetDefaultRouteChoice().(*DefaultRoute_AllRouteTables); ok {
		return x.AllRouteTables
	}
	return nil
}

func (m *DefaultRoute) GetSelectiveRouteTables() *AWSDefaultRoutesRouteTable {
	if x, ok := m.GetDefaultRouteChoice().(*DefaultRoute_SelectiveRouteTables); ok {
		return x.SelectiveRouteTables
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DefaultRoute) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DefaultRoute_AllRouteTables)(nil),
		(*DefaultRoute_SelectiveRouteTables)(nil),
	}
}

// AWS Subnet IDs
//
// x-displayName: "AWS Subnet IDs"
// AWS Subnet IDs
type AWSSubnetIDListType struct {
	// List of subnet IDs
	//
	// x-displayName: "List of subnet IDs"
	// x-required
	// x-example: "subnet-12345678901234567"
	// List of subnet IDs
	SubnetIds []string `protobuf:"bytes,1,rep,name=subnet_ids,json=subnetIds,proto3" json:"subnet_ids,omitempty"`
}

func (m *AWSSubnetIDListType) Reset()      { *m = AWSSubnetIDListType{} }
func (*AWSSubnetIDListType) ProtoMessage() {}
func (*AWSSubnetIDListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{9}
}
func (m *AWSSubnetIDListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSSubnetIDListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSSubnetIDListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSSubnetIDListType.Merge(m, src)
}
func (m *AWSSubnetIDListType) XXX_Size() int {
	return m.Size()
}
func (m *AWSSubnetIDListType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSSubnetIDListType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSSubnetIDListType proto.InternalMessageInfo

func (m *AWSSubnetIDListType) GetSubnetIds() []string {
	if m != nil {
		return m.SubnetIds
	}
	return nil
}

// AWS Route Table List
//
// x-displayName: "AWS Route Table List"
// AWS Route Table List
type AWSRouteTableListType struct {
	// List of route tables
	//
	// x-required
	// x-displayName: "List of route tables"
	// Route Tables
	RouteTables []*AWSRouteTableType `protobuf:"bytes,1,rep,name=route_tables,json=routeTables,proto3" json:"route_tables,omitempty"`
}

func (m *AWSRouteTableListType) Reset()      { *m = AWSRouteTableListType{} }
func (*AWSRouteTableListType) ProtoMessage() {}
func (*AWSRouteTableListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{10}
}
func (m *AWSRouteTableListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSRouteTableListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSRouteTableListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSRouteTableListType.Merge(m, src)
}
func (m *AWSRouteTableListType) XXX_Size() int {
	return m.Size()
}
func (m *AWSRouteTableListType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSRouteTableListType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSRouteTableListType proto.InternalMessageInfo

func (m *AWSRouteTableListType) GetRouteTables() []*AWSRouteTableType {
	if m != nil {
		return m.RouteTables
	}
	return nil
}

// AWS Route Table
//
// x-displayName: "AWS Route Table"
// AWS Route Table
type AWSDefaultRoutesRouteTable struct {
	// Route table ID
	//
	// x-displayName: "Route table ID"
	// x-example: "rtb-12345678901234567"
	// Route table ID
	RouteTableId []string `protobuf:"bytes,1,rep,name=route_table_id,json=routeTableId,proto3" json:"route_table_id,omitempty"`
}

func (m *AWSDefaultRoutesRouteTable) Reset()      { *m = AWSDefaultRoutesRouteTable{} }
func (*AWSDefaultRoutesRouteTable) ProtoMessage() {}
func (*AWSDefaultRoutesRouteTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{11}
}
func (m *AWSDefaultRoutesRouteTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSDefaultRoutesRouteTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSDefaultRoutesRouteTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSDefaultRoutesRouteTable.Merge(m, src)
}
func (m *AWSDefaultRoutesRouteTable) XXX_Size() int {
	return m.Size()
}
func (m *AWSDefaultRoutesRouteTable) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSDefaultRoutesRouteTable.DiscardUnknown(m)
}

var xxx_messageInfo_AWSDefaultRoutesRouteTable proto.InternalMessageInfo

func (m *AWSDefaultRoutesRouteTable) GetRouteTableId() []string {
	if m != nil {
		return m.RouteTableId
	}
	return nil
}

// Azure Route Table
//
// x-displayName: "Azure Route Table"
// Azure Route Table
type AzureRouteTables struct {
	// Route table ID
	//
	// x-displayName: "Route table ID"
	// x-example: "/rg-1/rtb-12345678901234567"
	// Route table ID in the format /<resource-group-name>/<route-name>
	RouteTableId []string `protobuf:"bytes,1,rep,name=route_table_id,json=routeTableId,proto3" json:"route_table_id,omitempty"`
}

func (m *AzureRouteTables) Reset()      { *m = AzureRouteTables{} }
func (*AzureRouteTables) ProtoMessage() {}
func (*AzureRouteTables) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{12}
}
func (m *AzureRouteTables) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureRouteTables) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureRouteTables) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureRouteTables.Merge(m, src)
}
func (m *AzureRouteTables) XXX_Size() int {
	return m.Size()
}
func (m *AzureRouteTables) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureRouteTables.DiscardUnknown(m)
}

var xxx_messageInfo_AzureRouteTables proto.InternalMessageInfo

func (m *AzureRouteTables) GetRouteTableId() []string {
	if m != nil {
		return m.RouteTableId
	}
	return nil
}

// List Azure Route Table with Static Route
//
// x-displayName: "List Azure Route Table with Static Route"
// List Azure Route Table with Static Route
type AzureRouteTableWithStaticRouteListType struct {
	// List of route tables with static routes
	//
	// x-required
	// x-displayName: "List of route tables with static routes"
	// Route Tables with static routes
	RouteTables []*AzureRouteTableWithStaticRoute `protobuf:"bytes,1,rep,name=route_tables,json=routeTables,proto3" json:"route_tables,omitempty"`
}

func (m *AzureRouteTableWithStaticRouteListType) Reset() {
	*m = AzureRouteTableWithStaticRouteListType{}
}
func (*AzureRouteTableWithStaticRouteListType) ProtoMessage() {}
func (*AzureRouteTableWithStaticRouteListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{13}
}
func (m *AzureRouteTableWithStaticRouteListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureRouteTableWithStaticRouteListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureRouteTableWithStaticRouteListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureRouteTableWithStaticRouteListType.Merge(m, src)
}
func (m *AzureRouteTableWithStaticRouteListType) XXX_Size() int {
	return m.Size()
}
func (m *AzureRouteTableWithStaticRouteListType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureRouteTableWithStaticRouteListType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureRouteTableWithStaticRouteListType proto.InternalMessageInfo

func (m *AzureRouteTableWithStaticRouteListType) GetRouteTables() []*AzureRouteTableWithStaticRoute {
	if m != nil {
		return m.RouteTables
	}
	return nil
}

// Azure Route Table
//
// x-displayName: "Azure Route Table with Static Route"
// Azure Route Table with Static Route
type AzureRouteTableWithStaticRoute struct {
	// Route table ID
	//
	// x-displayName: "Route table ID"
	// x-example: "/rg-1/rtb-12345678901234567"
	// Route table ID in the format /<resource-group-name>/<route-name>
	RouteTableId string `protobuf:"bytes,1,opt,name=route_table_id,json=routeTableId,proto3" json:"route_table_id,omitempty"`
	// static_routes
	//
	// x-displayName: "Static Routes"
	// x-example: "10.1.1.0/24"
	// x-required
	// List of Static Routes
	StaticRoutes []string `protobuf:"bytes,108,rep,name=static_routes,json=staticRoutes,proto3" json:"static_routes,omitempty"`
}

func (m *AzureRouteTableWithStaticRoute) Reset()      { *m = AzureRouteTableWithStaticRoute{} }
func (*AzureRouteTableWithStaticRoute) ProtoMessage() {}
func (*AzureRouteTableWithStaticRoute) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{14}
}
func (m *AzureRouteTableWithStaticRoute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureRouteTableWithStaticRoute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureRouteTableWithStaticRoute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureRouteTableWithStaticRoute.Merge(m, src)
}
func (m *AzureRouteTableWithStaticRoute) XXX_Size() int {
	return m.Size()
}
func (m *AzureRouteTableWithStaticRoute) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureRouteTableWithStaticRoute.DiscardUnknown(m)
}

var xxx_messageInfo_AzureRouteTableWithStaticRoute proto.InternalMessageInfo

func (m *AzureRouteTableWithStaticRoute) GetRouteTableId() string {
	if m != nil {
		return m.RouteTableId
	}
	return ""
}

func (m *AzureRouteTableWithStaticRoute) GetStaticRoutes() []string {
	if m != nil {
		return m.StaticRoutes
	}
	return nil
}

// AWS Route Table
//
// x-displayName: "AWS Route Table"
// AWS Route Table
type AWSRouteTableType struct {
	// Route table ID
	//
	// x-displayName: "Route table ID"
	// x-example: "rtb-12345678901234567"
	// Route table ID
	RouteTableId string `protobuf:"bytes,1,opt,name=route_table_id,json=routeTableId,proto3" json:"route_table_id,omitempty"`
	// static_routes
	//
	// x-displayName: "Static Routes"
	// x-example: "10.1.1.0/24"
	// x-required
	// List of Static Routes
	StaticRoutes []string `protobuf:"bytes,108,rep,name=static_routes,json=staticRoutes,proto3" json:"static_routes,omitempty"`
}

func (m *AWSRouteTableType) Reset()      { *m = AWSRouteTableType{} }
func (*AWSRouteTableType) ProtoMessage() {}
func (*AWSRouteTableType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{15}
}
func (m *AWSRouteTableType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSRouteTableType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSRouteTableType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSRouteTableType.Merge(m, src)
}
func (m *AWSRouteTableType) XXX_Size() int {
	return m.Size()
}
func (m *AWSRouteTableType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSRouteTableType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSRouteTableType proto.InternalMessageInfo

func (m *AWSRouteTableType) GetRouteTableId() string {
	if m != nil {
		return m.RouteTableId
	}
	return ""
}

func (m *AWSRouteTableType) GetStaticRoutes() []string {
	if m != nil {
		return m.StaticRoutes
	}
	return nil
}

// Cloud Connect ReplaceAWSREType Type
//
// x-displayName: "AWS RE Type"
// Cloud Connect AWS RE Type
type ReplaceAWSREType struct {
	// VPC Attachments
	//
	// x-displayName: "VPC Attachments"
	VpcAttachments *AWSVPCAttachmentListType `protobuf:"bytes,3,opt,name=vpc_attachments,json=vpcAttachments,proto3" json:"vpc_attachments,omitempty"`
}

func (m *ReplaceAWSREType) Reset()      { *m = ReplaceAWSREType{} }
func (*ReplaceAWSREType) ProtoMessage() {}
func (*ReplaceAWSREType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{16}
}
func (m *ReplaceAWSREType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceAWSREType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceAWSREType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceAWSREType.Merge(m, src)
}
func (m *ReplaceAWSREType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceAWSREType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceAWSREType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceAWSREType proto.InternalMessageInfo

func (m *ReplaceAWSREType) GetVpcAttachments() *AWSVPCAttachmentListType {
	if m != nil {
		return m.VpcAttachments
	}
	return nil
}

// Cloud Connect AWS TGW Site Type
//
// x-displayName: "AWS TGW Site Type"
// Cloud Connect AWS TGW Site Type
type AWSTGWSiteType struct {
	// AWS TGW Site Reference
	//
	// x-displayName: "AWS TGW Site Reference"
	// AWS TGW Site Reference
	// x-required
	Site *views.ObjectRefType `protobuf:"bytes,1,opt,name=site,proto3" json:"site,omitempty"`
	// Cloud Credential
	//
	// x-displayName: "Credential Reference"
	// Reference to cloud credential to deploy resources
	// x-required
	Cred *views.ObjectRefType `protobuf:"bytes,2,opt,name=cred,proto3" json:"cred,omitempty"`
	// Spoke VPCs
	//
	// x-displayName: "Spoke VPCs"
	// Spoke VPCs to be attached to the AWS TGW Site
	// x-required
	VpcAttachments *AWSVPCAttachmentListType `protobuf:"bytes,3,opt,name=vpc_attachments,json=vpcAttachments,proto3" json:"vpc_attachments,omitempty"`
}

func (m *AWSTGWSiteType) Reset()      { *m = AWSTGWSiteType{} }
func (*AWSTGWSiteType) ProtoMessage() {}
func (*AWSTGWSiteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{17}
}
func (m *AWSTGWSiteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSTGWSiteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSTGWSiteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSTGWSiteType.Merge(m, src)
}
func (m *AWSTGWSiteType) XXX_Size() int {
	return m.Size()
}
func (m *AWSTGWSiteType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSTGWSiteType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSTGWSiteType proto.InternalMessageInfo

func (m *AWSTGWSiteType) GetSite() *views.ObjectRefType {
	if m != nil {
		return m.Site
	}
	return nil
}

func (m *AWSTGWSiteType) GetCred() *views.ObjectRefType {
	if m != nil {
		return m.Cred
	}
	return nil
}

func (m *AWSTGWSiteType) GetVpcAttachments() *AWSVPCAttachmentListType {
	if m != nil {
		return m.VpcAttachments
	}
	return nil
}

// Replace Cloud Connect AWS TGW Site Type
//
// x-displayName: "AWS TGW Site Type"
// Cloud Connect AWS TGW Site Type
type ReplaceAWSTGWSiteType struct {
	// Spoke VPCs
	//
	// x-displayName: "Spoke VPCs"
	// Spoke VPCs to be attached to the AWS TGW Site
	VpcAttachments *AWSVPCAttachmentListType `protobuf:"bytes,3,opt,name=vpc_attachments,json=vpcAttachments,proto3" json:"vpc_attachments,omitempty"`
}

func (m *ReplaceAWSTGWSiteType) Reset()      { *m = ReplaceAWSTGWSiteType{} }
func (*ReplaceAWSTGWSiteType) ProtoMessage() {}
func (*ReplaceAWSTGWSiteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{18}
}
func (m *ReplaceAWSTGWSiteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceAWSTGWSiteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceAWSTGWSiteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceAWSTGWSiteType.Merge(m, src)
}
func (m *ReplaceAWSTGWSiteType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceAWSTGWSiteType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceAWSTGWSiteType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceAWSTGWSiteType proto.InternalMessageInfo

func (m *ReplaceAWSTGWSiteType) GetVpcAttachments() *AWSVPCAttachmentListType {
	if m != nil {
		return m.VpcAttachments
	}
	return nil
}

// Cloud Connect Azure VNET Site Type
//
// x-displayName: "Azure VNET Site Type"
// Cloud Connect Azure VNET Site Type
type AzureVNETSiteType struct {
	// Azure VNET Site Reference
	//
	// x-displayName: "Azure VNET Site Reference"
	// Azure VNET Site Reference
	// x-required
	Site *views.ObjectRefType `protobuf:"bytes,1,opt,name=site,proto3" json:"site,omitempty"`
	// Cloud Credential
	//
	// x-displayName: "Credential Reference"
	// Reference to cloud credential to deploy resources
	Cred *views.ObjectRefType `protobuf:"bytes,2,opt,name=cred,proto3" json:"cred,omitempty"`
	// Spoke VNETs
	//
	// x-displayName: "Spoke VNETs"
	// Spoke VNETs to be attached to the Azure Hub VNET Site
	// x-required
	VnetAttachments *AzureVnetAttachmentListType `protobuf:"bytes,5,opt,name=vnet_attachments,json=vnetAttachments,proto3" json:"vnet_attachments,omitempty"`
}

func (m *AzureVNETSiteType) Reset()      { *m = AzureVNETSiteType{} }
func (*AzureVNETSiteType) ProtoMessage() {}
func (*AzureVNETSiteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{19}
}
func (m *AzureVNETSiteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureVNETSiteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureVNETSiteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureVNETSiteType.Merge(m, src)
}
func (m *AzureVNETSiteType) XXX_Size() int {
	return m.Size()
}
func (m *AzureVNETSiteType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureVNETSiteType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureVNETSiteType proto.InternalMessageInfo

func (m *AzureVNETSiteType) GetSite() *views.ObjectRefType {
	if m != nil {
		return m.Site
	}
	return nil
}

func (m *AzureVNETSiteType) GetCred() *views.ObjectRefType {
	if m != nil {
		return m.Cred
	}
	return nil
}

func (m *AzureVNETSiteType) GetVnetAttachments() *AzureVnetAttachmentListType {
	if m != nil {
		return m.VnetAttachments
	}
	return nil
}

// Replace Cloud Connect Azure Vnet Site Type
//
// x-displayName: "Azure Vnet Site Type"
// Cloud Connect Azure Vnet Site Type
type ReplaceAzureVNETSiteType struct {
	// Spoke VNETs
	//
	// x-displayName: "Spoke VNETs"
	// Spoke VNETs to be attached to the Azure Vnet Site
	VnetAttachments *AzureVnetAttachmentListType `protobuf:"bytes,3,opt,name=vnet_attachments,json=vnetAttachments,proto3" json:"vnet_attachments,omitempty"`
}

func (m *ReplaceAzureVNETSiteType) Reset()      { *m = ReplaceAzureVNETSiteType{} }
func (*ReplaceAzureVNETSiteType) ProtoMessage() {}
func (*ReplaceAzureVNETSiteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{20}
}
func (m *ReplaceAzureVNETSiteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceAzureVNETSiteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceAzureVNETSiteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceAzureVNETSiteType.Merge(m, src)
}
func (m *ReplaceAzureVNETSiteType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceAzureVNETSiteType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceAzureVNETSiteType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceAzureVNETSiteType proto.InternalMessageInfo

func (m *ReplaceAzureVNETSiteType) GetVnetAttachments() *AzureVnetAttachmentListType {
	if m != nil {
		return m.VnetAttachments
	}
	return nil
}

// Cloud Connect Status
//
// x-displayName: "Status"
// Cloud Connect Status
type CloudConnectStatusType struct {
	// Cloud Connect Status
	//
	// x-displayName: "Status"
	// Cloud Connect Status
	//
	// Types that are valid to be assigned to CloudConnectDeployment:
	//	*CloudConnectStatusType_CloudConnectAwsSite
	//	*CloudConnectStatusType_CloudConnectAzureSite
	CloudConnectDeployment isCloudConnectStatusType_CloudConnectDeployment `protobuf_oneof:"cloud_connect_deployment"`
}

func (m *CloudConnectStatusType) Reset()      { *m = CloudConnectStatusType{} }
func (*CloudConnectStatusType) ProtoMessage() {}
func (*CloudConnectStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{21}
}
func (m *CloudConnectStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudConnectStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CloudConnectStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudConnectStatusType.Merge(m, src)
}
func (m *CloudConnectStatusType) XXX_Size() int {
	return m.Size()
}
func (m *CloudConnectStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudConnectStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_CloudConnectStatusType proto.InternalMessageInfo

type isCloudConnectStatusType_CloudConnectDeployment interface {
	isCloudConnectStatusType_CloudConnectDeployment()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CloudConnectStatusType_CloudConnectAwsSite struct {
	CloudConnectAwsSite *AWSAttachmentsListStatusType `protobuf:"bytes,2,opt,name=cloud_connect_aws_site,json=cloudConnectAwsSite,proto3,oneof" json:"cloud_connect_aws_site,omitempty"`
}
type CloudConnectStatusType_CloudConnectAzureSite struct {
	CloudConnectAzureSite *AzureAttachmentsListStatusType `protobuf:"bytes,3,opt,name=cloud_connect_azure_site,json=cloudConnectAzureSite,proto3,oneof" json:"cloud_connect_azure_site,omitempty"`
}

func (*CloudConnectStatusType_CloudConnectAwsSite) isCloudConnectStatusType_CloudConnectDeployment() {
}
func (*CloudConnectStatusType_CloudConnectAzureSite) isCloudConnectStatusType_CloudConnectDeployment() {
}

func (m *CloudConnectStatusType) GetCloudConnectDeployment() isCloudConnectStatusType_CloudConnectDeployment {
	if m != nil {
		return m.CloudConnectDeployment
	}
	return nil
}

func (m *CloudConnectStatusType) GetCloudConnectAwsSite() *AWSAttachmentsListStatusType {
	if x, ok := m.GetCloudConnectDeployment().(*CloudConnectStatusType_CloudConnectAwsSite); ok {
		return x.CloudConnectAwsSite
	}
	return nil
}

func (m *CloudConnectStatusType) GetCloudConnectAzureSite() *AzureAttachmentsListStatusType {
	if x, ok := m.GetCloudConnectDeployment().(*CloudConnectStatusType_CloudConnectAzureSite); ok {
		return x.CloudConnectAzureSite
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CloudConnectStatusType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CloudConnectStatusType_CloudConnectAwsSite)(nil),
		(*CloudConnectStatusType_CloudConnectAzureSite)(nil),
	}
}

// AWS VPC Attachment List Status Type
//
// x-displayName: "AWS VPC Attachment List Status Type"
// AWS VPC Attachment List Status Type
type AWSAttachmentsListStatusType struct {
	// AWS VPC Attachment Status Type
	//
	// x-displayName: "AWS VPC Attachment Status"
	// AWS Attachment Status Type
	AttachmentStatus []*AWSAttachmentsStatusType `protobuf:"bytes,1,rep,name=attachment_status,json=attachmentStatus,proto3" json:"attachment_status,omitempty"`
}

func (m *AWSAttachmentsListStatusType) Reset()      { *m = AWSAttachmentsListStatusType{} }
func (*AWSAttachmentsListStatusType) ProtoMessage() {}
func (*AWSAttachmentsListStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{22}
}
func (m *AWSAttachmentsListStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSAttachmentsListStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSAttachmentsListStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSAttachmentsListStatusType.Merge(m, src)
}
func (m *AWSAttachmentsListStatusType) XXX_Size() int {
	return m.Size()
}
func (m *AWSAttachmentsListStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSAttachmentsListStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSAttachmentsListStatusType proto.InternalMessageInfo

func (m *AWSAttachmentsListStatusType) GetAttachmentStatus() []*AWSAttachmentsStatusType {
	if m != nil {
		return m.AttachmentStatus
	}
	return nil
}

// AWS VPC Attachment Status Type
//
// x-displayName: "AWS Attachment Status Type"
// AWS Attachment Status Type
type AWSAttachmentsStatusType struct {
	// TGW Attachment ID
	//
	// x-displayName: "TGW Attachment ID"
	// TGW Attachment ID
	TgwAttachmentId string `protobuf:"bytes,2,opt,name=tgw_attachment_id,json=tgwAttachmentId,proto3" json:"tgw_attachment_id,omitempty"`
	// Attachment Creation Time
	//
	// x-displayName: "Attachment Creation Time"
	// Attachment Creation Time
	CreationTime *types.Timestamp `protobuf:"bytes,1,opt,name=creation_time,json=creationTime,proto3" json:"creation_time,omitempty"`
	// VPC ID
	//
	// x-displayName: "VPC ID"
	// VPC ID
	VpcId string `protobuf:"bytes,4,opt,name=vpc_id,json=vpcId,proto3" json:"vpc_id,omitempty"`
	// VPC Owner Account
	//
	// x-displayName: "VPC Owner Account"
	// VPC Owner Account
	VpcOwnerId string `protobuf:"bytes,5,opt,name=vpc_owner_id,json=vpcOwnerId,proto3" json:"vpc_owner_id,omitempty"`
	// VPC CIDR
	//
	// x-displayName: "VPC CIDR"
	// VPC CIDR
	VpcCidr string `protobuf:"bytes,12,opt,name=vpc_cidr,json=vpcCidr,proto3" json:"vpc_cidr,omitempty"`
	// Deployment State
	//
	// x-displayName: "Deployment State"
	// VPC deployment state
	VpcDeploymentState CloudConnectVPCStateType `protobuf:"varint,11,opt,name=vpc_deployment_state,json=vpcDeploymentState,proto3,enum=ves.io.schema.cloud_connect.CloudConnectVPCStateType" json:"vpc_deployment_state,omitempty"`
	// Attachment Deployment Status
	//
	// x-displayName: "Attachment Deployment Status"
	// Attachment Deployment Status
	DeploymentStatus string `protobuf:"bytes,7,opt,name=deployment_status,json=deploymentStatus,proto3" json:"deployment_status,omitempty"`
	// Attachment Tags
	//
	// x-displayName: "Attachment Tags"
	// Attachment Tags
	Tags map[string]string `protobuf:"bytes,8,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Subnets
	//
	// x-displayName: "Network Interfaces"
	// Network Interfaces created along with the attachment
	Subnets []*SubnetStatusType `protobuf:"bytes,10,rep,name=subnets,proto3" json:"subnets,omitempty"`
	// Routes
	//
	// x-displayName: "Installed Routes"
	// Routes
	InstalledRoutes *AWSRouteTableListType `protobuf:"bytes,9,opt,name=installed_routes,json=installedRoutes,proto3" json:"installed_routes,omitempty"`
}

func (m *AWSAttachmentsStatusType) Reset()      { *m = AWSAttachmentsStatusType{} }
func (*AWSAttachmentsStatusType) ProtoMessage() {}
func (*AWSAttachmentsStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{23}
}
func (m *AWSAttachmentsStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSAttachmentsStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSAttachmentsStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSAttachmentsStatusType.Merge(m, src)
}
func (m *AWSAttachmentsStatusType) XXX_Size() int {
	return m.Size()
}
func (m *AWSAttachmentsStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSAttachmentsStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_AWSAttachmentsStatusType proto.InternalMessageInfo

func (m *AWSAttachmentsStatusType) GetTgwAttachmentId() string {
	if m != nil {
		return m.TgwAttachmentId
	}
	return ""
}

func (m *AWSAttachmentsStatusType) GetCreationTime() *types.Timestamp {
	if m != nil {
		return m.CreationTime
	}
	return nil
}

func (m *AWSAttachmentsStatusType) GetVpcId() string {
	if m != nil {
		return m.VpcId
	}
	return ""
}

func (m *AWSAttachmentsStatusType) GetVpcOwnerId() string {
	if m != nil {
		return m.VpcOwnerId
	}
	return ""
}

func (m *AWSAttachmentsStatusType) GetVpcCidr() string {
	if m != nil {
		return m.VpcCidr
	}
	return ""
}

func (m *AWSAttachmentsStatusType) GetVpcDeploymentState() CloudConnectVPCStateType {
	if m != nil {
		return m.VpcDeploymentState
	}
	return AVAILABLE
}

func (m *AWSAttachmentsStatusType) GetDeploymentStatus() string {
	if m != nil {
		return m.DeploymentStatus
	}
	return ""
}

func (m *AWSAttachmentsStatusType) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *AWSAttachmentsStatusType) GetSubnets() []*SubnetStatusType {
	if m != nil {
		return m.Subnets
	}
	return nil
}

func (m *AWSAttachmentsStatusType) GetInstalledRoutes() *AWSRouteTableListType {
	if m != nil {
		return m.InstalledRoutes
	}
	return nil
}

// SubnetStatusType for AWS VPC Attachment
//
// x-displayName: "Network Interface Status"
// Network Interface Status
type SubnetStatusType struct {
	// Network Interface ID
	//
	// x-displayName: "Network Interface ID"
	// Network Interface ID
	NetworkInterfaceId string `protobuf:"bytes,1,opt,name=network_interface_id,json=networkInterfaceId,proto3" json:"network_interface_id,omitempty"`
	// Interface Type
	// x-displayName: "Interface Type"
	//
	// Interface Type
	InterfaceType string `protobuf:"bytes,2,opt,name=interface_type,json=interfaceType,proto3" json:"interface_type,omitempty"`
	// Private IPV4 Address
	// x-displayName: "Private IPV4 Address"
	//
	// Private IPV4 Address
	PrivateIpv4Address string `protobuf:"bytes,3,opt,name=private_ipv4_address,json=privateIpv4Address,proto3" json:"private_ipv4_address,omitempty"`
	// Availability Zone
	// x-displayName: "Availability Zone"
	//
	// Availability Zone
	AvailabilityZone string `protobuf:"bytes,4,opt,name=availability_zone,json=availabilityZone,proto3" json:"availability_zone,omitempty"`
	// Subnet ID
	// x-displayName: "Subnet ID"
	//
	// Subnet ID
	SubnetId string `protobuf:"bytes,5,opt,name=subnet_id,json=subnetId,proto3" json:"subnet_id,omitempty"`
	// Status
	// x-displayName: "Status"
	//
	// Status
	Status string `protobuf:"bytes,6,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *SubnetStatusType) Reset()      { *m = SubnetStatusType{} }
func (*SubnetStatusType) ProtoMessage() {}
func (*SubnetStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{24}
}
func (m *SubnetStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubnetStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SubnetStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubnetStatusType.Merge(m, src)
}
func (m *SubnetStatusType) XXX_Size() int {
	return m.Size()
}
func (m *SubnetStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_SubnetStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_SubnetStatusType proto.InternalMessageInfo

func (m *SubnetStatusType) GetNetworkInterfaceId() string {
	if m != nil {
		return m.NetworkInterfaceId
	}
	return ""
}

func (m *SubnetStatusType) GetInterfaceType() string {
	if m != nil {
		return m.InterfaceType
	}
	return ""
}

func (m *SubnetStatusType) GetPrivateIpv4Address() string {
	if m != nil {
		return m.PrivateIpv4Address
	}
	return ""
}

func (m *SubnetStatusType) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

func (m *SubnetStatusType) GetSubnetId() string {
	if m != nil {
		return m.SubnetId
	}
	return ""
}

func (m *SubnetStatusType) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// Azure spoke Attachment List Status Type
//
// x-displayName: "Azure spoke Attachment List Status Type"
// Azure VEspokeNT Attachment List Status Type
type AzureAttachmentsListStatusType struct {
	// Azure spoke Attachment Status Type
	//
	// x-displayName: "Azure spoke Attachment Status"
	// Azure spoke Attachment Status Type
	AttachmentStatus []*AzureAttachmentsStatusType `protobuf:"bytes,1,rep,name=attachment_status,json=attachmentStatus,proto3" json:"attachment_status,omitempty"`
}

func (m *AzureAttachmentsListStatusType) Reset()      { *m = AzureAttachmentsListStatusType{} }
func (*AzureAttachmentsListStatusType) ProtoMessage() {}
func (*AzureAttachmentsListStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{25}
}
func (m *AzureAttachmentsListStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureAttachmentsListStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureAttachmentsListStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureAttachmentsListStatusType.Merge(m, src)
}
func (m *AzureAttachmentsListStatusType) XXX_Size() int {
	return m.Size()
}
func (m *AzureAttachmentsListStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureAttachmentsListStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureAttachmentsListStatusType proto.InternalMessageInfo

func (m *AzureAttachmentsListStatusType) GetAttachmentStatus() []*AzureAttachmentsStatusType {
	if m != nil {
		return m.AttachmentStatus
	}
	return nil
}

// Azure Attachment Status Type
//
// x-displayName: "Azure Attachment Status Type"
// Azure Attachment Status Type
type AzureAttachmentsStatusType struct {
	// VNET Attachment ID
	//
	// x-displayName: "VNET Attachment ID"
	// VNET Attachment ID
	VnetAttachmentId string `protobuf:"bytes,2,opt,name=vnet_attachment_id,json=vnetAttachmentId,proto3" json:"vnet_attachment_id,omitempty"`
	// VNET subscription
	//
	// x-displayName: "VNET Subscription"
	// VNET Subscription
	SpokeSubscriptionId string `protobuf:"bytes,15,opt,name=spoke_subscription_id,json=spokeSubscriptionId,proto3" json:"spoke_subscription_id,omitempty"`
	// Spoke VNET ID
	//
	// x-displayName: "Spoke VNET ID"
	// Spoke VNET ID
	SpokeVnetId string `protobuf:"bytes,3,opt,name=spoke_vnet_id,json=spokeVnetId,proto3" json:"spoke_vnet_id,omitempty"`
	// Hub VNET Name
	//
	// x-displayName: "Hub VNET Name"
	// Hub VNET Name
	HubVnetName string `protobuf:"bytes,4,opt,name=hub_vnet_name,json=hubVnetName,proto3" json:"hub_vnet_name,omitempty"`
	// Hub VNET Resource Group
	//
	// x-displayName: "Hub VNET Resource Group"
	// Hub VNET Resource Group
	HubVnetResourceGroup string `protobuf:"bytes,16,opt,name=hub_vnet_resource_group,json=hubVnetResourceGroup,proto3" json:"hub_vnet_resource_group,omitempty"`
	// Hub Owner subscription
	//
	// x-displayName: "Hub Owner Subscription"
	// Hub Owner Subscription
	HubOwnerSubscriptionid string `protobuf:"bytes,5,opt,name=hub_owner_subscriptionid,json=hubOwnerSubscriptionid,proto3" json:"hub_owner_subscriptionid,omitempty"`
	// Hub VNET Peering state
	//
	// x-displayName: "Hub VNET Peering state"
	// Hub VNET Peering state
	PeeringState string `protobuf:"bytes,6,opt,name=peering_state,json=peeringState,proto3" json:"peering_state,omitempty"`
	// Hub VNET Provisioning state
	//
	// x-displayName: "Hub VNET Provisioning state"
	// Hub VNET Provisioning state
	ProvisioningState string `protobuf:"bytes,7,opt,name=provisioning_state,json=provisioningState,proto3" json:"provisioning_state,omitempty"`
	// Attachment Deployment Status
	//
	// x-displayName: "Attachment Deployment Status"
	// Attachment Deployment Status
	DeploymentStatus string `protobuf:"bytes,8,opt,name=deployment_status,json=deploymentStatus,proto3" json:"deployment_status,omitempty"`
	// Hub VNET peering sync level
	//
	// x-displayName: "Hub VNET peering sync level"
	// Hub VNET peering sync level
	PeeringSyncLevel string `protobuf:"bytes,9,opt,name=peering_sync_level,json=peeringSyncLevel,proto3" json:"peering_sync_level,omitempty"`
	// Attachment Tags
	//
	// x-displayName: "Attachment Tags"
	// Attachment Tags
	Tags map[string]string `protobuf:"bytes,10,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Subnets
	//
	// x-displayName: "Network Interfaces"
	// Network Interfaces created along with the attachment
	Subnets []*SubnetStatusType `protobuf:"bytes,11,rep,name=subnets,proto3" json:"subnets,omitempty"`
	// x-displayName: "Installed Routes"
	// Routes
	InstalledRoutes *AzureRouteTableWithStaticRouteListType `protobuf:"bytes,12,opt,name=installed_routes,json=installedRoutes,proto3" json:"installed_routes,omitempty"`
	// VNET CIDR
	//
	// x-displayName: "VNET CIDR"
	// VNET CIDR
	VnetCidr string `protobuf:"bytes,14,opt,name=vnet_cidr,json=vnetCidr,proto3" json:"vnet_cidr,omitempty"`
}

func (m *AzureAttachmentsStatusType) Reset()      { *m = AzureAttachmentsStatusType{} }
func (*AzureAttachmentsStatusType) ProtoMessage() {}
func (*AzureAttachmentsStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{26}
}
func (m *AzureAttachmentsStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AzureAttachmentsStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AzureAttachmentsStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AzureAttachmentsStatusType.Merge(m, src)
}
func (m *AzureAttachmentsStatusType) XXX_Size() int {
	return m.Size()
}
func (m *AzureAttachmentsStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_AzureAttachmentsStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_AzureAttachmentsStatusType proto.InternalMessageInfo

func (m *AzureAttachmentsStatusType) GetVnetAttachmentId() string {
	if m != nil {
		return m.VnetAttachmentId
	}
	return ""
}

func (m *AzureAttachmentsStatusType) GetSpokeSubscriptionId() string {
	if m != nil {
		return m.SpokeSubscriptionId
	}
	return ""
}

func (m *AzureAttachmentsStatusType) GetSpokeVnetId() string {
	if m != nil {
		return m.SpokeVnetId
	}
	return ""
}

func (m *AzureAttachmentsStatusType) GetHubVnetName() string {
	if m != nil {
		return m.HubVnetName
	}
	return ""
}

func (m *AzureAttachmentsStatusType) GetHubVnetResourceGroup() string {
	if m != nil {
		return m.HubVnetResourceGroup
	}
	return ""
}

func (m *AzureAttachmentsStatusType) GetHubOwnerSubscriptionid() string {
	if m != nil {
		return m.HubOwnerSubscriptionid
	}
	return ""
}

func (m *AzureAttachmentsStatusType) GetPeeringState() string {
	if m != nil {
		return m.PeeringState
	}
	return ""
}

func (m *AzureAttachmentsStatusType) GetProvisioningState() string {
	if m != nil {
		return m.ProvisioningState
	}
	return ""
}

func (m *AzureAttachmentsStatusType) GetDeploymentStatus() string {
	if m != nil {
		return m.DeploymentStatus
	}
	return ""
}

func (m *AzureAttachmentsStatusType) GetPeeringSyncLevel() string {
	if m != nil {
		return m.PeeringSyncLevel
	}
	return ""
}

func (m *AzureAttachmentsStatusType) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *AzureAttachmentsStatusType) GetSubnets() []*SubnetStatusType {
	if m != nil {
		return m.Subnets
	}
	return nil
}

func (m *AzureAttachmentsStatusType) GetInstalledRoutes() *AzureRouteTableWithStaticRouteListType {
	if m != nil {
		return m.InstalledRoutes
	}
	return nil
}

func (m *AzureAttachmentsStatusType) GetVnetCidr() string {
	if m != nil {
		return m.VnetCidr
	}
	return ""
}

// Cloud Connect specification
//
// x-displayName: "Specification"
// Desired state for Cloud Connect
type GlobalSpecType struct {
	// Provider choice
	//
	// x-displayName: "Provider"
	// x-required
	//
	// Types that are valid to be assigned to Cloud:
	//	*GlobalSpecType_AwsRe
	//	*GlobalSpecType_AwsTgwSite
	//	*GlobalSpecType_AzureVnetSite
	Cloud isGlobalSpecType_Cloud `protobuf_oneof:"cloud"`
	// Segment
	//
	// x-displayName: "Segment"
	// x-required
	Segment *views.ObjectRefType `protobuf:"bytes,13,opt,name=segment,proto3" json:"segment,omitempty"`
	// Bandwidth option
	//
	// x-displayName: "Bandwidth Option"
	// x-required
	// Supported bandwidth
	//
	// Types that are valid to be assigned to BandwidthOption:
	//	*GlobalSpecType_Bandwidth_500Mbs
	BandwidthOption isGlobalSpecType_BandwidthOption `protobuf_oneof:"bandwidth_option"`
	// Site Reference
	//
	// x-displayName: "Site"
	Sites []*schema.ObjectRefType `protobuf:"bytes,12,rep,name=sites,proto3" json:"sites,omitempty"`
	// Virtual Network Reference
	//
	// x-displayName: "Virtual Network"
	VirtualNetwork []*schema.ObjectRefType `protobuf:"bytes,14,rep,name=virtual_network,json=virtualNetwork,proto3" json:"virtual_network,omitempty"`
	// Cloud Connect State
	//
	// x-displayName: "Cloud Connect State"
	// State of the vpc attachments with the Cloud Connect deployment
	State CloudConnectState `protobuf:"varint,15,opt,name=state,proto3,enum=ves.io.schema.cloud_connect.CloudConnectState" json:"state,omitempty"`
	// Onboared VPC Count
	//
	// x-displayName: "onboarded_vpc"
	// Number of vpc that have been onboarded onto the cloud from this config.
	OnboardedVpc uint32 `protobuf:"varint,17,opt,name=onboarded_vpc,json=onboardedVpc,proto3" json:"onboarded_vpc,omitempty"`
	// CloudConnect Connection Coordinates
	//
	// x-displayName: "CloudConnect Coordinates"
	// Coordinates of the attached site with this cloud connect.
	Coordinates *site.Coordinates `protobuf:"bytes,18,opt,name=coordinates,proto3" json:"coordinates,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{27}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_Cloud interface {
	isGlobalSpecType_Cloud()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_BandwidthOption interface {
	isGlobalSpecType_BandwidthOption()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_AwsRe struct {
	AwsRe *AWSREType `protobuf:"bytes,2,opt,name=aws_re,json=awsRe,proto3,oneof" json:"aws_re,omitempty"`
}
type GlobalSpecType_AwsTgwSite struct {
	AwsTgwSite *AWSTGWSiteType `protobuf:"bytes,7,opt,name=aws_tgw_site,json=awsTgwSite,proto3,oneof" json:"aws_tgw_site,omitempty"`
}
type GlobalSpecType_AzureVnetSite struct {
	AzureVnetSite *AzureVNETSiteType `protobuf:"bytes,19,opt,name=azure_vnet_site,json=azureVnetSite,proto3,oneof" json:"azure_vnet_site,omitempty"`
}
type GlobalSpecType_Bandwidth_500Mbs struct {
	Bandwidth_500Mbs *schema.Empty `protobuf:"bytes,9,opt,name=bandwidth_500mbs,json=bandwidth500mbs,proto3,oneof" json:"bandwidth_500mbs,omitempty"`
}

func (*GlobalSpecType_AwsRe) isGlobalSpecType_Cloud()                      {}
func (*GlobalSpecType_AwsTgwSite) isGlobalSpecType_Cloud()                 {}
func (*GlobalSpecType_AzureVnetSite) isGlobalSpecType_Cloud()              {}
func (*GlobalSpecType_Bandwidth_500Mbs) isGlobalSpecType_BandwidthOption() {}

func (m *GlobalSpecType) GetCloud() isGlobalSpecType_Cloud {
	if m != nil {
		return m.Cloud
	}
	return nil
}
func (m *GlobalSpecType) GetBandwidthOption() isGlobalSpecType_BandwidthOption {
	if m != nil {
		return m.BandwidthOption
	}
	return nil
}

func (m *GlobalSpecType) GetAwsRe() *AWSREType {
	if x, ok := m.GetCloud().(*GlobalSpecType_AwsRe); ok {
		return x.AwsRe
	}
	return nil
}

func (m *GlobalSpecType) GetAwsTgwSite() *AWSTGWSiteType {
	if x, ok := m.GetCloud().(*GlobalSpecType_AwsTgwSite); ok {
		return x.AwsTgwSite
	}
	return nil
}

func (m *GlobalSpecType) GetAzureVnetSite() *AzureVNETSiteType {
	if x, ok := m.GetCloud().(*GlobalSpecType_AzureVnetSite); ok {
		return x.AzureVnetSite
	}
	return nil
}

func (m *GlobalSpecType) GetSegment() *views.ObjectRefType {
	if m != nil {
		return m.Segment
	}
	return nil
}

func (m *GlobalSpecType) GetBandwidth_500Mbs() *schema.Empty {
	if x, ok := m.GetBandwidthOption().(*GlobalSpecType_Bandwidth_500Mbs); ok {
		return x.Bandwidth_500Mbs
	}
	return nil
}

func (m *GlobalSpecType) GetSites() []*schema.ObjectRefType {
	if m != nil {
		return m.Sites
	}
	return nil
}

func (m *GlobalSpecType) GetVirtualNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.VirtualNetwork
	}
	return nil
}

func (m *GlobalSpecType) GetState() CloudConnectState {
	if m != nil {
		return m.State
	}
	return DOWN
}

func (m *GlobalSpecType) GetOnboardedVpc() uint32 {
	if m != nil {
		return m.OnboardedVpc
	}
	return 0
}

func (m *GlobalSpecType) GetCoordinates() *site.Coordinates {
	if m != nil {
		return m.Coordinates
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_AwsRe)(nil),
		(*GlobalSpecType_AwsTgwSite)(nil),
		(*GlobalSpecType_AzureVnetSite)(nil),
		(*GlobalSpecType_Bandwidth_500Mbs)(nil),
	}
}

// Create Cloud Connect
//
// x-displayName: "Create Cloud Connect"
// Shape of the Cloud Connect specification
type CreateSpecType struct {
	// Types that are valid to be assigned to Cloud:
	//	*CreateSpecType_AwsRe
	//	*CreateSpecType_AwsTgwSite
	//	*CreateSpecType_AzureVnetSite
	Cloud   isCreateSpecType_Cloud `protobuf_oneof:"cloud"`
	Segment *views.ObjectRefType   `protobuf:"bytes,13,opt,name=segment,proto3" json:"segment,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{28}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_Cloud interface {
	isCreateSpecType_Cloud()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_AwsRe struct {
	AwsRe *AWSREType `protobuf:"bytes,2,opt,name=aws_re,json=awsRe,proto3,oneof" json:"aws_re,omitempty"`
}
type CreateSpecType_AwsTgwSite struct {
	AwsTgwSite *AWSTGWSiteType `protobuf:"bytes,7,opt,name=aws_tgw_site,json=awsTgwSite,proto3,oneof" json:"aws_tgw_site,omitempty"`
}
type CreateSpecType_AzureVnetSite struct {
	AzureVnetSite *AzureVNETSiteType `protobuf:"bytes,19,opt,name=azure_vnet_site,json=azureVnetSite,proto3,oneof" json:"azure_vnet_site,omitempty"`
}

func (*CreateSpecType_AwsRe) isCreateSpecType_Cloud()         {}
func (*CreateSpecType_AwsTgwSite) isCreateSpecType_Cloud()    {}
func (*CreateSpecType_AzureVnetSite) isCreateSpecType_Cloud() {}

func (m *CreateSpecType) GetCloud() isCreateSpecType_Cloud {
	if m != nil {
		return m.Cloud
	}
	return nil
}

func (m *CreateSpecType) GetAwsRe() *AWSREType {
	if x, ok := m.GetCloud().(*CreateSpecType_AwsRe); ok {
		return x.AwsRe
	}
	return nil
}

func (m *CreateSpecType) GetAwsTgwSite() *AWSTGWSiteType {
	if x, ok := m.GetCloud().(*CreateSpecType_AwsTgwSite); ok {
		return x.AwsTgwSite
	}
	return nil
}

func (m *CreateSpecType) GetAzureVnetSite() *AzureVNETSiteType {
	if x, ok := m.GetCloud().(*CreateSpecType_AzureVnetSite); ok {
		return x.AzureVnetSite
	}
	return nil
}

func (m *CreateSpecType) GetSegment() *views.ObjectRefType {
	if m != nil {
		return m.Segment
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_AwsRe)(nil),
		(*CreateSpecType_AwsTgwSite)(nil),
		(*CreateSpecType_AzureVnetSite)(nil),
	}
}

// Replace Cloud Connect
//
// x-displayName: "Replace Cloud Connect"
// Shape of the Cloud Connect specification
type ReplaceSpecType struct {
	// Types that are valid to be assigned to Cloud:
	//	*ReplaceSpecType_AwsRe
	//	*ReplaceSpecType_AwsTgwSite
	//	*ReplaceSpecType_AzureVnetSite
	Cloud   isReplaceSpecType_Cloud `protobuf_oneof:"cloud"`
	Segment *views.ObjectRefType    `protobuf:"bytes,13,opt,name=segment,proto3" json:"segment,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{29}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_Cloud interface {
	isReplaceSpecType_Cloud()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_AwsRe struct {
	AwsRe *ReplaceAWSREType `protobuf:"bytes,2,opt,name=aws_re,json=awsRe,proto3,oneof" json:"aws_re,omitempty"`
}
type ReplaceSpecType_AwsTgwSite struct {
	AwsTgwSite *ReplaceAWSTGWSiteType `protobuf:"bytes,7,opt,name=aws_tgw_site,json=awsTgwSite,proto3,oneof" json:"aws_tgw_site,omitempty"`
}
type ReplaceSpecType_AzureVnetSite struct {
	AzureVnetSite *ReplaceAzureVNETSiteType `protobuf:"bytes,19,opt,name=azure_vnet_site,json=azureVnetSite,proto3,oneof" json:"azure_vnet_site,omitempty"`
}

func (*ReplaceSpecType_AwsRe) isReplaceSpecType_Cloud()         {}
func (*ReplaceSpecType_AwsTgwSite) isReplaceSpecType_Cloud()    {}
func (*ReplaceSpecType_AzureVnetSite) isReplaceSpecType_Cloud() {}

func (m *ReplaceSpecType) GetCloud() isReplaceSpecType_Cloud {
	if m != nil {
		return m.Cloud
	}
	return nil
}

func (m *ReplaceSpecType) GetAwsRe() *ReplaceAWSREType {
	if x, ok := m.GetCloud().(*ReplaceSpecType_AwsRe); ok {
		return x.AwsRe
	}
	return nil
}

func (m *ReplaceSpecType) GetAwsTgwSite() *ReplaceAWSTGWSiteType {
	if x, ok := m.GetCloud().(*ReplaceSpecType_AwsTgwSite); ok {
		return x.AwsTgwSite
	}
	return nil
}

func (m *ReplaceSpecType) GetAzureVnetSite() *ReplaceAzureVNETSiteType {
	if x, ok := m.GetCloud().(*ReplaceSpecType_AzureVnetSite); ok {
		return x.AzureVnetSite
	}
	return nil
}

func (m *ReplaceSpecType) GetSegment() *views.ObjectRefType {
	if m != nil {
		return m.Segment
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_AwsRe)(nil),
		(*ReplaceSpecType_AwsTgwSite)(nil),
		(*ReplaceSpecType_AzureVnetSite)(nil),
	}
}

// Get Cloud Connect
//
// x-displayName: "Get Cloud Connect"
// Shape of the Cloud Connect specification
type GetSpecType struct {
	// Types that are valid to be assigned to Cloud:
	//	*GetSpecType_AwsRe
	//	*GetSpecType_AwsTgwSite
	//	*GetSpecType_AzureVnetSite
	Cloud        isGetSpecType_Cloud  `protobuf_oneof:"cloud"`
	Segment      *views.ObjectRefType `protobuf:"bytes,13,opt,name=segment,proto3" json:"segment,omitempty"`
	State        CloudConnectState    `protobuf:"varint,15,opt,name=state,proto3,enum=ves.io.schema.cloud_connect.CloudConnectState" json:"state,omitempty"`
	OnboardedVpc uint32               `protobuf:"varint,17,opt,name=onboarded_vpc,json=onboardedVpc,proto3" json:"onboarded_vpc,omitempty"`
	Coordinates  *site.Coordinates    `protobuf:"bytes,18,opt,name=coordinates,proto3" json:"coordinates,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{30}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_Cloud interface {
	isGetSpecType_Cloud()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_AwsRe struct {
	AwsRe *AWSREType `protobuf:"bytes,2,opt,name=aws_re,json=awsRe,proto3,oneof" json:"aws_re,omitempty"`
}
type GetSpecType_AwsTgwSite struct {
	AwsTgwSite *AWSTGWSiteType `protobuf:"bytes,7,opt,name=aws_tgw_site,json=awsTgwSite,proto3,oneof" json:"aws_tgw_site,omitempty"`
}
type GetSpecType_AzureVnetSite struct {
	AzureVnetSite *AzureVNETSiteType `protobuf:"bytes,19,opt,name=azure_vnet_site,json=azureVnetSite,proto3,oneof" json:"azure_vnet_site,omitempty"`
}

func (*GetSpecType_AwsRe) isGetSpecType_Cloud()         {}
func (*GetSpecType_AwsTgwSite) isGetSpecType_Cloud()    {}
func (*GetSpecType_AzureVnetSite) isGetSpecType_Cloud() {}

func (m *GetSpecType) GetCloud() isGetSpecType_Cloud {
	if m != nil {
		return m.Cloud
	}
	return nil
}

func (m *GetSpecType) GetAwsRe() *AWSREType {
	if x, ok := m.GetCloud().(*GetSpecType_AwsRe); ok {
		return x.AwsRe
	}
	return nil
}

func (m *GetSpecType) GetAwsTgwSite() *AWSTGWSiteType {
	if x, ok := m.GetCloud().(*GetSpecType_AwsTgwSite); ok {
		return x.AwsTgwSite
	}
	return nil
}

func (m *GetSpecType) GetAzureVnetSite() *AzureVNETSiteType {
	if x, ok := m.GetCloud().(*GetSpecType_AzureVnetSite); ok {
		return x.AzureVnetSite
	}
	return nil
}

func (m *GetSpecType) GetSegment() *views.ObjectRefType {
	if m != nil {
		return m.Segment
	}
	return nil
}

func (m *GetSpecType) GetState() CloudConnectState {
	if m != nil {
		return m.State
	}
	return DOWN
}

func (m *GetSpecType) GetOnboardedVpc() uint32 {
	if m != nil {
		return m.OnboardedVpc
	}
	return 0
}

func (m *GetSpecType) GetCoordinates() *site.Coordinates {
	if m != nil {
		return m.Coordinates
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_AwsRe)(nil),
		(*GetSpecType_AwsTgwSite)(nil),
		(*GetSpecType_AzureVnetSite)(nil),
	}
}

// Label Filter
//
// x-displayName: "Label Filter"
// Metrics used in the cloud connect are tagged with labels listed in the enum Label.
// Label Filter is used to filter the timeseries that match the specified label key/value
// and the operator.
type LabelFilter struct {
	// Label
	//
	// x-displayName: "Label"
	// Label name
	Label Label `protobuf:"varint,1,opt,name=label,proto3,enum=ves.io.schema.cloud_connect.Label" json:"label,omitempty"`
	// Operator
	//
	// x-displayName: "Operator"
	// Operator to be applied on the label
	Op schema.MetricLabelOp `protobuf:"varint,2,opt,name=op,proto3,enum=ves.io.schema.MetricLabelOp" json:"op,omitempty"`
	// Value
	//
	// x-displayName: "Value"
	// x-example: "ce01"
	// Value of the label
	Value string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *LabelFilter) Reset()      { *m = LabelFilter{} }
func (*LabelFilter) ProtoMessage() {}
func (*LabelFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{31}
}
func (m *LabelFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabelFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LabelFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabelFilter.Merge(m, src)
}
func (m *LabelFilter) XXX_Size() int {
	return m.Size()
}
func (m *LabelFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_LabelFilter.DiscardUnknown(m)
}

var xxx_messageInfo_LabelFilter proto.InternalMessageInfo

func (m *LabelFilter) GetLabel() Label {
	if m != nil {
		return m.Label
	}
	return LABEL_NONE
}

func (m *LabelFilter) GetOp() schema.MetricLabelOp {
	if m != nil {
		return m.Op
	}
	return schema.EQ
}

func (m *LabelFilter) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Customer Edge
//
// x-displayName: "Customer Edge"
// Customer Edge uniquely identifies customer edge i.e. site.
type CustomerEdge struct {
	// Customer Edge
	//
	// x-displayName: "Customer Edge"
	// x-example: "Customer Edge 1"
	// Name of the customer edge
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *CustomerEdge) Reset()      { *m = CustomerEdge{} }
func (*CustomerEdge) ProtoMessage() {}
func (*CustomerEdge) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{32}
}
func (m *CustomerEdge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CustomerEdge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CustomerEdge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CustomerEdge.Merge(m, src)
}
func (m *CustomerEdge) XXX_Size() int {
	return m.Size()
}
func (m *CustomerEdge) XXX_DiscardUnknown() {
	xxx_messageInfo_CustomerEdge.DiscardUnknown(m)
}

var xxx_messageInfo_CustomerEdge proto.InternalMessageInfo

func (m *CustomerEdge) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Metric Data
//
// x-displayName: "Metric Data"
// MetricData contains metric type and the corresponding value for a cloud connect
type MetricData struct {
	// Type
	//
	// x-displayName: "Type"
	// Identifies the metric type
	Type FieldSelector `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.cloud_connect.FieldSelector" json:"type,omitempty"`
	// Unit
	//
	// x-displayName: "Unit"
	// Unit for the metric value
	Unit schema.UnitType `protobuf:"varint,2,opt,name=unit,proto3,enum=ves.io.schema.UnitType" json:"unit,omitempty"`
	// Value
	//
	// x-displayName: "Value"
	// List of metric values. May contain more than one value if timeseries data is requested.
	Values []*schema.MetricValue `protobuf:"bytes,3,rep,name=values,proto3" json:"values,omitempty"`
}

func (m *MetricData) Reset()      { *m = MetricData{} }
func (*MetricData) ProtoMessage() {}
func (*MetricData) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{33}
}
func (m *MetricData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MetricData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricData.Merge(m, src)
}
func (m *MetricData) XXX_Size() int {
	return m.Size()
}
func (m *MetricData) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricData.DiscardUnknown(m)
}

var xxx_messageInfo_MetricData proto.InternalMessageInfo

func (m *MetricData) GetType() FieldSelector {
	if m != nil {
		return m.Type
	}
	return METRIC_TYPE_NONE
}

func (m *MetricData) GetUnit() schema.UnitType {
	if m != nil {
		return m.Unit
	}
	return schema.UNIT_MILLISECONDS
}

func (m *MetricData) GetValues() []*schema.MetricValue {
	if m != nil {
		return m.Values
	}
	return nil
}

// Cloud Connect Segmentation Data
//
// x-displayName: "Cloud Connect Segmentation Data"
// SegmentationData contains metric type and the corresponding value for a cloud connect
type SegmentationData struct {
	// Type
	//
	// x-displayName: "Type"
	// Identifies the segment type
	Type TrafficType `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.cloud_connect.TrafficType" json:"type,omitempty"`
	// Data
	//
	// x-displayName: "Data"
	// List of metric values. May contain more than one value if timeseries data is requested.
	Data []*MetricData `protobuf:"bytes,2,rep,name=data,proto3" json:"data,omitempty"`
}

func (m *SegmentationData) Reset()      { *m = SegmentationData{} }
func (*SegmentationData) ProtoMessage() {}
func (*SegmentationData) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{34}
}
func (m *SegmentationData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SegmentationData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SegmentationData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SegmentationData.Merge(m, src)
}
func (m *SegmentationData) XXX_Size() int {
	return m.Size()
}
func (m *SegmentationData) XXX_DiscardUnknown() {
	xxx_messageInfo_SegmentationData.DiscardUnknown(m)
}

var xxx_messageInfo_SegmentationData proto.InternalMessageInfo

func (m *SegmentationData) GetType() TrafficType {
	if m != nil {
		return m.Type
	}
	return TRAFFIC_TYPE_NONE
}

func (m *SegmentationData) GetData() []*MetricData {
	if m != nil {
		return m.Data
	}
	return nil
}

// Cloud Connect Edge Data
//
// x-displayName: "Cloud Connect Edge Data"
// EdgeData wraps all the response data for a customer edge.
type EdgeData struct {
	// CE
	//
	// x-displayName: "CE"
	// Identifier for the customer edge
	Ce *CustomerEdge `protobuf:"bytes,1,opt,name=ce,proto3" json:"ce,omitempty"`
	// Metric
	//
	// x-displayName: "Metric"
	// Metric data for the segments
	Segments []*SegmentationData `protobuf:"bytes,2,rep,name=segments,proto3" json:"segments,omitempty"`
}

func (m *EdgeData) Reset()      { *m = EdgeData{} }
func (*EdgeData) ProtoMessage() {}
func (*EdgeData) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{35}
}
func (m *EdgeData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EdgeData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EdgeData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EdgeData.Merge(m, src)
}
func (m *EdgeData) XXX_Size() int {
	return m.Size()
}
func (m *EdgeData) XXX_DiscardUnknown() {
	xxx_messageInfo_EdgeData.DiscardUnknown(m)
}

var xxx_messageInfo_EdgeData proto.InternalMessageInfo

func (m *EdgeData) GetCe() *CustomerEdge {
	if m != nil {
		return m.Ce
	}
	return nil
}

func (m *EdgeData) GetSegments() []*SegmentationData {
	if m != nil {
		return m.Segments
	}
	return nil
}

// Cloud Connect Data
//
// x-displayName: "Cloud Connect Data"
// CloudConnectData wraps all the response data for a cloud connect.
type CloudConnectData struct {
	// Labels
	//
	// x-displayName: "Labels"
	// Labels contains the name/value pair.
	// "name" is the label defined in Labels
	Labels map[string]string `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Data
	//
	// x-displayName: "Data"
	// metric values
	Data []*MetricData `protobuf:"bytes,2,rep,name=data,proto3" json:"data,omitempty"`
}

func (m *CloudConnectData) Reset()      { *m = CloudConnectData{} }
func (*CloudConnectData) ProtoMessage() {}
func (*CloudConnectData) Descriptor() ([]byte, []int) {
	return fileDescriptor_245b6fb3a531fd11, []int{36}
}
func (m *CloudConnectData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloudConnectData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CloudConnectData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloudConnectData.Merge(m, src)
}
func (m *CloudConnectData) XXX_Size() int {
	return m.Size()
}
func (m *CloudConnectData) XXX_DiscardUnknown() {
	xxx_messageInfo_CloudConnectData.DiscardUnknown(m)
}

var xxx_messageInfo_CloudConnectData proto.InternalMessageInfo

func (m *CloudConnectData) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *CloudConnectData) GetData() []*MetricData {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.cloud_connect.CloudConnectState", CloudConnectState_name, CloudConnectState_value)
	golang_proto.RegisterEnum("ves.io.schema.cloud_connect.CloudConnectState", CloudConnectState_name, CloudConnectState_value)
	proto.RegisterEnum("ves.io.schema.cloud_connect.CloudConnectVPCStateType", CloudConnectVPCStateType_name, CloudConnectVPCStateType_value)
	golang_proto.RegisterEnum("ves.io.schema.cloud_connect.CloudConnectVPCStateType", CloudConnectVPCStateType_name, CloudConnectVPCStateType_value)
	proto.RegisterEnum("ves.io.schema.cloud_connect.CloudConnectProviderType", CloudConnectProviderType_name, CloudConnectProviderType_value)
	golang_proto.RegisterEnum("ves.io.schema.cloud_connect.CloudConnectProviderType", CloudConnectProviderType_name, CloudConnectProviderType_value)
	proto.RegisterEnum("ves.io.schema.cloud_connect.Label", Label_name, Label_value)
	golang_proto.RegisterEnum("ves.io.schema.cloud_connect.Label", Label_name, Label_value)
	proto.RegisterEnum("ves.io.schema.cloud_connect.TrafficType", TrafficType_name, TrafficType_value)
	golang_proto.RegisterEnum("ves.io.schema.cloud_connect.TrafficType", TrafficType_name, TrafficType_value)
	proto.RegisterEnum("ves.io.schema.cloud_connect.FieldSelector", FieldSelector_name, FieldSelector_value)
	golang_proto.RegisterEnum("ves.io.schema.cloud_connect.FieldSelector", FieldSelector_name, FieldSelector_value)
	proto.RegisterType((*AWSREType)(nil), "ves.io.schema.cloud_connect.AWSREType")
	golang_proto.RegisterType((*AWSREType)(nil), "ves.io.schema.cloud_connect.AWSREType")
	proto.RegisterType((*PeerType)(nil), "ves.io.schema.cloud_connect.PeerType")
	golang_proto.RegisterType((*PeerType)(nil), "ves.io.schema.cloud_connect.PeerType")
	proto.RegisterType((*CloudLinkListType)(nil), "ves.io.schema.cloud_connect.CloudLinkListType")
	golang_proto.RegisterType((*CloudLinkListType)(nil), "ves.io.schema.cloud_connect.CloudLinkListType")
	proto.RegisterType((*AWSVPCAttachmentListType)(nil), "ves.io.schema.cloud_connect.AWSVPCAttachmentListType")
	golang_proto.RegisterType((*AWSVPCAttachmentListType)(nil), "ves.io.schema.cloud_connect.AWSVPCAttachmentListType")
	proto.RegisterType((*AWSVPCAttachmentType)(nil), "ves.io.schema.cloud_connect.AWSVPCAttachmentType")
	golang_proto.RegisterType((*AWSVPCAttachmentType)(nil), "ves.io.schema.cloud_connect.AWSVPCAttachmentType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_connect.AWSVPCAttachmentType.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_connect.AWSVPCAttachmentType.LabelsEntry")
	proto.RegisterType((*AzureVnetAttachmentListType)(nil), "ves.io.schema.cloud_connect.AzureVnetAttachmentListType")
	golang_proto.RegisterType((*AzureVnetAttachmentListType)(nil), "ves.io.schema.cloud_connect.AzureVnetAttachmentListType")
	proto.RegisterType((*AzureVNETAttachmentType)(nil), "ves.io.schema.cloud_connect.AzureVNETAttachmentType")
	golang_proto.RegisterType((*AzureVNETAttachmentType)(nil), "ves.io.schema.cloud_connect.AzureVNETAttachmentType")
	proto.RegisterType((*AzureDefaultRoute)(nil), "ves.io.schema.cloud_connect.AzureDefaultRoute")
	golang_proto.RegisterType((*AzureDefaultRoute)(nil), "ves.io.schema.cloud_connect.AzureDefaultRoute")
	proto.RegisterType((*DefaultRoute)(nil), "ves.io.schema.cloud_connect.DefaultRoute")
	golang_proto.RegisterType((*DefaultRoute)(nil), "ves.io.schema.cloud_connect.DefaultRoute")
	proto.RegisterType((*AWSSubnetIDListType)(nil), "ves.io.schema.cloud_connect.AWSSubnetIDListType")
	golang_proto.RegisterType((*AWSSubnetIDListType)(nil), "ves.io.schema.cloud_connect.AWSSubnetIDListType")
	proto.RegisterType((*AWSRouteTableListType)(nil), "ves.io.schema.cloud_connect.AWSRouteTableListType")
	golang_proto.RegisterType((*AWSRouteTableListType)(nil), "ves.io.schema.cloud_connect.AWSRouteTableListType")
	proto.RegisterType((*AWSDefaultRoutesRouteTable)(nil), "ves.io.schema.cloud_connect.AWSDefaultRoutesRouteTable")
	golang_proto.RegisterType((*AWSDefaultRoutesRouteTable)(nil), "ves.io.schema.cloud_connect.AWSDefaultRoutesRouteTable")
	proto.RegisterType((*AzureRouteTables)(nil), "ves.io.schema.cloud_connect.AzureRouteTables")
	golang_proto.RegisterType((*AzureRouteTables)(nil), "ves.io.schema.cloud_connect.AzureRouteTables")
	proto.RegisterType((*AzureRouteTableWithStaticRouteListType)(nil), "ves.io.schema.cloud_connect.AzureRouteTableWithStaticRouteListType")
	golang_proto.RegisterType((*AzureRouteTableWithStaticRouteListType)(nil), "ves.io.schema.cloud_connect.AzureRouteTableWithStaticRouteListType")
	proto.RegisterType((*AzureRouteTableWithStaticRoute)(nil), "ves.io.schema.cloud_connect.AzureRouteTableWithStaticRoute")
	golang_proto.RegisterType((*AzureRouteTableWithStaticRoute)(nil), "ves.io.schema.cloud_connect.AzureRouteTableWithStaticRoute")
	proto.RegisterType((*AWSRouteTableType)(nil), "ves.io.schema.cloud_connect.AWSRouteTableType")
	golang_proto.RegisterType((*AWSRouteTableType)(nil), "ves.io.schema.cloud_connect.AWSRouteTableType")
	proto.RegisterType((*ReplaceAWSREType)(nil), "ves.io.schema.cloud_connect.ReplaceAWSREType")
	golang_proto.RegisterType((*ReplaceAWSREType)(nil), "ves.io.schema.cloud_connect.ReplaceAWSREType")
	proto.RegisterType((*AWSTGWSiteType)(nil), "ves.io.schema.cloud_connect.AWSTGWSiteType")
	golang_proto.RegisterType((*AWSTGWSiteType)(nil), "ves.io.schema.cloud_connect.AWSTGWSiteType")
	proto.RegisterType((*ReplaceAWSTGWSiteType)(nil), "ves.io.schema.cloud_connect.ReplaceAWSTGWSiteType")
	golang_proto.RegisterType((*ReplaceAWSTGWSiteType)(nil), "ves.io.schema.cloud_connect.ReplaceAWSTGWSiteType")
	proto.RegisterType((*AzureVNETSiteType)(nil), "ves.io.schema.cloud_connect.AzureVNETSiteType")
	golang_proto.RegisterType((*AzureVNETSiteType)(nil), "ves.io.schema.cloud_connect.AzureVNETSiteType")
	proto.RegisterType((*ReplaceAzureVNETSiteType)(nil), "ves.io.schema.cloud_connect.ReplaceAzureVNETSiteType")
	golang_proto.RegisterType((*ReplaceAzureVNETSiteType)(nil), "ves.io.schema.cloud_connect.ReplaceAzureVNETSiteType")
	proto.RegisterType((*CloudConnectStatusType)(nil), "ves.io.schema.cloud_connect.CloudConnectStatusType")
	golang_proto.RegisterType((*CloudConnectStatusType)(nil), "ves.io.schema.cloud_connect.CloudConnectStatusType")
	proto.RegisterType((*AWSAttachmentsListStatusType)(nil), "ves.io.schema.cloud_connect.AWSAttachmentsListStatusType")
	golang_proto.RegisterType((*AWSAttachmentsListStatusType)(nil), "ves.io.schema.cloud_connect.AWSAttachmentsListStatusType")
	proto.RegisterType((*AWSAttachmentsStatusType)(nil), "ves.io.schema.cloud_connect.AWSAttachmentsStatusType")
	golang_proto.RegisterType((*AWSAttachmentsStatusType)(nil), "ves.io.schema.cloud_connect.AWSAttachmentsStatusType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_connect.AWSAttachmentsStatusType.TagsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_connect.AWSAttachmentsStatusType.TagsEntry")
	proto.RegisterType((*SubnetStatusType)(nil), "ves.io.schema.cloud_connect.SubnetStatusType")
	golang_proto.RegisterType((*SubnetStatusType)(nil), "ves.io.schema.cloud_connect.SubnetStatusType")
	proto.RegisterType((*AzureAttachmentsListStatusType)(nil), "ves.io.schema.cloud_connect.AzureAttachmentsListStatusType")
	golang_proto.RegisterType((*AzureAttachmentsListStatusType)(nil), "ves.io.schema.cloud_connect.AzureAttachmentsListStatusType")
	proto.RegisterType((*AzureAttachmentsStatusType)(nil), "ves.io.schema.cloud_connect.AzureAttachmentsStatusType")
	golang_proto.RegisterType((*AzureAttachmentsStatusType)(nil), "ves.io.schema.cloud_connect.AzureAttachmentsStatusType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_connect.AzureAttachmentsStatusType.TagsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_connect.AzureAttachmentsStatusType.TagsEntry")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.cloud_connect.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.cloud_connect.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.cloud_connect.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.cloud_connect.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.cloud_connect.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.cloud_connect.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.cloud_connect.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.cloud_connect.GetSpecType")
	proto.RegisterType((*LabelFilter)(nil), "ves.io.schema.cloud_connect.LabelFilter")
	golang_proto.RegisterType((*LabelFilter)(nil), "ves.io.schema.cloud_connect.LabelFilter")
	proto.RegisterType((*CustomerEdge)(nil), "ves.io.schema.cloud_connect.CustomerEdge")
	golang_proto.RegisterType((*CustomerEdge)(nil), "ves.io.schema.cloud_connect.CustomerEdge")
	proto.RegisterType((*MetricData)(nil), "ves.io.schema.cloud_connect.MetricData")
	golang_proto.RegisterType((*MetricData)(nil), "ves.io.schema.cloud_connect.MetricData")
	proto.RegisterType((*SegmentationData)(nil), "ves.io.schema.cloud_connect.SegmentationData")
	golang_proto.RegisterType((*SegmentationData)(nil), "ves.io.schema.cloud_connect.SegmentationData")
	proto.RegisterType((*EdgeData)(nil), "ves.io.schema.cloud_connect.EdgeData")
	golang_proto.RegisterType((*EdgeData)(nil), "ves.io.schema.cloud_connect.EdgeData")
	proto.RegisterType((*CloudConnectData)(nil), "ves.io.schema.cloud_connect.CloudConnectData")
	golang_proto.RegisterType((*CloudConnectData)(nil), "ves.io.schema.cloud_connect.CloudConnectData")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_connect.CloudConnectData.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.cloud_connect.CloudConnectData.LabelsEntry")
}

func init() {
	proto.RegisterFile("ves.io/schema/cloud_connect/types.proto", fileDescriptor_245b6fb3a531fd11)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/cloud_connect/types.proto", fileDescriptor_245b6fb3a531fd11)
}

var fileDescriptor_245b6fb3a531fd11 = []byte{
	// 4083 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x3b, 0x4d, 0x6c, 0x1b, 0xd9,
	0x79, 0x7a, 0xfc, 0x13, 0xf9, 0x49, 0xa2, 0x86, 0xcf, 0x92, 0x45, 0xcb, 0x0b, 0x99, 0x61, 0xec,
	0x5d, 0x59, 0x96, 0x28, 0x5b, 0x6b, 0xaf, 0x6d, 0xed, 0xc6, 0x1b, 0x4a, 0xa4, 0x65, 0x0a, 0x5a,
	0x49, 0x19, 0xd1, 0x72, 0xd6, 0x6b, 0x9b, 0x19, 0xce, 0x3c, 0xd3, 0x53, 0x53, 0x33, 0xc4, 0xcc,
	0x90, 0xaa, 0x36, 0x51, 0xe3, 0x06, 0x68, 0x80, 0x26, 0x28, 0xba, 0xd8, 0x5e, 0x8a, 0xa6, 0x87,
	0x1e, 0x03, 0x03, 0x69, 0x4f, 0x2d, 0x90, 0xa5, 0x51, 0x18, 0x29, 0x52, 0x04, 0x46, 0x0b, 0xf8,
	0xb8, 0x87, 0x16, 0xc8, 0xca, 0x97, 0xed, 0xa9, 0x8b, 0x02, 0x05, 0x82, 0xf6, 0x52, 0xbc, 0xf7,
	0x66, 0x86, 0x33, 0x24, 0x45, 0x49, 0xb6, 0x2f, 0x5b, 0xe4, 0xa4, 0xe1, 0xfb, 0x7e, 0xdf, 0xf7,
	0xf7, 0xbe, 0xf7, 0xcd, 0x08, 0xde, 0x6a, 0x10, 0x33, 0xa3, 0xea, 0xb3, 0xa6, 0xfc, 0x80, 0x6c,
	0x49, 0xb3, 0x72, 0x55, 0xaf, 0x2b, 0x25, 0x59, 0xd7, 0x34, 0x22, 0x5b, 0xb3, 0xd6, 0x4e, 0x8d,
	0x98, 0x99, 0x9a, 0xa1, 0x5b, 0x3a, 0x3e, 0xc9, 0x11, 0x33, 0x1c, 0x31, 0xe3, 0x43, 0x1c, 0x9f,
	0xa9, 0xa8, 0xd6, 0x83, 0x7a, 0x39, 0x23, 0xeb, 0x5b, 0xb3, 0x15, 0xbd, 0xa2, 0xcf, 0x32, 0x9a,
	0x72, 0xfd, 0x3e, 0xfb, 0xc5, 0x7e, 0xb0, 0x27, 0xce, 0x6b, 0xfc, 0x54, 0x45, 0xd7, 0x2b, 0x55,
	0xd2, 0xc2, 0xb2, 0xd4, 0x2d, 0x62, 0x5a, 0xd2, 0x56, 0xcd, 0x46, 0x38, 0xdb, 0x4d, 0x2b, 0x83,
	0x94, 0x0c, 0x52, 0x51, 0x75, 0xcd, 0xab, 0xd7, 0xf8, 0x49, 0x3f, 0xaa, 0x5e, 0xb3, 0x54, 0x5d,
	0x73, 0x80, 0x13, 0x7e, 0xa0, 0xa9, 0x5a, 0xc4, 0x47, 0x7c, 0xc2, 0x0f, 0xf7, 0x82, 0xde, 0xf0,
	0x83, 0x1a, 0x52, 0x55, 0x55, 0x24, 0x8b, 0xd8, 0xd0, 0x54, 0x1b, 0x54, 0x25, 0xdb, 0x25, 0xbf,
	0xe8, 0x53, 0x9d, 0x18, 0xa6, 0x57, 0x40, 0xfa, 0x27, 0x21, 0x88, 0x65, 0x6f, 0x6d, 0x88, 0xf9,
	0xe2, 0x4e, 0x8d, 0x60, 0x09, 0x22, 0x7c, 0x73, 0x49, 0x94, 0x42, 0x93, 0x03, 0x73, 0xe9, 0x8c,
	0xdf, 0xde, 0x8c, 0x3e, 0xb3, 0x56, 0xfe, 0x03, 0x22, 0x5b, 0x22, 0xb9, 0x4f, 0x69, 0x16, 0xce,
	0x3c, 0xde, 0x1d, 0x74, 0x4c, 0x43, 0x49, 0x1f, 0x3d, 0x41, 0xe8, 0xb3, 0x27, 0x28, 0x1e, 0x45,
	0x93, 0xe8, 0x3c, 0x9a, 0x8f, 0xc8, 0xba, 0x76, 0x5f, 0xad, 0x88, 0x36, 0x63, 0x7c, 0x0f, 0x42,
	0xb2, 0x41, 0x94, 0x64, 0xe0, 0xd0, 0x02, 0xde, 0x7c, 0xbc, 0x9b, 0xb0, 0x1d, 0x6d, 0x10, 0x85,
	0x68, 0x96, 0x2a, 0x55, 0xcd, 0x2e, 0x12, 0x18, 0x5f, 0xac, 0xc0, 0x70, 0xa3, 0x26, 0x97, 0x24,
	0xcb, 0x92, 0xe4, 0x07, 0x5b, 0x44, 0xb3, 0xcc, 0x64, 0x90, 0x89, 0xba, 0x94, 0xe9, 0x11, 0x3b,
	0x99, 0xec, 0xad, 0x8d, 0xcd, 0xf5, 0xc5, 0xac, 0x4b, 0xb5, 0xa2, 0x9a, 0x16, 0x93, 0x1e, 0xfa,
	0xaa, 0x89, 0x90, 0x18, 0x6f, 0xd4, 0xe4, 0x16, 0xd0, 0xc4, 0x37, 0x61, 0x80, 0xd3, 0x57, 0x55,
	0xed, 0xa1, 0x99, 0x0c, 0x31, 0x09, 0x99, 0x9e, 0x12, 0x16, 0xe9, 0xaf, 0x15, 0x55, 0x7b, 0xd8,
	0xc6, 0x1a, 0x64, 0x07, 0x60, 0xe2, 0x13, 0x10, 0xb4, 0x2a, 0xdb, 0xc9, 0x70, 0x0a, 0x4d, 0xc6,
	0x16, 0xfa, 0x3f, 0xdf, 0x45, 0x5f, 0x52, 0x0c, 0xba, 0x86, 0x73, 0x10, 0xae, 0x11, 0x62, 0x98,
	0xc9, 0x58, 0x2a, 0x38, 0x39, 0x30, 0x77, 0xa6, 0xa7, 0xac, 0x75, 0x42, 0x0c, 0x26, 0xc2, 0xe5,
	0xc1, 0x89, 0xe7, 0xe1, 0xbf, 0xae, 0xf5, 0x5f, 0x98, 0x9e, 0x9b, 0x7e, 0x7b, 0xfa, 0xe2, 0x72,
	0x28, 0x1a, 0x11, 0xfa, 0x97, 0x43, 0xd1, 0x7e, 0x21, 0xba, 0x1c, 0x8a, 0x46, 0x85, 0x58, 0xfa,
	0xef, 0x10, 0x44, 0x1d, 0x52, 0x7c, 0x0a, 0x06, 0xac, 0xca, 0x76, 0x49, 0x52, 0x14, 0x83, 0x98,
	0x26, 0x0b, 0x88, 0x98, 0x08, 0x56, 0x65, 0x3b, 0xcb, 0x57, 0xf0, 0x09, 0x88, 0x52, 0xa6, 0x25,
	0xc9, 0xd4, 0x98, 0x37, 0x83, 0x62, 0x3f, 0xfd, 0x9d, 0x35, 0x35, 0xfc, 0x2e, 0x84, 0x34, 0x5d,
	0x21, 0xb6, 0xe5, 0xdf, 0xea, 0xaa, 0xab, 0x9b, 0x48, 0x99, 0x55, 0x5d, 0x21, 0x54, 0xa4, 0xc8,
	0x88, 0xf0, 0x14, 0x24, 0x54, 0xcd, 0x54, 0x15, 0x52, 0xaa, 0x18, 0xa4, 0x64, 0xd6, 0xcb, 0x1a,
	0xb1, 0x98, 0x85, 0x63, 0xe2, 0x30, 0x07, 0x2c, 0x19, 0x64, 0x83, 0x2d, 0xa7, 0xff, 0x18, 0x41,
	0xa2, 0xc3, 0xb0, 0xb8, 0x0a, 0xd0, 0xf2, 0x4e, 0x12, 0x31, 0x83, 0x1d, 0x26, 0xd2, 0xce, 0x3e,
	0xde, 0xf5, 0x10, 0x76, 0x86, 0xd8, 0x67, 0xff, 0xf1, 0x34, 0x18, 0xfe, 0x14, 0x05, 0x04, 0x24,
	0xc6, 0x5c, 0xaf, 0xa5, 0xeb, 0x90, 0xdc, 0x2f, 0x7a, 0xf0, 0x87, 0x10, 0xa5, 0xd1, 0x58, 0x55,
	0x4d, 0xcb, 0xd6, 0xe3, 0xc2, 0x91, 0xc2, 0x90, 0xa9, 0x35, 0x40, 0xe5, 0x46, 0x3e, 0x45, 0x41,
	0xe1, 0x11, 0x12, 0xfb, 0x1b, 0x35, 0x99, 0xb2, 0x4f, 0xff, 0x6b, 0x3f, 0x8c, 0x74, 0x43, 0xc7,
	0x32, 0x44, 0xa8, 0x4c, 0x55, 0xe1, 0x3e, 0x5b, 0x58, 0xf9, 0x5d, 0x13, 0xf5, 0x7d, 0xf6, 0x04,
	0x09, 0x51, 0xba, 0x15, 0xbe, 0xc1, 0x19, 0x45, 0xb2, 0x24, 0xca, 0x36, 0x64, 0x04, 0x92, 0xdf,
	0xa6, 0x0f, 0x6f, 0x1a, 0xa7, 0xe7, 0xd2, 0xf7, 0x26, 0x1b, 0x35, 0x79, 0xe6, 0xec, 0xe4, 0x47,
	0xd2, 0xcc, 0xc7, 0xe7, 0x67, 0xae, 0xde, 0xfd, 0xfe, 0x95, 0xdd, 0x1f, 0xb8, 0xcf, 0x17, 0x2e,
	0xef, 0x9e, 0x3d, 0x2d, 0x86, 0x1b, 0x35, 0xb9, 0xa0, 0xe0, 0x6f, 0x41, 0x7c, 0x4b, 0xd2, 0xea,
	0x52, 0xb5, 0x64, 0xe8, 0x75, 0x4b, 0xd5, 0x2a, 0xc9, 0x08, 0xf3, 0xf5, 0x48, 0xdb, 0xf6, 0xf2,
	0x5b, 0x35, 0x6b, 0xe7, 0x46, 0x9f, 0x38, 0xc4, 0xb1, 0x45, 0x8e, 0x8c, 0xd7, 0x61, 0x48, 0x21,
	0xf7, 0xa5, 0x7a, 0xd5, 0x62, 0xf4, 0x24, 0x19, 0x63, 0xd4, 0x67, 0x7b, 0x1a, 0x27, 0xc7, 0x29,
	0x28, 0x0f, 0x72, 0xa3, 0x4f, 0x1c, 0x54, 0x3c, 0xbf, 0xf1, 0x47, 0x10, 0x97, 0xeb, 0xa6, 0xa5,
	0x6f, 0xb9, 0x0a, 0x01, 0x63, 0x39, 0x77, 0x90, 0xbd, 0x19, 0x79, 0x51, 0x2a, 0x57, 0x89, 0xe3,
	0x35, 0xaa, 0x2e, 0xe7, 0xe5, 0xa8, 0xab, 0x41, 0xa4, 0x2a, 0x95, 0x49, 0xd5, 0x4c, 0x0e, 0x30,
	0x27, 0x7e, 0xeb, 0xc8, 0x4e, 0xcc, 0xac, 0x30, 0xfa, 0xbc, 0x66, 0x19, 0x3b, 0x0b, 0x63, 0x34,
	0x25, 0xff, 0xea, 0x09, 0x0a, 0x41, 0x00, 0xf5, 0xed, 0xfd, 0xf6, 0xd7, 0xc1, 0xc8, 0x4f, 0x9e,
	0xa0, 0x40, 0xb4, 0x4f, 0xb4, 0xa5, 0x8c, 0x5f, 0x85, 0x01, 0x0f, 0x3e, 0x16, 0x20, 0xf8, 0x90,
	0xec, 0xd8, 0x29, 0x48, 0x1f, 0xf1, 0x08, 0x84, 0x1b, 0x52, 0xb5, 0x4e, 0x58, 0xe2, 0xc5, 0x44,
	0xfe, 0x63, 0x3e, 0x70, 0x05, 0xcd, 0x7f, 0x19, 0x78, 0xd6, 0x44, 0x2f, 0x02, 0x80, 0x21, 0xb2,
	0xb9, 0xbe, 0x98, 0x2a, 0xe4, 0xc6, 0xa3, 0x4e, 0x3c, 0xc0, 0xbf, 0x04, 0x20, 0x6e, 0x6f, 0x29,
	0xb5, 0xf8, 0x40, 0x57, 0x65, 0x32, 0xf5, 0xcb, 0x00, 0xfc, 0x43, 0x00, 0x66, 0xda, 0xbd, 0x39,
	0x77, 0x72, 0x55, 0x4f, 0x31, 0xcf, 0x98, 0xa9, 0x6d, 0xb5, 0x5a, 0x4d, 0x95, 0x49, 0x4a, 0xd5,
	0x4c, 0x4b, 0xaa, 0x56, 0x89, 0x02, 0x2b, 0x30, 0xe1, 0xf3, 0x5e, 0x46, 0xaa, 0x72, 0x4a, 0x52,
	0xb2, 0xa8, 0x21, 0xcd, 0xb9, 0xa9, 0xb5, 0x06, 0x31, 0x0c, 0x55, 0x21, 0x29, 0xdb, 0x69, 0x29,
	0x66, 0xe6, 0xd4, 0x7d, 0xdd, 0x48, 0x49, 0xd5, 0x6a, 0xaa, 0x65, 0x74, 0x13, 0x1e, 0xc2, 0xdb,
	0x7e, 0x6e, 0x26, 0xa9, 0x12, 0xd9, 0x52, 0x1b, 0xc4, 0xc7, 0x33, 0xe3, 0xf9, 0x51, 0x52, 0x95,
	0xf4, 0x45, 0x21, 0x3c, 0x75, 0xbe, 0x87, 0x98, 0x0d, 0x87, 0x8b, 0x4f, 0xd8, 0x32, 0x9c, 0xf4,
	0x87, 0x89, 0x97, 0xad, 0x99, 0x3e, 0x27, 0x84, 0xd3, 0x71, 0xbf, 0xa0, 0xa9, 0xb1, 0x45, 0x46,
	0x90, 0x5a, 0x2c, 0xe4, 0x44, 0xd3, 0xc3, 0x6c, 0x61, 0x12, 0xe2, 0x36, 0x93, 0x92, 0xcc, 0xac,
	0x89, 0x8f, 0x3f, 0x6d, 0xa2, 0xc8, 0xf3, 0x26, 0x0a, 0xef, 0x35, 0x51, 0xe4, 0x9d, 0xe9, 0xab,
	0xd3, 0x17, 0xce, 0xff, 0xcd, 0x13, 0x84, 0x96, 0x43, 0xd1, 0x80, 0x10, 0x5c, 0x0e, 0x45, 0x83,
	0x42, 0x68, 0x39, 0x14, 0x0d, 0x09, 0xe1, 0xe5, 0x50, 0x34, 0x2c, 0x44, 0x7c, 0xc5, 0x77, 0x17,
	0x4e, 0x66, 0x3f, 0xae, 0x1b, 0x64, 0x53, 0x23, 0x56, 0x97, 0x4a, 0x72, 0x0f, 0x62, 0x0d, 0x8d,
	0x58, 0xde, 0x52, 0x72, 0xb1, 0x77, 0x14, 0x32, 0x66, 0xab, 0xf9, 0x62, 0xaf, 0x6a, 0x12, 0xa5,
	0x3c, 0x59, 0x39, 0xf9, 0x65, 0x3f, 0x8c, 0xed, 0x43, 0x82, 0x97, 0x61, 0xd8, 0xac, 0x97, 0x4d,
	0xd9, 0x50, 0x59, 0x73, 0xd1, 0x2a, 0x2d, 0xdf, 0x38, 0xb0, 0xb4, 0x88, 0x71, 0x2f, 0x65, 0x41,
	0xc1, 0x3f, 0x80, 0x7e, 0xb6, 0x0f, 0x95, 0xb7, 0x00, 0xb1, 0x05, 0xb9, 0x17, 0x8f, 0xb0, 0x11,
	0x4c, 0x3e, 0x0a, 0xd0, 0xa7, 0xf7, 0x8c, 0xf9, 0xb9, 0x2b, 0xf7, 0xee, 0xcc, 0x7e, 0x34, 0x73,
	0x67, 0xfb, 0x4e, 0xa6, 0x74, 0x67, 0xf2, 0xce, 0xd9, 0xbb, 0xe7, 0xee, 0xcc, 0xd2, 0xea, 0x94,
	0x9d, 0xb9, 0x7d, 0xd7, 0xfe, 0x7b, 0x7e, 0xe6, 0xea, 0xcc, 0xdd, 0xef, 0x9f, 0x9f, 0xbe, 0x7c,
	0x65, 0xb7, 0xb5, 0x72, 0xf7, 0xb4, 0x18, 0xa1, 0x32, 0xbb, 0x96, 0xad, 0xd0, 0x51, 0xca, 0xd6,
	0x47, 0xdd, 0xcb, 0x56, 0xe6, 0x60, 0x47, 0x78, 0x6b, 0xd7, 0x42, 0x88, 0xe6, 0x7f, 0x47, 0x05,
	0x33, 0x3a, 0x2a, 0x18, 0x2f, 0xa9, 0x8b, 0x07, 0x73, 0x6f, 0x05, 0xe5, 0x2d, 0xd5, 0x7a, 0xb0,
	0x61, 0x49, 0x96, 0x2a, 0xb3, 0xb5, 0x56, 0xaf, 0x61, 0x8b, 0xf4, 0x17, 0xb6, 0xf9, 0x4f, 0x82,
	0xcf, 0x9a, 0xe8, 0xa7, 0x41, 0x38, 0x0d, 0xc3, 0x1b, 0x1e, 0x3f, 0xd1, 0xb2, 0x91, 0xe8, 0x70,
	0x3a, 0x8c, 0x40, 0x3f, 0x8d, 0x0e, 0x0a, 0x8d, 0xb9, 0x6e, 0xfc, 0x7d, 0x55, 0x79, 0xbd, 0x55,
	0xe5, 0x4c, 0x47, 0x55, 0x39, 0xf6, 0xb4, 0x89, 0x42, 0xcf, 0x9b, 0x28, 0xb8, 0xd7, 0x44, 0xc1,
	0x8b, 0xd3, 0xef, 0xd8, 0x25, 0x85, 0x17, 0x93, 0xb0, 0x10, 0x49, 0xff, 0x37, 0x82, 0x44, 0x47,
	0x94, 0xe1, 0x6f, 0x83, 0xd0, 0x6e, 0x41, 0xbb, 0xad, 0xdf, 0x2f, 0xda, 0xe3, 0x52, 0xb5, 0xea,
	0xd9, 0x16, 0x26, 0x70, 0xbc, 0xbb, 0xd5, 0xec, 0xac, 0x99, 0x39, 0x4a, 0x64, 0x9a, 0x37, 0xfa,
	0xc4, 0x11, 0x97, 0x9d, 0x67, 0x7d, 0xe1, 0x1c, 0x8c, 0xf8, 0x5c, 0xe5, 0xdd, 0x37, 0x72, 0xf6,
	0x7d, 0x61, 0xfa, 0x62, 0xc7, 0xbe, 0x1f, 0x05, 0x60, 0xf0, 0x35, 0x6f, 0x59, 0x3f, 0x60, 0xcb,
	0x97, 0x0f, 0x3a, 0xf9, 0xbd, 0xfa, 0x98, 0x2d, 0xce, 0xaf, 0x6b, 0xf3, 0xde, 0x73, 0x84, 0x9a,
	0xe0, 0xef, 0x11, 0x1c, 0xcb, 0xde, 0xda, 0xe0, 0xed, 0x70, 0x21, 0xe7, 0x1e, 0x17, 0x3f, 0x46,
	0x00, 0xbc, 0x75, 0x2e, 0xa9, 0x8a, 0xc9, 0x0e, 0x8c, 0xd8, 0x42, 0xe5, 0xb3, 0x27, 0x08, 0xdb,
	0x2d, 0x6d, 0x5b, 0xa1, 0xcd, 0x7c, 0x8a, 0xce, 0xa5, 0xcf, 0x1a, 0x6f, 0xcd, 0x9d, 0xb9, 0x37,
	0xc9, 0xe9, 0x7a, 0xb6, 0x81, 0x6e, 0x27, 0x1c, 0x72, 0x9e, 0xa2, 0xc8, 0x79, 0x4a, 0x22, 0x31,
	0xc6, 0x59, 0x14, 0x14, 0x73, 0x7e, 0xf4, 0x57, 0x4d, 0x94, 0x80, 0x61, 0x00, 0xae, 0x62, 0xaa,
	0x90, 0x33, 0x31, 0xba, 0x90, 0xfe, 0x39, 0x82, 0xd1, 0xae, 0xcd, 0x17, 0x36, 0x60, 0xb0, 0xcd,
	0x7f, 0xc1, 0x83, 0x4b, 0xac, 0x97, 0x13, 0xab, 0x77, 0xa7, 0xdc, 0x53, 0xee, 0x37, 0xa8, 0xab,
	0x8a, 0x03, 0x46, 0xcb, 0x09, 0xf3, 0x27, 0x7f, 0xd5, 0x44, 0x63, 0x30, 0xda, 0xaa, 0x63, 0x76,
	0x34, 0xa0, 0x0b, 0x93, 0x28, 0xfd, 0xd7, 0x08, 0xc6, 0xf7, 0x77, 0x2c, 0xfe, 0x23, 0x68, 0x4b,
	0x6d, 0xdb, 0xd8, 0xdf, 0xb5, 0xcf, 0xb5, 0x7d, 0x0c, 0xce, 0xd5, 0xe8, 0xd6, 0x82, 0x1b, 0x56,
	0xb9, 0x77, 0x0b, 0x3e, 0xd8, 0x52, 0xbd, 0xa0, 0x50, 0x4b, 0x0a, 0xed, 0xa9, 0x86, 0xff, 0x02,
	0xed, 0xa3, 0xd5, 0xd6, 0x61, 0xb5, 0x6a, 0x9d, 0xbc, 0xf3, 0xc6, 0x95, 0xb9, 0x77, 0x3a, 0x4f,
	0x5e, 0xae, 0x67, 0xfb, 0xb9, 0xfb, 0x8e, 0xff, 0xdc, 0xf5, 0xab, 0xfa, 0xcf, 0x08, 0xde, 0x3c,
	0xdc, 0x79, 0x85, 0x7f, 0xd8, 0x35, 0x0a, 0xde, 0x7d, 0x85, 0xa3, 0xf0, 0x75, 0x86, 0xc4, 0xf3,
	0x00, 0x4c, 0xf4, 0x96, 0x86, 0xff, 0xb4, 0x9b, 0x07, 0xbc, 0xfd, 0xce, 0x7e, 0x1e, 0x78, 0xfd,
	0x76, 0xc7, 0x22, 0x0c, 0x99, 0x4c, 0x35, 0x5e, 0x62, 0xcc, 0x64, 0x95, 0xc5, 0xc2, 0x0c, 0x95,
	0x02, 0x9f, 0xa2, 0xfe, 0x74, 0xd8, 0x08, 0xfe, 0x0e, 0xb9, 0xa6, 0x10, 0xe6, 0xba, 0x9a, 0x67,
	0xd0, 0x6c, 0x6d, 0xcf, 0x9c, 0x5f, 0x7d, 0xd6, 0x44, 0xcb, 0x70, 0x1a, 0x04, 0x9f, 0x7d, 0x68,
	0x6b, 0x20, 0xb4, 0x6f, 0x1c, 0xd2, 0x30, 0xc4, 0x4d, 0xc3, 0xcf, 0x39, 0x73, 0x21, 0xd1, 0xa6,
	0x90, 0x00, 0xe9, 0x5f, 0x04, 0x20, 0xd1, 0x91, 0xc6, 0xd8, 0xda, 0xc7, 0x88, 0xab, 0xbd, 0x8d,
	0xf8, 0x6a, 0x29, 0xf5, 0xb5, 0xb0, 0xd7, 0x23, 0x04, 0x82, 0x48, 0x6a, 0x55, 0x49, 0x26, 0xad,
	0xf9, 0xdd, 0xbd, 0xd7, 0x3b, 0xfc, 0x6a, 0x1f, 0x7b, 0xcd, 0x0f, 0x3e, 0xbb, 0xd6, 0x9a, 0x16,
	0xa6, 0x9b, 0x01, 0x88, 0x67, 0x6f, 0x6d, 0x14, 0x97, 0x6e, 0x6d, 0xa8, 0x16, 0xf7, 0xd7, 0x5d,
	0x08, 0x99, 0xaa, 0x45, 0x8e, 0x38, 0x3e, 0x94, 0xb6, 0xcd, 0x92, 0x55, 0xd9, 0x2e, 0x51, 0xd2,
	0x7d, 0xc6, 0x87, 0x8c, 0xed, 0xff, 0x8f, 0xe1, 0x21, 0xbf, 0x01, 0xa6, 0x3f, 0x41, 0x30, 0xda,
	0x72, 0xa0, 0xd7, 0x88, 0xaf, 0x5d, 0x8b, 0xe7, 0x5d, 0xb4, 0x98, 0x4f, 0x3c, 0xbb, 0xd6, 0xe6,
	0x3d, 0xea, 0xd0, 0x84, 0x7b, 0x07, 0x74, 0xd5, 0xf9, 0xde, 0x91, 0x7d, 0x3a, 0xf9, 0x78, 0x77,
	0x58, 0xa2, 0x7c, 0x4a, 0xec, 0x8e, 0x70, 0xa0, 0x5b, 0x37, 0x8e, 0xec, 0xd6, 0x93, 0xdd, 0xdc,
	0xea, 0xcc, 0x3a, 0xb9, 0x2f, 0x55, 0x10, 0x98, 0x74, 0xaf, 0x19, 0xc3, 0x4c, 0xc0, 0x95, 0x43,
	0xdc, 0x9b, 0xbb, 0x5e, 0xc2, 0x6d, 0x7f, 0x0e, 0x37, 0x7c, 0x50, 0xc7, 0xa1, 0x3f, 0x43, 0x90,
	0x74, 0x1c, 0xda, 0x61, 0xc4, 0x6e, 0xda, 0x04, 0x5f, 0x55, 0x9b, 0xe7, 0xdd, 0xb4, 0x99, 0x1f,
	0x79, 0x76, 0xad, 0xd3, 0x8b, 0xe9, 0xbf, 0x0d, 0xc0, 0x71, 0x36, 0x29, 0x5d, 0xe4, 0x9c, 0x69,
	0x81, 0xa9, 0x9b, 0x4c, 0xb7, 0x1a, 0x1c, 0xf7, 0x09, 0x2d, 0xd1, 0x7c, 0x64, 0x2e, 0xe7, 0x0e,
	0xb9, 0x7a, 0x50, 0xd8, 0x79, 0xa4, 0x53, 0xe5, 0x5a, 0xac, 0x6f, 0xf4, 0x89, 0xc7, 0x64, 0x8f,
	0xd0, 0xec, 0xb6, 0x49, 0x15, 0xc2, 0x0d, 0x48, 0xb6, 0x49, 0x64, 0xd1, 0xc2, 0x64, 0x72, 0xab,
	0x1c, 0xe2, 0xa4, 0xef, 0x25, 0x75, 0xd4, 0x27, 0x95, 0x62, 0x53, 0xb9, 0x0b, 0xa7, 0xdb, 0xe5,
	0x2a, 0xa4, 0x56, 0xd5, 0x77, 0x28, 0x0f, 0x1c, 0xa5, 0xd6, 0xb4, 0xbb, 0x6c, 0x24, 0x04, 0xd2,
	0x3f, 0x42, 0xf0, 0x46, 0xaf, 0xbd, 0xe1, 0x32, 0x24, 0x5a, 0xde, 0x2c, 0x99, 0x0c, 0x60, 0xf7,
	0x29, 0x97, 0x8e, 0x60, 0xb1, 0x16, 0x47, 0x51, 0x68, 0xf1, 0xe3, 0xab, 0xe9, 0xff, 0x8d, 0xb0,
	0xe1, 0x72, 0x57, 0x74, 0x3c, 0x05, 0x09, 0x36, 0xa1, 0x6f, 0x29, 0xe1, 0x0c, 0x55, 0xc4, 0x61,
	0xab, 0xb2, 0xdd, 0x22, 0x2a, 0x28, 0xf8, 0x7d, 0x18, 0x92, 0x0d, 0x22, 0xb1, 0x9b, 0xbc, 0xa5,
	0x6e, 0x39, 0xd9, 0x3c, 0x9e, 0xe1, 0x2f, 0xc1, 0x32, 0xce, 0x4b, 0xb0, 0x4c, 0xd1, 0x79, 0x09,
	0x26, 0x0e, 0x3a, 0x04, 0x74, 0x09, 0x8f, 0xba, 0x53, 0xe5, 0x90, 0x3d, 0x72, 0x64, 0x73, 0xe0,
	0x14, 0x0c, 0xd2, 0x65, 0x7d, 0x5b, 0x23, 0x06, 0x05, 0x86, 0xf9, 0x6b, 0x82, 0x46, 0x4d, 0x5e,
	0xa3, 0x4b, 0x05, 0x05, 0x9f, 0xe0, 0x23, 0x70, 0x59, 0x55, 0x8c, 0xe4, 0x20, 0x83, 0xf6, 0x37,
	0x6a, 0xf2, 0xa2, 0xaa, 0x18, 0xb8, 0x02, 0x23, 0x14, 0xd4, 0x72, 0x02, 0xb3, 0x22, 0x49, 0x0e,
	0xa4, 0xd0, 0x64, 0xfc, 0x00, 0x23, 0x7a, 0x63, 0x79, 0x73, 0x7d, 0x91, 0x9a, 0x85, 0xbf, 0x44,
	0xc0, 0x8d, 0x9a, 0x9c, 0x73, 0x39, 0xb2, 0x75, 0x7c, 0x0e, 0x12, 0x6d, 0x42, 0xea, 0x66, 0xb2,
	0x9f, 0x29, 0x23, 0x28, 0x3e, 0xdc, 0xba, 0x49, 0xab, 0x91, 0x25, 0x55, 0xcc, 0x64, 0x94, 0xb9,
	0xf2, 0xfd, 0x97, 0x72, 0x65, 0xa6, 0x28, 0x55, 0xf8, 0xf0, 0x56, 0x64, 0xcc, 0xf0, 0x12, 0xf4,
	0xf3, 0x3b, 0x91, 0x99, 0x04, 0xc6, 0xb7, 0xf7, 0xdd, 0x99, 0x5f, 0x96, 0x3c, 0xa1, 0xe1, 0x50,
	0xe3, 0xbb, 0x20, 0xb8, 0x23, 0x13, 0xa7, 0x3d, 0x89, 0xbd, 0xec, 0xa4, 0x9b, 0xbd, 0x50, 0xe1,
	0xbc, 0x78, 0xa7, 0x31, 0x7e, 0x19, 0x62, 0xae, 0xea, 0x47, 0x9a, 0x3b, 0xff, 0x1a, 0x3d, 0x6b,
	0xa2, 0xa7, 0xa8, 0xeb, 0xdc, 0xf9, 0x34, 0x0c, 0xb5, 0xac, 0x44, 0x41, 0xc7, 0xba, 0x44, 0x2e,
	0x60, 0x08, 0x2d, 0x16, 0x72, 0xe2, 0x38, 0xb4, 0x02, 0x06, 0xbe, 0x09, 0x09, 0xca, 0x8d, 0xc5,
	0x52, 0x2a, 0x2b, 0xcb, 0x7a, 0x5d, 0xb3, 0xc6, 0xe3, 0xfe, 0x98, 0x83, 0x6f, 0x40, 0x98, 0xb9,
	0x79, 0x3c, 0xd9, 0x3d, 0x9e, 0x52, 0x08, 0x26, 0x21, 0xd1, 0x8a, 0x89, 0x14, 0xb7, 0x2b, 0xd5,
	0xa2, 0x23, 0x2a, 0xdc, 0xcb, 0x75, 0x44, 0xe8, 0x4f, 0xbf, 0x08, 0x82, 0xd0, 0xee, 0x09, 0x7c,
	0x1e, 0x46, 0x34, 0x62, 0x6d, 0xeb, 0xc6, 0xc3, 0x92, 0xaa, 0x59, 0xc4, 0xb8, 0x2f, 0xc9, 0xad,
	0xc6, 0x54, 0xc4, 0x36, 0xac, 0xe0, 0x80, 0x0a, 0x0a, 0x3e, 0x03, 0xf1, 0x16, 0xa6, 0xb5, 0x53,
	0x73, 0xac, 0x37, 0xe4, 0xae, 0x3a, 0x8c, 0x6b, 0x86, 0xda, 0x90, 0x2c, 0x52, 0x52, 0x6b, 0x8d,
	0x8b, 0xee, 0x9b, 0xb7, 0x20, 0x67, 0x6c, 0xc3, 0x0a, 0xb5, 0xc6, 0x45, 0xe7, 0x0d, 0xdc, 0x39,
	0x48, 0x48, 0x0d, 0x49, 0xad, 0x4a, 0x65, 0xb5, 0xaa, 0x5a, 0x3b, 0xa5, 0x8f, 0x75, 0x8d, 0xd8,
	0xe9, 0x29, 0x78, 0x01, 0xb7, 0x75, 0x8d, 0xe0, 0x93, 0x10, 0x73, 0x07, 0x02, 0x76, 0x9a, 0x46,
	0x9d, 0x6b, 0x3a, 0x3e, 0x0e, 0x11, 0x3b, 0x2b, 0x22, 0x0c, 0x62, 0xff, 0x9a, 0xff, 0x82, 0x7a,
	0xf5, 0xdf, 0x10, 0x64, 0x60, 0x64, 0x95, 0x6f, 0x2c, 0xe5, 0xee, 0x8c, 0x3a, 0xf2, 0x78, 0x77,
	0x63, 0x40, 0x1a, 0xe2, 0x2d, 0x3c, 0xba, 0x3b, 0xda, 0xe5, 0xfa, 0x8d, 0x40, 0x79, 0xae, 0xf3,
	0x3d, 0xa5, 0x0a, 0xeb, 0x9b, 0x17, 0x53, 0xf6, 0xae, 0x28, 0xcf, 0x6e, 0x76, 0xa0, 0x3e, 0xcc,
	0x7a, 0x36, 0x95, 0xa2, 0xbb, 0xa2, 0x3e, 0xec, 0x30, 0x01, 0x24, 0x21, 0xe6, 0x4e, 0x1b, 0xc6,
	0x07, 0x3c, 0xfb, 0xa6, 0xd1, 0x69, 0x3b, 0x3f, 0xea, 0xec, 0x38, 0xfd, 0x63, 0x64, 0x5f, 0xe6,
	0xf6, 0x2f, 0xf5, 0xca, 0xfe, 0xa5, 0xfe, 0xf2, 0x91, 0x0e, 0xaa, 0x9e, 0xc5, 0xfe, 0x2f, 0x01,
	0xc6, 0xf7, 0x27, 0xc0, 0xd3, 0x80, 0xdb, 0x5a, 0x88, 0x56, 0xbd, 0x17, 0xfc, 0x4d, 0x40, 0x41,
	0xc1, 0x73, 0x30, 0x6a, 0xd6, 0xf4, 0x87, 0xec, 0x05, 0xaa, 0x6f, 0x72, 0x3f, 0xcc, 0x08, 0x8e,
	0x31, 0xe0, 0x86, 0x7f, 0x36, 0x9f, 0x86, 0x21, 0x4e, 0xe3, 0x4c, 0xe8, 0x79, 0xe8, 0x0d, 0xb0,
	0xc5, 0x4d, 0x1e, 0x29, 0x69, 0x18, 0x7a, 0x50, 0x2f, 0x73, 0x0c, 0x4d, 0xda, 0x72, 0xe2, 0x6d,
	0xe0, 0x41, 0xbd, 0x4c, 0x31, 0x56, 0xa5, 0x2d, 0x82, 0x2f, 0xc1, 0x98, 0x8b, 0x63, 0x10, 0x53,
	0xaf, 0x1b, 0x32, 0x29, 0x55, 0x0c, 0xbd, 0x5e, 0x4b, 0x0a, 0x0c, 0x7b, 0xc4, 0xc6, 0x16, 0x6d,
	0xe0, 0x12, 0x85, 0xe1, 0x2b, 0x90, 0xa4, 0x64, 0x3c, 0xaf, 0xbd, 0x6a, 0xbb, 0x01, 0x7b, 0xfc,
	0x41, 0xbd, 0xcc, 0x6a, 0xc1, 0x86, 0x0f, 0x8a, 0xbf, 0x09, 0x43, 0x35, 0x42, 0x0c, 0x55, 0xab,
	0xd8, 0x27, 0x08, 0x8f, 0xe2, 0x41, 0x7b, 0x91, 0x1f, 0x02, 0x33, 0x80, 0x6b, 0x86, 0xde, 0x50,
	0x4d, 0x4a, 0xe3, 0x62, 0xf2, 0x53, 0x20, 0xe1, 0x85, 0xf4, 0x38, 0x33, 0xa2, 0xfb, 0x9c, 0x19,
	0xd3, 0x80, 0x5d, 0x05, 0x76, 0x34, 0xb9, 0x54, 0x25, 0x0d, 0x52, 0x65, 0x75, 0x39, 0x26, 0x0a,
	0x8e, 0x16, 0x3b, 0x9a, 0xbc, 0x42, 0xd7, 0xf1, 0x4d, 0xfb, 0x84, 0xe1, 0x27, 0x41, 0xf6, 0x25,
	0x23, 0xa8, 0xd7, 0x19, 0x33, 0xf0, 0x4a, 0x67, 0x8c, 0xd6, 0xe5, 0x8c, 0x19, 0x7c, 0x6d, 0xef,
	0x22, 0x3a, 0x0e, 0x1d, 0x5a, 0x9a, 0x58, 0xac, 0xb0, 0x1e, 0x21, 0xce, 0x4b, 0x13, 0x5d, 0xa0,
	0x4d, 0xc2, 0xcb, 0x9f, 0x48, 0xff, 0x14, 0x7c, 0xd6, 0x44, 0xff, 0x18, 0x84, 0x14, 0x0c, 0x6d,
	0xd0, 0x00, 0x4e, 0x39, 0xef, 0x2e, 0x86, 0xdb, 0xc2, 0x1c, 0x66, 0x00, 0x73, 0x0c, 0x6f, 0x58,
	0x8d, 0x8f, 0xed, 0x93, 0x41, 0x94, 0xe1, 0x8d, 0x7a, 0x99, 0xb3, 0xa3, 0xf1, 0x4e, 0x19, 0xfa,
	0x72, 0x02, 0x2e, 0xc2, 0x98, 0x8b, 0xe1, 0xc4, 0x78, 0x8a, 0x05, 0xf9, 0xf8, 0x89, 0x7d, 0x73,
	0x03, 0xde, 0x86, 0x51, 0x97, 0xca, 0xa7, 0xc9, 0xf8, 0xfe, 0x89, 0x01, 0x67, 0xda, 0xcf, 0xd6,
	0x91, 0x6e, 0x65, 0x82, 0xea, 0xbc, 0xce, 0xc3, 0x30, 0xc5, 0xcf, 0xca, 0xe1, 0xb6, 0x94, 0x81,
	0x29, 0xc0, 0xeb, 0x9e, 0x24, 0xb0, 0xd1, 0x46, 0xba, 0x25, 0x0d, 0xc3, 0x75, 0xb8, 0xed, 0x68,
	0x72, 0x8a, 0x85, 0x35, 0xc3, 0xed, 0x48, 0x82, 0xc3, 0x1f, 0xbd, 0x70, 0xcc, 0x6e, 0x00, 0x06,
	0x3c, 0xe1, 0x60, 0x37, 0xe3, 0xff, 0x19, 0x81, 0xf8, 0x52, 0x55, 0x2f, 0x4b, 0xd5, 0x8d, 0x1a,
	0x91, 0x59, 0x39, 0xcc, 0x43, 0x84, 0xde, 0x53, 0x0c, 0xe7, 0x96, 0xf2, 0xe6, 0x81, 0xed, 0x4f,
	0xde, 0xf7, 0x26, 0x2c, 0x2c, 0x6d, 0x9b, 0x22, 0xc1, 0x6b, 0xe0, 0x1b, 0x3f, 0xb0, 0x7a, 0x30,
	0x30, 0x77, 0xee, 0x20, 0x66, 0x9e, 0x6b, 0xf3, 0x8d, 0x3e, 0x11, 0xa4, 0x6d, 0xb3, 0x58, 0xd9,
	0x66, 0x77, 0x9b, 0xef, 0x42, 0xfb, 0xdd, 0x37, 0x79, 0xec, 0xb0, 0x6f, 0x09, 0xbd, 0x37, 0xb6,
	0x1b, 0x7d, 0xe2, 0x90, 0xe4, 0xdc, 0xfe, 0x18, 0xe7, 0xdb, 0xd0, 0x6f, 0x92, 0x0a, 0xb5, 0x58,
	0x72, 0xe8, 0xd0, 0x37, 0xe5, 0x37, 0x1e, 0xef, 0x3a, 0x54, 0x5d, 0xee, 0xdf, 0x0e, 0x08, 0x67,
	0x41, 0x28, 0x4b, 0x9a, 0xb2, 0xad, 0x2a, 0xd6, 0x83, 0xd2, 0xa5, 0xf3, 0xe7, 0xb7, 0xca, 0x4e,
	0x5b, 0xd9, 0xfd, 0xcd, 0x09, 0x12, 0x87, 0x5d, 0x7c, 0x8e, 0x8e, 0x17, 0x20, 0x4c, 0x77, 0x4b,
	0x4b, 0x05, 0x2d, 0x3e, 0x6f, 0xb4, 0xd1, 0xf9, 0xd5, 0x8a, 0x3f, 0xde, 0x65, 0x77, 0x7f, 0xf7,
	0xfb, 0x24, 0x46, 0x8a, 0xbf, 0x07, 0xc3, 0x0d, 0xd5, 0xb0, 0xea, 0x52, 0xb5, 0x64, 0xf7, 0x15,
	0xc9, 0xf8, 0x21, 0xb8, 0x9d, 0x78, 0xbc, 0xdb, 0x4e, 0xe7, 0x30, 0x8e, 0xdb, 0xeb, 0x76, 0xfb,
	0x82, 0x73, 0x10, 0xe6, 0x85, 0x7f, 0x98, 0x5d, 0x32, 0x32, 0x87, 0xbe, 0x64, 0xb0, 0x7c, 0x10,
	0x39, 0x31, 0x3e, 0x0b, 0x43, 0xba, 0x56, 0xd6, 0x25, 0x43, 0x21, 0x4a, 0xa9, 0x51, 0x93, 0x93,
	0x89, 0x14, 0x9a, 0x1c, 0xe2, 0xb1, 0x25, 0x0e, 0xba, 0xa0, 0xcd, 0x9a, 0x8c, 0x97, 0x60, 0x40,
	0xd6, 0x75, 0x43, 0x51, 0x35, 0x89, 0x1a, 0x07, 0x33, 0xa3, 0x9e, 0x6a, 0x13, 0x4b, 0x77, 0x9f,
	0x59, 0x6c, 0xa1, 0xd9, 0x9c, 0xbc, 0x94, 0x0b, 0xa7, 0x20, 0xcc, 0xb4, 0x63, 0x5f, 0x19, 0x04,
	0xe8, 0x6d, 0x75, 0xaf, 0x89, 0x22, 0x73, 0xd3, 0x97, 0xa7, 0x2f, 0x5c, 0xa5, 0xd8, 0x0b, 0xdf,
	0xf0, 0xfa, 0x90, 0x7f, 0x07, 0x88, 0x87, 0x9e, 0x36, 0x51, 0xec, 0x79, 0x13, 0x45, 0xf7, 0x9a,
	0x08, 0x5d, 0xe5, 0xd9, 0xe4, 0xf6, 0xb8, 0x82, 0x90, 0x68, 0xfb, 0x1c, 0x81, 0x7f, 0x11, 0x16,
	0x15, 0x62, 0xe9, 0x3f, 0x09, 0x42, 0x7c, 0x91, 0x5e, 0x00, 0x89, 0x9b, 0x71, 0xef, 0xbf, 0x5c,
	0xc6, 0x7d, 0x2d, 0x73, 0xed, 0xbd, 0x97, 0xc8, 0x35, 0x37, 0x9b, 0xd8, 0x6c, 0xcd, 0x5f, 0xae,
	0x16, 0xb0, 0xe3, 0xbd, 0xd8, 0x8f, 0xfe, 0x07, 0xf1, 0xc7, 0xc3, 0x78, 0x23, 0xfd, 0xb3, 0x20,
	0x0c, 0xdb, 0x53, 0x25, 0xd7, 0x11, 0xd7, 0xdb, 0x1c, 0xd1, 0xfb, 0x9c, 0x6f, 0x9f, 0x12, 0xb7,
	0xfc, 0xb1, 0xd9, 0xd5, 0x1f, 0x73, 0x87, 0xe4, 0xb6, 0xbf, 0x5b, 0x4a, 0xfb, 0xb9, 0xe5, 0xd2,
	0xa1, 0x58, 0x7f, 0x8d, 0xbc, 0xf3, 0x24, 0x04, 0x03, 0x4b, 0xc4, 0xfa, 0x7d, 0x8a, 0x1c, 0xd5,
	0x09, 0x5f, 0xdf, 0x3a, 0xfc, 0x3a, 0xc3, 0xe7, 0xa7, 0xc8, 0xfe, 0xd0, 0xef, 0xba, 0x5a, 0xb5,
	0x88, 0x81, 0xaf, 0x40, 0x98, 0x7d, 0x01, 0xc8, 0x1a, 0xdc, 0x78, 0x87, 0x41, 0xfd, 0x46, 0x61,
	0x84, 0x22, 0x27, 0xc0, 0xd3, 0x10, 0xd0, 0x6b, 0x2c, 0xe8, 0xe2, 0x1d, 0x67, 0xe5, 0x07, 0xc4,
	0x32, 0x54, 0x99, 0xa1, 0xaf, 0xd5, 0xc4, 0x80, 0x5e, 0x6b, 0x35, 0xcd, 0x41, 0x4f, 0xd3, 0x9c,
	0x4e, 0xc3, 0x20, 0xff, 0x28, 0x85, 0x18, 0x79, 0xa5, 0x42, 0x30, 0x86, 0x10, 0xbb, 0xe1, 0xf1,
	0x6e, 0x9b, 0x3d, 0xa7, 0x7f, 0x81, 0x00, 0x38, 0xbf, 0x9c, 0x64, 0x49, 0xf8, 0x1a, 0x84, 0xd8,
	0x40, 0x83, 0xeb, 0x3b, 0xd5, 0x53, 0xdf, 0xeb, 0x2a, 0xa9, 0x2a, 0xfc, 0xfb, 0x19, 0xdd, 0x10,
	0x19, 0x1d, 0x3e, 0x07, 0xa1, 0xba, 0xa6, 0x5a, 0xb6, 0xe2, 0x63, 0x6d, 0xf4, 0x37, 0x35, 0x95,
	0xdf, 0x18, 0x18, 0x12, 0x9e, 0x83, 0x08, 0x53, 0xd4, 0x4c, 0x06, 0x59, 0x4f, 0x30, 0xde, 0x75,
	0x9f, 0x9b, 0x14, 0x45, 0xb4, 0x31, 0xd3, 0x7f, 0x86, 0x40, 0xd8, 0xe0, 0x21, 0xc7, 0x66, 0x99,
	0x4c, 0xeb, 0xf7, 0x7c, 0x5a, 0x4f, 0xf6, 0xd4, 0xba, 0x68, 0x48, 0xf7, 0xef, 0xab, 0x32, 0x57,
	0x83, 0xe9, 0xfc, 0x2e, 0x84, 0x14, 0xc9, 0x92, 0x92, 0x01, 0xa6, 0xc4, 0x5b, 0x3d, 0xa9, 0x5b,
	0xa6, 0x12, 0x19, 0x51, 0xfa, 0x13, 0x04, 0x51, 0x6a, 0x5c, 0xa6, 0xc7, 0x55, 0x08, 0xc8, 0xce,
	0x24, 0xb6, 0xf7, 0xa7, 0xaf, 0x5e, 0xbf, 0x88, 0x01, 0x99, 0xe0, 0x02, 0x44, 0xed, 0x4c, 0x32,
	0x6d, 0x45, 0x0e, 0xb8, 0xec, 0xb5, 0xd9, 0x40, 0x74, 0xc9, 0xd3, 0xff, 0x8e, 0x40, 0xf0, 0x26,
	0x18, 0x53, 0xed, 0x3b, 0xee, 0x17, 0xaf, 0x7c, 0xcc, 0x71, 0xf5, 0xd0, 0xf9, 0x49, 0xc9, 0xbd,
	0x5f, 0xbb, 0x3a, 0x1f, 0xb5, 0xbe, 0x92, 0xdd, 0x5e, 0xe1, 0x8b, 0xd8, 0xa9, 0xb7, 0xed, 0x4f,
	0xc4, 0xbd, 0xf5, 0x03, 0x47, 0x21, 0x94, 0x5b, 0xbb, 0xb5, 0x2a, 0xf4, 0xe1, 0x41, 0x88, 0xe6,
	0xf2, 0x4b, 0x62, 0x36, 0x97, 0xcf, 0x09, 0x08, 0x47, 0x20, 0x70, 0x73, 0x5d, 0x08, 0x4c, 0xdd,
	0x85, 0xe4, 0x7e, 0x13, 0x66, 0x3c, 0x04, 0xb1, 0xec, 0x66, 0xb6, 0xb0, 0x92, 0x5d, 0x58, 0xc9,
	0x0b, 0x7d, 0x78, 0x00, 0xfa, 0xd7, 0xf3, 0xab, 0xb9, 0xc2, 0xea, 0x92, 0x80, 0x30, 0x40, 0xe4,
	0x7a, 0xb6, 0xb0, 0x92, 0xcf, 0x09, 0x01, 0x0a, 0xc8, 0xe5, 0x57, 0xf2, 0xc5, 0x7c, 0x4e, 0x08,
	0x72, 0x31, 0x2b, 0xf9, 0x22, 0x45, 0x0b, 0x4d, 0x5d, 0xf6, 0xb3, 0x67, 0x17, 0x2f, 0xc5, 0xfe,
	0xf0, 0xbe, 0x1f, 0x82, 0xd9, 0x5b, 0x1b, 0x42, 0x1f, 0x8e, 0x41, 0x38, 0x7b, 0xfb, 0xa6, 0x98,
	0x17, 0x10, 0x5d, 0x5b, 0x5a, 0xa4, 0x7a, 0x15, 0x20, 0xcc, 0xec, 0x80, 0xe3, 0x00, 0x2b, 0xd9,
	0x85, 0xfc, 0x4a, 0x69, 0x75, 0x6d, 0x95, 0x6a, 0x31, 0x06, 0xc7, 0xf8, 0xef, 0xc5, 0x9b, 0x1b,
	0xc5, 0xb5, 0x0f, 0xf2, 0x62, 0x29, 0x9f, 0x5b, 0xa2, 0xa4, 0x2d, 0xc0, 0xca, 0xda, 0xcd, 0x5c,
	0x69, 0x71, 0x6d, 0x75, 0x35, 0xbf, 0x58, 0x14, 0x02, 0x53, 0x3f, 0x84, 0x01, 0x4f, 0x70, 0xe3,
	0x51, 0x48, 0x14, 0xc5, 0xec, 0xf5, 0xeb, 0x85, 0xc5, 0x52, 0xf1, 0xc3, 0xf5, 0xbc, 0xc3, 0x77,
	0x02, 0xc6, 0x7d, 0xcb, 0x85, 0xd5, 0x62, 0x5e, 0x2c, 0x6d, 0xe4, 0x97, 0x3e, 0xc8, 0xaf, 0x16,
	0x05, 0xd4, 0x0d, 0x2e, 0x66, 0x5d, 0x78, 0x00, 0x9f, 0x80, 0xd1, 0x4e, 0xfa, 0xd5, 0x7c, 0x51,
	0x08, 0x4e, 0x6d, 0xc3, 0x90, 0xaf, 0x26, 0xe0, 0x11, 0x10, 0x3e, 0xc8, 0x17, 0xc5, 0x36, 0x0d,
	0x92, 0x30, 0xe2, 0x5d, 0x2d, 0xac, 0x96, 0x16, 0x3e, 0x2c, 0xe6, 0x37, 0x04, 0x44, 0x79, 0x7b,
	0x21, 0x6b, 0x37, 0x8b, 0x36, 0x28, 0x80, 0x4f, 0xc2, 0x98, 0x17, 0x54, 0x5c, 0x2b, 0x66, 0x57,
	0x6c, 0x60, 0x70, 0xe1, 0xcf, 0xd1, 0xf3, 0x2f, 0x26, 0xfa, 0x3e, 0xff, 0x62, 0xa2, 0xef, 0xab,
	0x2f, 0x26, 0xd0, 0xa3, 0xbd, 0x09, 0xf4, 0xf3, 0xbd, 0x09, 0xf4, 0x9b, 0xbd, 0x09, 0xf4, 0x7c,
	0x6f, 0x02, 0x7d, 0xbe, 0x37, 0x81, 0x7e, 0xbb, 0x37, 0x81, 0xbe, 0xdc, 0x9b, 0xe8, 0xfb, 0x6a,
	0x6f, 0x02, 0x7d, 0xf2, 0x62, 0xa2, 0xef, 0xe9, 0x8b, 0x09, 0xf4, 0xfc, 0xc5, 0x44, 0xdf, 0xe7,
	0x2f, 0x26, 0xfa, 0x6e, 0x7f, 0xa7, 0xa2, 0xd7, 0x1e, 0x56, 0x32, 0x0d, 0x9d, 0xd6, 0x6c, 0x43,
	0xca, 0xd4, 0xcd, 0x59, 0xf6, 0x70, 0x5f, 0x37, 0xb6, 0x66, 0x6a, 0xb6, 0x2b, 0x67, 0x1c, 0xf0,
	0x6c, 0xad, 0x5c, 0xd1, 0x67, 0xc9, 0x1f, 0x5a, 0xce, 0xbf, 0xff, 0x74, 0xf9, 0x1f, 0xa7, 0x72,
	0x84, 0xbd, 0x7f, 0x79, 0xfb, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0xba, 0xe0, 0xc8, 0xd9, 0x09,
	0x35, 0x00, 0x00,
}

func (x CloudConnectState) String() string {
	s, ok := CloudConnectState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CloudConnectVPCStateType) String() string {
	s, ok := CloudConnectVPCStateType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CloudConnectProviderType) String() string {
	s, ok := CloudConnectProviderType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Label) String() string {
	s, ok := Label_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TrafficType) String() string {
	s, ok := TrafficType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x FieldSelector) String() string {
	s, ok := FieldSelector_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *AWSREType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSREType)
	if !ok {
		that2, ok := that.(AWSREType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Region.Equal(that1.Region) {
		return false
	}
	if !this.Cred.Equal(that1.Cred) {
		return false
	}
	if !this.VpcAttachments.Equal(that1.VpcAttachments) {
		return false
	}
	if !this.CloudLinks.Equal(that1.CloudLinks) {
		return false
	}
	if this.Tgw != that1.Tgw {
		return false
	}
	if len(this.Peers) != len(that1.Peers) {
		return false
	}
	for i := range this.Peers {
		if !this.Peers[i].Equal(that1.Peers[i]) {
			return false
		}
	}
	return true
}
func (this *PeerType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PeerType)
	if !ok {
		that2, ok := that.(PeerType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TgwAddress != that1.TgwAddress {
		return false
	}
	if this.PeerAsn != that1.PeerAsn {
		return false
	}
	if !this.Node.Equal(that1.Node) {
		return false
	}
	if this.InsideGreSubnet != that1.InsideGreSubnet {
		return false
	}
	return true
}
func (this *CloudLinkListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudLinkListType)
	if !ok {
		that2, ok := that.(CloudLinkListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.CloudLink) != len(that1.CloudLink) {
		return false
	}
	for i := range this.CloudLink {
		if !this.CloudLink[i].Equal(that1.CloudLink[i]) {
			return false
		}
	}
	return true
}
func (this *AWSVPCAttachmentListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCAttachmentListType)
	if !ok {
		that2, ok := that.(AWSVPCAttachmentListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.VpcList) != len(that1.VpcList) {
		return false
	}
	for i := range this.VpcList {
		if !this.VpcList[i].Equal(that1.VpcList[i]) {
			return false
		}
	}
	return true
}
func (this *AWSVPCAttachmentType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCAttachmentType)
	if !ok {
		that2, ok := that.(AWSVPCAttachmentType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VpcId != that1.VpcId {
		return false
	}
	if that1.RoutingChoice == nil {
		if this.RoutingChoice != nil {
			return false
		}
	} else if this.RoutingChoice == nil {
		return false
	} else if !this.RoutingChoice.Equal(that1.RoutingChoice) {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	return true
}
func (this *AWSVPCAttachmentType_ManualRouting) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCAttachmentType_ManualRouting)
	if !ok {
		that2, ok := that.(AWSVPCAttachmentType_ManualRouting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ManualRouting.Equal(that1.ManualRouting) {
		return false
	}
	return true
}
func (this *AWSVPCAttachmentType_DefaultRoute) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCAttachmentType_DefaultRoute)
	if !ok {
		that2, ok := that.(AWSVPCAttachmentType_DefaultRoute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultRoute.Equal(that1.DefaultRoute) {
		return false
	}
	return true
}
func (this *AWSVPCAttachmentType_CustomRouting) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSVPCAttachmentType_CustomRouting)
	if !ok {
		that2, ok := that.(AWSVPCAttachmentType_CustomRouting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CustomRouting.Equal(that1.CustomRouting) {
		return false
	}
	return true
}
func (this *AzureVnetAttachmentListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVnetAttachmentListType)
	if !ok {
		that2, ok := that.(AzureVnetAttachmentListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.VnetList) != len(that1.VnetList) {
		return false
	}
	for i := range this.VnetList {
		if !this.VnetList[i].Equal(that1.VnetList[i]) {
			return false
		}
	}
	return true
}
func (this *AzureVNETAttachmentType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVNETAttachmentType)
	if !ok {
		that2, ok := that.(AzureVNETAttachmentType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubscriptionId != that1.SubscriptionId {
		return false
	}
	if this.VnetId != that1.VnetId {
		return false
	}
	if that1.RoutingChoice == nil {
		if this.RoutingChoice != nil {
			return false
		}
	} else if this.RoutingChoice == nil {
		return false
	} else if !this.RoutingChoice.Equal(that1.RoutingChoice) {
		return false
	}
	return true
}
func (this *AzureVNETAttachmentType_ManualRouting) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVNETAttachmentType_ManualRouting)
	if !ok {
		that2, ok := that.(AzureVNETAttachmentType_ManualRouting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ManualRouting.Equal(that1.ManualRouting) {
		return false
	}
	return true
}
func (this *AzureVNETAttachmentType_DefaultRoute) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVNETAttachmentType_DefaultRoute)
	if !ok {
		that2, ok := that.(AzureVNETAttachmentType_DefaultRoute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultRoute.Equal(that1.DefaultRoute) {
		return false
	}
	return true
}
func (this *AzureVNETAttachmentType_CustomRouting) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVNETAttachmentType_CustomRouting)
	if !ok {
		that2, ok := that.(AzureVNETAttachmentType_CustomRouting)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CustomRouting.Equal(that1.CustomRouting) {
		return false
	}
	return true
}
func (this *AzureDefaultRoute) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureDefaultRoute)
	if !ok {
		that2, ok := that.(AzureDefaultRoute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.DefaultRouteChoice == nil {
		if this.DefaultRouteChoice != nil {
			return false
		}
	} else if this.DefaultRouteChoice == nil {
		return false
	} else if !this.DefaultRouteChoice.Equal(that1.DefaultRouteChoice) {
		return false
	}
	return true
}
func (this *AzureDefaultRoute_AllRouteTables) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureDefaultRoute_AllRouteTables)
	if !ok {
		that2, ok := that.(AzureDefaultRoute_AllRouteTables)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllRouteTables.Equal(that1.AllRouteTables) {
		return false
	}
	return true
}
func (this *AzureDefaultRoute_SelectiveRouteTables) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureDefaultRoute_SelectiveRouteTables)
	if !ok {
		that2, ok := that.(AzureDefaultRoute_SelectiveRouteTables)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SelectiveRouteTables.Equal(that1.SelectiveRouteTables) {
		return false
	}
	return true
}
func (this *DefaultRoute) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DefaultRoute)
	if !ok {
		that2, ok := that.(DefaultRoute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.DefaultRouteChoice == nil {
		if this.DefaultRouteChoice != nil {
			return false
		}
	} else if this.DefaultRouteChoice == nil {
		return false
	} else if !this.DefaultRouteChoice.Equal(that1.DefaultRouteChoice) {
		return false
	}
	return true
}
func (this *DefaultRoute_AllRouteTables) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DefaultRoute_AllRouteTables)
	if !ok {
		that2, ok := that.(DefaultRoute_AllRouteTables)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllRouteTables.Equal(that1.AllRouteTables) {
		return false
	}
	return true
}
func (this *DefaultRoute_SelectiveRouteTables) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DefaultRoute_SelectiveRouteTables)
	if !ok {
		that2, ok := that.(DefaultRoute_SelectiveRouteTables)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SelectiveRouteTables.Equal(that1.SelectiveRouteTables) {
		return false
	}
	return true
}
func (this *AWSSubnetIDListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSSubnetIDListType)
	if !ok {
		that2, ok := that.(AWSSubnetIDListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SubnetIds) != len(that1.SubnetIds) {
		return false
	}
	for i := range this.SubnetIds {
		if this.SubnetIds[i] != that1.SubnetIds[i] {
			return false
		}
	}
	return true
}
func (this *AWSRouteTableListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSRouteTableListType)
	if !ok {
		that2, ok := that.(AWSRouteTableListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.RouteTables) != len(that1.RouteTables) {
		return false
	}
	for i := range this.RouteTables {
		if !this.RouteTables[i].Equal(that1.RouteTables[i]) {
			return false
		}
	}
	return true
}
func (this *AWSDefaultRoutesRouteTable) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSDefaultRoutesRouteTable)
	if !ok {
		that2, ok := that.(AWSDefaultRoutesRouteTable)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.RouteTableId) != len(that1.RouteTableId) {
		return false
	}
	for i := range this.RouteTableId {
		if this.RouteTableId[i] != that1.RouteTableId[i] {
			return false
		}
	}
	return true
}
func (this *AzureRouteTables) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureRouteTables)
	if !ok {
		that2, ok := that.(AzureRouteTables)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.RouteTableId) != len(that1.RouteTableId) {
		return false
	}
	for i := range this.RouteTableId {
		if this.RouteTableId[i] != that1.RouteTableId[i] {
			return false
		}
	}
	return true
}
func (this *AzureRouteTableWithStaticRouteListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureRouteTableWithStaticRouteListType)
	if !ok {
		that2, ok := that.(AzureRouteTableWithStaticRouteListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.RouteTables) != len(that1.RouteTables) {
		return false
	}
	for i := range this.RouteTables {
		if !this.RouteTables[i].Equal(that1.RouteTables[i]) {
			return false
		}
	}
	return true
}
func (this *AzureRouteTableWithStaticRoute) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureRouteTableWithStaticRoute)
	if !ok {
		that2, ok := that.(AzureRouteTableWithStaticRoute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RouteTableId != that1.RouteTableId {
		return false
	}
	if len(this.StaticRoutes) != len(that1.StaticRoutes) {
		return false
	}
	for i := range this.StaticRoutes {
		if this.StaticRoutes[i] != that1.StaticRoutes[i] {
			return false
		}
	}
	return true
}
func (this *AWSRouteTableType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSRouteTableType)
	if !ok {
		that2, ok := that.(AWSRouteTableType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RouteTableId != that1.RouteTableId {
		return false
	}
	if len(this.StaticRoutes) != len(that1.StaticRoutes) {
		return false
	}
	for i := range this.StaticRoutes {
		if this.StaticRoutes[i] != that1.StaticRoutes[i] {
			return false
		}
	}
	return true
}
func (this *ReplaceAWSREType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceAWSREType)
	if !ok {
		that2, ok := that.(ReplaceAWSREType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VpcAttachments.Equal(that1.VpcAttachments) {
		return false
	}
	return true
}
func (this *AWSTGWSiteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSTGWSiteType)
	if !ok {
		that2, ok := that.(AWSTGWSiteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Site.Equal(that1.Site) {
		return false
	}
	if !this.Cred.Equal(that1.Cred) {
		return false
	}
	if !this.VpcAttachments.Equal(that1.VpcAttachments) {
		return false
	}
	return true
}
func (this *ReplaceAWSTGWSiteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceAWSTGWSiteType)
	if !ok {
		that2, ok := that.(ReplaceAWSTGWSiteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VpcAttachments.Equal(that1.VpcAttachments) {
		return false
	}
	return true
}
func (this *AzureVNETSiteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureVNETSiteType)
	if !ok {
		that2, ok := that.(AzureVNETSiteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Site.Equal(that1.Site) {
		return false
	}
	if !this.Cred.Equal(that1.Cred) {
		return false
	}
	if !this.VnetAttachments.Equal(that1.VnetAttachments) {
		return false
	}
	return true
}
func (this *ReplaceAzureVNETSiteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceAzureVNETSiteType)
	if !ok {
		that2, ok := that.(ReplaceAzureVNETSiteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VnetAttachments.Equal(that1.VnetAttachments) {
		return false
	}
	return true
}
func (this *CloudConnectStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudConnectStatusType)
	if !ok {
		that2, ok := that.(CloudConnectStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.CloudConnectDeployment == nil {
		if this.CloudConnectDeployment != nil {
			return false
		}
	} else if this.CloudConnectDeployment == nil {
		return false
	} else if !this.CloudConnectDeployment.Equal(that1.CloudConnectDeployment) {
		return false
	}
	return true
}
func (this *CloudConnectStatusType_CloudConnectAwsSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudConnectStatusType_CloudConnectAwsSite)
	if !ok {
		that2, ok := that.(CloudConnectStatusType_CloudConnectAwsSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CloudConnectAwsSite.Equal(that1.CloudConnectAwsSite) {
		return false
	}
	return true
}
func (this *CloudConnectStatusType_CloudConnectAzureSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudConnectStatusType_CloudConnectAzureSite)
	if !ok {
		that2, ok := that.(CloudConnectStatusType_CloudConnectAzureSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CloudConnectAzureSite.Equal(that1.CloudConnectAzureSite) {
		return false
	}
	return true
}
func (this *AWSAttachmentsListStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSAttachmentsListStatusType)
	if !ok {
		that2, ok := that.(AWSAttachmentsListStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.AttachmentStatus) != len(that1.AttachmentStatus) {
		return false
	}
	for i := range this.AttachmentStatus {
		if !this.AttachmentStatus[i].Equal(that1.AttachmentStatus[i]) {
			return false
		}
	}
	return true
}
func (this *AWSAttachmentsStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSAttachmentsStatusType)
	if !ok {
		that2, ok := that.(AWSAttachmentsStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TgwAttachmentId != that1.TgwAttachmentId {
		return false
	}
	if !this.CreationTime.Equal(that1.CreationTime) {
		return false
	}
	if this.VpcId != that1.VpcId {
		return false
	}
	if this.VpcOwnerId != that1.VpcOwnerId {
		return false
	}
	if this.VpcCidr != that1.VpcCidr {
		return false
	}
	if this.VpcDeploymentState != that1.VpcDeploymentState {
		return false
	}
	if this.DeploymentStatus != that1.DeploymentStatus {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if len(this.Subnets) != len(that1.Subnets) {
		return false
	}
	for i := range this.Subnets {
		if !this.Subnets[i].Equal(that1.Subnets[i]) {
			return false
		}
	}
	if !this.InstalledRoutes.Equal(that1.InstalledRoutes) {
		return false
	}
	return true
}
func (this *SubnetStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubnetStatusType)
	if !ok {
		that2, ok := that.(SubnetStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NetworkInterfaceId != that1.NetworkInterfaceId {
		return false
	}
	if this.InterfaceType != that1.InterfaceType {
		return false
	}
	if this.PrivateIpv4Address != that1.PrivateIpv4Address {
		return false
	}
	if this.AvailabilityZone != that1.AvailabilityZone {
		return false
	}
	if this.SubnetId != that1.SubnetId {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *AzureAttachmentsListStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureAttachmentsListStatusType)
	if !ok {
		that2, ok := that.(AzureAttachmentsListStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.AttachmentStatus) != len(that1.AttachmentStatus) {
		return false
	}
	for i := range this.AttachmentStatus {
		if !this.AttachmentStatus[i].Equal(that1.AttachmentStatus[i]) {
			return false
		}
	}
	return true
}
func (this *AzureAttachmentsStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AzureAttachmentsStatusType)
	if !ok {
		that2, ok := that.(AzureAttachmentsStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VnetAttachmentId != that1.VnetAttachmentId {
		return false
	}
	if this.SpokeSubscriptionId != that1.SpokeSubscriptionId {
		return false
	}
	if this.SpokeVnetId != that1.SpokeVnetId {
		return false
	}
	if this.HubVnetName != that1.HubVnetName {
		return false
	}
	if this.HubVnetResourceGroup != that1.HubVnetResourceGroup {
		return false
	}
	if this.HubOwnerSubscriptionid != that1.HubOwnerSubscriptionid {
		return false
	}
	if this.PeeringState != that1.PeeringState {
		return false
	}
	if this.ProvisioningState != that1.ProvisioningState {
		return false
	}
	if this.DeploymentStatus != that1.DeploymentStatus {
		return false
	}
	if this.PeeringSyncLevel != that1.PeeringSyncLevel {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if len(this.Subnets) != len(that1.Subnets) {
		return false
	}
	for i := range this.Subnets {
		if !this.Subnets[i].Equal(that1.Subnets[i]) {
			return false
		}
	}
	if !this.InstalledRoutes.Equal(that1.InstalledRoutes) {
		return false
	}
	if this.VnetCidr != that1.VnetCidr {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Cloud == nil {
		if this.Cloud != nil {
			return false
		}
	} else if this.Cloud == nil {
		return false
	} else if !this.Cloud.Equal(that1.Cloud) {
		return false
	}
	if !this.Segment.Equal(that1.Segment) {
		return false
	}
	if that1.BandwidthOption == nil {
		if this.BandwidthOption != nil {
			return false
		}
	} else if this.BandwidthOption == nil {
		return false
	} else if !this.BandwidthOption.Equal(that1.BandwidthOption) {
		return false
	}
	if len(this.Sites) != len(that1.Sites) {
		return false
	}
	for i := range this.Sites {
		if !this.Sites[i].Equal(that1.Sites[i]) {
			return false
		}
	}
	if len(this.VirtualNetwork) != len(that1.VirtualNetwork) {
		return false
	}
	for i := range this.VirtualNetwork {
		if !this.VirtualNetwork[i].Equal(that1.VirtualNetwork[i]) {
			return false
		}
	}
	if this.State != that1.State {
		return false
	}
	if this.OnboardedVpc != that1.OnboardedVpc {
		return false
	}
	if !this.Coordinates.Equal(that1.Coordinates) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AwsRe) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AwsRe)
	if !ok {
		that2, ok := that.(GlobalSpecType_AwsRe)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsRe.Equal(that1.AwsRe) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AwsTgwSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AwsTgwSite)
	if !ok {
		that2, ok := that.(GlobalSpecType_AwsTgwSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsTgwSite.Equal(that1.AwsTgwSite) {
		return false
	}
	return true
}
func (this *GlobalSpecType_AzureVnetSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_AzureVnetSite)
	if !ok {
		that2, ok := that.(GlobalSpecType_AzureVnetSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AzureVnetSite.Equal(that1.AzureVnetSite) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Bandwidth_500Mbs) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Bandwidth_500Mbs)
	if !ok {
		that2, ok := that.(GlobalSpecType_Bandwidth_500Mbs)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Bandwidth_500Mbs.Equal(that1.Bandwidth_500Mbs) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Cloud == nil {
		if this.Cloud != nil {
			return false
		}
	} else if this.Cloud == nil {
		return false
	} else if !this.Cloud.Equal(that1.Cloud) {
		return false
	}
	if !this.Segment.Equal(that1.Segment) {
		return false
	}
	return true
}
func (this *CreateSpecType_AwsRe) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AwsRe)
	if !ok {
		that2, ok := that.(CreateSpecType_AwsRe)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsRe.Equal(that1.AwsRe) {
		return false
	}
	return true
}
func (this *CreateSpecType_AwsTgwSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AwsTgwSite)
	if !ok {
		that2, ok := that.(CreateSpecType_AwsTgwSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsTgwSite.Equal(that1.AwsTgwSite) {
		return false
	}
	return true
}
func (this *CreateSpecType_AzureVnetSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_AzureVnetSite)
	if !ok {
		that2, ok := that.(CreateSpecType_AzureVnetSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AzureVnetSite.Equal(that1.AzureVnetSite) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Cloud == nil {
		if this.Cloud != nil {
			return false
		}
	} else if this.Cloud == nil {
		return false
	} else if !this.Cloud.Equal(that1.Cloud) {
		return false
	}
	if !this.Segment.Equal(that1.Segment) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AwsRe) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AwsRe)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AwsRe)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsRe.Equal(that1.AwsRe) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AwsTgwSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AwsTgwSite)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AwsTgwSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsTgwSite.Equal(that1.AwsTgwSite) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_AzureVnetSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_AzureVnetSite)
	if !ok {
		that2, ok := that.(ReplaceSpecType_AzureVnetSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AzureVnetSite.Equal(that1.AzureVnetSite) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Cloud == nil {
		if this.Cloud != nil {
			return false
		}
	} else if this.Cloud == nil {
		return false
	} else if !this.Cloud.Equal(that1.Cloud) {
		return false
	}
	if !this.Segment.Equal(that1.Segment) {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.OnboardedVpc != that1.OnboardedVpc {
		return false
	}
	if !this.Coordinates.Equal(that1.Coordinates) {
		return false
	}
	return true
}
func (this *GetSpecType_AwsRe) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AwsRe)
	if !ok {
		that2, ok := that.(GetSpecType_AwsRe)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsRe.Equal(that1.AwsRe) {
		return false
	}
	return true
}
func (this *GetSpecType_AwsTgwSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AwsTgwSite)
	if !ok {
		that2, ok := that.(GetSpecType_AwsTgwSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsTgwSite.Equal(that1.AwsTgwSite) {
		return false
	}
	return true
}
func (this *GetSpecType_AzureVnetSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_AzureVnetSite)
	if !ok {
		that2, ok := that.(GetSpecType_AzureVnetSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AzureVnetSite.Equal(that1.AzureVnetSite) {
		return false
	}
	return true
}
func (this *LabelFilter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LabelFilter)
	if !ok {
		that2, ok := that.(LabelFilter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Label != that1.Label {
		return false
	}
	if this.Op != that1.Op {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *CustomerEdge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CustomerEdge)
	if !ok {
		that2, ok := that.(CustomerEdge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *MetricData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetricData)
	if !ok {
		that2, ok := that.(MetricData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Unit != that1.Unit {
		return false
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if !this.Values[i].Equal(that1.Values[i]) {
			return false
		}
	}
	return true
}
func (this *SegmentationData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SegmentationData)
	if !ok {
		that2, ok := that.(SegmentationData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.Data) != len(that1.Data) {
		return false
	}
	for i := range this.Data {
		if !this.Data[i].Equal(that1.Data[i]) {
			return false
		}
	}
	return true
}
func (this *EdgeData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EdgeData)
	if !ok {
		that2, ok := that.(EdgeData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ce.Equal(that1.Ce) {
		return false
	}
	if len(this.Segments) != len(that1.Segments) {
		return false
	}
	for i := range this.Segments {
		if !this.Segments[i].Equal(that1.Segments[i]) {
			return false
		}
	}
	return true
}
func (this *CloudConnectData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloudConnectData)
	if !ok {
		that2, ok := that.(CloudConnectData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Data) != len(that1.Data) {
		return false
	}
	for i := range this.Data {
		if !this.Data[i].Equal(that1.Data[i]) {
			return false
		}
	}
	return true
}
func (this *AWSREType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&cloud_connect.AWSREType{")
	if this.Region != nil {
		s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	}
	if this.Cred != nil {
		s = append(s, "Cred: "+fmt.Sprintf("%#v", this.Cred)+",\n")
	}
	if this.VpcAttachments != nil {
		s = append(s, "VpcAttachments: "+fmt.Sprintf("%#v", this.VpcAttachments)+",\n")
	}
	if this.CloudLinks != nil {
		s = append(s, "CloudLinks: "+fmt.Sprintf("%#v", this.CloudLinks)+",\n")
	}
	s = append(s, "Tgw: "+fmt.Sprintf("%#v", this.Tgw)+",\n")
	if this.Peers != nil {
		s = append(s, "Peers: "+fmt.Sprintf("%#v", this.Peers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PeerType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cloud_connect.PeerType{")
	s = append(s, "TgwAddress: "+fmt.Sprintf("%#v", this.TgwAddress)+",\n")
	s = append(s, "PeerAsn: "+fmt.Sprintf("%#v", this.PeerAsn)+",\n")
	if this.Node != nil {
		s = append(s, "Node: "+fmt.Sprintf("%#v", this.Node)+",\n")
	}
	s = append(s, "InsideGreSubnet: "+fmt.Sprintf("%#v", this.InsideGreSubnet)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudLinkListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.CloudLinkListType{")
	if this.CloudLink != nil {
		s = append(s, "CloudLink: "+fmt.Sprintf("%#v", this.CloudLink)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCAttachmentListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.AWSVPCAttachmentListType{")
	if this.VpcList != nil {
		s = append(s, "VpcList: "+fmt.Sprintf("%#v", this.VpcList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCAttachmentType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&cloud_connect.AWSVPCAttachmentType{")
	s = append(s, "VpcId: "+fmt.Sprintf("%#v", this.VpcId)+",\n")
	if this.RoutingChoice != nil {
		s = append(s, "RoutingChoice: "+fmt.Sprintf("%#v", this.RoutingChoice)+",\n")
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSVPCAttachmentType_ManualRouting) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.AWSVPCAttachmentType_ManualRouting{` +
		`ManualRouting:` + fmt.Sprintf("%#v", this.ManualRouting) + `}`}, ", ")
	return s
}
func (this *AWSVPCAttachmentType_DefaultRoute) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.AWSVPCAttachmentType_DefaultRoute{` +
		`DefaultRoute:` + fmt.Sprintf("%#v", this.DefaultRoute) + `}`}, ", ")
	return s
}
func (this *AWSVPCAttachmentType_CustomRouting) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.AWSVPCAttachmentType_CustomRouting{` +
		`CustomRouting:` + fmt.Sprintf("%#v", this.CustomRouting) + `}`}, ", ")
	return s
}
func (this *AzureVnetAttachmentListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.AzureVnetAttachmentListType{")
	if this.VnetList != nil {
		s = append(s, "VnetList: "+fmt.Sprintf("%#v", this.VnetList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureVNETAttachmentType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&cloud_connect.AzureVNETAttachmentType{")
	s = append(s, "SubscriptionId: "+fmt.Sprintf("%#v", this.SubscriptionId)+",\n")
	s = append(s, "VnetId: "+fmt.Sprintf("%#v", this.VnetId)+",\n")
	if this.RoutingChoice != nil {
		s = append(s, "RoutingChoice: "+fmt.Sprintf("%#v", this.RoutingChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureVNETAttachmentType_ManualRouting) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.AzureVNETAttachmentType_ManualRouting{` +
		`ManualRouting:` + fmt.Sprintf("%#v", this.ManualRouting) + `}`}, ", ")
	return s
}
func (this *AzureVNETAttachmentType_DefaultRoute) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.AzureVNETAttachmentType_DefaultRoute{` +
		`DefaultRoute:` + fmt.Sprintf("%#v", this.DefaultRoute) + `}`}, ", ")
	return s
}
func (this *AzureVNETAttachmentType_CustomRouting) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.AzureVNETAttachmentType_CustomRouting{` +
		`CustomRouting:` + fmt.Sprintf("%#v", this.CustomRouting) + `}`}, ", ")
	return s
}
func (this *AzureDefaultRoute) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloud_connect.AzureDefaultRoute{")
	if this.DefaultRouteChoice != nil {
		s = append(s, "DefaultRouteChoice: "+fmt.Sprintf("%#v", this.DefaultRouteChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureDefaultRoute_AllRouteTables) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.AzureDefaultRoute_AllRouteTables{` +
		`AllRouteTables:` + fmt.Sprintf("%#v", this.AllRouteTables) + `}`}, ", ")
	return s
}
func (this *AzureDefaultRoute_SelectiveRouteTables) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.AzureDefaultRoute_SelectiveRouteTables{` +
		`SelectiveRouteTables:` + fmt.Sprintf("%#v", this.SelectiveRouteTables) + `}`}, ", ")
	return s
}
func (this *DefaultRoute) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloud_connect.DefaultRoute{")
	if this.DefaultRouteChoice != nil {
		s = append(s, "DefaultRouteChoice: "+fmt.Sprintf("%#v", this.DefaultRouteChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DefaultRoute_AllRouteTables) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.DefaultRoute_AllRouteTables{` +
		`AllRouteTables:` + fmt.Sprintf("%#v", this.AllRouteTables) + `}`}, ", ")
	return s
}
func (this *DefaultRoute_SelectiveRouteTables) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.DefaultRoute_SelectiveRouteTables{` +
		`SelectiveRouteTables:` + fmt.Sprintf("%#v", this.SelectiveRouteTables) + `}`}, ", ")
	return s
}
func (this *AWSSubnetIDListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.AWSSubnetIDListType{")
	s = append(s, "SubnetIds: "+fmt.Sprintf("%#v", this.SubnetIds)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSRouteTableListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.AWSRouteTableListType{")
	if this.RouteTables != nil {
		s = append(s, "RouteTables: "+fmt.Sprintf("%#v", this.RouteTables)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSDefaultRoutesRouteTable) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.AWSDefaultRoutesRouteTable{")
	s = append(s, "RouteTableId: "+fmt.Sprintf("%#v", this.RouteTableId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureRouteTables) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.AzureRouteTables{")
	s = append(s, "RouteTableId: "+fmt.Sprintf("%#v", this.RouteTableId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureRouteTableWithStaticRouteListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.AzureRouteTableWithStaticRouteListType{")
	if this.RouteTables != nil {
		s = append(s, "RouteTables: "+fmt.Sprintf("%#v", this.RouteTables)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureRouteTableWithStaticRoute) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloud_connect.AzureRouteTableWithStaticRoute{")
	s = append(s, "RouteTableId: "+fmt.Sprintf("%#v", this.RouteTableId)+",\n")
	s = append(s, "StaticRoutes: "+fmt.Sprintf("%#v", this.StaticRoutes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSRouteTableType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloud_connect.AWSRouteTableType{")
	s = append(s, "RouteTableId: "+fmt.Sprintf("%#v", this.RouteTableId)+",\n")
	s = append(s, "StaticRoutes: "+fmt.Sprintf("%#v", this.StaticRoutes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceAWSREType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.ReplaceAWSREType{")
	if this.VpcAttachments != nil {
		s = append(s, "VpcAttachments: "+fmt.Sprintf("%#v", this.VpcAttachments)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSTGWSiteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloud_connect.AWSTGWSiteType{")
	if this.Site != nil {
		s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	}
	if this.Cred != nil {
		s = append(s, "Cred: "+fmt.Sprintf("%#v", this.Cred)+",\n")
	}
	if this.VpcAttachments != nil {
		s = append(s, "VpcAttachments: "+fmt.Sprintf("%#v", this.VpcAttachments)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceAWSTGWSiteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.ReplaceAWSTGWSiteType{")
	if this.VpcAttachments != nil {
		s = append(s, "VpcAttachments: "+fmt.Sprintf("%#v", this.VpcAttachments)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureVNETSiteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloud_connect.AzureVNETSiteType{")
	if this.Site != nil {
		s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	}
	if this.Cred != nil {
		s = append(s, "Cred: "+fmt.Sprintf("%#v", this.Cred)+",\n")
	}
	if this.VnetAttachments != nil {
		s = append(s, "VnetAttachments: "+fmt.Sprintf("%#v", this.VnetAttachments)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceAzureVNETSiteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.ReplaceAzureVNETSiteType{")
	if this.VnetAttachments != nil {
		s = append(s, "VnetAttachments: "+fmt.Sprintf("%#v", this.VnetAttachments)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudConnectStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloud_connect.CloudConnectStatusType{")
	if this.CloudConnectDeployment != nil {
		s = append(s, "CloudConnectDeployment: "+fmt.Sprintf("%#v", this.CloudConnectDeployment)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudConnectStatusType_CloudConnectAwsSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.CloudConnectStatusType_CloudConnectAwsSite{` +
		`CloudConnectAwsSite:` + fmt.Sprintf("%#v", this.CloudConnectAwsSite) + `}`}, ", ")
	return s
}
func (this *CloudConnectStatusType_CloudConnectAzureSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.CloudConnectStatusType_CloudConnectAzureSite{` +
		`CloudConnectAzureSite:` + fmt.Sprintf("%#v", this.CloudConnectAzureSite) + `}`}, ", ")
	return s
}
func (this *AWSAttachmentsListStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.AWSAttachmentsListStatusType{")
	if this.AttachmentStatus != nil {
		s = append(s, "AttachmentStatus: "+fmt.Sprintf("%#v", this.AttachmentStatus)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AWSAttachmentsStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&cloud_connect.AWSAttachmentsStatusType{")
	s = append(s, "TgwAttachmentId: "+fmt.Sprintf("%#v", this.TgwAttachmentId)+",\n")
	if this.CreationTime != nil {
		s = append(s, "CreationTime: "+fmt.Sprintf("%#v", this.CreationTime)+",\n")
	}
	s = append(s, "VpcId: "+fmt.Sprintf("%#v", this.VpcId)+",\n")
	s = append(s, "VpcOwnerId: "+fmt.Sprintf("%#v", this.VpcOwnerId)+",\n")
	s = append(s, "VpcCidr: "+fmt.Sprintf("%#v", this.VpcCidr)+",\n")
	s = append(s, "VpcDeploymentState: "+fmt.Sprintf("%#v", this.VpcDeploymentState)+",\n")
	s = append(s, "DeploymentStatus: "+fmt.Sprintf("%#v", this.DeploymentStatus)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	if this.Subnets != nil {
		s = append(s, "Subnets: "+fmt.Sprintf("%#v", this.Subnets)+",\n")
	}
	if this.InstalledRoutes != nil {
		s = append(s, "InstalledRoutes: "+fmt.Sprintf("%#v", this.InstalledRoutes)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SubnetStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&cloud_connect.SubnetStatusType{")
	s = append(s, "NetworkInterfaceId: "+fmt.Sprintf("%#v", this.NetworkInterfaceId)+",\n")
	s = append(s, "InterfaceType: "+fmt.Sprintf("%#v", this.InterfaceType)+",\n")
	s = append(s, "PrivateIpv4Address: "+fmt.Sprintf("%#v", this.PrivateIpv4Address)+",\n")
	s = append(s, "AvailabilityZone: "+fmt.Sprintf("%#v", this.AvailabilityZone)+",\n")
	s = append(s, "SubnetId: "+fmt.Sprintf("%#v", this.SubnetId)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureAttachmentsListStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.AzureAttachmentsListStatusType{")
	if this.AttachmentStatus != nil {
		s = append(s, "AttachmentStatus: "+fmt.Sprintf("%#v", this.AttachmentStatus)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AzureAttachmentsStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&cloud_connect.AzureAttachmentsStatusType{")
	s = append(s, "VnetAttachmentId: "+fmt.Sprintf("%#v", this.VnetAttachmentId)+",\n")
	s = append(s, "SpokeSubscriptionId: "+fmt.Sprintf("%#v", this.SpokeSubscriptionId)+",\n")
	s = append(s, "SpokeVnetId: "+fmt.Sprintf("%#v", this.SpokeVnetId)+",\n")
	s = append(s, "HubVnetName: "+fmt.Sprintf("%#v", this.HubVnetName)+",\n")
	s = append(s, "HubVnetResourceGroup: "+fmt.Sprintf("%#v", this.HubVnetResourceGroup)+",\n")
	s = append(s, "HubOwnerSubscriptionid: "+fmt.Sprintf("%#v", this.HubOwnerSubscriptionid)+",\n")
	s = append(s, "PeeringState: "+fmt.Sprintf("%#v", this.PeeringState)+",\n")
	s = append(s, "ProvisioningState: "+fmt.Sprintf("%#v", this.ProvisioningState)+",\n")
	s = append(s, "DeploymentStatus: "+fmt.Sprintf("%#v", this.DeploymentStatus)+",\n")
	s = append(s, "PeeringSyncLevel: "+fmt.Sprintf("%#v", this.PeeringSyncLevel)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	if this.Subnets != nil {
		s = append(s, "Subnets: "+fmt.Sprintf("%#v", this.Subnets)+",\n")
	}
	if this.InstalledRoutes != nil {
		s = append(s, "InstalledRoutes: "+fmt.Sprintf("%#v", this.InstalledRoutes)+",\n")
	}
	s = append(s, "VnetCidr: "+fmt.Sprintf("%#v", this.VnetCidr)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&cloud_connect.GlobalSpecType{")
	if this.Cloud != nil {
		s = append(s, "Cloud: "+fmt.Sprintf("%#v", this.Cloud)+",\n")
	}
	if this.Segment != nil {
		s = append(s, "Segment: "+fmt.Sprintf("%#v", this.Segment)+",\n")
	}
	if this.BandwidthOption != nil {
		s = append(s, "BandwidthOption: "+fmt.Sprintf("%#v", this.BandwidthOption)+",\n")
	}
	if this.Sites != nil {
		s = append(s, "Sites: "+fmt.Sprintf("%#v", this.Sites)+",\n")
	}
	if this.VirtualNetwork != nil {
		s = append(s, "VirtualNetwork: "+fmt.Sprintf("%#v", this.VirtualNetwork)+",\n")
	}
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "OnboardedVpc: "+fmt.Sprintf("%#v", this.OnboardedVpc)+",\n")
	if this.Coordinates != nil {
		s = append(s, "Coordinates: "+fmt.Sprintf("%#v", this.Coordinates)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_AwsRe) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.GlobalSpecType_AwsRe{` +
		`AwsRe:` + fmt.Sprintf("%#v", this.AwsRe) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AwsTgwSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.GlobalSpecType_AwsTgwSite{` +
		`AwsTgwSite:` + fmt.Sprintf("%#v", this.AwsTgwSite) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_AzureVnetSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.GlobalSpecType_AzureVnetSite{` +
		`AzureVnetSite:` + fmt.Sprintf("%#v", this.AzureVnetSite) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_Bandwidth_500Mbs) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.GlobalSpecType_Bandwidth_500Mbs{` +
		`Bandwidth_500Mbs:` + fmt.Sprintf("%#v", this.Bandwidth_500Mbs) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cloud_connect.CreateSpecType{")
	if this.Cloud != nil {
		s = append(s, "Cloud: "+fmt.Sprintf("%#v", this.Cloud)+",\n")
	}
	if this.Segment != nil {
		s = append(s, "Segment: "+fmt.Sprintf("%#v", this.Segment)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_AwsRe) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.CreateSpecType_AwsRe{` +
		`AwsRe:` + fmt.Sprintf("%#v", this.AwsRe) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_AwsTgwSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.CreateSpecType_AwsTgwSite{` +
		`AwsTgwSite:` + fmt.Sprintf("%#v", this.AwsTgwSite) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_AzureVnetSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.CreateSpecType_AzureVnetSite{` +
		`AzureVnetSite:` + fmt.Sprintf("%#v", this.AzureVnetSite) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cloud_connect.ReplaceSpecType{")
	if this.Cloud != nil {
		s = append(s, "Cloud: "+fmt.Sprintf("%#v", this.Cloud)+",\n")
	}
	if this.Segment != nil {
		s = append(s, "Segment: "+fmt.Sprintf("%#v", this.Segment)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_AwsRe) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.ReplaceSpecType_AwsRe{` +
		`AwsRe:` + fmt.Sprintf("%#v", this.AwsRe) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_AwsTgwSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.ReplaceSpecType_AwsTgwSite{` +
		`AwsTgwSite:` + fmt.Sprintf("%#v", this.AwsTgwSite) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_AzureVnetSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.ReplaceSpecType_AzureVnetSite{` +
		`AzureVnetSite:` + fmt.Sprintf("%#v", this.AzureVnetSite) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&cloud_connect.GetSpecType{")
	if this.Cloud != nil {
		s = append(s, "Cloud: "+fmt.Sprintf("%#v", this.Cloud)+",\n")
	}
	if this.Segment != nil {
		s = append(s, "Segment: "+fmt.Sprintf("%#v", this.Segment)+",\n")
	}
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "OnboardedVpc: "+fmt.Sprintf("%#v", this.OnboardedVpc)+",\n")
	if this.Coordinates != nil {
		s = append(s, "Coordinates: "+fmt.Sprintf("%#v", this.Coordinates)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_AwsRe) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.GetSpecType_AwsRe{` +
		`AwsRe:` + fmt.Sprintf("%#v", this.AwsRe) + `}`}, ", ")
	return s
}
func (this *GetSpecType_AwsTgwSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.GetSpecType_AwsTgwSite{` +
		`AwsTgwSite:` + fmt.Sprintf("%#v", this.AwsTgwSite) + `}`}, ", ")
	return s
}
func (this *GetSpecType_AzureVnetSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cloud_connect.GetSpecType_AzureVnetSite{` +
		`AzureVnetSite:` + fmt.Sprintf("%#v", this.AzureVnetSite) + `}`}, ", ")
	return s
}
func (this *LabelFilter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloud_connect.LabelFilter{")
	s = append(s, "Label: "+fmt.Sprintf("%#v", this.Label)+",\n")
	s = append(s, "Op: "+fmt.Sprintf("%#v", this.Op)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CustomerEdge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cloud_connect.CustomerEdge{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MetricData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cloud_connect.MetricData{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Unit: "+fmt.Sprintf("%#v", this.Unit)+",\n")
	if this.Values != nil {
		s = append(s, "Values: "+fmt.Sprintf("%#v", this.Values)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SegmentationData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloud_connect.SegmentationData{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Data != nil {
		s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EdgeData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloud_connect.EdgeData{")
	if this.Ce != nil {
		s = append(s, "Ce: "+fmt.Sprintf("%#v", this.Ce)+",\n")
	}
	if this.Segments != nil {
		s = append(s, "Segments: "+fmt.Sprintf("%#v", this.Segments)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloudConnectData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cloud_connect.CloudConnectData{")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	if this.Data != nil {
		s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *AWSREType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSREType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSREType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Peers) > 0 {
		for iNdEx := len(m.Peers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Peers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Tgw) > 0 {
		i -= len(m.Tgw)
		copy(dAtA[i:], m.Tgw)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Tgw)))
		i--
		dAtA[i] = 0x2a
	}
	if m.CloudLinks != nil {
		{
			size, err := m.CloudLinks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.VpcAttachments != nil {
		{
			size, err := m.VpcAttachments.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Cred != nil {
		{
			size, err := m.Cred.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Region != nil {
		{
			size, err := m.Region.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PeerType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InsideGreSubnet) > 0 {
		i -= len(m.InsideGreSubnet)
		copy(dAtA[i:], m.InsideGreSubnet)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InsideGreSubnet)))
		i--
		dAtA[i] = 0x22
	}
	if m.Node != nil {
		{
			size, err := m.Node.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PeerAsn != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PeerAsn))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TgwAddress) > 0 {
		i -= len(m.TgwAddress)
		copy(dAtA[i:], m.TgwAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TgwAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloudLinkListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudLinkListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudLinkListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CloudLink) > 0 {
		for iNdEx := len(m.CloudLink) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CloudLink[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSVPCAttachmentListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSVPCAttachmentListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCAttachmentListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VpcList) > 0 {
		for iNdEx := len(m.VpcList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VpcList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSVPCAttachmentType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSVPCAttachmentType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCAttachmentType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.RoutingChoice != nil {
		{
			size := m.RoutingChoice.Size()
			i -= size
			if _, err := m.RoutingChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.VpcId) > 0 {
		i -= len(m.VpcId)
		copy(dAtA[i:], m.VpcId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VpcId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWSVPCAttachmentType_ManualRouting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCAttachmentType_ManualRouting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ManualRouting != nil {
		{
			size, err := m.ManualRouting.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *AWSVPCAttachmentType_DefaultRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCAttachmentType_DefaultRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultRoute != nil {
		{
			size, err := m.DefaultRoute.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *AWSVPCAttachmentType_CustomRouting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSVPCAttachmentType_CustomRouting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CustomRouting != nil {
		{
			size, err := m.CustomRouting.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *AzureVnetAttachmentListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVnetAttachmentListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVnetAttachmentListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VnetList) > 0 {
		for iNdEx := len(m.VnetList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VnetList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AzureVNETAttachmentType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVNETAttachmentType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVNETAttachmentType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RoutingChoice != nil {
		{
			size := m.RoutingChoice.Size()
			i -= size
			if _, err := m.RoutingChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.VnetId) > 0 {
		i -= len(m.VnetId)
		copy(dAtA[i:], m.VnetId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VnetId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SubscriptionId) > 0 {
		i -= len(m.SubscriptionId)
		copy(dAtA[i:], m.SubscriptionId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubscriptionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureVNETAttachmentType_ManualRouting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVNETAttachmentType_ManualRouting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ManualRouting != nil {
		{
			size, err := m.ManualRouting.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AzureVNETAttachmentType_CustomRouting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVNETAttachmentType_CustomRouting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CustomRouting != nil {
		{
			size, err := m.CustomRouting.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *AzureVNETAttachmentType_DefaultRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVNETAttachmentType_DefaultRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultRoute != nil {
		{
			size, err := m.DefaultRoute.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *AzureDefaultRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureDefaultRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureDefaultRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DefaultRouteChoice != nil {
		{
			size := m.DefaultRouteChoice.Size()
			i -= size
			if _, err := m.DefaultRouteChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AzureDefaultRoute_AllRouteTables) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureDefaultRoute_AllRouteTables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllRouteTables != nil {
		{
			size, err := m.AllRouteTables.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AzureDefaultRoute_SelectiveRouteTables) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureDefaultRoute_SelectiveRouteTables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SelectiveRouteTables != nil {
		{
			size, err := m.SelectiveRouteTables.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DefaultRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefaultRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DefaultRouteChoice != nil {
		{
			size := m.DefaultRouteChoice.Size()
			i -= size
			if _, err := m.DefaultRouteChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DefaultRoute_AllRouteTables) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultRoute_AllRouteTables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllRouteTables != nil {
		{
			size, err := m.AllRouteTables.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DefaultRoute_SelectiveRouteTables) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultRoute_SelectiveRouteTables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SelectiveRouteTables != nil {
		{
			size, err := m.SelectiveRouteTables.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AWSSubnetIDListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSSubnetIDListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSSubnetIDListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubnetIds) > 0 {
		for iNdEx := len(m.SubnetIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SubnetIds[iNdEx])
			copy(dAtA[i:], m.SubnetIds[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.SubnetIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSRouteTableListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSRouteTableListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSRouteTableListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RouteTables) > 0 {
		for iNdEx := len(m.RouteTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RouteTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSDefaultRoutesRouteTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSDefaultRoutesRouteTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSDefaultRoutesRouteTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RouteTableId) > 0 {
		for iNdEx := len(m.RouteTableId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RouteTableId[iNdEx])
			copy(dAtA[i:], m.RouteTableId[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RouteTableId[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AzureRouteTables) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureRouteTables) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureRouteTables) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RouteTableId) > 0 {
		for iNdEx := len(m.RouteTableId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RouteTableId[iNdEx])
			copy(dAtA[i:], m.RouteTableId[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RouteTableId[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AzureRouteTableWithStaticRouteListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureRouteTableWithStaticRouteListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureRouteTableWithStaticRouteListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RouteTables) > 0 {
		for iNdEx := len(m.RouteTables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RouteTables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AzureRouteTableWithStaticRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureRouteTableWithStaticRoute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureRouteTableWithStaticRoute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StaticRoutes) > 0 {
		for iNdEx := len(m.StaticRoutes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StaticRoutes[iNdEx])
			copy(dAtA[i:], m.StaticRoutes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.StaticRoutes[iNdEx])))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.RouteTableId) > 0 {
		i -= len(m.RouteTableId)
		copy(dAtA[i:], m.RouteTableId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RouteTableId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AWSRouteTableType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSRouteTableType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSRouteTableType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StaticRoutes) > 0 {
		for iNdEx := len(m.StaticRoutes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StaticRoutes[iNdEx])
			copy(dAtA[i:], m.StaticRoutes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.StaticRoutes[iNdEx])))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xe2
		}
	}
	if len(m.RouteTableId) > 0 {
		i -= len(m.RouteTableId)
		copy(dAtA[i:], m.RouteTableId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RouteTableId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceAWSREType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceAWSREType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceAWSREType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VpcAttachments != nil {
		{
			size, err := m.VpcAttachments.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *AWSTGWSiteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSTGWSiteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSTGWSiteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VpcAttachments != nil {
		{
			size, err := m.VpcAttachments.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Cred != nil {
		{
			size, err := m.Cred.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Site != nil {
		{
			size, err := m.Site.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceAWSTGWSiteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceAWSTGWSiteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceAWSTGWSiteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VpcAttachments != nil {
		{
			size, err := m.VpcAttachments.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *AzureVNETSiteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureVNETSiteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureVNETSiteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VnetAttachments != nil {
		{
			size, err := m.VnetAttachments.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Cred != nil {
		{
			size, err := m.Cred.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Site != nil {
		{
			size, err := m.Site.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceAzureVNETSiteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceAzureVNETSiteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceAzureVNETSiteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VnetAttachments != nil {
		{
			size, err := m.VnetAttachments.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *CloudConnectStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudConnectStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudConnectStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CloudConnectDeployment != nil {
		{
			size := m.CloudConnectDeployment.Size()
			i -= size
			if _, err := m.CloudConnectDeployment.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CloudConnectStatusType_CloudConnectAwsSite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudConnectStatusType_CloudConnectAwsSite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CloudConnectAwsSite != nil {
		{
			size, err := m.CloudConnectAwsSite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CloudConnectStatusType_CloudConnectAzureSite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudConnectStatusType_CloudConnectAzureSite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CloudConnectAzureSite != nil {
		{
			size, err := m.CloudConnectAzureSite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AWSAttachmentsListStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSAttachmentsListStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSAttachmentsListStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AttachmentStatus) > 0 {
		for iNdEx := len(m.AttachmentStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AttachmentStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AWSAttachmentsStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSAttachmentsStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSAttachmentsStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VpcCidr) > 0 {
		i -= len(m.VpcCidr)
		copy(dAtA[i:], m.VpcCidr)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VpcCidr)))
		i--
		dAtA[i] = 0x62
	}
	if m.VpcDeploymentState != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VpcDeploymentState))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Subnets) > 0 {
		for iNdEx := len(m.Subnets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subnets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.InstalledRoutes != nil {
		{
			size, err := m.InstalledRoutes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Tags) > 0 {
		keysForTags := make([]string, 0, len(m.Tags))
		for k := range m.Tags {
			keysForTags = append(keysForTags, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
		for iNdEx := len(keysForTags) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Tags[string(keysForTags[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForTags[iNdEx])
			copy(dAtA[i:], keysForTags[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForTags[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.DeploymentStatus) > 0 {
		i -= len(m.DeploymentStatus)
		copy(dAtA[i:], m.DeploymentStatus)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DeploymentStatus)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.VpcOwnerId) > 0 {
		i -= len(m.VpcOwnerId)
		copy(dAtA[i:], m.VpcOwnerId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VpcOwnerId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.VpcId) > 0 {
		i -= len(m.VpcId)
		copy(dAtA[i:], m.VpcId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VpcId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TgwAttachmentId) > 0 {
		i -= len(m.TgwAttachmentId)
		copy(dAtA[i:], m.TgwAttachmentId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TgwAttachmentId)))
		i--
		dAtA[i] = 0x12
	}
	if m.CreationTime != nil {
		{
			size, err := m.CreationTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubnetStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubnetStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubnetStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SubnetId) > 0 {
		i -= len(m.SubnetId)
		copy(dAtA[i:], m.SubnetId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubnetId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AvailabilityZone) > 0 {
		i -= len(m.AvailabilityZone)
		copy(dAtA[i:], m.AvailabilityZone)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AvailabilityZone)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PrivateIpv4Address) > 0 {
		i -= len(m.PrivateIpv4Address)
		copy(dAtA[i:], m.PrivateIpv4Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PrivateIpv4Address)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.InterfaceType) > 0 {
		i -= len(m.InterfaceType)
		copy(dAtA[i:], m.InterfaceType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InterfaceType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NetworkInterfaceId) > 0 {
		i -= len(m.NetworkInterfaceId)
		copy(dAtA[i:], m.NetworkInterfaceId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NetworkInterfaceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AzureAttachmentsListStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureAttachmentsListStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureAttachmentsListStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AttachmentStatus) > 0 {
		for iNdEx := len(m.AttachmentStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AttachmentStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AzureAttachmentsStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AzureAttachmentsStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AzureAttachmentsStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HubVnetResourceGroup) > 0 {
		i -= len(m.HubVnetResourceGroup)
		copy(dAtA[i:], m.HubVnetResourceGroup)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HubVnetResourceGroup)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.SpokeSubscriptionId) > 0 {
		i -= len(m.SpokeSubscriptionId)
		copy(dAtA[i:], m.SpokeSubscriptionId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SpokeSubscriptionId)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.VnetCidr) > 0 {
		i -= len(m.VnetCidr)
		copy(dAtA[i:], m.VnetCidr)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VnetCidr)))
		i--
		dAtA[i] = 0x72
	}
	if m.InstalledRoutes != nil {
		{
			size, err := m.InstalledRoutes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.Subnets) > 0 {
		for iNdEx := len(m.Subnets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subnets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.Tags) > 0 {
		keysForTags := make([]string, 0, len(m.Tags))
		for k := range m.Tags {
			keysForTags = append(keysForTags, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
		for iNdEx := len(keysForTags) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Tags[string(keysForTags[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForTags[iNdEx])
			copy(dAtA[i:], keysForTags[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForTags[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.PeeringSyncLevel) > 0 {
		i -= len(m.PeeringSyncLevel)
		copy(dAtA[i:], m.PeeringSyncLevel)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PeeringSyncLevel)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.DeploymentStatus) > 0 {
		i -= len(m.DeploymentStatus)
		copy(dAtA[i:], m.DeploymentStatus)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DeploymentStatus)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ProvisioningState) > 0 {
		i -= len(m.ProvisioningState)
		copy(dAtA[i:], m.ProvisioningState)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProvisioningState)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PeeringState) > 0 {
		i -= len(m.PeeringState)
		copy(dAtA[i:], m.PeeringState)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PeeringState)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.HubOwnerSubscriptionid) > 0 {
		i -= len(m.HubOwnerSubscriptionid)
		copy(dAtA[i:], m.HubOwnerSubscriptionid)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HubOwnerSubscriptionid)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.HubVnetName) > 0 {
		i -= len(m.HubVnetName)
		copy(dAtA[i:], m.HubVnetName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HubVnetName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SpokeVnetId) > 0 {
		i -= len(m.SpokeVnetId)
		copy(dAtA[i:], m.SpokeVnetId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SpokeVnetId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.VnetAttachmentId) > 0 {
		i -= len(m.VnetAttachmentId)
		copy(dAtA[i:], m.VnetAttachmentId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VnetAttachmentId)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Cloud != nil {
		{
			size := m.Cloud.Size()
			i -= size
			if _, err := m.Cloud.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Coordinates != nil {
		{
			size, err := m.Coordinates.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.OnboardedVpc != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.OnboardedVpc))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x78
	}
	if len(m.VirtualNetwork) > 0 {
		for iNdEx := len(m.VirtualNetwork) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VirtualNetwork[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if m.Segment != nil {
		{
			size, err := m.Segment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Sites) > 0 {
		for iNdEx := len(m.Sites) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sites[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if m.BandwidthOption != nil {
		{
			size := m.BandwidthOption.Size()
			i -= size
			if _, err := m.BandwidthOption.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_AwsRe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AwsRe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsRe != nil {
		{
			size, err := m.AwsRe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_AwsTgwSite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AwsTgwSite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsTgwSite != nil {
		{
			size, err := m.AwsTgwSite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_Bandwidth_500Mbs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_Bandwidth_500Mbs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Bandwidth_500Mbs != nil {
		{
			size, err := m.Bandwidth_500Mbs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_AzureVnetSite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_AzureVnetSite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AzureVnetSite != nil {
		{
			size, err := m.AzureVnetSite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Cloud != nil {
		{
			size := m.Cloud.Size()
			i -= size
			if _, err := m.Cloud.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Segment != nil {
		{
			size, err := m.Segment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_AwsRe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_AwsRe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsRe != nil {
		{
			size, err := m.AwsRe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_AwsTgwSite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_AwsTgwSite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsTgwSite != nil {
		{
			size, err := m.AwsTgwSite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_AzureVnetSite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_AzureVnetSite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AzureVnetSite != nil {
		{
			size, err := m.AzureVnetSite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Cloud != nil {
		{
			size := m.Cloud.Size()
			i -= size
			if _, err := m.Cloud.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Segment != nil {
		{
			size, err := m.Segment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_AwsRe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_AwsRe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsRe != nil {
		{
			size, err := m.AwsRe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_AwsTgwSite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_AwsTgwSite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsTgwSite != nil {
		{
			size, err := m.AwsTgwSite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_AzureVnetSite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_AzureVnetSite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AzureVnetSite != nil {
		{
			size, err := m.AzureVnetSite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Cloud != nil {
		{
			size := m.Cloud.Size()
			i -= size
			if _, err := m.Cloud.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Coordinates != nil {
		{
			size, err := m.Coordinates.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.OnboardedVpc != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.OnboardedVpc))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x78
	}
	if m.Segment != nil {
		{
			size, err := m.Segment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_AwsRe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_AwsRe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsRe != nil {
		{
			size, err := m.AwsRe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_AwsTgwSite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_AwsTgwSite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsTgwSite != nil {
		{
			size, err := m.AwsTgwSite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_AzureVnetSite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_AzureVnetSite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AzureVnetSite != nil {
		{
			size, err := m.AzureVnetSite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *LabelFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LabelFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Op != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x10
	}
	if m.Label != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Label))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CustomerEdge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomerEdge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CustomerEdge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetricData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Unit != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Unit))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SegmentationData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SegmentationData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SegmentationData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EdgeData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EdgeData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EdgeData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Segments) > 0 {
		for iNdEx := len(m.Segments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Segments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Ce != nil {
		{
			size, err := m.Ce.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloudConnectData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloudConnectData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloudConnectData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AWSREType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Region != nil {
		l = m.Region.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Cred != nil {
		l = m.Cred.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VpcAttachments != nil {
		l = m.VpcAttachments.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CloudLinks != nil {
		l = m.CloudLinks.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Tgw)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Peers) > 0 {
		for _, e := range m.Peers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *PeerType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TgwAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PeerAsn != 0 {
		n += 1 + sovTypes(uint64(m.PeerAsn))
	}
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.InsideGreSubnet)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CloudLinkListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CloudLink) > 0 {
		for _, e := range m.CloudLink {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSVPCAttachmentListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VpcList) > 0 {
		for _, e := range m.VpcList {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSVPCAttachmentType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VpcId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RoutingChoice != nil {
		n += m.RoutingChoice.Size()
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AWSVPCAttachmentType_ManualRouting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ManualRouting != nil {
		l = m.ManualRouting.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AWSVPCAttachmentType_DefaultRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultRoute != nil {
		l = m.DefaultRoute.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AWSVPCAttachmentType_CustomRouting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CustomRouting != nil {
		l = m.CustomRouting.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AzureVnetAttachmentListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VnetList) > 0 {
		for _, e := range m.VnetList {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AzureVNETAttachmentType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SubscriptionId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VnetId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RoutingChoice != nil {
		n += m.RoutingChoice.Size()
	}
	return n
}

func (m *AzureVNETAttachmentType_ManualRouting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ManualRouting != nil {
		l = m.ManualRouting.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AzureVNETAttachmentType_CustomRouting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CustomRouting != nil {
		l = m.CustomRouting.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AzureVNETAttachmentType_DefaultRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultRoute != nil {
		l = m.DefaultRoute.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AzureDefaultRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultRouteChoice != nil {
		n += m.DefaultRouteChoice.Size()
	}
	return n
}

func (m *AzureDefaultRoute_AllRouteTables) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllRouteTables != nil {
		l = m.AllRouteTables.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AzureDefaultRoute_SelectiveRouteTables) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SelectiveRouteTables != nil {
		l = m.SelectiveRouteTables.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DefaultRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultRouteChoice != nil {
		n += m.DefaultRouteChoice.Size()
	}
	return n
}

func (m *DefaultRoute_AllRouteTables) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllRouteTables != nil {
		l = m.AllRouteTables.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DefaultRoute_SelectiveRouteTables) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SelectiveRouteTables != nil {
		l = m.SelectiveRouteTables.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AWSSubnetIDListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SubnetIds) > 0 {
		for _, s := range m.SubnetIds {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSRouteTableListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RouteTables) > 0 {
		for _, e := range m.RouteTables {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSDefaultRoutesRouteTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RouteTableId) > 0 {
		for _, s := range m.RouteTableId {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AzureRouteTables) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RouteTableId) > 0 {
		for _, s := range m.RouteTableId {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AzureRouteTableWithStaticRouteListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RouteTables) > 0 {
		for _, e := range m.RouteTables {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AzureRouteTableWithStaticRoute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RouteTableId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.StaticRoutes) > 0 {
		for _, s := range m.StaticRoutes {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSRouteTableType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RouteTableId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.StaticRoutes) > 0 {
		for _, s := range m.StaticRoutes {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ReplaceAWSREType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VpcAttachments != nil {
		l = m.VpcAttachments.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AWSTGWSiteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Site != nil {
		l = m.Site.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Cred != nil {
		l = m.Cred.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VpcAttachments != nil {
		l = m.VpcAttachments.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceAWSTGWSiteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VpcAttachments != nil {
		l = m.VpcAttachments.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AzureVNETSiteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Site != nil {
		l = m.Site.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Cred != nil {
		l = m.Cred.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VnetAttachments != nil {
		l = m.VnetAttachments.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceAzureVNETSiteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VnetAttachments != nil {
		l = m.VnetAttachments.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CloudConnectStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloudConnectDeployment != nil {
		n += m.CloudConnectDeployment.Size()
	}
	return n
}

func (m *CloudConnectStatusType_CloudConnectAwsSite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloudConnectAwsSite != nil {
		l = m.CloudConnectAwsSite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CloudConnectStatusType_CloudConnectAzureSite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloudConnectAzureSite != nil {
		l = m.CloudConnectAzureSite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AWSAttachmentsListStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AttachmentStatus) > 0 {
		for _, e := range m.AttachmentStatus {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AWSAttachmentsStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreationTime != nil {
		l = m.CreationTime.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TgwAttachmentId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VpcId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VpcOwnerId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DeploymentStatus)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.InstalledRoutes != nil {
		l = m.InstalledRoutes.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Subnets) > 0 {
		for _, e := range m.Subnets {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.VpcDeploymentState != 0 {
		n += 1 + sovTypes(uint64(m.VpcDeploymentState))
	}
	l = len(m.VpcCidr)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SubnetStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NetworkInterfaceId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.InterfaceType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PrivateIpv4Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AvailabilityZone)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubnetId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AzureAttachmentsListStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AttachmentStatus) > 0 {
		for _, e := range m.AttachmentStatus {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AzureAttachmentsStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VnetAttachmentId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SpokeVnetId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.HubVnetName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.HubOwnerSubscriptionid)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PeeringState)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProvisioningState)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DeploymentStatus)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PeeringSyncLevel)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Subnets) > 0 {
		for _, e := range m.Subnets {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InstalledRoutes != nil {
		l = m.InstalledRoutes.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VnetCidr)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SpokeSubscriptionId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.HubVnetResourceGroup)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cloud != nil {
		n += m.Cloud.Size()
	}
	if m.BandwidthOption != nil {
		n += m.BandwidthOption.Size()
	}
	if len(m.Sites) > 0 {
		for _, e := range m.Sites {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Segment != nil {
		l = m.Segment.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.VirtualNetwork) > 0 {
		for _, e := range m.VirtualNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	if m.OnboardedVpc != 0 {
		n += 2 + sovTypes(uint64(m.OnboardedVpc))
	}
	if m.Coordinates != nil {
		l = m.Coordinates.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType_AwsRe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsRe != nil {
		l = m.AwsRe.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AwsTgwSite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsTgwSite != nil {
		l = m.AwsTgwSite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_Bandwidth_500Mbs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bandwidth_500Mbs != nil {
		l = m.Bandwidth_500Mbs.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_AzureVnetSite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AzureVnetSite != nil {
		l = m.AzureVnetSite.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cloud != nil {
		n += m.Cloud.Size()
	}
	if m.Segment != nil {
		l = m.Segment.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType_AwsRe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsRe != nil {
		l = m.AwsRe.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AwsTgwSite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsTgwSite != nil {
		l = m.AwsTgwSite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_AzureVnetSite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AzureVnetSite != nil {
		l = m.AzureVnetSite.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cloud != nil {
		n += m.Cloud.Size()
	}
	if m.Segment != nil {
		l = m.Segment.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType_AwsRe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsRe != nil {
		l = m.AwsRe.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AwsTgwSite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsTgwSite != nil {
		l = m.AwsTgwSite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_AzureVnetSite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AzureVnetSite != nil {
		l = m.AzureVnetSite.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cloud != nil {
		n += m.Cloud.Size()
	}
	if m.Segment != nil {
		l = m.Segment.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	if m.OnboardedVpc != 0 {
		n += 2 + sovTypes(uint64(m.OnboardedVpc))
	}
	if m.Coordinates != nil {
		l = m.Coordinates.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GetSpecType_AwsRe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsRe != nil {
		l = m.AwsRe.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AwsTgwSite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsTgwSite != nil {
		l = m.AwsTgwSite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_AzureVnetSite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AzureVnetSite != nil {
		l = m.AzureVnetSite.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LabelFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Label != 0 {
		n += 1 + sovTypes(uint64(m.Label))
	}
	if m.Op != 0 {
		n += 1 + sovTypes(uint64(m.Op))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CustomerEdge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MetricData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.Unit != 0 {
		n += 1 + sovTypes(uint64(m.Unit))
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *SegmentationData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *EdgeData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ce != nil {
		l = m.Ce.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Segments) > 0 {
		for _, e := range m.Segments {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CloudConnectData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AWSREType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPeers := "[]*PeerType{"
	for _, f := range this.Peers {
		repeatedStringForPeers += strings.Replace(f.String(), "PeerType", "PeerType", 1) + ","
	}
	repeatedStringForPeers += "}"
	s := strings.Join([]string{`&AWSREType{`,
		`Region:` + strings.Replace(fmt.Sprintf("%v", this.Region), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`Cred:` + strings.Replace(fmt.Sprintf("%v", this.Cred), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`VpcAttachments:` + strings.Replace(this.VpcAttachments.String(), "AWSVPCAttachmentListType", "AWSVPCAttachmentListType", 1) + `,`,
		`CloudLinks:` + strings.Replace(this.CloudLinks.String(), "CloudLinkListType", "CloudLinkListType", 1) + `,`,
		`Tgw:` + fmt.Sprintf("%v", this.Tgw) + `,`,
		`Peers:` + repeatedStringForPeers + `,`,
		`}`,
	}, "")
	return s
}
func (this *PeerType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PeerType{`,
		`TgwAddress:` + fmt.Sprintf("%v", this.TgwAddress) + `,`,
		`PeerAsn:` + fmt.Sprintf("%v", this.PeerAsn) + `,`,
		`Node:` + strings.Replace(fmt.Sprintf("%v", this.Node), "NodeType", "cloud_re_region.NodeType", 1) + `,`,
		`InsideGreSubnet:` + fmt.Sprintf("%v", this.InsideGreSubnet) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudLinkListType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCloudLink := "[]*ObjectRefType{"
	for _, f := range this.CloudLink {
		repeatedStringForCloudLink += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "views.ObjectRefType", 1) + ","
	}
	repeatedStringForCloudLink += "}"
	s := strings.Join([]string{`&CloudLinkListType{`,
		`CloudLink:` + repeatedStringForCloudLink + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCAttachmentListType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForVpcList := "[]*AWSVPCAttachmentType{"
	for _, f := range this.VpcList {
		repeatedStringForVpcList += strings.Replace(f.String(), "AWSVPCAttachmentType", "AWSVPCAttachmentType", 1) + ","
	}
	repeatedStringForVpcList += "}"
	s := strings.Join([]string{`&AWSVPCAttachmentListType{`,
		`VpcList:` + repeatedStringForVpcList + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCAttachmentType) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&AWSVPCAttachmentType{`,
		`VpcId:` + fmt.Sprintf("%v", this.VpcId) + `,`,
		`RoutingChoice:` + fmt.Sprintf("%v", this.RoutingChoice) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCAttachmentType_ManualRouting) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCAttachmentType_ManualRouting{`,
		`ManualRouting:` + strings.Replace(fmt.Sprintf("%v", this.ManualRouting), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCAttachmentType_DefaultRoute) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCAttachmentType_DefaultRoute{`,
		`DefaultRoute:` + strings.Replace(fmt.Sprintf("%v", this.DefaultRoute), "DefaultRoute", "DefaultRoute", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSVPCAttachmentType_CustomRouting) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSVPCAttachmentType_CustomRouting{`,
		`CustomRouting:` + strings.Replace(fmt.Sprintf("%v", this.CustomRouting), "AWSRouteTableListType", "AWSRouteTableListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVnetAttachmentListType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForVnetList := "[]*AzureVNETAttachmentType{"
	for _, f := range this.VnetList {
		repeatedStringForVnetList += strings.Replace(f.String(), "AzureVNETAttachmentType", "AzureVNETAttachmentType", 1) + ","
	}
	repeatedStringForVnetList += "}"
	s := strings.Join([]string{`&AzureVnetAttachmentListType{`,
		`VnetList:` + repeatedStringForVnetList + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVNETAttachmentType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVNETAttachmentType{`,
		`SubscriptionId:` + fmt.Sprintf("%v", this.SubscriptionId) + `,`,
		`VnetId:` + fmt.Sprintf("%v", this.VnetId) + `,`,
		`RoutingChoice:` + fmt.Sprintf("%v", this.RoutingChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVNETAttachmentType_ManualRouting) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVNETAttachmentType_ManualRouting{`,
		`ManualRouting:` + strings.Replace(fmt.Sprintf("%v", this.ManualRouting), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVNETAttachmentType_CustomRouting) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVNETAttachmentType_CustomRouting{`,
		`CustomRouting:` + strings.Replace(fmt.Sprintf("%v", this.CustomRouting), "AzureRouteTableWithStaticRouteListType", "AzureRouteTableWithStaticRouteListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVNETAttachmentType_DefaultRoute) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVNETAttachmentType_DefaultRoute{`,
		`DefaultRoute:` + strings.Replace(fmt.Sprintf("%v", this.DefaultRoute), "AzureDefaultRoute", "AzureDefaultRoute", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureDefaultRoute) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureDefaultRoute{`,
		`DefaultRouteChoice:` + fmt.Sprintf("%v", this.DefaultRouteChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureDefaultRoute_AllRouteTables) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureDefaultRoute_AllRouteTables{`,
		`AllRouteTables:` + strings.Replace(fmt.Sprintf("%v", this.AllRouteTables), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureDefaultRoute_SelectiveRouteTables) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureDefaultRoute_SelectiveRouteTables{`,
		`SelectiveRouteTables:` + strings.Replace(fmt.Sprintf("%v", this.SelectiveRouteTables), "AzureRouteTables", "AzureRouteTables", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DefaultRoute) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DefaultRoute{`,
		`DefaultRouteChoice:` + fmt.Sprintf("%v", this.DefaultRouteChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DefaultRoute_AllRouteTables) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DefaultRoute_AllRouteTables{`,
		`AllRouteTables:` + strings.Replace(fmt.Sprintf("%v", this.AllRouteTables), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DefaultRoute_SelectiveRouteTables) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DefaultRoute_SelectiveRouteTables{`,
		`SelectiveRouteTables:` + strings.Replace(fmt.Sprintf("%v", this.SelectiveRouteTables), "AWSDefaultRoutesRouteTable", "AWSDefaultRoutesRouteTable", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSSubnetIDListType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSSubnetIDListType{`,
		`SubnetIds:` + fmt.Sprintf("%v", this.SubnetIds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSRouteTableListType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRouteTables := "[]*AWSRouteTableType{"
	for _, f := range this.RouteTables {
		repeatedStringForRouteTables += strings.Replace(f.String(), "AWSRouteTableType", "AWSRouteTableType", 1) + ","
	}
	repeatedStringForRouteTables += "}"
	s := strings.Join([]string{`&AWSRouteTableListType{`,
		`RouteTables:` + repeatedStringForRouteTables + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSDefaultRoutesRouteTable) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSDefaultRoutesRouteTable{`,
		`RouteTableId:` + fmt.Sprintf("%v", this.RouteTableId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureRouteTables) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureRouteTables{`,
		`RouteTableId:` + fmt.Sprintf("%v", this.RouteTableId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureRouteTableWithStaticRouteListType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRouteTables := "[]*AzureRouteTableWithStaticRoute{"
	for _, f := range this.RouteTables {
		repeatedStringForRouteTables += strings.Replace(f.String(), "AzureRouteTableWithStaticRoute", "AzureRouteTableWithStaticRoute", 1) + ","
	}
	repeatedStringForRouteTables += "}"
	s := strings.Join([]string{`&AzureRouteTableWithStaticRouteListType{`,
		`RouteTables:` + repeatedStringForRouteTables + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureRouteTableWithStaticRoute) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureRouteTableWithStaticRoute{`,
		`RouteTableId:` + fmt.Sprintf("%v", this.RouteTableId) + `,`,
		`StaticRoutes:` + fmt.Sprintf("%v", this.StaticRoutes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSRouteTableType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSRouteTableType{`,
		`RouteTableId:` + fmt.Sprintf("%v", this.RouteTableId) + `,`,
		`StaticRoutes:` + fmt.Sprintf("%v", this.StaticRoutes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceAWSREType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceAWSREType{`,
		`VpcAttachments:` + strings.Replace(this.VpcAttachments.String(), "AWSVPCAttachmentListType", "AWSVPCAttachmentListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSTGWSiteType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSTGWSiteType{`,
		`Site:` + strings.Replace(fmt.Sprintf("%v", this.Site), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`Cred:` + strings.Replace(fmt.Sprintf("%v", this.Cred), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`VpcAttachments:` + strings.Replace(this.VpcAttachments.String(), "AWSVPCAttachmentListType", "AWSVPCAttachmentListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceAWSTGWSiteType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceAWSTGWSiteType{`,
		`VpcAttachments:` + strings.Replace(this.VpcAttachments.String(), "AWSVPCAttachmentListType", "AWSVPCAttachmentListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureVNETSiteType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AzureVNETSiteType{`,
		`Site:` + strings.Replace(fmt.Sprintf("%v", this.Site), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`Cred:` + strings.Replace(fmt.Sprintf("%v", this.Cred), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`VnetAttachments:` + strings.Replace(this.VnetAttachments.String(), "AzureVnetAttachmentListType", "AzureVnetAttachmentListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceAzureVNETSiteType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceAzureVNETSiteType{`,
		`VnetAttachments:` + strings.Replace(this.VnetAttachments.String(), "AzureVnetAttachmentListType", "AzureVnetAttachmentListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudConnectStatusType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudConnectStatusType{`,
		`CloudConnectDeployment:` + fmt.Sprintf("%v", this.CloudConnectDeployment) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudConnectStatusType_CloudConnectAwsSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudConnectStatusType_CloudConnectAwsSite{`,
		`CloudConnectAwsSite:` + strings.Replace(fmt.Sprintf("%v", this.CloudConnectAwsSite), "AWSAttachmentsListStatusType", "AWSAttachmentsListStatusType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudConnectStatusType_CloudConnectAzureSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloudConnectStatusType_CloudConnectAzureSite{`,
		`CloudConnectAzureSite:` + strings.Replace(fmt.Sprintf("%v", this.CloudConnectAzureSite), "AzureAttachmentsListStatusType", "AzureAttachmentsListStatusType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSAttachmentsListStatusType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAttachmentStatus := "[]*AWSAttachmentsStatusType{"
	for _, f := range this.AttachmentStatus {
		repeatedStringForAttachmentStatus += strings.Replace(f.String(), "AWSAttachmentsStatusType", "AWSAttachmentsStatusType", 1) + ","
	}
	repeatedStringForAttachmentStatus += "}"
	s := strings.Join([]string{`&AWSAttachmentsListStatusType{`,
		`AttachmentStatus:` + repeatedStringForAttachmentStatus + `,`,
		`}`,
	}, "")
	return s
}
func (this *AWSAttachmentsStatusType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSubnets := "[]*SubnetStatusType{"
	for _, f := range this.Subnets {
		repeatedStringForSubnets += strings.Replace(f.String(), "SubnetStatusType", "SubnetStatusType", 1) + ","
	}
	repeatedStringForSubnets += "}"
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&AWSAttachmentsStatusType{`,
		`CreationTime:` + strings.Replace(fmt.Sprintf("%v", this.CreationTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`TgwAttachmentId:` + fmt.Sprintf("%v", this.TgwAttachmentId) + `,`,
		`VpcId:` + fmt.Sprintf("%v", this.VpcId) + `,`,
		`VpcOwnerId:` + fmt.Sprintf("%v", this.VpcOwnerId) + `,`,
		`DeploymentStatus:` + fmt.Sprintf("%v", this.DeploymentStatus) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`InstalledRoutes:` + strings.Replace(this.InstalledRoutes.String(), "AWSRouteTableListType", "AWSRouteTableListType", 1) + `,`,
		`Subnets:` + repeatedStringForSubnets + `,`,
		`VpcDeploymentState:` + fmt.Sprintf("%v", this.VpcDeploymentState) + `,`,
		`VpcCidr:` + fmt.Sprintf("%v", this.VpcCidr) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SubnetStatusType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SubnetStatusType{`,
		`NetworkInterfaceId:` + fmt.Sprintf("%v", this.NetworkInterfaceId) + `,`,
		`InterfaceType:` + fmt.Sprintf("%v", this.InterfaceType) + `,`,
		`PrivateIpv4Address:` + fmt.Sprintf("%v", this.PrivateIpv4Address) + `,`,
		`AvailabilityZone:` + fmt.Sprintf("%v", this.AvailabilityZone) + `,`,
		`SubnetId:` + fmt.Sprintf("%v", this.SubnetId) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureAttachmentsListStatusType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAttachmentStatus := "[]*AzureAttachmentsStatusType{"
	for _, f := range this.AttachmentStatus {
		repeatedStringForAttachmentStatus += strings.Replace(f.String(), "AzureAttachmentsStatusType", "AzureAttachmentsStatusType", 1) + ","
	}
	repeatedStringForAttachmentStatus += "}"
	s := strings.Join([]string{`&AzureAttachmentsListStatusType{`,
		`AttachmentStatus:` + repeatedStringForAttachmentStatus + `,`,
		`}`,
	}, "")
	return s
}
func (this *AzureAttachmentsStatusType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSubnets := "[]*SubnetStatusType{"
	for _, f := range this.Subnets {
		repeatedStringForSubnets += strings.Replace(f.String(), "SubnetStatusType", "SubnetStatusType", 1) + ","
	}
	repeatedStringForSubnets += "}"
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&AzureAttachmentsStatusType{`,
		`VnetAttachmentId:` + fmt.Sprintf("%v", this.VnetAttachmentId) + `,`,
		`SpokeVnetId:` + fmt.Sprintf("%v", this.SpokeVnetId) + `,`,
		`HubVnetName:` + fmt.Sprintf("%v", this.HubVnetName) + `,`,
		`HubOwnerSubscriptionid:` + fmt.Sprintf("%v", this.HubOwnerSubscriptionid) + `,`,
		`PeeringState:` + fmt.Sprintf("%v", this.PeeringState) + `,`,
		`ProvisioningState:` + fmt.Sprintf("%v", this.ProvisioningState) + `,`,
		`DeploymentStatus:` + fmt.Sprintf("%v", this.DeploymentStatus) + `,`,
		`PeeringSyncLevel:` + fmt.Sprintf("%v", this.PeeringSyncLevel) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`Subnets:` + repeatedStringForSubnets + `,`,
		`InstalledRoutes:` + strings.Replace(this.InstalledRoutes.String(), "AzureRouteTableWithStaticRouteListType", "AzureRouteTableWithStaticRouteListType", 1) + `,`,
		`VnetCidr:` + fmt.Sprintf("%v", this.VnetCidr) + `,`,
		`SpokeSubscriptionId:` + fmt.Sprintf("%v", this.SpokeSubscriptionId) + `,`,
		`HubVnetResourceGroup:` + fmt.Sprintf("%v", this.HubVnetResourceGroup) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSites := "[]*ObjectRefType{"
	for _, f := range this.Sites {
		repeatedStringForSites += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForSites += "}"
	repeatedStringForVirtualNetwork := "[]*ObjectRefType{"
	for _, f := range this.VirtualNetwork {
		repeatedStringForVirtualNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForVirtualNetwork += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Cloud:` + fmt.Sprintf("%v", this.Cloud) + `,`,
		`BandwidthOption:` + fmt.Sprintf("%v", this.BandwidthOption) + `,`,
		`Sites:` + repeatedStringForSites + `,`,
		`Segment:` + strings.Replace(fmt.Sprintf("%v", this.Segment), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`VirtualNetwork:` + repeatedStringForVirtualNetwork + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`OnboardedVpc:` + fmt.Sprintf("%v", this.OnboardedVpc) + `,`,
		`Coordinates:` + strings.Replace(fmt.Sprintf("%v", this.Coordinates), "Coordinates", "site.Coordinates", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AwsRe) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AwsRe{`,
		`AwsRe:` + strings.Replace(fmt.Sprintf("%v", this.AwsRe), "AWSREType", "AWSREType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AwsTgwSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AwsTgwSite{`,
		`AwsTgwSite:` + strings.Replace(fmt.Sprintf("%v", this.AwsTgwSite), "AWSTGWSiteType", "AWSTGWSiteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Bandwidth_500Mbs) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Bandwidth_500Mbs{`,
		`Bandwidth_500Mbs:` + strings.Replace(fmt.Sprintf("%v", this.Bandwidth_500Mbs), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_AzureVnetSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_AzureVnetSite{`,
		`AzureVnetSite:` + strings.Replace(fmt.Sprintf("%v", this.AzureVnetSite), "AzureVNETSiteType", "AzureVNETSiteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Cloud:` + fmt.Sprintf("%v", this.Cloud) + `,`,
		`Segment:` + strings.Replace(fmt.Sprintf("%v", this.Segment), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AwsRe) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AwsRe{`,
		`AwsRe:` + strings.Replace(fmt.Sprintf("%v", this.AwsRe), "AWSREType", "AWSREType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AwsTgwSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AwsTgwSite{`,
		`AwsTgwSite:` + strings.Replace(fmt.Sprintf("%v", this.AwsTgwSite), "AWSTGWSiteType", "AWSTGWSiteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_AzureVnetSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_AzureVnetSite{`,
		`AzureVnetSite:` + strings.Replace(fmt.Sprintf("%v", this.AzureVnetSite), "AzureVNETSiteType", "AzureVNETSiteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Cloud:` + fmt.Sprintf("%v", this.Cloud) + `,`,
		`Segment:` + strings.Replace(fmt.Sprintf("%v", this.Segment), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AwsRe) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AwsRe{`,
		`AwsRe:` + strings.Replace(fmt.Sprintf("%v", this.AwsRe), "ReplaceAWSREType", "ReplaceAWSREType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AwsTgwSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AwsTgwSite{`,
		`AwsTgwSite:` + strings.Replace(fmt.Sprintf("%v", this.AwsTgwSite), "ReplaceAWSTGWSiteType", "ReplaceAWSTGWSiteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_AzureVnetSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_AzureVnetSite{`,
		`AzureVnetSite:` + strings.Replace(fmt.Sprintf("%v", this.AzureVnetSite), "ReplaceAzureVNETSiteType", "ReplaceAzureVNETSiteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`Cloud:` + fmt.Sprintf("%v", this.Cloud) + `,`,
		`Segment:` + strings.Replace(fmt.Sprintf("%v", this.Segment), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`OnboardedVpc:` + fmt.Sprintf("%v", this.OnboardedVpc) + `,`,
		`Coordinates:` + strings.Replace(fmt.Sprintf("%v", this.Coordinates), "Coordinates", "site.Coordinates", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AwsRe) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AwsRe{`,
		`AwsRe:` + strings.Replace(fmt.Sprintf("%v", this.AwsRe), "AWSREType", "AWSREType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AwsTgwSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AwsTgwSite{`,
		`AwsTgwSite:` + strings.Replace(fmt.Sprintf("%v", this.AwsTgwSite), "AWSTGWSiteType", "AWSTGWSiteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_AzureVnetSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_AzureVnetSite{`,
		`AzureVnetSite:` + strings.Replace(fmt.Sprintf("%v", this.AzureVnetSite), "AzureVNETSiteType", "AzureVNETSiteType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LabelFilter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LabelFilter{`,
		`Label:` + fmt.Sprintf("%v", this.Label) + `,`,
		`Op:` + fmt.Sprintf("%v", this.Op) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CustomerEdge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CustomerEdge{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForValues := "[]*MetricValue{"
	for _, f := range this.Values {
		repeatedStringForValues += strings.Replace(fmt.Sprintf("%v", f), "MetricValue", "schema.MetricValue", 1) + ","
	}
	repeatedStringForValues += "}"
	s := strings.Join([]string{`&MetricData{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Unit:` + fmt.Sprintf("%v", this.Unit) + `,`,
		`Values:` + repeatedStringForValues + `,`,
		`}`,
	}, "")
	return s
}
func (this *SegmentationData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForData := "[]*MetricData{"
	for _, f := range this.Data {
		repeatedStringForData += strings.Replace(f.String(), "MetricData", "MetricData", 1) + ","
	}
	repeatedStringForData += "}"
	s := strings.Join([]string{`&SegmentationData{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Data:` + repeatedStringForData + `,`,
		`}`,
	}, "")
	return s
}
func (this *EdgeData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSegments := "[]*SegmentationData{"
	for _, f := range this.Segments {
		repeatedStringForSegments += strings.Replace(f.String(), "SegmentationData", "SegmentationData", 1) + ","
	}
	repeatedStringForSegments += "}"
	s := strings.Join([]string{`&EdgeData{`,
		`Ce:` + strings.Replace(this.Ce.String(), "CustomerEdge", "CustomerEdge", 1) + `,`,
		`Segments:` + repeatedStringForSegments + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloudConnectData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForData := "[]*MetricData{"
	for _, f := range this.Data {
		repeatedStringForData += strings.Replace(f.String(), "MetricData", "MetricData", 1) + ","
	}
	repeatedStringForData += "}"
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&CloudConnectData{`,
		`Labels:` + mapStringForLabels + `,`,
		`Data:` + repeatedStringForData + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AWSREType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSREType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSREType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Region == nil {
				m.Region = &views.ObjectRefType{}
			}
			if err := m.Region.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cred", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cred == nil {
				m.Cred = &views.ObjectRefType{}
			}
			if err := m.Cred.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcAttachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VpcAttachments == nil {
				m.VpcAttachments = &AWSVPCAttachmentListType{}
			}
			if err := m.VpcAttachments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudLinks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloudLinks == nil {
				m.CloudLinks = &CloudLinkListType{}
			}
			if err := m.CloudLinks.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tgw", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tgw = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peers = append(m.Peers, &PeerType{})
			if err := m.Peers[len(m.Peers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TgwAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TgwAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerAsn", wireType)
			}
			m.PeerAsn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerAsn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &cloud_re_region.NodeType{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideGreSubnet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideGreSubnet = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudLinkListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudLinkListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudLinkListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudLink", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudLink = append(m.CloudLink, &views.ObjectRefType{})
			if err := m.CloudLink[len(m.CloudLink)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSVPCAttachmentListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSVPCAttachmentListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSVPCAttachmentListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcList = append(m.VpcList, &AWSVPCAttachmentType{})
			if err := m.VpcList[len(m.VpcList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSVPCAttachmentType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSVPCAttachmentType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSVPCAttachmentType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualRouting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RoutingChoice = &AWSVPCAttachmentType_ManualRouting{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultRoute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DefaultRoute{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RoutingChoice = &AWSVPCAttachmentType_DefaultRoute{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomRouting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSRouteTableListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RoutingChoice = &AWSVPCAttachmentType_CustomRouting{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVnetAttachmentListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVnetAttachmentListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVnetAttachmentListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnetList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VnetList = append(m.VnetList, &AzureVNETAttachmentType{})
			if err := m.VnetList[len(m.VnetList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVNETAttachmentType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVNETAttachmentType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVNETAttachmentType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubscriptionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualRouting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RoutingChoice = &AzureVNETAttachmentType_ManualRouting{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomRouting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureRouteTableWithStaticRouteListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RoutingChoice = &AzureVNETAttachmentType_CustomRouting{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultRoute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureDefaultRoute{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RoutingChoice = &AzureVNETAttachmentType_DefaultRoute{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureDefaultRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureDefaultRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureDefaultRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllRouteTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DefaultRouteChoice = &AzureDefaultRoute_AllRouteTables{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectiveRouteTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureRouteTables{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DefaultRouteChoice = &AzureDefaultRoute_SelectiveRouteTables{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefaultRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefaultRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefaultRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllRouteTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DefaultRouteChoice = &DefaultRoute_AllRouteTables{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectiveRouteTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSDefaultRoutesRouteTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DefaultRouteChoice = &DefaultRoute_SelectiveRouteTables{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSSubnetIDListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSSubnetIDListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSSubnetIDListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetIds = append(m.SubnetIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSRouteTableListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSRouteTableListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSRouteTableListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteTables = append(m.RouteTables, &AWSRouteTableType{})
			if err := m.RouteTables[len(m.RouteTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSDefaultRoutesRouteTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSDefaultRoutesRouteTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSDefaultRoutesRouteTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTableId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteTableId = append(m.RouteTableId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureRouteTables) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureRouteTables: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureRouteTables: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTableId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteTableId = append(m.RouteTableId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureRouteTableWithStaticRouteListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureRouteTableWithStaticRouteListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureRouteTableWithStaticRouteListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteTables = append(m.RouteTables, &AzureRouteTableWithStaticRoute{})
			if err := m.RouteTables[len(m.RouteTables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureRouteTableWithStaticRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureRouteTableWithStaticRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureRouteTableWithStaticRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTableId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteTableId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 108:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticRoutes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaticRoutes = append(m.StaticRoutes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSRouteTableType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSRouteTableType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSRouteTableType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTableId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteTableId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 108:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticRoutes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaticRoutes = append(m.StaticRoutes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceAWSREType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceAWSREType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceAWSREType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcAttachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VpcAttachments == nil {
				m.VpcAttachments = &AWSVPCAttachmentListType{}
			}
			if err := m.VpcAttachments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSTGWSiteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSTGWSiteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSTGWSiteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Site == nil {
				m.Site = &views.ObjectRefType{}
			}
			if err := m.Site.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cred", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cred == nil {
				m.Cred = &views.ObjectRefType{}
			}
			if err := m.Cred.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcAttachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VpcAttachments == nil {
				m.VpcAttachments = &AWSVPCAttachmentListType{}
			}
			if err := m.VpcAttachments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceAWSTGWSiteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceAWSTGWSiteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceAWSTGWSiteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcAttachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VpcAttachments == nil {
				m.VpcAttachments = &AWSVPCAttachmentListType{}
			}
			if err := m.VpcAttachments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureVNETSiteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureVNETSiteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureVNETSiteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Site == nil {
				m.Site = &views.ObjectRefType{}
			}
			if err := m.Site.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cred", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cred == nil {
				m.Cred = &views.ObjectRefType{}
			}
			if err := m.Cred.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnetAttachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VnetAttachments == nil {
				m.VnetAttachments = &AzureVnetAttachmentListType{}
			}
			if err := m.VnetAttachments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceAzureVNETSiteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceAzureVNETSiteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceAzureVNETSiteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnetAttachments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VnetAttachments == nil {
				m.VnetAttachments = &AzureVnetAttachmentListType{}
			}
			if err := m.VnetAttachments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudConnectStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudConnectStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudConnectStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudConnectAwsSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSAttachmentsListStatusType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudConnectDeployment = &CloudConnectStatusType_CloudConnectAwsSite{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudConnectAzureSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureAttachmentsListStatusType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CloudConnectDeployment = &CloudConnectStatusType_CloudConnectAzureSite{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSAttachmentsListStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSAttachmentsListStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSAttachmentsListStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachmentStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttachmentStatus = append(m.AttachmentStatus, &AWSAttachmentsStatusType{})
			if err := m.AttachmentStatus[len(m.AttachmentStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSAttachmentsStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSAttachmentsStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSAttachmentsStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTime == nil {
				m.CreationTime = &types.Timestamp{}
			}
			if err := m.CreationTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TgwAttachmentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TgwAttachmentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcOwnerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcOwnerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstalledRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InstalledRoutes == nil {
				m.InstalledRoutes = &AWSRouteTableListType{}
			}
			if err := m.InstalledRoutes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnets = append(m.Subnets, &SubnetStatusType{})
			if err := m.Subnets[len(m.Subnets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcDeploymentState", wireType)
			}
			m.VpcDeploymentState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VpcDeploymentState |= CloudConnectVPCStateType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpcCidr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VpcCidr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubnetStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubnetStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubnetStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkInterfaceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkInterfaceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateIpv4Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateIpv4Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailabilityZone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailabilityZone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureAttachmentsListStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureAttachmentsListStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureAttachmentsListStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachmentStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttachmentStatus = append(m.AttachmentStatus, &AzureAttachmentsStatusType{})
			if err := m.AttachmentStatus[len(m.AttachmentStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureAttachmentsStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureAttachmentsStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureAttachmentsStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnetAttachmentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VnetAttachmentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpokeVnetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpokeVnetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HubVnetName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HubVnetName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HubOwnerSubscriptionid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HubOwnerSubscriptionid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeeringState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeeringState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProvisioningState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProvisioningState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeeringSyncLevel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeeringSyncLevel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnets = append(m.Subnets, &SubnetStatusType{})
			if err := m.Subnets[len(m.Subnets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstalledRoutes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InstalledRoutes == nil {
				m.InstalledRoutes = &AzureRouteTableWithStaticRouteListType{}
			}
			if err := m.InstalledRoutes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnetCidr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VnetCidr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpokeSubscriptionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpokeSubscriptionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HubVnetResourceGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HubVnetResourceGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsRe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSREType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &GlobalSpecType_AwsRe{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsTgwSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSTGWSiteType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &GlobalSpecType_AwsTgwSite{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bandwidth_500Mbs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.BandwidthOption = &GlobalSpecType_Bandwidth_500Mbs{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sites = append(m.Sites, &schema.ObjectRefType{})
			if err := m.Sites[len(m.Sites)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Segment == nil {
				m.Segment = &views.ObjectRefType{}
			}
			if err := m.Segment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualNetwork = append(m.VirtualNetwork, &schema.ObjectRefType{})
			if err := m.VirtualNetwork[len(m.VirtualNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= CloudConnectState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnboardedVpc", wireType)
			}
			m.OnboardedVpc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnboardedVpc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coordinates == nil {
				m.Coordinates = &site.Coordinates{}
			}
			if err := m.Coordinates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureVnetSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureVNETSiteType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &GlobalSpecType_AzureVnetSite{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsRe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSREType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &CreateSpecType_AwsRe{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsTgwSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSTGWSiteType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &CreateSpecType_AwsTgwSite{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Segment == nil {
				m.Segment = &views.ObjectRefType{}
			}
			if err := m.Segment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureVnetSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureVNETSiteType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &CreateSpecType_AzureVnetSite{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsRe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReplaceAWSREType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &ReplaceSpecType_AwsRe{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsTgwSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReplaceAWSTGWSiteType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &ReplaceSpecType_AwsTgwSite{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Segment == nil {
				m.Segment = &views.ObjectRefType{}
			}
			if err := m.Segment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureVnetSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReplaceAzureVNETSiteType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &ReplaceSpecType_AzureVnetSite{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsRe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSREType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &GetSpecType_AwsRe{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsTgwSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSTGWSiteType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &GetSpecType_AwsTgwSite{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Segment == nil {
				m.Segment = &views.ObjectRefType{}
			}
			if err := m.Segment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= CloudConnectState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnboardedVpc", wireType)
			}
			m.OnboardedVpc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnboardedVpc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coordinates == nil {
				m.Coordinates = &site.Coordinates{}
			}
			if err := m.Coordinates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureVnetSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AzureVNETSiteType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Cloud = &GetSpecType_AzureVnetSite{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			m.Label = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Label |= Label(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= schema.MetricLabelOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomerEdge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomerEdge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomerEdge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= FieldSelector(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			m.Unit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Unit |= schema.UnitType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &schema.MetricValue{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SegmentationData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SegmentationData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SegmentationData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= TrafficType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &MetricData{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgeData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgeData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ce", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ce == nil {
				m.Ce = &CustomerEdge{}
			}
			if err := m.Ce.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Segments = append(m.Segments, &SegmentationData{})
			if err := m.Segments[len(m.Segments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloudConnectData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloudConnectData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloudConnectData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &MetricData{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
