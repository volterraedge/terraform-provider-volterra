// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/network_interface/types.proto

package network_interface

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	_ "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// DHCP POOL SETTING
//
// x-displayName: "Interface Network Type"
// Identifies the how to pick the network for Interface.
type DHCPPoolSettingType int32

const (
	// x-displayName: "Include IP Addresses from DHCP Pools"
	// Address ranges in DHCP pool list are allocation list
	INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS DHCPPoolSettingType = 0
	// x-displayName: "Exclude IP Addresses from DHCP Pools"
	// Address ranges in DHCP pool list are exclude list
	EXCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS DHCPPoolSettingType = 1
)

var DHCPPoolSettingType_name = map[int32]string{
	0: "INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS",
	1: "EXCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS",
}

var DHCPPoolSettingType_value = map[string]int32{
	"INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS": 0,
	"EXCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS": 1,
}

func (DHCPPoolSettingType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{0}
}

// Interface Network Type
//
// x-displayName: "Interface Network Type"
// Identifies the how to pick the network for Interface.
type InterfaceNetworkType int32

const (
	// x-displayName: "Network Reference"
	// Backward compatibility to existing config or per site network
	NETWORK_INTERFACE_NETWORK_REF InterfaceNetworkType = 0
	// x-displayName: "Site Local Network"
	// Take site local from from fleet
	NETWORK_INTERFACE_SITE_LOCAL InterfaceNetworkType = 1
	// x-displayName: "Site Local Inside Network"
	// Take site local inside from from fleet
	NETWORK_INTERFACE_SITE_LOCAL_INSIDE InterfaceNetworkType = 2
	// x-displayName: "Site Storage Network"
	// Network interface is used to connect to storage network
	NETWORK_INTERFACE_STORAGE InterfaceNetworkType = 3
	// x-displayName: "Site Management Network"
	// Network interface is used to connect to storage network
	NETWORK_INTERFACE_MANAGEMENT InterfaceNetworkType = 4
	// x-displayName: "IP Fabric Network"
	// Network interface is used to connect to IP Fabric network
	NETWORK_INTERFACE_IPFABRIC InterfaceNetworkType = 5
)

var InterfaceNetworkType_name = map[int32]string{
	0: "NETWORK_INTERFACE_NETWORK_REF",
	1: "NETWORK_INTERFACE_SITE_LOCAL",
	2: "NETWORK_INTERFACE_SITE_LOCAL_INSIDE",
	3: "NETWORK_INTERFACE_STORAGE",
	4: "NETWORK_INTERFACE_MANAGEMENT",
	5: "NETWORK_INTERFACE_IPFABRIC",
}

var InterfaceNetworkType_value = map[string]int32{
	"NETWORK_INTERFACE_NETWORK_REF":       0,
	"NETWORK_INTERFACE_SITE_LOCAL":        1,
	"NETWORK_INTERFACE_SITE_LOCAL_INSIDE": 2,
	"NETWORK_INTERFACE_STORAGE":           3,
	"NETWORK_INTERFACE_MANAGEMENT":        4,
	"NETWORK_INTERFACE_IPFABRIC":          5,
}

func (InterfaceNetworkType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{1}
}

// Network Interface Type
//
// x-displayName: "Network Interface Type"
// Identifies the type of the interface.
type NetworkInterfaceType int32

const (
	// x-displayName: "Ethernet"
	// Network interface is an Ethernet interface
	NETWORK_INTERFACE_ETHERNET NetworkInterfaceType = 0
	// x-displayName: "VLAN"
	// Network interface is a VLAN interface
	NETWORK_INTERFACE_VLAN_INTERFACE NetworkInterfaceType = 1
	// x-displayName: "Link Aggregation"
	// Network interface is a bond interface running LACP
	NETWORK_INTERFACE_LACP_INTERFACE NetworkInterfaceType = 2
	// x-displayName: "Tunnel Interface"
	// Network interface is a tunnel interface
	NETWORK_INTERFACE_TUNNEL_INTERFACE NetworkInterfaceType = 3
	// x-displayName: "Loopback Device"
	// Network interface is a loopback device
	NETWORK_INTERFACE_LOOPBACK_INTERFACE NetworkInterfaceType = 4
	// x-displayName: "Layer2 Interface"
	// Network interface is a layer2 interface
	NETWORK_INTERFACE_LAYER2_INTERFACE NetworkInterfaceType = 5
)

var NetworkInterfaceType_name = map[int32]string{
	0: "NETWORK_INTERFACE_ETHERNET",
	1: "NETWORK_INTERFACE_VLAN_INTERFACE",
	2: "NETWORK_INTERFACE_LACP_INTERFACE",
	3: "NETWORK_INTERFACE_TUNNEL_INTERFACE",
	4: "NETWORK_INTERFACE_LOOPBACK_INTERFACE",
	5: "NETWORK_INTERFACE_LAYER2_INTERFACE",
}

var NetworkInterfaceType_value = map[string]int32{
	"NETWORK_INTERFACE_ETHERNET":           0,
	"NETWORK_INTERFACE_VLAN_INTERFACE":     1,
	"NETWORK_INTERFACE_LACP_INTERFACE":     2,
	"NETWORK_INTERFACE_TUNNEL_INTERFACE":   3,
	"NETWORK_INTERFACE_LOOPBACK_INTERFACE": 4,
	"NETWORK_INTERFACE_LAYER2_INTERFACE":   5,
}

func (NetworkInterfaceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{2}
}

// Network Interface DHCP Client
//
// x-displayName: "DHCP Client"
// Controls whether or not DHCP client is enabled on the interface
type NetworkInterfaceDHCP int32

const (
	// x-displayName: "Disable"
	// DHCP client is disabled
	NETWORK_INTERFACE_DHCP_DISABLE NetworkInterfaceDHCP = 0
	// x-displayName: "Enable"
	// DHCP client is enabled
	NETWORK_INTERFACE_DHCP_ENABLE NetworkInterfaceDHCP = 1
)

var NetworkInterfaceDHCP_name = map[int32]string{
	0: "NETWORK_INTERFACE_DHCP_DISABLE",
	1: "NETWORK_INTERFACE_DHCP_ENABLE",
}

var NetworkInterfaceDHCP_value = map[string]int32{
	"NETWORK_INTERFACE_DHCP_DISABLE": 0,
	"NETWORK_INTERFACE_DHCP_ENABLE":  1,
}

func (NetworkInterfaceDHCP) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{3}
}

// Network Interface VLAN Tagging
//
// x-displayName: "Vlan Tagging"
// Controls whether or not VLAN tagging is enabled on the interface
type NetworkInterfaceVLANTagging int32

const (
	// x-displayName: "Disable"
	// Vlan tagging is disabled
	NETWORK_INTERFACE_VLAN_TAGGING_DISABLE NetworkInterfaceVLANTagging = 0
	// x-displayName: "Enable"
	// Vlan tagging is enabled
	NETWORK_INTERFACE_VLAN_TAGGING_ENABLE NetworkInterfaceVLANTagging = 1
)

var NetworkInterfaceVLANTagging_name = map[int32]string{
	0: "NETWORK_INTERFACE_VLAN_TAGGING_DISABLE",
	1: "NETWORK_INTERFACE_VLAN_TAGGING_ENABLE",
}

var NetworkInterfaceVLANTagging_value = map[string]int32{
	"NETWORK_INTERFACE_VLAN_TAGGING_DISABLE": 0,
	"NETWORK_INTERFACE_VLAN_TAGGING_ENABLE":  1,
}

func (NetworkInterfaceVLANTagging) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{4}
}

// Network Interface Gateway Mode
//
// x-displayName: "Gateway Mode"
// Controls the mode of obtaining gateway address for the interface
type NetworkInterfaceGatewayMode int32

const (
	// x-displayName: "Disable"
	// Gateway is disabled
	NETWORK_INTERFACE_GATEWAY_DISABLE NetworkInterfaceGatewayMode = 0
	// x-displayName: "System Allocated"
	// Gateway is allocated by the system
	NETWORK_INTERFACE_GATEWAY_AUTO_ALLOCATE NetworkInterfaceGatewayMode = 1
	// x-displayName: "User Configured"
	// Use the specified gateway
	NETWORK_INTERFACE_GATEWAY_USE_CONFIGURED NetworkInterfaceGatewayMode = 2
)

var NetworkInterfaceGatewayMode_name = map[int32]string{
	0: "NETWORK_INTERFACE_GATEWAY_DISABLE",
	1: "NETWORK_INTERFACE_GATEWAY_AUTO_ALLOCATE",
	2: "NETWORK_INTERFACE_GATEWAY_USE_CONFIGURED",
}

var NetworkInterfaceGatewayMode_value = map[string]int32{
	"NETWORK_INTERFACE_GATEWAY_DISABLE":        0,
	"NETWORK_INTERFACE_GATEWAY_AUTO_ALLOCATE":  1,
	"NETWORK_INTERFACE_GATEWAY_USE_CONFIGURED": 2,
}

func (NetworkInterfaceGatewayMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{5}
}

// Network Interface DNS Mode
//
// x-displayName: "DNS Mode"
// Controls the mode of obtaining DNS address for the interface
type NetworkInterfaceDNSMode int32

const (
	// x-displayName: "Disable"
	// DNS is disabled
	NETWORK_INTERFACE_DNS_DISABLE NetworkInterfaceDNSMode = 0
	// x-displayName: "System Allocated"
	// DNS is allocated by the system
	NETWORK_INTERFACE_DNS_AUTO_ALLOCATE NetworkInterfaceDNSMode = 1
	// x-displayName: "User Configured"
	// Use the specified DNS
	NETWORK_INTERFACE_DNS_USE_CONFIGURED NetworkInterfaceDNSMode = 2
)

var NetworkInterfaceDNSMode_name = map[int32]string{
	0: "NETWORK_INTERFACE_DNS_DISABLE",
	1: "NETWORK_INTERFACE_DNS_AUTO_ALLOCATE",
	2: "NETWORK_INTERFACE_DNS_USE_CONFIGURED",
}

var NetworkInterfaceDNSMode_value = map[string]int32{
	"NETWORK_INTERFACE_DNS_DISABLE":        0,
	"NETWORK_INTERFACE_DNS_AUTO_ALLOCATE":  1,
	"NETWORK_INTERFACE_DNS_USE_CONFIGURED": 2,
}

func (NetworkInterfaceDNSMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{6}
}

// Network Interface DHCP Server
//
// x-displayName: "DHCP Server"
// Controls whether or not DHCP server runs on the interface
type NetworkInterfaceDHCPServer int32

const (
	// x-displayName: "Disable DHCP Server"
	// DHCP server is disabled
	NETWORK_INTERFACE_DHCP_SERVER_DISABLE NetworkInterfaceDHCPServer = 0
	// x-displayName: "Enable DHCP Server"
	// DHCP server is enabled
	NETWORK_INTERFACE_DHCP_SERVER_ENABLE NetworkInterfaceDHCPServer = 1
	// x-displayName: "Enable Enhanced DHCP Server"
	// Enhanced DHCP server is enabled
	NETWORK_INTERFACE_ENHANCED_DHCP_SERVER_ENABLE NetworkInterfaceDHCPServer = 2
)

var NetworkInterfaceDHCPServer_name = map[int32]string{
	0: "NETWORK_INTERFACE_DHCP_SERVER_DISABLE",
	1: "NETWORK_INTERFACE_DHCP_SERVER_ENABLE",
	2: "NETWORK_INTERFACE_ENHANCED_DHCP_SERVER_ENABLE",
}

var NetworkInterfaceDHCPServer_value = map[string]int32{
	"NETWORK_INTERFACE_DHCP_SERVER_DISABLE":         0,
	"NETWORK_INTERFACE_DHCP_SERVER_ENABLE":          1,
	"NETWORK_INTERFACE_ENHANCED_DHCP_SERVER_ENABLE": 2,
}

func (NetworkInterfaceDHCPServer) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{7}
}

// Interface State
//
// x-displayName: "Interface State"
// Shows the interface link state
type NetworkInterfaceUpDown int32

const (
	// x-displayName: "Admin Down"
	// Interface is admistratively down
	NETWORK_INTERFACE_ADMINISTRATIVELY_DOWN NetworkInterfaceUpDown = 0
	// x-displayName: "Operationally Down"
	// Interface is operationally down
	NETWORK_INTERFACE_OPERATIONALY_DOWN NetworkInterfaceUpDown = 1
	// x-displayName: "Operationally up"
	// Interface is operationally up
	NETWORK_INTERFACE_OPERATIONALY_UP NetworkInterfaceUpDown = 2
)

var NetworkInterfaceUpDown_name = map[int32]string{
	0: "NETWORK_INTERFACE_ADMINISTRATIVELY_DOWN",
	1: "NETWORK_INTERFACE_OPERATIONALY_DOWN",
	2: "NETWORK_INTERFACE_OPERATIONALY_UP",
}

var NetworkInterfaceUpDown_value = map[string]int32{
	"NETWORK_INTERFACE_ADMINISTRATIVELY_DOWN": 0,
	"NETWORK_INTERFACE_OPERATIONALY_DOWN":     1,
	"NETWORK_INTERFACE_OPERATIONALY_UP":       2,
}

func (NetworkInterfaceUpDown) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{8}
}

// Network Interface Default Gateway
//
// x-displayName: "Default Gateway"
// Controls how the Default Gateway of the Network interface is derived
type NetworkInterfaceDFGW struct {
	// Default Gateway Mode
	//
	// x-displayName: "Default Gateway Mode"
	// x-required
	// Mode of obtaining default gateway
	DefaultGatewayMode NetworkInterfaceGatewayMode `protobuf:"varint,1,opt,name=default_gateway_mode,json=defaultGatewayMode,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceGatewayMode" json:"default_gateway_mode,omitempty"`
	// Default Gateway
	//
	// x-displayName: "Default Gateway"
	// Address of default gateway when mode is "use-configured"
	DefaultGatewayAddress *schema.Ipv4AddressType `protobuf:"bytes,2,opt,name=default_gateway_address,json=defaultGatewayAddress,proto3" json:"default_gateway_address,omitempty"`
}

func (m *NetworkInterfaceDFGW) Reset()      { *m = NetworkInterfaceDFGW{} }
func (*NetworkInterfaceDFGW) ProtoMessage() {}
func (*NetworkInterfaceDFGW) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{0}
}
func (m *NetworkInterfaceDFGW) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkInterfaceDFGW) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NetworkInterfaceDFGW) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkInterfaceDFGW.Merge(m, src)
}
func (m *NetworkInterfaceDFGW) XXX_Size() int {
	return m.Size()
}
func (m *NetworkInterfaceDFGW) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkInterfaceDFGW.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkInterfaceDFGW proto.InternalMessageInfo

func (m *NetworkInterfaceDFGW) GetDefaultGatewayMode() NetworkInterfaceGatewayMode {
	if m != nil {
		return m.DefaultGatewayMode
	}
	return NETWORK_INTERFACE_GATEWAY_DISABLE
}

func (m *NetworkInterfaceDFGW) GetDefaultGatewayAddress() *schema.Ipv4AddressType {
	if m != nil {
		return m.DefaultGatewayAddress
	}
	return nil
}

// Network Interface DNS server
//
// x-displayName: "DNS Server"
// Controls how the DNS Server of the Network interface is derived
type NetworkInterfaceDNS struct {
	// DNS Server Mode
	//
	// x-displayName: "DNS Server Mode"
	// x-required
	// Mode of obtaining DNS server
	DnsMode NetworkInterfaceDNSMode `protobuf:"varint,1,opt,name=dns_mode,json=dnsMode,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceDNSMode" json:"dns_mode,omitempty"`
	// DNS Server
	//
	// x-displayName: "DNS Server"
	// Address of DNS server when mode is "use-configured"
	DnsServer []*schema.Ipv4AddressType `protobuf:"bytes,2,rep,name=dns_server,json=dnsServer,proto3" json:"dns_server,omitempty"`
}

func (m *NetworkInterfaceDNS) Reset()      { *m = NetworkInterfaceDNS{} }
func (*NetworkInterfaceDNS) ProtoMessage() {}
func (*NetworkInterfaceDNS) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{1}
}
func (m *NetworkInterfaceDNS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkInterfaceDNS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NetworkInterfaceDNS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkInterfaceDNS.Merge(m, src)
}
func (m *NetworkInterfaceDNS) XXX_Size() int {
	return m.Size()
}
func (m *NetworkInterfaceDNS) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkInterfaceDNS.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkInterfaceDNS proto.InternalMessageInfo

func (m *NetworkInterfaceDNS) GetDnsMode() NetworkInterfaceDNSMode {
	if m != nil {
		return m.DnsMode
	}
	return NETWORK_INTERFACE_DNS_DISABLE
}

func (m *NetworkInterfaceDNS) GetDnsServer() []*schema.Ipv4AddressType {
	if m != nil {
		return m.DnsServer
	}
	return nil
}

// Network Interface Tunnel
//
// x-displayName: "Tunnel"
// Tunnel attached to this interface, enables encapsulation on interface
type NetworkInterfaceTunnel struct {
	// Tunnel
	//
	// x-displayName: "Tunnel"
	// Tunnel which is attached to this interface
	Tunnel []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=tunnel,proto3" json:"tunnel,omitempty"`
}

func (m *NetworkInterfaceTunnel) Reset()      { *m = NetworkInterfaceTunnel{} }
func (*NetworkInterfaceTunnel) ProtoMessage() {}
func (*NetworkInterfaceTunnel) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{2}
}
func (m *NetworkInterfaceTunnel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkInterfaceTunnel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NetworkInterfaceTunnel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkInterfaceTunnel.Merge(m, src)
}
func (m *NetworkInterfaceTunnel) XXX_Size() int {
	return m.Size()
}
func (m *NetworkInterfaceTunnel) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkInterfaceTunnel.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkInterfaceTunnel proto.InternalMessageInfo

func (m *NetworkInterfaceTunnel) GetTunnel() []*schema.ObjectRefType {
	if m != nil {
		return m.Tunnel
	}
	return nil
}

// DHCP IP Range
//
// x-displayName: "DHCP IP Range"
// DHCP pool is a range of IP addresses (start ip and end ip).
type DHCPPoolType struct {
	// Start IP
	//
	// x-displayName: "Starting IP"
	// x-example: "10.1.1.5"
	// Starting IP of the pool range.
	// In case of address allocator, offset is derived based on network prefix.
	// 10.1.1.5 with prefix length of 24, start offset is 0.0.0.5
	StartIp string `protobuf:"bytes,1,opt,name=start_ip,json=startIp,proto3" json:"start_ip,omitempty"`
	// End IP
	//
	// x-displayName: "Ending IP"
	// x-example: "10.1.1.200"
	// Ending IP of the pool range.
	// In case of address allocator, offset is derived based on network prefix.
	// 10.1.1.200 with prefix length of 24, end offset is 0.0.0.200
	EndIp string `protobuf:"bytes,2,opt,name=end_ip,json=endIp,proto3" json:"end_ip,omitempty"`
	// Exclude
	//
	// x-displayName: "Exclude"
	// If exclude is true, IP addresses are not assigned from this range.
	Exclude bool `protobuf:"varint,3,opt,name=exclude,proto3" json:"exclude,omitempty"`
}

func (m *DHCPPoolType) Reset()      { *m = DHCPPoolType{} }
func (*DHCPPoolType) ProtoMessage() {}
func (*DHCPPoolType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{3}
}
func (m *DHCPPoolType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHCPPoolType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DHCPPoolType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHCPPoolType.Merge(m, src)
}
func (m *DHCPPoolType) XXX_Size() int {
	return m.Size()
}
func (m *DHCPPoolType) XXX_DiscardUnknown() {
	xxx_messageInfo_DHCPPoolType.DiscardUnknown(m)
}

var xxx_messageInfo_DHCPPoolType proto.InternalMessageInfo

func (m *DHCPPoolType) GetStartIp() string {
	if m != nil {
		return m.StartIp
	}
	return ""
}

func (m *DHCPPoolType) GetEndIp() string {
	if m != nil {
		return m.EndIp
	}
	return ""
}

func (m *DHCPPoolType) GetExclude() bool {
	if m != nil {
		return m.Exclude
	}
	return false
}

// DHCP IPV6 Range
//
// x-displayName: "DHCP IPV6 Range"
// DHCP IPV6 pool is a range of IP addresses (start ip and end ip).
type DHCPIPV6PoolType struct {
	// Start IPV6
	//
	// x-displayName: "Starting IPV6"
	// x-example: "2001::1"
	// Starting IPV6 address of the pool range.
	// In case of address allocator, offset is derived based on network prefix.
	// 2001::1 with prefix length of 64, start offset is 5
	StartIp string `protobuf:"bytes,1,opt,name=start_ip,json=startIp,proto3" json:"start_ip,omitempty"`
	// End IP
	//
	// x-displayName: "Ending IPV6"
	// x-example: "2001::200"
	// Ending IPV6 address of the pool range.
	// In case of address allocator, offset is derived based on network prefix.
	EndIp string `protobuf:"bytes,2,opt,name=end_ip,json=endIp,proto3" json:"end_ip,omitempty"`
	// Exclude
	//
	// x-displayName: "Exclude"
	// If exclude is true, IP addresses are not assigned from this range.
	Exclude bool `protobuf:"varint,3,opt,name=exclude,proto3" json:"exclude,omitempty"`
}

func (m *DHCPIPV6PoolType) Reset()      { *m = DHCPIPV6PoolType{} }
func (*DHCPIPV6PoolType) ProtoMessage() {}
func (*DHCPIPV6PoolType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{4}
}
func (m *DHCPIPV6PoolType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHCPIPV6PoolType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DHCPIPV6PoolType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHCPIPV6PoolType.Merge(m, src)
}
func (m *DHCPIPV6PoolType) XXX_Size() int {
	return m.Size()
}
func (m *DHCPIPV6PoolType) XXX_DiscardUnknown() {
	xxx_messageInfo_DHCPIPV6PoolType.DiscardUnknown(m)
}

var xxx_messageInfo_DHCPIPV6PoolType proto.InternalMessageInfo

func (m *DHCPIPV6PoolType) GetStartIp() string {
	if m != nil {
		return m.StartIp
	}
	return ""
}

func (m *DHCPIPV6PoolType) GetEndIp() string {
	if m != nil {
		return m.EndIp
	}
	return ""
}

func (m *DHCPIPV6PoolType) GetExclude() bool {
	if m != nil {
		return m.Exclude
	}
	return false
}

// DHCPIPV6NetworkType
//
// x-displayName: "DHCPIPV6NetworkType"
// DHCP IPV6 network type configuration
type DHCPIPV6NetworkType struct {
	// Network Prefix choice
	//
	// x-displayName: "Select Network Prefix Method"
	// x-required
	// Select DHCP network prefix for a site
	//
	// Types that are valid to be assigned to NetworkPrefixChoice:
	//	*DHCPIPV6NetworkType_NetworkPrefix
	//	*DHCPIPV6NetworkType_NetworkPrefixAllocator
	NetworkPrefixChoice isDHCPIPV6NetworkType_NetworkPrefixChoice `protobuf_oneof:"network_prefix_choice"`
	// DHCP pools
	//
	// x-displayName: "DHCP Pools"
	// List of non overlapping ip address ranges.
	Pools []*DHCPIPV6PoolType `protobuf:"bytes,4,rep,name=pools,proto3" json:"pools,omitempty"`
}

func (m *DHCPIPV6NetworkType) Reset()      { *m = DHCPIPV6NetworkType{} }
func (*DHCPIPV6NetworkType) ProtoMessage() {}
func (*DHCPIPV6NetworkType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{5}
}
func (m *DHCPIPV6NetworkType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHCPIPV6NetworkType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DHCPIPV6NetworkType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHCPIPV6NetworkType.Merge(m, src)
}
func (m *DHCPIPV6NetworkType) XXX_Size() int {
	return m.Size()
}
func (m *DHCPIPV6NetworkType) XXX_DiscardUnknown() {
	xxx_messageInfo_DHCPIPV6NetworkType.DiscardUnknown(m)
}

var xxx_messageInfo_DHCPIPV6NetworkType proto.InternalMessageInfo

type isDHCPIPV6NetworkType_NetworkPrefixChoice interface {
	isDHCPIPV6NetworkType_NetworkPrefixChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DHCPIPV6NetworkType_NetworkPrefix struct {
	NetworkPrefix string `protobuf:"bytes,2,opt,name=network_prefix,json=networkPrefix,proto3,oneof" json:"network_prefix,omitempty"`
}
type DHCPIPV6NetworkType_NetworkPrefixAllocator struct {
	NetworkPrefixAllocator *views.ObjectRefType `protobuf:"bytes,3,opt,name=network_prefix_allocator,json=networkPrefixAllocator,proto3,oneof" json:"network_prefix_allocator,omitempty"`
}

func (*DHCPIPV6NetworkType_NetworkPrefix) isDHCPIPV6NetworkType_NetworkPrefixChoice()          {}
func (*DHCPIPV6NetworkType_NetworkPrefixAllocator) isDHCPIPV6NetworkType_NetworkPrefixChoice() {}

func (m *DHCPIPV6NetworkType) GetNetworkPrefixChoice() isDHCPIPV6NetworkType_NetworkPrefixChoice {
	if m != nil {
		return m.NetworkPrefixChoice
	}
	return nil
}

func (m *DHCPIPV6NetworkType) GetNetworkPrefix() string {
	if x, ok := m.GetNetworkPrefixChoice().(*DHCPIPV6NetworkType_NetworkPrefix); ok {
		return x.NetworkPrefix
	}
	return ""
}

func (m *DHCPIPV6NetworkType) GetNetworkPrefixAllocator() *views.ObjectRefType {
	if x, ok := m.GetNetworkPrefixChoice().(*DHCPIPV6NetworkType_NetworkPrefixAllocator); ok {
		return x.NetworkPrefixAllocator
	}
	return nil
}

func (m *DHCPIPV6NetworkType) GetPools() []*DHCPIPV6PoolType {
	if m != nil {
		return m.Pools
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DHCPIPV6NetworkType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DHCPIPV6NetworkType_NetworkPrefix)(nil),
		(*DHCPIPV6NetworkType_NetworkPrefixAllocator)(nil),
	}
}

// DHCP Network
//
// x-displayName: "DHCP Network"
// DHCP network configuration
type DHCPNetworkType struct {
	// Network Prefix choice
	//
	// x-displayName: "Select Network Prefix Method"
	// x-required
	// Select DHCP network prefix for a site
	//
	// Types that are valid to be assigned to NetworkPrefixChoice:
	//	*DHCPNetworkType_NetworkPrefix
	//	*DHCPNetworkType_NetworkPrefixAllocator
	NetworkPrefixChoice isDHCPNetworkType_NetworkPrefixChoice `protobuf_oneof:"network_prefix_choice"`
	// DHCP pools
	//
	// x-displayName: "DHCP Pools"
	// List of non overlapping ip address ranges.
	Pools []*DHCPPoolType `protobuf:"bytes,4,rep,name=pools,proto3" json:"pools,omitempty"`
	// Default gateway Address
	//
	// x-displayName: "Select Default Gateway address"
	// x-required
	// Select how default gateway address is determined
	//
	// Types that are valid to be assigned to GatewayChoice:
	//	*DHCPNetworkType_FirstAddress
	//	*DHCPNetworkType_LastAddress
	//	*DHCPNetworkType_DgwAddress
	GatewayChoice isDHCPNetworkType_GatewayChoice `protobuf_oneof:"gateway_choice"`
	// DNS server Address
	//
	// x-displayName: "Select DNS server address"
	// x-required
	// Select how default gateway address is determined
	//
	// Types that are valid to be assigned to DnsChoice:
	//	*DHCPNetworkType_SameAsDgw
	//	*DHCPNetworkType_DnsAddress
	DnsChoice isDHCPNetworkType_DnsChoice `protobuf_oneof:"dns_choice"`
	// DHCP Pool Settings
	//
	// x-displayName: "DHCP Pool Settings"
	// x-required
	// Controls how DHCP pools are handled
	PoolSettings DHCPPoolSettingType `protobuf:"varint,12,opt,name=pool_settings,json=poolSettings,proto3,enum=ves.io.schema.network_interface.DHCPPoolSettingType" json:"pool_settings,omitempty"`
}

func (m *DHCPNetworkType) Reset()      { *m = DHCPNetworkType{} }
func (*DHCPNetworkType) ProtoMessage() {}
func (*DHCPNetworkType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{6}
}
func (m *DHCPNetworkType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHCPNetworkType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DHCPNetworkType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHCPNetworkType.Merge(m, src)
}
func (m *DHCPNetworkType) XXX_Size() int {
	return m.Size()
}
func (m *DHCPNetworkType) XXX_DiscardUnknown() {
	xxx_messageInfo_DHCPNetworkType.DiscardUnknown(m)
}

var xxx_messageInfo_DHCPNetworkType proto.InternalMessageInfo

type isDHCPNetworkType_NetworkPrefixChoice interface {
	isDHCPNetworkType_NetworkPrefixChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isDHCPNetworkType_GatewayChoice interface {
	isDHCPNetworkType_GatewayChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isDHCPNetworkType_DnsChoice interface {
	isDHCPNetworkType_DnsChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DHCPNetworkType_NetworkPrefix struct {
	NetworkPrefix string `protobuf:"bytes,2,opt,name=network_prefix,json=networkPrefix,proto3,oneof" json:"network_prefix,omitempty"`
}
type DHCPNetworkType_NetworkPrefixAllocator struct {
	NetworkPrefixAllocator *views.ObjectRefType `protobuf:"bytes,3,opt,name=network_prefix_allocator,json=networkPrefixAllocator,proto3,oneof" json:"network_prefix_allocator,omitempty"`
}
type DHCPNetworkType_FirstAddress struct {
	FirstAddress *schema.Empty `protobuf:"bytes,6,opt,name=first_address,json=firstAddress,proto3,oneof" json:"first_address,omitempty"`
}
type DHCPNetworkType_LastAddress struct {
	LastAddress *schema.Empty `protobuf:"bytes,7,opt,name=last_address,json=lastAddress,proto3,oneof" json:"last_address,omitempty"`
}
type DHCPNetworkType_DgwAddress struct {
	DgwAddress string `protobuf:"bytes,8,opt,name=dgw_address,json=dgwAddress,proto3,oneof" json:"dgw_address,omitempty"`
}
type DHCPNetworkType_SameAsDgw struct {
	SameAsDgw *schema.Empty `protobuf:"bytes,10,opt,name=same_as_dgw,json=sameAsDgw,proto3,oneof" json:"same_as_dgw,omitempty"`
}
type DHCPNetworkType_DnsAddress struct {
	DnsAddress string `protobuf:"bytes,11,opt,name=dns_address,json=dnsAddress,proto3,oneof" json:"dns_address,omitempty"`
}

func (*DHCPNetworkType_NetworkPrefix) isDHCPNetworkType_NetworkPrefixChoice()          {}
func (*DHCPNetworkType_NetworkPrefixAllocator) isDHCPNetworkType_NetworkPrefixChoice() {}
func (*DHCPNetworkType_FirstAddress) isDHCPNetworkType_GatewayChoice()                 {}
func (*DHCPNetworkType_LastAddress) isDHCPNetworkType_GatewayChoice()                  {}
func (*DHCPNetworkType_DgwAddress) isDHCPNetworkType_GatewayChoice()                   {}
func (*DHCPNetworkType_SameAsDgw) isDHCPNetworkType_DnsChoice()                        {}
func (*DHCPNetworkType_DnsAddress) isDHCPNetworkType_DnsChoice()                       {}

func (m *DHCPNetworkType) GetNetworkPrefixChoice() isDHCPNetworkType_NetworkPrefixChoice {
	if m != nil {
		return m.NetworkPrefixChoice
	}
	return nil
}
func (m *DHCPNetworkType) GetGatewayChoice() isDHCPNetworkType_GatewayChoice {
	if m != nil {
		return m.GatewayChoice
	}
	return nil
}
func (m *DHCPNetworkType) GetDnsChoice() isDHCPNetworkType_DnsChoice {
	if m != nil {
		return m.DnsChoice
	}
	return nil
}

func (m *DHCPNetworkType) GetNetworkPrefix() string {
	if x, ok := m.GetNetworkPrefixChoice().(*DHCPNetworkType_NetworkPrefix); ok {
		return x.NetworkPrefix
	}
	return ""
}

func (m *DHCPNetworkType) GetNetworkPrefixAllocator() *views.ObjectRefType {
	if x, ok := m.GetNetworkPrefixChoice().(*DHCPNetworkType_NetworkPrefixAllocator); ok {
		return x.NetworkPrefixAllocator
	}
	return nil
}

func (m *DHCPNetworkType) GetPools() []*DHCPPoolType {
	if m != nil {
		return m.Pools
	}
	return nil
}

func (m *DHCPNetworkType) GetFirstAddress() *schema.Empty {
	if x, ok := m.GetGatewayChoice().(*DHCPNetworkType_FirstAddress); ok {
		return x.FirstAddress
	}
	return nil
}

func (m *DHCPNetworkType) GetLastAddress() *schema.Empty {
	if x, ok := m.GetGatewayChoice().(*DHCPNetworkType_LastAddress); ok {
		return x.LastAddress
	}
	return nil
}

func (m *DHCPNetworkType) GetDgwAddress() string {
	if x, ok := m.GetGatewayChoice().(*DHCPNetworkType_DgwAddress); ok {
		return x.DgwAddress
	}
	return ""
}

func (m *DHCPNetworkType) GetSameAsDgw() *schema.Empty {
	if x, ok := m.GetDnsChoice().(*DHCPNetworkType_SameAsDgw); ok {
		return x.SameAsDgw
	}
	return nil
}

func (m *DHCPNetworkType) GetDnsAddress() string {
	if x, ok := m.GetDnsChoice().(*DHCPNetworkType_DnsAddress); ok {
		return x.DnsAddress
	}
	return ""
}

func (m *DHCPNetworkType) GetPoolSettings() DHCPPoolSettingType {
	if m != nil {
		return m.PoolSettings
	}
	return INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DHCPNetworkType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DHCPNetworkType_NetworkPrefix)(nil),
		(*DHCPNetworkType_NetworkPrefixAllocator)(nil),
		(*DHCPNetworkType_FirstAddress)(nil),
		(*DHCPNetworkType_LastAddress)(nil),
		(*DHCPNetworkType_DgwAddress)(nil),
		(*DHCPNetworkType_SameAsDgw)(nil),
		(*DHCPNetworkType_DnsAddress)(nil),
	}
}

// Interface IP Assignments
//
// x-displayName: "Interface IP Assignments"
// Map of Interface IP assignments per node
type DHCPInterfaceIPType struct {
	// Site:Node to IP mapping
	//
	// x-displayName: "Site:Node to IP Mapping"
	// x-example: "value"
	// Map of Site:Node to IP address.
	InterfaceIpMap map[string]string `protobuf:"bytes,1,rep,name=interface_ip_map,json=interfaceIpMap,proto3" json:"interface_ip_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *DHCPInterfaceIPType) Reset()      { *m = DHCPInterfaceIPType{} }
func (*DHCPInterfaceIPType) ProtoMessage() {}
func (*DHCPInterfaceIPType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{7}
}
func (m *DHCPInterfaceIPType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHCPInterfaceIPType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DHCPInterfaceIPType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHCPInterfaceIPType.Merge(m, src)
}
func (m *DHCPInterfaceIPType) XXX_Size() int {
	return m.Size()
}
func (m *DHCPInterfaceIPType) XXX_DiscardUnknown() {
	xxx_messageInfo_DHCPInterfaceIPType.DiscardUnknown(m)
}

var xxx_messageInfo_DHCPInterfaceIPType proto.InternalMessageInfo

func (m *DHCPInterfaceIPType) GetInterfaceIpMap() map[string]string {
	if m != nil {
		return m.InterfaceIpMap
	}
	return nil
}

// Interface IPV6 Assignments
//
// x-displayName: "Interface IPV6 Assignments"
// Map of Interface IPV6 assignments per node
type DHCPInterfaceIPV6Type struct {
	// Site:Node to IPV6 mapping
	//
	// x-displayName: "Site:Node to IPV6 Mapping"
	// x-example: "value"
	// Map of Site:Node to IPV6 address.
	InterfaceIpMap map[string]string `protobuf:"bytes,1,rep,name=interface_ip_map,json=interfaceIpMap,proto3" json:"interface_ip_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *DHCPInterfaceIPV6Type) Reset()      { *m = DHCPInterfaceIPV6Type{} }
func (*DHCPInterfaceIPV6Type) ProtoMessage() {}
func (*DHCPInterfaceIPV6Type) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{8}
}
func (m *DHCPInterfaceIPV6Type) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHCPInterfaceIPV6Type) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DHCPInterfaceIPV6Type) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHCPInterfaceIPV6Type.Merge(m, src)
}
func (m *DHCPInterfaceIPV6Type) XXX_Size() int {
	return m.Size()
}
func (m *DHCPInterfaceIPV6Type) XXX_DiscardUnknown() {
	xxx_messageInfo_DHCPInterfaceIPV6Type.DiscardUnknown(m)
}

var xxx_messageInfo_DHCPInterfaceIPV6Type proto.InternalMessageInfo

func (m *DHCPInterfaceIPV6Type) GetInterfaceIpMap() map[string]string {
	if m != nil {
		return m.InterfaceIpMap
	}
	return nil
}

// DHCPServerParametersType
//
// x-displayName: "DHCPServerParametersType"
type DHCPServerParametersType struct {
	// DHCP Networks
	//
	// x-displayName: "DHCP Networks"
	// x-required
	// List of networks from which DHCP server can allocate ip addresses
	DhcpNetworks []*DHCPNetworkType `protobuf:"bytes,1,rep,name=dhcp_networks,json=dhcpNetworks,proto3" json:"dhcp_networks,omitempty"`
	// Interface IP(s)
	//
	// x-displayName: "Select Interface Addressing"
	// x-required
	// Specify how interfaces on each node are assigned local address
	//
	// Types that are valid to be assigned to InterfacesAddressingChoice:
	//	*DHCPServerParametersType_AutomaticFromStart
	//	*DHCPServerParametersType_AutomaticFromEnd
	//	*DHCPServerParametersType_InterfaceIpMap
	InterfacesAddressingChoice isDHCPServerParametersType_InterfacesAddressingChoice `protobuf_oneof:"interfaces_addressing_choice"`
	// Fixed IP Assignments
	//
	// x-displayName: "Fixed MAC address to IP Assignments"
	// x-example: "value"
	// Fixed MAC address to ip assignments, Key: Mac address, Value: IP Address
	FixedIpMap map[string]string `protobuf:"bytes,6,rep,name=fixed_ip_map,json=fixedIpMap,proto3" json:"fixed_ip_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Option 82 Tag
	//
	// x-displayName: "Option 82 Tag"
	// x-example: "network_red"
	// Optional tag that can be given to this configuration
	DhcpOption82Tag string `protobuf:"bytes,7,opt,name=dhcp_option82_tag,json=dhcpOption82Tag,proto3" json:"dhcp_option82_tag,omitempty"`
}

func (m *DHCPServerParametersType) Reset()      { *m = DHCPServerParametersType{} }
func (*DHCPServerParametersType) ProtoMessage() {}
func (*DHCPServerParametersType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{9}
}
func (m *DHCPServerParametersType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHCPServerParametersType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DHCPServerParametersType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHCPServerParametersType.Merge(m, src)
}
func (m *DHCPServerParametersType) XXX_Size() int {
	return m.Size()
}
func (m *DHCPServerParametersType) XXX_DiscardUnknown() {
	xxx_messageInfo_DHCPServerParametersType.DiscardUnknown(m)
}

var xxx_messageInfo_DHCPServerParametersType proto.InternalMessageInfo

type isDHCPServerParametersType_InterfacesAddressingChoice interface {
	isDHCPServerParametersType_InterfacesAddressingChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DHCPServerParametersType_AutomaticFromStart struct {
	AutomaticFromStart *schema.Empty `protobuf:"bytes,3,opt,name=automatic_from_start,json=automaticFromStart,proto3,oneof" json:"automatic_from_start,omitempty"`
}
type DHCPServerParametersType_AutomaticFromEnd struct {
	AutomaticFromEnd *schema.Empty `protobuf:"bytes,4,opt,name=automatic_from_end,json=automaticFromEnd,proto3,oneof" json:"automatic_from_end,omitempty"`
}
type DHCPServerParametersType_InterfaceIpMap struct {
	InterfaceIpMap *DHCPInterfaceIPType `protobuf:"bytes,5,opt,name=interface_ip_map,json=interfaceIpMap,proto3,oneof" json:"interface_ip_map,omitempty"`
}

func (*DHCPServerParametersType_AutomaticFromStart) isDHCPServerParametersType_InterfacesAddressingChoice() {
}
func (*DHCPServerParametersType_AutomaticFromEnd) isDHCPServerParametersType_InterfacesAddressingChoice() {
}
func (*DHCPServerParametersType_InterfaceIpMap) isDHCPServerParametersType_InterfacesAddressingChoice() {
}

func (m *DHCPServerParametersType) GetInterfacesAddressingChoice() isDHCPServerParametersType_InterfacesAddressingChoice {
	if m != nil {
		return m.InterfacesAddressingChoice
	}
	return nil
}

func (m *DHCPServerParametersType) GetDhcpNetworks() []*DHCPNetworkType {
	if m != nil {
		return m.DhcpNetworks
	}
	return nil
}

func (m *DHCPServerParametersType) GetAutomaticFromStart() *schema.Empty {
	if x, ok := m.GetInterfacesAddressingChoice().(*DHCPServerParametersType_AutomaticFromStart); ok {
		return x.AutomaticFromStart
	}
	return nil
}

func (m *DHCPServerParametersType) GetAutomaticFromEnd() *schema.Empty {
	if x, ok := m.GetInterfacesAddressingChoice().(*DHCPServerParametersType_AutomaticFromEnd); ok {
		return x.AutomaticFromEnd
	}
	return nil
}

func (m *DHCPServerParametersType) GetInterfaceIpMap() *DHCPInterfaceIPType {
	if x, ok := m.GetInterfacesAddressingChoice().(*DHCPServerParametersType_InterfaceIpMap); ok {
		return x.InterfaceIpMap
	}
	return nil
}

func (m *DHCPServerParametersType) GetFixedIpMap() map[string]string {
	if m != nil {
		return m.FixedIpMap
	}
	return nil
}

func (m *DHCPServerParametersType) GetDhcpOption82Tag() string {
	if m != nil {
		return m.DhcpOption82Tag
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DHCPServerParametersType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DHCPServerParametersType_AutomaticFromStart)(nil),
		(*DHCPServerParametersType_AutomaticFromEnd)(nil),
		(*DHCPServerParametersType_InterfaceIpMap)(nil),
	}
}

// IPV6AutoConfigType
//
// x-displayName: "IPV6AutoConfigType"
type IPV6AutoConfigType struct {
	// Auto config Choice
	//
	// x-displayName: "Select Auto Config Choice"
	// x-required
	// Specify how the system should behave w.r.t IPV6 auto configuration
	//
	// Types that are valid to be assigned to AutoconfigChoice:
	//	*IPV6AutoConfigType_Host
	//	*IPV6AutoConfigType_Router
	AutoconfigChoice isIPV6AutoConfigType_AutoconfigChoice `protobuf_oneof:"autoconfig_choice"`
}

func (m *IPV6AutoConfigType) Reset()      { *m = IPV6AutoConfigType{} }
func (*IPV6AutoConfigType) ProtoMessage() {}
func (*IPV6AutoConfigType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{10}
}
func (m *IPV6AutoConfigType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPV6AutoConfigType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IPV6AutoConfigType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPV6AutoConfigType.Merge(m, src)
}
func (m *IPV6AutoConfigType) XXX_Size() int {
	return m.Size()
}
func (m *IPV6AutoConfigType) XXX_DiscardUnknown() {
	xxx_messageInfo_IPV6AutoConfigType.DiscardUnknown(m)
}

var xxx_messageInfo_IPV6AutoConfigType proto.InternalMessageInfo

type isIPV6AutoConfigType_AutoconfigChoice interface {
	isIPV6AutoConfigType_AutoconfigChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type IPV6AutoConfigType_Host struct {
	Host *schema.Empty `protobuf:"bytes,2,opt,name=host,proto3,oneof" json:"host,omitempty"`
}
type IPV6AutoConfigType_Router struct {
	Router *IPV6AutoConfigRouterType `protobuf:"bytes,3,opt,name=router,proto3,oneof" json:"router,omitempty"`
}

func (*IPV6AutoConfigType_Host) isIPV6AutoConfigType_AutoconfigChoice()   {}
func (*IPV6AutoConfigType_Router) isIPV6AutoConfigType_AutoconfigChoice() {}

func (m *IPV6AutoConfigType) GetAutoconfigChoice() isIPV6AutoConfigType_AutoconfigChoice {
	if m != nil {
		return m.AutoconfigChoice
	}
	return nil
}

func (m *IPV6AutoConfigType) GetHost() *schema.Empty {
	if x, ok := m.GetAutoconfigChoice().(*IPV6AutoConfigType_Host); ok {
		return x.Host
	}
	return nil
}

func (m *IPV6AutoConfigType) GetRouter() *IPV6AutoConfigRouterType {
	if x, ok := m.GetAutoconfigChoice().(*IPV6AutoConfigType_Router); ok {
		return x.Router
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*IPV6AutoConfigType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*IPV6AutoConfigType_Host)(nil),
		(*IPV6AutoConfigType_Router)(nil),
	}
}

// IPV6AutoConfigRouterType
//
// x-displayName: "IPV6AutoConfigRouterType"
type IPV6AutoConfigRouterType struct {
	// address choice
	//
	// x-displayName: "Select Address Choice"
	// x-required
	// Specify how the address need to be obtained for interfaces and clients
	//
	// Types that are valid to be assigned to AddressChoice:
	//	*IPV6AutoConfigRouterType_NetworkPrefix
	//	*IPV6AutoConfigRouterType_Stateful
	AddressChoice isIPV6AutoConfigRouterType_AddressChoice `protobuf_oneof:"address_choice"`
	// Dns Information
	//
	// x-displayName: "DNS Information"
	// Dns information that needs to added in the RouterAdvetisement
	DnsConfig *IPV6DnsConfig `protobuf:"bytes,4,opt,name=dns_config,json=dnsConfig,proto3" json:"dns_config,omitempty"`
}

func (m *IPV6AutoConfigRouterType) Reset()      { *m = IPV6AutoConfigRouterType{} }
func (*IPV6AutoConfigRouterType) ProtoMessage() {}
func (*IPV6AutoConfigRouterType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{11}
}
func (m *IPV6AutoConfigRouterType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPV6AutoConfigRouterType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IPV6AutoConfigRouterType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPV6AutoConfigRouterType.Merge(m, src)
}
func (m *IPV6AutoConfigRouterType) XXX_Size() int {
	return m.Size()
}
func (m *IPV6AutoConfigRouterType) XXX_DiscardUnknown() {
	xxx_messageInfo_IPV6AutoConfigRouterType.DiscardUnknown(m)
}

var xxx_messageInfo_IPV6AutoConfigRouterType proto.InternalMessageInfo

type isIPV6AutoConfigRouterType_AddressChoice interface {
	isIPV6AutoConfigRouterType_AddressChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type IPV6AutoConfigRouterType_NetworkPrefix struct {
	NetworkPrefix string `protobuf:"bytes,2,opt,name=network_prefix,json=networkPrefix,proto3,oneof" json:"network_prefix,omitempty"`
}
type IPV6AutoConfigRouterType_Stateful struct {
	Stateful *DHCPIPV6StatefulServer `protobuf:"bytes,3,opt,name=stateful,proto3,oneof" json:"stateful,omitempty"`
}

func (*IPV6AutoConfigRouterType_NetworkPrefix) isIPV6AutoConfigRouterType_AddressChoice() {}
func (*IPV6AutoConfigRouterType_Stateful) isIPV6AutoConfigRouterType_AddressChoice()      {}

func (m *IPV6AutoConfigRouterType) GetAddressChoice() isIPV6AutoConfigRouterType_AddressChoice {
	if m != nil {
		return m.AddressChoice
	}
	return nil
}

func (m *IPV6AutoConfigRouterType) GetNetworkPrefix() string {
	if x, ok := m.GetAddressChoice().(*IPV6AutoConfigRouterType_NetworkPrefix); ok {
		return x.NetworkPrefix
	}
	return ""
}

func (m *IPV6AutoConfigRouterType) GetStateful() *DHCPIPV6StatefulServer {
	if x, ok := m.GetAddressChoice().(*IPV6AutoConfigRouterType_Stateful); ok {
		return x.Stateful
	}
	return nil
}

func (m *IPV6AutoConfigRouterType) GetDnsConfig() *IPV6DnsConfig {
	if m != nil {
		return m.DnsConfig
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*IPV6AutoConfigRouterType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*IPV6AutoConfigRouterType_NetworkPrefix)(nil),
		(*IPV6AutoConfigRouterType_Stateful)(nil),
	}
}

// IPV6DnsList
//
// x-displayName: "IPV6DnsList"
type IPV6DnsList struct {
	// Dns List
	//
	// x-displayName: "Dns List"
	// x-required
	// x-example: "2001::11"
	// List of IPV6 Addresses acting as Dns servers
	DnsList []string `protobuf:"bytes,1,rep,name=dns_list,json=dnsList,proto3" json:"dns_list,omitempty"`
}

func (m *IPV6DnsList) Reset()      { *m = IPV6DnsList{} }
func (*IPV6DnsList) ProtoMessage() {}
func (*IPV6DnsList) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{12}
}
func (m *IPV6DnsList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPV6DnsList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IPV6DnsList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPV6DnsList.Merge(m, src)
}
func (m *IPV6DnsList) XXX_Size() int {
	return m.Size()
}
func (m *IPV6DnsList) XXX_DiscardUnknown() {
	xxx_messageInfo_IPV6DnsList.DiscardUnknown(m)
}

var xxx_messageInfo_IPV6DnsList proto.InternalMessageInfo

func (m *IPV6DnsList) GetDnsList() []string {
	if m != nil {
		return m.DnsList
	}
	return nil
}

// IPV6LocalDnsAddress
//
// x-displayName: "IPV6LocalDnsAddress"
type IPV6LocalDnsAddress struct {
	// Local Dns Address
	//
	// x-displayName: "Select local dns address"
	// x-required
	// Select address from network prefix range as dns server
	//
	// Types that are valid to be assigned to LocalDnsChoice:
	//	*IPV6LocalDnsAddress_FirstAddress
	//	*IPV6LocalDnsAddress_LastAddress
	//	*IPV6LocalDnsAddress_ConfiguredAddress
	LocalDnsChoice isIPV6LocalDnsAddress_LocalDnsChoice `protobuf_oneof:"local_dns_choice"`
}

func (m *IPV6LocalDnsAddress) Reset()      { *m = IPV6LocalDnsAddress{} }
func (*IPV6LocalDnsAddress) ProtoMessage() {}
func (*IPV6LocalDnsAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{13}
}
func (m *IPV6LocalDnsAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPV6LocalDnsAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IPV6LocalDnsAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPV6LocalDnsAddress.Merge(m, src)
}
func (m *IPV6LocalDnsAddress) XXX_Size() int {
	return m.Size()
}
func (m *IPV6LocalDnsAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_IPV6LocalDnsAddress.DiscardUnknown(m)
}

var xxx_messageInfo_IPV6LocalDnsAddress proto.InternalMessageInfo

type isIPV6LocalDnsAddress_LocalDnsChoice interface {
	isIPV6LocalDnsAddress_LocalDnsChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type IPV6LocalDnsAddress_FirstAddress struct {
	FirstAddress *schema.Empty `protobuf:"bytes,3,opt,name=first_address,json=firstAddress,proto3,oneof" json:"first_address,omitempty"`
}
type IPV6LocalDnsAddress_LastAddress struct {
	LastAddress *schema.Empty `protobuf:"bytes,4,opt,name=last_address,json=lastAddress,proto3,oneof" json:"last_address,omitempty"`
}
type IPV6LocalDnsAddress_ConfiguredAddress struct {
	ConfiguredAddress string `protobuf:"bytes,5,opt,name=configured_address,json=configuredAddress,proto3,oneof" json:"configured_address,omitempty"`
}

func (*IPV6LocalDnsAddress_FirstAddress) isIPV6LocalDnsAddress_LocalDnsChoice()      {}
func (*IPV6LocalDnsAddress_LastAddress) isIPV6LocalDnsAddress_LocalDnsChoice()       {}
func (*IPV6LocalDnsAddress_ConfiguredAddress) isIPV6LocalDnsAddress_LocalDnsChoice() {}

func (m *IPV6LocalDnsAddress) GetLocalDnsChoice() isIPV6LocalDnsAddress_LocalDnsChoice {
	if m != nil {
		return m.LocalDnsChoice
	}
	return nil
}

func (m *IPV6LocalDnsAddress) GetFirstAddress() *schema.Empty {
	if x, ok := m.GetLocalDnsChoice().(*IPV6LocalDnsAddress_FirstAddress); ok {
		return x.FirstAddress
	}
	return nil
}

func (m *IPV6LocalDnsAddress) GetLastAddress() *schema.Empty {
	if x, ok := m.GetLocalDnsChoice().(*IPV6LocalDnsAddress_LastAddress); ok {
		return x.LastAddress
	}
	return nil
}

func (m *IPV6LocalDnsAddress) GetConfiguredAddress() string {
	if x, ok := m.GetLocalDnsChoice().(*IPV6LocalDnsAddress_ConfiguredAddress); ok {
		return x.ConfiguredAddress
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*IPV6LocalDnsAddress) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*IPV6LocalDnsAddress_FirstAddress)(nil),
		(*IPV6LocalDnsAddress_LastAddress)(nil),
		(*IPV6LocalDnsAddress_ConfiguredAddress)(nil),
	}
}

// IPV6DnsConfig
//
// x-displayName: "IPV6DnsConfig"
type IPV6DnsConfig struct {
	// DNS server Address
	//
	// x-displayName: "Select DNS server address"
	// x-required
	// Select how DNS server address is determined
	//
	// Types that are valid to be assigned to DnsChoice:
	//	*IPV6DnsConfig_LocalDns
	//	*IPV6DnsConfig_ConfiguredList
	DnsChoice isIPV6DnsConfig_DnsChoice `protobuf_oneof:"dns_choice"`
}

func (m *IPV6DnsConfig) Reset()      { *m = IPV6DnsConfig{} }
func (*IPV6DnsConfig) ProtoMessage() {}
func (*IPV6DnsConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{14}
}
func (m *IPV6DnsConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPV6DnsConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IPV6DnsConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPV6DnsConfig.Merge(m, src)
}
func (m *IPV6DnsConfig) XXX_Size() int {
	return m.Size()
}
func (m *IPV6DnsConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_IPV6DnsConfig.DiscardUnknown(m)
}

var xxx_messageInfo_IPV6DnsConfig proto.InternalMessageInfo

type isIPV6DnsConfig_DnsChoice interface {
	isIPV6DnsConfig_DnsChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type IPV6DnsConfig_LocalDns struct {
	LocalDns *IPV6LocalDnsAddress `protobuf:"bytes,2,opt,name=local_dns,json=localDns,proto3,oneof" json:"local_dns,omitempty"`
}
type IPV6DnsConfig_ConfiguredList struct {
	ConfiguredList *IPV6DnsList `protobuf:"bytes,3,opt,name=configured_list,json=configuredList,proto3,oneof" json:"configured_list,omitempty"`
}

func (*IPV6DnsConfig_LocalDns) isIPV6DnsConfig_DnsChoice()       {}
func (*IPV6DnsConfig_ConfiguredList) isIPV6DnsConfig_DnsChoice() {}

func (m *IPV6DnsConfig) GetDnsChoice() isIPV6DnsConfig_DnsChoice {
	if m != nil {
		return m.DnsChoice
	}
	return nil
}

func (m *IPV6DnsConfig) GetLocalDns() *IPV6LocalDnsAddress {
	if x, ok := m.GetDnsChoice().(*IPV6DnsConfig_LocalDns); ok {
		return x.LocalDns
	}
	return nil
}

func (m *IPV6DnsConfig) GetConfiguredList() *IPV6DnsList {
	if x, ok := m.GetDnsChoice().(*IPV6DnsConfig_ConfiguredList); ok {
		return x.ConfiguredList
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*IPV6DnsConfig) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*IPV6DnsConfig_LocalDns)(nil),
		(*IPV6DnsConfig_ConfiguredList)(nil),
	}
}

// DHCPIPV6StatefulServer
//
// x-displayName: "DHCPIPV6 Stateful Server"
type DHCPIPV6StatefulServer struct {
	// DHCP IPV6 Networks
	//
	// x-displayName: "DHCP IPV6 Networks"
	// x-required
	// List of networks from which DHCP server can allocate ip addresses
	DhcpNetworks []*DHCPIPV6NetworkType `protobuf:"bytes,1,rep,name=dhcp_networks,json=dhcpNetworks,proto3" json:"dhcp_networks,omitempty"`
	// Interface IP(s)
	//
	// x-displayName: "Select Interface Addressing"
	// x-required
	// Specify how interfaces on each node are assigned local address
	//
	// Types that are valid to be assigned to InterfacesAddressingChoice:
	//	*DHCPIPV6StatefulServer_AutomaticFromStart
	//	*DHCPIPV6StatefulServer_AutomaticFromEnd
	//	*DHCPIPV6StatefulServer_InterfaceIpMap
	InterfacesAddressingChoice isDHCPIPV6StatefulServer_InterfacesAddressingChoice `protobuf_oneof:"interfaces_addressing_choice"`
	// Fixed IPV6 Assignments
	//
	// x-displayName: "Fixed MAC address to IPV6 Assignments"
	// x-example: "value"
	// Fixed MAC address to ipv6 assignments, Key: Mac address, Value: IPV6 Address
	FixedIpMap map[string]string `protobuf:"bytes,6,rep,name=fixed_ip_map,json=fixedIpMap,proto3" json:"fixed_ip_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *DHCPIPV6StatefulServer) Reset()      { *m = DHCPIPV6StatefulServer{} }
func (*DHCPIPV6StatefulServer) ProtoMessage() {}
func (*DHCPIPV6StatefulServer) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{15}
}
func (m *DHCPIPV6StatefulServer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DHCPIPV6StatefulServer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DHCPIPV6StatefulServer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DHCPIPV6StatefulServer.Merge(m, src)
}
func (m *DHCPIPV6StatefulServer) XXX_Size() int {
	return m.Size()
}
func (m *DHCPIPV6StatefulServer) XXX_DiscardUnknown() {
	xxx_messageInfo_DHCPIPV6StatefulServer.DiscardUnknown(m)
}

var xxx_messageInfo_DHCPIPV6StatefulServer proto.InternalMessageInfo

type isDHCPIPV6StatefulServer_InterfacesAddressingChoice interface {
	isDHCPIPV6StatefulServer_InterfacesAddressingChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DHCPIPV6StatefulServer_AutomaticFromStart struct {
	AutomaticFromStart *schema.Empty `protobuf:"bytes,3,opt,name=automatic_from_start,json=automaticFromStart,proto3,oneof" json:"automatic_from_start,omitempty"`
}
type DHCPIPV6StatefulServer_AutomaticFromEnd struct {
	AutomaticFromEnd *schema.Empty `protobuf:"bytes,4,opt,name=automatic_from_end,json=automaticFromEnd,proto3,oneof" json:"automatic_from_end,omitempty"`
}
type DHCPIPV6StatefulServer_InterfaceIpMap struct {
	InterfaceIpMap *DHCPInterfaceIPV6Type `protobuf:"bytes,5,opt,name=interface_ip_map,json=interfaceIpMap,proto3,oneof" json:"interface_ip_map,omitempty"`
}

func (*DHCPIPV6StatefulServer_AutomaticFromStart) isDHCPIPV6StatefulServer_InterfacesAddressingChoice() {
}
func (*DHCPIPV6StatefulServer_AutomaticFromEnd) isDHCPIPV6StatefulServer_InterfacesAddressingChoice() {
}
func (*DHCPIPV6StatefulServer_InterfaceIpMap) isDHCPIPV6StatefulServer_InterfacesAddressingChoice() {}

func (m *DHCPIPV6StatefulServer) GetInterfacesAddressingChoice() isDHCPIPV6StatefulServer_InterfacesAddressingChoice {
	if m != nil {
		return m.InterfacesAddressingChoice
	}
	return nil
}

func (m *DHCPIPV6StatefulServer) GetDhcpNetworks() []*DHCPIPV6NetworkType {
	if m != nil {
		return m.DhcpNetworks
	}
	return nil
}

func (m *DHCPIPV6StatefulServer) GetAutomaticFromStart() *schema.Empty {
	if x, ok := m.GetInterfacesAddressingChoice().(*DHCPIPV6StatefulServer_AutomaticFromStart); ok {
		return x.AutomaticFromStart
	}
	return nil
}

func (m *DHCPIPV6StatefulServer) GetAutomaticFromEnd() *schema.Empty {
	if x, ok := m.GetInterfacesAddressingChoice().(*DHCPIPV6StatefulServer_AutomaticFromEnd); ok {
		return x.AutomaticFromEnd
	}
	return nil
}

func (m *DHCPIPV6StatefulServer) GetInterfaceIpMap() *DHCPInterfaceIPV6Type {
	if x, ok := m.GetInterfacesAddressingChoice().(*DHCPIPV6StatefulServer_InterfaceIpMap); ok {
		return x.InterfaceIpMap
	}
	return nil
}

func (m *DHCPIPV6StatefulServer) GetFixedIpMap() map[string]string {
	if m != nil {
		return m.FixedIpMap
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DHCPIPV6StatefulServer) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DHCPIPV6StatefulServer_AutomaticFromStart)(nil),
		(*DHCPIPV6StatefulServer_AutomaticFromEnd)(nil),
		(*DHCPIPV6StatefulServer_InterfaceIpMap)(nil),
	}
}

// Static IP Parameters
//
// x-displayName: "Node: Static IP Parameters"
// Configure Static IP parameters for a node
type StaticIpParametersNodeType struct {
	// Default Gateway
	//
	// x-displayName: "IP address/Prefix Length"
	// x-example: "192.168.20.1/24"
	// x-required
	// IP address of the interface and prefix length
	IpAddress string `protobuf:"bytes,1,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	// Default Gateway
	//
	// x-displayName: "Default Gateway"
	// x-example: "192.168.20.1"
	// IP address of the default gateway.
	DefaultGw string `protobuf:"bytes,2,opt,name=default_gw,json=defaultGw,proto3" json:"default_gw,omitempty"`
	// DNS Server
	//
	// x-displayName: "DNS Server"
	// x-example: "192.168.20.1"
	// IP address of the DNS server
	DnsServer string `protobuf:"bytes,3,opt,name=dns_server,json=dnsServer,proto3" json:"dns_server,omitempty"`
}

func (m *StaticIpParametersNodeType) Reset()      { *m = StaticIpParametersNodeType{} }
func (*StaticIpParametersNodeType) ProtoMessage() {}
func (*StaticIpParametersNodeType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{16}
}
func (m *StaticIpParametersNodeType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StaticIpParametersNodeType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StaticIpParametersNodeType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StaticIpParametersNodeType.Merge(m, src)
}
func (m *StaticIpParametersNodeType) XXX_Size() int {
	return m.Size()
}
func (m *StaticIpParametersNodeType) XXX_DiscardUnknown() {
	xxx_messageInfo_StaticIpParametersNodeType.DiscardUnknown(m)
}

var xxx_messageInfo_StaticIpParametersNodeType proto.InternalMessageInfo

func (m *StaticIpParametersNodeType) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *StaticIpParametersNodeType) GetDefaultGw() string {
	if m != nil {
		return m.DefaultGw
	}
	return ""
}

func (m *StaticIpParametersNodeType) GetDnsServer() string {
	if m != nil {
		return m.DnsServer
	}
	return ""
}

// Static IP Parameters
//
// x-displayName: "Cluster: Static IP Parameters"
// Configure Static IP parameters  for cluster
type StaticIpParametersClusterType struct {
	// Site:Node to IP mapping
	//
	// x-displayName: "Node to IP Mapping"
	// Map of Node to Static ip configuration value, Key:Node, Value:IP Address
	InterfaceIpMap map[string]*StaticIpParametersNodeType `protobuf:"bytes,1,rep,name=interface_ip_map,json=interfaceIpMap,proto3" json:"interface_ip_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *StaticIpParametersClusterType) Reset()      { *m = StaticIpParametersClusterType{} }
func (*StaticIpParametersClusterType) ProtoMessage() {}
func (*StaticIpParametersClusterType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{17}
}
func (m *StaticIpParametersClusterType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StaticIpParametersClusterType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StaticIpParametersClusterType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StaticIpParametersClusterType.Merge(m, src)
}
func (m *StaticIpParametersClusterType) XXX_Size() int {
	return m.Size()
}
func (m *StaticIpParametersClusterType) XXX_DiscardUnknown() {
	xxx_messageInfo_StaticIpParametersClusterType.DiscardUnknown(m)
}

var xxx_messageInfo_StaticIpParametersClusterType proto.InternalMessageInfo

func (m *StaticIpParametersClusterType) GetInterfaceIpMap() map[string]*StaticIpParametersNodeType {
	if m != nil {
		return m.InterfaceIpMap
	}
	return nil
}

// Static IP Parameters
//
// x-displayName: "Fleet: Static IP Parameters"
// Configure Static IP parameters
type StaticIpParametersFleetType struct {
	// Fleet
	//
	// x-displayName: "Fleet address allocator"
	// Static IP configuration for the fleet
	NetworkPrefixAllocator *views.ObjectRefType `protobuf:"bytes,1,opt,name=network_prefix_allocator,json=networkPrefixAllocator,proto3" json:"network_prefix_allocator,omitempty"`
	// Default Gateway
	//
	// x-displayName: "Default Gateway"
	// x-example: "192.168.20.1"
	// IP address offset of the default gateway, prefix len is used to calculate offset
	DefaultGw string `protobuf:"bytes,2,opt,name=default_gw,json=defaultGw,proto3" json:"default_gw,omitempty"`
	// DNS Server
	//
	// x-displayName: "DNS Server"
	// x-example: "192.168.20.1"
	// IP address offset of the DNS server, prefix len is used to calculate offset
	DnsServer string `protobuf:"bytes,3,opt,name=dns_server,json=dnsServer,proto3" json:"dns_server,omitempty"`
}

func (m *StaticIpParametersFleetType) Reset()      { *m = StaticIpParametersFleetType{} }
func (*StaticIpParametersFleetType) ProtoMessage() {}
func (*StaticIpParametersFleetType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{18}
}
func (m *StaticIpParametersFleetType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StaticIpParametersFleetType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StaticIpParametersFleetType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StaticIpParametersFleetType.Merge(m, src)
}
func (m *StaticIpParametersFleetType) XXX_Size() int {
	return m.Size()
}
func (m *StaticIpParametersFleetType) XXX_DiscardUnknown() {
	xxx_messageInfo_StaticIpParametersFleetType.DiscardUnknown(m)
}

var xxx_messageInfo_StaticIpParametersFleetType proto.InternalMessageInfo

func (m *StaticIpParametersFleetType) GetNetworkPrefixAllocator() *views.ObjectRefType {
	if m != nil {
		return m.NetworkPrefixAllocator
	}
	return nil
}

func (m *StaticIpParametersFleetType) GetDefaultGw() string {
	if m != nil {
		return m.DefaultGw
	}
	return ""
}

func (m *StaticIpParametersFleetType) GetDnsServer() string {
	if m != nil {
		return m.DnsServer
	}
	return ""
}

// Static IP Parameters
//
// x-displayName: "Static IP Parameters"
// Configure Static IP parameters
type StaticIPParametersType struct {
	// Network Prefix choice
	//
	// x-displayName: "Select Static IP Configuration"
	// x-required
	// Select static ip configuration for Node/Cluster/Fleet
	//
	// Types that are valid to be assigned to NetworkPrefixChoice:
	//	*StaticIPParametersType_NodeStaticIp
	//	*StaticIPParametersType_ClusterStaticIp
	//	*StaticIPParametersType_FleetStaticIp
	NetworkPrefixChoice isStaticIPParametersType_NetworkPrefixChoice `protobuf_oneof:"network_prefix_choice"`
}

func (m *StaticIPParametersType) Reset()      { *m = StaticIPParametersType{} }
func (*StaticIPParametersType) ProtoMessage() {}
func (*StaticIPParametersType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{19}
}
func (m *StaticIPParametersType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StaticIPParametersType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StaticIPParametersType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StaticIPParametersType.Merge(m, src)
}
func (m *StaticIPParametersType) XXX_Size() int {
	return m.Size()
}
func (m *StaticIPParametersType) XXX_DiscardUnknown() {
	xxx_messageInfo_StaticIPParametersType.DiscardUnknown(m)
}

var xxx_messageInfo_StaticIPParametersType proto.InternalMessageInfo

type isStaticIPParametersType_NetworkPrefixChoice interface {
	isStaticIPParametersType_NetworkPrefixChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type StaticIPParametersType_NodeStaticIp struct {
	NodeStaticIp *StaticIpParametersNodeType `protobuf:"bytes,2,opt,name=node_static_ip,json=nodeStaticIp,proto3,oneof" json:"node_static_ip,omitempty"`
}
type StaticIPParametersType_ClusterStaticIp struct {
	ClusterStaticIp *StaticIpParametersClusterType `protobuf:"bytes,3,opt,name=cluster_static_ip,json=clusterStaticIp,proto3,oneof" json:"cluster_static_ip,omitempty"`
}
type StaticIPParametersType_FleetStaticIp struct {
	FleetStaticIp *StaticIpParametersFleetType `protobuf:"bytes,4,opt,name=fleet_static_ip,json=fleetStaticIp,proto3,oneof" json:"fleet_static_ip,omitempty"`
}

func (*StaticIPParametersType_NodeStaticIp) isStaticIPParametersType_NetworkPrefixChoice()    {}
func (*StaticIPParametersType_ClusterStaticIp) isStaticIPParametersType_NetworkPrefixChoice() {}
func (*StaticIPParametersType_FleetStaticIp) isStaticIPParametersType_NetworkPrefixChoice()   {}

func (m *StaticIPParametersType) GetNetworkPrefixChoice() isStaticIPParametersType_NetworkPrefixChoice {
	if m != nil {
		return m.NetworkPrefixChoice
	}
	return nil
}

func (m *StaticIPParametersType) GetNodeStaticIp() *StaticIpParametersNodeType {
	if x, ok := m.GetNetworkPrefixChoice().(*StaticIPParametersType_NodeStaticIp); ok {
		return x.NodeStaticIp
	}
	return nil
}

func (m *StaticIPParametersType) GetClusterStaticIp() *StaticIpParametersClusterType {
	if x, ok := m.GetNetworkPrefixChoice().(*StaticIPParametersType_ClusterStaticIp); ok {
		return x.ClusterStaticIp
	}
	return nil
}

func (m *StaticIPParametersType) GetFleetStaticIp() *StaticIpParametersFleetType {
	if x, ok := m.GetNetworkPrefixChoice().(*StaticIPParametersType_FleetStaticIp); ok {
		return x.FleetStaticIp
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StaticIPParametersType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StaticIPParametersType_NodeStaticIp)(nil),
		(*StaticIPParametersType_ClusterStaticIp)(nil),
		(*StaticIPParametersType_FleetStaticIp)(nil),
	}
}

// Dedicated Interface
//
// x-displayName: "Dedicated Interface"
// Dedicated Interface Configuration
type DedicatedInterfaceType struct {
	// Device
	//
	// x-displayName: "Interface Device"
	// x-example: "eth0"
	// x-required
	// Name of the device for which interface is configured. Use wwan0 for 4G/LTE.
	Device string `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
	// Select Node Independent or Node Specific Interface
	//
	// x-displayName: "Select Configuration for Cluster or Specific Node"
	// x-required
	// Cluster configuration will apply to a given device on all nodes of the site.
	// Node configuration will apply to a given device on a specific node.
	//
	// Types that are valid to be assigned to NodeChoice:
	//	*DedicatedInterfaceType_Cluster
	//	*DedicatedInterfaceType_Node
	NodeChoice isDedicatedInterfaceType_NodeChoice `protobuf_oneof:"node_choice"`
	// Maximum Packet Size (MTU)
	//
	// x-displayName: "Maximum Packet Size (MTU)"
	// x-example: "1450"
	// Maximum packet size (Maximum Transfer Unit) of the interface
	// When configured, mtu must be between 512 and 16384
	Mtu uint32 `protobuf:"varint,8,opt,name=mtu,proto3" json:"mtu,omitempty"`
	// Priority
	//
	// x-displayName: "Priority"
	// x-example: "42"
	// Priority of the network interface when multiple network interfaces are present in outside network
	// Greater the value, higher the priority
	Priority uint32 `protobuf:"varint,9,opt,name=priority,proto3" json:"priority,omitempty"`
	// Primary Interface
	//
	// x-displayName: "Select Primary Interface"
	// x-required
	// Select if this interface is primary interface, only one interface can be primary in a given fleet
	//
	// Types that are valid to be assigned to PrimaryChoice:
	//	*DedicatedInterfaceType_NotPrimary
	//	*DedicatedInterfaceType_IsPrimary
	PrimaryChoice isDedicatedInterfaceType_PrimaryChoice `protobuf_oneof:"primary_choice"`
	// Select Link Quality Monitoring configuration
	//
	// x-displayName: "Select Link Quality Monitoring configuration"
	// Link Quality Monitoring configuration for a network interface. When enabled, VER will send probes
	// on the network interface to monitor quality of the link. Links are assigned a score based on the result of probes.
	//
	// Types that are valid to be assigned to MonitoringChoice:
	//	*DedicatedInterfaceType_MonitorDisabled
	//	*DedicatedInterfaceType_Monitor
	MonitoringChoice isDedicatedInterfaceType_MonitoringChoice `protobuf_oneof:"monitoring_choice"`
}

func (m *DedicatedInterfaceType) Reset()      { *m = DedicatedInterfaceType{} }
func (*DedicatedInterfaceType) ProtoMessage() {}
func (*DedicatedInterfaceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{20}
}
func (m *DedicatedInterfaceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DedicatedInterfaceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DedicatedInterfaceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DedicatedInterfaceType.Merge(m, src)
}
func (m *DedicatedInterfaceType) XXX_Size() int {
	return m.Size()
}
func (m *DedicatedInterfaceType) XXX_DiscardUnknown() {
	xxx_messageInfo_DedicatedInterfaceType.DiscardUnknown(m)
}

var xxx_messageInfo_DedicatedInterfaceType proto.InternalMessageInfo

type isDedicatedInterfaceType_NodeChoice interface {
	isDedicatedInterfaceType_NodeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isDedicatedInterfaceType_PrimaryChoice interface {
	isDedicatedInterfaceType_PrimaryChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isDedicatedInterfaceType_MonitoringChoice interface {
	isDedicatedInterfaceType_MonitoringChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DedicatedInterfaceType_Cluster struct {
	Cluster *schema.Empty `protobuf:"bytes,3,opt,name=cluster,proto3,oneof" json:"cluster,omitempty"`
}
type DedicatedInterfaceType_Node struct {
	Node string `protobuf:"bytes,4,opt,name=node,proto3,oneof" json:"node,omitempty"`
}
type DedicatedInterfaceType_NotPrimary struct {
	NotPrimary *schema.Empty `protobuf:"bytes,11,opt,name=not_primary,json=notPrimary,proto3,oneof" json:"not_primary,omitempty"`
}
type DedicatedInterfaceType_IsPrimary struct {
	IsPrimary *schema.Empty `protobuf:"bytes,12,opt,name=is_primary,json=isPrimary,proto3,oneof" json:"is_primary,omitempty"`
}
type DedicatedInterfaceType_MonitorDisabled struct {
	MonitorDisabled *schema.Empty `protobuf:"bytes,14,opt,name=monitor_disabled,json=monitorDisabled,proto3,oneof" json:"monitor_disabled,omitempty"`
}
type DedicatedInterfaceType_Monitor struct {
	Monitor *LinkQualityMonitorConfig `protobuf:"bytes,15,opt,name=monitor,proto3,oneof" json:"monitor,omitempty"`
}

func (*DedicatedInterfaceType_Cluster) isDedicatedInterfaceType_NodeChoice()               {}
func (*DedicatedInterfaceType_Node) isDedicatedInterfaceType_NodeChoice()                  {}
func (*DedicatedInterfaceType_NotPrimary) isDedicatedInterfaceType_PrimaryChoice()         {}
func (*DedicatedInterfaceType_IsPrimary) isDedicatedInterfaceType_PrimaryChoice()          {}
func (*DedicatedInterfaceType_MonitorDisabled) isDedicatedInterfaceType_MonitoringChoice() {}
func (*DedicatedInterfaceType_Monitor) isDedicatedInterfaceType_MonitoringChoice()         {}

func (m *DedicatedInterfaceType) GetNodeChoice() isDedicatedInterfaceType_NodeChoice {
	if m != nil {
		return m.NodeChoice
	}
	return nil
}
func (m *DedicatedInterfaceType) GetPrimaryChoice() isDedicatedInterfaceType_PrimaryChoice {
	if m != nil {
		return m.PrimaryChoice
	}
	return nil
}
func (m *DedicatedInterfaceType) GetMonitoringChoice() isDedicatedInterfaceType_MonitoringChoice {
	if m != nil {
		return m.MonitoringChoice
	}
	return nil
}

func (m *DedicatedInterfaceType) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *DedicatedInterfaceType) GetCluster() *schema.Empty {
	if x, ok := m.GetNodeChoice().(*DedicatedInterfaceType_Cluster); ok {
		return x.Cluster
	}
	return nil
}

func (m *DedicatedInterfaceType) GetNode() string {
	if x, ok := m.GetNodeChoice().(*DedicatedInterfaceType_Node); ok {
		return x.Node
	}
	return ""
}

func (m *DedicatedInterfaceType) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *DedicatedInterfaceType) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *DedicatedInterfaceType) GetNotPrimary() *schema.Empty {
	if x, ok := m.GetPrimaryChoice().(*DedicatedInterfaceType_NotPrimary); ok {
		return x.NotPrimary
	}
	return nil
}

func (m *DedicatedInterfaceType) GetIsPrimary() *schema.Empty {
	if x, ok := m.GetPrimaryChoice().(*DedicatedInterfaceType_IsPrimary); ok {
		return x.IsPrimary
	}
	return nil
}

func (m *DedicatedInterfaceType) GetMonitorDisabled() *schema.Empty {
	if x, ok := m.GetMonitoringChoice().(*DedicatedInterfaceType_MonitorDisabled); ok {
		return x.MonitorDisabled
	}
	return nil
}

func (m *DedicatedInterfaceType) GetMonitor() *LinkQualityMonitorConfig {
	if x, ok := m.GetMonitoringChoice().(*DedicatedInterfaceType_Monitor); ok {
		return x.Monitor
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DedicatedInterfaceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DedicatedInterfaceType_Cluster)(nil),
		(*DedicatedInterfaceType_Node)(nil),
		(*DedicatedInterfaceType_NotPrimary)(nil),
		(*DedicatedInterfaceType_IsPrimary)(nil),
		(*DedicatedInterfaceType_MonitorDisabled)(nil),
		(*DedicatedInterfaceType_Monitor)(nil),
	}
}

// Dedicated Management Interface
//
// x-displayName: "Dedicated Management Interface"
// Dedicated Interface Configuration
type DedicatedManagementInterfaceType struct {
	// Device
	//
	// x-displayName: "Interface Device"
	// x-example: "eth0"
	// x-required
	// Name of the device for which interface is configured
	Device string `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
	// Select Node Independent or Node Specific Interface
	//
	// x-displayName: "Select Configuration for Cluster or Specific Node"
	// x-required
	// Cluster configuration will apply to a given device on all nodes of the site.
	// Node configuration will apply to a given device on a specific node.
	//
	// Types that are valid to be assigned to NodeChoice:
	//	*DedicatedManagementInterfaceType_Cluster
	//	*DedicatedManagementInterfaceType_Node
	NodeChoice isDedicatedManagementInterfaceType_NodeChoice `protobuf_oneof:"node_choice"`
	// Maximum Packet Size (MTU)
	//
	// x-displayName: "Maximum Packet Size (MTU)"
	// x-example: "1450"
	// Maximum packet size (Maximum Transfer Unit) of the interface
	// When configured, mtu must be between 512 and 16384
	Mtu uint32 `protobuf:"varint,5,opt,name=mtu,proto3" json:"mtu,omitempty"`
}

func (m *DedicatedManagementInterfaceType) Reset()      { *m = DedicatedManagementInterfaceType{} }
func (*DedicatedManagementInterfaceType) ProtoMessage() {}
func (*DedicatedManagementInterfaceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{21}
}
func (m *DedicatedManagementInterfaceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DedicatedManagementInterfaceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DedicatedManagementInterfaceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DedicatedManagementInterfaceType.Merge(m, src)
}
func (m *DedicatedManagementInterfaceType) XXX_Size() int {
	return m.Size()
}
func (m *DedicatedManagementInterfaceType) XXX_DiscardUnknown() {
	xxx_messageInfo_DedicatedManagementInterfaceType.DiscardUnknown(m)
}

var xxx_messageInfo_DedicatedManagementInterfaceType proto.InternalMessageInfo

type isDedicatedManagementInterfaceType_NodeChoice interface {
	isDedicatedManagementInterfaceType_NodeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DedicatedManagementInterfaceType_Cluster struct {
	Cluster *schema.Empty `protobuf:"bytes,3,opt,name=cluster,proto3,oneof" json:"cluster,omitempty"`
}
type DedicatedManagementInterfaceType_Node struct {
	Node string `protobuf:"bytes,4,opt,name=node,proto3,oneof" json:"node,omitempty"`
}

func (*DedicatedManagementInterfaceType_Cluster) isDedicatedManagementInterfaceType_NodeChoice() {}
func (*DedicatedManagementInterfaceType_Node) isDedicatedManagementInterfaceType_NodeChoice()    {}

func (m *DedicatedManagementInterfaceType) GetNodeChoice() isDedicatedManagementInterfaceType_NodeChoice {
	if m != nil {
		return m.NodeChoice
	}
	return nil
}

func (m *DedicatedManagementInterfaceType) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *DedicatedManagementInterfaceType) GetCluster() *schema.Empty {
	if x, ok := m.GetNodeChoice().(*DedicatedManagementInterfaceType_Cluster); ok {
		return x.Cluster
	}
	return nil
}

func (m *DedicatedManagementInterfaceType) GetNode() string {
	if x, ok := m.GetNodeChoice().(*DedicatedManagementInterfaceType_Node); ok {
		return x.Node
	}
	return ""
}

func (m *DedicatedManagementInterfaceType) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DedicatedManagementInterfaceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DedicatedManagementInterfaceType_Cluster)(nil),
		(*DedicatedManagementInterfaceType_Node)(nil),
	}
}

// Ethernet Interface
//
// x-displayName: "Ethernet Interface"
// Ethernet Interface Configuration
type EthernetInterfaceType struct {
	// Device
	//
	// x-displayName: "Ethernet Device"
	// x-example: "eth0"
	// x-required
	// Interface configuration for the ethernet device
	Device string `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
	// Select Node Independent or Node Specific Interface
	//
	// x-displayName: "Select Configuration for Cluster or Specific Node"
	// x-required
	// Cluster configuration will apply to a given device on all nodes of the site.
	// Node configuration will apply to a given device on a given node.
	//
	// Types that are valid to be assigned to NodeChoice:
	//	*EthernetInterfaceType_Cluster
	//	*EthernetInterfaceType_Node
	NodeChoice isEthernetInterfaceType_NodeChoice `protobuf_oneof:"node_choice"`
	// Select Untagged or VLAN tagged
	//
	// x-displayName: "Select Untagged or VLAN tagged"
	// x-required
	// Select if this interface is VLAN tagged or untagged
	//
	// Types that are valid to be assigned to VlanChoice:
	//	*EthernetInterfaceType_Untagged
	//	*EthernetInterfaceType_VlanId
	VlanChoice isEthernetInterfaceType_VlanChoice `protobuf_oneof:"vlan_choice"`
	// Interface Addressing
	//
	// x-displayName: "Select Interface Address Method"
	// x-required
	// Select how ip address will be assigned to Interface
	//
	// Types that are valid to be assigned to AddressChoice:
	//	*EthernetInterfaceType_DhcpClient
	//	*EthernetInterfaceType_DhcpServer
	//	*EthernetInterfaceType_StaticIp
	AddressChoice isEthernetInterfaceType_AddressChoice `protobuf_oneof:"address_choice"`
	// IPv6 Interface Addressing
	//
	// x-displayName: "Select Interface IPv6 Address Method"
	// Select how IPv6 address will be assigned to Interface
	//
	// Types that are valid to be assigned to Ipv6AddressChoice:
	//	*EthernetInterfaceType_NoIpv6Address
	//	*EthernetInterfaceType_StaticIpv6Address
	//	*EthernetInterfaceType_Ipv6AutoConfig
	Ipv6AddressChoice isEthernetInterfaceType_Ipv6AddressChoice `protobuf_oneof:"ipv6_address_choice"`
	// Network for this Interface
	//
	// x-displayName: "Select Virtual Network"
	// x-required
	// Select virtual network of this interface
	//
	// Types that are valid to be assigned to NetworkChoice:
	//	*EthernetInterfaceType_SiteLocalNetwork
	//	*EthernetInterfaceType_SiteLocalInsideNetwork
	//	*EthernetInterfaceType_InsideNetwork
	//	*EthernetInterfaceType_StorageNetwork
	//	*EthernetInterfaceType_Srv6Network
	//	*EthernetInterfaceType_IpFabricNetwork
	//	*EthernetInterfaceType_SegmentNetwork
	NetworkChoice isEthernetInterfaceType_NetworkChoice `protobuf_oneof:"network_choice"`
	// Maximum Packet Size (MTU)
	//
	// x-displayName: "Maximum Packet Size (MTU)"
	// x-example: "1450"
	// Maximum packet size (Maximum Transfer Unit) of the interface
	// When configured, mtu must be between 512 and 16384
	Mtu uint32 `protobuf:"varint,16,opt,name=mtu,proto3" json:"mtu,omitempty"`
	// Priority
	//
	// x-displayName: "Priority"
	// x-example: "42"
	// Priority of the network interface when multiple network interfaces are present in outside network
	// Greater the value, higher the priority
	Priority uint32 `protobuf:"varint,17,opt,name=priority,proto3" json:"priority,omitempty"`
	// Primary Interface
	//
	// x-displayName: "Select Primary Interface"
	// x-required
	// Select if this interface is primary interface, only one interface can be primary in a given fleet
	//
	// Types that are valid to be assigned to PrimaryChoice:
	//	*EthernetInterfaceType_NotPrimary
	//	*EthernetInterfaceType_IsPrimary
	PrimaryChoice isEthernetInterfaceType_PrimaryChoice `protobuf_oneof:"primary_choice"`
	// Select Link Quality Monitoring configuration
	//
	// x-displayName: "Select Link Quality Monitoring configuration"
	// Link Quality Monitoring configuration for a network interface. When enabled, VER will send probes
	// on the network interface to monitor quality of the link. Links are assigned a score based on the result of probes.
	//
	// Types that are valid to be assigned to MonitoringChoice:
	//	*EthernetInterfaceType_MonitorDisabled
	//	*EthernetInterfaceType_Monitor
	MonitoringChoice isEthernetInterfaceType_MonitoringChoice `protobuf_oneof:"monitoring_choice"`
}

func (m *EthernetInterfaceType) Reset()      { *m = EthernetInterfaceType{} }
func (*EthernetInterfaceType) ProtoMessage() {}
func (*EthernetInterfaceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{22}
}
func (m *EthernetInterfaceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EthernetInterfaceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *EthernetInterfaceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EthernetInterfaceType.Merge(m, src)
}
func (m *EthernetInterfaceType) XXX_Size() int {
	return m.Size()
}
func (m *EthernetInterfaceType) XXX_DiscardUnknown() {
	xxx_messageInfo_EthernetInterfaceType.DiscardUnknown(m)
}

var xxx_messageInfo_EthernetInterfaceType proto.InternalMessageInfo

type isEthernetInterfaceType_NodeChoice interface {
	isEthernetInterfaceType_NodeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isEthernetInterfaceType_VlanChoice interface {
	isEthernetInterfaceType_VlanChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isEthernetInterfaceType_AddressChoice interface {
	isEthernetInterfaceType_AddressChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isEthernetInterfaceType_Ipv6AddressChoice interface {
	isEthernetInterfaceType_Ipv6AddressChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isEthernetInterfaceType_NetworkChoice interface {
	isEthernetInterfaceType_NetworkChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isEthernetInterfaceType_PrimaryChoice interface {
	isEthernetInterfaceType_PrimaryChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isEthernetInterfaceType_MonitoringChoice interface {
	isEthernetInterfaceType_MonitoringChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type EthernetInterfaceType_Cluster struct {
	Cluster *schema.Empty `protobuf:"bytes,3,opt,name=cluster,proto3,oneof" json:"cluster,omitempty"`
}
type EthernetInterfaceType_Node struct {
	Node string `protobuf:"bytes,4,opt,name=node,proto3,oneof" json:"node,omitempty"`
}
type EthernetInterfaceType_Untagged struct {
	Untagged *schema.Empty `protobuf:"bytes,6,opt,name=untagged,proto3,oneof" json:"untagged,omitempty"`
}
type EthernetInterfaceType_VlanId struct {
	VlanId uint32 `protobuf:"varint,7,opt,name=vlan_id,json=vlanId,proto3,oneof" json:"vlan_id,omitempty"`
}
type EthernetInterfaceType_DhcpClient struct {
	DhcpClient *schema.Empty `protobuf:"bytes,9,opt,name=dhcp_client,json=dhcpClient,proto3,oneof" json:"dhcp_client,omitempty"`
}
type EthernetInterfaceType_DhcpServer struct {
	DhcpServer *DHCPServerParametersType `protobuf:"bytes,10,opt,name=dhcp_server,json=dhcpServer,proto3,oneof" json:"dhcp_server,omitempty"`
}
type EthernetInterfaceType_StaticIp struct {
	StaticIp *StaticIPParametersType `protobuf:"bytes,11,opt,name=static_ip,json=staticIp,proto3,oneof" json:"static_ip,omitempty"`
}
type EthernetInterfaceType_NoIpv6Address struct {
	NoIpv6Address *schema.Empty `protobuf:"bytes,31,opt,name=no_ipv6_address,json=noIpv6Address,proto3,oneof" json:"no_ipv6_address,omitempty"`
}
type EthernetInterfaceType_StaticIpv6Address struct {
	StaticIpv6Address *StaticIPParametersType `protobuf:"bytes,32,opt,name=static_ipv6_address,json=staticIpv6Address,proto3,oneof" json:"static_ipv6_address,omitempty"`
}
type EthernetInterfaceType_Ipv6AutoConfig struct {
	Ipv6AutoConfig *IPV6AutoConfigType `protobuf:"bytes,33,opt,name=ipv6_auto_config,json=ipv6AutoConfig,proto3,oneof" json:"ipv6_auto_config,omitempty"`
}
type EthernetInterfaceType_SiteLocalNetwork struct {
	SiteLocalNetwork *schema.Empty `protobuf:"bytes,13,opt,name=site_local_network,json=siteLocalNetwork,proto3,oneof" json:"site_local_network,omitempty"`
}
type EthernetInterfaceType_SiteLocalInsideNetwork struct {
	SiteLocalInsideNetwork *schema.Empty `protobuf:"bytes,14,opt,name=site_local_inside_network,json=siteLocalInsideNetwork,proto3,oneof" json:"site_local_inside_network,omitempty"`
}
type EthernetInterfaceType_InsideNetwork struct {
	InsideNetwork *views.ObjectRefType `protobuf:"bytes,15,opt,name=inside_network,json=insideNetwork,proto3,oneof" json:"inside_network,omitempty"`
}
type EthernetInterfaceType_StorageNetwork struct {
	StorageNetwork *schema.Empty `protobuf:"bytes,21,opt,name=storage_network,json=storageNetwork,proto3,oneof" json:"storage_network,omitempty"`
}
type EthernetInterfaceType_Srv6Network struct {
	Srv6Network *views.ObjectRefType `protobuf:"bytes,25,opt,name=srv6_network,json=srv6Network,proto3,oneof" json:"srv6_network,omitempty"`
}
type EthernetInterfaceType_IpFabricNetwork struct {
	IpFabricNetwork *schema.Empty `protobuf:"bytes,26,opt,name=ip_fabric_network,json=ipFabricNetwork,proto3,oneof" json:"ip_fabric_network,omitempty"`
}
type EthernetInterfaceType_SegmentNetwork struct {
	SegmentNetwork *views.ObjectRefType `protobuf:"bytes,27,opt,name=segment_network,json=segmentNetwork,proto3,oneof" json:"segment_network,omitempty"`
}
type EthernetInterfaceType_NotPrimary struct {
	NotPrimary *schema.Empty `protobuf:"bytes,19,opt,name=not_primary,json=notPrimary,proto3,oneof" json:"not_primary,omitempty"`
}
type EthernetInterfaceType_IsPrimary struct {
	IsPrimary *schema.Empty `protobuf:"bytes,20,opt,name=is_primary,json=isPrimary,proto3,oneof" json:"is_primary,omitempty"`
}
type EthernetInterfaceType_MonitorDisabled struct {
	MonitorDisabled *schema.Empty `protobuf:"bytes,23,opt,name=monitor_disabled,json=monitorDisabled,proto3,oneof" json:"monitor_disabled,omitempty"`
}
type EthernetInterfaceType_Monitor struct {
	Monitor *LinkQualityMonitorConfig `protobuf:"bytes,24,opt,name=monitor,proto3,oneof" json:"monitor,omitempty"`
}

func (*EthernetInterfaceType_Cluster) isEthernetInterfaceType_NodeChoice()                   {}
func (*EthernetInterfaceType_Node) isEthernetInterfaceType_NodeChoice()                      {}
func (*EthernetInterfaceType_Untagged) isEthernetInterfaceType_VlanChoice()                  {}
func (*EthernetInterfaceType_VlanId) isEthernetInterfaceType_VlanChoice()                    {}
func (*EthernetInterfaceType_DhcpClient) isEthernetInterfaceType_AddressChoice()             {}
func (*EthernetInterfaceType_DhcpServer) isEthernetInterfaceType_AddressChoice()             {}
func (*EthernetInterfaceType_StaticIp) isEthernetInterfaceType_AddressChoice()               {}
func (*EthernetInterfaceType_NoIpv6Address) isEthernetInterfaceType_Ipv6AddressChoice()      {}
func (*EthernetInterfaceType_StaticIpv6Address) isEthernetInterfaceType_Ipv6AddressChoice()  {}
func (*EthernetInterfaceType_Ipv6AutoConfig) isEthernetInterfaceType_Ipv6AddressChoice()     {}
func (*EthernetInterfaceType_SiteLocalNetwork) isEthernetInterfaceType_NetworkChoice()       {}
func (*EthernetInterfaceType_SiteLocalInsideNetwork) isEthernetInterfaceType_NetworkChoice() {}
func (*EthernetInterfaceType_InsideNetwork) isEthernetInterfaceType_NetworkChoice()          {}
func (*EthernetInterfaceType_StorageNetwork) isEthernetInterfaceType_NetworkChoice()         {}
func (*EthernetInterfaceType_Srv6Network) isEthernetInterfaceType_NetworkChoice()            {}
func (*EthernetInterfaceType_IpFabricNetwork) isEthernetInterfaceType_NetworkChoice()        {}
func (*EthernetInterfaceType_SegmentNetwork) isEthernetInterfaceType_NetworkChoice()         {}
func (*EthernetInterfaceType_NotPrimary) isEthernetInterfaceType_PrimaryChoice()             {}
func (*EthernetInterfaceType_IsPrimary) isEthernetInterfaceType_PrimaryChoice()              {}
func (*EthernetInterfaceType_MonitorDisabled) isEthernetInterfaceType_MonitoringChoice()     {}
func (*EthernetInterfaceType_Monitor) isEthernetInterfaceType_MonitoringChoice()             {}

func (m *EthernetInterfaceType) GetNodeChoice() isEthernetInterfaceType_NodeChoice {
	if m != nil {
		return m.NodeChoice
	}
	return nil
}
func (m *EthernetInterfaceType) GetVlanChoice() isEthernetInterfaceType_VlanChoice {
	if m != nil {
		return m.VlanChoice
	}
	return nil
}
func (m *EthernetInterfaceType) GetAddressChoice() isEthernetInterfaceType_AddressChoice {
	if m != nil {
		return m.AddressChoice
	}
	return nil
}
func (m *EthernetInterfaceType) GetIpv6AddressChoice() isEthernetInterfaceType_Ipv6AddressChoice {
	if m != nil {
		return m.Ipv6AddressChoice
	}
	return nil
}
func (m *EthernetInterfaceType) GetNetworkChoice() isEthernetInterfaceType_NetworkChoice {
	if m != nil {
		return m.NetworkChoice
	}
	return nil
}
func (m *EthernetInterfaceType) GetPrimaryChoice() isEthernetInterfaceType_PrimaryChoice {
	if m != nil {
		return m.PrimaryChoice
	}
	return nil
}
func (m *EthernetInterfaceType) GetMonitoringChoice() isEthernetInterfaceType_MonitoringChoice {
	if m != nil {
		return m.MonitoringChoice
	}
	return nil
}

func (m *EthernetInterfaceType) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *EthernetInterfaceType) GetCluster() *schema.Empty {
	if x, ok := m.GetNodeChoice().(*EthernetInterfaceType_Cluster); ok {
		return x.Cluster
	}
	return nil
}

func (m *EthernetInterfaceType) GetNode() string {
	if x, ok := m.GetNodeChoice().(*EthernetInterfaceType_Node); ok {
		return x.Node
	}
	return ""
}

func (m *EthernetInterfaceType) GetUntagged() *schema.Empty {
	if x, ok := m.GetVlanChoice().(*EthernetInterfaceType_Untagged); ok {
		return x.Untagged
	}
	return nil
}

func (m *EthernetInterfaceType) GetVlanId() uint32 {
	if x, ok := m.GetVlanChoice().(*EthernetInterfaceType_VlanId); ok {
		return x.VlanId
	}
	return 0
}

func (m *EthernetInterfaceType) GetDhcpClient() *schema.Empty {
	if x, ok := m.GetAddressChoice().(*EthernetInterfaceType_DhcpClient); ok {
		return x.DhcpClient
	}
	return nil
}

func (m *EthernetInterfaceType) GetDhcpServer() *DHCPServerParametersType {
	if x, ok := m.GetAddressChoice().(*EthernetInterfaceType_DhcpServer); ok {
		return x.DhcpServer
	}
	return nil
}

func (m *EthernetInterfaceType) GetStaticIp() *StaticIPParametersType {
	if x, ok := m.GetAddressChoice().(*EthernetInterfaceType_StaticIp); ok {
		return x.StaticIp
	}
	return nil
}

func (m *EthernetInterfaceType) GetNoIpv6Address() *schema.Empty {
	if x, ok := m.GetIpv6AddressChoice().(*EthernetInterfaceType_NoIpv6Address); ok {
		return x.NoIpv6Address
	}
	return nil
}

func (m *EthernetInterfaceType) GetStaticIpv6Address() *StaticIPParametersType {
	if x, ok := m.GetIpv6AddressChoice().(*EthernetInterfaceType_StaticIpv6Address); ok {
		return x.StaticIpv6Address
	}
	return nil
}

func (m *EthernetInterfaceType) GetIpv6AutoConfig() *IPV6AutoConfigType {
	if x, ok := m.GetIpv6AddressChoice().(*EthernetInterfaceType_Ipv6AutoConfig); ok {
		return x.Ipv6AutoConfig
	}
	return nil
}

func (m *EthernetInterfaceType) GetSiteLocalNetwork() *schema.Empty {
	if x, ok := m.GetNetworkChoice().(*EthernetInterfaceType_SiteLocalNetwork); ok {
		return x.SiteLocalNetwork
	}
	return nil
}

func (m *EthernetInterfaceType) GetSiteLocalInsideNetwork() *schema.Empty {
	if x, ok := m.GetNetworkChoice().(*EthernetInterfaceType_SiteLocalInsideNetwork); ok {
		return x.SiteLocalInsideNetwork
	}
	return nil
}

func (m *EthernetInterfaceType) GetInsideNetwork() *views.ObjectRefType {
	if x, ok := m.GetNetworkChoice().(*EthernetInterfaceType_InsideNetwork); ok {
		return x.InsideNetwork
	}
	return nil
}

func (m *EthernetInterfaceType) GetStorageNetwork() *schema.Empty {
	if x, ok := m.GetNetworkChoice().(*EthernetInterfaceType_StorageNetwork); ok {
		return x.StorageNetwork
	}
	return nil
}

func (m *EthernetInterfaceType) GetSrv6Network() *views.ObjectRefType {
	if x, ok := m.GetNetworkChoice().(*EthernetInterfaceType_Srv6Network); ok {
		return x.Srv6Network
	}
	return nil
}

func (m *EthernetInterfaceType) GetIpFabricNetwork() *schema.Empty {
	if x, ok := m.GetNetworkChoice().(*EthernetInterfaceType_IpFabricNetwork); ok {
		return x.IpFabricNetwork
	}
	return nil
}

func (m *EthernetInterfaceType) GetSegmentNetwork() *views.ObjectRefType {
	if x, ok := m.GetNetworkChoice().(*EthernetInterfaceType_SegmentNetwork); ok {
		return x.SegmentNetwork
	}
	return nil
}

func (m *EthernetInterfaceType) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *EthernetInterfaceType) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *EthernetInterfaceType) GetNotPrimary() *schema.Empty {
	if x, ok := m.GetPrimaryChoice().(*EthernetInterfaceType_NotPrimary); ok {
		return x.NotPrimary
	}
	return nil
}

func (m *EthernetInterfaceType) GetIsPrimary() *schema.Empty {
	if x, ok := m.GetPrimaryChoice().(*EthernetInterfaceType_IsPrimary); ok {
		return x.IsPrimary
	}
	return nil
}

func (m *EthernetInterfaceType) GetMonitorDisabled() *schema.Empty {
	if x, ok := m.GetMonitoringChoice().(*EthernetInterfaceType_MonitorDisabled); ok {
		return x.MonitorDisabled
	}
	return nil
}

func (m *EthernetInterfaceType) GetMonitor() *LinkQualityMonitorConfig {
	if x, ok := m.GetMonitoringChoice().(*EthernetInterfaceType_Monitor); ok {
		return x.Monitor
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*EthernetInterfaceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*EthernetInterfaceType_Cluster)(nil),
		(*EthernetInterfaceType_Node)(nil),
		(*EthernetInterfaceType_Untagged)(nil),
		(*EthernetInterfaceType_VlanId)(nil),
		(*EthernetInterfaceType_DhcpClient)(nil),
		(*EthernetInterfaceType_DhcpServer)(nil),
		(*EthernetInterfaceType_StaticIp)(nil),
		(*EthernetInterfaceType_NoIpv6Address)(nil),
		(*EthernetInterfaceType_StaticIpv6Address)(nil),
		(*EthernetInterfaceType_Ipv6AutoConfig)(nil),
		(*EthernetInterfaceType_SiteLocalNetwork)(nil),
		(*EthernetInterfaceType_SiteLocalInsideNetwork)(nil),
		(*EthernetInterfaceType_InsideNetwork)(nil),
		(*EthernetInterfaceType_StorageNetwork)(nil),
		(*EthernetInterfaceType_Srv6Network)(nil),
		(*EthernetInterfaceType_IpFabricNetwork)(nil),
		(*EthernetInterfaceType_SegmentNetwork)(nil),
		(*EthernetInterfaceType_NotPrimary)(nil),
		(*EthernetInterfaceType_IsPrimary)(nil),
		(*EthernetInterfaceType_MonitorDisabled)(nil),
		(*EthernetInterfaceType_Monitor)(nil),
	}
}

// Tunnel Interface
//
// x-displayName: "Tunnel Interface"
// Tunnel Interface Configuration
type TunnelInterfaceType struct {
	// Select Node Independent or Node Specific Interface
	//
	// x-displayName: "Select Configuration for Cluster or Specific Node"
	// x-required
	// Cluster configuration will apply to a given device on all nodes of the Site.
	// Node configuration will apply to a device on a specific node.
	//
	// Types that are valid to be assigned to NodeChoice:
	//	*TunnelInterfaceType_Cluster
	//	*TunnelInterfaceType_Node
	NodeChoice isTunnelInterfaceType_NodeChoice `protobuf_oneof:"node_choice"`
	// Tunnel
	//
	// x-displayName: "Tunnel"
	// x-required
	// Tunnel Configuration for this Interface
	Tunnel *views.ObjectRefType `protobuf:"bytes,4,opt,name=tunnel,proto3" json:"tunnel,omitempty"`
	// Static IP
	//
	// x-displayName: "Static IP"
	// x-required
	// Interface IP is configured statically
	StaticIp *StaticIPParametersType `protobuf:"bytes,5,opt,name=static_ip,json=staticIp,proto3" json:"static_ip,omitempty"`
	// Network for this Interface
	//
	// x-displayName: "Select Virtual Network"
	// x-required
	// Select virtual network of this interface
	//
	// Types that are valid to be assigned to NetworkChoice:
	//	*TunnelInterfaceType_SiteLocalNetwork
	//	*TunnelInterfaceType_SiteLocalInsideNetwork
	//	*TunnelInterfaceType_InsideNetwork
	NetworkChoice isTunnelInterfaceType_NetworkChoice `protobuf_oneof:"network_choice"`
	// Maximum Packet Size (MTU)
	//
	// x-displayName: "Maximum Packet Size (MTU)"
	// x-example: "1450"
	// Maximum packet size (Maximum Transfer Unit) of the interface
	// When configured, mtu must be between 512 and 16384
	Mtu uint32 `protobuf:"varint,10,opt,name=mtu,proto3" json:"mtu,omitempty"`
	// Priority
	//
	// x-displayName: "Priority"
	// x-example: "42"
	// Priority of the network interface when multiple network interfaces are present in outside network
	// Greater the value, higher the priority
	Priority uint32 `protobuf:"varint,11,opt,name=priority,proto3" json:"priority,omitempty"`
}

func (m *TunnelInterfaceType) Reset()      { *m = TunnelInterfaceType{} }
func (*TunnelInterfaceType) ProtoMessage() {}
func (*TunnelInterfaceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{23}
}
func (m *TunnelInterfaceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunnelInterfaceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TunnelInterfaceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelInterfaceType.Merge(m, src)
}
func (m *TunnelInterfaceType) XXX_Size() int {
	return m.Size()
}
func (m *TunnelInterfaceType) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelInterfaceType.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelInterfaceType proto.InternalMessageInfo

type isTunnelInterfaceType_NodeChoice interface {
	isTunnelInterfaceType_NodeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isTunnelInterfaceType_NetworkChoice interface {
	isTunnelInterfaceType_NetworkChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type TunnelInterfaceType_Cluster struct {
	Cluster *schema.Empty `protobuf:"bytes,2,opt,name=cluster,proto3,oneof" json:"cluster,omitempty"`
}
type TunnelInterfaceType_Node struct {
	Node string `protobuf:"bytes,3,opt,name=node,proto3,oneof" json:"node,omitempty"`
}
type TunnelInterfaceType_SiteLocalNetwork struct {
	SiteLocalNetwork *schema.Empty `protobuf:"bytes,7,opt,name=site_local_network,json=siteLocalNetwork,proto3,oneof" json:"site_local_network,omitempty"`
}
type TunnelInterfaceType_SiteLocalInsideNetwork struct {
	SiteLocalInsideNetwork *schema.Empty `protobuf:"bytes,8,opt,name=site_local_inside_network,json=siteLocalInsideNetwork,proto3,oneof" json:"site_local_inside_network,omitempty"`
}
type TunnelInterfaceType_InsideNetwork struct {
	InsideNetwork *views.ObjectRefType `protobuf:"bytes,9,opt,name=inside_network,json=insideNetwork,proto3,oneof" json:"inside_network,omitempty"`
}

func (*TunnelInterfaceType_Cluster) isTunnelInterfaceType_NodeChoice()                   {}
func (*TunnelInterfaceType_Node) isTunnelInterfaceType_NodeChoice()                      {}
func (*TunnelInterfaceType_SiteLocalNetwork) isTunnelInterfaceType_NetworkChoice()       {}
func (*TunnelInterfaceType_SiteLocalInsideNetwork) isTunnelInterfaceType_NetworkChoice() {}
func (*TunnelInterfaceType_InsideNetwork) isTunnelInterfaceType_NetworkChoice()          {}

func (m *TunnelInterfaceType) GetNodeChoice() isTunnelInterfaceType_NodeChoice {
	if m != nil {
		return m.NodeChoice
	}
	return nil
}
func (m *TunnelInterfaceType) GetNetworkChoice() isTunnelInterfaceType_NetworkChoice {
	if m != nil {
		return m.NetworkChoice
	}
	return nil
}

func (m *TunnelInterfaceType) GetCluster() *schema.Empty {
	if x, ok := m.GetNodeChoice().(*TunnelInterfaceType_Cluster); ok {
		return x.Cluster
	}
	return nil
}

func (m *TunnelInterfaceType) GetNode() string {
	if x, ok := m.GetNodeChoice().(*TunnelInterfaceType_Node); ok {
		return x.Node
	}
	return ""
}

func (m *TunnelInterfaceType) GetTunnel() *views.ObjectRefType {
	if m != nil {
		return m.Tunnel
	}
	return nil
}

func (m *TunnelInterfaceType) GetStaticIp() *StaticIPParametersType {
	if m != nil {
		return m.StaticIp
	}
	return nil
}

func (m *TunnelInterfaceType) GetSiteLocalNetwork() *schema.Empty {
	if x, ok := m.GetNetworkChoice().(*TunnelInterfaceType_SiteLocalNetwork); ok {
		return x.SiteLocalNetwork
	}
	return nil
}

func (m *TunnelInterfaceType) GetSiteLocalInsideNetwork() *schema.Empty {
	if x, ok := m.GetNetworkChoice().(*TunnelInterfaceType_SiteLocalInsideNetwork); ok {
		return x.SiteLocalInsideNetwork
	}
	return nil
}

func (m *TunnelInterfaceType) GetInsideNetwork() *views.ObjectRefType {
	if x, ok := m.GetNetworkChoice().(*TunnelInterfaceType_InsideNetwork); ok {
		return x.InsideNetwork
	}
	return nil
}

func (m *TunnelInterfaceType) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *TunnelInterfaceType) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TunnelInterfaceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TunnelInterfaceType_Cluster)(nil),
		(*TunnelInterfaceType_Node)(nil),
		(*TunnelInterfaceType_SiteLocalNetwork)(nil),
		(*TunnelInterfaceType_SiteLocalInsideNetwork)(nil),
		(*TunnelInterfaceType_InsideNetwork)(nil),
	}
}

// Legacy Configuration
//
// x-displayName: "Legacy Configuration"
// Legacy Interface Configuration
type LegacyInterfaceType struct {
	// Interface Type
	//
	// x-displayName: "Type"
	// x-required
	// Specifies the type of interface (ethernet, vlan, lacp etc)
	Type NetworkInterfaceType `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceType" json:"type,omitempty"`
	// Mtu
	//
	// x-displayName: "MTU"
	// x-example: "0"
	// Maximum Transfer Unit (Max packet length) of the interface
	// When configured, mtu must be between 512 and 16384
	Mtu uint32 `protobuf:"varint,3,opt,name=mtu,proto3" json:"mtu,omitempty"`
	// Virtual Network
	//
	// x-displayName: "Virtual Network"
	// Virtual-network for the interface
	// This is optional and can contain at most one entry
	VirtualNetwork []*schema.ObjectRefType `protobuf:"bytes,4,rep,name=virtual_network,json=virtualNetwork,proto3" json:"virtual_network,omitempty"`
	// DHCP Client
	//
	// x-displayName: "Enable DHCP Client"
	// x-required
	// Enable DHCP based address assignment for this interface.
	DhcpAddress NetworkInterfaceDHCP `protobuf:"varint,5,opt,name=dhcp_address,json=dhcpAddress,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceDHCP" json:"dhcp_address,omitempty"`
	// Static IP
	//
	// x-displayName: "Static IP"
	// If DHCP server is enabled, configures the subnet to be used for IP allocation.
	StaticAddresses []*schema.Ipv4SubnetType `protobuf:"bytes,6,rep,name=static_addresses,json=staticAddresses,proto3" json:"static_addresses,omitempty"`
	// Default Gateway
	//
	// x-displayName: "Default Gateway"
	// Configures how default gateway is derived for the subnet static addresses
	DefaultGateway *NetworkInterfaceDFGW `protobuf:"bytes,7,opt,name=default_gateway,json=defaultGateway,proto3" json:"default_gateway,omitempty"`
	// DNS Server
	//
	// x-displayName: "DNS Server"
	// Configures how DNS server is derived for the subnet in static addresses
	DNSServer *NetworkInterfaceDNS `protobuf:"bytes,8,opt,name=DNS_server,json=DNSServer,proto3" json:"DNS_server,omitempty"`
	// DHCP Server
	//
	// x-displayName: "Enable DHCP Server"
	// x-required
	// Behave as DHCP server for subnet configured in static addresses.
	DHCPServer NetworkInterfaceDHCPServer `protobuf:"varint,9,opt,name=DHCP_server,json=DHCPServer,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceDHCPServer" json:"DHCP_server,omitempty"`
	// Vlan Tagging
	//
	// x-displayName: "Enable VLAN Tagging"
	// x-example: "NETWORK_INTERFACE_VLAN_TAGGING_DISABLE"
	// Enable/Disable VLAN tagging on this interface.
	// Must be enabled for VLAN interfaces
	VlanTagging NetworkInterfaceVLANTagging `protobuf:"varint,10,opt,name=vlan_tagging,json=vlanTagging,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceVLANTagging" json:"vlan_tagging,omitempty"`
	// Device Name
	//
	// x-displayName: "Device Name"
	// x-example: "value"
	// x-required
	// Name of the physical network interface device  which this network interface represents.
	DeviceName string `protobuf:"bytes,11,opt,name=device_name,json=deviceName,proto3" json:"device_name,omitempty"`
	// Vlan Tag
	//
	// x-displayName: "VLAN Tag"
	// x-example: "0"
	// Vlan tag of the interface, valid only if VLAN tagging is enabled
	// when vlan_tagging is enabled, value must be between 1 - 4094
	VlanTag uint32 `protobuf:"varint,13,opt,name=vlan_tag,json=vlanTag,proto3" json:"vlan_tag,omitempty"`
	// Tunnel
	//
	// x-displayName: "Tunnel"
	// When interface is created as TUNNEL type, then reference to tunnel is specified here
	Tunnel *NetworkInterfaceTunnel `protobuf:"bytes,14,opt,name=tunnel,proto3" json:"tunnel,omitempty"`
	// Priority
	//
	// x-displayName: "Priority"
	// x-example: "42"
	// Priority of the network interface when multiple network interfaces are present in the fleet object
	// Greater the value, higher the priority
	Priority uint32 `protobuf:"varint,15,opt,name=priority,proto3" json:"priority,omitempty"`
	// Address Allocator
	//
	// x-displayName: "Address Allocator"
	// Reference to an address allocator for the network interface. When set, the allocator is used to
	// allocate a subnet for the interface and an address from the subnet is set on the interface.
	AddressAllocator []*schema.ObjectRefType `protobuf:"bytes,16,rep,name=address_allocator,json=addressAllocator,proto3" json:"address_allocator,omitempty"`
	// Select Link Quality Monitoring configuration
	//
	// x-displayName: "Select Link Quality Monitoring configuration"
	// Link Quality Monitoring configuration for a network interface. When enabled, VER will send probes
	// on the network interface to monitor quality of the link. Links are assigned a score based on the result of probes.
	//
	// Types that are valid to be assigned to MonitoringChoice:
	//	*LegacyInterfaceType_MonitorDisabled
	//	*LegacyInterfaceType_Monitor
	MonitoringChoice isLegacyInterfaceType_MonitoringChoice `protobuf_oneof:"monitoring_choice"`
}

func (m *LegacyInterfaceType) Reset()      { *m = LegacyInterfaceType{} }
func (*LegacyInterfaceType) ProtoMessage() {}
func (*LegacyInterfaceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{24}
}
func (m *LegacyInterfaceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LegacyInterfaceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LegacyInterfaceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LegacyInterfaceType.Merge(m, src)
}
func (m *LegacyInterfaceType) XXX_Size() int {
	return m.Size()
}
func (m *LegacyInterfaceType) XXX_DiscardUnknown() {
	xxx_messageInfo_LegacyInterfaceType.DiscardUnknown(m)
}

var xxx_messageInfo_LegacyInterfaceType proto.InternalMessageInfo

type isLegacyInterfaceType_MonitoringChoice interface {
	isLegacyInterfaceType_MonitoringChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type LegacyInterfaceType_MonitorDisabled struct {
	MonitorDisabled *schema.Empty `protobuf:"bytes,18,opt,name=monitor_disabled,json=monitorDisabled,proto3,oneof" json:"monitor_disabled,omitempty"`
}
type LegacyInterfaceType_Monitor struct {
	Monitor *LinkQualityMonitorConfig `protobuf:"bytes,19,opt,name=monitor,proto3,oneof" json:"monitor,omitempty"`
}

func (*LegacyInterfaceType_MonitorDisabled) isLegacyInterfaceType_MonitoringChoice() {}
func (*LegacyInterfaceType_Monitor) isLegacyInterfaceType_MonitoringChoice()         {}

func (m *LegacyInterfaceType) GetMonitoringChoice() isLegacyInterfaceType_MonitoringChoice {
	if m != nil {
		return m.MonitoringChoice
	}
	return nil
}

func (m *LegacyInterfaceType) GetType() NetworkInterfaceType {
	if m != nil {
		return m.Type
	}
	return NETWORK_INTERFACE_ETHERNET
}

func (m *LegacyInterfaceType) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *LegacyInterfaceType) GetVirtualNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.VirtualNetwork
	}
	return nil
}

func (m *LegacyInterfaceType) GetDhcpAddress() NetworkInterfaceDHCP {
	if m != nil {
		return m.DhcpAddress
	}
	return NETWORK_INTERFACE_DHCP_DISABLE
}

func (m *LegacyInterfaceType) GetStaticAddresses() []*schema.Ipv4SubnetType {
	if m != nil {
		return m.StaticAddresses
	}
	return nil
}

func (m *LegacyInterfaceType) GetDefaultGateway() *NetworkInterfaceDFGW {
	if m != nil {
		return m.DefaultGateway
	}
	return nil
}

func (m *LegacyInterfaceType) GetDNSServer() *NetworkInterfaceDNS {
	if m != nil {
		return m.DNSServer
	}
	return nil
}

func (m *LegacyInterfaceType) GetDHCPServer() NetworkInterfaceDHCPServer {
	if m != nil {
		return m.DHCPServer
	}
	return NETWORK_INTERFACE_DHCP_SERVER_DISABLE
}

func (m *LegacyInterfaceType) GetVlanTagging() NetworkInterfaceVLANTagging {
	if m != nil {
		return m.VlanTagging
	}
	return NETWORK_INTERFACE_VLAN_TAGGING_DISABLE
}

func (m *LegacyInterfaceType) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func (m *LegacyInterfaceType) GetVlanTag() uint32 {
	if m != nil {
		return m.VlanTag
	}
	return 0
}

func (m *LegacyInterfaceType) GetTunnel() *NetworkInterfaceTunnel {
	if m != nil {
		return m.Tunnel
	}
	return nil
}

func (m *LegacyInterfaceType) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *LegacyInterfaceType) GetAddressAllocator() []*schema.ObjectRefType {
	if m != nil {
		return m.AddressAllocator
	}
	return nil
}

func (m *LegacyInterfaceType) GetMonitorDisabled() *schema.Empty {
	if x, ok := m.GetMonitoringChoice().(*LegacyInterfaceType_MonitorDisabled); ok {
		return x.MonitorDisabled
	}
	return nil
}

func (m *LegacyInterfaceType) GetMonitor() *LinkQualityMonitorConfig {
	if x, ok := m.GetMonitoringChoice().(*LegacyInterfaceType_Monitor); ok {
		return x.Monitor
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LegacyInterfaceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LegacyInterfaceType_MonitorDisabled)(nil),
		(*LegacyInterfaceType_Monitor)(nil),
	}
}

// Loopback Device
//
// x-displayName: "Loopback Device"
// Loopback Device Configuration
type LoopbackInterfaceType struct {
	// Device
	//
	// x-displayName: "Loopback Ethernet Device"
	// x-example: "eth0"
	// x-required
	// Interface configuration for the Loopback Ethernet device
	Device string `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
	// Select Node Independent or Node Specific Interface
	//
	// x-displayName: "Select Configuration for Cluster or Specific Node"
	// x-required
	// Cluster configuration will apply to a given device on all nodes of the site.
	// Node configuration will apply to a given device on a given node.
	//
	// Types that are valid to be assigned to NodeChoice:
	//	*LoopbackInterfaceType_Cluster
	//	*LoopbackInterfaceType_Node
	NodeChoice isLoopbackInterfaceType_NodeChoice `protobuf_oneof:"node_choice"`
	// Interface Addressing
	//
	// x-displayName: "Select Interface Address Method"
	// x-required
	// Select how ip address will be assigned to Interface
	//
	// Types that are valid to be assigned to AddressChoice:
	//	*LoopbackInterfaceType_DhcpClient
	//	*LoopbackInterfaceType_DhcpServer
	//	*LoopbackInterfaceType_StaticIp
	AddressChoice isLoopbackInterfaceType_AddressChoice `protobuf_oneof:"address_choice"`
	// IPv6 Interface Addressing
	//
	// x-displayName: "Select Interface IPv6 Address Method"
	// Select how IPv6 address will be assigned to Interface
	//
	// Types that are valid to be assigned to Ipv6AddressChoice:
	//	*LoopbackInterfaceType_NoIpv6Address
	//	*LoopbackInterfaceType_StaticIpv6Address
	Ipv6AddressChoice isLoopbackInterfaceType_Ipv6AddressChoice `protobuf_oneof:"ipv6_address_choice"`
	// Network for this Interface
	//
	// x-displayName: "Select Virtual Network"
	// x-required
	// Select virtual network of this interface
	//
	// Types that are valid to be assigned to NetworkChoice:
	//	*LoopbackInterfaceType_SiteLocalNetwork
	//	*LoopbackInterfaceType_SiteLocalInsideNetwork
	//	*LoopbackInterfaceType_IpFabricNetwork
	NetworkChoice isLoopbackInterfaceType_NetworkChoice `protobuf_oneof:"network_choice"`
	// Maximum Packet Size (MTU)
	//
	// x-displayName: "Maximum Packet Size (MTU)"
	// x-example: "1450"
	// Maximum packet size (Maximum Transfer Unit) of the interface
	// When configured, mtu must be between 512 and 16384
	Mtu uint32 `protobuf:"varint,9,opt,name=mtu,proto3" json:"mtu,omitempty"`
}

func (m *LoopbackInterfaceType) Reset()      { *m = LoopbackInterfaceType{} }
func (*LoopbackInterfaceType) ProtoMessage() {}
func (*LoopbackInterfaceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{25}
}
func (m *LoopbackInterfaceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoopbackInterfaceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LoopbackInterfaceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoopbackInterfaceType.Merge(m, src)
}
func (m *LoopbackInterfaceType) XXX_Size() int {
	return m.Size()
}
func (m *LoopbackInterfaceType) XXX_DiscardUnknown() {
	xxx_messageInfo_LoopbackInterfaceType.DiscardUnknown(m)
}

var xxx_messageInfo_LoopbackInterfaceType proto.InternalMessageInfo

type isLoopbackInterfaceType_NodeChoice interface {
	isLoopbackInterfaceType_NodeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isLoopbackInterfaceType_AddressChoice interface {
	isLoopbackInterfaceType_AddressChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isLoopbackInterfaceType_Ipv6AddressChoice interface {
	isLoopbackInterfaceType_Ipv6AddressChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isLoopbackInterfaceType_NetworkChoice interface {
	isLoopbackInterfaceType_NetworkChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type LoopbackInterfaceType_Cluster struct {
	Cluster *schema.Empty `protobuf:"bytes,3,opt,name=cluster,proto3,oneof" json:"cluster,omitempty"`
}
type LoopbackInterfaceType_Node struct {
	Node string `protobuf:"bytes,4,opt,name=node,proto3,oneof" json:"node,omitempty"`
}
type LoopbackInterfaceType_DhcpClient struct {
	DhcpClient *schema.Empty `protobuf:"bytes,6,opt,name=dhcp_client,json=dhcpClient,proto3,oneof" json:"dhcp_client,omitempty"`
}
type LoopbackInterfaceType_DhcpServer struct {
	DhcpServer *DHCPServerParametersType `protobuf:"bytes,7,opt,name=dhcp_server,json=dhcpServer,proto3,oneof" json:"dhcp_server,omitempty"`
}
type LoopbackInterfaceType_StaticIp struct {
	StaticIp *StaticIPParametersType `protobuf:"bytes,8,opt,name=static_ip,json=staticIp,proto3,oneof" json:"static_ip,omitempty"`
}
type LoopbackInterfaceType_NoIpv6Address struct {
	NoIpv6Address *schema.Empty `protobuf:"bytes,31,opt,name=no_ipv6_address,json=noIpv6Address,proto3,oneof" json:"no_ipv6_address,omitempty"`
}
type LoopbackInterfaceType_StaticIpv6Address struct {
	StaticIpv6Address *StaticIPParametersType `protobuf:"bytes,32,opt,name=static_ipv6_address,json=staticIpv6Address,proto3,oneof" json:"static_ipv6_address,omitempty"`
}
type LoopbackInterfaceType_SiteLocalNetwork struct {
	SiteLocalNetwork *schema.Empty `protobuf:"bytes,11,opt,name=site_local_network,json=siteLocalNetwork,proto3,oneof" json:"site_local_network,omitempty"`
}
type LoopbackInterfaceType_SiteLocalInsideNetwork struct {
	SiteLocalInsideNetwork *schema.Empty `protobuf:"bytes,12,opt,name=site_local_inside_network,json=siteLocalInsideNetwork,proto3,oneof" json:"site_local_inside_network,omitempty"`
}
type LoopbackInterfaceType_IpFabricNetwork struct {
	IpFabricNetwork *schema.Empty `protobuf:"bytes,13,opt,name=ip_fabric_network,json=ipFabricNetwork,proto3,oneof" json:"ip_fabric_network,omitempty"`
}

func (*LoopbackInterfaceType_Cluster) isLoopbackInterfaceType_NodeChoice()                   {}
func (*LoopbackInterfaceType_Node) isLoopbackInterfaceType_NodeChoice()                      {}
func (*LoopbackInterfaceType_DhcpClient) isLoopbackInterfaceType_AddressChoice()             {}
func (*LoopbackInterfaceType_DhcpServer) isLoopbackInterfaceType_AddressChoice()             {}
func (*LoopbackInterfaceType_StaticIp) isLoopbackInterfaceType_AddressChoice()               {}
func (*LoopbackInterfaceType_NoIpv6Address) isLoopbackInterfaceType_Ipv6AddressChoice()      {}
func (*LoopbackInterfaceType_StaticIpv6Address) isLoopbackInterfaceType_Ipv6AddressChoice()  {}
func (*LoopbackInterfaceType_SiteLocalNetwork) isLoopbackInterfaceType_NetworkChoice()       {}
func (*LoopbackInterfaceType_SiteLocalInsideNetwork) isLoopbackInterfaceType_NetworkChoice() {}
func (*LoopbackInterfaceType_IpFabricNetwork) isLoopbackInterfaceType_NetworkChoice()        {}

func (m *LoopbackInterfaceType) GetNodeChoice() isLoopbackInterfaceType_NodeChoice {
	if m != nil {
		return m.NodeChoice
	}
	return nil
}
func (m *LoopbackInterfaceType) GetAddressChoice() isLoopbackInterfaceType_AddressChoice {
	if m != nil {
		return m.AddressChoice
	}
	return nil
}
func (m *LoopbackInterfaceType) GetIpv6AddressChoice() isLoopbackInterfaceType_Ipv6AddressChoice {
	if m != nil {
		return m.Ipv6AddressChoice
	}
	return nil
}
func (m *LoopbackInterfaceType) GetNetworkChoice() isLoopbackInterfaceType_NetworkChoice {
	if m != nil {
		return m.NetworkChoice
	}
	return nil
}

func (m *LoopbackInterfaceType) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *LoopbackInterfaceType) GetCluster() *schema.Empty {
	if x, ok := m.GetNodeChoice().(*LoopbackInterfaceType_Cluster); ok {
		return x.Cluster
	}
	return nil
}

func (m *LoopbackInterfaceType) GetNode() string {
	if x, ok := m.GetNodeChoice().(*LoopbackInterfaceType_Node); ok {
		return x.Node
	}
	return ""
}

func (m *LoopbackInterfaceType) GetDhcpClient() *schema.Empty {
	if x, ok := m.GetAddressChoice().(*LoopbackInterfaceType_DhcpClient); ok {
		return x.DhcpClient
	}
	return nil
}

func (m *LoopbackInterfaceType) GetDhcpServer() *DHCPServerParametersType {
	if x, ok := m.GetAddressChoice().(*LoopbackInterfaceType_DhcpServer); ok {
		return x.DhcpServer
	}
	return nil
}

func (m *LoopbackInterfaceType) GetStaticIp() *StaticIPParametersType {
	if x, ok := m.GetAddressChoice().(*LoopbackInterfaceType_StaticIp); ok {
		return x.StaticIp
	}
	return nil
}

func (m *LoopbackInterfaceType) GetNoIpv6Address() *schema.Empty {
	if x, ok := m.GetIpv6AddressChoice().(*LoopbackInterfaceType_NoIpv6Address); ok {
		return x.NoIpv6Address
	}
	return nil
}

func (m *LoopbackInterfaceType) GetStaticIpv6Address() *StaticIPParametersType {
	if x, ok := m.GetIpv6AddressChoice().(*LoopbackInterfaceType_StaticIpv6Address); ok {
		return x.StaticIpv6Address
	}
	return nil
}

func (m *LoopbackInterfaceType) GetSiteLocalNetwork() *schema.Empty {
	if x, ok := m.GetNetworkChoice().(*LoopbackInterfaceType_SiteLocalNetwork); ok {
		return x.SiteLocalNetwork
	}
	return nil
}

func (m *LoopbackInterfaceType) GetSiteLocalInsideNetwork() *schema.Empty {
	if x, ok := m.GetNetworkChoice().(*LoopbackInterfaceType_SiteLocalInsideNetwork); ok {
		return x.SiteLocalInsideNetwork
	}
	return nil
}

func (m *LoopbackInterfaceType) GetIpFabricNetwork() *schema.Empty {
	if x, ok := m.GetNetworkChoice().(*LoopbackInterfaceType_IpFabricNetwork); ok {
		return x.IpFabricNetwork
	}
	return nil
}

func (m *LoopbackInterfaceType) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LoopbackInterfaceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LoopbackInterfaceType_Cluster)(nil),
		(*LoopbackInterfaceType_Node)(nil),
		(*LoopbackInterfaceType_DhcpClient)(nil),
		(*LoopbackInterfaceType_DhcpServer)(nil),
		(*LoopbackInterfaceType_StaticIp)(nil),
		(*LoopbackInterfaceType_NoIpv6Address)(nil),
		(*LoopbackInterfaceType_StaticIpv6Address)(nil),
		(*LoopbackInterfaceType_SiteLocalNetwork)(nil),
		(*LoopbackInterfaceType_SiteLocalInsideNetwork)(nil),
		(*LoopbackInterfaceType_IpFabricNetwork)(nil),
	}
}

// Link Quality Monitoring Configuration
//
// x-displayName: "Link Quality Monitoring Configuration"
// Link Quality Monitoring configuration for a network interface.
type LinkQualityMonitorConfig struct {
}

func (m *LinkQualityMonitorConfig) Reset()      { *m = LinkQualityMonitorConfig{} }
func (*LinkQualityMonitorConfig) ProtoMessage() {}
func (*LinkQualityMonitorConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{26}
}
func (m *LinkQualityMonitorConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkQualityMonitorConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LinkQualityMonitorConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkQualityMonitorConfig.Merge(m, src)
}
func (m *LinkQualityMonitorConfig) XXX_Size() int {
	return m.Size()
}
func (m *LinkQualityMonitorConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkQualityMonitorConfig.DiscardUnknown(m)
}

var xxx_messageInfo_LinkQualityMonitorConfig proto.InternalMessageInfo

// Host Interface
//
// x-displayName: "Host Interface"
// Host Interface configuration corresponding to a Network Interface
type VhostInterfaceType struct {
	// Select type of host interface for the network interface
	//
	// x-displayName: "Select Configuration of Host Interface"
	// x-required
	// Configures Host Interface for a Network Interface
	//
	// Types that are valid to be assigned to HostChoice:
	//	*VhostInterfaceType_NoHost
	//	*VhostInterfaceType_Vhost
	//	*VhostInterfaceType_Virtual
	HostChoice isVhostInterfaceType_HostChoice `protobuf_oneof:"host_choice"`
}

func (m *VhostInterfaceType) Reset()      { *m = VhostInterfaceType{} }
func (*VhostInterfaceType) ProtoMessage() {}
func (*VhostInterfaceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{27}
}
func (m *VhostInterfaceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VhostInterfaceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VhostInterfaceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VhostInterfaceType.Merge(m, src)
}
func (m *VhostInterfaceType) XXX_Size() int {
	return m.Size()
}
func (m *VhostInterfaceType) XXX_DiscardUnknown() {
	xxx_messageInfo_VhostInterfaceType.DiscardUnknown(m)
}

var xxx_messageInfo_VhostInterfaceType proto.InternalMessageInfo

type isVhostInterfaceType_HostChoice interface {
	isVhostInterfaceType_HostChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type VhostInterfaceType_NoHost struct {
	NoHost *schema.Empty `protobuf:"bytes,2,opt,name=no_host,json=noHost,proto3,oneof" json:"no_host,omitempty"`
}
type VhostInterfaceType_Vhost struct {
	Vhost *schema.Empty `protobuf:"bytes,3,opt,name=vhost,proto3,oneof" json:"vhost,omitempty"`
}
type VhostInterfaceType_Virtual struct {
	Virtual *schema.Empty `protobuf:"bytes,4,opt,name=virtual,proto3,oneof" json:"virtual,omitempty"`
}

func (*VhostInterfaceType_NoHost) isVhostInterfaceType_HostChoice()  {}
func (*VhostInterfaceType_Vhost) isVhostInterfaceType_HostChoice()   {}
func (*VhostInterfaceType_Virtual) isVhostInterfaceType_HostChoice() {}

func (m *VhostInterfaceType) GetHostChoice() isVhostInterfaceType_HostChoice {
	if m != nil {
		return m.HostChoice
	}
	return nil
}

func (m *VhostInterfaceType) GetNoHost() *schema.Empty {
	if x, ok := m.GetHostChoice().(*VhostInterfaceType_NoHost); ok {
		return x.NoHost
	}
	return nil
}

func (m *VhostInterfaceType) GetVhost() *schema.Empty {
	if x, ok := m.GetHostChoice().(*VhostInterfaceType_Vhost); ok {
		return x.Vhost
	}
	return nil
}

func (m *VhostInterfaceType) GetVirtual() *schema.Empty {
	if x, ok := m.GetHostChoice().(*VhostInterfaceType_Virtual); ok {
		return x.Virtual
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VhostInterfaceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VhostInterfaceType_NoHost)(nil),
		(*VhostInterfaceType_Vhost)(nil),
		(*VhostInterfaceType_Virtual)(nil),
	}
}

// Layer2 VLAN interface
//
// x-displayName: "Layer2 VLAN Interface"
// Layer2 VLAN Interface Configuration
type Layer2VlanInterfaceType struct {
	// Device
	//
	// x-displayName: "Ethernet Device"
	// x-example: "eth0"
	// x-required
	// Physical ethernet interface
	Device string `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
	// VLAN Id
	//
	// x-displayName: "VLAN Id"
	// x-example: "10"
	// x-required
	// VLAN Id
	VlanId uint32 `protobuf:"varint,2,opt,name=vlan_id,json=vlanId,proto3" json:"vlan_id,omitempty"`
}

func (m *Layer2VlanInterfaceType) Reset()      { *m = Layer2VlanInterfaceType{} }
func (*Layer2VlanInterfaceType) ProtoMessage() {}
func (*Layer2VlanInterfaceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{28}
}
func (m *Layer2VlanInterfaceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Layer2VlanInterfaceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Layer2VlanInterfaceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Layer2VlanInterfaceType.Merge(m, src)
}
func (m *Layer2VlanInterfaceType) XXX_Size() int {
	return m.Size()
}
func (m *Layer2VlanInterfaceType) XXX_DiscardUnknown() {
	xxx_messageInfo_Layer2VlanInterfaceType.DiscardUnknown(m)
}

var xxx_messageInfo_Layer2VlanInterfaceType proto.InternalMessageInfo

func (m *Layer2VlanInterfaceType) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *Layer2VlanInterfaceType) GetVlanId() uint32 {
	if m != nil {
		return m.VlanId
	}
	return 0
}

// VLAN on Site Local Outside Interface
//
// x-displayName: "VLAN on Site Local Outside Interface"
// Layer2 Site Local Outside VLAN Interface Configuration
type Layer2SloVlanInterfaceType struct {
	// VLAN Id
	//
	// x-displayName: "VLAN Id"
	// x-example: "10"
	// x-required
	// VLAN Id
	VlanId uint32 `protobuf:"varint,1,opt,name=vlan_id,json=vlanId,proto3" json:"vlan_id,omitempty"`
}

func (m *Layer2SloVlanInterfaceType) Reset()      { *m = Layer2SloVlanInterfaceType{} }
func (*Layer2SloVlanInterfaceType) ProtoMessage() {}
func (*Layer2SloVlanInterfaceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{29}
}
func (m *Layer2SloVlanInterfaceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Layer2SloVlanInterfaceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Layer2SloVlanInterfaceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Layer2SloVlanInterfaceType.Merge(m, src)
}
func (m *Layer2SloVlanInterfaceType) XXX_Size() int {
	return m.Size()
}
func (m *Layer2SloVlanInterfaceType) XXX_DiscardUnknown() {
	xxx_messageInfo_Layer2SloVlanInterfaceType.DiscardUnknown(m)
}

var xxx_messageInfo_Layer2SloVlanInterfaceType proto.InternalMessageInfo

func (m *Layer2SloVlanInterfaceType) GetVlanId() uint32 {
	if m != nil {
		return m.VlanId
	}
	return 0
}

// Layer2 SR-IOV interface
//
// x-displayName: "Layer2 SR-IOV Interface"
// Layer2 SR-IOV Interface Configuration
type Layer2SriovInterfaceType struct {
	// Device
	//
	// x-displayName: "Ethernet Device"
	// x-example: "eth0"
	// x-required
	// Physical ethernet interface
	Device string `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
	// Select Untagged or VLAN tagged
	//
	// x-displayName: "Select Untagged or VLAN tagged"
	// x-required
	// Select if this interface is VLAN tagged or untagged
	//
	// Types that are valid to be assigned to VlanChoice:
	//	*Layer2SriovInterfaceType_Untagged
	//	*Layer2SriovInterfaceType_VlanId
	VlanChoice isLayer2SriovInterfaceType_VlanChoice `protobuf_oneof:"vlan_choice"`
}

func (m *Layer2SriovInterfaceType) Reset()      { *m = Layer2SriovInterfaceType{} }
func (*Layer2SriovInterfaceType) ProtoMessage() {}
func (*Layer2SriovInterfaceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{30}
}
func (m *Layer2SriovInterfaceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Layer2SriovInterfaceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Layer2SriovInterfaceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Layer2SriovInterfaceType.Merge(m, src)
}
func (m *Layer2SriovInterfaceType) XXX_Size() int {
	return m.Size()
}
func (m *Layer2SriovInterfaceType) XXX_DiscardUnknown() {
	xxx_messageInfo_Layer2SriovInterfaceType.DiscardUnknown(m)
}

var xxx_messageInfo_Layer2SriovInterfaceType proto.InternalMessageInfo

type isLayer2SriovInterfaceType_VlanChoice interface {
	isLayer2SriovInterfaceType_VlanChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Layer2SriovInterfaceType_Untagged struct {
	Untagged *schema.Empty `protobuf:"bytes,3,opt,name=untagged,proto3,oneof" json:"untagged,omitempty"`
}
type Layer2SriovInterfaceType_VlanId struct {
	VlanId uint32 `protobuf:"varint,4,opt,name=vlan_id,json=vlanId,proto3,oneof" json:"vlan_id,omitempty"`
}

func (*Layer2SriovInterfaceType_Untagged) isLayer2SriovInterfaceType_VlanChoice() {}
func (*Layer2SriovInterfaceType_VlanId) isLayer2SriovInterfaceType_VlanChoice()   {}

func (m *Layer2SriovInterfaceType) GetVlanChoice() isLayer2SriovInterfaceType_VlanChoice {
	if m != nil {
		return m.VlanChoice
	}
	return nil
}

func (m *Layer2SriovInterfaceType) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *Layer2SriovInterfaceType) GetUntagged() *schema.Empty {
	if x, ok := m.GetVlanChoice().(*Layer2SriovInterfaceType_Untagged); ok {
		return x.Untagged
	}
	return nil
}

func (m *Layer2SriovInterfaceType) GetVlanId() uint32 {
	if x, ok := m.GetVlanChoice().(*Layer2SriovInterfaceType_VlanId); ok {
		return x.VlanId
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Layer2SriovInterfaceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Layer2SriovInterfaceType_Untagged)(nil),
		(*Layer2SriovInterfaceType_VlanId)(nil),
	}
}

// Layer2 interface
//
// x-displayName: "Layer2 Interface"
// Layer2 Interface Configuration
type Layer2InterfaceType struct {
	// Layer2 Interface choice
	//
	// x-displayName: "Layer2 Interface Type"
	// x-required
	// Select the Layer2 interface type
	//
	// Types that are valid to be assigned to Layer2InterfaceChoice:
	//	*Layer2InterfaceType_L2VlanInterface
	//	*Layer2InterfaceType_L2VlanSloInterface
	//	*Layer2InterfaceType_L2SriovInterface
	Layer2InterfaceChoice isLayer2InterfaceType_Layer2InterfaceChoice `protobuf_oneof:"layer2_interface_choice"`
}

func (m *Layer2InterfaceType) Reset()      { *m = Layer2InterfaceType{} }
func (*Layer2InterfaceType) ProtoMessage() {}
func (*Layer2InterfaceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{31}
}
func (m *Layer2InterfaceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Layer2InterfaceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Layer2InterfaceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Layer2InterfaceType.Merge(m, src)
}
func (m *Layer2InterfaceType) XXX_Size() int {
	return m.Size()
}
func (m *Layer2InterfaceType) XXX_DiscardUnknown() {
	xxx_messageInfo_Layer2InterfaceType.DiscardUnknown(m)
}

var xxx_messageInfo_Layer2InterfaceType proto.InternalMessageInfo

type isLayer2InterfaceType_Layer2InterfaceChoice interface {
	isLayer2InterfaceType_Layer2InterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Layer2InterfaceType_L2VlanInterface struct {
	L2VlanInterface *Layer2VlanInterfaceType `protobuf:"bytes,2,opt,name=l2vlan_interface,json=l2vlanInterface,proto3,oneof" json:"l2vlan_interface,omitempty"`
}
type Layer2InterfaceType_L2VlanSloInterface struct {
	L2VlanSloInterface *Layer2SloVlanInterfaceType `protobuf:"bytes,3,opt,name=l2vlan_slo_interface,json=l2vlanSloInterface,proto3,oneof" json:"l2vlan_slo_interface,omitempty"`
}
type Layer2InterfaceType_L2SriovInterface struct {
	L2SriovInterface *Layer2SriovInterfaceType `protobuf:"bytes,4,opt,name=l2sriov_interface,json=l2sriovInterface,proto3,oneof" json:"l2sriov_interface,omitempty"`
}

func (*Layer2InterfaceType_L2VlanInterface) isLayer2InterfaceType_Layer2InterfaceChoice()    {}
func (*Layer2InterfaceType_L2VlanSloInterface) isLayer2InterfaceType_Layer2InterfaceChoice() {}
func (*Layer2InterfaceType_L2SriovInterface) isLayer2InterfaceType_Layer2InterfaceChoice()   {}

func (m *Layer2InterfaceType) GetLayer2InterfaceChoice() isLayer2InterfaceType_Layer2InterfaceChoice {
	if m != nil {
		return m.Layer2InterfaceChoice
	}
	return nil
}

func (m *Layer2InterfaceType) GetL2VlanInterface() *Layer2VlanInterfaceType {
	if x, ok := m.GetLayer2InterfaceChoice().(*Layer2InterfaceType_L2VlanInterface); ok {
		return x.L2VlanInterface
	}
	return nil
}

func (m *Layer2InterfaceType) GetL2VlanSloInterface() *Layer2SloVlanInterfaceType {
	if x, ok := m.GetLayer2InterfaceChoice().(*Layer2InterfaceType_L2VlanSloInterface); ok {
		return x.L2VlanSloInterface
	}
	return nil
}

func (m *Layer2InterfaceType) GetL2SriovInterface() *Layer2SriovInterfaceType {
	if x, ok := m.GetLayer2InterfaceChoice().(*Layer2InterfaceType_L2SriovInterface); ok {
		return x.L2SriovInterface
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Layer2InterfaceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Layer2InterfaceType_L2VlanInterface)(nil),
		(*Layer2InterfaceType_L2VlanSloInterface)(nil),
		(*Layer2InterfaceType_L2SriovInterface)(nil),
	}
}

// Global Specification
//
// x-displayName: "Global Specification"
// Network Interface specification
type GlobalSpecType struct {
	// Interface Type
	//
	// x-displayName: "Type"
	// x-required
	// Specifies the type of interface (ethernet, vlan, lacp etc)
	Type NetworkInterfaceType `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceType" json:"type,omitempty"`
	// Mtu
	//
	// x-displayName: "MTU"
	// x-example: "0"
	// Maximum Transfer Unit (Max packet length) of the interface
	// When configured, mtu must be between 512 and 16384
	Mtu uint32 `protobuf:"varint,3,opt,name=mtu,proto3" json:"mtu,omitempty"`
	// Virtual Network
	//
	// x-displayName: "Virtual Network"
	// Virtual-network for the interface
	// This is optional and can contain at most one entry
	VirtualNetwork []*schema.ObjectRefType `protobuf:"bytes,4,rep,name=virtual_network,json=virtualNetwork,proto3" json:"virtual_network,omitempty"`
	// DHCP Client
	//
	// x-displayName: "Enable DHCP Client"
	// x-required
	// Enable DHCP based address assignment for this interface.
	DhcpAddress NetworkInterfaceDHCP `protobuf:"varint,5,opt,name=dhcp_address,json=dhcpAddress,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceDHCP" json:"dhcp_address,omitempty"`
	// Static IP
	//
	// x-displayName: "Static IP"
	// If DHCP server is enabled, configures the subnet to be used for IP allocation.
	StaticAddresses []*schema.Ipv4SubnetType `protobuf:"bytes,6,rep,name=static_addresses,json=staticAddresses,proto3" json:"static_addresses,omitempty"`
	// Static IPV6 address
	//
	// x-displayName: "Static IPV6"
	// If DHCP server is enabled, configures the subnet to be used for IPV6 allocation.
	StaticIpv6Addresses []*schema.Ipv6SubnetType `protobuf:"bytes,38,rep,name=static_ipv6_addresses,json=staticIpv6Addresses,proto3" json:"static_ipv6_addresses,omitempty"`
	// Default Gateway
	//
	// x-displayName: "Default Gateway"
	// Configures how default gateway is derived for the subnet static addresses
	DefaultGateway *NetworkInterfaceDFGW `protobuf:"bytes,7,opt,name=default_gateway,json=defaultGateway,proto3" json:"default_gateway,omitempty"`
	// DNS Server
	//
	// x-displayName: "DNS Server"
	// Configures how DNS server is derived for the subnet in static addresses
	DNSServer *NetworkInterfaceDNS `protobuf:"bytes,8,opt,name=DNS_server,json=DNSServer,proto3" json:"DNS_server,omitempty"`
	// DHCP Server
	//
	// x-displayName: "Enable DHCP Server"
	// x-required
	// Behave as DHCP server for subnet configured in static addresses.
	DHCPServer NetworkInterfaceDHCPServer `protobuf:"varint,9,opt,name=DHCP_server,json=DHCPServer,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceDHCPServer" json:"DHCP_server,omitempty"`
	// Vlan Tagging
	//
	// x-displayName: "Enable VLAN Tagging"
	// x-example: "NETWORK_INTERFACE_VLAN_TAGGING_DISABLE"
	// Enable/Disable VLAN tagging on this interface.
	// Must be enabled for VLAN interfaces
	VlanTagging NetworkInterfaceVLANTagging `protobuf:"varint,10,opt,name=vlan_tagging,json=vlanTagging,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceVLANTagging" json:"vlan_tagging,omitempty"`
	// Device Name
	//
	// x-displayName: "Device Name"
	// x-example: "value"
	// x-required
	// Name of the physical network interface device  which this network interface represents.
	DeviceName string `protobuf:"bytes,11,opt,name=device_name,json=deviceName,proto3" json:"device_name,omitempty"`
	// Parent Network Interface
	//
	// x-displayName: "Parent Interface"
	// When interface is created as VLAN tagged sub-interface or LACP (interface type),
	// then reference to parent network interface is specified here. Valid only for subinterfaces
	ParentNetworkInterface []*schema.ObjectRefType `protobuf:"bytes,12,rep,name=parent_network_interface,json=parentNetworkInterface,proto3" json:"parent_network_interface,omitempty"`
	// Vlan Tag
	//
	// x-displayName: "VLAN Tag"
	// x-example: "0"
	// Vlan tag of the interface, valid only if VLAN tagging is enabled
	// when vlan_tagging is enabled, value must be between 1 - 4094
	VlanTag uint32 `protobuf:"varint,13,opt,name=vlan_tag,json=vlanTag,proto3" json:"vlan_tag,omitempty"`
	// Tunnel
	//
	// x-displayName: "Tunnel"
	// When interface is created as TUNNEL type, then reference to tunnel is specified here
	Tunnel *NetworkInterfaceTunnel `protobuf:"bytes,14,opt,name=tunnel,proto3" json:"tunnel,omitempty"`
	// Priority
	//
	// x-displayName: "Priority"
	// x-example: "42"
	// Priority of the network interface when multiple network interfaces are present in the fleet object
	// Greater the value, higher the priority
	Priority uint32 `protobuf:"varint,15,opt,name=priority,proto3" json:"priority,omitempty"`
	// Address Allocator
	//
	// x-displayName: "Address Allocator"
	// Reference to an address allocator for the network interface. When set, the allocator is used to
	// allocate a subnet for the interface and an address from the subnet is set on the interface.
	AddressAllocator []*schema.ObjectRefType `protobuf:"bytes,16,rep,name=address_allocator,json=addressAllocator,proto3" json:"address_allocator,omitempty"`
	// IPV6 Address Auto Configuration
	//
	// x-displayName: "IPV6 Auto Configuration"
	// IPV6 Addrss Auto configuration parameters
	Ipv6AutoConfig *IPV6AutoConfigType `protobuf:"bytes,39,opt,name=ipv6_auto_config,json=ipv6AutoConfig,proto3" json:"ipv6_auto_config,omitempty"`
	// DHCP server parameters
	//
	// x-displayName: "DHCP server parameters"
	// DHCP server parameters
	DhcpServerParams *DHCPServerParametersType `protobuf:"bytes,28,opt,name=dhcp_server_params,json=dhcpServerParams,proto3" json:"dhcp_server_params,omitempty"`
	// Network Config Method
	//
	// x-displayName: "Network Config Method"
	// Configuration to pick network from interface or fleet
	NetworkConfig InterfaceNetworkType `protobuf:"varint,29,opt,name=network_config,json=networkConfig,proto3,enum=ves.io.schema.network_interface.InterfaceNetworkType" json:"network_config,omitempty"`
	// Site:Node to IP mapping
	//
	// x-displayName: "Site:Node to IP Mapping"
	// Map of Site:Node to IP address offset. Key:Node, Value:Map
	// Value of 10.1.1.5 with network prefix 24, offset is 0.0.0.5
	InterfaceIpMap map[string]string `protobuf:"bytes,30,rep,name=interface_ip_map,json=interfaceIpMap,proto3" json:"interface_ip_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Primary Interface
	//
	// x-displayName: "Primary Interface"
	// This interface is primary interface
	IsPrimary bool `protobuf:"varint,31,opt,name=is_primary,json=isPrimary,proto3" json:"is_primary,omitempty"`
	// Select Link Quality Monitoring configuration
	//
	// x-displayName: "Select Link Quality Monitoring configuration"
	// Link Quality Monitoring configuration for a network interface. When enabled, VER will send probes
	// on the network interface to monitor quality of the link. Links are assigned a score based on the result of probes.
	//
	// Types that are valid to be assigned to MonitoringChoice:
	//	*GlobalSpecType_MonitorDisabled
	//	*GlobalSpecType_Monitor
	MonitoringChoice isGlobalSpecType_MonitoringChoice `protobuf_oneof:"monitoring_choice"`
	// Ipv6 Static IP
	//
	// x-displayName: "IPv6 Static IP"
	// Configure IPv6 subnet to be used.
	Ipv6StaticAddresses *StaticIPParametersType `protobuf:"bytes,35,opt,name=ipv6_static_addresses,json=ipv6StaticAddresses,proto3" json:"ipv6_static_addresses,omitempty"`
	// Ipv4 Static IP
	//
	// x-displayName: "IPv4 Static IP"
	// Configure IPv4 subnet to be used.
	Ipv4StaticAddresses *StaticIPParametersType `protobuf:"bytes,37,opt,name=ipv4_static_addresses,json=ipv4StaticAddresses,proto3" json:"ipv4_static_addresses,omitempty"`
	// Vhost Interface
	//
	// x-displayName: "Vhost Interface"
	// Configuration for vhost interface corresponding to the network interface
	VhostType *VhostInterfaceType `protobuf:"bytes,36,opt,name=vhost_type,json=vhostType,proto3" json:"vhost_type,omitempty"`
	// Segmentation status
	//
	// x-displayName: "Segmentation Status"
	// Configures if segmentation is enabled on interface. Segment for a packet are classified
	// from source-ip address
	//
	// Types that are valid to be assigned to SegmentMultiplexing:
	//	*GlobalSpecType_SegmentationDisabled
	//	*GlobalSpecType_SegmentationEnabled
	SegmentMultiplexing isGlobalSpecType_SegmentMultiplexing `protobuf_oneof:"segment_multiplexing"`
	// Interface Config Type
	//
	// x-displayName: "Interface Config Type"
	// x-required
	// Select the interface configuration type
	//
	// Types that are valid to be assigned to InterfaceChoice:
	//	*GlobalSpecType_DedicatedInterface
	//	*GlobalSpecType_EthernetInterface
	//	*GlobalSpecType_TunnelInterface
	//	*GlobalSpecType_Legacy
	//	*GlobalSpecType_DedicatedManagementInterface
	//	*GlobalSpecType_LoopbackInterface
	//	*GlobalSpecType_Layer2Interface
	InterfaceChoice isGlobalSpecType_InterfaceChoice `protobuf_oneof:"interface_choice"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{32}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_MonitoringChoice interface {
	isGlobalSpecType_MonitoringChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_SegmentMultiplexing interface {
	isGlobalSpecType_SegmentMultiplexing()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGlobalSpecType_InterfaceChoice interface {
	isGlobalSpecType_InterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_MonitorDisabled struct {
	MonitorDisabled *schema.Empty `protobuf:"bytes,33,opt,name=monitor_disabled,json=monitorDisabled,proto3,oneof" json:"monitor_disabled,omitempty"`
}
type GlobalSpecType_Monitor struct {
	Monitor *LinkQualityMonitorConfig `protobuf:"bytes,34,opt,name=monitor,proto3,oneof" json:"monitor,omitempty"`
}
type GlobalSpecType_SegmentationDisabled struct {
	SegmentationDisabled *schema.Empty `protobuf:"bytes,41,opt,name=segmentation_disabled,json=segmentationDisabled,proto3,oneof" json:"segmentation_disabled,omitempty"`
}
type GlobalSpecType_SegmentationEnabled struct {
	SegmentationEnabled *schema.Empty `protobuf:"bytes,42,opt,name=segmentation_enabled,json=segmentationEnabled,proto3,oneof" json:"segmentation_enabled,omitempty"`
}
type GlobalSpecType_DedicatedInterface struct {
	DedicatedInterface *DedicatedInterfaceType `protobuf:"bytes,1001,opt,name=dedicated_interface,json=dedicatedInterface,proto3,oneof" json:"dedicated_interface,omitempty"`
}
type GlobalSpecType_EthernetInterface struct {
	EthernetInterface *EthernetInterfaceType `protobuf:"bytes,1002,opt,name=ethernet_interface,json=ethernetInterface,proto3,oneof" json:"ethernet_interface,omitempty"`
}
type GlobalSpecType_TunnelInterface struct {
	TunnelInterface *TunnelInterfaceType `protobuf:"bytes,1003,opt,name=tunnel_interface,json=tunnelInterface,proto3,oneof" json:"tunnel_interface,omitempty"`
}
type GlobalSpecType_Legacy struct {
	Legacy *schema.Empty `protobuf:"bytes,1004,opt,name=legacy,proto3,oneof" json:"legacy,omitempty"`
}
type GlobalSpecType_DedicatedManagementInterface struct {
	DedicatedManagementInterface *DedicatedManagementInterfaceType `protobuf:"bytes,1005,opt,name=dedicated_management_interface,json=dedicatedManagementInterface,proto3,oneof" json:"dedicated_management_interface,omitempty"`
}
type GlobalSpecType_LoopbackInterface struct {
	LoopbackInterface *LoopbackInterfaceType `protobuf:"bytes,1006,opt,name=loopback_interface,json=loopbackInterface,proto3,oneof" json:"loopback_interface,omitempty"`
}
type GlobalSpecType_Layer2Interface struct {
	Layer2Interface *Layer2InterfaceType `protobuf:"bytes,1008,opt,name=layer2_interface,json=layer2Interface,proto3,oneof" json:"layer2_interface,omitempty"`
}

func (*GlobalSpecType_MonitorDisabled) isGlobalSpecType_MonitoringChoice()             {}
func (*GlobalSpecType_Monitor) isGlobalSpecType_MonitoringChoice()                     {}
func (*GlobalSpecType_SegmentationDisabled) isGlobalSpecType_SegmentMultiplexing()     {}
func (*GlobalSpecType_SegmentationEnabled) isGlobalSpecType_SegmentMultiplexing()      {}
func (*GlobalSpecType_DedicatedInterface) isGlobalSpecType_InterfaceChoice()           {}
func (*GlobalSpecType_EthernetInterface) isGlobalSpecType_InterfaceChoice()            {}
func (*GlobalSpecType_TunnelInterface) isGlobalSpecType_InterfaceChoice()              {}
func (*GlobalSpecType_Legacy) isGlobalSpecType_InterfaceChoice()                       {}
func (*GlobalSpecType_DedicatedManagementInterface) isGlobalSpecType_InterfaceChoice() {}
func (*GlobalSpecType_LoopbackInterface) isGlobalSpecType_InterfaceChoice()            {}
func (*GlobalSpecType_Layer2Interface) isGlobalSpecType_InterfaceChoice()              {}

func (m *GlobalSpecType) GetMonitoringChoice() isGlobalSpecType_MonitoringChoice {
	if m != nil {
		return m.MonitoringChoice
	}
	return nil
}
func (m *GlobalSpecType) GetSegmentMultiplexing() isGlobalSpecType_SegmentMultiplexing {
	if m != nil {
		return m.SegmentMultiplexing
	}
	return nil
}
func (m *GlobalSpecType) GetInterfaceChoice() isGlobalSpecType_InterfaceChoice {
	if m != nil {
		return m.InterfaceChoice
	}
	return nil
}

func (m *GlobalSpecType) GetType() NetworkInterfaceType {
	if m != nil {
		return m.Type
	}
	return NETWORK_INTERFACE_ETHERNET
}

func (m *GlobalSpecType) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *GlobalSpecType) GetVirtualNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.VirtualNetwork
	}
	return nil
}

func (m *GlobalSpecType) GetDhcpAddress() NetworkInterfaceDHCP {
	if m != nil {
		return m.DhcpAddress
	}
	return NETWORK_INTERFACE_DHCP_DISABLE
}

func (m *GlobalSpecType) GetStaticAddresses() []*schema.Ipv4SubnetType {
	if m != nil {
		return m.StaticAddresses
	}
	return nil
}

func (m *GlobalSpecType) GetStaticIpv6Addresses() []*schema.Ipv6SubnetType {
	if m != nil {
		return m.StaticIpv6Addresses
	}
	return nil
}

func (m *GlobalSpecType) GetDefaultGateway() *NetworkInterfaceDFGW {
	if m != nil {
		return m.DefaultGateway
	}
	return nil
}

func (m *GlobalSpecType) GetDNSServer() *NetworkInterfaceDNS {
	if m != nil {
		return m.DNSServer
	}
	return nil
}

func (m *GlobalSpecType) GetDHCPServer() NetworkInterfaceDHCPServer {
	if m != nil {
		return m.DHCPServer
	}
	return NETWORK_INTERFACE_DHCP_SERVER_DISABLE
}

func (m *GlobalSpecType) GetVlanTagging() NetworkInterfaceVLANTagging {
	if m != nil {
		return m.VlanTagging
	}
	return NETWORK_INTERFACE_VLAN_TAGGING_DISABLE
}

func (m *GlobalSpecType) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func (m *GlobalSpecType) GetParentNetworkInterface() []*schema.ObjectRefType {
	if m != nil {
		return m.ParentNetworkInterface
	}
	return nil
}

func (m *GlobalSpecType) GetVlanTag() uint32 {
	if m != nil {
		return m.VlanTag
	}
	return 0
}

func (m *GlobalSpecType) GetTunnel() *NetworkInterfaceTunnel {
	if m != nil {
		return m.Tunnel
	}
	return nil
}

func (m *GlobalSpecType) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *GlobalSpecType) GetAddressAllocator() []*schema.ObjectRefType {
	if m != nil {
		return m.AddressAllocator
	}
	return nil
}

func (m *GlobalSpecType) GetIpv6AutoConfig() *IPV6AutoConfigType {
	if m != nil {
		return m.Ipv6AutoConfig
	}
	return nil
}

func (m *GlobalSpecType) GetDhcpServerParams() *DHCPServerParametersType {
	if m != nil {
		return m.DhcpServerParams
	}
	return nil
}

func (m *GlobalSpecType) GetNetworkConfig() InterfaceNetworkType {
	if m != nil {
		return m.NetworkConfig
	}
	return NETWORK_INTERFACE_NETWORK_REF
}

func (m *GlobalSpecType) GetInterfaceIpMap() map[string]string {
	if m != nil {
		return m.InterfaceIpMap
	}
	return nil
}

func (m *GlobalSpecType) GetIsPrimary() bool {
	if m != nil {
		return m.IsPrimary
	}
	return false
}

func (m *GlobalSpecType) GetMonitorDisabled() *schema.Empty {
	if x, ok := m.GetMonitoringChoice().(*GlobalSpecType_MonitorDisabled); ok {
		return x.MonitorDisabled
	}
	return nil
}

func (m *GlobalSpecType) GetMonitor() *LinkQualityMonitorConfig {
	if x, ok := m.GetMonitoringChoice().(*GlobalSpecType_Monitor); ok {
		return x.Monitor
	}
	return nil
}

func (m *GlobalSpecType) GetIpv6StaticAddresses() *StaticIPParametersType {
	if m != nil {
		return m.Ipv6StaticAddresses
	}
	return nil
}

func (m *GlobalSpecType) GetIpv4StaticAddresses() *StaticIPParametersType {
	if m != nil {
		return m.Ipv4StaticAddresses
	}
	return nil
}

func (m *GlobalSpecType) GetVhostType() *VhostInterfaceType {
	if m != nil {
		return m.VhostType
	}
	return nil
}

func (m *GlobalSpecType) GetSegmentationDisabled() *schema.Empty {
	if x, ok := m.GetSegmentMultiplexing().(*GlobalSpecType_SegmentationDisabled); ok {
		return x.SegmentationDisabled
	}
	return nil
}

func (m *GlobalSpecType) GetSegmentationEnabled() *schema.Empty {
	if x, ok := m.GetSegmentMultiplexing().(*GlobalSpecType_SegmentationEnabled); ok {
		return x.SegmentationEnabled
	}
	return nil
}

func (m *GlobalSpecType) GetDedicatedInterface() *DedicatedInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*GlobalSpecType_DedicatedInterface); ok {
		return x.DedicatedInterface
	}
	return nil
}

func (m *GlobalSpecType) GetEthernetInterface() *EthernetInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*GlobalSpecType_EthernetInterface); ok {
		return x.EthernetInterface
	}
	return nil
}

func (m *GlobalSpecType) GetTunnelInterface() *TunnelInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*GlobalSpecType_TunnelInterface); ok {
		return x.TunnelInterface
	}
	return nil
}

func (m *GlobalSpecType) GetLegacy() *schema.Empty {
	if x, ok := m.GetInterfaceChoice().(*GlobalSpecType_Legacy); ok {
		return x.Legacy
	}
	return nil
}

func (m *GlobalSpecType) GetDedicatedManagementInterface() *DedicatedManagementInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*GlobalSpecType_DedicatedManagementInterface); ok {
		return x.DedicatedManagementInterface
	}
	return nil
}

func (m *GlobalSpecType) GetLoopbackInterface() *LoopbackInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*GlobalSpecType_LoopbackInterface); ok {
		return x.LoopbackInterface
	}
	return nil
}

func (m *GlobalSpecType) GetLayer2Interface() *Layer2InterfaceType {
	if x, ok := m.GetInterfaceChoice().(*GlobalSpecType_Layer2Interface); ok {
		return x.Layer2Interface
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_MonitorDisabled)(nil),
		(*GlobalSpecType_Monitor)(nil),
		(*GlobalSpecType_SegmentationDisabled)(nil),
		(*GlobalSpecType_SegmentationEnabled)(nil),
		(*GlobalSpecType_DedicatedInterface)(nil),
		(*GlobalSpecType_EthernetInterface)(nil),
		(*GlobalSpecType_TunnelInterface)(nil),
		(*GlobalSpecType_Legacy)(nil),
		(*GlobalSpecType_DedicatedManagementInterface)(nil),
		(*GlobalSpecType_LoopbackInterface)(nil),
		(*GlobalSpecType_Layer2Interface)(nil),
	}
}

// Create network interface
//
// x-displayName: "Create Network Interface"
// Network interface represents configuration of a network device.
// It is created by users in system namespace.
type CreateSpecType struct {
	// Interface Config Type
	//
	// x-displayName: "Interface Config Type"
	// x-required
	// Select the interface configuration type
	//
	// Types that are valid to be assigned to InterfaceChoice:
	//	*CreateSpecType_DedicatedInterface
	//	*CreateSpecType_EthernetInterface
	//	*CreateSpecType_TunnelInterface
	//	*CreateSpecType_LegacyInterface
	//	*CreateSpecType_DedicatedManagementInterface
	//	*CreateSpecType_Layer2Interface
	InterfaceChoice isCreateSpecType_InterfaceChoice `protobuf_oneof:"interface_choice"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{33}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_InterfaceChoice interface {
	isCreateSpecType_InterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_DedicatedInterface struct {
	DedicatedInterface *DedicatedInterfaceType `protobuf:"bytes,18,opt,name=dedicated_interface,json=dedicatedInterface,proto3,oneof" json:"dedicated_interface,omitempty"`
}
type CreateSpecType_EthernetInterface struct {
	EthernetInterface *EthernetInterfaceType `protobuf:"bytes,19,opt,name=ethernet_interface,json=ethernetInterface,proto3,oneof" json:"ethernet_interface,omitempty"`
}
type CreateSpecType_TunnelInterface struct {
	TunnelInterface *TunnelInterfaceType `protobuf:"bytes,20,opt,name=tunnel_interface,json=tunnelInterface,proto3,oneof" json:"tunnel_interface,omitempty"`
}
type CreateSpecType_LegacyInterface struct {
	LegacyInterface *LegacyInterfaceType `protobuf:"bytes,21,opt,name=legacy_interface,json=legacyInterface,proto3,oneof" json:"legacy_interface,omitempty"`
}
type CreateSpecType_DedicatedManagementInterface struct {
	DedicatedManagementInterface *DedicatedManagementInterfaceType `protobuf:"bytes,22,opt,name=dedicated_management_interface,json=dedicatedManagementInterface,proto3,oneof" json:"dedicated_management_interface,omitempty"`
}
type CreateSpecType_Layer2Interface struct {
	Layer2Interface *Layer2InterfaceType `protobuf:"bytes,24,opt,name=layer2_interface,json=layer2Interface,proto3,oneof" json:"layer2_interface,omitempty"`
}

func (*CreateSpecType_DedicatedInterface) isCreateSpecType_InterfaceChoice()           {}
func (*CreateSpecType_EthernetInterface) isCreateSpecType_InterfaceChoice()            {}
func (*CreateSpecType_TunnelInterface) isCreateSpecType_InterfaceChoice()              {}
func (*CreateSpecType_LegacyInterface) isCreateSpecType_InterfaceChoice()              {}
func (*CreateSpecType_DedicatedManagementInterface) isCreateSpecType_InterfaceChoice() {}
func (*CreateSpecType_Layer2Interface) isCreateSpecType_InterfaceChoice()              {}

func (m *CreateSpecType) GetInterfaceChoice() isCreateSpecType_InterfaceChoice {
	if m != nil {
		return m.InterfaceChoice
	}
	return nil
}

func (m *CreateSpecType) GetDedicatedInterface() *DedicatedInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*CreateSpecType_DedicatedInterface); ok {
		return x.DedicatedInterface
	}
	return nil
}

func (m *CreateSpecType) GetEthernetInterface() *EthernetInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*CreateSpecType_EthernetInterface); ok {
		return x.EthernetInterface
	}
	return nil
}

func (m *CreateSpecType) GetTunnelInterface() *TunnelInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*CreateSpecType_TunnelInterface); ok {
		return x.TunnelInterface
	}
	return nil
}

func (m *CreateSpecType) GetLegacyInterface() *LegacyInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*CreateSpecType_LegacyInterface); ok {
		return x.LegacyInterface
	}
	return nil
}

func (m *CreateSpecType) GetDedicatedManagementInterface() *DedicatedManagementInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*CreateSpecType_DedicatedManagementInterface); ok {
		return x.DedicatedManagementInterface
	}
	return nil
}

func (m *CreateSpecType) GetLayer2Interface() *Layer2InterfaceType {
	if x, ok := m.GetInterfaceChoice().(*CreateSpecType_Layer2Interface); ok {
		return x.Layer2Interface
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_DedicatedInterface)(nil),
		(*CreateSpecType_EthernetInterface)(nil),
		(*CreateSpecType_TunnelInterface)(nil),
		(*CreateSpecType_LegacyInterface)(nil),
		(*CreateSpecType_DedicatedManagementInterface)(nil),
		(*CreateSpecType_Layer2Interface)(nil),
	}
}

// Replace network interface
//
// x-displayName: "Replace Network Interface"
// Network interface represents configuration of a network device.
// Replace network interface will replace the contents of given network interface object.
type ReplaceSpecType struct {
	// Interface Config Type
	//
	// x-displayName: "Interface Config Type"
	// x-required
	// Select the interface configuration type
	//
	// Types that are valid to be assigned to InterfaceChoice:
	//	*ReplaceSpecType_DedicatedInterface
	//	*ReplaceSpecType_EthernetInterface
	//	*ReplaceSpecType_TunnelInterface
	//	*ReplaceSpecType_LegacyInterface
	//	*ReplaceSpecType_DedicatedManagementInterface
	//	*ReplaceSpecType_Layer2Interface
	InterfaceChoice isReplaceSpecType_InterfaceChoice `protobuf_oneof:"interface_choice"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{34}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_InterfaceChoice interface {
	isReplaceSpecType_InterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_DedicatedInterface struct {
	DedicatedInterface *DedicatedInterfaceType `protobuf:"bytes,18,opt,name=dedicated_interface,json=dedicatedInterface,proto3,oneof" json:"dedicated_interface,omitempty"`
}
type ReplaceSpecType_EthernetInterface struct {
	EthernetInterface *EthernetInterfaceType `protobuf:"bytes,19,opt,name=ethernet_interface,json=ethernetInterface,proto3,oneof" json:"ethernet_interface,omitempty"`
}
type ReplaceSpecType_TunnelInterface struct {
	TunnelInterface *TunnelInterfaceType `protobuf:"bytes,20,opt,name=tunnel_interface,json=tunnelInterface,proto3,oneof" json:"tunnel_interface,omitempty"`
}
type ReplaceSpecType_LegacyInterface struct {
	LegacyInterface *LegacyInterfaceType `protobuf:"bytes,21,opt,name=legacy_interface,json=legacyInterface,proto3,oneof" json:"legacy_interface,omitempty"`
}
type ReplaceSpecType_DedicatedManagementInterface struct {
	DedicatedManagementInterface *DedicatedManagementInterfaceType `protobuf:"bytes,22,opt,name=dedicated_management_interface,json=dedicatedManagementInterface,proto3,oneof" json:"dedicated_management_interface,omitempty"`
}
type ReplaceSpecType_Layer2Interface struct {
	Layer2Interface *Layer2InterfaceType `protobuf:"bytes,24,opt,name=layer2_interface,json=layer2Interface,proto3,oneof" json:"layer2_interface,omitempty"`
}

func (*ReplaceSpecType_DedicatedInterface) isReplaceSpecType_InterfaceChoice()           {}
func (*ReplaceSpecType_EthernetInterface) isReplaceSpecType_InterfaceChoice()            {}
func (*ReplaceSpecType_TunnelInterface) isReplaceSpecType_InterfaceChoice()              {}
func (*ReplaceSpecType_LegacyInterface) isReplaceSpecType_InterfaceChoice()              {}
func (*ReplaceSpecType_DedicatedManagementInterface) isReplaceSpecType_InterfaceChoice() {}
func (*ReplaceSpecType_Layer2Interface) isReplaceSpecType_InterfaceChoice()              {}

func (m *ReplaceSpecType) GetInterfaceChoice() isReplaceSpecType_InterfaceChoice {
	if m != nil {
		return m.InterfaceChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetDedicatedInterface() *DedicatedInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*ReplaceSpecType_DedicatedInterface); ok {
		return x.DedicatedInterface
	}
	return nil
}

func (m *ReplaceSpecType) GetEthernetInterface() *EthernetInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*ReplaceSpecType_EthernetInterface); ok {
		return x.EthernetInterface
	}
	return nil
}

func (m *ReplaceSpecType) GetTunnelInterface() *TunnelInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*ReplaceSpecType_TunnelInterface); ok {
		return x.TunnelInterface
	}
	return nil
}

func (m *ReplaceSpecType) GetLegacyInterface() *LegacyInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*ReplaceSpecType_LegacyInterface); ok {
		return x.LegacyInterface
	}
	return nil
}

func (m *ReplaceSpecType) GetDedicatedManagementInterface() *DedicatedManagementInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*ReplaceSpecType_DedicatedManagementInterface); ok {
		return x.DedicatedManagementInterface
	}
	return nil
}

func (m *ReplaceSpecType) GetLayer2Interface() *Layer2InterfaceType {
	if x, ok := m.GetInterfaceChoice().(*ReplaceSpecType_Layer2Interface); ok {
		return x.Layer2Interface
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_DedicatedInterface)(nil),
		(*ReplaceSpecType_EthernetInterface)(nil),
		(*ReplaceSpecType_TunnelInterface)(nil),
		(*ReplaceSpecType_LegacyInterface)(nil),
		(*ReplaceSpecType_DedicatedManagementInterface)(nil),
		(*ReplaceSpecType_Layer2Interface)(nil),
	}
}

// Get network interface
//
// x-displayName: "Get Network Interface"
// Get network interface from system namespace
type GetSpecType struct {
	Type                   NetworkInterfaceType        `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceType" json:"type,omitempty"`
	Mtu                    uint32                      `protobuf:"varint,3,opt,name=mtu,proto3" json:"mtu,omitempty"`
	VirtualNetwork         []*schema.ObjectRefType     `protobuf:"bytes,4,rep,name=virtual_network,json=virtualNetwork,proto3" json:"virtual_network,omitempty"`
	DhcpAddress            NetworkInterfaceDHCP        `protobuf:"varint,5,opt,name=dhcp_address,json=dhcpAddress,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceDHCP" json:"dhcp_address,omitempty"`
	StaticAddresses        []*schema.Ipv4SubnetType    `protobuf:"bytes,6,rep,name=static_addresses,json=staticAddresses,proto3" json:"static_addresses,omitempty"`
	DefaultGateway         *NetworkInterfaceDFGW       `protobuf:"bytes,7,opt,name=default_gateway,json=defaultGateway,proto3" json:"default_gateway,omitempty"`
	DNSServer              *NetworkInterfaceDNS        `protobuf:"bytes,8,opt,name=DNS_server,json=DNSServer,proto3" json:"DNS_server,omitempty"`
	DHCPServer             NetworkInterfaceDHCPServer  `protobuf:"varint,9,opt,name=DHCP_server,json=DHCPServer,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceDHCPServer" json:"DHCP_server,omitempty"`
	VlanTagging            NetworkInterfaceVLANTagging `protobuf:"varint,10,opt,name=vlan_tagging,json=vlanTagging,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceVLANTagging" json:"vlan_tagging,omitempty"`
	DeviceName             string                      `protobuf:"bytes,11,opt,name=device_name,json=deviceName,proto3" json:"device_name,omitempty"`
	ParentNetworkInterface []*schema.ObjectRefType     `protobuf:"bytes,12,rep,name=parent_network_interface,json=parentNetworkInterface,proto3" json:"parent_network_interface,omitempty"`
	VlanTag                uint32                      `protobuf:"varint,13,opt,name=vlan_tag,json=vlanTag,proto3" json:"vlan_tag,omitempty"`
	Tunnel                 *NetworkInterfaceTunnel     `protobuf:"bytes,14,opt,name=tunnel,proto3" json:"tunnel,omitempty"`
	Priority               uint32                      `protobuf:"varint,15,opt,name=priority,proto3" json:"priority,omitempty"`
	AddressAllocator       []*schema.ObjectRefType     `protobuf:"bytes,16,rep,name=address_allocator,json=addressAllocator,proto3" json:"address_allocator,omitempty"`
	InterfaceIpMap         map[string]string           `protobuf:"bytes,30,rep,name=interface_ip_map,json=interfaceIpMap,proto3" json:"interface_ip_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	IsPrimary              bool                        `protobuf:"varint,31,opt,name=is_primary,json=isPrimary,proto3" json:"is_primary,omitempty"`
	// Types that are valid to be assigned to MonitoringChoice:
	//	*GetSpecType_MonitorDisabled
	//	*GetSpecType_Monitor
	MonitoringChoice isGetSpecType_MonitoringChoice `protobuf_oneof:"monitoring_choice"`
	// Interface Config Type
	//
	// x-displayName: "Interface Config Type"
	// x-required
	// Select the interface configuration type
	//
	// Types that are valid to be assigned to InterfaceChoice:
	//	*GetSpecType_DedicatedInterface
	//	*GetSpecType_EthernetInterface
	//	*GetSpecType_TunnelInterface
	//	*GetSpecType_LegacyInterface
	//	*GetSpecType_DedicatedManagementInterface
	//	*GetSpecType_Layer2Interface
	InterfaceChoice isGetSpecType_InterfaceChoice `protobuf_oneof:"interface_choice"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{35}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_MonitoringChoice interface {
	isGetSpecType_MonitoringChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isGetSpecType_InterfaceChoice interface {
	isGetSpecType_InterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_MonitorDisabled struct {
	MonitorDisabled *schema.Empty `protobuf:"bytes,33,opt,name=monitor_disabled,json=monitorDisabled,proto3,oneof" json:"monitor_disabled,omitempty"`
}
type GetSpecType_Monitor struct {
	Monitor *LinkQualityMonitorConfig `protobuf:"bytes,34,opt,name=monitor,proto3,oneof" json:"monitor,omitempty"`
}
type GetSpecType_DedicatedInterface struct {
	DedicatedInterface *DedicatedInterfaceType `protobuf:"bytes,18,opt,name=dedicated_interface,json=dedicatedInterface,proto3,oneof" json:"dedicated_interface,omitempty"`
}
type GetSpecType_EthernetInterface struct {
	EthernetInterface *EthernetInterfaceType `protobuf:"bytes,19,opt,name=ethernet_interface,json=ethernetInterface,proto3,oneof" json:"ethernet_interface,omitempty"`
}
type GetSpecType_TunnelInterface struct {
	TunnelInterface *TunnelInterfaceType `protobuf:"bytes,20,opt,name=tunnel_interface,json=tunnelInterface,proto3,oneof" json:"tunnel_interface,omitempty"`
}
type GetSpecType_LegacyInterface struct {
	LegacyInterface *LegacyInterfaceType `protobuf:"bytes,21,opt,name=legacy_interface,json=legacyInterface,proto3,oneof" json:"legacy_interface,omitempty"`
}
type GetSpecType_DedicatedManagementInterface struct {
	DedicatedManagementInterface *DedicatedManagementInterfaceType `protobuf:"bytes,22,opt,name=dedicated_management_interface,json=dedicatedManagementInterface,proto3,oneof" json:"dedicated_management_interface,omitempty"`
}
type GetSpecType_Layer2Interface struct {
	Layer2Interface *Layer2InterfaceType `protobuf:"bytes,24,opt,name=layer2_interface,json=layer2Interface,proto3,oneof" json:"layer2_interface,omitempty"`
}

func (*GetSpecType_MonitorDisabled) isGetSpecType_MonitoringChoice()             {}
func (*GetSpecType_Monitor) isGetSpecType_MonitoringChoice()                     {}
func (*GetSpecType_DedicatedInterface) isGetSpecType_InterfaceChoice()           {}
func (*GetSpecType_EthernetInterface) isGetSpecType_InterfaceChoice()            {}
func (*GetSpecType_TunnelInterface) isGetSpecType_InterfaceChoice()              {}
func (*GetSpecType_LegacyInterface) isGetSpecType_InterfaceChoice()              {}
func (*GetSpecType_DedicatedManagementInterface) isGetSpecType_InterfaceChoice() {}
func (*GetSpecType_Layer2Interface) isGetSpecType_InterfaceChoice()              {}

func (m *GetSpecType) GetMonitoringChoice() isGetSpecType_MonitoringChoice {
	if m != nil {
		return m.MonitoringChoice
	}
	return nil
}
func (m *GetSpecType) GetInterfaceChoice() isGetSpecType_InterfaceChoice {
	if m != nil {
		return m.InterfaceChoice
	}
	return nil
}

func (m *GetSpecType) GetType() NetworkInterfaceType {
	if m != nil {
		return m.Type
	}
	return NETWORK_INTERFACE_ETHERNET
}

func (m *GetSpecType) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *GetSpecType) GetVirtualNetwork() []*schema.ObjectRefType {
	if m != nil {
		return m.VirtualNetwork
	}
	return nil
}

func (m *GetSpecType) GetDhcpAddress() NetworkInterfaceDHCP {
	if m != nil {
		return m.DhcpAddress
	}
	return NETWORK_INTERFACE_DHCP_DISABLE
}

func (m *GetSpecType) GetStaticAddresses() []*schema.Ipv4SubnetType {
	if m != nil {
		return m.StaticAddresses
	}
	return nil
}

func (m *GetSpecType) GetDefaultGateway() *NetworkInterfaceDFGW {
	if m != nil {
		return m.DefaultGateway
	}
	return nil
}

func (m *GetSpecType) GetDNSServer() *NetworkInterfaceDNS {
	if m != nil {
		return m.DNSServer
	}
	return nil
}

func (m *GetSpecType) GetDHCPServer() NetworkInterfaceDHCPServer {
	if m != nil {
		return m.DHCPServer
	}
	return NETWORK_INTERFACE_DHCP_SERVER_DISABLE
}

func (m *GetSpecType) GetVlanTagging() NetworkInterfaceVLANTagging {
	if m != nil {
		return m.VlanTagging
	}
	return NETWORK_INTERFACE_VLAN_TAGGING_DISABLE
}

func (m *GetSpecType) GetDeviceName() string {
	if m != nil {
		return m.DeviceName
	}
	return ""
}

func (m *GetSpecType) GetParentNetworkInterface() []*schema.ObjectRefType {
	if m != nil {
		return m.ParentNetworkInterface
	}
	return nil
}

func (m *GetSpecType) GetVlanTag() uint32 {
	if m != nil {
		return m.VlanTag
	}
	return 0
}

func (m *GetSpecType) GetTunnel() *NetworkInterfaceTunnel {
	if m != nil {
		return m.Tunnel
	}
	return nil
}

func (m *GetSpecType) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *GetSpecType) GetAddressAllocator() []*schema.ObjectRefType {
	if m != nil {
		return m.AddressAllocator
	}
	return nil
}

func (m *GetSpecType) GetInterfaceIpMap() map[string]string {
	if m != nil {
		return m.InterfaceIpMap
	}
	return nil
}

func (m *GetSpecType) GetIsPrimary() bool {
	if m != nil {
		return m.IsPrimary
	}
	return false
}

func (m *GetSpecType) GetMonitorDisabled() *schema.Empty {
	if x, ok := m.GetMonitoringChoice().(*GetSpecType_MonitorDisabled); ok {
		return x.MonitorDisabled
	}
	return nil
}

func (m *GetSpecType) GetMonitor() *LinkQualityMonitorConfig {
	if x, ok := m.GetMonitoringChoice().(*GetSpecType_Monitor); ok {
		return x.Monitor
	}
	return nil
}

func (m *GetSpecType) GetDedicatedInterface() *DedicatedInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*GetSpecType_DedicatedInterface); ok {
		return x.DedicatedInterface
	}
	return nil
}

func (m *GetSpecType) GetEthernetInterface() *EthernetInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*GetSpecType_EthernetInterface); ok {
		return x.EthernetInterface
	}
	return nil
}

func (m *GetSpecType) GetTunnelInterface() *TunnelInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*GetSpecType_TunnelInterface); ok {
		return x.TunnelInterface
	}
	return nil
}

func (m *GetSpecType) GetLegacyInterface() *LegacyInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*GetSpecType_LegacyInterface); ok {
		return x.LegacyInterface
	}
	return nil
}

func (m *GetSpecType) GetDedicatedManagementInterface() *DedicatedManagementInterfaceType {
	if x, ok := m.GetInterfaceChoice().(*GetSpecType_DedicatedManagementInterface); ok {
		return x.DedicatedManagementInterface
	}
	return nil
}

func (m *GetSpecType) GetLayer2Interface() *Layer2InterfaceType {
	if x, ok := m.GetInterfaceChoice().(*GetSpecType_Layer2Interface); ok {
		return x.Layer2Interface
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_MonitorDisabled)(nil),
		(*GetSpecType_Monitor)(nil),
		(*GetSpecType_DedicatedInterface)(nil),
		(*GetSpecType_EthernetInterface)(nil),
		(*GetSpecType_TunnelInterface)(nil),
		(*GetSpecType_LegacyInterface)(nil),
		(*GetSpecType_DedicatedManagementInterface)(nil),
		(*GetSpecType_Layer2Interface)(nil),
	}
}

// Network Interface Status
//
// x-displayName: "Status"
// Current Status of the Network interface
type NetworkInterfaceStatus struct {
	// Interface State
	//
	// x-displayName: "Interface State"
	// Current state of the interface
	UpDown NetworkInterfaceUpDown `protobuf:"varint,1,opt,name=up_down,json=upDown,proto3,enum=ves.io.schema.network_interface.NetworkInterfaceUpDown" json:"up_down,omitempty"`
}

func (m *NetworkInterfaceStatus) Reset()      { *m = NetworkInterfaceStatus{} }
func (*NetworkInterfaceStatus) ProtoMessage() {}
func (*NetworkInterfaceStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_4532352236a933ec, []int{36}
}
func (m *NetworkInterfaceStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkInterfaceStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NetworkInterfaceStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkInterfaceStatus.Merge(m, src)
}
func (m *NetworkInterfaceStatus) XXX_Size() int {
	return m.Size()
}
func (m *NetworkInterfaceStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkInterfaceStatus.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkInterfaceStatus proto.InternalMessageInfo

func (m *NetworkInterfaceStatus) GetUpDown() NetworkInterfaceUpDown {
	if m != nil {
		return m.UpDown
	}
	return NETWORK_INTERFACE_ADMINISTRATIVELY_DOWN
}

func init() {
	proto.RegisterEnum("ves.io.schema.network_interface.DHCPPoolSettingType", DHCPPoolSettingType_name, DHCPPoolSettingType_value)
	golang_proto.RegisterEnum("ves.io.schema.network_interface.DHCPPoolSettingType", DHCPPoolSettingType_name, DHCPPoolSettingType_value)
	proto.RegisterEnum("ves.io.schema.network_interface.InterfaceNetworkType", InterfaceNetworkType_name, InterfaceNetworkType_value)
	golang_proto.RegisterEnum("ves.io.schema.network_interface.InterfaceNetworkType", InterfaceNetworkType_name, InterfaceNetworkType_value)
	proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceType", NetworkInterfaceType_name, NetworkInterfaceType_value)
	golang_proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceType", NetworkInterfaceType_name, NetworkInterfaceType_value)
	proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceDHCP", NetworkInterfaceDHCP_name, NetworkInterfaceDHCP_value)
	golang_proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceDHCP", NetworkInterfaceDHCP_name, NetworkInterfaceDHCP_value)
	proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceVLANTagging", NetworkInterfaceVLANTagging_name, NetworkInterfaceVLANTagging_value)
	golang_proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceVLANTagging", NetworkInterfaceVLANTagging_name, NetworkInterfaceVLANTagging_value)
	proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceGatewayMode", NetworkInterfaceGatewayMode_name, NetworkInterfaceGatewayMode_value)
	golang_proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceGatewayMode", NetworkInterfaceGatewayMode_name, NetworkInterfaceGatewayMode_value)
	proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceDNSMode", NetworkInterfaceDNSMode_name, NetworkInterfaceDNSMode_value)
	golang_proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceDNSMode", NetworkInterfaceDNSMode_name, NetworkInterfaceDNSMode_value)
	proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceDHCPServer", NetworkInterfaceDHCPServer_name, NetworkInterfaceDHCPServer_value)
	golang_proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceDHCPServer", NetworkInterfaceDHCPServer_name, NetworkInterfaceDHCPServer_value)
	proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceUpDown", NetworkInterfaceUpDown_name, NetworkInterfaceUpDown_value)
	golang_proto.RegisterEnum("ves.io.schema.network_interface.NetworkInterfaceUpDown", NetworkInterfaceUpDown_name, NetworkInterfaceUpDown_value)
	proto.RegisterType((*NetworkInterfaceDFGW)(nil), "ves.io.schema.network_interface.NetworkInterfaceDFGW")
	golang_proto.RegisterType((*NetworkInterfaceDFGW)(nil), "ves.io.schema.network_interface.NetworkInterfaceDFGW")
	proto.RegisterType((*NetworkInterfaceDNS)(nil), "ves.io.schema.network_interface.NetworkInterfaceDNS")
	golang_proto.RegisterType((*NetworkInterfaceDNS)(nil), "ves.io.schema.network_interface.NetworkInterfaceDNS")
	proto.RegisterType((*NetworkInterfaceTunnel)(nil), "ves.io.schema.network_interface.NetworkInterfaceTunnel")
	golang_proto.RegisterType((*NetworkInterfaceTunnel)(nil), "ves.io.schema.network_interface.NetworkInterfaceTunnel")
	proto.RegisterType((*DHCPPoolType)(nil), "ves.io.schema.network_interface.DHCPPoolType")
	golang_proto.RegisterType((*DHCPPoolType)(nil), "ves.io.schema.network_interface.DHCPPoolType")
	proto.RegisterType((*DHCPIPV6PoolType)(nil), "ves.io.schema.network_interface.DHCPIPV6PoolType")
	golang_proto.RegisterType((*DHCPIPV6PoolType)(nil), "ves.io.schema.network_interface.DHCPIPV6PoolType")
	proto.RegisterType((*DHCPIPV6NetworkType)(nil), "ves.io.schema.network_interface.DHCPIPV6NetworkType")
	golang_proto.RegisterType((*DHCPIPV6NetworkType)(nil), "ves.io.schema.network_interface.DHCPIPV6NetworkType")
	proto.RegisterType((*DHCPNetworkType)(nil), "ves.io.schema.network_interface.DHCPNetworkType")
	golang_proto.RegisterType((*DHCPNetworkType)(nil), "ves.io.schema.network_interface.DHCPNetworkType")
	proto.RegisterType((*DHCPInterfaceIPType)(nil), "ves.io.schema.network_interface.DHCPInterfaceIPType")
	golang_proto.RegisterType((*DHCPInterfaceIPType)(nil), "ves.io.schema.network_interface.DHCPInterfaceIPType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.network_interface.DHCPInterfaceIPType.InterfaceIpMapEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.network_interface.DHCPInterfaceIPType.InterfaceIpMapEntry")
	proto.RegisterType((*DHCPInterfaceIPV6Type)(nil), "ves.io.schema.network_interface.DHCPInterfaceIPV6Type")
	golang_proto.RegisterType((*DHCPInterfaceIPV6Type)(nil), "ves.io.schema.network_interface.DHCPInterfaceIPV6Type")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.network_interface.DHCPInterfaceIPV6Type.InterfaceIpMapEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.network_interface.DHCPInterfaceIPV6Type.InterfaceIpMapEntry")
	proto.RegisterType((*DHCPServerParametersType)(nil), "ves.io.schema.network_interface.DHCPServerParametersType")
	golang_proto.RegisterType((*DHCPServerParametersType)(nil), "ves.io.schema.network_interface.DHCPServerParametersType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.network_interface.DHCPServerParametersType.FixedIpMapEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.network_interface.DHCPServerParametersType.FixedIpMapEntry")
	proto.RegisterType((*IPV6AutoConfigType)(nil), "ves.io.schema.network_interface.IPV6AutoConfigType")
	golang_proto.RegisterType((*IPV6AutoConfigType)(nil), "ves.io.schema.network_interface.IPV6AutoConfigType")
	proto.RegisterType((*IPV6AutoConfigRouterType)(nil), "ves.io.schema.network_interface.IPV6AutoConfigRouterType")
	golang_proto.RegisterType((*IPV6AutoConfigRouterType)(nil), "ves.io.schema.network_interface.IPV6AutoConfigRouterType")
	proto.RegisterType((*IPV6DnsList)(nil), "ves.io.schema.network_interface.IPV6DnsList")
	golang_proto.RegisterType((*IPV6DnsList)(nil), "ves.io.schema.network_interface.IPV6DnsList")
	proto.RegisterType((*IPV6LocalDnsAddress)(nil), "ves.io.schema.network_interface.IPV6LocalDnsAddress")
	golang_proto.RegisterType((*IPV6LocalDnsAddress)(nil), "ves.io.schema.network_interface.IPV6LocalDnsAddress")
	proto.RegisterType((*IPV6DnsConfig)(nil), "ves.io.schema.network_interface.IPV6DnsConfig")
	golang_proto.RegisterType((*IPV6DnsConfig)(nil), "ves.io.schema.network_interface.IPV6DnsConfig")
	proto.RegisterType((*DHCPIPV6StatefulServer)(nil), "ves.io.schema.network_interface.DHCPIPV6StatefulServer")
	golang_proto.RegisterType((*DHCPIPV6StatefulServer)(nil), "ves.io.schema.network_interface.DHCPIPV6StatefulServer")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.network_interface.DHCPIPV6StatefulServer.FixedIpMapEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.network_interface.DHCPIPV6StatefulServer.FixedIpMapEntry")
	proto.RegisterType((*StaticIpParametersNodeType)(nil), "ves.io.schema.network_interface.StaticIpParametersNodeType")
	golang_proto.RegisterType((*StaticIpParametersNodeType)(nil), "ves.io.schema.network_interface.StaticIpParametersNodeType")
	proto.RegisterType((*StaticIpParametersClusterType)(nil), "ves.io.schema.network_interface.StaticIpParametersClusterType")
	golang_proto.RegisterType((*StaticIpParametersClusterType)(nil), "ves.io.schema.network_interface.StaticIpParametersClusterType")
	proto.RegisterMapType((map[string]*StaticIpParametersNodeType)(nil), "ves.io.schema.network_interface.StaticIpParametersClusterType.InterfaceIpMapEntry")
	golang_proto.RegisterMapType((map[string]*StaticIpParametersNodeType)(nil), "ves.io.schema.network_interface.StaticIpParametersClusterType.InterfaceIpMapEntry")
	proto.RegisterType((*StaticIpParametersFleetType)(nil), "ves.io.schema.network_interface.StaticIpParametersFleetType")
	golang_proto.RegisterType((*StaticIpParametersFleetType)(nil), "ves.io.schema.network_interface.StaticIpParametersFleetType")
	proto.RegisterType((*StaticIPParametersType)(nil), "ves.io.schema.network_interface.StaticIPParametersType")
	golang_proto.RegisterType((*StaticIPParametersType)(nil), "ves.io.schema.network_interface.StaticIPParametersType")
	proto.RegisterType((*DedicatedInterfaceType)(nil), "ves.io.schema.network_interface.DedicatedInterfaceType")
	golang_proto.RegisterType((*DedicatedInterfaceType)(nil), "ves.io.schema.network_interface.DedicatedInterfaceType")
	proto.RegisterType((*DedicatedManagementInterfaceType)(nil), "ves.io.schema.network_interface.DedicatedManagementInterfaceType")
	golang_proto.RegisterType((*DedicatedManagementInterfaceType)(nil), "ves.io.schema.network_interface.DedicatedManagementInterfaceType")
	proto.RegisterType((*EthernetInterfaceType)(nil), "ves.io.schema.network_interface.EthernetInterfaceType")
	golang_proto.RegisterType((*EthernetInterfaceType)(nil), "ves.io.schema.network_interface.EthernetInterfaceType")
	proto.RegisterType((*TunnelInterfaceType)(nil), "ves.io.schema.network_interface.TunnelInterfaceType")
	golang_proto.RegisterType((*TunnelInterfaceType)(nil), "ves.io.schema.network_interface.TunnelInterfaceType")
	proto.RegisterType((*LegacyInterfaceType)(nil), "ves.io.schema.network_interface.LegacyInterfaceType")
	golang_proto.RegisterType((*LegacyInterfaceType)(nil), "ves.io.schema.network_interface.LegacyInterfaceType")
	proto.RegisterType((*LoopbackInterfaceType)(nil), "ves.io.schema.network_interface.LoopbackInterfaceType")
	golang_proto.RegisterType((*LoopbackInterfaceType)(nil), "ves.io.schema.network_interface.LoopbackInterfaceType")
	proto.RegisterType((*LinkQualityMonitorConfig)(nil), "ves.io.schema.network_interface.LinkQualityMonitorConfig")
	golang_proto.RegisterType((*LinkQualityMonitorConfig)(nil), "ves.io.schema.network_interface.LinkQualityMonitorConfig")
	proto.RegisterType((*VhostInterfaceType)(nil), "ves.io.schema.network_interface.VhostInterfaceType")
	golang_proto.RegisterType((*VhostInterfaceType)(nil), "ves.io.schema.network_interface.VhostInterfaceType")
	proto.RegisterType((*Layer2VlanInterfaceType)(nil), "ves.io.schema.network_interface.Layer2VlanInterfaceType")
	golang_proto.RegisterType((*Layer2VlanInterfaceType)(nil), "ves.io.schema.network_interface.Layer2VlanInterfaceType")
	proto.RegisterType((*Layer2SloVlanInterfaceType)(nil), "ves.io.schema.network_interface.Layer2SloVlanInterfaceType")
	golang_proto.RegisterType((*Layer2SloVlanInterfaceType)(nil), "ves.io.schema.network_interface.Layer2SloVlanInterfaceType")
	proto.RegisterType((*Layer2SriovInterfaceType)(nil), "ves.io.schema.network_interface.Layer2SriovInterfaceType")
	golang_proto.RegisterType((*Layer2SriovInterfaceType)(nil), "ves.io.schema.network_interface.Layer2SriovInterfaceType")
	proto.RegisterType((*Layer2InterfaceType)(nil), "ves.io.schema.network_interface.Layer2InterfaceType")
	golang_proto.RegisterType((*Layer2InterfaceType)(nil), "ves.io.schema.network_interface.Layer2InterfaceType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.network_interface.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.network_interface.GlobalSpecType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.network_interface.GlobalSpecType.InterfaceIpMapEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.network_interface.GlobalSpecType.InterfaceIpMapEntry")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.network_interface.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.network_interface.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.network_interface.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.network_interface.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.network_interface.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.network_interface.GetSpecType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.network_interface.GetSpecType.InterfaceIpMapEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.network_interface.GetSpecType.InterfaceIpMapEntry")
	proto.RegisterType((*NetworkInterfaceStatus)(nil), "ves.io.schema.network_interface.NetworkInterfaceStatus")
	golang_proto.RegisterType((*NetworkInterfaceStatus)(nil), "ves.io.schema.network_interface.NetworkInterfaceStatus")
}

func init() {
	proto.RegisterFile("ves.io/schema/network_interface/types.proto", fileDescriptor_4532352236a933ec)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/network_interface/types.proto", fileDescriptor_4532352236a933ec)
}

var fileDescriptor_4532352236a933ec = []byte{
	// 6115 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x7d, 0x5b, 0x6c, 0x1b, 0xd9,
	0x79, 0xbf, 0x0e, 0xef, 0xfc, 0xa8, 0xcb, 0x68, 0x24, 0xd9, 0xb4, 0xd6, 0xa6, 0x69, 0xad, 0xaf,
	0xdc, 0xb1, 0x2d, 0x52, 0xb2, 0x2c, 0xd9, 0x9b, 0x8d, 0x49, 0x89, 0x96, 0xa8, 0xc8, 0x94, 0x32,
	0x94, 0xbd, 0xd9, 0xdc, 0x88, 0x11, 0x39, 0xa2, 0x67, 0x4d, 0xce, 0xf0, 0xcf, 0x19, 0xc9, 0x6b,
	0xe0, 0xef, 0x76, 0xb3, 0x28, 0x90, 0xd6, 0x45, 0x2f, 0x68, 0x50, 0x14, 0x58, 0x14, 0xed, 0x43,
	0x0b, 0x34, 0x71, 0x13, 0xa0, 0x0f, 0x2d, 0x5a, 0x74, 0xf4, 0xa0, 0x18, 0x08, 0xb0, 0x0d, 0x50,
	0x40, 0x6f, 0x5d, 0xf4, 0xa1, 0x48, 0xb4, 0x0f, 0xdd, 0x75, 0x9b, 0x66, 0x51, 0xf4, 0x21, 0xd8,
	0x00, 0x4d, 0x71, 0xce, 0x5c, 0x38, 0x1c, 0x0e, 0xa9, 0x91, 0xe4, 0x78, 0xdd, 0x74, 0x5f, 0x46,
	0xe4, 0xcc, 0x77, 0xbe, 0xef, 0x9c, 0xf3, 0x5d, 0xce, 0xef, 0xfb, 0xce, 0x19, 0x0a, 0x5e, 0xd9,
	0xe4, 0xe5, 0x4b, 0x82, 0x74, 0x59, 0x2e, 0xdd, 0xe5, 0x6b, 0xdc, 0x65, 0x91, 0x57, 0xee, 0x4b,
	0x8d, 0x7b, 0x45, 0x41, 0x54, 0xf8, 0xc6, 0x3a, 0x57, 0xe2, 0x2f, 0x2b, 0x0f, 0xea, 0xbc, 0x7c,
	0xa9, 0xde, 0x90, 0x14, 0x89, 0x3e, 0xa9, 0x11, 0x5f, 0xd2, 0x88, 0x2f, 0xb5, 0x11, 0x8f, 0x5e,
	0xac, 0x08, 0xca, 0xdd, 0x8d, 0xb5, 0x4b, 0x25, 0xa9, 0x76, 0xb9, 0x22, 0x55, 0xa4, 0xcb, 0xa4,
	0xdd, 0xda, 0xc6, 0x3a, 0xf9, 0x46, 0xbe, 0x90, 0x4f, 0x1a, 0xbf, 0xd1, 0x93, 0x15, 0x49, 0xaa,
	0x54, 0xf9, 0x26, 0x95, 0x22, 0xd4, 0x78, 0x59, 0xe1, 0x6a, 0x75, 0x9d, 0xe0, 0x68, 0x5b, 0xef,
	0xf4, 0x07, 0x2f, 0xb5, 0x3e, 0x90, 0xea, 0x8a, 0x20, 0x89, 0x7a, 0x37, 0x47, 0x4f, 0xb4, 0x3e,
	0xac, 0x6f, 0x2a, 0x45, 0xcb, 0x28, 0x46, 0x8f, 0xb5, 0x3e, 0xb6, 0x3e, 0x3a, 0xde, 0xfa, 0x68,
	0x93, 0xab, 0x0a, 0x65, 0x4e, 0xe1, 0xf5, 0xa7, 0x71, 0xdb, 0x53, 0x81, 0xbf, 0x5f, 0x6c, 0x95,
	0x7c, 0xb2, 0x9d, 0x42, 0xb6, 0x0a, 0x18, 0xfb, 0x17, 0x04, 0xc3, 0x79, 0x6d, 0xda, 0x72, 0xc6,
	0xac, 0xcd, 0xdd, 0x9c, 0x7f, 0x9d, 0x16, 0x61, 0xb8, 0xcc, 0xaf, 0x73, 0x1b, 0x55, 0xa5, 0x58,
	0xe1, 0x14, 0xfe, 0x3e, 0xf7, 0xa0, 0x58, 0x93, 0xca, 0x7c, 0x14, 0xc5, 0xd1, 0xf9, 0xfe, 0xd4,
	0xab, 0x97, 0xf6, 0x98, 0xf9, 0x4b, 0x76, 0xa6, 0xf3, 0x1a, 0x93, 0x5b, 0x52, 0x99, 0x67, 0x69,
	0x9d, 0xb3, 0xe5, 0x1e, 0x7d, 0x07, 0x8e, 0xda, 0xe5, 0x71, 0xe5, 0x72, 0x83, 0x97, 0xe5, 0xa8,
	0x27, 0x8e, 0xce, 0x47, 0x52, 0x31, 0x9b, 0xc8, 0x5c, 0x7d, 0x73, 0x32, 0xad, 0x51, 0xac, 0x3e,
	0xa8, 0xf3, 0xec, 0x48, 0x2b, 0x53, 0xfd, 0xd1, 0xd8, 0x77, 0x10, 0x0c, 0xb5, 0x0d, 0x30, 0x5f,
	0xa0, 0x0b, 0x10, 0x2a, 0x8b, 0xb2, 0x75, 0x4c, 0xd3, 0xfb, 0x1e, 0xd3, 0x5c, 0xbe, 0x40, 0xc6,
	0x13, 0x2c, 0x8b, 0x32, 0x19, 0xc4, 0xe7, 0x00, 0x30, 0x53, 0x99, 0x6f, 0x6c, 0xf2, 0x8d, 0xa8,
	0x27, 0xee, 0x75, 0xd1, 0xef, 0x70, 0x59, 0x94, 0x0b, 0xa4, 0xc1, 0x98, 0x00, 0x47, 0xec, 0x22,
	0x56, 0x37, 0x44, 0x91, 0xaf, 0xd2, 0x39, 0x08, 0x28, 0xe4, 0x53, 0x14, 0x11, 0xa6, 0xc7, 0x6d,
	0x4c, 0x97, 0xd7, 0xde, 0xe4, 0x4b, 0x0a, 0xcb, 0xaf, 0x63, 0x96, 0x99, 0xa1, 0xc7, 0x0f, 0x75,
	0xf2, 0xbf, 0xff, 0x68, 0xdb, 0xeb, 0xff, 0x03, 0xe4, 0xa1, 0x10, 0xab, 0xdf, 0x59, 0xf4, 0x85,
	0x3c, 0x94, 0x77, 0xec, 0x1b, 0x08, 0x7a, 0xe7, 0x16, 0x66, 0x57, 0x56, 0x24, 0xa9, 0x8a, 0xdb,
	0xd0, 0xe7, 0x21, 0x24, 0x2b, 0x5c, 0x43, 0x29, 0x0a, 0x75, 0x32, 0x1f, 0xe1, 0x4c, 0xdf, 0xcf,
	0x54, 0xd4, 0x83, 0x19, 0xf8, 0x1a, 0x9e, 0xb7, 0x10, 0x1b, 0x24, 0x8f, 0x73, 0x75, 0xfa, 0x34,
	0x04, 0x78, 0xb1, 0x8c, 0xe9, 0x3c, 0x4e, 0x74, 0x7e, 0x5e, 0x2c, 0xe7, 0xea, 0xf4, 0x29, 0x08,
	0xf2, 0x6f, 0x95, 0xaa, 0x1b, 0x65, 0x3e, 0xea, 0x8d, 0xa3, 0xf3, 0xa1, 0x4c, 0xf0, 0xfd, 0x87,
	0xe8, 0x43, 0x15, 0x21, 0xd6, 0xb8, 0x3f, 0xf6, 0x4d, 0x04, 0x14, 0xee, 0x43, 0x6e, 0xe5, 0xce,
	0x94, 0xd9, 0x8f, 0x0b, 0x6d, 0xfd, 0xe8, 0x37, 0xf8, 0xfb, 0x1b, 0xde, 0xb7, 0x91, 0xa5, 0x23,
	0x67, 0x6c, 0x1d, 0xb1, 0x13, 0xba, 0xef, 0xc9, 0xf7, 0xbc, 0x30, 0x64, 0xf4, 0x44, 0xd7, 0x00,
	0xe9, 0xcc, 0x55, 0xe8, 0x37, 0xac, 0xa0, 0xde, 0xe0, 0xd7, 0x85, 0xb7, 0x9c, 0x24, 0x79, 0xd0,
	0x42, 0x0f, 0xdb, 0xa7, 0xd3, 0xad, 0x10, 0x32, 0xfa, 0xd7, 0x21, 0xda, 0xda, 0xb0, 0xc8, 0x55,
	0xab, 0x52, 0x89, 0x53, 0xa4, 0x06, 0xe9, 0x44, 0x24, 0x35, 0x66, 0xd3, 0x20, 0x71, 0x4d, 0x9b,
	0x1e, 0x4f, 0x3e, 0x7e, 0x38, 0xa8, 0x3b, 0x41, 0xb3, 0xfd, 0xfb, 0x0f, 0xd1, 0xb6, 0x8a, 0xc8,
	0x00, 0x16, 0x7a, 0xd8, 0x23, 0x2d, 0x72, 0xd3, 0x06, 0x11, 0xfd, 0x35, 0xf0, 0xd7, 0x25, 0xa9,
	0x2a, 0x47, 0x7d, 0xc4, 0x5e, 0x92, 0x7b, 0xda, 0xb6, 0x5d, 0x11, 0x99, 0x61, 0xd3, 0x76, 0x28,
	0xe3, 0x53, 0x14, 0xb1, 0x1a, 0xd7, 0x6b, 0xb7, 0x7e, 0xa8, 0xa2, 0x1c, 0xcc, 0x43, 0x40, 0x93,
	0x9b, 0xf8, 0x1c, 0x5c, 0x07, 0xca, 0x3e, 0x59, 0x70, 0xae, 0xf3, 0x2c, 0xd0, 0x91, 0xd1, 0xb0,
	0xd9, 0xdb, 0xcc, 0x79, 0x18, 0xb1, 0x11, 0x96, 0xee, 0x4a, 0x42, 0x89, 0xa7, 0x07, 0xb6, 0x55,
	0xe4, 0xd9, 0x51, 0x11, 0xda, 0x55, 0x91, 0x37, 0xc5, 0x4c, 0x2c, 0xfa, 0x42, 0x88, 0xf2, 0x8c,
	0xfd, 0x6e, 0x18, 0x06, 0x70, 0x87, 0xf7, 0xab, 0xab, 0x9f, 0xa1, 0x17, 0x51, 0x57, 0x6f, 0xb4,
	0xea, 0xea, 0xa2, 0x2b, 0x5d, 0xb9, 0xd2, 0x13, 0x7d, 0x1d, 0xfa, 0xd6, 0x85, 0x86, 0xac, 0x98,
	0xb1, 0x34, 0x40, 0x06, 0x34, 0x6c, 0x13, 0x91, 0xad, 0xd5, 0x95, 0x07, 0x0b, 0x88, 0xed, 0x25,
	0xc4, 0x7a, 0x74, 0xa2, 0x67, 0xa0, 0xb7, 0xca, 0x59, 0xda, 0x06, 0xbb, 0xb6, 0x8d, 0x60, 0x5a,
	0xa3, 0xe9, 0x38, 0x44, 0xca, 0x95, 0xfb, 0x66, 0xcb, 0x90, 0x43, 0xa0, 0x58, 0x40, 0x2c, 0x94,
	0x2b, 0xf7, 0x8d, 0x16, 0x53, 0x10, 0x91, 0xb9, 0x1a, 0x5f, 0xe4, 0xe4, 0x62, 0xb9, 0x72, 0x3f,
	0x0a, 0x5d, 0x64, 0x79, 0xd8, 0x30, 0x26, 0x4d, 0xcb, 0x73, 0x95, 0xfb, 0x44, 0x92, 0x28, 0x9b,
	0x92, 0x22, 0x4e, 0x92, 0x3c, 0x2c, 0x0e, 0xcb, 0x86, 0xa4, 0x37, 0xa0, 0x0f, 0x4f, 0x4e, 0x51,
	0xe6, 0x15, 0x45, 0x10, 0x2b, 0x72, 0xb4, 0x97, 0x84, 0xff, 0x49, 0xd7, 0xd3, 0x5e, 0xd0, 0x1a,
	0x92, 0xe8, 0xdd, 0x5b, 0x6f, 0xde, 0x90, 0xaf, 0xfd, 0x97, 0xe7, 0x3f, 0x5f, 0x83, 0x24, 0x93,
	0x4c, 0x31, 0x93, 0xcc, 0x15, 0x66, 0xe6, 0x89, 0x8a, 0xbe, 0x0a, 0x83, 0x5a, 0xa0, 0x8d, 0xeb,
	0xb6, 0x4a, 0xa3, 0x24, 0xc4, 0x21, 0x4a, 0x6e, 0x61, 0x66, 0x72, 0x7c, 0x56, 0x12, 0xd7, 0x85,
	0xca, 0x46, 0x83, 0xc3, 0x0b, 0x37, 0xed, 0xc3, 0x8d, 0xe1, 0x0c, 0xc4, 0xe6, 0xb4, 0xe5, 0x2c,
	0xae, 0xaf, 0x67, 0x71, 0x4e, 0x2c, 0xc7, 0xe7, 0xf2, 0x85, 0xb8, 0xb6, 0x56, 0xd0, 0xde, 0x2b,
	0xcc, 0xcc, 0x0f, 0x55, 0xf4, 0x8e, 0xe7, 0x99, 0x79, 0x21, 0xd0, 0xe0, 0x27, 0x3d, 0xca, 0x84,
	0x75, 0x83, 0xa4, 0xbc, 0xb0, 0x06, 0x03, 0xb6, 0x8e, 0x24, 0x96, 0xe1, 0x16, 0xc4, 0x6c, 0x76,
	0x95, 0xea, 0xbb, 0x89, 0xbf, 0xc6, 0xf5, 0x39, 0x86, 0xe3, 0xad, 0xa6, 0x93, 0xea, 0x5d, 0xe2,
	0x2c, 0x4f, 0xfb, 0x5a, 0xac, 0x03, 0x3e, 0x0f, 0xd0, 0x1c, 0x58, 0x22, 0x09, 0x97, 0x21, 0xd6,
	0x62, 0x0c, 0x29, 0x7b, 0x17, 0x08, 0x83, 0xa6, 0xd2, 0xdd, 0x87, 0x8f, 0xcc, 0xcb, 0xd0, 0x6f,
	0xa0, 0x0b, 0x9d, 0x64, 0x70, 0x5b, 0x45, 0x81, 0x1d, 0x15, 0xf9, 0x77, 0x55, 0xe4, 0x9f, 0x62,
	0xae, 0x32, 0xd3, 0x99, 0x93, 0xda, 0x2a, 0x6e, 0x21, 0x80, 0x1d, 0x15, 0x85, 0x31, 0x41, 0x72,
	0x9c, 0x49, 0x26, 0xb5, 0x20, 0xb4, 0xe8, 0x0b, 0xf9, 0xa9, 0xc0, 0xa2, 0x2f, 0x14, 0xa6, 0x60,
	0xec, 0x37, 0x7c, 0xfa, 0x02, 0x62, 0x18, 0x4b, 0x6e, 0x85, 0x04, 0xa5, 0xef, 0x78, 0x81, 0x32,
	0x0d, 0xa8, 0x28, 0xd4, 0x8b, 0x35, 0xae, 0xae, 0x2f, 0xe1, 0x0b, 0xee, 0x42, 0x72, 0x2b, 0xc3,
	0x4b, 0xcd, 0xef, 0xf5, 0x5b, 0x5c, 0x3d, 0x2b, 0x2a, 0x8d, 0x07, 0x99, 0xbf, 0xf6, 0x60, 0x53,
	0xef, 0x7d, 0x17, 0x85, 0xc7, 0x82, 0x0d, 0x3f, 0x85, 0xa2, 0x6f, 0x23, 0x12, 0x09, 0xde, 0x45,
	0x1e, 0xea, 0x06, 0xfe, 0x14, 0x7e, 0x17, 0x05, 0x12, 0xc4, 0x15, 0x76, 0x7f, 0xf4, 0x03, 0xef,
	0xf9, 0x47, 0x5b, 0xe8, 0x34, 0x3d, 0xf6, 0xcf, 0x2a, 0x8a, 0x41, 0xa8, 0xc6, 0xc9, 0x0a, 0xdf,
	0xb8, 0x38, 0x6e, 0x7e, 0x4a, 0x9a, 0x9f, 0x52, 0x98, 0x38, 0xfb, 0x68, 0x0b, 0xa5, 0xe9, 0xcf,
	0x3f, 0x55, 0xd1, 0xf5, 0xbc, 0x54, 0xe6, 0xe3, 0xeb, 0x52, 0x23, 0x6e, 0xf6, 0x30, 0x2e, 0xd7,
	0xf9, 0x92, 0xb0, 0x2e, 0xf0, 0xe5, 0x38, 0x27, 0xc7, 0x65, 0x41, 0xe1, 0xaf, 0x89, 0x52, 0x99,
	0x67, 0xc8, 0xc7, 0xb8, 0x20, 0xc7, 0x35, 0x30, 0xca, 0x55, 0x31, 0xa7, 0xfe, 0x47, 0x5b, 0x08,
	0xe8, 0xd0, 0xae, 0x8a, 0x7c, 0x98, 0x13, 0xbe, 0x05, 0x8f, 0xb6, 0x50, 0x80, 0xf6, 0xbd, 0xa7,
	0xa2, 0x1e, 0xfc, 0x35, 0xf0, 0x68, 0x0b, 0x79, 0x42, 0xa4, 0x8f, 0xd3, 0x8f, 0xb6, 0xd0, 0xe4,
	0x68, 0xea, 0xa9, 0x8a, 0x2e, 0xe5, 0x56, 0x36, 0x27, 0xe3, 0xba, 0xa6, 0x89, 0x78, 0xe5, 0x2e,
	0x6f, 0xe9, 0x82, 0x24, 0xc6, 0xb9, 0x78, 0x45, 0xd8, 0xe4, 0xc5, 0xb8, 0xa8, 0xb3, 0x3d, 0xf2,
	0x68, 0x0b, 0xd1, 0xa3, 0xd4, 0xae, 0x8a, 0x7a, 0x49, 0x63, 0xdd, 0xec, 0x4c, 0x89, 0xa3, 0x44,
	0x22, 0xdb, 0x2f, 0xb4, 0xcc, 0xe5, 0x68, 0x1a, 0x86, 0x1c, 0x66, 0x97, 0xa6, 0xc0, 0x7b, 0x8f,
	0x7f, 0xa0, 0x61, 0x11, 0x16, 0x7f, 0xa4, 0x87, 0xc1, 0xbf, 0xc9, 0x55, 0x37, 0x78, 0x6d, 0x81,
	0x61, 0xb5, 0x2f, 0xd7, 0x3c, 0xd3, 0x68, 0xec, 0xb7, 0x7c, 0x30, 0x62, 0xd3, 0xda, 0x9d, 0x29,
	0x62, 0x08, 0xdf, 0xed, 0x6c, 0x08, 0x8b, 0xfb, 0x35, 0x04, 0x8d, 0xa5, 0xa3, 0x29, 0xfc, 0xcd,
	0x5e, 0xa6, 0x00, 0xef, 0xa2, 0x60, 0x42, 0xc3, 0x47, 0xff, 0x3b, 0x6d, 0x61, 0xea, 0x30, 0xb6,
	0x30, 0xf5, 0x1c, 0x6d, 0xe1, 0x8f, 0x42, 0x5a, 0x94, 0xd7, 0xc2, 0xda, 0x0a, 0xd7, 0xe0, 0x6a,
	0xbc, 0xc2, 0x37, 0x08, 0xe8, 0xa7, 0x37, 0xa0, 0xaf, 0x7c, 0xb7, 0x54, 0x2f, 0xea, 0xba, 0x96,
	0x75, 0x53, 0x18, 0x77, 0x65, 0x0a, 0x16, 0xd4, 0x93, 0x89, 0x35, 0x11, 0xbe, 0xf1, 0x29, 0x84,
	0x2c, 0x38, 0xa0, 0x17, 0x8b, 0xd1, 0x1b, 0xc8, 0xf4, 0x02, 0x0c, 0x73, 0x1b, 0x8a, 0x54, 0xe3,
	0x14, 0xa1, 0x54, 0x5c, 0x6f, 0x48, 0xb5, 0x22, 0xc1, 0xd2, 0x3a, 0xcc, 0x71, 0x5e, 0x6d, 0x7b,
	0x58, 0xda, 0x6c, 0x73, 0xb3, 0x21, 0xd5, 0x0a, 0xb8, 0x05, 0x3d, 0x07, 0xb4, 0x8d, 0x13, 0x2f,
	0x96, 0xa3, 0xbe, 0xae, 0x7c, 0xa8, 0x16, 0x3e, 0x59, 0xb1, 0x4c, 0xaf, 0x3b, 0x38, 0x85, 0x9f,
	0xf0, 0x98, 0x3c, 0x48, 0x74, 0xcc, 0xf8, 0xb6, 0x35, 0xa4, 0x65, 0x53, 0x27, 0xfd, 0xa1, 0x07,
	0x7a, 0xd7, 0x85, 0xb7, 0xf8, 0xb2, 0x21, 0x24, 0x40, 0xa6, 0x3b, 0xe7, 0x4a, 0x88, 0x93, 0x02,
	0x2f, 0xdd, 0xc4, 0xdc, 0x2c, 0x8e, 0xf7, 0x09, 0x32, 0xbc, 0x6b, 0xcc, 0xdf, 0xf0, 0xfe, 0x1d,
	0x22, 0x5f, 0x03, 0xef, 0x22, 0x2f, 0xd5, 0xf4, 0xc0, 0x71, 0xd4, 0x31, 0x18, 0x3f, 0x55, 0x51,
	0xec, 0x56, 0x7a, 0xd6, 0x30, 0xcf, 0xb8, 0xb4, 0x4e, 0x4c, 0x9b, 0xa0, 0x84, 0x52, 0x55, 0xe0,
	0x45, 0x05, 0x13, 0x8f, 0x3c, 0xda, 0x42, 0x83, 0xf4, 0xc0, 0xae, 0x8a, 0x22, 0x16, 0xe2, 0xfd,
	0x45, 0x52, 0x43, 0x82, 0x22, 0xc5, 0xd7, 0xf8, 0x38, 0x27, 0xcb, 0x42, 0x45, 0xe4, 0xcb, 0xf8,
	0xab, 0x83, 0x40, 0x97, 0x91, 0x14, 0xd6, 0xcd, 0xd9, 0xa0, 0x6f, 0xc0, 0x20, 0xb1, 0x6c, 0xcd,
	0xdd, 0xa7, 0x53, 0x45, 0x85, 0xab, 0x10, 0xe4, 0x18, 0xce, 0x0c, 0x5b, 0xe0, 0xb0, 0x0e, 0xce,
	0xa2, 0x37, 0xd8, 0x01, 0x4c, 0xbe, 0xac, 0x53, 0xaf, 0x72, 0x95, 0xd1, 0xcf, 0xc1, 0x80, 0x6d,
	0x76, 0xf7, 0xe3, 0x77, 0xd7, 0x2a, 0x4f, 0x54, 0x54, 0x82, 0x31, 0x38, 0x61, 0x45, 0x5d, 0x32,
	0xa3, 0x81, 0x2d, 0xc6, 0x80, 0x10, 0x18, 0x86, 0x1d, 0x81, 0x41, 0xd3, 0x80, 0x8c, 0xa1, 0xd1,
	0x28, 0x05, 0x67, 0x20, 0x4e, 0x3a, 0x10, 0xcf, 0xad, 0xc4, 0xd3, 0x64, 0x82, 0x6a, 0xbc, 0xa8,
	0x68, 0x01, 0x67, 0x96, 0xcc, 0x8d, 0x4c, 0xa3, 0xa9, 0x4c, 0x12, 0x8e, 0x9b, 0x86, 0x62, 0x62,
	0x11, 0x41, 0xac, 0x58, 0x81, 0x83, 0x77, 0x47, 0x45, 0x1e, 0x0c, 0x1c, 0x26, 0x30, 0x22, 0xd4,
	0x73, 0xef, 0xef, 0x23, 0xa0, 0x71, 0x14, 0x4f, 0x6f, 0x28, 0x92, 0x06, 0xfe, 0x48, 0x4c, 0x48,
	0x80, 0xef, 0xae, 0x24, 0x2b, 0x7a, 0xb9, 0xa3, 0x93, 0x13, 0x11, 0x1a, 0xba, 0x00, 0x81, 0x86,
	0xb4, 0xa1, 0xf0, 0x46, 0x86, 0x32, 0xb3, 0xa7, 0x25, 0xb7, 0x0a, 0x64, 0x49, 0x63, 0x2c, 0x76,
	0xa1, 0x87, 0xd5, 0x59, 0x65, 0x4e, 0xc3, 0x20, 0xf6, 0xd0, 0x12, 0xa1, 0xd8, 0x23, 0x03, 0xfb,
	0x13, 0x0f, 0x44, 0x3b, 0xb1, 0xa4, 0x27, 0x3a, 0xa4, 0x62, 0xd0, 0x2d, 0x65, 0xbe, 0x4d, 0x12,
	0x7f, 0x85, 0x5f, 0xdf, 0xa8, 0xea, 0x83, 0xba, 0xea, 0x3a, 0x69, 0x2d, 0xe8, 0x0d, 0x35, 0x57,
	0x5d, 0xe8, 0x61, 0x4d, 0x56, 0xf4, 0x2d, 0x1d, 0xcc, 0x91, 0x3e, 0xea, 0x01, 0xea, 0x92, 0xab,
	0xd9, 0x9a, 0x13, 0x65, 0x7d, 0x64, 0xe1, 0xb2, 0xf1, 0x31, 0x73, 0x0a, 0xfa, 0x8d, 0x2c, 0xaf,
	0xfb, 0x04, 0xb1, 0x10, 0xd1, 0x99, 0x2c, 0x09, 0xb2, 0x42, 0xcf, 0x6a, 0xe5, 0xa6, 0xaa, 0x20,
	0x2b, 0x24, 0xd6, 0x87, 0x33, 0xe7, 0xcd, 0xc8, 0xed, 0x73, 0x8a, 0xdc, 0xd6, 0x82, 0x47, 0x59,
	0x63, 0x32, 0xf6, 0x73, 0x04, 0x43, 0x98, 0xe9, 0x92, 0x54, 0xe2, 0xaa, 0x73, 0xcd, 0x8c, 0xa6,
	0x2d, 0xcb, 0xeb, 0x1e, 0xcf, 0xbb, 0x67, 0x79, 0xdd, 0x63, 0x78, 0x4b, 0x96, 0xf7, 0x79, 0xa0,
	0x4b, 0x7a, 0xf2, 0xc2, 0x97, 0x4d, 0x06, 0x7e, 0xa7, 0x62, 0xcc, 0x42, 0x0f, 0x3b, 0xd8, 0xa4,
	0xd5, 0x19, 0x64, 0xce, 0x00, 0x85, 0x93, 0x8f, 0x6a, 0xd1, 0x86, 0xb7, 0xbd, 0xfa, 0x7c, 0x9a,
	0x6e, 0x83, 0x67, 0x74, 0x17, 0x41, 0x5f, 0x8b, 0x5e, 0xe8, 0x02, 0x84, 0xcd, 0xe6, 0xba, 0xdb,
	0x4c, 0xba, 0x52, 0xad, 0x6d, 0x02, 0xb1, 0xc1, 0x54, 0xf5, 0x5b, 0xf4, 0xeb, 0x30, 0x60, 0x19,
	0x14, 0x51, 0x98, 0x36, 0x9d, 0x8c, 0x5b, 0xab, 0xc1, 0xba, 0xc2, 0x8b, 0x50, 0x93, 0x0d, 0xbe,
	0x93, 0x39, 0xd1, 0x92, 0x56, 0x74, 0x30, 0x9b, 0x9f, 0x06, 0xe0, 0x88, 0xb3, 0x55, 0xd3, 0x0f,
	0x9c, 0x31, 0xc3, 0xa4, 0x6b, 0x2f, 0xf9, 0xd5, 0xc1, 0x0d, 0x77, 0x3b, 0xe2, 0x86, 0xa9, 0x83,
	0x81, 0xe9, 0x8e, 0xc8, 0xe1, 0x5f, 0x9d, 0x91, 0xc3, 0xfc, 0x01, 0x43, 0x53, 0x1b, 0x6e, 0xf8,
	0xb9, 0x6b, 0xdc, 0xe0, 0x8c, 0xdc, 0x9f, 0x17, 0x70, 0x98, 0x3a, 0x0c, 0x70, 0x98, 0x72, 0x01,
	0x1c, 0x0e, 0xb9, 0xec, 0x1f, 0x7c, 0x35, 0xfe, 0x4b, 0x04, 0xa3, 0x58, 0x49, 0x42, 0x29, 0x57,
	0x6f, 0x82, 0x3c, 0x9c, 0x96, 0x90, 0xb5, 0xec, 0x22, 0x80, 0x50, 0x37, 0x63, 0x5b, 0x7b, 0x45,
	0xfa, 0xdb, 0x08, 0xb1, 0x61, 0xa1, 0x6e, 0x84, 0x44, 0x06, 0xc0, 0xdc, 0xc6, 0xb8, 0xef, 0x50,
	0x20, 0xaf, 0x23, 0x36, 0x6c, 0x6c, 0x54, 0xdc, 0xa7, 0xc7, 0x5b, 0xf6, 0x0b, 0xbc, 0x84, 0x7a,
	0x10, 0xc3, 0x23, 0x7b, 0x0b, 0x73, 0x8b, 0xe0, 0x1f, 0x7c, 0x70, 0xa2, 0xbd, 0xb7, 0xb3, 0xd5,
	0x0d, 0xd9, 0x58, 0x7c, 0xff, 0xa2, 0x73, 0xa6, 0xc9, 0xee, 0x69, 0xb5, 0x5d, 0x59, 0x3b, 0x66,
	0x9c, 0xdf, 0x76, 0xce, 0x38, 0x75, 0x13, 0x7e, 0xb1, 0x72, 0x4c, 0x8b, 0x75, 0xdf, 0x78, 0xb4,
	0x85, 0x5e, 0x1d, 0xbd, 0xf6, 0x54, 0x45, 0x53, 0xda, 0x98, 0x31, 0xd8, 0xab, 0x9b, 0xa3, 0x76,
	0x48, 0x2e, 0x39, 0x9c, 0x5e, 0xb6, 0x26, 0x97, 0xb1, 0x47, 0x5b, 0x68, 0x74, 0x34, 0xba, 0xab,
	0xa2, 0xe1, 0x26, 0x93, 0xe6, 0xd4, 0x59, 0xac, 0x1d, 0x47, 0x97, 0xb6, 0x24, 0xf3, 0xd7, 0xdc,
	0x26, 0x99, 0x5f, 0xb4, 0x5a, 0x7d, 0x24, 0x75, 0xfd, 0x00, 0x6a, 0x34, 0xec, 0xd9, 0x9a, 0xa1,
	0xfe, 0x04, 0xc1, 0x4b, 0xed, 0x94, 0x37, 0xab, 0x3c, 0xaf, 0x10, 0x4b, 0x6a, 0x74, 0x29, 0x8c,
	0x23, 0xd7, 0x85, 0xf1, 0x61, 0xa7, 0xc2, 0x78, 0xc7, 0x5a, 0xf8, 0xfe, 0xfc, 0x87, 0x71, 0xf0,
	0x9f, 0xbe, 0x8e, 0xbe, 0xf3, 0xc7, 0x5e, 0x38, 0xa2, 0x8f, 0x77, 0xc5, 0x96, 0x8f, 0x97, 0xa0,
	0x1f, 0x2b, 0x15, 0x2f, 0x6b, 0x78, 0x61, 0xd2, 0xb7, 0x94, 0x0e, 0x37, 0xd5, 0x18, 0x69, 0x61,
	0xa6, 0x06, 0x05, 0xbd, 0x09, 0x83, 0x25, 0xcd, 0x9b, 0x2c, 0x72, 0xb4, 0x25, 0xf4, 0xb5, 0xc3,
	0x79, 0x66, 0x26, 0x84, 0x0d, 0x6c, 0x47, 0x5b, 0xc2, 0x06, 0x74, 0x21, 0xa6, 0x5c, 0x19, 0x06,
	0xd6, 0xb1, 0x52, 0x2d, 0x52, 0xb5, 0x05, 0xf7, 0xd5, 0x03, 0x48, 0x35, 0xcd, 0x23, 0x13, 0x69,
	0xdd, 0xdd, 0xe8, 0x23, 0x32, 0x8c, 0x06, 0x99, 0x44, 0xa7, 0x9a, 0xec, 0xa0, 0x05, 0xf8, 0xf8,
	0x53, 0xcc, 0x04, 0x33, 0xa9, 0x43, 0x9f, 0xef, 0x62, 0xe8, 0xc3, 0x97, 0x85, 0x12, 0xa7, 0xf0,
	0xe5, 0xe6, 0x06, 0x28, 0x56, 0x0f, 0x0b, 0x81, 0x32, 0xbf, 0x29, 0x94, 0x78, 0x3d, 0x00, 0x5f,
	0xdb, 0x55, 0xd1, 0x39, 0xf0, 0xf1, 0xca, 0xdd, 0x71, 0x72, 0x4d, 0x92, 0xeb, 0x0c, 0xf8, 0xf1,
	0xe7, 0x71, 0xf0, 0xdf, 0xaf, 0x72, 0x22, 0xfe, 0x73, 0x9f, 0x13, 0xc7, 0x0d, 0x73, 0x08, 0x34,
	0x7c, 0x14, 0x8a, 0xde, 0x60, 0x75, 0x4e, 0xf4, 0x38, 0x04, 0xf5, 0x89, 0xda, 0x03, 0xc6, 0x18,
	0x64, 0xf4, 0x3c, 0xf8, 0xb0, 0x3e, 0xc9, 0xe4, 0x85, 0x33, 0xc9, 0xdd, 0x3d, 0x03, 0x9a, 0x4d,
	0x34, 0xce, 0xde, 0x30, 0x03, 0x3a, 0x01, 0xde, 0x9a, 0xb2, 0x41, 0x76, 0x45, 0xfa, 0x32, 0xd1,
	0x6d, 0x3d, 0x1d, 0x1e, 0x48, 0xf4, 0x65, 0x22, 0xe3, 0xcc, 0x95, 0x64, 0xea, 0x62, 0x72, 0x6a,
	0x62, 0x7a, 0x92, 0xc5, 0x44, 0x74, 0x02, 0x42, 0xf5, 0x86, 0x20, 0x35, 0x04, 0xe5, 0x41, 0x34,
	0x4c, 0x1a, 0xf4, 0x1b, 0x0d, 0xfc, 0x09, 0x6f, 0xf4, 0x17, 0x88, 0x35, 0x9f, 0xd3, 0x57, 0x21,
	0x22, 0x4a, 0x4a, 0xb1, 0xde, 0x10, 0x6a, 0x5c, 0xe3, 0x01, 0xd9, 0x0b, 0xe9, 0xbc, 0x5f, 0x03,
	0xa2, 0xa4, 0xac, 0x68, 0x94, 0xf4, 0x15, 0x00, 0x41, 0x36, 0xdb, 0xf5, 0x76, 0x6d, 0x17, 0x16,
	0x64, 0xa3, 0xd9, 0x3c, 0x50, 0x35, 0x49, 0x14, 0x14, 0xa9, 0x51, 0x2c, 0x0b, 0x32, 0xb7, 0x56,
	0xe5, 0xcb, 0xd1, 0xfe, 0xce, 0x8d, 0x75, 0x90, 0xe5, 0x61, 0x07, 0xf4, 0x56, 0x73, 0x7a, 0x23,
	0xfa, 0x2b, 0x10, 0xd4, 0x6f, 0x45, 0x07, 0x5c, 0xe6, 0xb3, 0x4b, 0x82, 0x78, 0xef, 0x8b, 0x1b,
	0x5c, 0x55, 0x50, 0x1e, 0xdc, 0xd2, 0x9a, 0xea, 0x19, 0x9a, 0x21, 0xc4, 0xe0, 0x78, 0xed, 0xc6,
	0x13, 0x15, 0xbd, 0x0a, 0xa3, 0x30, 0x64, 0x1a, 0x57, 0xdc, 0xb4, 0x2e, 0xda, 0x9b, 0x64, 0x52,
	0x10, 0x83, 0xe1, 0x59, 0xa9, 0x56, 0x93, 0x44, 0xdb, 0x5e, 0x4c, 0x60, 0x9a, 0x99, 0x61, 0x92,
	0x13, 0x99, 0x18, 0x9e, 0xd7, 0x32, 0x6f, 0x85, 0xee, 0x06, 0x94, 0xf0, 0x4e, 0x30, 0x93, 0x99,
	0x97, 0xa1, 0x5f, 0x9f, 0x3b, 0xab, 0x91, 0x47, 0x76, 0x54, 0x04, 0x64, 0xd3, 0x20, 0xc9, 0x24,
	0x53, 0x99, 0x04, 0x0c, 0xea, 0x3d, 0xb2, 0xa0, 0x92, 0x91, 0x6d, 0x15, 0xf5, 0xbf, 0xa7, 0xf9,
	0x6e, 0x1f, 0xa1, 0x9d, 0x64, 0x92, 0x3a, 0x32, 0x31, 0x37, 0x18, 0x02, 0x54, 0x70, 0xd1, 0x17,
	0x0a, 0x52, 0xa1, 0x45, 0x5f, 0x08, 0xa8, 0xc8, 0xa2, 0x2f, 0xd4, 0x47, 0xf5, 0x8f, 0xfd, 0x93,
	0x07, 0xe2, 0xe6, 0x88, 0x6e, 0x71, 0x22, 0x57, 0xe1, 0x6b, 0xbc, 0xa8, 0xb4, 0x3a, 0xce, 0x55,
	0x9b, 0xe3, 0x9c, 0xc4, 0x88, 0xcc, 0xea, 0x38, 0x2f, 0xae, 0x77, 0xf8, 0x5d, 0x78, 0xc7, 0xb5,
	0x8b, 0x4f, 0x54, 0x74, 0x01, 0xce, 0x41, 0xac, 0xa9, 0xdb, 0xe6, 0x54, 0x58, 0xd4, 0xec, 0x4f,
	0x32, 0x29, 0xe6, 0xca, 0x5e, 0x8a, 0xd4, 0x11, 0xe1, 0x0f, 0x68, 0x18, 0xc9, 0x2a, 0x77, 0xf9,
	0x86, 0xc8, 0xef, 0x35, 0x9d, 0x64, 0x0c, 0x5b, 0xa8, 0x37, 0xe4, 0x19, 0x47, 0xd7, 0x02, 0x5a,
	0xc2, 0xf7, 0x82, 0x4d, 0x67, 0x0a, 0x42, 0x1b, 0xa2, 0xc2, 0x55, 0x2a, 0x7c, 0x79, 0x8f, 0xdd,
	0x5f, 0x93, 0x8e, 0x3e, 0x07, 0xc1, 0xcd, 0x2a, 0x27, 0x16, 0x85, 0x32, 0x29, 0xdd, 0xf5, 0x65,
	0x7a, 0x31, 0xe7, 0x60, 0xc2, 0x1f, 0xfd, 0xc5, 0xc9, 0xf3, 0x68, 0x01, 0xb1, 0x01, 0xfc, 0x38,
	0x57, 0xc6, 0x11, 0x87, 0xe4, 0xa4, 0x1a, 0xf2, 0x27, 0x01, 0xaa, 0xf3, 0xae, 0x2d, 0x60, 0x52,
	0xad, 0x80, 0x46, 0xaf, 0xe9, 0x0d, 0xf5, 0xa5, 0x1b, 0x5c, 0x7a, 0x7d, 0xa7, 0x7a, 0x6c, 0xc6,
	0xb7, 0xa3, 0x79, 0x3d, 0x91, 0xa1, 0x27, 0xcc, 0x77, 0x20, 0xdc, 0x5c, 0xf1, 0x22, 0x2e, 0x4b,
	0x4a, 0xce, 0x00, 0x61, 0xc1, 0xa3, 0x95, 0x94, 0xc8, 0x7a, 0xfa, 0x1a, 0x0c, 0x88, 0x52, 0x51,
	0xa8, 0x6f, 0x4e, 0x99, 0x79, 0xc1, 0xc9, 0x2e, 0x03, 0xf7, 0xb2, 0x7d, 0xa2, 0x94, 0xab, 0x6f,
	0x4e, 0x19, 0x39, 0x82, 0x00, 0x43, 0x66, 0xbf, 0x2c, 0x3c, 0xe2, 0x87, 0xeb, 0xa1, 0x97, 0x1d,
	0x34, 0x7a, 0xd8, 0x14, 0xf5, 0x4d, 0x04, 0x94, 0x26, 0x64, 0x43, 0x91, 0x8c, 0x22, 0xd8, 0x29,
	0x22, 0x68, 0x62, 0x9f, 0x25, 0x43, 0x32, 0xcd, 0x67, 0x9f, 0x3e, 0x7c, 0xb9, 0xcc, 0xd7, 0xa4,
	0x24, 0xa3, 0xf0, 0xb2, 0xc2, 0x94, 0x1a, 0x0a, 0x23, 0x2b, 0x5c, 0x45, 0x10, 0x2b, 0x8c, 0x2c,
	0xad, 0x2b, 0x6b, 0x9c, 0x78, 0xaf, 0x58, 0xe3, 0x4b, 0x0b, 0x5e, 0xb6, 0x1f, 0x8b, 0x6d, 0xb6,
	0xc6, 0x89, 0x3f, 0x46, 0xe9, 0x45, 0xad, 0x60, 0xa3, 0x0b, 0x8b, 0xf6, 0x75, 0x99, 0x37, 0x1f,
	0x4b, 0xe1, 0x16, 0xa4, 0x56, 0x63, 0x6c, 0x9e, 0x57, 0xe0, 0x98, 0x85, 0x8b, 0x20, 0xca, 0x42,
	0x99, 0x37, 0x99, 0x75, 0x5b, 0x7a, 0x86, 0x1f, 0x6f, 0x21, 0x0a, 0xfa, 0x37, 0xa5, 0xaa, 0x22,
	0x2b, 0x5c, 0xe9, 0x5e, 0x11, 0xb3, 0x59, 0xf0, 0xb1, 0x47, 0x4c, 0x11, 0x39, 0xc2, 0xcc, 0x10,
	0xb4, 0x0e, 0xfd, 0x36, 0xee, 0x03, 0xae, 0x11, 0xef, 0xb1, 0xc7, 0x0f, 0x07, 0x36, 0x85, 0x86,
	0xb2, 0xd1, 0x1c, 0xa8, 0x7e, 0xe2, 0x68, 0xc1, 0xc7, 0xf6, 0x09, 0x2d, 0x72, 0xbe, 0x0c, 0x03,
	0xb2, 0x22, 0x35, 0xb8, 0x4a, 0x53, 0xd0, 0x48, 0x97, 0x61, 0x1c, 0xc3, 0xe1, 0xf0, 0xf1, 0x16,
	0x1a, 0x84, 0x01, 0x99, 0x2f, 0x6d, 0x34, 0xf8, 0x1a, 0x2f, 0xdf, 0x35, 0xc6, 0xd2, 0xaf, 0x73,
	0x32, 0x78, 0xaf, 0x41, 0xaf, 0xdc, 0xd8, 0x9c, 0x32, 0x19, 0x1f, 0x7b, 0x36, 0x23, 0x88, 0x60,
	0xa6, 0x86, 0x8c, 0x2f, 0xc0, 0xa0, 0x50, 0x2f, 0xae, 0x73, 0x6b, 0x0d, 0xa1, 0x64, 0x0a, 0x1a,
	0xed, 0x32, 0x82, 0x60, 0x93, 0xd1, 0x80, 0x50, 0xbf, 0x49, 0x1a, 0x1a, 0xcc, 0x7e, 0x13, 0xe1,
	0x61, 0x55, 0x70, 0xec, 0x36, 0x79, 0xbd, 0xe4, 0xba, 0xd3, 0x33, 0x8f, 0x1f, 0x06, 0xf5, 0xd6,
	0x8f, 0xb7, 0xd0, 0x2b, 0x09, 0x6f, 0xa9, 0xa1, 0x24, 0x82, 0xba, 0x79, 0x26, 0x7c, 0xf5, 0x86,
	0x54, 0x4e, 0xf4, 0x5a, 0xad, 0x34, 0x11, 0x5c, 0xe7, 0xcb, 0x0d, 0xae, 0x56, 0x27, 0x73, 0xa7,
	0xb5, 0x34, 0xba, 0xa2, 0x2f, 0x42, 0xd4, 0x7e, 0x21, 0xda, 0xe0, 0xfe, 0x20, 0xda, 0x50, 0x17,
	0xfb, 0xf7, 0x77, 0x81, 0x68, 0xc3, 0x5d, 0xdb, 0xed, 0x01, 0xd1, 0x8e, 0xee, 0x09, 0xd1, 0x02,
	0x5d, 0x21, 0x5a, 0xf4, 0xd9, 0x40, 0xb4, 0x40, 0x13, 0xa2, 0xc9, 0x4f, 0x54, 0x24, 0xc1, 0x09,
	0xa0, 0x8d, 0x65, 0xd7, 0xb2, 0x74, 0x07, 0x93, 0x4c, 0x3c, 0xc5, 0xc4, 0xaf, 0xc0, 0x08, 0x50,
	0xb9, 0x15, 0x1b, 0x42, 0x43, 0xd3, 0x30, 0x02, 0x03, 0x77, 0x34, 0x53, 0x35, 0x8f, 0xd8, 0x78,
	0x92, 0x29, 0x88, 0x77, 0xc0, 0x74, 0xa1, 0xe4, 0x14, 0x93, 0xbc, 0xca, 0xa4, 0x52, 0x7b, 0xa2,
	0xba, 0x18, 0x44, 0xc8, 0x22, 0x68, 0x79, 0x6e, 0x1c, 0x14, 0xf1, 0x4e, 0x31, 0x57, 0x33, 0x67,
	0xda, 0xb6, 0x02, 0x86, 0xb6, 0x55, 0x14, 0xde, 0x51, 0x51, 0x68, 0x57, 0x45, 0xc1, 0x19, 0x86,
	0x1c, 0x16, 0xc9, 0xb0, 0x30, 0x64, 0x0d, 0xf3, 0x06, 0xed, 0xf5, 0x6d, 0x15, 0x9d, 0xdc, 0x51,
	0x51, 0x6c, 0x57, 0x45, 0xa1, 0x89, 0x24, 0x33, 0x91, 0x62, 0x26, 0x26, 0x1e, 0x7d, 0x82, 0xdc,
	0x84, 0xd7, 0xcc, 0x85, 0xe6, 0x06, 0x8b, 0xce, 0xee, 0xe8, 0xb6, 0x8a, 0xfa, 0x76, 0x54, 0xd4,
	0xbb, 0xab, 0xa2, 0x48, 0x72, 0x82, 0x49, 0x4e, 0x32, 0xa9, 0xab, 0x4c, 0x2a, 0xd9, 0x01, 0x9b,
	0x0e, 0xed, 0xa8, 0x88, 0x26, 0x78, 0x73, 0x86, 0x49, 0x8d, 0x77, 0xc6, 0xa6, 0x47, 0x75, 0x6c,
	0x7a, 0x84, 0x24, 0x6b, 0x13, 0x4c, 0x6a, 0xd2, 0x86, 0x4d, 0x43, 0x54, 0x78, 0xd1, 0x17, 0x8a,
	0x51, 0x27, 0x17, 0x7d, 0xa1, 0x5e, 0xaa, 0x6f, 0xd1, 0x17, 0xa2, 0xa9, 0xa1, 0x45, 0x5f, 0xe8,
	0x08, 0x75, 0x74, 0xec, 0x07, 0x01, 0x18, 0xd2, 0xce, 0xaf, 0xb6, 0xa2, 0xa8, 0xa9, 0x26, 0x18,
	0xf2, 0x74, 0x33, 0x45, 0x3d, 0xb1, 0x34, 0x21, 0xd1, 0xac, 0x0e, 0x89, 0xb4, 0x3c, 0xff, 0xe2,
	0xde, 0x90, 0xc8, 0x09, 0x0e, 0x65, 0xcd, 0x93, 0xb4, 0x3e, 0xd7, 0x91, 0x25, 0x6c, 0x9e, 0xa7,
	0x35, 0x4e, 0xd1, 0xd2, 0xab, 0x56, 0x6c, 0xe1, 0x3f, 0xd4, 0xca, 0x6d, 0x41, 0x16, 0xce, 0x8b,
	0x64, 0xf7, 0x73, 0x77, 0xed, 0x8b, 0xe4, 0x17, 0xbb, 0x2d, 0x92, 0xa1, 0xae, 0xcc, 0xdc, 0x2f,
	0x87, 0xe1, 0x67, 0xb1, 0x98, 0x20, 0xfb, 0x72, 0xa8, 0x87, 0x5d, 0xd8, 0x6f, 0xd8, 0x8d, 0x74,
	0x0f, 0xbb, 0xd7, 0xde, 0x7c, 0xa2, 0xa2, 0x75, 0x88, 0x02, 0xa5, 0xd9, 0xa3, 0x25, 0xbc, 0xf8,
	0x92, 0x4c, 0x7c, 0xd2, 0x39, 0xb6, 0x5c, 0x81, 0xe1, 0xf6, 0xd8, 0x82, 0xa6, 0xe0, 0x44, 0x87,
	0xd0, 0xa2, 0x9d, 0x0e, 0xeb, 0x14, 0x57, 0xac, 0x67, 0xd0, 0x6c, 0xce, 0x8b, 0x3d, 0x32, 0xb8,
	0xa3, 0xa2, 0x00, 0xf6, 0xb2, 0xab, 0xcc, 0x34, 0x33, 0x63, 0x1e, 0x31, 0x0b, 0x50, 0xc1, 0xb1,
	0x3f, 0x8b, 0xc0, 0xd0, 0x12, 0x5f, 0xe1, 0x4a, 0x0f, 0x5a, 0xfd, 0xe8, 0x4b, 0xe0, 0x53, 0x1e,
	0xd4, 0x8d, 0xe3, 0xeb, 0x57, 0xf6, 0x7d, 0x7c, 0x9d, 0x68, 0xa7, 0x0f, 0xcf, 0x57, 0xe8, 0x1d,
	0xe4, 0x1f, 0xf5, 0xf6, 0x20, 0x2f, 0x4b, 0x38, 0x1a, 0x6a, 0xf0, 0xba, 0x51, 0x43, 0x09, 0xec,
	0xda, 0xd5, 0xcf, 0xb1, 0x76, 0x3f, 0xa3, 0x7e, 0xbc, 0xdd, 0x2a, 0x2c, 0x87, 0xd5, 0xfb, 0xf5,
	0x47, 0xc6, 0xac, 0x7f, 0x09, 0xc8, 0x86, 0x54, 0xcb, 0x1e, 0xe3, 0x41, 0x86, 0x8c, 0xf3, 0x07,
	0x96, 0x64, 0x1e, 0x06, 0x42, 0x5e, 0x00, 0x4a, 0x77, 0x64, 0x9d, 0x37, 0x2f, 0xeb, 0x7b, 0x3c,
	0x27, 0x1c, 0x0e, 0xee, 0x17, 0x36, 0xd6, 0x44, 0xad, 0xfc, 0xc5, 0x0e, 0x68, 0xcd, 0xd2, 0x46,
	0x2b, 0xfa, 0xeb, 0x30, 0x60, 0x7b, 0x83, 0x41, 0xf7, 0xdc, 0x03, 0x74, 0xf3, 0xe6, 0xfc, 0xeb,
	0x6c, 0x7f, 0xeb, 0x0b, 0x0d, 0x74, 0x81, 0x1c, 0x93, 0x34, 0x32, 0xa6, 0x90, 0xcb, 0xed, 0x4e,
	0x87, 0x77, 0x16, 0xd8, 0xf0, 0x5c, 0xbe, 0xa0, 0xe7, 0x48, 0x5f, 0x85, 0x08, 0x9e, 0x13, 0x83,
	0x6b, 0x98, 0xcc, 0xeb, 0xf5, 0x03, 0xcd, 0xab, 0xc6, 0x91, 0x85, 0xe6, 0x67, 0xba, 0x08, 0xbd,
	0x64, 0x09, 0xc5, 0x69, 0xa5, 0x20, 0x56, 0x88, 0x5f, 0x1f, 0xe4, 0xe5, 0x91, 0x3b, 0x4b, 0xe9,
	0xfc, 0xaa, 0xc6, 0x83, 0x25, 0x8b, 0xb2, 0xfe, 0x85, 0x3e, 0x09, 0x11, 0x2d, 0xc3, 0x2e, 0x8a,
	0x5c, 0x8d, 0xd7, 0x4e, 0xff, 0xb2, 0xa0, 0xdd, 0xca, 0x73, 0x35, 0x9e, 0x3e, 0x03, 0x21, 0xa3,
	0x07, 0x24, 0xd9, 0xe8, 0xd3, 0x0f, 0x21, 0x24, 0xbc, 0xd1, 0xff, 0x3e, 0xc9, 0x06, 0x75, 0x5e,
	0xf4, 0xb2, 0xb9, 0x2a, 0xf4, 0xbb, 0x8c, 0xe5, 0xce, 0x2f, 0x6a, 0x98, 0xeb, 0x83, 0x35, 0x38,
	0x0d, 0xec, 0x81, 0x09, 0x05, 0x68, 0x2f, 0x90, 0x47, 0x29, 0x17, 0x3e, 0x14, 0x73, 0x2a, 0xad,
	0x5b, 0xbc, 0x88, 0xd2, 0x1f, 0x36, 0xcb, 0xeb, 0x4e, 0x70, 0x90, 0xde, 0x13, 0x0e, 0xf6, 0x74,
	0x85, 0x83, 0x43, 0xcf, 0x06, 0x0e, 0xf6, 0x34, 0xe1, 0xe0, 0xdb, 0xe8, 0x89, 0x8a, 0xfe, 0x3f,
	0x9c, 0x02, 0x4a, 0x0b, 0x7b, 0x96, 0x70, 0xdd, 0x97, 0x64, 0x92, 0x49, 0x82, 0xac, 0x30, 0xc6,
	0x81, 0xb8, 0x43, 0xdc, 0xee, 0xbd, 0xc2, 0x90, 0x73, 0xbc, 0xcc, 0x0c, 0x93, 0x9c, 0x72, 0x0c,
	0xe1, 0x93, 0x70, 0xb2, 0x43, 0x08, 0x0f, 0x4e, 0x30, 0xc9, 0x2b, 0x4c, 0xf2, 0x6a, 0x67, 0x44,
	0x44, 0xeb, 0x88, 0x68, 0x90, 0xa0, 0xa7, 0x69, 0x26, 0x89, 0x63, 0xf5, 0x20, 0x45, 0x8f, 0x7d,
	0x12, 0x86, 0x91, 0x25, 0x49, 0xaa, 0xaf, 0x71, 0xa5, 0xd6, 0x10, 0x4b, 0x97, 0x6c, 0x55, 0xa3,
	0x2f, 0xec, 0xaa, 0x68, 0x1a, 0xbc, 0x55, 0x69, 0x1c, 0x5f, 0x92, 0xf8, 0x92, 0xc2, 0x97, 0x09,
	0x7c, 0x99, 0xc4, 0x97, 0x2b, 0xf8, 0x32, 0x85, 0x2f, 0x57, 0xf1, 0x85, 0x10, 0xcf, 0x80, 0xaf,
	0x2a, 0x25, 0x5f, 0xc4, 0x72, 0xb6, 0xad, 0x08, 0xd4, 0xbd, 0xc8, 0xd4, 0xa5, 0x08, 0x14, 0x7c,
	0x36, 0x45, 0x20, 0xd4, 0xb9, 0x08, 0x14, 0x3a, 0x5c, 0x89, 0x05, 0x1d, 0xbc, 0x08, 0xe4, 0x79,
	0x3e, 0x45, 0x20, 0x8f, 0x53, 0x11, 0xc8, 0x19, 0x55, 0x46, 0xba, 0x96, 0xac, 0xf6, 0x59, 0x7a,
	0xe9, 0xdd, 0x77, 0xe9, 0xc5, 0xdb, 0x11, 0x6b, 0x3a, 0x96, 0x14, 0xfa, 0xdc, 0x94, 0x14, 0xbc,
	0xed, 0x25, 0x05, 0x1d, 0xc9, 0x84, 0xdd, 0x14, 0x93, 0xd7, 0x9f, 0xa8, 0x68, 0x0d, 0x8e, 0xc2,
	0x80, 0xe1, 0xc6, 0xf1, 0x39, 0xcd, 0xb7, 0x30, 0x46, 0x4c, 0x75, 0xc2, 0x88, 0x8e, 0xf9, 0xe7,
	0x38, 0x1c, 0xeb, 0x10, 0x61, 0xd0, 0x8c, 0x9b, 0xed, 0x04, 0x5b, 0xb2, 0xe8, 0xf0, 0x92, 0xc2,
	0xb2, 0x73, 0x5a, 0x39, 0x6d, 0x49, 0x2b, 0xfd, 0x24, 0xad, 0x74, 0x9b, 0x53, 0x3a, 0xc3, 0xd2,
	0xd6, 0x4d, 0x0c, 0x5b, 0xf2, 0xa7, 0xa5, 0x7d, 0x40, 0x45, 0xc6, 0x46, 0x21, 0xda, 0x29, 0xbc,
	0x8f, 0xfd, 0x23, 0x02, 0xfa, 0xce, 0x5d, 0x49, 0xb6, 0xd5, 0xd2, 0x2f, 0x43, 0x50, 0x94, 0x8a,
	0x2e, 0x4e, 0x3c, 0x06, 0x44, 0x69, 0x41, 0x92, 0x15, 0x9a, 0x01, 0xff, 0x26, 0x21, 0xef, 0x1e,
	0xdf, 0x34, 0x22, 0x1c, 0x0f, 0x75, 0x0c, 0xb9, 0xc7, 0xe9, 0x22, 0x83, 0x2c, 0x13, 0x87, 0x08,
	0x6e, 0xe9, 0x78, 0x0e, 0xcd, 0xba, 0x4f, 0xf9, 0x57, 0x08, 0x8e, 0x2e, 0x71, 0x0f, 0xf8, 0x46,
	0xea, 0x4e, 0x95, 0x13, 0x5b, 0x07, 0x25, 0xda, 0x42, 0xfd, 0x9d, 0x5d, 0x15, 0xcd, 0xb6, 0x6d,
	0x54, 0xa6, 0xc8, 0x75, 0x82, 0x5c, 0x27, 0xc9, 0xf5, 0x0a, 0xb9, 0x4e, 0x91, 0xeb, 0x55, 0x72,
	0x9d, 0x6e, 0xd9, 0xd2, 0xec, 0x14, 0xf5, 0xcf, 0x34, 0x0b, 0xf5, 0x9e, 0xf6, 0x42, 0xbd, 0x51,
	0xa6, 0x1f, 0x9b, 0x85, 0x51, 0xad, 0xc7, 0x85, 0xaa, 0xd4, 0xde, 0x69, 0x0b, 0x13, 0xd4, 0x85,
	0xc9, 0xef, 0x78, 0x20, 0xaa, 0x73, 0x69, 0x08, 0xd2, 0xe6, 0xa7, 0x3b, 0x70, 0xeb, 0xae, 0x46,
	0x77, 0x7b, 0x70, 0xdc, 0xd5, 0xf0, 0x39, 0xec, 0x6a, 0xf4, 0x18, 0x23, 0x75, 0xaa, 0xfc, 0x38,
	0x6c, 0x13, 0xfd, 0xb6, 0x17, 0x86, 0xb4, 0xf9, 0x68, 0x9d, 0x0a, 0x1e, 0xa8, 0x6a, 0x4a, 0x13,
	0x64, 0xdc, 0xd7, 0x2d, 0x7c, 0xef, 0x37, 0x8c, 0x3b, 0xd8, 0x15, 0x46, 0x60, 0x1a, 0xcf, 0x26,
	0x12, 0x92, 0x60, 0x58, 0x17, 0x23, 0x57, 0x25, 0x8b, 0x28, 0xaf, 0xcb, 0x83, 0x0b, 0x9d, 0x0d,
	0x62, 0xa1, 0x87, 0xa5, 0x35, 0xd6, 0x85, 0xaa, 0xd4, 0x14, 0x78, 0x17, 0x06, 0xab, 0x29, 0x19,
	0xab, 0xde, 0x22, 0xcd, 0xe7, 0x16, 0xfc, 0x75, 0x30, 0x9c, 0x85, 0x1e, 0x96, 0xd2, 0xb9, 0x9a,
	0xf7, 0x33, 0x0c, 0x1c, 0xad, 0x12, 0xfa, 0x26, 0x83, 0x3d, 0x4f, 0x0f, 0xbc, 0x7d, 0x1c, 0xfa,
	0xe7, 0xab, 0xd2, 0x1a, 0x57, 0x2d, 0xd4, 0xf9, 0x12, 0x51, 0x44, 0xee, 0x19, 0xe4, 0xc7, 0x7a,
	0x42, 0x7c, 0xd6, 0x9a, 0x10, 0x0f, 0xff, 0xca, 0x26, 0xc3, 0x5f, 0x3f, 0x60, 0x32, 0xdc, 0xe1,
	0x25, 0xd4, 0xb6, 0x14, 0x59, 0x84, 0x11, 0x07, 0xd0, 0xc3, 0xcb, 0xd1, 0xb3, 0x9d, 0x84, 0x4c,
	0x59, 0x84, 0xbc, 0xa4, 0xaf, 0xf3, 0x8e, 0xb2, 0x86, 0xda, 0x70, 0xcf, 0x67, 0x29, 0xf9, 0x8b,
	0x99, 0x92, 0x3f, 0x84, 0x68, 0x9d, 0x6b, 0x58, 0xf6, 0x78, 0x2c, 0xe1, 0xa4, 0xd7, 0x85, 0xb3,
	0x9c, 0x79, 0xfc, 0x70, 0xb0, 0xad, 0xa5, 0xdd, 0x34, 0x10, 0x7b, 0x44, 0x13, 0x62, 0xef, 0xf7,
	0xa7, 0x56, 0x11, 0x38, 0xdb, 0x56, 0x11, 0x80, 0x4f, 0xbb, 0x1a, 0xf0, 0x35, 0x87, 0xcd, 0xe1,
	0x73, 0x07, 0xde, 0x1c, 0x6e, 0xdb, 0xf2, 0xad, 0x00, 0x6d, 0x49, 0xef, 0x8a, 0xe4, 0x74, 0xa5,
	0x1c, 0x3d, 0x7e, 0xc8, 0x2c, 0x8f, 0xa5, 0x9a, 0xd9, 0x1d, 0x79, 0x22, 0xd3, 0x5f, 0xb5, 0x40,
	0x57, 0x6d, 0x14, 0x27, 0x5c, 0x86, 0x44, 0x53, 0x59, 0x96, 0xb3, 0xf1, 0xe6, 0x8b, 0x29, 0xfa,
	0x30, 0xbe, 0x8f, 0x1c, 0x0e, 0xd4, 0xc6, 0x88, 0x42, 0x66, 0xf7, 0x14, 0xd0, 0xba, 0x24, 0x39,
	0x9e, 0xa0, 0x65, 0xf7, 0xf5, 0xf6, 0x6e, 0xe7, 0x03, 0xdb, 0x5d, 0xde, 0x67, 0xa4, 0x4f, 0xb4,
	0xec, 0x1e, 0xe2, 0x44, 0x35, 0x64, 0xdd, 0x25, 0x4c, 0x3b, 0x94, 0x85, 0x4e, 0x75, 0x45, 0x55,
	0x6d, 0x05, 0xa1, 0xdb, 0xcd, 0x82, 0xd0, 0xd8, 0x21, 0x0b, 0x42, 0x96, 0x52, 0x10, 0xad, 0xc0,
	0x08, 0x31, 0xd1, 0xb6, 0x65, 0xe9, 0xe5, 0x43, 0x25, 0xca, 0xcd, 0xdf, 0x00, 0x21, 0x59, 0x54,
	0xc1, 0xb6, 0x4e, 0x69, 0x52, 0x27, 0xdb, 0xa5, 0x9e, 0x79, 0x86, 0x52, 0x27, 0xed, 0x52, 0xbf,
	0x02, 0x40, 0x72, 0x17, 0xf2, 0xe3, 0x40, 0xd1, 0xd3, 0x2e, 0x1d, 0xb1, 0x3d, 0xb5, 0x6a, 0x8a,
	0x09, 0x13, 0x7e, 0x04, 0x0c, 0xad, 0xc2, 0x88, 0xbe, 0xc5, 0x4d, 0xf2, 0xd0, 0xa6, 0x9e, 0x2f,
	0xb8, 0xc9, 0xac, 0x11, 0x3b, 0x6c, 0x6d, 0x6d, 0x6a, 0x9d, 0x85, 0x96, 0xfb, 0x45, 0x5e, 0xd4,
	0x98, 0x26, 0xdc, 0x31, 0x1d, 0xb2, 0x36, 0xce, 0x6a, 0x6d, 0x69, 0x05, 0x86, 0xca, 0xc6, 0x69,
	0x2e, 0xcb, 0xd2, 0xf0, 0x51, 0xd0, 0xed, 0x4b, 0x61, 0x8e, 0x67, 0x48, 0x9b, 0x62, 0x3d, 0x2c,
	0x5d, 0x6e, 0x23, 0xa1, 0xff, 0x1f, 0xd0, 0xbc, 0xbe, 0xf9, 0x6c, 0x11, 0xfa, 0x34, 0xe8, 0xf2,
	0xad, 0x12, 0xc7, 0xf3, 0x62, 0x56, 0x99, 0x83, 0xbc, 0x9d, 0x82, 0xbe, 0x07, 0x94, 0xb6, 0x36,
	0x58, 0x04, 0xfe, 0x5b, 0xd0, 0x25, 0x88, 0x70, 0xd8, 0x58, 0xb5, 0x8a, 0x1b, 0x50, 0x5a, 0x9f,
	0xd3, 0xd3, 0x10, 0xa8, 0x92, 0x62, 0x6a, 0xf4, 0xdf, 0x83, 0x6e, 0x94, 0xe3, 0x61, 0x75, 0x7a,
	0xfa, 0x5b, 0x08, 0x62, 0x4d, 0x85, 0xd4, 0xcc, 0xe3, 0x75, 0x96, 0x5e, 0xff, 0x44, 0x63, 0x99,
	0x76, 0xaf, 0x9b, 0x0e, 0x07, 0x16, 0xad, 0xf2, 0x8f, 0x97, 0xbb, 0x10, 0x63, 0x7d, 0x55, 0xf5,
	0x32, 0x8d, 0xa5, 0x23, 0xff, 0xe1, 0x56, 0x5f, 0x8e, 0x95, 0xda, 0x16, 0x7d, 0x55, 0xed, 0x14,
	0x58, 0x5f, 0xf6, 0xb4, 0x24, 0xfa, 0xb1, 0x5b, 0x7d, 0x39, 0x64, 0x8a, 0x2d, 0xfa, 0xaa, 0xb6,
	0x3e, 0x7f, 0x06, 0x6f, 0xa0, 0x67, 0xce, 0x3a, 0xd5, 0xb0, 0x71, 0x02, 0x75, 0x6a, 0x47, 0x45,
	0x71, 0x52, 0x20, 0x9a, 0x60, 0x26, 0x26, 0x33, 0x17, 0x4d, 0x27, 0x2e, 0xd6, 0x36, 0xaa, 0x8a,
	0x50, 0xaf, 0xf2, 0x6f, 0x61, 0x24, 0x37, 0xb2, 0xad, 0xa2, 0x0b, 0x3b, 0x2a, 0x3a, 0x8f, 0x49,
	0x27, 0x93, 0xcc, 0x64, 0xea, 0x63, 0x15, 0xa1, 0xcc, 0x8c, 0x75, 0x39, 0xd4, 0xb9, 0x9e, 0xd9,
	0x56, 0xd1, 0x47, 0xc1, 0x1d, 0x15, 0x7d, 0x18, 0xdc, 0x55, 0xd1, 0x50, 0x72, 0x7c, 0x3c, 0xc9,
	0x24, 0xc7, 0xc7, 0x53, 0xf8, 0x32, 0x81, 0x2f, 0x93, 0xb8, 0xa9, 0x56, 0x29, 0x37, 0xcf, 0x08,
	0x0c, 0x51, 0xc3, 0x8b, 0xbe, 0xd0, 0x30, 0x35, 0xb2, 0xe8, 0x0b, 0x8d, 0x50, 0x47, 0xb4, 0x53,
	0x03, 0x8b, 0xbe, 0xd0, 0x51, 0x2a, 0xba, 0xe8, 0x0b, 0x45, 0xa9, 0x63, 0x8b, 0xbe, 0xd0, 0x31,
	0x6a, 0x74, 0xd1, 0x17, 0x1a, 0xa5, 0x5e, 0x5a, 0xf4, 0x85, 0x5e, 0xa2, 0x8e, 0x2f, 0xfa, 0x42,
	0x71, 0xea, 0xd4, 0xa2, 0x2f, 0x74, 0x9e, 0xba, 0xb0, 0x18, 0x08, 0x7d, 0x18, 0xa4, 0x3e, 0x0a,
	0x2e, 0x06, 0x42, 0x3f, 0x0d, 0x52, 0x1f, 0x07, 0xc7, 0xfe, 0x36, 0x00, 0xfd, 0xb3, 0x0d, 0x9e,
	0x53, 0x78, 0x33, 0x05, 0x7c, 0xd3, 0x39, 0x96, 0xd0, 0x87, 0x0a, 0x25, 0x38, 0x3f, 0x76, 0x88,
	0x20, 0x35, 0xc7, 0x08, 0x32, 0x74, 0xa8, 0x00, 0xe2, 0xd3, 0xcf, 0xf4, 0xbb, 0x8c, 0x1e, 0xc3,
	0x87, 0x08, 0x1e, 0x2d, 0xaf, 0x10, 0xd8, 0xa3, 0x87, 0x08, 0x94, 0x16, 0x0d, 0x2c, 0xc2, 0x46,
	0xdc, 0x5a, 0x7e, 0xfb, 0xd6, 0x35, 0x79, 0x77, 0x60, 0xa7, 0xf9, 0xee, 0xc0, 0x40, 0xb5, 0x95,
	0xc6, 0x4d, 0xcc, 0x39, 0xf2, 0xac, 0x42, 0x8e, 0x75, 0xe0, 0xdd, 0x63, 0x0e, 0xe7, 0x10, 0x00,
	0xa2, 0x07, 0xf7, 0x7f, 0x32, 0xf0, 0xd6, 0xdb, 0xd7, 0x5e, 0xf9, 0xe1, 0x6b, 0xb6, 0x32, 0xc6,
	0x13, 0x15, 0x1d, 0x81, 0x61, 0xe8, 0x6f, 0xbe, 0xaa, 0x4e, 0x2c, 0xdb, 0x93, 0xbc, 0x9a, 0xb9,
	0xee, 0xe0, 0x89, 0xe7, 0xf4, 0xd3, 0x3d, 0x83, 0xbb, 0x2a, 0x1a, 0x4c, 0xce, 0x30, 0xc9, 0x69,
	0x26, 0x35, 0xce, 0xa4, 0x52, 0x4c, 0x2a, 0xc9, 0xa4, 0x26, 0xdf, 0xf9, 0x04, 0x05, 0x5e, 0x15,
	0x25, 0x91, 0x7f, 0xcd, 0xf4, 0xc5, 0xa3, 0x54, 0x74, 0xec, 0x7b, 0x01, 0x18, 0x60, 0xf9, 0x7a,
	0x95, 0x2b, 0xfd, 0x9f, 0x70, 0x9d, 0xca, 0x33, 0x76, 0x1d, 0x5f, 0x27, 0xb7, 0xa9, 0x3c, 0x63,
	0xb7, 0x31, 0x05, 0x7d, 0xe6, 0x2f, 0x9f, 0xaa, 0xbf, 0xbc, 0x47, 0x43, 0x64, 0x9e, 0x57, 0x7e,
	0x19, 0x95, 0x46, 0xca, 0x52, 0x69, 0xfc, 0xec, 0x80, 0xcd, 0x67, 0x07, 0x6c, 0x3e, 0xab, 0xe6,
	0x7d, 0x56, 0xcd, 0x73, 0x57, 0xcd, 0x7b, 0xb3, 0x63, 0x99, 0xea, 0xc6, 0xde, 0x65, 0xaa, 0x66,
	0x30, 0x73, 0xaa, 0x51, 0xfd, 0xea, 0xd4, 0x93, 0x7e, 0x39, 0xa8, 0x06, 0x3d, 0x67, 0x54, 0x83,
	0x9e, 0x1f, 0xaa, 0x41, 0xcf, 0x0b, 0xd5, 0xa0, 0x17, 0x05, 0xd5, 0xa0, 0xe7, 0x8c, 0x6a, 0xd0,
	0x2f, 0x23, 0xf9, 0xdf, 0x1f, 0x30, 0x72, 0x3e, 0xed, 0xf6, 0xce, 0x27, 0xa8, 0xfd, 0xf6, 0x61,
	0x41, 0x94, 0x96, 0xbe, 0x37, 0xa1, 0xd4, 0x9b, 0xed, 0xbf, 0x79, 0x5d, 0x50, 0x38, 0x65, 0x43,
	0xa6, 0x57, 0x20, 0xb8, 0x51, 0x2f, 0x96, 0xa5, 0xfb, 0xa2, 0x8e, 0xab, 0xf6, 0x1f, 0xb4, 0x6f,
	0xd7, 0xe7, 0xa4, 0xfb, 0x22, 0x1b, 0xd8, 0x20, 0x7f, 0x13, 0x92, 0xf6, 0x23, 0x9d, 0xb6, 0xdf,
	0x70, 0xa5, 0xcf, 0xc3, 0xe9, 0x5c, 0x7e, 0x76, 0xe9, 0xf6, 0x5c, 0xb6, 0x98, 0x5b, 0x29, 0xa6,
	0xe7, 0xe6, 0xd8, 0x6c, 0xa1, 0x90, 0x2d, 0x14, 0x6f, 0xb2, 0xcb, 0xb7, 0x8a, 0x64, 0xf1, 0x5e,
	0x59, 0x5e, 0x5e, 0x2a, 0x50, 0x3d, 0x98, 0x32, 0xfb, 0x25, 0x17, 0x94, 0x88, 0xfc, 0xe2, 0x43,
	0x4f, 0xe2, 0x29, 0x82, 0x61, 0xa7, 0x2d, 0x06, 0xfa, 0x14, 0x9c, 0xc8, 0x67, 0x57, 0x5f, 0x5f,
	0x66, 0xbf, 0x50, 0xcc, 0xe5, 0x57, 0xb3, 0xec, 0xcd, 0xf4, 0x6c, 0xb6, 0x68, 0xdc, 0x61, 0xb3,
	0x37, 0xa9, 0x1e, 0x3a, 0x0e, 0xc7, 0xdb, 0x49, 0x0a, 0xb9, 0xd5, 0x6c, 0x71, 0x69, 0x79, 0x36,
	0xbd, 0x44, 0x21, 0xfa, 0x1c, 0xbc, 0xdc, 0x8d, 0xa2, 0x98, 0xcb, 0x17, 0x72, 0x73, 0x59, 0xca,
	0x43, 0x9f, 0x80, 0x63, 0x0e, 0x84, 0xab, 0xcb, 0x6c, 0x7a, 0x3e, 0x4b, 0x79, 0x9d, 0x25, 0xdd,
	0x4a, 0xe7, 0xd3, 0xf3, 0xd9, 0x5b, 0xd9, 0xfc, 0x2a, 0xe5, 0xa3, 0x5f, 0x86, 0xd1, 0x76, 0x8a,
	0xdc, 0xca, 0xcd, 0x74, 0x86, 0xcd, 0xcd, 0x52, 0xfe, 0x51, 0xef, 0xdb, 0x0f, 0x51, 0xe2, 0x1b,
	0x9e, 0xf6, 0x9f, 0x92, 0x27, 0x83, 0x8d, 0x39, 0xb5, 0xce, 0xae, 0x2e, 0x64, 0xd9, 0x7c, 0x76,
	0x95, 0xea, 0xa1, 0x4f, 0x43, 0xbc, 0xfd, 0x39, 0x46, 0x24, 0xcd, 0xaf, 0x14, 0x72, 0xa6, 0x5a,
	0x4a, 0xcf, 0xae, 0x58, 0xa8, 0x3c, 0xf4, 0x59, 0x18, 0x6b, 0xa7, 0x5a, 0xbd, 0x9d, 0xcf, 0x67,
	0x97, 0x2c, 0x74, 0x5e, 0xfa, 0x22, 0x9c, 0x76, 0xe0, 0xb6, 0xbc, 0xbc, 0x92, 0x49, 0xcf, 0x5a,
	0x6e, 0x51, 0x3e, 0x32, 0x36, 0x67, 0xb6, 0x4b, 0xe9, 0x37, 0xb2, 0x6c, 0xca, 0x42, 0xec, 0x4f,
	0x7c, 0xcd, 0xe1, 0xd7, 0xf4, 0x17, 0x66, 0x57, 0xe8, 0x31, 0x88, 0xb5, 0xb7, 0x27, 0x06, 0x33,
	0x97, 0x2b, 0xa4, 0x33, 0x4b, 0x59, 0xaa, 0xc7, 0xd9, 0x26, 0x08, 0x4d, 0x36, 0x4f, 0x48, 0x50,
	0x42, 0x81, 0x97, 0xba, 0x20, 0x37, 0x3a, 0x01, 0x67, 0x3b, 0x4c, 0xe4, 0x6a, 0x7a, 0x7e, 0x3e,
	0x97, 0x9f, 0xb7, 0x48, 0xbb, 0x00, 0x67, 0xf6, 0xa0, 0x35, 0xa5, 0xfe, 0x29, 0x6a, 0x17, 0x6b,
	0xfd, 0xe9, 0xfe, 0x33, 0x70, 0xaa, 0x9d, 0xd5, 0x7c, 0x7a, 0x35, 0xfb, 0x7a, 0xfa, 0x0d, 0x8b,
	0xc4, 0x57, 0xe0, 0x5c, 0x67, 0xb2, 0xf4, 0xed, 0xd5, 0xe5, 0x62, 0x7a, 0x09, 0x1b, 0xee, 0x2a,
	0xd6, 0x36, 0x03, 0xe7, 0x3b, 0x13, 0xdf, 0x2e, 0x64, 0x8b, 0xb3, 0xcb, 0xf9, 0x9b, 0xb9, 0xf9,
	0xdb, 0x6c, 0x76, 0x8e, 0xf2, 0x24, 0x7e, 0x0f, 0xc1, 0xd1, 0x0e, 0x3f, 0xce, 0xdf, 0x61, 0x5a,
	0xf3, 0x05, 0x4b, 0xcf, 0x1c, 0x1d, 0x09, 0x93, 0xd8, 0x7b, 0x75, 0xde, 0xc9, 0x6a, 0x30, 0x61,
	0x5b, 0x8f, 0xfe, 0x1c, 0xc1, 0x68, 0x67, 0x0c, 0xef, 0x3c, 0xfb, 0x44, 0xd7, 0x85, 0x2c, 0x7b,
	0x27, 0xcb, 0x5a, 0x3a, 0xe7, 0x2c, 0xd3, 0x42, 0x6a, 0xe8, 0x89, 0x4e, 0xc2, 0x45, 0x07, 0x3f,
	0xcb, 0x2f, 0xa4, 0xf3, 0xb3, 0xd9, 0x39, 0xa7, 0x26, 0x9e, 0xc4, 0x1f, 0xa2, 0xf6, 0xf0, 0xab,
	0x05, 0x4d, 0x67, 0x75, 0xa5, 0xe7, 0x6e, 0xe5, 0xf2, 0xb9, 0xc2, 0x2a, 0x9b, 0x5e, 0xcd, 0xdd,
	0xc9, 0x2e, 0xbd, 0x51, 0x9c, 0x5b, 0x7e, 0x3d, 0xdf, 0x69, 0x06, 0x97, 0x57, 0xb2, 0x98, 0x6e,
	0x39, 0x9f, 0x36, 0x08, 0x91, 0xb3, 0xad, 0xb4, 0x10, 0xde, 0x5e, 0xa1, 0x3c, 0x99, 0x6f, 0xa1,
	0x9d, 0x1f, 0xc7, 0x7a, 0xde, 0xff, 0x71, 0xac, 0xe7, 0xe3, 0x1f, 0xc7, 0xd0, 0xdb, 0xbb, 0x31,
	0xf4, 0xed, 0xdd, 0x18, 0x7a, 0x6f, 0x37, 0x86, 0x76, 0x76, 0x63, 0xe8, 0xfd, 0xdd, 0x18, 0xfa,
	0xd1, 0x6e, 0x0c, 0x7d, 0xb8, 0x1b, 0xeb, 0xf9, 0x78, 0x37, 0x86, 0x7e, 0xff, 0x83, 0x58, 0xcf,
	0xf6, 0x07, 0x31, 0xb4, 0xf3, 0x41, 0xac, 0xe7, 0xfd, 0x0f, 0x62, 0x3d, 0x5f, 0xbe, 0x5d, 0x91,
	0xea, 0xf7, 0x2a, 0x97, 0x36, 0xa5, 0xaa, 0xc2, 0x37, 0x1a, 0xdc, 0xa5, 0x0d, 0xf9, 0x32, 0xf9,
	0xb0, 0x2e, 0x35, 0x6a, 0x17, 0xeb, 0x0d, 0x69, 0x53, 0x28, 0xf3, 0x8d, 0x8b, 0xc6, 0xe3, 0xcb,
	0xf5, 0xb5, 0x8a, 0x74, 0x99, 0x7f, 0x4b, 0xd1, 0xff, 0x4b, 0x46, 0xa7, 0x7f, 0x3d, 0xb2, 0x16,
	0x20, 0xff, 0x33, 0x63, 0xe2, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xd6, 0x78, 0x63, 0xa1, 0xa4,
	0x64, 0x00, 0x00,
}

func (x DHCPPoolSettingType) String() string {
	s, ok := DHCPPoolSettingType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x InterfaceNetworkType) String() string {
	s, ok := InterfaceNetworkType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NetworkInterfaceType) String() string {
	s, ok := NetworkInterfaceType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NetworkInterfaceDHCP) String() string {
	s, ok := NetworkInterfaceDHCP_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NetworkInterfaceVLANTagging) String() string {
	s, ok := NetworkInterfaceVLANTagging_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NetworkInterfaceGatewayMode) String() string {
	s, ok := NetworkInterfaceGatewayMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NetworkInterfaceDNSMode) String() string {
	s, ok := NetworkInterfaceDNSMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NetworkInterfaceDHCPServer) String() string {
	s, ok := NetworkInterfaceDHCPServer_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NetworkInterfaceUpDown) String() string {
	s, ok := NetworkInterfaceUpDown_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *NetworkInterfaceDFGW) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkInterfaceDFGW)
	if !ok {
		that2, ok := that.(NetworkInterfaceDFGW)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DefaultGatewayMode != that1.DefaultGatewayMode {
		return false
	}
	if !this.DefaultGatewayAddress.Equal(that1.DefaultGatewayAddress) {
		return false
	}
	return true
}
func (this *NetworkInterfaceDNS) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkInterfaceDNS)
	if !ok {
		that2, ok := that.(NetworkInterfaceDNS)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DnsMode != that1.DnsMode {
		return false
	}
	if len(this.DnsServer) != len(that1.DnsServer) {
		return false
	}
	for i := range this.DnsServer {
		if !this.DnsServer[i].Equal(that1.DnsServer[i]) {
			return false
		}
	}
	return true
}
func (this *NetworkInterfaceTunnel) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkInterfaceTunnel)
	if !ok {
		that2, ok := that.(NetworkInterfaceTunnel)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Tunnel) != len(that1.Tunnel) {
		return false
	}
	for i := range this.Tunnel {
		if !this.Tunnel[i].Equal(that1.Tunnel[i]) {
			return false
		}
	}
	return true
}
func (this *DHCPPoolType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPPoolType)
	if !ok {
		that2, ok := that.(DHCPPoolType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StartIp != that1.StartIp {
		return false
	}
	if this.EndIp != that1.EndIp {
		return false
	}
	if this.Exclude != that1.Exclude {
		return false
	}
	return true
}
func (this *DHCPIPV6PoolType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPIPV6PoolType)
	if !ok {
		that2, ok := that.(DHCPIPV6PoolType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StartIp != that1.StartIp {
		return false
	}
	if this.EndIp != that1.EndIp {
		return false
	}
	if this.Exclude != that1.Exclude {
		return false
	}
	return true
}
func (this *DHCPIPV6NetworkType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPIPV6NetworkType)
	if !ok {
		that2, ok := that.(DHCPIPV6NetworkType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.NetworkPrefixChoice == nil {
		if this.NetworkPrefixChoice != nil {
			return false
		}
	} else if this.NetworkPrefixChoice == nil {
		return false
	} else if !this.NetworkPrefixChoice.Equal(that1.NetworkPrefixChoice) {
		return false
	}
	if len(this.Pools) != len(that1.Pools) {
		return false
	}
	for i := range this.Pools {
		if !this.Pools[i].Equal(that1.Pools[i]) {
			return false
		}
	}
	return true
}
func (this *DHCPIPV6NetworkType_NetworkPrefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPIPV6NetworkType_NetworkPrefix)
	if !ok {
		that2, ok := that.(DHCPIPV6NetworkType_NetworkPrefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NetworkPrefix != that1.NetworkPrefix {
		return false
	}
	return true
}
func (this *DHCPIPV6NetworkType_NetworkPrefixAllocator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPIPV6NetworkType_NetworkPrefixAllocator)
	if !ok {
		that2, ok := that.(DHCPIPV6NetworkType_NetworkPrefixAllocator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NetworkPrefixAllocator.Equal(that1.NetworkPrefixAllocator) {
		return false
	}
	return true
}
func (this *DHCPNetworkType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPNetworkType)
	if !ok {
		that2, ok := that.(DHCPNetworkType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.NetworkPrefixChoice == nil {
		if this.NetworkPrefixChoice != nil {
			return false
		}
	} else if this.NetworkPrefixChoice == nil {
		return false
	} else if !this.NetworkPrefixChoice.Equal(that1.NetworkPrefixChoice) {
		return false
	}
	if len(this.Pools) != len(that1.Pools) {
		return false
	}
	for i := range this.Pools {
		if !this.Pools[i].Equal(that1.Pools[i]) {
			return false
		}
	}
	if that1.GatewayChoice == nil {
		if this.GatewayChoice != nil {
			return false
		}
	} else if this.GatewayChoice == nil {
		return false
	} else if !this.GatewayChoice.Equal(that1.GatewayChoice) {
		return false
	}
	if that1.DnsChoice == nil {
		if this.DnsChoice != nil {
			return false
		}
	} else if this.DnsChoice == nil {
		return false
	} else if !this.DnsChoice.Equal(that1.DnsChoice) {
		return false
	}
	if this.PoolSettings != that1.PoolSettings {
		return false
	}
	return true
}
func (this *DHCPNetworkType_NetworkPrefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPNetworkType_NetworkPrefix)
	if !ok {
		that2, ok := that.(DHCPNetworkType_NetworkPrefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NetworkPrefix != that1.NetworkPrefix {
		return false
	}
	return true
}
func (this *DHCPNetworkType_NetworkPrefixAllocator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPNetworkType_NetworkPrefixAllocator)
	if !ok {
		that2, ok := that.(DHCPNetworkType_NetworkPrefixAllocator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NetworkPrefixAllocator.Equal(that1.NetworkPrefixAllocator) {
		return false
	}
	return true
}
func (this *DHCPNetworkType_FirstAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPNetworkType_FirstAddress)
	if !ok {
		that2, ok := that.(DHCPNetworkType_FirstAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FirstAddress.Equal(that1.FirstAddress) {
		return false
	}
	return true
}
func (this *DHCPNetworkType_LastAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPNetworkType_LastAddress)
	if !ok {
		that2, ok := that.(DHCPNetworkType_LastAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LastAddress.Equal(that1.LastAddress) {
		return false
	}
	return true
}
func (this *DHCPNetworkType_DgwAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPNetworkType_DgwAddress)
	if !ok {
		that2, ok := that.(DHCPNetworkType_DgwAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DgwAddress != that1.DgwAddress {
		return false
	}
	return true
}
func (this *DHCPNetworkType_SameAsDgw) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPNetworkType_SameAsDgw)
	if !ok {
		that2, ok := that.(DHCPNetworkType_SameAsDgw)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SameAsDgw.Equal(that1.SameAsDgw) {
		return false
	}
	return true
}
func (this *DHCPNetworkType_DnsAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPNetworkType_DnsAddress)
	if !ok {
		that2, ok := that.(DHCPNetworkType_DnsAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DnsAddress != that1.DnsAddress {
		return false
	}
	return true
}
func (this *DHCPInterfaceIPType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPInterfaceIPType)
	if !ok {
		that2, ok := that.(DHCPInterfaceIPType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.InterfaceIpMap) != len(that1.InterfaceIpMap) {
		return false
	}
	for i := range this.InterfaceIpMap {
		if this.InterfaceIpMap[i] != that1.InterfaceIpMap[i] {
			return false
		}
	}
	return true
}
func (this *DHCPInterfaceIPV6Type) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPInterfaceIPV6Type)
	if !ok {
		that2, ok := that.(DHCPInterfaceIPV6Type)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.InterfaceIpMap) != len(that1.InterfaceIpMap) {
		return false
	}
	for i := range this.InterfaceIpMap {
		if this.InterfaceIpMap[i] != that1.InterfaceIpMap[i] {
			return false
		}
	}
	return true
}
func (this *DHCPServerParametersType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPServerParametersType)
	if !ok {
		that2, ok := that.(DHCPServerParametersType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.DhcpNetworks) != len(that1.DhcpNetworks) {
		return false
	}
	for i := range this.DhcpNetworks {
		if !this.DhcpNetworks[i].Equal(that1.DhcpNetworks[i]) {
			return false
		}
	}
	if that1.InterfacesAddressingChoice == nil {
		if this.InterfacesAddressingChoice != nil {
			return false
		}
	} else if this.InterfacesAddressingChoice == nil {
		return false
	} else if !this.InterfacesAddressingChoice.Equal(that1.InterfacesAddressingChoice) {
		return false
	}
	if len(this.FixedIpMap) != len(that1.FixedIpMap) {
		return false
	}
	for i := range this.FixedIpMap {
		if this.FixedIpMap[i] != that1.FixedIpMap[i] {
			return false
		}
	}
	if this.DhcpOption82Tag != that1.DhcpOption82Tag {
		return false
	}
	return true
}
func (this *DHCPServerParametersType_AutomaticFromStart) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPServerParametersType_AutomaticFromStart)
	if !ok {
		that2, ok := that.(DHCPServerParametersType_AutomaticFromStart)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AutomaticFromStart.Equal(that1.AutomaticFromStart) {
		return false
	}
	return true
}
func (this *DHCPServerParametersType_AutomaticFromEnd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPServerParametersType_AutomaticFromEnd)
	if !ok {
		that2, ok := that.(DHCPServerParametersType_AutomaticFromEnd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AutomaticFromEnd.Equal(that1.AutomaticFromEnd) {
		return false
	}
	return true
}
func (this *DHCPServerParametersType_InterfaceIpMap) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPServerParametersType_InterfaceIpMap)
	if !ok {
		that2, ok := that.(DHCPServerParametersType_InterfaceIpMap)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InterfaceIpMap.Equal(that1.InterfaceIpMap) {
		return false
	}
	return true
}
func (this *IPV6AutoConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IPV6AutoConfigType)
	if !ok {
		that2, ok := that.(IPV6AutoConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AutoconfigChoice == nil {
		if this.AutoconfigChoice != nil {
			return false
		}
	} else if this.AutoconfigChoice == nil {
		return false
	} else if !this.AutoconfigChoice.Equal(that1.AutoconfigChoice) {
		return false
	}
	return true
}
func (this *IPV6AutoConfigType_Host) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IPV6AutoConfigType_Host)
	if !ok {
		that2, ok := that.(IPV6AutoConfigType_Host)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Host.Equal(that1.Host) {
		return false
	}
	return true
}
func (this *IPV6AutoConfigType_Router) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IPV6AutoConfigType_Router)
	if !ok {
		that2, ok := that.(IPV6AutoConfigType_Router)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Router.Equal(that1.Router) {
		return false
	}
	return true
}
func (this *IPV6AutoConfigRouterType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IPV6AutoConfigRouterType)
	if !ok {
		that2, ok := that.(IPV6AutoConfigRouterType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AddressChoice == nil {
		if this.AddressChoice != nil {
			return false
		}
	} else if this.AddressChoice == nil {
		return false
	} else if !this.AddressChoice.Equal(that1.AddressChoice) {
		return false
	}
	if !this.DnsConfig.Equal(that1.DnsConfig) {
		return false
	}
	return true
}
func (this *IPV6AutoConfigRouterType_NetworkPrefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IPV6AutoConfigRouterType_NetworkPrefix)
	if !ok {
		that2, ok := that.(IPV6AutoConfigRouterType_NetworkPrefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NetworkPrefix != that1.NetworkPrefix {
		return false
	}
	return true
}
func (this *IPV6AutoConfigRouterType_Stateful) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IPV6AutoConfigRouterType_Stateful)
	if !ok {
		that2, ok := that.(IPV6AutoConfigRouterType_Stateful)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Stateful.Equal(that1.Stateful) {
		return false
	}
	return true
}
func (this *IPV6DnsList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IPV6DnsList)
	if !ok {
		that2, ok := that.(IPV6DnsList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.DnsList) != len(that1.DnsList) {
		return false
	}
	for i := range this.DnsList {
		if this.DnsList[i] != that1.DnsList[i] {
			return false
		}
	}
	return true
}
func (this *IPV6LocalDnsAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IPV6LocalDnsAddress)
	if !ok {
		that2, ok := that.(IPV6LocalDnsAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.LocalDnsChoice == nil {
		if this.LocalDnsChoice != nil {
			return false
		}
	} else if this.LocalDnsChoice == nil {
		return false
	} else if !this.LocalDnsChoice.Equal(that1.LocalDnsChoice) {
		return false
	}
	return true
}
func (this *IPV6LocalDnsAddress_FirstAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IPV6LocalDnsAddress_FirstAddress)
	if !ok {
		that2, ok := that.(IPV6LocalDnsAddress_FirstAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FirstAddress.Equal(that1.FirstAddress) {
		return false
	}
	return true
}
func (this *IPV6LocalDnsAddress_LastAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IPV6LocalDnsAddress_LastAddress)
	if !ok {
		that2, ok := that.(IPV6LocalDnsAddress_LastAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LastAddress.Equal(that1.LastAddress) {
		return false
	}
	return true
}
func (this *IPV6LocalDnsAddress_ConfiguredAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IPV6LocalDnsAddress_ConfiguredAddress)
	if !ok {
		that2, ok := that.(IPV6LocalDnsAddress_ConfiguredAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ConfiguredAddress != that1.ConfiguredAddress {
		return false
	}
	return true
}
func (this *IPV6DnsConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IPV6DnsConfig)
	if !ok {
		that2, ok := that.(IPV6DnsConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.DnsChoice == nil {
		if this.DnsChoice != nil {
			return false
		}
	} else if this.DnsChoice == nil {
		return false
	} else if !this.DnsChoice.Equal(that1.DnsChoice) {
		return false
	}
	return true
}
func (this *IPV6DnsConfig_LocalDns) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IPV6DnsConfig_LocalDns)
	if !ok {
		that2, ok := that.(IPV6DnsConfig_LocalDns)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LocalDns.Equal(that1.LocalDns) {
		return false
	}
	return true
}
func (this *IPV6DnsConfig_ConfiguredList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IPV6DnsConfig_ConfiguredList)
	if !ok {
		that2, ok := that.(IPV6DnsConfig_ConfiguredList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ConfiguredList.Equal(that1.ConfiguredList) {
		return false
	}
	return true
}
func (this *DHCPIPV6StatefulServer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPIPV6StatefulServer)
	if !ok {
		that2, ok := that.(DHCPIPV6StatefulServer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.DhcpNetworks) != len(that1.DhcpNetworks) {
		return false
	}
	for i := range this.DhcpNetworks {
		if !this.DhcpNetworks[i].Equal(that1.DhcpNetworks[i]) {
			return false
		}
	}
	if that1.InterfacesAddressingChoice == nil {
		if this.InterfacesAddressingChoice != nil {
			return false
		}
	} else if this.InterfacesAddressingChoice == nil {
		return false
	} else if !this.InterfacesAddressingChoice.Equal(that1.InterfacesAddressingChoice) {
		return false
	}
	if len(this.FixedIpMap) != len(that1.FixedIpMap) {
		return false
	}
	for i := range this.FixedIpMap {
		if this.FixedIpMap[i] != that1.FixedIpMap[i] {
			return false
		}
	}
	return true
}
func (this *DHCPIPV6StatefulServer_AutomaticFromStart) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPIPV6StatefulServer_AutomaticFromStart)
	if !ok {
		that2, ok := that.(DHCPIPV6StatefulServer_AutomaticFromStart)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AutomaticFromStart.Equal(that1.AutomaticFromStart) {
		return false
	}
	return true
}
func (this *DHCPIPV6StatefulServer_AutomaticFromEnd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPIPV6StatefulServer_AutomaticFromEnd)
	if !ok {
		that2, ok := that.(DHCPIPV6StatefulServer_AutomaticFromEnd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AutomaticFromEnd.Equal(that1.AutomaticFromEnd) {
		return false
	}
	return true
}
func (this *DHCPIPV6StatefulServer_InterfaceIpMap) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DHCPIPV6StatefulServer_InterfaceIpMap)
	if !ok {
		that2, ok := that.(DHCPIPV6StatefulServer_InterfaceIpMap)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InterfaceIpMap.Equal(that1.InterfaceIpMap) {
		return false
	}
	return true
}
func (this *StaticIpParametersNodeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StaticIpParametersNodeType)
	if !ok {
		that2, ok := that.(StaticIpParametersNodeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IpAddress != that1.IpAddress {
		return false
	}
	if this.DefaultGw != that1.DefaultGw {
		return false
	}
	if this.DnsServer != that1.DnsServer {
		return false
	}
	return true
}
func (this *StaticIpParametersClusterType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StaticIpParametersClusterType)
	if !ok {
		that2, ok := that.(StaticIpParametersClusterType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.InterfaceIpMap) != len(that1.InterfaceIpMap) {
		return false
	}
	for i := range this.InterfaceIpMap {
		if !this.InterfaceIpMap[i].Equal(that1.InterfaceIpMap[i]) {
			return false
		}
	}
	return true
}
func (this *StaticIpParametersFleetType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StaticIpParametersFleetType)
	if !ok {
		that2, ok := that.(StaticIpParametersFleetType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NetworkPrefixAllocator.Equal(that1.NetworkPrefixAllocator) {
		return false
	}
	if this.DefaultGw != that1.DefaultGw {
		return false
	}
	if this.DnsServer != that1.DnsServer {
		return false
	}
	return true
}
func (this *StaticIPParametersType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StaticIPParametersType)
	if !ok {
		that2, ok := that.(StaticIPParametersType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.NetworkPrefixChoice == nil {
		if this.NetworkPrefixChoice != nil {
			return false
		}
	} else if this.NetworkPrefixChoice == nil {
		return false
	} else if !this.NetworkPrefixChoice.Equal(that1.NetworkPrefixChoice) {
		return false
	}
	return true
}
func (this *StaticIPParametersType_NodeStaticIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StaticIPParametersType_NodeStaticIp)
	if !ok {
		that2, ok := that.(StaticIPParametersType_NodeStaticIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NodeStaticIp.Equal(that1.NodeStaticIp) {
		return false
	}
	return true
}
func (this *StaticIPParametersType_ClusterStaticIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StaticIPParametersType_ClusterStaticIp)
	if !ok {
		that2, ok := that.(StaticIPParametersType_ClusterStaticIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClusterStaticIp.Equal(that1.ClusterStaticIp) {
		return false
	}
	return true
}
func (this *StaticIPParametersType_FleetStaticIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StaticIPParametersType_FleetStaticIp)
	if !ok {
		that2, ok := that.(StaticIPParametersType_FleetStaticIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FleetStaticIp.Equal(that1.FleetStaticIp) {
		return false
	}
	return true
}
func (this *DedicatedInterfaceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DedicatedInterfaceType)
	if !ok {
		that2, ok := that.(DedicatedInterfaceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Device != that1.Device {
		return false
	}
	if that1.NodeChoice == nil {
		if this.NodeChoice != nil {
			return false
		}
	} else if this.NodeChoice == nil {
		return false
	} else if !this.NodeChoice.Equal(that1.NodeChoice) {
		return false
	}
	if this.Mtu != that1.Mtu {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if that1.PrimaryChoice == nil {
		if this.PrimaryChoice != nil {
			return false
		}
	} else if this.PrimaryChoice == nil {
		return false
	} else if !this.PrimaryChoice.Equal(that1.PrimaryChoice) {
		return false
	}
	if that1.MonitoringChoice == nil {
		if this.MonitoringChoice != nil {
			return false
		}
	} else if this.MonitoringChoice == nil {
		return false
	} else if !this.MonitoringChoice.Equal(that1.MonitoringChoice) {
		return false
	}
	return true
}
func (this *DedicatedInterfaceType_Cluster) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DedicatedInterfaceType_Cluster)
	if !ok {
		that2, ok := that.(DedicatedInterfaceType_Cluster)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Cluster.Equal(that1.Cluster) {
		return false
	}
	return true
}
func (this *DedicatedInterfaceType_Node) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DedicatedInterfaceType_Node)
	if !ok {
		that2, ok := that.(DedicatedInterfaceType_Node)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Node != that1.Node {
		return false
	}
	return true
}
func (this *DedicatedInterfaceType_NotPrimary) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DedicatedInterfaceType_NotPrimary)
	if !ok {
		that2, ok := that.(DedicatedInterfaceType_NotPrimary)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NotPrimary.Equal(that1.NotPrimary) {
		return false
	}
	return true
}
func (this *DedicatedInterfaceType_IsPrimary) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DedicatedInterfaceType_IsPrimary)
	if !ok {
		that2, ok := that.(DedicatedInterfaceType_IsPrimary)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IsPrimary.Equal(that1.IsPrimary) {
		return false
	}
	return true
}
func (this *DedicatedInterfaceType_MonitorDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DedicatedInterfaceType_MonitorDisabled)
	if !ok {
		that2, ok := that.(DedicatedInterfaceType_MonitorDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MonitorDisabled.Equal(that1.MonitorDisabled) {
		return false
	}
	return true
}
func (this *DedicatedInterfaceType_Monitor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DedicatedInterfaceType_Monitor)
	if !ok {
		that2, ok := that.(DedicatedInterfaceType_Monitor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Monitor.Equal(that1.Monitor) {
		return false
	}
	return true
}
func (this *DedicatedManagementInterfaceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DedicatedManagementInterfaceType)
	if !ok {
		that2, ok := that.(DedicatedManagementInterfaceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Device != that1.Device {
		return false
	}
	if that1.NodeChoice == nil {
		if this.NodeChoice != nil {
			return false
		}
	} else if this.NodeChoice == nil {
		return false
	} else if !this.NodeChoice.Equal(that1.NodeChoice) {
		return false
	}
	if this.Mtu != that1.Mtu {
		return false
	}
	return true
}
func (this *DedicatedManagementInterfaceType_Cluster) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DedicatedManagementInterfaceType_Cluster)
	if !ok {
		that2, ok := that.(DedicatedManagementInterfaceType_Cluster)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Cluster.Equal(that1.Cluster) {
		return false
	}
	return true
}
func (this *DedicatedManagementInterfaceType_Node) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DedicatedManagementInterfaceType_Node)
	if !ok {
		that2, ok := that.(DedicatedManagementInterfaceType_Node)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Node != that1.Node {
		return false
	}
	return true
}
func (this *EthernetInterfaceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType)
	if !ok {
		that2, ok := that.(EthernetInterfaceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Device != that1.Device {
		return false
	}
	if that1.NodeChoice == nil {
		if this.NodeChoice != nil {
			return false
		}
	} else if this.NodeChoice == nil {
		return false
	} else if !this.NodeChoice.Equal(that1.NodeChoice) {
		return false
	}
	if that1.VlanChoice == nil {
		if this.VlanChoice != nil {
			return false
		}
	} else if this.VlanChoice == nil {
		return false
	} else if !this.VlanChoice.Equal(that1.VlanChoice) {
		return false
	}
	if that1.AddressChoice == nil {
		if this.AddressChoice != nil {
			return false
		}
	} else if this.AddressChoice == nil {
		return false
	} else if !this.AddressChoice.Equal(that1.AddressChoice) {
		return false
	}
	if that1.Ipv6AddressChoice == nil {
		if this.Ipv6AddressChoice != nil {
			return false
		}
	} else if this.Ipv6AddressChoice == nil {
		return false
	} else if !this.Ipv6AddressChoice.Equal(that1.Ipv6AddressChoice) {
		return false
	}
	if that1.NetworkChoice == nil {
		if this.NetworkChoice != nil {
			return false
		}
	} else if this.NetworkChoice == nil {
		return false
	} else if !this.NetworkChoice.Equal(that1.NetworkChoice) {
		return false
	}
	if this.Mtu != that1.Mtu {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if that1.PrimaryChoice == nil {
		if this.PrimaryChoice != nil {
			return false
		}
	} else if this.PrimaryChoice == nil {
		return false
	} else if !this.PrimaryChoice.Equal(that1.PrimaryChoice) {
		return false
	}
	if that1.MonitoringChoice == nil {
		if this.MonitoringChoice != nil {
			return false
		}
	} else if this.MonitoringChoice == nil {
		return false
	} else if !this.MonitoringChoice.Equal(that1.MonitoringChoice) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_Cluster) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_Cluster)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_Cluster)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Cluster.Equal(that1.Cluster) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_Node) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_Node)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_Node)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Node != that1.Node {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_Untagged) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_Untagged)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_Untagged)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Untagged.Equal(that1.Untagged) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_VlanId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_VlanId)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_VlanId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VlanId != that1.VlanId {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_DhcpClient) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_DhcpClient)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_DhcpClient)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DhcpClient.Equal(that1.DhcpClient) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_DhcpServer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_DhcpServer)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_DhcpServer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DhcpServer.Equal(that1.DhcpServer) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_StaticIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_StaticIp)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_StaticIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StaticIp.Equal(that1.StaticIp) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_NoIpv6Address) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_NoIpv6Address)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_NoIpv6Address)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoIpv6Address.Equal(that1.NoIpv6Address) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_StaticIpv6Address) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_StaticIpv6Address)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_StaticIpv6Address)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StaticIpv6Address.Equal(that1.StaticIpv6Address) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_Ipv6AutoConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_Ipv6AutoConfig)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_Ipv6AutoConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipv6AutoConfig.Equal(that1.Ipv6AutoConfig) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_SiteLocalNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_SiteLocalNetwork)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_SiteLocalNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteLocalNetwork.Equal(that1.SiteLocalNetwork) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_SiteLocalInsideNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_SiteLocalInsideNetwork)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_SiteLocalInsideNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteLocalInsideNetwork.Equal(that1.SiteLocalInsideNetwork) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_InsideNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_InsideNetwork)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_InsideNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InsideNetwork.Equal(that1.InsideNetwork) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_StorageNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_StorageNetwork)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_StorageNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageNetwork.Equal(that1.StorageNetwork) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_Srv6Network) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_Srv6Network)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_Srv6Network)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Srv6Network.Equal(that1.Srv6Network) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_IpFabricNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_IpFabricNetwork)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_IpFabricNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpFabricNetwork.Equal(that1.IpFabricNetwork) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_SegmentNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_SegmentNetwork)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_SegmentNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SegmentNetwork.Equal(that1.SegmentNetwork) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_NotPrimary) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_NotPrimary)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_NotPrimary)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NotPrimary.Equal(that1.NotPrimary) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_IsPrimary) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_IsPrimary)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_IsPrimary)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IsPrimary.Equal(that1.IsPrimary) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_MonitorDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_MonitorDisabled)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_MonitorDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MonitorDisabled.Equal(that1.MonitorDisabled) {
		return false
	}
	return true
}
func (this *EthernetInterfaceType_Monitor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EthernetInterfaceType_Monitor)
	if !ok {
		that2, ok := that.(EthernetInterfaceType_Monitor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Monitor.Equal(that1.Monitor) {
		return false
	}
	return true
}
func (this *TunnelInterfaceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TunnelInterfaceType)
	if !ok {
		that2, ok := that.(TunnelInterfaceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.NodeChoice == nil {
		if this.NodeChoice != nil {
			return false
		}
	} else if this.NodeChoice == nil {
		return false
	} else if !this.NodeChoice.Equal(that1.NodeChoice) {
		return false
	}
	if !this.Tunnel.Equal(that1.Tunnel) {
		return false
	}
	if !this.StaticIp.Equal(that1.StaticIp) {
		return false
	}
	if that1.NetworkChoice == nil {
		if this.NetworkChoice != nil {
			return false
		}
	} else if this.NetworkChoice == nil {
		return false
	} else if !this.NetworkChoice.Equal(that1.NetworkChoice) {
		return false
	}
	if this.Mtu != that1.Mtu {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	return true
}
func (this *TunnelInterfaceType_Cluster) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TunnelInterfaceType_Cluster)
	if !ok {
		that2, ok := that.(TunnelInterfaceType_Cluster)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Cluster.Equal(that1.Cluster) {
		return false
	}
	return true
}
func (this *TunnelInterfaceType_Node) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TunnelInterfaceType_Node)
	if !ok {
		that2, ok := that.(TunnelInterfaceType_Node)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Node != that1.Node {
		return false
	}
	return true
}
func (this *TunnelInterfaceType_SiteLocalNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TunnelInterfaceType_SiteLocalNetwork)
	if !ok {
		that2, ok := that.(TunnelInterfaceType_SiteLocalNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteLocalNetwork.Equal(that1.SiteLocalNetwork) {
		return false
	}
	return true
}
func (this *TunnelInterfaceType_SiteLocalInsideNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TunnelInterfaceType_SiteLocalInsideNetwork)
	if !ok {
		that2, ok := that.(TunnelInterfaceType_SiteLocalInsideNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteLocalInsideNetwork.Equal(that1.SiteLocalInsideNetwork) {
		return false
	}
	return true
}
func (this *TunnelInterfaceType_InsideNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TunnelInterfaceType_InsideNetwork)
	if !ok {
		that2, ok := that.(TunnelInterfaceType_InsideNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InsideNetwork.Equal(that1.InsideNetwork) {
		return false
	}
	return true
}
func (this *LegacyInterfaceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LegacyInterfaceType)
	if !ok {
		that2, ok := that.(LegacyInterfaceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Mtu != that1.Mtu {
		return false
	}
	if len(this.VirtualNetwork) != len(that1.VirtualNetwork) {
		return false
	}
	for i := range this.VirtualNetwork {
		if !this.VirtualNetwork[i].Equal(that1.VirtualNetwork[i]) {
			return false
		}
	}
	if this.DhcpAddress != that1.DhcpAddress {
		return false
	}
	if len(this.StaticAddresses) != len(that1.StaticAddresses) {
		return false
	}
	for i := range this.StaticAddresses {
		if !this.StaticAddresses[i].Equal(that1.StaticAddresses[i]) {
			return false
		}
	}
	if !this.DefaultGateway.Equal(that1.DefaultGateway) {
		return false
	}
	if !this.DNSServer.Equal(that1.DNSServer) {
		return false
	}
	if this.DHCPServer != that1.DHCPServer {
		return false
	}
	if this.VlanTagging != that1.VlanTagging {
		return false
	}
	if this.DeviceName != that1.DeviceName {
		return false
	}
	if this.VlanTag != that1.VlanTag {
		return false
	}
	if !this.Tunnel.Equal(that1.Tunnel) {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if len(this.AddressAllocator) != len(that1.AddressAllocator) {
		return false
	}
	for i := range this.AddressAllocator {
		if !this.AddressAllocator[i].Equal(that1.AddressAllocator[i]) {
			return false
		}
	}
	if that1.MonitoringChoice == nil {
		if this.MonitoringChoice != nil {
			return false
		}
	} else if this.MonitoringChoice == nil {
		return false
	} else if !this.MonitoringChoice.Equal(that1.MonitoringChoice) {
		return false
	}
	return true
}
func (this *LegacyInterfaceType_MonitorDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LegacyInterfaceType_MonitorDisabled)
	if !ok {
		that2, ok := that.(LegacyInterfaceType_MonitorDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MonitorDisabled.Equal(that1.MonitorDisabled) {
		return false
	}
	return true
}
func (this *LegacyInterfaceType_Monitor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LegacyInterfaceType_Monitor)
	if !ok {
		that2, ok := that.(LegacyInterfaceType_Monitor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Monitor.Equal(that1.Monitor) {
		return false
	}
	return true
}
func (this *LoopbackInterfaceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoopbackInterfaceType)
	if !ok {
		that2, ok := that.(LoopbackInterfaceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Device != that1.Device {
		return false
	}
	if that1.NodeChoice == nil {
		if this.NodeChoice != nil {
			return false
		}
	} else if this.NodeChoice == nil {
		return false
	} else if !this.NodeChoice.Equal(that1.NodeChoice) {
		return false
	}
	if that1.AddressChoice == nil {
		if this.AddressChoice != nil {
			return false
		}
	} else if this.AddressChoice == nil {
		return false
	} else if !this.AddressChoice.Equal(that1.AddressChoice) {
		return false
	}
	if that1.Ipv6AddressChoice == nil {
		if this.Ipv6AddressChoice != nil {
			return false
		}
	} else if this.Ipv6AddressChoice == nil {
		return false
	} else if !this.Ipv6AddressChoice.Equal(that1.Ipv6AddressChoice) {
		return false
	}
	if that1.NetworkChoice == nil {
		if this.NetworkChoice != nil {
			return false
		}
	} else if this.NetworkChoice == nil {
		return false
	} else if !this.NetworkChoice.Equal(that1.NetworkChoice) {
		return false
	}
	if this.Mtu != that1.Mtu {
		return false
	}
	return true
}
func (this *LoopbackInterfaceType_Cluster) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoopbackInterfaceType_Cluster)
	if !ok {
		that2, ok := that.(LoopbackInterfaceType_Cluster)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Cluster.Equal(that1.Cluster) {
		return false
	}
	return true
}
func (this *LoopbackInterfaceType_Node) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoopbackInterfaceType_Node)
	if !ok {
		that2, ok := that.(LoopbackInterfaceType_Node)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Node != that1.Node {
		return false
	}
	return true
}
func (this *LoopbackInterfaceType_DhcpClient) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoopbackInterfaceType_DhcpClient)
	if !ok {
		that2, ok := that.(LoopbackInterfaceType_DhcpClient)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DhcpClient.Equal(that1.DhcpClient) {
		return false
	}
	return true
}
func (this *LoopbackInterfaceType_DhcpServer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoopbackInterfaceType_DhcpServer)
	if !ok {
		that2, ok := that.(LoopbackInterfaceType_DhcpServer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DhcpServer.Equal(that1.DhcpServer) {
		return false
	}
	return true
}
func (this *LoopbackInterfaceType_StaticIp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoopbackInterfaceType_StaticIp)
	if !ok {
		that2, ok := that.(LoopbackInterfaceType_StaticIp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StaticIp.Equal(that1.StaticIp) {
		return false
	}
	return true
}
func (this *LoopbackInterfaceType_NoIpv6Address) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoopbackInterfaceType_NoIpv6Address)
	if !ok {
		that2, ok := that.(LoopbackInterfaceType_NoIpv6Address)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoIpv6Address.Equal(that1.NoIpv6Address) {
		return false
	}
	return true
}
func (this *LoopbackInterfaceType_StaticIpv6Address) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoopbackInterfaceType_StaticIpv6Address)
	if !ok {
		that2, ok := that.(LoopbackInterfaceType_StaticIpv6Address)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StaticIpv6Address.Equal(that1.StaticIpv6Address) {
		return false
	}
	return true
}
func (this *LoopbackInterfaceType_SiteLocalNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoopbackInterfaceType_SiteLocalNetwork)
	if !ok {
		that2, ok := that.(LoopbackInterfaceType_SiteLocalNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteLocalNetwork.Equal(that1.SiteLocalNetwork) {
		return false
	}
	return true
}
func (this *LoopbackInterfaceType_SiteLocalInsideNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoopbackInterfaceType_SiteLocalInsideNetwork)
	if !ok {
		that2, ok := that.(LoopbackInterfaceType_SiteLocalInsideNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteLocalInsideNetwork.Equal(that1.SiteLocalInsideNetwork) {
		return false
	}
	return true
}
func (this *LoopbackInterfaceType_IpFabricNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoopbackInterfaceType_IpFabricNetwork)
	if !ok {
		that2, ok := that.(LoopbackInterfaceType_IpFabricNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpFabricNetwork.Equal(that1.IpFabricNetwork) {
		return false
	}
	return true
}
func (this *LinkQualityMonitorConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LinkQualityMonitorConfig)
	if !ok {
		that2, ok := that.(LinkQualityMonitorConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *VhostInterfaceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VhostInterfaceType)
	if !ok {
		that2, ok := that.(VhostInterfaceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.HostChoice == nil {
		if this.HostChoice != nil {
			return false
		}
	} else if this.HostChoice == nil {
		return false
	} else if !this.HostChoice.Equal(that1.HostChoice) {
		return false
	}
	return true
}
func (this *VhostInterfaceType_NoHost) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VhostInterfaceType_NoHost)
	if !ok {
		that2, ok := that.(VhostInterfaceType_NoHost)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoHost.Equal(that1.NoHost) {
		return false
	}
	return true
}
func (this *VhostInterfaceType_Vhost) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VhostInterfaceType_Vhost)
	if !ok {
		that2, ok := that.(VhostInterfaceType_Vhost)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Vhost.Equal(that1.Vhost) {
		return false
	}
	return true
}
func (this *VhostInterfaceType_Virtual) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VhostInterfaceType_Virtual)
	if !ok {
		that2, ok := that.(VhostInterfaceType_Virtual)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Virtual.Equal(that1.Virtual) {
		return false
	}
	return true
}
func (this *Layer2VlanInterfaceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Layer2VlanInterfaceType)
	if !ok {
		that2, ok := that.(Layer2VlanInterfaceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Device != that1.Device {
		return false
	}
	if this.VlanId != that1.VlanId {
		return false
	}
	return true
}
func (this *Layer2SloVlanInterfaceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Layer2SloVlanInterfaceType)
	if !ok {
		that2, ok := that.(Layer2SloVlanInterfaceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VlanId != that1.VlanId {
		return false
	}
	return true
}
func (this *Layer2SriovInterfaceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Layer2SriovInterfaceType)
	if !ok {
		that2, ok := that.(Layer2SriovInterfaceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Device != that1.Device {
		return false
	}
	if that1.VlanChoice == nil {
		if this.VlanChoice != nil {
			return false
		}
	} else if this.VlanChoice == nil {
		return false
	} else if !this.VlanChoice.Equal(that1.VlanChoice) {
		return false
	}
	return true
}
func (this *Layer2SriovInterfaceType_Untagged) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Layer2SriovInterfaceType_Untagged)
	if !ok {
		that2, ok := that.(Layer2SriovInterfaceType_Untagged)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Untagged.Equal(that1.Untagged) {
		return false
	}
	return true
}
func (this *Layer2SriovInterfaceType_VlanId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Layer2SriovInterfaceType_VlanId)
	if !ok {
		that2, ok := that.(Layer2SriovInterfaceType_VlanId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VlanId != that1.VlanId {
		return false
	}
	return true
}
func (this *Layer2InterfaceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Layer2InterfaceType)
	if !ok {
		that2, ok := that.(Layer2InterfaceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Layer2InterfaceChoice == nil {
		if this.Layer2InterfaceChoice != nil {
			return false
		}
	} else if this.Layer2InterfaceChoice == nil {
		return false
	} else if !this.Layer2InterfaceChoice.Equal(that1.Layer2InterfaceChoice) {
		return false
	}
	return true
}
func (this *Layer2InterfaceType_L2VlanInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Layer2InterfaceType_L2VlanInterface)
	if !ok {
		that2, ok := that.(Layer2InterfaceType_L2VlanInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.L2VlanInterface.Equal(that1.L2VlanInterface) {
		return false
	}
	return true
}
func (this *Layer2InterfaceType_L2VlanSloInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Layer2InterfaceType_L2VlanSloInterface)
	if !ok {
		that2, ok := that.(Layer2InterfaceType_L2VlanSloInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.L2VlanSloInterface.Equal(that1.L2VlanSloInterface) {
		return false
	}
	return true
}
func (this *Layer2InterfaceType_L2SriovInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Layer2InterfaceType_L2SriovInterface)
	if !ok {
		that2, ok := that.(Layer2InterfaceType_L2SriovInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.L2SriovInterface.Equal(that1.L2SriovInterface) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Mtu != that1.Mtu {
		return false
	}
	if len(this.VirtualNetwork) != len(that1.VirtualNetwork) {
		return false
	}
	for i := range this.VirtualNetwork {
		if !this.VirtualNetwork[i].Equal(that1.VirtualNetwork[i]) {
			return false
		}
	}
	if this.DhcpAddress != that1.DhcpAddress {
		return false
	}
	if len(this.StaticAddresses) != len(that1.StaticAddresses) {
		return false
	}
	for i := range this.StaticAddresses {
		if !this.StaticAddresses[i].Equal(that1.StaticAddresses[i]) {
			return false
		}
	}
	if len(this.StaticIpv6Addresses) != len(that1.StaticIpv6Addresses) {
		return false
	}
	for i := range this.StaticIpv6Addresses {
		if !this.StaticIpv6Addresses[i].Equal(that1.StaticIpv6Addresses[i]) {
			return false
		}
	}
	if !this.DefaultGateway.Equal(that1.DefaultGateway) {
		return false
	}
	if !this.DNSServer.Equal(that1.DNSServer) {
		return false
	}
	if this.DHCPServer != that1.DHCPServer {
		return false
	}
	if this.VlanTagging != that1.VlanTagging {
		return false
	}
	if this.DeviceName != that1.DeviceName {
		return false
	}
	if len(this.ParentNetworkInterface) != len(that1.ParentNetworkInterface) {
		return false
	}
	for i := range this.ParentNetworkInterface {
		if !this.ParentNetworkInterface[i].Equal(that1.ParentNetworkInterface[i]) {
			return false
		}
	}
	if this.VlanTag != that1.VlanTag {
		return false
	}
	if !this.Tunnel.Equal(that1.Tunnel) {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if len(this.AddressAllocator) != len(that1.AddressAllocator) {
		return false
	}
	for i := range this.AddressAllocator {
		if !this.AddressAllocator[i].Equal(that1.AddressAllocator[i]) {
			return false
		}
	}
	if !this.Ipv6AutoConfig.Equal(that1.Ipv6AutoConfig) {
		return false
	}
	if !this.DhcpServerParams.Equal(that1.DhcpServerParams) {
		return false
	}
	if this.NetworkConfig != that1.NetworkConfig {
		return false
	}
	if len(this.InterfaceIpMap) != len(that1.InterfaceIpMap) {
		return false
	}
	for i := range this.InterfaceIpMap {
		if this.InterfaceIpMap[i] != that1.InterfaceIpMap[i] {
			return false
		}
	}
	if this.IsPrimary != that1.IsPrimary {
		return false
	}
	if that1.MonitoringChoice == nil {
		if this.MonitoringChoice != nil {
			return false
		}
	} else if this.MonitoringChoice == nil {
		return false
	} else if !this.MonitoringChoice.Equal(that1.MonitoringChoice) {
		return false
	}
	if !this.Ipv6StaticAddresses.Equal(that1.Ipv6StaticAddresses) {
		return false
	}
	if !this.Ipv4StaticAddresses.Equal(that1.Ipv4StaticAddresses) {
		return false
	}
	if !this.VhostType.Equal(that1.VhostType) {
		return false
	}
	if that1.SegmentMultiplexing == nil {
		if this.SegmentMultiplexing != nil {
			return false
		}
	} else if this.SegmentMultiplexing == nil {
		return false
	} else if !this.SegmentMultiplexing.Equal(that1.SegmentMultiplexing) {
		return false
	}
	if that1.InterfaceChoice == nil {
		if this.InterfaceChoice != nil {
			return false
		}
	} else if this.InterfaceChoice == nil {
		return false
	} else if !this.InterfaceChoice.Equal(that1.InterfaceChoice) {
		return false
	}
	return true
}
func (this *GlobalSpecType_MonitorDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_MonitorDisabled)
	if !ok {
		that2, ok := that.(GlobalSpecType_MonitorDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MonitorDisabled.Equal(that1.MonitorDisabled) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Monitor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Monitor)
	if !ok {
		that2, ok := that.(GlobalSpecType_Monitor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Monitor.Equal(that1.Monitor) {
		return false
	}
	return true
}
func (this *GlobalSpecType_SegmentationDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_SegmentationDisabled)
	if !ok {
		that2, ok := that.(GlobalSpecType_SegmentationDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SegmentationDisabled.Equal(that1.SegmentationDisabled) {
		return false
	}
	return true
}
func (this *GlobalSpecType_SegmentationEnabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_SegmentationEnabled)
	if !ok {
		that2, ok := that.(GlobalSpecType_SegmentationEnabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SegmentationEnabled.Equal(that1.SegmentationEnabled) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DedicatedInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DedicatedInterface)
	if !ok {
		that2, ok := that.(GlobalSpecType_DedicatedInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DedicatedInterface.Equal(that1.DedicatedInterface) {
		return false
	}
	return true
}
func (this *GlobalSpecType_EthernetInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_EthernetInterface)
	if !ok {
		that2, ok := that.(GlobalSpecType_EthernetInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EthernetInterface.Equal(that1.EthernetInterface) {
		return false
	}
	return true
}
func (this *GlobalSpecType_TunnelInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_TunnelInterface)
	if !ok {
		that2, ok := that.(GlobalSpecType_TunnelInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TunnelInterface.Equal(that1.TunnelInterface) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Legacy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Legacy)
	if !ok {
		that2, ok := that.(GlobalSpecType_Legacy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Legacy.Equal(that1.Legacy) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DedicatedManagementInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DedicatedManagementInterface)
	if !ok {
		that2, ok := that.(GlobalSpecType_DedicatedManagementInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DedicatedManagementInterface.Equal(that1.DedicatedManagementInterface) {
		return false
	}
	return true
}
func (this *GlobalSpecType_LoopbackInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_LoopbackInterface)
	if !ok {
		that2, ok := that.(GlobalSpecType_LoopbackInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LoopbackInterface.Equal(that1.LoopbackInterface) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Layer2Interface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Layer2Interface)
	if !ok {
		that2, ok := that.(GlobalSpecType_Layer2Interface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Layer2Interface.Equal(that1.Layer2Interface) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.InterfaceChoice == nil {
		if this.InterfaceChoice != nil {
			return false
		}
	} else if this.InterfaceChoice == nil {
		return false
	} else if !this.InterfaceChoice.Equal(that1.InterfaceChoice) {
		return false
	}
	return true
}
func (this *CreateSpecType_DedicatedInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DedicatedInterface)
	if !ok {
		that2, ok := that.(CreateSpecType_DedicatedInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DedicatedInterface.Equal(that1.DedicatedInterface) {
		return false
	}
	return true
}
func (this *CreateSpecType_EthernetInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_EthernetInterface)
	if !ok {
		that2, ok := that.(CreateSpecType_EthernetInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EthernetInterface.Equal(that1.EthernetInterface) {
		return false
	}
	return true
}
func (this *CreateSpecType_TunnelInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_TunnelInterface)
	if !ok {
		that2, ok := that.(CreateSpecType_TunnelInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TunnelInterface.Equal(that1.TunnelInterface) {
		return false
	}
	return true
}
func (this *CreateSpecType_LegacyInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_LegacyInterface)
	if !ok {
		that2, ok := that.(CreateSpecType_LegacyInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LegacyInterface.Equal(that1.LegacyInterface) {
		return false
	}
	return true
}
func (this *CreateSpecType_DedicatedManagementInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_DedicatedManagementInterface)
	if !ok {
		that2, ok := that.(CreateSpecType_DedicatedManagementInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DedicatedManagementInterface.Equal(that1.DedicatedManagementInterface) {
		return false
	}
	return true
}
func (this *CreateSpecType_Layer2Interface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_Layer2Interface)
	if !ok {
		that2, ok := that.(CreateSpecType_Layer2Interface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Layer2Interface.Equal(that1.Layer2Interface) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.InterfaceChoice == nil {
		if this.InterfaceChoice != nil {
			return false
		}
	} else if this.InterfaceChoice == nil {
		return false
	} else if !this.InterfaceChoice.Equal(that1.InterfaceChoice) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DedicatedInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DedicatedInterface)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DedicatedInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DedicatedInterface.Equal(that1.DedicatedInterface) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_EthernetInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_EthernetInterface)
	if !ok {
		that2, ok := that.(ReplaceSpecType_EthernetInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EthernetInterface.Equal(that1.EthernetInterface) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_TunnelInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_TunnelInterface)
	if !ok {
		that2, ok := that.(ReplaceSpecType_TunnelInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TunnelInterface.Equal(that1.TunnelInterface) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_LegacyInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_LegacyInterface)
	if !ok {
		that2, ok := that.(ReplaceSpecType_LegacyInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LegacyInterface.Equal(that1.LegacyInterface) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_DedicatedManagementInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_DedicatedManagementInterface)
	if !ok {
		that2, ok := that.(ReplaceSpecType_DedicatedManagementInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DedicatedManagementInterface.Equal(that1.DedicatedManagementInterface) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_Layer2Interface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_Layer2Interface)
	if !ok {
		that2, ok := that.(ReplaceSpecType_Layer2Interface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Layer2Interface.Equal(that1.Layer2Interface) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Mtu != that1.Mtu {
		return false
	}
	if len(this.VirtualNetwork) != len(that1.VirtualNetwork) {
		return false
	}
	for i := range this.VirtualNetwork {
		if !this.VirtualNetwork[i].Equal(that1.VirtualNetwork[i]) {
			return false
		}
	}
	if this.DhcpAddress != that1.DhcpAddress {
		return false
	}
	if len(this.StaticAddresses) != len(that1.StaticAddresses) {
		return false
	}
	for i := range this.StaticAddresses {
		if !this.StaticAddresses[i].Equal(that1.StaticAddresses[i]) {
			return false
		}
	}
	if !this.DefaultGateway.Equal(that1.DefaultGateway) {
		return false
	}
	if !this.DNSServer.Equal(that1.DNSServer) {
		return false
	}
	if this.DHCPServer != that1.DHCPServer {
		return false
	}
	if this.VlanTagging != that1.VlanTagging {
		return false
	}
	if this.DeviceName != that1.DeviceName {
		return false
	}
	if len(this.ParentNetworkInterface) != len(that1.ParentNetworkInterface) {
		return false
	}
	for i := range this.ParentNetworkInterface {
		if !this.ParentNetworkInterface[i].Equal(that1.ParentNetworkInterface[i]) {
			return false
		}
	}
	if this.VlanTag != that1.VlanTag {
		return false
	}
	if !this.Tunnel.Equal(that1.Tunnel) {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if len(this.AddressAllocator) != len(that1.AddressAllocator) {
		return false
	}
	for i := range this.AddressAllocator {
		if !this.AddressAllocator[i].Equal(that1.AddressAllocator[i]) {
			return false
		}
	}
	if len(this.InterfaceIpMap) != len(that1.InterfaceIpMap) {
		return false
	}
	for i := range this.InterfaceIpMap {
		if this.InterfaceIpMap[i] != that1.InterfaceIpMap[i] {
			return false
		}
	}
	if this.IsPrimary != that1.IsPrimary {
		return false
	}
	if that1.MonitoringChoice == nil {
		if this.MonitoringChoice != nil {
			return false
		}
	} else if this.MonitoringChoice == nil {
		return false
	} else if !this.MonitoringChoice.Equal(that1.MonitoringChoice) {
		return false
	}
	if that1.InterfaceChoice == nil {
		if this.InterfaceChoice != nil {
			return false
		}
	} else if this.InterfaceChoice == nil {
		return false
	} else if !this.InterfaceChoice.Equal(that1.InterfaceChoice) {
		return false
	}
	return true
}
func (this *GetSpecType_MonitorDisabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_MonitorDisabled)
	if !ok {
		that2, ok := that.(GetSpecType_MonitorDisabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MonitorDisabled.Equal(that1.MonitorDisabled) {
		return false
	}
	return true
}
func (this *GetSpecType_Monitor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_Monitor)
	if !ok {
		that2, ok := that.(GetSpecType_Monitor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Monitor.Equal(that1.Monitor) {
		return false
	}
	return true
}
func (this *GetSpecType_DedicatedInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DedicatedInterface)
	if !ok {
		that2, ok := that.(GetSpecType_DedicatedInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DedicatedInterface.Equal(that1.DedicatedInterface) {
		return false
	}
	return true
}
func (this *GetSpecType_EthernetInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_EthernetInterface)
	if !ok {
		that2, ok := that.(GetSpecType_EthernetInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EthernetInterface.Equal(that1.EthernetInterface) {
		return false
	}
	return true
}
func (this *GetSpecType_TunnelInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_TunnelInterface)
	if !ok {
		that2, ok := that.(GetSpecType_TunnelInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TunnelInterface.Equal(that1.TunnelInterface) {
		return false
	}
	return true
}
func (this *GetSpecType_LegacyInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_LegacyInterface)
	if !ok {
		that2, ok := that.(GetSpecType_LegacyInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LegacyInterface.Equal(that1.LegacyInterface) {
		return false
	}
	return true
}
func (this *GetSpecType_DedicatedManagementInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_DedicatedManagementInterface)
	if !ok {
		that2, ok := that.(GetSpecType_DedicatedManagementInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DedicatedManagementInterface.Equal(that1.DedicatedManagementInterface) {
		return false
	}
	return true
}
func (this *GetSpecType_Layer2Interface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_Layer2Interface)
	if !ok {
		that2, ok := that.(GetSpecType_Layer2Interface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Layer2Interface.Equal(that1.Layer2Interface) {
		return false
	}
	return true
}
func (this *NetworkInterfaceStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkInterfaceStatus)
	if !ok {
		that2, ok := that.(NetworkInterfaceStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UpDown != that1.UpDown {
		return false
	}
	return true
}
func (this *NetworkInterfaceDFGW) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&network_interface.NetworkInterfaceDFGW{")
	s = append(s, "DefaultGatewayMode: "+fmt.Sprintf("%#v", this.DefaultGatewayMode)+",\n")
	if this.DefaultGatewayAddress != nil {
		s = append(s, "DefaultGatewayAddress: "+fmt.Sprintf("%#v", this.DefaultGatewayAddress)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkInterfaceDNS) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&network_interface.NetworkInterfaceDNS{")
	s = append(s, "DnsMode: "+fmt.Sprintf("%#v", this.DnsMode)+",\n")
	if this.DnsServer != nil {
		s = append(s, "DnsServer: "+fmt.Sprintf("%#v", this.DnsServer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkInterfaceTunnel) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&network_interface.NetworkInterfaceTunnel{")
	if this.Tunnel != nil {
		s = append(s, "Tunnel: "+fmt.Sprintf("%#v", this.Tunnel)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DHCPPoolType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&network_interface.DHCPPoolType{")
	s = append(s, "StartIp: "+fmt.Sprintf("%#v", this.StartIp)+",\n")
	s = append(s, "EndIp: "+fmt.Sprintf("%#v", this.EndIp)+",\n")
	s = append(s, "Exclude: "+fmt.Sprintf("%#v", this.Exclude)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DHCPIPV6PoolType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&network_interface.DHCPIPV6PoolType{")
	s = append(s, "StartIp: "+fmt.Sprintf("%#v", this.StartIp)+",\n")
	s = append(s, "EndIp: "+fmt.Sprintf("%#v", this.EndIp)+",\n")
	s = append(s, "Exclude: "+fmt.Sprintf("%#v", this.Exclude)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DHCPIPV6NetworkType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&network_interface.DHCPIPV6NetworkType{")
	if this.NetworkPrefixChoice != nil {
		s = append(s, "NetworkPrefixChoice: "+fmt.Sprintf("%#v", this.NetworkPrefixChoice)+",\n")
	}
	if this.Pools != nil {
		s = append(s, "Pools: "+fmt.Sprintf("%#v", this.Pools)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DHCPIPV6NetworkType_NetworkPrefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPIPV6NetworkType_NetworkPrefix{` +
		`NetworkPrefix:` + fmt.Sprintf("%#v", this.NetworkPrefix) + `}`}, ", ")
	return s
}
func (this *DHCPIPV6NetworkType_NetworkPrefixAllocator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPIPV6NetworkType_NetworkPrefixAllocator{` +
		`NetworkPrefixAllocator:` + fmt.Sprintf("%#v", this.NetworkPrefixAllocator) + `}`}, ", ")
	return s
}
func (this *DHCPNetworkType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&network_interface.DHCPNetworkType{")
	if this.NetworkPrefixChoice != nil {
		s = append(s, "NetworkPrefixChoice: "+fmt.Sprintf("%#v", this.NetworkPrefixChoice)+",\n")
	}
	if this.Pools != nil {
		s = append(s, "Pools: "+fmt.Sprintf("%#v", this.Pools)+",\n")
	}
	if this.GatewayChoice != nil {
		s = append(s, "GatewayChoice: "+fmt.Sprintf("%#v", this.GatewayChoice)+",\n")
	}
	if this.DnsChoice != nil {
		s = append(s, "DnsChoice: "+fmt.Sprintf("%#v", this.DnsChoice)+",\n")
	}
	s = append(s, "PoolSettings: "+fmt.Sprintf("%#v", this.PoolSettings)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DHCPNetworkType_NetworkPrefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPNetworkType_NetworkPrefix{` +
		`NetworkPrefix:` + fmt.Sprintf("%#v", this.NetworkPrefix) + `}`}, ", ")
	return s
}
func (this *DHCPNetworkType_NetworkPrefixAllocator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPNetworkType_NetworkPrefixAllocator{` +
		`NetworkPrefixAllocator:` + fmt.Sprintf("%#v", this.NetworkPrefixAllocator) + `}`}, ", ")
	return s
}
func (this *DHCPNetworkType_FirstAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPNetworkType_FirstAddress{` +
		`FirstAddress:` + fmt.Sprintf("%#v", this.FirstAddress) + `}`}, ", ")
	return s
}
func (this *DHCPNetworkType_LastAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPNetworkType_LastAddress{` +
		`LastAddress:` + fmt.Sprintf("%#v", this.LastAddress) + `}`}, ", ")
	return s
}
func (this *DHCPNetworkType_DgwAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPNetworkType_DgwAddress{` +
		`DgwAddress:` + fmt.Sprintf("%#v", this.DgwAddress) + `}`}, ", ")
	return s
}
func (this *DHCPNetworkType_SameAsDgw) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPNetworkType_SameAsDgw{` +
		`SameAsDgw:` + fmt.Sprintf("%#v", this.SameAsDgw) + `}`}, ", ")
	return s
}
func (this *DHCPNetworkType_DnsAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPNetworkType_DnsAddress{` +
		`DnsAddress:` + fmt.Sprintf("%#v", this.DnsAddress) + `}`}, ", ")
	return s
}
func (this *DHCPInterfaceIPType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&network_interface.DHCPInterfaceIPType{")
	keysForInterfaceIpMap := make([]string, 0, len(this.InterfaceIpMap))
	for k, _ := range this.InterfaceIpMap {
		keysForInterfaceIpMap = append(keysForInterfaceIpMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForInterfaceIpMap)
	mapStringForInterfaceIpMap := "map[string]string{"
	for _, k := range keysForInterfaceIpMap {
		mapStringForInterfaceIpMap += fmt.Sprintf("%#v: %#v,", k, this.InterfaceIpMap[k])
	}
	mapStringForInterfaceIpMap += "}"
	if this.InterfaceIpMap != nil {
		s = append(s, "InterfaceIpMap: "+mapStringForInterfaceIpMap+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DHCPInterfaceIPV6Type) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&network_interface.DHCPInterfaceIPV6Type{")
	keysForInterfaceIpMap := make([]string, 0, len(this.InterfaceIpMap))
	for k, _ := range this.InterfaceIpMap {
		keysForInterfaceIpMap = append(keysForInterfaceIpMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForInterfaceIpMap)
	mapStringForInterfaceIpMap := "map[string]string{"
	for _, k := range keysForInterfaceIpMap {
		mapStringForInterfaceIpMap += fmt.Sprintf("%#v: %#v,", k, this.InterfaceIpMap[k])
	}
	mapStringForInterfaceIpMap += "}"
	if this.InterfaceIpMap != nil {
		s = append(s, "InterfaceIpMap: "+mapStringForInterfaceIpMap+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DHCPServerParametersType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&network_interface.DHCPServerParametersType{")
	if this.DhcpNetworks != nil {
		s = append(s, "DhcpNetworks: "+fmt.Sprintf("%#v", this.DhcpNetworks)+",\n")
	}
	if this.InterfacesAddressingChoice != nil {
		s = append(s, "InterfacesAddressingChoice: "+fmt.Sprintf("%#v", this.InterfacesAddressingChoice)+",\n")
	}
	keysForFixedIpMap := make([]string, 0, len(this.FixedIpMap))
	for k, _ := range this.FixedIpMap {
		keysForFixedIpMap = append(keysForFixedIpMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForFixedIpMap)
	mapStringForFixedIpMap := "map[string]string{"
	for _, k := range keysForFixedIpMap {
		mapStringForFixedIpMap += fmt.Sprintf("%#v: %#v,", k, this.FixedIpMap[k])
	}
	mapStringForFixedIpMap += "}"
	if this.FixedIpMap != nil {
		s = append(s, "FixedIpMap: "+mapStringForFixedIpMap+",\n")
	}
	s = append(s, "DhcpOption82Tag: "+fmt.Sprintf("%#v", this.DhcpOption82Tag)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DHCPServerParametersType_AutomaticFromStart) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPServerParametersType_AutomaticFromStart{` +
		`AutomaticFromStart:` + fmt.Sprintf("%#v", this.AutomaticFromStart) + `}`}, ", ")
	return s
}
func (this *DHCPServerParametersType_AutomaticFromEnd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPServerParametersType_AutomaticFromEnd{` +
		`AutomaticFromEnd:` + fmt.Sprintf("%#v", this.AutomaticFromEnd) + `}`}, ", ")
	return s
}
func (this *DHCPServerParametersType_InterfaceIpMap) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPServerParametersType_InterfaceIpMap{` +
		`InterfaceIpMap:` + fmt.Sprintf("%#v", this.InterfaceIpMap) + `}`}, ", ")
	return s
}
func (this *IPV6AutoConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&network_interface.IPV6AutoConfigType{")
	if this.AutoconfigChoice != nil {
		s = append(s, "AutoconfigChoice: "+fmt.Sprintf("%#v", this.AutoconfigChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IPV6AutoConfigType_Host) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.IPV6AutoConfigType_Host{` +
		`Host:` + fmt.Sprintf("%#v", this.Host) + `}`}, ", ")
	return s
}
func (this *IPV6AutoConfigType_Router) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.IPV6AutoConfigType_Router{` +
		`Router:` + fmt.Sprintf("%#v", this.Router) + `}`}, ", ")
	return s
}
func (this *IPV6AutoConfigRouterType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&network_interface.IPV6AutoConfigRouterType{")
	if this.AddressChoice != nil {
		s = append(s, "AddressChoice: "+fmt.Sprintf("%#v", this.AddressChoice)+",\n")
	}
	if this.DnsConfig != nil {
		s = append(s, "DnsConfig: "+fmt.Sprintf("%#v", this.DnsConfig)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IPV6AutoConfigRouterType_NetworkPrefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.IPV6AutoConfigRouterType_NetworkPrefix{` +
		`NetworkPrefix:` + fmt.Sprintf("%#v", this.NetworkPrefix) + `}`}, ", ")
	return s
}
func (this *IPV6AutoConfigRouterType_Stateful) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.IPV6AutoConfigRouterType_Stateful{` +
		`Stateful:` + fmt.Sprintf("%#v", this.Stateful) + `}`}, ", ")
	return s
}
func (this *IPV6DnsList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&network_interface.IPV6DnsList{")
	s = append(s, "DnsList: "+fmt.Sprintf("%#v", this.DnsList)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IPV6LocalDnsAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&network_interface.IPV6LocalDnsAddress{")
	if this.LocalDnsChoice != nil {
		s = append(s, "LocalDnsChoice: "+fmt.Sprintf("%#v", this.LocalDnsChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IPV6LocalDnsAddress_FirstAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.IPV6LocalDnsAddress_FirstAddress{` +
		`FirstAddress:` + fmt.Sprintf("%#v", this.FirstAddress) + `}`}, ", ")
	return s
}
func (this *IPV6LocalDnsAddress_LastAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.IPV6LocalDnsAddress_LastAddress{` +
		`LastAddress:` + fmt.Sprintf("%#v", this.LastAddress) + `}`}, ", ")
	return s
}
func (this *IPV6LocalDnsAddress_ConfiguredAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.IPV6LocalDnsAddress_ConfiguredAddress{` +
		`ConfiguredAddress:` + fmt.Sprintf("%#v", this.ConfiguredAddress) + `}`}, ", ")
	return s
}
func (this *IPV6DnsConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&network_interface.IPV6DnsConfig{")
	if this.DnsChoice != nil {
		s = append(s, "DnsChoice: "+fmt.Sprintf("%#v", this.DnsChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IPV6DnsConfig_LocalDns) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.IPV6DnsConfig_LocalDns{` +
		`LocalDns:` + fmt.Sprintf("%#v", this.LocalDns) + `}`}, ", ")
	return s
}
func (this *IPV6DnsConfig_ConfiguredList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.IPV6DnsConfig_ConfiguredList{` +
		`ConfiguredList:` + fmt.Sprintf("%#v", this.ConfiguredList) + `}`}, ", ")
	return s
}
func (this *DHCPIPV6StatefulServer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&network_interface.DHCPIPV6StatefulServer{")
	if this.DhcpNetworks != nil {
		s = append(s, "DhcpNetworks: "+fmt.Sprintf("%#v", this.DhcpNetworks)+",\n")
	}
	if this.InterfacesAddressingChoice != nil {
		s = append(s, "InterfacesAddressingChoice: "+fmt.Sprintf("%#v", this.InterfacesAddressingChoice)+",\n")
	}
	keysForFixedIpMap := make([]string, 0, len(this.FixedIpMap))
	for k, _ := range this.FixedIpMap {
		keysForFixedIpMap = append(keysForFixedIpMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForFixedIpMap)
	mapStringForFixedIpMap := "map[string]string{"
	for _, k := range keysForFixedIpMap {
		mapStringForFixedIpMap += fmt.Sprintf("%#v: %#v,", k, this.FixedIpMap[k])
	}
	mapStringForFixedIpMap += "}"
	if this.FixedIpMap != nil {
		s = append(s, "FixedIpMap: "+mapStringForFixedIpMap+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DHCPIPV6StatefulServer_AutomaticFromStart) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPIPV6StatefulServer_AutomaticFromStart{` +
		`AutomaticFromStart:` + fmt.Sprintf("%#v", this.AutomaticFromStart) + `}`}, ", ")
	return s
}
func (this *DHCPIPV6StatefulServer_AutomaticFromEnd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPIPV6StatefulServer_AutomaticFromEnd{` +
		`AutomaticFromEnd:` + fmt.Sprintf("%#v", this.AutomaticFromEnd) + `}`}, ", ")
	return s
}
func (this *DHCPIPV6StatefulServer_InterfaceIpMap) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DHCPIPV6StatefulServer_InterfaceIpMap{` +
		`InterfaceIpMap:` + fmt.Sprintf("%#v", this.InterfaceIpMap) + `}`}, ", ")
	return s
}
func (this *StaticIpParametersNodeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&network_interface.StaticIpParametersNodeType{")
	s = append(s, "IpAddress: "+fmt.Sprintf("%#v", this.IpAddress)+",\n")
	s = append(s, "DefaultGw: "+fmt.Sprintf("%#v", this.DefaultGw)+",\n")
	s = append(s, "DnsServer: "+fmt.Sprintf("%#v", this.DnsServer)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StaticIpParametersClusterType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&network_interface.StaticIpParametersClusterType{")
	keysForInterfaceIpMap := make([]string, 0, len(this.InterfaceIpMap))
	for k, _ := range this.InterfaceIpMap {
		keysForInterfaceIpMap = append(keysForInterfaceIpMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForInterfaceIpMap)
	mapStringForInterfaceIpMap := "map[string]*StaticIpParametersNodeType{"
	for _, k := range keysForInterfaceIpMap {
		mapStringForInterfaceIpMap += fmt.Sprintf("%#v: %#v,", k, this.InterfaceIpMap[k])
	}
	mapStringForInterfaceIpMap += "}"
	if this.InterfaceIpMap != nil {
		s = append(s, "InterfaceIpMap: "+mapStringForInterfaceIpMap+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StaticIpParametersFleetType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&network_interface.StaticIpParametersFleetType{")
	if this.NetworkPrefixAllocator != nil {
		s = append(s, "NetworkPrefixAllocator: "+fmt.Sprintf("%#v", this.NetworkPrefixAllocator)+",\n")
	}
	s = append(s, "DefaultGw: "+fmt.Sprintf("%#v", this.DefaultGw)+",\n")
	s = append(s, "DnsServer: "+fmt.Sprintf("%#v", this.DnsServer)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StaticIPParametersType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&network_interface.StaticIPParametersType{")
	if this.NetworkPrefixChoice != nil {
		s = append(s, "NetworkPrefixChoice: "+fmt.Sprintf("%#v", this.NetworkPrefixChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StaticIPParametersType_NodeStaticIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.StaticIPParametersType_NodeStaticIp{` +
		`NodeStaticIp:` + fmt.Sprintf("%#v", this.NodeStaticIp) + `}`}, ", ")
	return s
}
func (this *StaticIPParametersType_ClusterStaticIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.StaticIPParametersType_ClusterStaticIp{` +
		`ClusterStaticIp:` + fmt.Sprintf("%#v", this.ClusterStaticIp) + `}`}, ", ")
	return s
}
func (this *StaticIPParametersType_FleetStaticIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.StaticIPParametersType_FleetStaticIp{` +
		`FleetStaticIp:` + fmt.Sprintf("%#v", this.FleetStaticIp) + `}`}, ", ")
	return s
}
func (this *DedicatedInterfaceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&network_interface.DedicatedInterfaceType{")
	s = append(s, "Device: "+fmt.Sprintf("%#v", this.Device)+",\n")
	if this.NodeChoice != nil {
		s = append(s, "NodeChoice: "+fmt.Sprintf("%#v", this.NodeChoice)+",\n")
	}
	s = append(s, "Mtu: "+fmt.Sprintf("%#v", this.Mtu)+",\n")
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	if this.PrimaryChoice != nil {
		s = append(s, "PrimaryChoice: "+fmt.Sprintf("%#v", this.PrimaryChoice)+",\n")
	}
	if this.MonitoringChoice != nil {
		s = append(s, "MonitoringChoice: "+fmt.Sprintf("%#v", this.MonitoringChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DedicatedInterfaceType_Cluster) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DedicatedInterfaceType_Cluster{` +
		`Cluster:` + fmt.Sprintf("%#v", this.Cluster) + `}`}, ", ")
	return s
}
func (this *DedicatedInterfaceType_Node) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DedicatedInterfaceType_Node{` +
		`Node:` + fmt.Sprintf("%#v", this.Node) + `}`}, ", ")
	return s
}
func (this *DedicatedInterfaceType_NotPrimary) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DedicatedInterfaceType_NotPrimary{` +
		`NotPrimary:` + fmt.Sprintf("%#v", this.NotPrimary) + `}`}, ", ")
	return s
}
func (this *DedicatedInterfaceType_IsPrimary) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DedicatedInterfaceType_IsPrimary{` +
		`IsPrimary:` + fmt.Sprintf("%#v", this.IsPrimary) + `}`}, ", ")
	return s
}
func (this *DedicatedInterfaceType_MonitorDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DedicatedInterfaceType_MonitorDisabled{` +
		`MonitorDisabled:` + fmt.Sprintf("%#v", this.MonitorDisabled) + `}`}, ", ")
	return s
}
func (this *DedicatedInterfaceType_Monitor) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DedicatedInterfaceType_Monitor{` +
		`Monitor:` + fmt.Sprintf("%#v", this.Monitor) + `}`}, ", ")
	return s
}
func (this *DedicatedManagementInterfaceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&network_interface.DedicatedManagementInterfaceType{")
	s = append(s, "Device: "+fmt.Sprintf("%#v", this.Device)+",\n")
	if this.NodeChoice != nil {
		s = append(s, "NodeChoice: "+fmt.Sprintf("%#v", this.NodeChoice)+",\n")
	}
	s = append(s, "Mtu: "+fmt.Sprintf("%#v", this.Mtu)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DedicatedManagementInterfaceType_Cluster) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DedicatedManagementInterfaceType_Cluster{` +
		`Cluster:` + fmt.Sprintf("%#v", this.Cluster) + `}`}, ", ")
	return s
}
func (this *DedicatedManagementInterfaceType_Node) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.DedicatedManagementInterfaceType_Node{` +
		`Node:` + fmt.Sprintf("%#v", this.Node) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 28)
	s = append(s, "&network_interface.EthernetInterfaceType{")
	s = append(s, "Device: "+fmt.Sprintf("%#v", this.Device)+",\n")
	if this.NodeChoice != nil {
		s = append(s, "NodeChoice: "+fmt.Sprintf("%#v", this.NodeChoice)+",\n")
	}
	if this.VlanChoice != nil {
		s = append(s, "VlanChoice: "+fmt.Sprintf("%#v", this.VlanChoice)+",\n")
	}
	if this.AddressChoice != nil {
		s = append(s, "AddressChoice: "+fmt.Sprintf("%#v", this.AddressChoice)+",\n")
	}
	if this.Ipv6AddressChoice != nil {
		s = append(s, "Ipv6AddressChoice: "+fmt.Sprintf("%#v", this.Ipv6AddressChoice)+",\n")
	}
	if this.NetworkChoice != nil {
		s = append(s, "NetworkChoice: "+fmt.Sprintf("%#v", this.NetworkChoice)+",\n")
	}
	s = append(s, "Mtu: "+fmt.Sprintf("%#v", this.Mtu)+",\n")
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	if this.PrimaryChoice != nil {
		s = append(s, "PrimaryChoice: "+fmt.Sprintf("%#v", this.PrimaryChoice)+",\n")
	}
	if this.MonitoringChoice != nil {
		s = append(s, "MonitoringChoice: "+fmt.Sprintf("%#v", this.MonitoringChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EthernetInterfaceType_Cluster) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_Cluster{` +
		`Cluster:` + fmt.Sprintf("%#v", this.Cluster) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_Node) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_Node{` +
		`Node:` + fmt.Sprintf("%#v", this.Node) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_Untagged) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_Untagged{` +
		`Untagged:` + fmt.Sprintf("%#v", this.Untagged) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_VlanId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_VlanId{` +
		`VlanId:` + fmt.Sprintf("%#v", this.VlanId) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_DhcpClient) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_DhcpClient{` +
		`DhcpClient:` + fmt.Sprintf("%#v", this.DhcpClient) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_DhcpServer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_DhcpServer{` +
		`DhcpServer:` + fmt.Sprintf("%#v", this.DhcpServer) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_StaticIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_StaticIp{` +
		`StaticIp:` + fmt.Sprintf("%#v", this.StaticIp) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_NoIpv6Address) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_NoIpv6Address{` +
		`NoIpv6Address:` + fmt.Sprintf("%#v", this.NoIpv6Address) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_StaticIpv6Address) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_StaticIpv6Address{` +
		`StaticIpv6Address:` + fmt.Sprintf("%#v", this.StaticIpv6Address) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_Ipv6AutoConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_Ipv6AutoConfig{` +
		`Ipv6AutoConfig:` + fmt.Sprintf("%#v", this.Ipv6AutoConfig) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_SiteLocalNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_SiteLocalNetwork{` +
		`SiteLocalNetwork:` + fmt.Sprintf("%#v", this.SiteLocalNetwork) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_SiteLocalInsideNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_SiteLocalInsideNetwork{` +
		`SiteLocalInsideNetwork:` + fmt.Sprintf("%#v", this.SiteLocalInsideNetwork) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_InsideNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_InsideNetwork{` +
		`InsideNetwork:` + fmt.Sprintf("%#v", this.InsideNetwork) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_StorageNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_StorageNetwork{` +
		`StorageNetwork:` + fmt.Sprintf("%#v", this.StorageNetwork) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_Srv6Network) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_Srv6Network{` +
		`Srv6Network:` + fmt.Sprintf("%#v", this.Srv6Network) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_IpFabricNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_IpFabricNetwork{` +
		`IpFabricNetwork:` + fmt.Sprintf("%#v", this.IpFabricNetwork) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_SegmentNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_SegmentNetwork{` +
		`SegmentNetwork:` + fmt.Sprintf("%#v", this.SegmentNetwork) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_NotPrimary) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_NotPrimary{` +
		`NotPrimary:` + fmt.Sprintf("%#v", this.NotPrimary) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_IsPrimary) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_IsPrimary{` +
		`IsPrimary:` + fmt.Sprintf("%#v", this.IsPrimary) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_MonitorDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_MonitorDisabled{` +
		`MonitorDisabled:` + fmt.Sprintf("%#v", this.MonitorDisabled) + `}`}, ", ")
	return s
}
func (this *EthernetInterfaceType_Monitor) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.EthernetInterfaceType_Monitor{` +
		`Monitor:` + fmt.Sprintf("%#v", this.Monitor) + `}`}, ", ")
	return s
}
func (this *TunnelInterfaceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&network_interface.TunnelInterfaceType{")
	if this.NodeChoice != nil {
		s = append(s, "NodeChoice: "+fmt.Sprintf("%#v", this.NodeChoice)+",\n")
	}
	if this.Tunnel != nil {
		s = append(s, "Tunnel: "+fmt.Sprintf("%#v", this.Tunnel)+",\n")
	}
	if this.StaticIp != nil {
		s = append(s, "StaticIp: "+fmt.Sprintf("%#v", this.StaticIp)+",\n")
	}
	if this.NetworkChoice != nil {
		s = append(s, "NetworkChoice: "+fmt.Sprintf("%#v", this.NetworkChoice)+",\n")
	}
	s = append(s, "Mtu: "+fmt.Sprintf("%#v", this.Mtu)+",\n")
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TunnelInterfaceType_Cluster) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.TunnelInterfaceType_Cluster{` +
		`Cluster:` + fmt.Sprintf("%#v", this.Cluster) + `}`}, ", ")
	return s
}
func (this *TunnelInterfaceType_Node) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.TunnelInterfaceType_Node{` +
		`Node:` + fmt.Sprintf("%#v", this.Node) + `}`}, ", ")
	return s
}
func (this *TunnelInterfaceType_SiteLocalNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.TunnelInterfaceType_SiteLocalNetwork{` +
		`SiteLocalNetwork:` + fmt.Sprintf("%#v", this.SiteLocalNetwork) + `}`}, ", ")
	return s
}
func (this *TunnelInterfaceType_SiteLocalInsideNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.TunnelInterfaceType_SiteLocalInsideNetwork{` +
		`SiteLocalInsideNetwork:` + fmt.Sprintf("%#v", this.SiteLocalInsideNetwork) + `}`}, ", ")
	return s
}
func (this *TunnelInterfaceType_InsideNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.TunnelInterfaceType_InsideNetwork{` +
		`InsideNetwork:` + fmt.Sprintf("%#v", this.InsideNetwork) + `}`}, ", ")
	return s
}
func (this *LegacyInterfaceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 20)
	s = append(s, "&network_interface.LegacyInterfaceType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Mtu: "+fmt.Sprintf("%#v", this.Mtu)+",\n")
	if this.VirtualNetwork != nil {
		s = append(s, "VirtualNetwork: "+fmt.Sprintf("%#v", this.VirtualNetwork)+",\n")
	}
	s = append(s, "DhcpAddress: "+fmt.Sprintf("%#v", this.DhcpAddress)+",\n")
	if this.StaticAddresses != nil {
		s = append(s, "StaticAddresses: "+fmt.Sprintf("%#v", this.StaticAddresses)+",\n")
	}
	if this.DefaultGateway != nil {
		s = append(s, "DefaultGateway: "+fmt.Sprintf("%#v", this.DefaultGateway)+",\n")
	}
	if this.DNSServer != nil {
		s = append(s, "DNSServer: "+fmt.Sprintf("%#v", this.DNSServer)+",\n")
	}
	s = append(s, "DHCPServer: "+fmt.Sprintf("%#v", this.DHCPServer)+",\n")
	s = append(s, "VlanTagging: "+fmt.Sprintf("%#v", this.VlanTagging)+",\n")
	s = append(s, "DeviceName: "+fmt.Sprintf("%#v", this.DeviceName)+",\n")
	s = append(s, "VlanTag: "+fmt.Sprintf("%#v", this.VlanTag)+",\n")
	if this.Tunnel != nil {
		s = append(s, "Tunnel: "+fmt.Sprintf("%#v", this.Tunnel)+",\n")
	}
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	if this.AddressAllocator != nil {
		s = append(s, "AddressAllocator: "+fmt.Sprintf("%#v", this.AddressAllocator)+",\n")
	}
	if this.MonitoringChoice != nil {
		s = append(s, "MonitoringChoice: "+fmt.Sprintf("%#v", this.MonitoringChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LegacyInterfaceType_MonitorDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.LegacyInterfaceType_MonitorDisabled{` +
		`MonitorDisabled:` + fmt.Sprintf("%#v", this.MonitorDisabled) + `}`}, ", ")
	return s
}
func (this *LegacyInterfaceType_Monitor) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.LegacyInterfaceType_Monitor{` +
		`Monitor:` + fmt.Sprintf("%#v", this.Monitor) + `}`}, ", ")
	return s
}
func (this *LoopbackInterfaceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&network_interface.LoopbackInterfaceType{")
	s = append(s, "Device: "+fmt.Sprintf("%#v", this.Device)+",\n")
	if this.NodeChoice != nil {
		s = append(s, "NodeChoice: "+fmt.Sprintf("%#v", this.NodeChoice)+",\n")
	}
	if this.AddressChoice != nil {
		s = append(s, "AddressChoice: "+fmt.Sprintf("%#v", this.AddressChoice)+",\n")
	}
	if this.Ipv6AddressChoice != nil {
		s = append(s, "Ipv6AddressChoice: "+fmt.Sprintf("%#v", this.Ipv6AddressChoice)+",\n")
	}
	if this.NetworkChoice != nil {
		s = append(s, "NetworkChoice: "+fmt.Sprintf("%#v", this.NetworkChoice)+",\n")
	}
	s = append(s, "Mtu: "+fmt.Sprintf("%#v", this.Mtu)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LoopbackInterfaceType_Cluster) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.LoopbackInterfaceType_Cluster{` +
		`Cluster:` + fmt.Sprintf("%#v", this.Cluster) + `}`}, ", ")
	return s
}
func (this *LoopbackInterfaceType_Node) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.LoopbackInterfaceType_Node{` +
		`Node:` + fmt.Sprintf("%#v", this.Node) + `}`}, ", ")
	return s
}
func (this *LoopbackInterfaceType_DhcpClient) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.LoopbackInterfaceType_DhcpClient{` +
		`DhcpClient:` + fmt.Sprintf("%#v", this.DhcpClient) + `}`}, ", ")
	return s
}
func (this *LoopbackInterfaceType_DhcpServer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.LoopbackInterfaceType_DhcpServer{` +
		`DhcpServer:` + fmt.Sprintf("%#v", this.DhcpServer) + `}`}, ", ")
	return s
}
func (this *LoopbackInterfaceType_StaticIp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.LoopbackInterfaceType_StaticIp{` +
		`StaticIp:` + fmt.Sprintf("%#v", this.StaticIp) + `}`}, ", ")
	return s
}
func (this *LoopbackInterfaceType_NoIpv6Address) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.LoopbackInterfaceType_NoIpv6Address{` +
		`NoIpv6Address:` + fmt.Sprintf("%#v", this.NoIpv6Address) + `}`}, ", ")
	return s
}
func (this *LoopbackInterfaceType_StaticIpv6Address) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.LoopbackInterfaceType_StaticIpv6Address{` +
		`StaticIpv6Address:` + fmt.Sprintf("%#v", this.StaticIpv6Address) + `}`}, ", ")
	return s
}
func (this *LoopbackInterfaceType_SiteLocalNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.LoopbackInterfaceType_SiteLocalNetwork{` +
		`SiteLocalNetwork:` + fmt.Sprintf("%#v", this.SiteLocalNetwork) + `}`}, ", ")
	return s
}
func (this *LoopbackInterfaceType_SiteLocalInsideNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.LoopbackInterfaceType_SiteLocalInsideNetwork{` +
		`SiteLocalInsideNetwork:` + fmt.Sprintf("%#v", this.SiteLocalInsideNetwork) + `}`}, ", ")
	return s
}
func (this *LoopbackInterfaceType_IpFabricNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.LoopbackInterfaceType_IpFabricNetwork{` +
		`IpFabricNetwork:` + fmt.Sprintf("%#v", this.IpFabricNetwork) + `}`}, ", ")
	return s
}
func (this *LinkQualityMonitorConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&network_interface.LinkQualityMonitorConfig{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VhostInterfaceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&network_interface.VhostInterfaceType{")
	if this.HostChoice != nil {
		s = append(s, "HostChoice: "+fmt.Sprintf("%#v", this.HostChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VhostInterfaceType_NoHost) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.VhostInterfaceType_NoHost{` +
		`NoHost:` + fmt.Sprintf("%#v", this.NoHost) + `}`}, ", ")
	return s
}
func (this *VhostInterfaceType_Vhost) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.VhostInterfaceType_Vhost{` +
		`Vhost:` + fmt.Sprintf("%#v", this.Vhost) + `}`}, ", ")
	return s
}
func (this *VhostInterfaceType_Virtual) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.VhostInterfaceType_Virtual{` +
		`Virtual:` + fmt.Sprintf("%#v", this.Virtual) + `}`}, ", ")
	return s
}
func (this *Layer2VlanInterfaceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&network_interface.Layer2VlanInterfaceType{")
	s = append(s, "Device: "+fmt.Sprintf("%#v", this.Device)+",\n")
	s = append(s, "VlanId: "+fmt.Sprintf("%#v", this.VlanId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Layer2SloVlanInterfaceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&network_interface.Layer2SloVlanInterfaceType{")
	s = append(s, "VlanId: "+fmt.Sprintf("%#v", this.VlanId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Layer2SriovInterfaceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&network_interface.Layer2SriovInterfaceType{")
	s = append(s, "Device: "+fmt.Sprintf("%#v", this.Device)+",\n")
	if this.VlanChoice != nil {
		s = append(s, "VlanChoice: "+fmt.Sprintf("%#v", this.VlanChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Layer2SriovInterfaceType_Untagged) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.Layer2SriovInterfaceType_Untagged{` +
		`Untagged:` + fmt.Sprintf("%#v", this.Untagged) + `}`}, ", ")
	return s
}
func (this *Layer2SriovInterfaceType_VlanId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.Layer2SriovInterfaceType_VlanId{` +
		`VlanId:` + fmt.Sprintf("%#v", this.VlanId) + `}`}, ", ")
	return s
}
func (this *Layer2InterfaceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&network_interface.Layer2InterfaceType{")
	if this.Layer2InterfaceChoice != nil {
		s = append(s, "Layer2InterfaceChoice: "+fmt.Sprintf("%#v", this.Layer2InterfaceChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Layer2InterfaceType_L2VlanInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.Layer2InterfaceType_L2VlanInterface{` +
		`L2VlanInterface:` + fmt.Sprintf("%#v", this.L2VlanInterface) + `}`}, ", ")
	return s
}
func (this *Layer2InterfaceType_L2VlanSloInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.Layer2InterfaceType_L2VlanSloInterface{` +
		`L2VlanSloInterface:` + fmt.Sprintf("%#v", this.L2VlanSloInterface) + `}`}, ", ")
	return s
}
func (this *Layer2InterfaceType_L2SriovInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.Layer2InterfaceType_L2SriovInterface{` +
		`L2SriovInterface:` + fmt.Sprintf("%#v", this.L2SriovInterface) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 39)
	s = append(s, "&network_interface.GlobalSpecType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Mtu: "+fmt.Sprintf("%#v", this.Mtu)+",\n")
	if this.VirtualNetwork != nil {
		s = append(s, "VirtualNetwork: "+fmt.Sprintf("%#v", this.VirtualNetwork)+",\n")
	}
	s = append(s, "DhcpAddress: "+fmt.Sprintf("%#v", this.DhcpAddress)+",\n")
	if this.StaticAddresses != nil {
		s = append(s, "StaticAddresses: "+fmt.Sprintf("%#v", this.StaticAddresses)+",\n")
	}
	if this.StaticIpv6Addresses != nil {
		s = append(s, "StaticIpv6Addresses: "+fmt.Sprintf("%#v", this.StaticIpv6Addresses)+",\n")
	}
	if this.DefaultGateway != nil {
		s = append(s, "DefaultGateway: "+fmt.Sprintf("%#v", this.DefaultGateway)+",\n")
	}
	if this.DNSServer != nil {
		s = append(s, "DNSServer: "+fmt.Sprintf("%#v", this.DNSServer)+",\n")
	}
	s = append(s, "DHCPServer: "+fmt.Sprintf("%#v", this.DHCPServer)+",\n")
	s = append(s, "VlanTagging: "+fmt.Sprintf("%#v", this.VlanTagging)+",\n")
	s = append(s, "DeviceName: "+fmt.Sprintf("%#v", this.DeviceName)+",\n")
	if this.ParentNetworkInterface != nil {
		s = append(s, "ParentNetworkInterface: "+fmt.Sprintf("%#v", this.ParentNetworkInterface)+",\n")
	}
	s = append(s, "VlanTag: "+fmt.Sprintf("%#v", this.VlanTag)+",\n")
	if this.Tunnel != nil {
		s = append(s, "Tunnel: "+fmt.Sprintf("%#v", this.Tunnel)+",\n")
	}
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	if this.AddressAllocator != nil {
		s = append(s, "AddressAllocator: "+fmt.Sprintf("%#v", this.AddressAllocator)+",\n")
	}
	if this.Ipv6AutoConfig != nil {
		s = append(s, "Ipv6AutoConfig: "+fmt.Sprintf("%#v", this.Ipv6AutoConfig)+",\n")
	}
	if this.DhcpServerParams != nil {
		s = append(s, "DhcpServerParams: "+fmt.Sprintf("%#v", this.DhcpServerParams)+",\n")
	}
	s = append(s, "NetworkConfig: "+fmt.Sprintf("%#v", this.NetworkConfig)+",\n")
	keysForInterfaceIpMap := make([]string, 0, len(this.InterfaceIpMap))
	for k, _ := range this.InterfaceIpMap {
		keysForInterfaceIpMap = append(keysForInterfaceIpMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForInterfaceIpMap)
	mapStringForInterfaceIpMap := "map[string]string{"
	for _, k := range keysForInterfaceIpMap {
		mapStringForInterfaceIpMap += fmt.Sprintf("%#v: %#v,", k, this.InterfaceIpMap[k])
	}
	mapStringForInterfaceIpMap += "}"
	if this.InterfaceIpMap != nil {
		s = append(s, "InterfaceIpMap: "+mapStringForInterfaceIpMap+",\n")
	}
	s = append(s, "IsPrimary: "+fmt.Sprintf("%#v", this.IsPrimary)+",\n")
	if this.MonitoringChoice != nil {
		s = append(s, "MonitoringChoice: "+fmt.Sprintf("%#v", this.MonitoringChoice)+",\n")
	}
	if this.Ipv6StaticAddresses != nil {
		s = append(s, "Ipv6StaticAddresses: "+fmt.Sprintf("%#v", this.Ipv6StaticAddresses)+",\n")
	}
	if this.Ipv4StaticAddresses != nil {
		s = append(s, "Ipv4StaticAddresses: "+fmt.Sprintf("%#v", this.Ipv4StaticAddresses)+",\n")
	}
	if this.VhostType != nil {
		s = append(s, "VhostType: "+fmt.Sprintf("%#v", this.VhostType)+",\n")
	}
	if this.SegmentMultiplexing != nil {
		s = append(s, "SegmentMultiplexing: "+fmt.Sprintf("%#v", this.SegmentMultiplexing)+",\n")
	}
	if this.InterfaceChoice != nil {
		s = append(s, "InterfaceChoice: "+fmt.Sprintf("%#v", this.InterfaceChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_MonitorDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GlobalSpecType_MonitorDisabled{` +
		`MonitorDisabled:` + fmt.Sprintf("%#v", this.MonitorDisabled) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_Monitor) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GlobalSpecType_Monitor{` +
		`Monitor:` + fmt.Sprintf("%#v", this.Monitor) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_SegmentationDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GlobalSpecType_SegmentationDisabled{` +
		`SegmentationDisabled:` + fmt.Sprintf("%#v", this.SegmentationDisabled) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_SegmentationEnabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GlobalSpecType_SegmentationEnabled{` +
		`SegmentationEnabled:` + fmt.Sprintf("%#v", this.SegmentationEnabled) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DedicatedInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GlobalSpecType_DedicatedInterface{` +
		`DedicatedInterface:` + fmt.Sprintf("%#v", this.DedicatedInterface) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_EthernetInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GlobalSpecType_EthernetInterface{` +
		`EthernetInterface:` + fmt.Sprintf("%#v", this.EthernetInterface) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_TunnelInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GlobalSpecType_TunnelInterface{` +
		`TunnelInterface:` + fmt.Sprintf("%#v", this.TunnelInterface) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_Legacy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GlobalSpecType_Legacy{` +
		`Legacy:` + fmt.Sprintf("%#v", this.Legacy) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_DedicatedManagementInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GlobalSpecType_DedicatedManagementInterface{` +
		`DedicatedManagementInterface:` + fmt.Sprintf("%#v", this.DedicatedManagementInterface) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_LoopbackInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GlobalSpecType_LoopbackInterface{` +
		`LoopbackInterface:` + fmt.Sprintf("%#v", this.LoopbackInterface) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_Layer2Interface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GlobalSpecType_Layer2Interface{` +
		`Layer2Interface:` + fmt.Sprintf("%#v", this.Layer2Interface) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&network_interface.CreateSpecType{")
	if this.InterfaceChoice != nil {
		s = append(s, "InterfaceChoice: "+fmt.Sprintf("%#v", this.InterfaceChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_DedicatedInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.CreateSpecType_DedicatedInterface{` +
		`DedicatedInterface:` + fmt.Sprintf("%#v", this.DedicatedInterface) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_EthernetInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.CreateSpecType_EthernetInterface{` +
		`EthernetInterface:` + fmt.Sprintf("%#v", this.EthernetInterface) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_TunnelInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.CreateSpecType_TunnelInterface{` +
		`TunnelInterface:` + fmt.Sprintf("%#v", this.TunnelInterface) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_LegacyInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.CreateSpecType_LegacyInterface{` +
		`LegacyInterface:` + fmt.Sprintf("%#v", this.LegacyInterface) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_DedicatedManagementInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.CreateSpecType_DedicatedManagementInterface{` +
		`DedicatedManagementInterface:` + fmt.Sprintf("%#v", this.DedicatedManagementInterface) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_Layer2Interface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.CreateSpecType_Layer2Interface{` +
		`Layer2Interface:` + fmt.Sprintf("%#v", this.Layer2Interface) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&network_interface.ReplaceSpecType{")
	if this.InterfaceChoice != nil {
		s = append(s, "InterfaceChoice: "+fmt.Sprintf("%#v", this.InterfaceChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_DedicatedInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.ReplaceSpecType_DedicatedInterface{` +
		`DedicatedInterface:` + fmt.Sprintf("%#v", this.DedicatedInterface) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_EthernetInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.ReplaceSpecType_EthernetInterface{` +
		`EthernetInterface:` + fmt.Sprintf("%#v", this.EthernetInterface) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_TunnelInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.ReplaceSpecType_TunnelInterface{` +
		`TunnelInterface:` + fmt.Sprintf("%#v", this.TunnelInterface) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_LegacyInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.ReplaceSpecType_LegacyInterface{` +
		`LegacyInterface:` + fmt.Sprintf("%#v", this.LegacyInterface) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_DedicatedManagementInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.ReplaceSpecType_DedicatedManagementInterface{` +
		`DedicatedManagementInterface:` + fmt.Sprintf("%#v", this.DedicatedManagementInterface) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_Layer2Interface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.ReplaceSpecType_Layer2Interface{` +
		`Layer2Interface:` + fmt.Sprintf("%#v", this.Layer2Interface) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 29)
	s = append(s, "&network_interface.GetSpecType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Mtu: "+fmt.Sprintf("%#v", this.Mtu)+",\n")
	if this.VirtualNetwork != nil {
		s = append(s, "VirtualNetwork: "+fmt.Sprintf("%#v", this.VirtualNetwork)+",\n")
	}
	s = append(s, "DhcpAddress: "+fmt.Sprintf("%#v", this.DhcpAddress)+",\n")
	if this.StaticAddresses != nil {
		s = append(s, "StaticAddresses: "+fmt.Sprintf("%#v", this.StaticAddresses)+",\n")
	}
	if this.DefaultGateway != nil {
		s = append(s, "DefaultGateway: "+fmt.Sprintf("%#v", this.DefaultGateway)+",\n")
	}
	if this.DNSServer != nil {
		s = append(s, "DNSServer: "+fmt.Sprintf("%#v", this.DNSServer)+",\n")
	}
	s = append(s, "DHCPServer: "+fmt.Sprintf("%#v", this.DHCPServer)+",\n")
	s = append(s, "VlanTagging: "+fmt.Sprintf("%#v", this.VlanTagging)+",\n")
	s = append(s, "DeviceName: "+fmt.Sprintf("%#v", this.DeviceName)+",\n")
	if this.ParentNetworkInterface != nil {
		s = append(s, "ParentNetworkInterface: "+fmt.Sprintf("%#v", this.ParentNetworkInterface)+",\n")
	}
	s = append(s, "VlanTag: "+fmt.Sprintf("%#v", this.VlanTag)+",\n")
	if this.Tunnel != nil {
		s = append(s, "Tunnel: "+fmt.Sprintf("%#v", this.Tunnel)+",\n")
	}
	s = append(s, "Priority: "+fmt.Sprintf("%#v", this.Priority)+",\n")
	if this.AddressAllocator != nil {
		s = append(s, "AddressAllocator: "+fmt.Sprintf("%#v", this.AddressAllocator)+",\n")
	}
	keysForInterfaceIpMap := make([]string, 0, len(this.InterfaceIpMap))
	for k, _ := range this.InterfaceIpMap {
		keysForInterfaceIpMap = append(keysForInterfaceIpMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForInterfaceIpMap)
	mapStringForInterfaceIpMap := "map[string]string{"
	for _, k := range keysForInterfaceIpMap {
		mapStringForInterfaceIpMap += fmt.Sprintf("%#v: %#v,", k, this.InterfaceIpMap[k])
	}
	mapStringForInterfaceIpMap += "}"
	if this.InterfaceIpMap != nil {
		s = append(s, "InterfaceIpMap: "+mapStringForInterfaceIpMap+",\n")
	}
	s = append(s, "IsPrimary: "+fmt.Sprintf("%#v", this.IsPrimary)+",\n")
	if this.MonitoringChoice != nil {
		s = append(s, "MonitoringChoice: "+fmt.Sprintf("%#v", this.MonitoringChoice)+",\n")
	}
	if this.InterfaceChoice != nil {
		s = append(s, "InterfaceChoice: "+fmt.Sprintf("%#v", this.InterfaceChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_MonitorDisabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GetSpecType_MonitorDisabled{` +
		`MonitorDisabled:` + fmt.Sprintf("%#v", this.MonitorDisabled) + `}`}, ", ")
	return s
}
func (this *GetSpecType_Monitor) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GetSpecType_Monitor{` +
		`Monitor:` + fmt.Sprintf("%#v", this.Monitor) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DedicatedInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GetSpecType_DedicatedInterface{` +
		`DedicatedInterface:` + fmt.Sprintf("%#v", this.DedicatedInterface) + `}`}, ", ")
	return s
}
func (this *GetSpecType_EthernetInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GetSpecType_EthernetInterface{` +
		`EthernetInterface:` + fmt.Sprintf("%#v", this.EthernetInterface) + `}`}, ", ")
	return s
}
func (this *GetSpecType_TunnelInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GetSpecType_TunnelInterface{` +
		`TunnelInterface:` + fmt.Sprintf("%#v", this.TunnelInterface) + `}`}, ", ")
	return s
}
func (this *GetSpecType_LegacyInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GetSpecType_LegacyInterface{` +
		`LegacyInterface:` + fmt.Sprintf("%#v", this.LegacyInterface) + `}`}, ", ")
	return s
}
func (this *GetSpecType_DedicatedManagementInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GetSpecType_DedicatedManagementInterface{` +
		`DedicatedManagementInterface:` + fmt.Sprintf("%#v", this.DedicatedManagementInterface) + `}`}, ", ")
	return s
}
func (this *GetSpecType_Layer2Interface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&network_interface.GetSpecType_Layer2Interface{` +
		`Layer2Interface:` + fmt.Sprintf("%#v", this.Layer2Interface) + `}`}, ", ")
	return s
}
func (this *NetworkInterfaceStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&network_interface.NetworkInterfaceStatus{")
	s = append(s, "UpDown: "+fmt.Sprintf("%#v", this.UpDown)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *NetworkInterfaceDFGW) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkInterfaceDFGW) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkInterfaceDFGW) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DefaultGatewayAddress != nil {
		{
			size, err := m.DefaultGatewayAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.DefaultGatewayMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DefaultGatewayMode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NetworkInterfaceDNS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkInterfaceDNS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkInterfaceDNS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DnsServer) > 0 {
		for iNdEx := len(m.DnsServer) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DnsServer[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.DnsMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DnsMode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NetworkInterfaceTunnel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkInterfaceTunnel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkInterfaceTunnel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tunnel) > 0 {
		for iNdEx := len(m.Tunnel) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tunnel[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DHCPPoolType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPPoolType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPPoolType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Exclude {
		i--
		if m.Exclude {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.EndIp) > 0 {
		i -= len(m.EndIp)
		copy(dAtA[i:], m.EndIp)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EndIp)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StartIp) > 0 {
		i -= len(m.StartIp)
		copy(dAtA[i:], m.StartIp)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StartIp)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DHCPIPV6PoolType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPIPV6PoolType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPIPV6PoolType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Exclude {
		i--
		if m.Exclude {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.EndIp) > 0 {
		i -= len(m.EndIp)
		copy(dAtA[i:], m.EndIp)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EndIp)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StartIp) > 0 {
		i -= len(m.StartIp)
		copy(dAtA[i:], m.StartIp)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StartIp)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DHCPIPV6NetworkType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPIPV6NetworkType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPIPV6NetworkType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for iNdEx := len(m.Pools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.NetworkPrefixChoice != nil {
		{
			size := m.NetworkPrefixChoice.Size()
			i -= size
			if _, err := m.NetworkPrefixChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DHCPIPV6NetworkType_NetworkPrefix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPIPV6NetworkType_NetworkPrefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.NetworkPrefix)
	copy(dAtA[i:], m.NetworkPrefix)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.NetworkPrefix)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *DHCPIPV6NetworkType_NetworkPrefixAllocator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPIPV6NetworkType_NetworkPrefixAllocator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NetworkPrefixAllocator != nil {
		{
			size, err := m.NetworkPrefixAllocator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DHCPNetworkType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPNetworkType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPNetworkType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PoolSettings != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PoolSettings))
		i--
		dAtA[i] = 0x60
	}
	if m.DnsChoice != nil {
		{
			size := m.DnsChoice.Size()
			i -= size
			if _, err := m.DnsChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.GatewayChoice != nil {
		{
			size := m.GatewayChoice.Size()
			i -= size
			if _, err := m.GatewayChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Pools) > 0 {
		for iNdEx := len(m.Pools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.NetworkPrefixChoice != nil {
		{
			size := m.NetworkPrefixChoice.Size()
			i -= size
			if _, err := m.NetworkPrefixChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DHCPNetworkType_NetworkPrefix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPNetworkType_NetworkPrefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.NetworkPrefix)
	copy(dAtA[i:], m.NetworkPrefix)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.NetworkPrefix)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *DHCPNetworkType_NetworkPrefixAllocator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPNetworkType_NetworkPrefixAllocator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NetworkPrefixAllocator != nil {
		{
			size, err := m.NetworkPrefixAllocator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DHCPNetworkType_FirstAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPNetworkType_FirstAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FirstAddress != nil {
		{
			size, err := m.FirstAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *DHCPNetworkType_LastAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPNetworkType_LastAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LastAddress != nil {
		{
			size, err := m.LastAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *DHCPNetworkType_DgwAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPNetworkType_DgwAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DgwAddress)
	copy(dAtA[i:], m.DgwAddress)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DgwAddress)))
	i--
	dAtA[i] = 0x42
	return len(dAtA) - i, nil
}
func (m *DHCPNetworkType_SameAsDgw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPNetworkType_SameAsDgw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SameAsDgw != nil {
		{
			size, err := m.SameAsDgw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *DHCPNetworkType_DnsAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPNetworkType_DnsAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DnsAddress)
	copy(dAtA[i:], m.DnsAddress)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DnsAddress)))
	i--
	dAtA[i] = 0x5a
	return len(dAtA) - i, nil
}
func (m *DHCPInterfaceIPType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPInterfaceIPType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPInterfaceIPType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InterfaceIpMap) > 0 {
		keysForInterfaceIpMap := make([]string, 0, len(m.InterfaceIpMap))
		for k := range m.InterfaceIpMap {
			keysForInterfaceIpMap = append(keysForInterfaceIpMap, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForInterfaceIpMap)
		for iNdEx := len(keysForInterfaceIpMap) - 1; iNdEx >= 0; iNdEx-- {
			v := m.InterfaceIpMap[string(keysForInterfaceIpMap[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForInterfaceIpMap[iNdEx])
			copy(dAtA[i:], keysForInterfaceIpMap[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForInterfaceIpMap[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DHCPInterfaceIPV6Type) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPInterfaceIPV6Type) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPInterfaceIPV6Type) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InterfaceIpMap) > 0 {
		keysForInterfaceIpMap := make([]string, 0, len(m.InterfaceIpMap))
		for k := range m.InterfaceIpMap {
			keysForInterfaceIpMap = append(keysForInterfaceIpMap, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForInterfaceIpMap)
		for iNdEx := len(keysForInterfaceIpMap) - 1; iNdEx >= 0; iNdEx-- {
			v := m.InterfaceIpMap[string(keysForInterfaceIpMap[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForInterfaceIpMap[iNdEx])
			copy(dAtA[i:], keysForInterfaceIpMap[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForInterfaceIpMap[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DHCPServerParametersType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPServerParametersType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPServerParametersType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DhcpOption82Tag) > 0 {
		i -= len(m.DhcpOption82Tag)
		copy(dAtA[i:], m.DhcpOption82Tag)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DhcpOption82Tag)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.FixedIpMap) > 0 {
		keysForFixedIpMap := make([]string, 0, len(m.FixedIpMap))
		for k := range m.FixedIpMap {
			keysForFixedIpMap = append(keysForFixedIpMap, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForFixedIpMap)
		for iNdEx := len(keysForFixedIpMap) - 1; iNdEx >= 0; iNdEx-- {
			v := m.FixedIpMap[string(keysForFixedIpMap[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForFixedIpMap[iNdEx])
			copy(dAtA[i:], keysForFixedIpMap[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForFixedIpMap[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.InterfacesAddressingChoice != nil {
		{
			size := m.InterfacesAddressingChoice.Size()
			i -= size
			if _, err := m.InterfacesAddressingChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.DhcpNetworks) > 0 {
		for iNdEx := len(m.DhcpNetworks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DhcpNetworks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DHCPServerParametersType_AutomaticFromStart) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPServerParametersType_AutomaticFromStart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AutomaticFromStart != nil {
		{
			size, err := m.AutomaticFromStart.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DHCPServerParametersType_AutomaticFromEnd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPServerParametersType_AutomaticFromEnd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AutomaticFromEnd != nil {
		{
			size, err := m.AutomaticFromEnd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DHCPServerParametersType_InterfaceIpMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPServerParametersType_InterfaceIpMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InterfaceIpMap != nil {
		{
			size, err := m.InterfaceIpMap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *IPV6AutoConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPV6AutoConfigType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPV6AutoConfigType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AutoconfigChoice != nil {
		{
			size := m.AutoconfigChoice.Size()
			i -= size
			if _, err := m.AutoconfigChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *IPV6AutoConfigType_Host) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPV6AutoConfigType_Host) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Host != nil {
		{
			size, err := m.Host.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *IPV6AutoConfigType_Router) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPV6AutoConfigType_Router) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Router != nil {
		{
			size, err := m.Router.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *IPV6AutoConfigRouterType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPV6AutoConfigRouterType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPV6AutoConfigRouterType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DnsConfig != nil {
		{
			size, err := m.DnsConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.AddressChoice != nil {
		{
			size := m.AddressChoice.Size()
			i -= size
			if _, err := m.AddressChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *IPV6AutoConfigRouterType_NetworkPrefix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPV6AutoConfigRouterType_NetworkPrefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.NetworkPrefix)
	copy(dAtA[i:], m.NetworkPrefix)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.NetworkPrefix)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *IPV6AutoConfigRouterType_Stateful) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPV6AutoConfigRouterType_Stateful) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Stateful != nil {
		{
			size, err := m.Stateful.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *IPV6DnsList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPV6DnsList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPV6DnsList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DnsList) > 0 {
		for iNdEx := len(m.DnsList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DnsList[iNdEx])
			copy(dAtA[i:], m.DnsList[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.DnsList[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IPV6LocalDnsAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPV6LocalDnsAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPV6LocalDnsAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LocalDnsChoice != nil {
		{
			size := m.LocalDnsChoice.Size()
			i -= size
			if _, err := m.LocalDnsChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *IPV6LocalDnsAddress_FirstAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPV6LocalDnsAddress_FirstAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FirstAddress != nil {
		{
			size, err := m.FirstAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *IPV6LocalDnsAddress_LastAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPV6LocalDnsAddress_LastAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LastAddress != nil {
		{
			size, err := m.LastAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *IPV6LocalDnsAddress_ConfiguredAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPV6LocalDnsAddress_ConfiguredAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ConfiguredAddress)
	copy(dAtA[i:], m.ConfiguredAddress)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ConfiguredAddress)))
	i--
	dAtA[i] = 0x2a
	return len(dAtA) - i, nil
}
func (m *IPV6DnsConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPV6DnsConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPV6DnsConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DnsChoice != nil {
		{
			size := m.DnsChoice.Size()
			i -= size
			if _, err := m.DnsChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *IPV6DnsConfig_LocalDns) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPV6DnsConfig_LocalDns) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LocalDns != nil {
		{
			size, err := m.LocalDns.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *IPV6DnsConfig_ConfiguredList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPV6DnsConfig_ConfiguredList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConfiguredList != nil {
		{
			size, err := m.ConfiguredList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DHCPIPV6StatefulServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DHCPIPV6StatefulServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPIPV6StatefulServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FixedIpMap) > 0 {
		keysForFixedIpMap := make([]string, 0, len(m.FixedIpMap))
		for k := range m.FixedIpMap {
			keysForFixedIpMap = append(keysForFixedIpMap, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForFixedIpMap)
		for iNdEx := len(keysForFixedIpMap) - 1; iNdEx >= 0; iNdEx-- {
			v := m.FixedIpMap[string(keysForFixedIpMap[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForFixedIpMap[iNdEx])
			copy(dAtA[i:], keysForFixedIpMap[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForFixedIpMap[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.InterfacesAddressingChoice != nil {
		{
			size := m.InterfacesAddressingChoice.Size()
			i -= size
			if _, err := m.InterfacesAddressingChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.DhcpNetworks) > 0 {
		for iNdEx := len(m.DhcpNetworks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DhcpNetworks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DHCPIPV6StatefulServer_AutomaticFromStart) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPIPV6StatefulServer_AutomaticFromStart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AutomaticFromStart != nil {
		{
			size, err := m.AutomaticFromStart.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DHCPIPV6StatefulServer_AutomaticFromEnd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPIPV6StatefulServer_AutomaticFromEnd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AutomaticFromEnd != nil {
		{
			size, err := m.AutomaticFromEnd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DHCPIPV6StatefulServer_InterfaceIpMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DHCPIPV6StatefulServer_InterfaceIpMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InterfaceIpMap != nil {
		{
			size, err := m.InterfaceIpMap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *StaticIpParametersNodeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaticIpParametersNodeType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StaticIpParametersNodeType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DnsServer) > 0 {
		i -= len(m.DnsServer)
		copy(dAtA[i:], m.DnsServer)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DnsServer)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DefaultGw) > 0 {
		i -= len(m.DefaultGw)
		copy(dAtA[i:], m.DefaultGw)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DefaultGw)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.IpAddress) > 0 {
		i -= len(m.IpAddress)
		copy(dAtA[i:], m.IpAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IpAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StaticIpParametersClusterType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaticIpParametersClusterType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StaticIpParametersClusterType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InterfaceIpMap) > 0 {
		keysForInterfaceIpMap := make([]string, 0, len(m.InterfaceIpMap))
		for k := range m.InterfaceIpMap {
			keysForInterfaceIpMap = append(keysForInterfaceIpMap, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForInterfaceIpMap)
		for iNdEx := len(keysForInterfaceIpMap) - 1; iNdEx >= 0; iNdEx-- {
			v := m.InterfaceIpMap[string(keysForInterfaceIpMap[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTypes(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForInterfaceIpMap[iNdEx])
			copy(dAtA[i:], keysForInterfaceIpMap[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForInterfaceIpMap[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StaticIpParametersFleetType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaticIpParametersFleetType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StaticIpParametersFleetType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DnsServer) > 0 {
		i -= len(m.DnsServer)
		copy(dAtA[i:], m.DnsServer)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DnsServer)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DefaultGw) > 0 {
		i -= len(m.DefaultGw)
		copy(dAtA[i:], m.DefaultGw)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DefaultGw)))
		i--
		dAtA[i] = 0x12
	}
	if m.NetworkPrefixAllocator != nil {
		{
			size, err := m.NetworkPrefixAllocator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StaticIPParametersType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaticIPParametersType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StaticIPParametersType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NetworkPrefixChoice != nil {
		{
			size := m.NetworkPrefixChoice.Size()
			i -= size
			if _, err := m.NetworkPrefixChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *StaticIPParametersType_NodeStaticIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StaticIPParametersType_NodeStaticIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NodeStaticIp != nil {
		{
			size, err := m.NodeStaticIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *StaticIPParametersType_ClusterStaticIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StaticIPParametersType_ClusterStaticIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClusterStaticIp != nil {
		{
			size, err := m.ClusterStaticIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *StaticIPParametersType_FleetStaticIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StaticIPParametersType_FleetStaticIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FleetStaticIp != nil {
		{
			size, err := m.FleetStaticIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DedicatedInterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DedicatedInterfaceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DedicatedInterfaceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MonitoringChoice != nil {
		{
			size := m.MonitoringChoice.Size()
			i -= size
			if _, err := m.MonitoringChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PrimaryChoice != nil {
		{
			size := m.PrimaryChoice.Size()
			i -= size
			if _, err := m.PrimaryChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Priority != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x48
	}
	if m.Mtu != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Mtu))
		i--
		dAtA[i] = 0x40
	}
	if m.NodeChoice != nil {
		{
			size := m.NodeChoice.Size()
			i -= size
			if _, err := m.NodeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Device) > 0 {
		i -= len(m.Device)
		copy(dAtA[i:], m.Device)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Device)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DedicatedInterfaceType_Cluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DedicatedInterfaceType_Cluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Cluster != nil {
		{
			size, err := m.Cluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DedicatedInterfaceType_Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DedicatedInterfaceType_Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Node)
	copy(dAtA[i:], m.Node)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Node)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *DedicatedInterfaceType_NotPrimary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DedicatedInterfaceType_NotPrimary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NotPrimary != nil {
		{
			size, err := m.NotPrimary.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *DedicatedInterfaceType_IsPrimary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DedicatedInterfaceType_IsPrimary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IsPrimary != nil {
		{
			size, err := m.IsPrimary.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *DedicatedInterfaceType_MonitorDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DedicatedInterfaceType_MonitorDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MonitorDisabled != nil {
		{
			size, err := m.MonitorDisabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *DedicatedInterfaceType_Monitor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DedicatedInterfaceType_Monitor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Monitor != nil {
		{
			size, err := m.Monitor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *DedicatedManagementInterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DedicatedManagementInterfaceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DedicatedManagementInterfaceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mtu != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Mtu))
		i--
		dAtA[i] = 0x28
	}
	if m.NodeChoice != nil {
		{
			size := m.NodeChoice.Size()
			i -= size
			if _, err := m.NodeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Device) > 0 {
		i -= len(m.Device)
		copy(dAtA[i:], m.Device)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Device)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DedicatedManagementInterfaceType_Cluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DedicatedManagementInterfaceType_Cluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Cluster != nil {
		{
			size, err := m.Cluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DedicatedManagementInterfaceType_Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DedicatedManagementInterfaceType_Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Node)
	copy(dAtA[i:], m.Node)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Node)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *EthernetInterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EthernetInterfaceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetInterfaceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ipv6AddressChoice != nil {
		{
			size := m.Ipv6AddressChoice.Size()
			i -= size
			if _, err := m.Ipv6AddressChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.NetworkChoice != nil {
		{
			size := m.NetworkChoice.Size()
			i -= size
			if _, err := m.NetworkChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.MonitoringChoice != nil {
		{
			size := m.MonitoringChoice.Size()
			i -= size
			if _, err := m.MonitoringChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.PrimaryChoice != nil {
		{
			size := m.PrimaryChoice.Size()
			i -= size
			if _, err := m.PrimaryChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Priority != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Mtu != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Mtu))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.AddressChoice != nil {
		{
			size := m.AddressChoice.Size()
			i -= size
			if _, err := m.AddressChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.VlanChoice != nil {
		{
			size := m.VlanChoice.Size()
			i -= size
			if _, err := m.VlanChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.NodeChoice != nil {
		{
			size := m.NodeChoice.Size()
			i -= size
			if _, err := m.NodeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Device) > 0 {
		i -= len(m.Device)
		copy(dAtA[i:], m.Device)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Device)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EthernetInterfaceType_Cluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetInterfaceType_Cluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Cluster != nil {
		{
			size, err := m.Cluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *EthernetInterfaceType_Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetInterfaceType_Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Node)
	copy(dAtA[i:], m.Node)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Node)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *EthernetInterfaceType_Untagged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetInterfaceType_Untagged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Untagged != nil {
		{
			size, err := m.Untagged.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *EthernetInterfaceType_VlanId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetInterfaceType_VlanId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.VlanId))
	i--
	dAtA[i] = 0x38
	return len(dAtA) - i, nil
}
func (m *EthernetInterfaceType_DhcpClient) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetInterfaceType_DhcpClient) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DhcpClient != nil {
		{
			size, err := m.DhcpClient.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *EthernetInterfaceType_DhcpServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetInterfaceType_DhcpServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DhcpServer != nil {
		{
			size, err := m.DhcpServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *EthernetInterfaceType_StaticIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetInterfaceType_StaticIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StaticIp != nil {
		{
			size, err := m.StaticIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *EthernetInterfaceType_SiteLocalNetwork) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetInterfaceType_SiteLocalNetwork) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteLocalNetwork != nil {
		{
			size, err := m.SiteLocalNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *EthernetInterfaceType_SiteLocalInsideNetwork) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetInterfaceType_SiteLocalInsideNetwork) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteLocalInsideNetwork != nil {
		{
			size, err := m.SiteLocalInsideNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *EthernetInterfaceType_InsideNetwork) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetInterfaceType_InsideNetwork) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InsideNetwork != nil {
		{
			size, err := m.InsideNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *EthernetInterfaceType_NotPrimary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetInterfaceType_NotPrimary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NotPrimary != nil {
		{
			size, err := m.NotPrimary.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *EthernetInterfaceType_IsPrimary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetInterfaceType_IsPrimary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IsPrimary != nil {
		{
			size, err := m.IsPrimary.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *EthernetInterfaceType_StorageNetwork) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetInterfaceType_StorageNetwork) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StorageNetwork != nil {
		{
			size, err := m.StorageNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *EthernetInterfaceType_MonitorDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetInterfaceType_MonitorDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MonitorDisabled != nil {
		{
			size, err := m.MonitorDisabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *EthernetInterfaceType_Monitor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetInterfaceType_Monitor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Monitor != nil {
		{
			size, err := m.Monitor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *EthernetInterfaceType_Srv6Network) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetInterfaceType_Srv6Network) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Srv6Network != nil {
		{
			size, err := m.Srv6Network.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *EthernetInterfaceType_IpFabricNetwork) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetInterfaceType_IpFabricNetwork) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpFabricNetwork != nil {
		{
			size, err := m.IpFabricNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *EthernetInterfaceType_SegmentNetwork) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetInterfaceType_SegmentNetwork) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SegmentNetwork != nil {
		{
			size, err := m.SegmentNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *EthernetInterfaceType_NoIpv6Address) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetInterfaceType_NoIpv6Address) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoIpv6Address != nil {
		{
			size, err := m.NoIpv6Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *EthernetInterfaceType_StaticIpv6Address) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetInterfaceType_StaticIpv6Address) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StaticIpv6Address != nil {
		{
			size, err := m.StaticIpv6Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *EthernetInterfaceType_Ipv6AutoConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EthernetInterfaceType_Ipv6AutoConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ipv6AutoConfig != nil {
		{
			size, err := m.Ipv6AutoConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *TunnelInterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelInterfaceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelInterfaceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Priority != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x58
	}
	if m.Mtu != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Mtu))
		i--
		dAtA[i] = 0x50
	}
	if m.NetworkChoice != nil {
		{
			size := m.NetworkChoice.Size()
			i -= size
			if _, err := m.NetworkChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.StaticIp != nil {
		{
			size, err := m.StaticIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Tunnel != nil {
		{
			size, err := m.Tunnel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.NodeChoice != nil {
		{
			size := m.NodeChoice.Size()
			i -= size
			if _, err := m.NodeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *TunnelInterfaceType_Cluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelInterfaceType_Cluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Cluster != nil {
		{
			size, err := m.Cluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *TunnelInterfaceType_Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelInterfaceType_Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Node)
	copy(dAtA[i:], m.Node)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Node)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *TunnelInterfaceType_SiteLocalNetwork) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelInterfaceType_SiteLocalNetwork) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteLocalNetwork != nil {
		{
			size, err := m.SiteLocalNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *TunnelInterfaceType_SiteLocalInsideNetwork) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelInterfaceType_SiteLocalInsideNetwork) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteLocalInsideNetwork != nil {
		{
			size, err := m.SiteLocalInsideNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *TunnelInterfaceType_InsideNetwork) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelInterfaceType_InsideNetwork) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InsideNetwork != nil {
		{
			size, err := m.InsideNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *LegacyInterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LegacyInterfaceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LegacyInterfaceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MonitoringChoice != nil {
		{
			size := m.MonitoringChoice.Size()
			i -= size
			if _, err := m.MonitoringChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.AddressAllocator) > 0 {
		for iNdEx := len(m.AddressAllocator) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AddressAllocator[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.Priority != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x78
	}
	if m.Tunnel != nil {
		{
			size, err := m.Tunnel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.VlanTag != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VlanTag))
		i--
		dAtA[i] = 0x68
	}
	if len(m.DeviceName) > 0 {
		i -= len(m.DeviceName)
		copy(dAtA[i:], m.DeviceName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DeviceName)))
		i--
		dAtA[i] = 0x5a
	}
	if m.VlanTagging != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VlanTagging))
		i--
		dAtA[i] = 0x50
	}
	if m.DHCPServer != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DHCPServer))
		i--
		dAtA[i] = 0x48
	}
	if m.DNSServer != nil {
		{
			size, err := m.DNSServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.DefaultGateway != nil {
		{
			size, err := m.DefaultGateway.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.StaticAddresses) > 0 {
		for iNdEx := len(m.StaticAddresses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StaticAddresses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.DhcpAddress != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DhcpAddress))
		i--
		dAtA[i] = 0x28
	}
	if len(m.VirtualNetwork) > 0 {
		for iNdEx := len(m.VirtualNetwork) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VirtualNetwork[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Mtu != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Mtu))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LegacyInterfaceType_MonitorDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LegacyInterfaceType_MonitorDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MonitorDisabled != nil {
		{
			size, err := m.MonitorDisabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *LegacyInterfaceType_Monitor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LegacyInterfaceType_Monitor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Monitor != nil {
		{
			size, err := m.Monitor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *LoopbackInterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoopbackInterfaceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoopbackInterfaceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ipv6AddressChoice != nil {
		{
			size := m.Ipv6AddressChoice.Size()
			i -= size
			if _, err := m.Ipv6AddressChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.NetworkChoice != nil {
		{
			size := m.NetworkChoice.Size()
			i -= size
			if _, err := m.NetworkChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Mtu != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Mtu))
		i--
		dAtA[i] = 0x48
	}
	if m.AddressChoice != nil {
		{
			size := m.AddressChoice.Size()
			i -= size
			if _, err := m.AddressChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.NodeChoice != nil {
		{
			size := m.NodeChoice.Size()
			i -= size
			if _, err := m.NodeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Device) > 0 {
		i -= len(m.Device)
		copy(dAtA[i:], m.Device)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Device)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoopbackInterfaceType_Cluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoopbackInterfaceType_Cluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Cluster != nil {
		{
			size, err := m.Cluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *LoopbackInterfaceType_Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoopbackInterfaceType_Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Node)
	copy(dAtA[i:], m.Node)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Node)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *LoopbackInterfaceType_DhcpClient) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoopbackInterfaceType_DhcpClient) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DhcpClient != nil {
		{
			size, err := m.DhcpClient.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *LoopbackInterfaceType_DhcpServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoopbackInterfaceType_DhcpServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DhcpServer != nil {
		{
			size, err := m.DhcpServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *LoopbackInterfaceType_StaticIp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoopbackInterfaceType_StaticIp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StaticIp != nil {
		{
			size, err := m.StaticIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *LoopbackInterfaceType_SiteLocalNetwork) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoopbackInterfaceType_SiteLocalNetwork) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteLocalNetwork != nil {
		{
			size, err := m.SiteLocalNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *LoopbackInterfaceType_SiteLocalInsideNetwork) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoopbackInterfaceType_SiteLocalInsideNetwork) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteLocalInsideNetwork != nil {
		{
			size, err := m.SiteLocalInsideNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *LoopbackInterfaceType_IpFabricNetwork) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoopbackInterfaceType_IpFabricNetwork) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpFabricNetwork != nil {
		{
			size, err := m.IpFabricNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *LoopbackInterfaceType_NoIpv6Address) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoopbackInterfaceType_NoIpv6Address) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoIpv6Address != nil {
		{
			size, err := m.NoIpv6Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *LoopbackInterfaceType_StaticIpv6Address) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoopbackInterfaceType_StaticIpv6Address) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StaticIpv6Address != nil {
		{
			size, err := m.StaticIpv6Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *LinkQualityMonitorConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkQualityMonitorConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LinkQualityMonitorConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *VhostInterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VhostInterfaceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VhostInterfaceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HostChoice != nil {
		{
			size := m.HostChoice.Size()
			i -= size
			if _, err := m.HostChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *VhostInterfaceType_NoHost) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VhostInterfaceType_NoHost) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoHost != nil {
		{
			size, err := m.NoHost.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *VhostInterfaceType_Vhost) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VhostInterfaceType_Vhost) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Vhost != nil {
		{
			size, err := m.Vhost.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *VhostInterfaceType_Virtual) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VhostInterfaceType_Virtual) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Virtual != nil {
		{
			size, err := m.Virtual.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Layer2VlanInterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Layer2VlanInterfaceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Layer2VlanInterfaceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VlanId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VlanId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Device) > 0 {
		i -= len(m.Device)
		copy(dAtA[i:], m.Device)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Device)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Layer2SloVlanInterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Layer2SloVlanInterfaceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Layer2SloVlanInterfaceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VlanId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VlanId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Layer2SriovInterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Layer2SriovInterfaceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Layer2SriovInterfaceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VlanChoice != nil {
		{
			size := m.VlanChoice.Size()
			i -= size
			if _, err := m.VlanChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Device) > 0 {
		i -= len(m.Device)
		copy(dAtA[i:], m.Device)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Device)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Layer2SriovInterfaceType_Untagged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Layer2SriovInterfaceType_Untagged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Untagged != nil {
		{
			size, err := m.Untagged.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Layer2SriovInterfaceType_VlanId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Layer2SriovInterfaceType_VlanId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.VlanId))
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *Layer2InterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Layer2InterfaceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Layer2InterfaceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Layer2InterfaceChoice != nil {
		{
			size := m.Layer2InterfaceChoice.Size()
			i -= size
			if _, err := m.Layer2InterfaceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Layer2InterfaceType_L2VlanInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Layer2InterfaceType_L2VlanInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.L2VlanInterface != nil {
		{
			size, err := m.L2VlanInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Layer2InterfaceType_L2VlanSloInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Layer2InterfaceType_L2VlanSloInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.L2VlanSloInterface != nil {
		{
			size, err := m.L2VlanSloInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Layer2InterfaceType_L2SriovInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Layer2InterfaceType_L2SriovInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.L2SriovInterface != nil {
		{
			size, err := m.L2SriovInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InterfaceChoice != nil {
		{
			size := m.InterfaceChoice.Size()
			i -= size
			if _, err := m.InterfaceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SegmentMultiplexing != nil {
		{
			size := m.SegmentMultiplexing.Size()
			i -= size
			if _, err := m.SegmentMultiplexing.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Ipv6AutoConfig != nil {
		{
			size, err := m.Ipv6AutoConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if len(m.StaticIpv6Addresses) > 0 {
		for iNdEx := len(m.StaticIpv6Addresses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StaticIpv6Addresses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.Ipv4StaticAddresses != nil {
		{
			size, err := m.Ipv4StaticAddresses.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	if m.VhostType != nil {
		{
			size, err := m.VhostType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if m.Ipv6StaticAddresses != nil {
		{
			size, err := m.Ipv6StaticAddresses.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.MonitoringChoice != nil {
		{
			size := m.MonitoringChoice.Size()
			i -= size
			if _, err := m.MonitoringChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.IsPrimary {
		i--
		if m.IsPrimary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if len(m.InterfaceIpMap) > 0 {
		keysForInterfaceIpMap := make([]string, 0, len(m.InterfaceIpMap))
		for k := range m.InterfaceIpMap {
			keysForInterfaceIpMap = append(keysForInterfaceIpMap, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForInterfaceIpMap)
		for iNdEx := len(keysForInterfaceIpMap) - 1; iNdEx >= 0; iNdEx-- {
			v := m.InterfaceIpMap[string(keysForInterfaceIpMap[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForInterfaceIpMap[iNdEx])
			copy(dAtA[i:], keysForInterfaceIpMap[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForInterfaceIpMap[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xf2
		}
	}
	if m.NetworkConfig != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NetworkConfig))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.DhcpServerParams != nil {
		{
			size, err := m.DhcpServerParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.AddressAllocator) > 0 {
		for iNdEx := len(m.AddressAllocator) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AddressAllocator[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.Priority != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x78
	}
	if m.Tunnel != nil {
		{
			size, err := m.Tunnel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.VlanTag != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VlanTag))
		i--
		dAtA[i] = 0x68
	}
	if len(m.ParentNetworkInterface) > 0 {
		for iNdEx := len(m.ParentNetworkInterface) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ParentNetworkInterface[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.DeviceName) > 0 {
		i -= len(m.DeviceName)
		copy(dAtA[i:], m.DeviceName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DeviceName)))
		i--
		dAtA[i] = 0x5a
	}
	if m.VlanTagging != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VlanTagging))
		i--
		dAtA[i] = 0x50
	}
	if m.DHCPServer != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DHCPServer))
		i--
		dAtA[i] = 0x48
	}
	if m.DNSServer != nil {
		{
			size, err := m.DNSServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.DefaultGateway != nil {
		{
			size, err := m.DefaultGateway.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.StaticAddresses) > 0 {
		for iNdEx := len(m.StaticAddresses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StaticAddresses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.DhcpAddress != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DhcpAddress))
		i--
		dAtA[i] = 0x28
	}
	if len(m.VirtualNetwork) > 0 {
		for iNdEx := len(m.VirtualNetwork) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VirtualNetwork[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Mtu != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Mtu))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_MonitorDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_MonitorDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MonitorDisabled != nil {
		{
			size, err := m.MonitorDisabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_Monitor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_Monitor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Monitor != nil {
		{
			size, err := m.Monitor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_SegmentationDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_SegmentationDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SegmentationDisabled != nil {
		{
			size, err := m.SegmentationDisabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_SegmentationEnabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_SegmentationEnabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SegmentationEnabled != nil {
		{
			size, err := m.SegmentationEnabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DedicatedInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DedicatedInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DedicatedInterface != nil {
		{
			size, err := m.DedicatedInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_EthernetInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_EthernetInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EthernetInterface != nil {
		{
			size, err := m.EthernetInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_TunnelInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_TunnelInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TunnelInterface != nil {
		{
			size, err := m.TunnelInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_Legacy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_Legacy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Legacy != nil {
		{
			size, err := m.Legacy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_DedicatedManagementInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DedicatedManagementInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DedicatedManagementInterface != nil {
		{
			size, err := m.DedicatedManagementInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_LoopbackInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_LoopbackInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LoopbackInterface != nil {
		{
			size, err := m.LoopbackInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_Layer2Interface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_Layer2Interface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Layer2Interface != nil {
		{
			size, err := m.Layer2Interface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3f
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InterfaceChoice != nil {
		{
			size := m.InterfaceChoice.Size()
			i -= size
			if _, err := m.InterfaceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_DedicatedInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DedicatedInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DedicatedInterface != nil {
		{
			size, err := m.DedicatedInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_EthernetInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_EthernetInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EthernetInterface != nil {
		{
			size, err := m.EthernetInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_TunnelInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_TunnelInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TunnelInterface != nil {
		{
			size, err := m.TunnelInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_LegacyInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_LegacyInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LegacyInterface != nil {
		{
			size, err := m.LegacyInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_DedicatedManagementInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_DedicatedManagementInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DedicatedManagementInterface != nil {
		{
			size, err := m.DedicatedManagementInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_Layer2Interface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_Layer2Interface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Layer2Interface != nil {
		{
			size, err := m.Layer2Interface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InterfaceChoice != nil {
		{
			size := m.InterfaceChoice.Size()
			i -= size
			if _, err := m.InterfaceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_DedicatedInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DedicatedInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DedicatedInterface != nil {
		{
			size, err := m.DedicatedInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_EthernetInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_EthernetInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EthernetInterface != nil {
		{
			size, err := m.EthernetInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_TunnelInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_TunnelInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TunnelInterface != nil {
		{
			size, err := m.TunnelInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_LegacyInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_LegacyInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LegacyInterface != nil {
		{
			size, err := m.LegacyInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_DedicatedManagementInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_DedicatedManagementInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DedicatedManagementInterface != nil {
		{
			size, err := m.DedicatedManagementInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_Layer2Interface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_Layer2Interface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Layer2Interface != nil {
		{
			size, err := m.Layer2Interface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MonitoringChoice != nil {
		{
			size := m.MonitoringChoice.Size()
			i -= size
			if _, err := m.MonitoringChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.IsPrimary {
		i--
		if m.IsPrimary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if len(m.InterfaceIpMap) > 0 {
		keysForInterfaceIpMap := make([]string, 0, len(m.InterfaceIpMap))
		for k := range m.InterfaceIpMap {
			keysForInterfaceIpMap = append(keysForInterfaceIpMap, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForInterfaceIpMap)
		for iNdEx := len(keysForInterfaceIpMap) - 1; iNdEx >= 0; iNdEx-- {
			v := m.InterfaceIpMap[string(keysForInterfaceIpMap[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForInterfaceIpMap[iNdEx])
			copy(dAtA[i:], keysForInterfaceIpMap[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForInterfaceIpMap[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xf2
		}
	}
	if m.InterfaceChoice != nil {
		{
			size := m.InterfaceChoice.Size()
			i -= size
			if _, err := m.InterfaceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.AddressAllocator) > 0 {
		for iNdEx := len(m.AddressAllocator) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AddressAllocator[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.Priority != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x78
	}
	if m.Tunnel != nil {
		{
			size, err := m.Tunnel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.VlanTag != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VlanTag))
		i--
		dAtA[i] = 0x68
	}
	if len(m.ParentNetworkInterface) > 0 {
		for iNdEx := len(m.ParentNetworkInterface) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ParentNetworkInterface[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.DeviceName) > 0 {
		i -= len(m.DeviceName)
		copy(dAtA[i:], m.DeviceName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DeviceName)))
		i--
		dAtA[i] = 0x5a
	}
	if m.VlanTagging != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VlanTagging))
		i--
		dAtA[i] = 0x50
	}
	if m.DHCPServer != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DHCPServer))
		i--
		dAtA[i] = 0x48
	}
	if m.DNSServer != nil {
		{
			size, err := m.DNSServer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.DefaultGateway != nil {
		{
			size, err := m.DefaultGateway.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.StaticAddresses) > 0 {
		for iNdEx := len(m.StaticAddresses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StaticAddresses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.DhcpAddress != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DhcpAddress))
		i--
		dAtA[i] = 0x28
	}
	if len(m.VirtualNetwork) > 0 {
		for iNdEx := len(m.VirtualNetwork) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VirtualNetwork[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Mtu != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Mtu))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_DedicatedInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DedicatedInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DedicatedInterface != nil {
		{
			size, err := m.DedicatedInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_EthernetInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_EthernetInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EthernetInterface != nil {
		{
			size, err := m.EthernetInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_TunnelInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_TunnelInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TunnelInterface != nil {
		{
			size, err := m.TunnelInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_LegacyInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_LegacyInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LegacyInterface != nil {
		{
			size, err := m.LegacyInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_DedicatedManagementInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_DedicatedManagementInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DedicatedManagementInterface != nil {
		{
			size, err := m.DedicatedManagementInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_Layer2Interface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_Layer2Interface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Layer2Interface != nil {
		{
			size, err := m.Layer2Interface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_MonitorDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_MonitorDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MonitorDisabled != nil {
		{
			size, err := m.MonitorDisabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_Monitor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_Monitor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Monitor != nil {
		{
			size, err := m.Monitor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *NetworkInterfaceStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkInterfaceStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkInterfaceStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpDown != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UpDown))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NetworkInterfaceDFGW) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultGatewayMode != 0 {
		n += 1 + sovTypes(uint64(m.DefaultGatewayMode))
	}
	if m.DefaultGatewayAddress != nil {
		l = m.DefaultGatewayAddress.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *NetworkInterfaceDNS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DnsMode != 0 {
		n += 1 + sovTypes(uint64(m.DnsMode))
	}
	if len(m.DnsServer) > 0 {
		for _, e := range m.DnsServer {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *NetworkInterfaceTunnel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tunnel) > 0 {
		for _, e := range m.Tunnel {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *DHCPPoolType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StartIp)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EndIp)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Exclude {
		n += 2
	}
	return n
}

func (m *DHCPIPV6PoolType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StartIp)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EndIp)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Exclude {
		n += 2
	}
	return n
}

func (m *DHCPIPV6NetworkType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NetworkPrefixChoice != nil {
		n += m.NetworkPrefixChoice.Size()
	}
	if len(m.Pools) > 0 {
		for _, e := range m.Pools {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *DHCPIPV6NetworkType_NetworkPrefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NetworkPrefix)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *DHCPIPV6NetworkType_NetworkPrefixAllocator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NetworkPrefixAllocator != nil {
		l = m.NetworkPrefixAllocator.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DHCPNetworkType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NetworkPrefixChoice != nil {
		n += m.NetworkPrefixChoice.Size()
	}
	if len(m.Pools) > 0 {
		for _, e := range m.Pools {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.GatewayChoice != nil {
		n += m.GatewayChoice.Size()
	}
	if m.DnsChoice != nil {
		n += m.DnsChoice.Size()
	}
	if m.PoolSettings != 0 {
		n += 1 + sovTypes(uint64(m.PoolSettings))
	}
	return n
}

func (m *DHCPNetworkType_NetworkPrefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NetworkPrefix)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *DHCPNetworkType_NetworkPrefixAllocator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NetworkPrefixAllocator != nil {
		l = m.NetworkPrefixAllocator.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DHCPNetworkType_FirstAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FirstAddress != nil {
		l = m.FirstAddress.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DHCPNetworkType_LastAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastAddress != nil {
		l = m.LastAddress.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DHCPNetworkType_DgwAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DgwAddress)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *DHCPNetworkType_SameAsDgw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SameAsDgw != nil {
		l = m.SameAsDgw.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DHCPNetworkType_DnsAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DnsAddress)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *DHCPInterfaceIPType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.InterfaceIpMap) > 0 {
		for k, v := range m.InterfaceIpMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DHCPInterfaceIPV6Type) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.InterfaceIpMap) > 0 {
		for k, v := range m.InterfaceIpMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DHCPServerParametersType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DhcpNetworks) > 0 {
		for _, e := range m.DhcpNetworks {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InterfacesAddressingChoice != nil {
		n += m.InterfacesAddressingChoice.Size()
	}
	if len(m.FixedIpMap) > 0 {
		for k, v := range m.FixedIpMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.DhcpOption82Tag)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *DHCPServerParametersType_AutomaticFromStart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AutomaticFromStart != nil {
		l = m.AutomaticFromStart.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DHCPServerParametersType_AutomaticFromEnd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AutomaticFromEnd != nil {
		l = m.AutomaticFromEnd.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DHCPServerParametersType_InterfaceIpMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InterfaceIpMap != nil {
		l = m.InterfaceIpMap.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *IPV6AutoConfigType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AutoconfigChoice != nil {
		n += m.AutoconfigChoice.Size()
	}
	return n
}

func (m *IPV6AutoConfigType_Host) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *IPV6AutoConfigType_Router) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Router != nil {
		l = m.Router.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *IPV6AutoConfigRouterType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddressChoice != nil {
		n += m.AddressChoice.Size()
	}
	if m.DnsConfig != nil {
		l = m.DnsConfig.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *IPV6AutoConfigRouterType_NetworkPrefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NetworkPrefix)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *IPV6AutoConfigRouterType_Stateful) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Stateful != nil {
		l = m.Stateful.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *IPV6DnsList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DnsList) > 0 {
		for _, s := range m.DnsList {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *IPV6LocalDnsAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LocalDnsChoice != nil {
		n += m.LocalDnsChoice.Size()
	}
	return n
}

func (m *IPV6LocalDnsAddress_FirstAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FirstAddress != nil {
		l = m.FirstAddress.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *IPV6LocalDnsAddress_LastAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastAddress != nil {
		l = m.LastAddress.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *IPV6LocalDnsAddress_ConfiguredAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConfiguredAddress)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *IPV6DnsConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DnsChoice != nil {
		n += m.DnsChoice.Size()
	}
	return n
}

func (m *IPV6DnsConfig_LocalDns) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LocalDns != nil {
		l = m.LocalDns.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *IPV6DnsConfig_ConfiguredList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfiguredList != nil {
		l = m.ConfiguredList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DHCPIPV6StatefulServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DhcpNetworks) > 0 {
		for _, e := range m.DhcpNetworks {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InterfacesAddressingChoice != nil {
		n += m.InterfacesAddressingChoice.Size()
	}
	if len(m.FixedIpMap) > 0 {
		for k, v := range m.FixedIpMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DHCPIPV6StatefulServer_AutomaticFromStart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AutomaticFromStart != nil {
		l = m.AutomaticFromStart.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DHCPIPV6StatefulServer_AutomaticFromEnd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AutomaticFromEnd != nil {
		l = m.AutomaticFromEnd.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DHCPIPV6StatefulServer_InterfaceIpMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InterfaceIpMap != nil {
		l = m.InterfaceIpMap.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *StaticIpParametersNodeType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DefaultGw)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DnsServer)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StaticIpParametersClusterType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.InterfaceIpMap) > 0 {
		for k, v := range m.InterfaceIpMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *StaticIpParametersFleetType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NetworkPrefixAllocator != nil {
		l = m.NetworkPrefixAllocator.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DefaultGw)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DnsServer)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StaticIPParametersType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NetworkPrefixChoice != nil {
		n += m.NetworkPrefixChoice.Size()
	}
	return n
}

func (m *StaticIPParametersType_NodeStaticIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeStaticIp != nil {
		l = m.NodeStaticIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *StaticIPParametersType_ClusterStaticIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterStaticIp != nil {
		l = m.ClusterStaticIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *StaticIPParametersType_FleetStaticIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FleetStaticIp != nil {
		l = m.FleetStaticIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DedicatedInterfaceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Device)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NodeChoice != nil {
		n += m.NodeChoice.Size()
	}
	if m.Mtu != 0 {
		n += 1 + sovTypes(uint64(m.Mtu))
	}
	if m.Priority != 0 {
		n += 1 + sovTypes(uint64(m.Priority))
	}
	if m.PrimaryChoice != nil {
		n += m.PrimaryChoice.Size()
	}
	if m.MonitoringChoice != nil {
		n += m.MonitoringChoice.Size()
	}
	return n
}

func (m *DedicatedInterfaceType_Cluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DedicatedInterfaceType_Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Node)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *DedicatedInterfaceType_NotPrimary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NotPrimary != nil {
		l = m.NotPrimary.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DedicatedInterfaceType_IsPrimary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsPrimary != nil {
		l = m.IsPrimary.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DedicatedInterfaceType_MonitorDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MonitorDisabled != nil {
		l = m.MonitorDisabled.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DedicatedInterfaceType_Monitor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Monitor != nil {
		l = m.Monitor.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DedicatedManagementInterfaceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Device)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NodeChoice != nil {
		n += m.NodeChoice.Size()
	}
	if m.Mtu != 0 {
		n += 1 + sovTypes(uint64(m.Mtu))
	}
	return n
}

func (m *DedicatedManagementInterfaceType_Cluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DedicatedManagementInterfaceType_Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Node)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *EthernetInterfaceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Device)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NodeChoice != nil {
		n += m.NodeChoice.Size()
	}
	if m.VlanChoice != nil {
		n += m.VlanChoice.Size()
	}
	if m.AddressChoice != nil {
		n += m.AddressChoice.Size()
	}
	if m.NetworkChoice != nil {
		n += m.NetworkChoice.Size()
	}
	if m.Mtu != 0 {
		n += 2 + sovTypes(uint64(m.Mtu))
	}
	if m.Priority != 0 {
		n += 2 + sovTypes(uint64(m.Priority))
	}
	if m.PrimaryChoice != nil {
		n += m.PrimaryChoice.Size()
	}
	if m.MonitoringChoice != nil {
		n += m.MonitoringChoice.Size()
	}
	if m.Ipv6AddressChoice != nil {
		n += m.Ipv6AddressChoice.Size()
	}
	return n
}

func (m *EthernetInterfaceType_Cluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Node)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *EthernetInterfaceType_Untagged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Untagged != nil {
		l = m.Untagged.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_VlanId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.VlanId))
	return n
}
func (m *EthernetInterfaceType_DhcpClient) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DhcpClient != nil {
		l = m.DhcpClient.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_DhcpServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DhcpServer != nil {
		l = m.DhcpServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_StaticIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StaticIp != nil {
		l = m.StaticIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_SiteLocalNetwork) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteLocalNetwork != nil {
		l = m.SiteLocalNetwork.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_SiteLocalInsideNetwork) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteLocalInsideNetwork != nil {
		l = m.SiteLocalInsideNetwork.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_InsideNetwork) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InsideNetwork != nil {
		l = m.InsideNetwork.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_NotPrimary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NotPrimary != nil {
		l = m.NotPrimary.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_IsPrimary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsPrimary != nil {
		l = m.IsPrimary.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_StorageNetwork) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNetwork != nil {
		l = m.StorageNetwork.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_MonitorDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MonitorDisabled != nil {
		l = m.MonitorDisabled.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_Monitor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Monitor != nil {
		l = m.Monitor.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_Srv6Network) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Srv6Network != nil {
		l = m.Srv6Network.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_IpFabricNetwork) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpFabricNetwork != nil {
		l = m.IpFabricNetwork.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_SegmentNetwork) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SegmentNetwork != nil {
		l = m.SegmentNetwork.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_NoIpv6Address) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoIpv6Address != nil {
		l = m.NoIpv6Address.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_StaticIpv6Address) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StaticIpv6Address != nil {
		l = m.StaticIpv6Address.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *EthernetInterfaceType_Ipv6AutoConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ipv6AutoConfig != nil {
		l = m.Ipv6AutoConfig.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TunnelInterfaceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeChoice != nil {
		n += m.NodeChoice.Size()
	}
	if m.Tunnel != nil {
		l = m.Tunnel.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.StaticIp != nil {
		l = m.StaticIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NetworkChoice != nil {
		n += m.NetworkChoice.Size()
	}
	if m.Mtu != 0 {
		n += 1 + sovTypes(uint64(m.Mtu))
	}
	if m.Priority != 0 {
		n += 1 + sovTypes(uint64(m.Priority))
	}
	return n
}

func (m *TunnelInterfaceType_Cluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TunnelInterfaceType_Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Node)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *TunnelInterfaceType_SiteLocalNetwork) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteLocalNetwork != nil {
		l = m.SiteLocalNetwork.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TunnelInterfaceType_SiteLocalInsideNetwork) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteLocalInsideNetwork != nil {
		l = m.SiteLocalInsideNetwork.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TunnelInterfaceType_InsideNetwork) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InsideNetwork != nil {
		l = m.InsideNetwork.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LegacyInterfaceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.Mtu != 0 {
		n += 1 + sovTypes(uint64(m.Mtu))
	}
	if len(m.VirtualNetwork) > 0 {
		for _, e := range m.VirtualNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.DhcpAddress != 0 {
		n += 1 + sovTypes(uint64(m.DhcpAddress))
	}
	if len(m.StaticAddresses) > 0 {
		for _, e := range m.StaticAddresses {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.DefaultGateway != nil {
		l = m.DefaultGateway.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DNSServer != nil {
		l = m.DNSServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DHCPServer != 0 {
		n += 1 + sovTypes(uint64(m.DHCPServer))
	}
	if m.VlanTagging != 0 {
		n += 1 + sovTypes(uint64(m.VlanTagging))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VlanTag != 0 {
		n += 1 + sovTypes(uint64(m.VlanTag))
	}
	if m.Tunnel != nil {
		l = m.Tunnel.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovTypes(uint64(m.Priority))
	}
	if len(m.AddressAllocator) > 0 {
		for _, e := range m.AddressAllocator {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.MonitoringChoice != nil {
		n += m.MonitoringChoice.Size()
	}
	return n
}

func (m *LegacyInterfaceType_MonitorDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MonitorDisabled != nil {
		l = m.MonitorDisabled.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LegacyInterfaceType_Monitor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Monitor != nil {
		l = m.Monitor.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LoopbackInterfaceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Device)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NodeChoice != nil {
		n += m.NodeChoice.Size()
	}
	if m.AddressChoice != nil {
		n += m.AddressChoice.Size()
	}
	if m.Mtu != 0 {
		n += 1 + sovTypes(uint64(m.Mtu))
	}
	if m.NetworkChoice != nil {
		n += m.NetworkChoice.Size()
	}
	if m.Ipv6AddressChoice != nil {
		n += m.Ipv6AddressChoice.Size()
	}
	return n
}

func (m *LoopbackInterfaceType_Cluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LoopbackInterfaceType_Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Node)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *LoopbackInterfaceType_DhcpClient) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DhcpClient != nil {
		l = m.DhcpClient.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LoopbackInterfaceType_DhcpServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DhcpServer != nil {
		l = m.DhcpServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LoopbackInterfaceType_StaticIp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StaticIp != nil {
		l = m.StaticIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LoopbackInterfaceType_SiteLocalNetwork) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteLocalNetwork != nil {
		l = m.SiteLocalNetwork.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LoopbackInterfaceType_SiteLocalInsideNetwork) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteLocalInsideNetwork != nil {
		l = m.SiteLocalInsideNetwork.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LoopbackInterfaceType_IpFabricNetwork) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpFabricNetwork != nil {
		l = m.IpFabricNetwork.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LoopbackInterfaceType_NoIpv6Address) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoIpv6Address != nil {
		l = m.NoIpv6Address.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LoopbackInterfaceType_StaticIpv6Address) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StaticIpv6Address != nil {
		l = m.StaticIpv6Address.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LinkQualityMonitorConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *VhostInterfaceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HostChoice != nil {
		n += m.HostChoice.Size()
	}
	return n
}

func (m *VhostInterfaceType_NoHost) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoHost != nil {
		l = m.NoHost.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VhostInterfaceType_Vhost) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vhost != nil {
		l = m.Vhost.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VhostInterfaceType_Virtual) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Virtual != nil {
		l = m.Virtual.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Layer2VlanInterfaceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Device)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VlanId != 0 {
		n += 1 + sovTypes(uint64(m.VlanId))
	}
	return n
}

func (m *Layer2SloVlanInterfaceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VlanId != 0 {
		n += 1 + sovTypes(uint64(m.VlanId))
	}
	return n
}

func (m *Layer2SriovInterfaceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Device)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VlanChoice != nil {
		n += m.VlanChoice.Size()
	}
	return n
}

func (m *Layer2SriovInterfaceType_Untagged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Untagged != nil {
		l = m.Untagged.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Layer2SriovInterfaceType_VlanId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.VlanId))
	return n
}
func (m *Layer2InterfaceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Layer2InterfaceChoice != nil {
		n += m.Layer2InterfaceChoice.Size()
	}
	return n
}

func (m *Layer2InterfaceType_L2VlanInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.L2VlanInterface != nil {
		l = m.L2VlanInterface.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Layer2InterfaceType_L2VlanSloInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.L2VlanSloInterface != nil {
		l = m.L2VlanSloInterface.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Layer2InterfaceType_L2SriovInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.L2SriovInterface != nil {
		l = m.L2SriovInterface.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.Mtu != 0 {
		n += 1 + sovTypes(uint64(m.Mtu))
	}
	if len(m.VirtualNetwork) > 0 {
		for _, e := range m.VirtualNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.DhcpAddress != 0 {
		n += 1 + sovTypes(uint64(m.DhcpAddress))
	}
	if len(m.StaticAddresses) > 0 {
		for _, e := range m.StaticAddresses {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.DefaultGateway != nil {
		l = m.DefaultGateway.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DNSServer != nil {
		l = m.DNSServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DHCPServer != 0 {
		n += 1 + sovTypes(uint64(m.DHCPServer))
	}
	if m.VlanTagging != 0 {
		n += 1 + sovTypes(uint64(m.VlanTagging))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.ParentNetworkInterface) > 0 {
		for _, e := range m.ParentNetworkInterface {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.VlanTag != 0 {
		n += 1 + sovTypes(uint64(m.VlanTag))
	}
	if m.Tunnel != nil {
		l = m.Tunnel.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovTypes(uint64(m.Priority))
	}
	if len(m.AddressAllocator) > 0 {
		for _, e := range m.AddressAllocator {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.DhcpServerParams != nil {
		l = m.DhcpServerParams.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.NetworkConfig != 0 {
		n += 2 + sovTypes(uint64(m.NetworkConfig))
	}
	if len(m.InterfaceIpMap) > 0 {
		for k, v := range m.InterfaceIpMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.IsPrimary {
		n += 3
	}
	if m.MonitoringChoice != nil {
		n += m.MonitoringChoice.Size()
	}
	if m.Ipv6StaticAddresses != nil {
		l = m.Ipv6StaticAddresses.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.VhostType != nil {
		l = m.VhostType.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.Ipv4StaticAddresses != nil {
		l = m.Ipv4StaticAddresses.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.StaticIpv6Addresses) > 0 {
		for _, e := range m.StaticIpv6Addresses {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.Ipv6AutoConfig != nil {
		l = m.Ipv6AutoConfig.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.SegmentMultiplexing != nil {
		n += m.SegmentMultiplexing.Size()
	}
	if m.InterfaceChoice != nil {
		n += m.InterfaceChoice.Size()
	}
	return n
}

func (m *GlobalSpecType_MonitorDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MonitorDisabled != nil {
		l = m.MonitorDisabled.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_Monitor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Monitor != nil {
		l = m.Monitor.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_SegmentationDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SegmentationDisabled != nil {
		l = m.SegmentationDisabled.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_SegmentationEnabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SegmentationEnabled != nil {
		l = m.SegmentationEnabled.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DedicatedInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DedicatedInterface != nil {
		l = m.DedicatedInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_EthernetInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EthernetInterface != nil {
		l = m.EthernetInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_TunnelInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TunnelInterface != nil {
		l = m.TunnelInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_Legacy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Legacy != nil {
		l = m.Legacy.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_DedicatedManagementInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DedicatedManagementInterface != nil {
		l = m.DedicatedManagementInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_LoopbackInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LoopbackInterface != nil {
		l = m.LoopbackInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_Layer2Interface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Layer2Interface != nil {
		l = m.Layer2Interface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InterfaceChoice != nil {
		n += m.InterfaceChoice.Size()
	}
	return n
}

func (m *CreateSpecType_DedicatedInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DedicatedInterface != nil {
		l = m.DedicatedInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_EthernetInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EthernetInterface != nil {
		l = m.EthernetInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_TunnelInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TunnelInterface != nil {
		l = m.TunnelInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_LegacyInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LegacyInterface != nil {
		l = m.LegacyInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_DedicatedManagementInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DedicatedManagementInterface != nil {
		l = m.DedicatedManagementInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_Layer2Interface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Layer2Interface != nil {
		l = m.Layer2Interface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InterfaceChoice != nil {
		n += m.InterfaceChoice.Size()
	}
	return n
}

func (m *ReplaceSpecType_DedicatedInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DedicatedInterface != nil {
		l = m.DedicatedInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_EthernetInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EthernetInterface != nil {
		l = m.EthernetInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_TunnelInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TunnelInterface != nil {
		l = m.TunnelInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_LegacyInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LegacyInterface != nil {
		l = m.LegacyInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_DedicatedManagementInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DedicatedManagementInterface != nil {
		l = m.DedicatedManagementInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_Layer2Interface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Layer2Interface != nil {
		l = m.Layer2Interface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.Mtu != 0 {
		n += 1 + sovTypes(uint64(m.Mtu))
	}
	if len(m.VirtualNetwork) > 0 {
		for _, e := range m.VirtualNetwork {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.DhcpAddress != 0 {
		n += 1 + sovTypes(uint64(m.DhcpAddress))
	}
	if len(m.StaticAddresses) > 0 {
		for _, e := range m.StaticAddresses {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.DefaultGateway != nil {
		l = m.DefaultGateway.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DNSServer != nil {
		l = m.DNSServer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DHCPServer != 0 {
		n += 1 + sovTypes(uint64(m.DHCPServer))
	}
	if m.VlanTagging != 0 {
		n += 1 + sovTypes(uint64(m.VlanTagging))
	}
	l = len(m.DeviceName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.ParentNetworkInterface) > 0 {
		for _, e := range m.ParentNetworkInterface {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.VlanTag != 0 {
		n += 1 + sovTypes(uint64(m.VlanTag))
	}
	if m.Tunnel != nil {
		l = m.Tunnel.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovTypes(uint64(m.Priority))
	}
	if len(m.AddressAllocator) > 0 {
		for _, e := range m.AddressAllocator {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.InterfaceChoice != nil {
		n += m.InterfaceChoice.Size()
	}
	if len(m.InterfaceIpMap) > 0 {
		for k, v := range m.InterfaceIpMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.IsPrimary {
		n += 3
	}
	if m.MonitoringChoice != nil {
		n += m.MonitoringChoice.Size()
	}
	return n
}

func (m *GetSpecType_DedicatedInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DedicatedInterface != nil {
		l = m.DedicatedInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_EthernetInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EthernetInterface != nil {
		l = m.EthernetInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_TunnelInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TunnelInterface != nil {
		l = m.TunnelInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_LegacyInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LegacyInterface != nil {
		l = m.LegacyInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_DedicatedManagementInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DedicatedManagementInterface != nil {
		l = m.DedicatedManagementInterface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_Layer2Interface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Layer2Interface != nil {
		l = m.Layer2Interface.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_MonitorDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MonitorDisabled != nil {
		l = m.MonitorDisabled.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_Monitor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Monitor != nil {
		l = m.Monitor.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkInterfaceStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpDown != 0 {
		n += 1 + sovTypes(uint64(m.UpDown))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *NetworkInterfaceDFGW) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkInterfaceDFGW{`,
		`DefaultGatewayMode:` + fmt.Sprintf("%v", this.DefaultGatewayMode) + `,`,
		`DefaultGatewayAddress:` + strings.Replace(fmt.Sprintf("%v", this.DefaultGatewayAddress), "Ipv4AddressType", "schema.Ipv4AddressType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkInterfaceDNS) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDnsServer := "[]*Ipv4AddressType{"
	for _, f := range this.DnsServer {
		repeatedStringForDnsServer += strings.Replace(fmt.Sprintf("%v", f), "Ipv4AddressType", "schema.Ipv4AddressType", 1) + ","
	}
	repeatedStringForDnsServer += "}"
	s := strings.Join([]string{`&NetworkInterfaceDNS{`,
		`DnsMode:` + fmt.Sprintf("%v", this.DnsMode) + `,`,
		`DnsServer:` + repeatedStringForDnsServer + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkInterfaceTunnel) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTunnel := "[]*ObjectRefType{"
	for _, f := range this.Tunnel {
		repeatedStringForTunnel += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForTunnel += "}"
	s := strings.Join([]string{`&NetworkInterfaceTunnel{`,
		`Tunnel:` + repeatedStringForTunnel + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPPoolType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPPoolType{`,
		`StartIp:` + fmt.Sprintf("%v", this.StartIp) + `,`,
		`EndIp:` + fmt.Sprintf("%v", this.EndIp) + `,`,
		`Exclude:` + fmt.Sprintf("%v", this.Exclude) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPIPV6PoolType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPIPV6PoolType{`,
		`StartIp:` + fmt.Sprintf("%v", this.StartIp) + `,`,
		`EndIp:` + fmt.Sprintf("%v", this.EndIp) + `,`,
		`Exclude:` + fmt.Sprintf("%v", this.Exclude) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPIPV6NetworkType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPools := "[]*DHCPIPV6PoolType{"
	for _, f := range this.Pools {
		repeatedStringForPools += strings.Replace(f.String(), "DHCPIPV6PoolType", "DHCPIPV6PoolType", 1) + ","
	}
	repeatedStringForPools += "}"
	s := strings.Join([]string{`&DHCPIPV6NetworkType{`,
		`NetworkPrefixChoice:` + fmt.Sprintf("%v", this.NetworkPrefixChoice) + `,`,
		`Pools:` + repeatedStringForPools + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPIPV6NetworkType_NetworkPrefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPIPV6NetworkType_NetworkPrefix{`,
		`NetworkPrefix:` + fmt.Sprintf("%v", this.NetworkPrefix) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPIPV6NetworkType_NetworkPrefixAllocator) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPIPV6NetworkType_NetworkPrefixAllocator{`,
		`NetworkPrefixAllocator:` + strings.Replace(fmt.Sprintf("%v", this.NetworkPrefixAllocator), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPNetworkType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPools := "[]*DHCPPoolType{"
	for _, f := range this.Pools {
		repeatedStringForPools += strings.Replace(f.String(), "DHCPPoolType", "DHCPPoolType", 1) + ","
	}
	repeatedStringForPools += "}"
	s := strings.Join([]string{`&DHCPNetworkType{`,
		`NetworkPrefixChoice:` + fmt.Sprintf("%v", this.NetworkPrefixChoice) + `,`,
		`Pools:` + repeatedStringForPools + `,`,
		`GatewayChoice:` + fmt.Sprintf("%v", this.GatewayChoice) + `,`,
		`DnsChoice:` + fmt.Sprintf("%v", this.DnsChoice) + `,`,
		`PoolSettings:` + fmt.Sprintf("%v", this.PoolSettings) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPNetworkType_NetworkPrefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPNetworkType_NetworkPrefix{`,
		`NetworkPrefix:` + fmt.Sprintf("%v", this.NetworkPrefix) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPNetworkType_NetworkPrefixAllocator) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPNetworkType_NetworkPrefixAllocator{`,
		`NetworkPrefixAllocator:` + strings.Replace(fmt.Sprintf("%v", this.NetworkPrefixAllocator), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPNetworkType_FirstAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPNetworkType_FirstAddress{`,
		`FirstAddress:` + strings.Replace(fmt.Sprintf("%v", this.FirstAddress), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPNetworkType_LastAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPNetworkType_LastAddress{`,
		`LastAddress:` + strings.Replace(fmt.Sprintf("%v", this.LastAddress), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPNetworkType_DgwAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPNetworkType_DgwAddress{`,
		`DgwAddress:` + fmt.Sprintf("%v", this.DgwAddress) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPNetworkType_SameAsDgw) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPNetworkType_SameAsDgw{`,
		`SameAsDgw:` + strings.Replace(fmt.Sprintf("%v", this.SameAsDgw), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPNetworkType_DnsAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPNetworkType_DnsAddress{`,
		`DnsAddress:` + fmt.Sprintf("%v", this.DnsAddress) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPInterfaceIPType) String() string {
	if this == nil {
		return "nil"
	}
	keysForInterfaceIpMap := make([]string, 0, len(this.InterfaceIpMap))
	for k, _ := range this.InterfaceIpMap {
		keysForInterfaceIpMap = append(keysForInterfaceIpMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForInterfaceIpMap)
	mapStringForInterfaceIpMap := "map[string]string{"
	for _, k := range keysForInterfaceIpMap {
		mapStringForInterfaceIpMap += fmt.Sprintf("%v: %v,", k, this.InterfaceIpMap[k])
	}
	mapStringForInterfaceIpMap += "}"
	s := strings.Join([]string{`&DHCPInterfaceIPType{`,
		`InterfaceIpMap:` + mapStringForInterfaceIpMap + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPInterfaceIPV6Type) String() string {
	if this == nil {
		return "nil"
	}
	keysForInterfaceIpMap := make([]string, 0, len(this.InterfaceIpMap))
	for k, _ := range this.InterfaceIpMap {
		keysForInterfaceIpMap = append(keysForInterfaceIpMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForInterfaceIpMap)
	mapStringForInterfaceIpMap := "map[string]string{"
	for _, k := range keysForInterfaceIpMap {
		mapStringForInterfaceIpMap += fmt.Sprintf("%v: %v,", k, this.InterfaceIpMap[k])
	}
	mapStringForInterfaceIpMap += "}"
	s := strings.Join([]string{`&DHCPInterfaceIPV6Type{`,
		`InterfaceIpMap:` + mapStringForInterfaceIpMap + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPServerParametersType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDhcpNetworks := "[]*DHCPNetworkType{"
	for _, f := range this.DhcpNetworks {
		repeatedStringForDhcpNetworks += strings.Replace(f.String(), "DHCPNetworkType", "DHCPNetworkType", 1) + ","
	}
	repeatedStringForDhcpNetworks += "}"
	keysForFixedIpMap := make([]string, 0, len(this.FixedIpMap))
	for k, _ := range this.FixedIpMap {
		keysForFixedIpMap = append(keysForFixedIpMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForFixedIpMap)
	mapStringForFixedIpMap := "map[string]string{"
	for _, k := range keysForFixedIpMap {
		mapStringForFixedIpMap += fmt.Sprintf("%v: %v,", k, this.FixedIpMap[k])
	}
	mapStringForFixedIpMap += "}"
	s := strings.Join([]string{`&DHCPServerParametersType{`,
		`DhcpNetworks:` + repeatedStringForDhcpNetworks + `,`,
		`InterfacesAddressingChoice:` + fmt.Sprintf("%v", this.InterfacesAddressingChoice) + `,`,
		`FixedIpMap:` + mapStringForFixedIpMap + `,`,
		`DhcpOption82Tag:` + fmt.Sprintf("%v", this.DhcpOption82Tag) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPServerParametersType_AutomaticFromStart) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPServerParametersType_AutomaticFromStart{`,
		`AutomaticFromStart:` + strings.Replace(fmt.Sprintf("%v", this.AutomaticFromStart), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPServerParametersType_AutomaticFromEnd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPServerParametersType_AutomaticFromEnd{`,
		`AutomaticFromEnd:` + strings.Replace(fmt.Sprintf("%v", this.AutomaticFromEnd), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPServerParametersType_InterfaceIpMap) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPServerParametersType_InterfaceIpMap{`,
		`InterfaceIpMap:` + strings.Replace(fmt.Sprintf("%v", this.InterfaceIpMap), "DHCPInterfaceIPType", "DHCPInterfaceIPType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IPV6AutoConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IPV6AutoConfigType{`,
		`AutoconfigChoice:` + fmt.Sprintf("%v", this.AutoconfigChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IPV6AutoConfigType_Host) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IPV6AutoConfigType_Host{`,
		`Host:` + strings.Replace(fmt.Sprintf("%v", this.Host), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IPV6AutoConfigType_Router) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IPV6AutoConfigType_Router{`,
		`Router:` + strings.Replace(fmt.Sprintf("%v", this.Router), "IPV6AutoConfigRouterType", "IPV6AutoConfigRouterType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IPV6AutoConfigRouterType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IPV6AutoConfigRouterType{`,
		`AddressChoice:` + fmt.Sprintf("%v", this.AddressChoice) + `,`,
		`DnsConfig:` + strings.Replace(this.DnsConfig.String(), "IPV6DnsConfig", "IPV6DnsConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IPV6AutoConfigRouterType_NetworkPrefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IPV6AutoConfigRouterType_NetworkPrefix{`,
		`NetworkPrefix:` + fmt.Sprintf("%v", this.NetworkPrefix) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IPV6AutoConfigRouterType_Stateful) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IPV6AutoConfigRouterType_Stateful{`,
		`Stateful:` + strings.Replace(fmt.Sprintf("%v", this.Stateful), "DHCPIPV6StatefulServer", "DHCPIPV6StatefulServer", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IPV6DnsList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IPV6DnsList{`,
		`DnsList:` + fmt.Sprintf("%v", this.DnsList) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IPV6LocalDnsAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IPV6LocalDnsAddress{`,
		`LocalDnsChoice:` + fmt.Sprintf("%v", this.LocalDnsChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IPV6LocalDnsAddress_FirstAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IPV6LocalDnsAddress_FirstAddress{`,
		`FirstAddress:` + strings.Replace(fmt.Sprintf("%v", this.FirstAddress), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IPV6LocalDnsAddress_LastAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IPV6LocalDnsAddress_LastAddress{`,
		`LastAddress:` + strings.Replace(fmt.Sprintf("%v", this.LastAddress), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IPV6LocalDnsAddress_ConfiguredAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IPV6LocalDnsAddress_ConfiguredAddress{`,
		`ConfiguredAddress:` + fmt.Sprintf("%v", this.ConfiguredAddress) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IPV6DnsConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IPV6DnsConfig{`,
		`DnsChoice:` + fmt.Sprintf("%v", this.DnsChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IPV6DnsConfig_LocalDns) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IPV6DnsConfig_LocalDns{`,
		`LocalDns:` + strings.Replace(fmt.Sprintf("%v", this.LocalDns), "IPV6LocalDnsAddress", "IPV6LocalDnsAddress", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IPV6DnsConfig_ConfiguredList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IPV6DnsConfig_ConfiguredList{`,
		`ConfiguredList:` + strings.Replace(fmt.Sprintf("%v", this.ConfiguredList), "IPV6DnsList", "IPV6DnsList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPIPV6StatefulServer) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForDhcpNetworks := "[]*DHCPIPV6NetworkType{"
	for _, f := range this.DhcpNetworks {
		repeatedStringForDhcpNetworks += strings.Replace(f.String(), "DHCPIPV6NetworkType", "DHCPIPV6NetworkType", 1) + ","
	}
	repeatedStringForDhcpNetworks += "}"
	keysForFixedIpMap := make([]string, 0, len(this.FixedIpMap))
	for k, _ := range this.FixedIpMap {
		keysForFixedIpMap = append(keysForFixedIpMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForFixedIpMap)
	mapStringForFixedIpMap := "map[string]string{"
	for _, k := range keysForFixedIpMap {
		mapStringForFixedIpMap += fmt.Sprintf("%v: %v,", k, this.FixedIpMap[k])
	}
	mapStringForFixedIpMap += "}"
	s := strings.Join([]string{`&DHCPIPV6StatefulServer{`,
		`DhcpNetworks:` + repeatedStringForDhcpNetworks + `,`,
		`InterfacesAddressingChoice:` + fmt.Sprintf("%v", this.InterfacesAddressingChoice) + `,`,
		`FixedIpMap:` + mapStringForFixedIpMap + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPIPV6StatefulServer_AutomaticFromStart) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPIPV6StatefulServer_AutomaticFromStart{`,
		`AutomaticFromStart:` + strings.Replace(fmt.Sprintf("%v", this.AutomaticFromStart), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPIPV6StatefulServer_AutomaticFromEnd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPIPV6StatefulServer_AutomaticFromEnd{`,
		`AutomaticFromEnd:` + strings.Replace(fmt.Sprintf("%v", this.AutomaticFromEnd), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DHCPIPV6StatefulServer_InterfaceIpMap) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DHCPIPV6StatefulServer_InterfaceIpMap{`,
		`InterfaceIpMap:` + strings.Replace(fmt.Sprintf("%v", this.InterfaceIpMap), "DHCPInterfaceIPV6Type", "DHCPInterfaceIPV6Type", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StaticIpParametersNodeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StaticIpParametersNodeType{`,
		`IpAddress:` + fmt.Sprintf("%v", this.IpAddress) + `,`,
		`DefaultGw:` + fmt.Sprintf("%v", this.DefaultGw) + `,`,
		`DnsServer:` + fmt.Sprintf("%v", this.DnsServer) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StaticIpParametersClusterType) String() string {
	if this == nil {
		return "nil"
	}
	keysForInterfaceIpMap := make([]string, 0, len(this.InterfaceIpMap))
	for k, _ := range this.InterfaceIpMap {
		keysForInterfaceIpMap = append(keysForInterfaceIpMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForInterfaceIpMap)
	mapStringForInterfaceIpMap := "map[string]*StaticIpParametersNodeType{"
	for _, k := range keysForInterfaceIpMap {
		mapStringForInterfaceIpMap += fmt.Sprintf("%v: %v,", k, this.InterfaceIpMap[k])
	}
	mapStringForInterfaceIpMap += "}"
	s := strings.Join([]string{`&StaticIpParametersClusterType{`,
		`InterfaceIpMap:` + mapStringForInterfaceIpMap + `,`,
		`}`,
	}, "")
	return s
}
func (this *StaticIpParametersFleetType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StaticIpParametersFleetType{`,
		`NetworkPrefixAllocator:` + strings.Replace(fmt.Sprintf("%v", this.NetworkPrefixAllocator), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`DefaultGw:` + fmt.Sprintf("%v", this.DefaultGw) + `,`,
		`DnsServer:` + fmt.Sprintf("%v", this.DnsServer) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StaticIPParametersType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StaticIPParametersType{`,
		`NetworkPrefixChoice:` + fmt.Sprintf("%v", this.NetworkPrefixChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StaticIPParametersType_NodeStaticIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StaticIPParametersType_NodeStaticIp{`,
		`NodeStaticIp:` + strings.Replace(fmt.Sprintf("%v", this.NodeStaticIp), "StaticIpParametersNodeType", "StaticIpParametersNodeType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StaticIPParametersType_ClusterStaticIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StaticIPParametersType_ClusterStaticIp{`,
		`ClusterStaticIp:` + strings.Replace(fmt.Sprintf("%v", this.ClusterStaticIp), "StaticIpParametersClusterType", "StaticIpParametersClusterType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StaticIPParametersType_FleetStaticIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StaticIPParametersType_FleetStaticIp{`,
		`FleetStaticIp:` + strings.Replace(fmt.Sprintf("%v", this.FleetStaticIp), "StaticIpParametersFleetType", "StaticIpParametersFleetType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DedicatedInterfaceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DedicatedInterfaceType{`,
		`Device:` + fmt.Sprintf("%v", this.Device) + `,`,
		`NodeChoice:` + fmt.Sprintf("%v", this.NodeChoice) + `,`,
		`Mtu:` + fmt.Sprintf("%v", this.Mtu) + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`PrimaryChoice:` + fmt.Sprintf("%v", this.PrimaryChoice) + `,`,
		`MonitoringChoice:` + fmt.Sprintf("%v", this.MonitoringChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DedicatedInterfaceType_Cluster) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DedicatedInterfaceType_Cluster{`,
		`Cluster:` + strings.Replace(fmt.Sprintf("%v", this.Cluster), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DedicatedInterfaceType_Node) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DedicatedInterfaceType_Node{`,
		`Node:` + fmt.Sprintf("%v", this.Node) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DedicatedInterfaceType_NotPrimary) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DedicatedInterfaceType_NotPrimary{`,
		`NotPrimary:` + strings.Replace(fmt.Sprintf("%v", this.NotPrimary), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DedicatedInterfaceType_IsPrimary) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DedicatedInterfaceType_IsPrimary{`,
		`IsPrimary:` + strings.Replace(fmt.Sprintf("%v", this.IsPrimary), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DedicatedInterfaceType_MonitorDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DedicatedInterfaceType_MonitorDisabled{`,
		`MonitorDisabled:` + strings.Replace(fmt.Sprintf("%v", this.MonitorDisabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DedicatedInterfaceType_Monitor) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DedicatedInterfaceType_Monitor{`,
		`Monitor:` + strings.Replace(fmt.Sprintf("%v", this.Monitor), "LinkQualityMonitorConfig", "LinkQualityMonitorConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DedicatedManagementInterfaceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DedicatedManagementInterfaceType{`,
		`Device:` + fmt.Sprintf("%v", this.Device) + `,`,
		`NodeChoice:` + fmt.Sprintf("%v", this.NodeChoice) + `,`,
		`Mtu:` + fmt.Sprintf("%v", this.Mtu) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DedicatedManagementInterfaceType_Cluster) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DedicatedManagementInterfaceType_Cluster{`,
		`Cluster:` + strings.Replace(fmt.Sprintf("%v", this.Cluster), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DedicatedManagementInterfaceType_Node) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DedicatedManagementInterfaceType_Node{`,
		`Node:` + fmt.Sprintf("%v", this.Node) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType{`,
		`Device:` + fmt.Sprintf("%v", this.Device) + `,`,
		`NodeChoice:` + fmt.Sprintf("%v", this.NodeChoice) + `,`,
		`VlanChoice:` + fmt.Sprintf("%v", this.VlanChoice) + `,`,
		`AddressChoice:` + fmt.Sprintf("%v", this.AddressChoice) + `,`,
		`NetworkChoice:` + fmt.Sprintf("%v", this.NetworkChoice) + `,`,
		`Mtu:` + fmt.Sprintf("%v", this.Mtu) + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`PrimaryChoice:` + fmt.Sprintf("%v", this.PrimaryChoice) + `,`,
		`MonitoringChoice:` + fmt.Sprintf("%v", this.MonitoringChoice) + `,`,
		`Ipv6AddressChoice:` + fmt.Sprintf("%v", this.Ipv6AddressChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_Cluster) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_Cluster{`,
		`Cluster:` + strings.Replace(fmt.Sprintf("%v", this.Cluster), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_Node) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_Node{`,
		`Node:` + fmt.Sprintf("%v", this.Node) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_Untagged) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_Untagged{`,
		`Untagged:` + strings.Replace(fmt.Sprintf("%v", this.Untagged), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_VlanId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_VlanId{`,
		`VlanId:` + fmt.Sprintf("%v", this.VlanId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_DhcpClient) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_DhcpClient{`,
		`DhcpClient:` + strings.Replace(fmt.Sprintf("%v", this.DhcpClient), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_DhcpServer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_DhcpServer{`,
		`DhcpServer:` + strings.Replace(fmt.Sprintf("%v", this.DhcpServer), "DHCPServerParametersType", "DHCPServerParametersType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_StaticIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_StaticIp{`,
		`StaticIp:` + strings.Replace(fmt.Sprintf("%v", this.StaticIp), "StaticIPParametersType", "StaticIPParametersType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_SiteLocalNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_SiteLocalNetwork{`,
		`SiteLocalNetwork:` + strings.Replace(fmt.Sprintf("%v", this.SiteLocalNetwork), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_SiteLocalInsideNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_SiteLocalInsideNetwork{`,
		`SiteLocalInsideNetwork:` + strings.Replace(fmt.Sprintf("%v", this.SiteLocalInsideNetwork), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_InsideNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_InsideNetwork{`,
		`InsideNetwork:` + strings.Replace(fmt.Sprintf("%v", this.InsideNetwork), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_NotPrimary) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_NotPrimary{`,
		`NotPrimary:` + strings.Replace(fmt.Sprintf("%v", this.NotPrimary), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_IsPrimary) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_IsPrimary{`,
		`IsPrimary:` + strings.Replace(fmt.Sprintf("%v", this.IsPrimary), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_StorageNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_StorageNetwork{`,
		`StorageNetwork:` + strings.Replace(fmt.Sprintf("%v", this.StorageNetwork), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_MonitorDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_MonitorDisabled{`,
		`MonitorDisabled:` + strings.Replace(fmt.Sprintf("%v", this.MonitorDisabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_Monitor) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_Monitor{`,
		`Monitor:` + strings.Replace(fmt.Sprintf("%v", this.Monitor), "LinkQualityMonitorConfig", "LinkQualityMonitorConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_Srv6Network) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_Srv6Network{`,
		`Srv6Network:` + strings.Replace(fmt.Sprintf("%v", this.Srv6Network), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_IpFabricNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_IpFabricNetwork{`,
		`IpFabricNetwork:` + strings.Replace(fmt.Sprintf("%v", this.IpFabricNetwork), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_SegmentNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_SegmentNetwork{`,
		`SegmentNetwork:` + strings.Replace(fmt.Sprintf("%v", this.SegmentNetwork), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_NoIpv6Address) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_NoIpv6Address{`,
		`NoIpv6Address:` + strings.Replace(fmt.Sprintf("%v", this.NoIpv6Address), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_StaticIpv6Address) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_StaticIpv6Address{`,
		`StaticIpv6Address:` + strings.Replace(fmt.Sprintf("%v", this.StaticIpv6Address), "StaticIPParametersType", "StaticIPParametersType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EthernetInterfaceType_Ipv6AutoConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EthernetInterfaceType_Ipv6AutoConfig{`,
		`Ipv6AutoConfig:` + strings.Replace(fmt.Sprintf("%v", this.Ipv6AutoConfig), "IPV6AutoConfigType", "IPV6AutoConfigType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TunnelInterfaceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TunnelInterfaceType{`,
		`NodeChoice:` + fmt.Sprintf("%v", this.NodeChoice) + `,`,
		`Tunnel:` + strings.Replace(fmt.Sprintf("%v", this.Tunnel), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`StaticIp:` + strings.Replace(this.StaticIp.String(), "StaticIPParametersType", "StaticIPParametersType", 1) + `,`,
		`NetworkChoice:` + fmt.Sprintf("%v", this.NetworkChoice) + `,`,
		`Mtu:` + fmt.Sprintf("%v", this.Mtu) + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TunnelInterfaceType_Cluster) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TunnelInterfaceType_Cluster{`,
		`Cluster:` + strings.Replace(fmt.Sprintf("%v", this.Cluster), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TunnelInterfaceType_Node) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TunnelInterfaceType_Node{`,
		`Node:` + fmt.Sprintf("%v", this.Node) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TunnelInterfaceType_SiteLocalNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TunnelInterfaceType_SiteLocalNetwork{`,
		`SiteLocalNetwork:` + strings.Replace(fmt.Sprintf("%v", this.SiteLocalNetwork), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TunnelInterfaceType_SiteLocalInsideNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TunnelInterfaceType_SiteLocalInsideNetwork{`,
		`SiteLocalInsideNetwork:` + strings.Replace(fmt.Sprintf("%v", this.SiteLocalInsideNetwork), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TunnelInterfaceType_InsideNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TunnelInterfaceType_InsideNetwork{`,
		`InsideNetwork:` + strings.Replace(fmt.Sprintf("%v", this.InsideNetwork), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LegacyInterfaceType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForVirtualNetwork := "[]*ObjectRefType{"
	for _, f := range this.VirtualNetwork {
		repeatedStringForVirtualNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForVirtualNetwork += "}"
	repeatedStringForStaticAddresses := "[]*Ipv4SubnetType{"
	for _, f := range this.StaticAddresses {
		repeatedStringForStaticAddresses += strings.Replace(fmt.Sprintf("%v", f), "Ipv4SubnetType", "schema.Ipv4SubnetType", 1) + ","
	}
	repeatedStringForStaticAddresses += "}"
	repeatedStringForAddressAllocator := "[]*ObjectRefType{"
	for _, f := range this.AddressAllocator {
		repeatedStringForAddressAllocator += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForAddressAllocator += "}"
	s := strings.Join([]string{`&LegacyInterfaceType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Mtu:` + fmt.Sprintf("%v", this.Mtu) + `,`,
		`VirtualNetwork:` + repeatedStringForVirtualNetwork + `,`,
		`DhcpAddress:` + fmt.Sprintf("%v", this.DhcpAddress) + `,`,
		`StaticAddresses:` + repeatedStringForStaticAddresses + `,`,
		`DefaultGateway:` + strings.Replace(this.DefaultGateway.String(), "NetworkInterfaceDFGW", "NetworkInterfaceDFGW", 1) + `,`,
		`DNSServer:` + strings.Replace(this.DNSServer.String(), "NetworkInterfaceDNS", "NetworkInterfaceDNS", 1) + `,`,
		`DHCPServer:` + fmt.Sprintf("%v", this.DHCPServer) + `,`,
		`VlanTagging:` + fmt.Sprintf("%v", this.VlanTagging) + `,`,
		`DeviceName:` + fmt.Sprintf("%v", this.DeviceName) + `,`,
		`VlanTag:` + fmt.Sprintf("%v", this.VlanTag) + `,`,
		`Tunnel:` + strings.Replace(this.Tunnel.String(), "NetworkInterfaceTunnel", "NetworkInterfaceTunnel", 1) + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`AddressAllocator:` + repeatedStringForAddressAllocator + `,`,
		`MonitoringChoice:` + fmt.Sprintf("%v", this.MonitoringChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LegacyInterfaceType_MonitorDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LegacyInterfaceType_MonitorDisabled{`,
		`MonitorDisabled:` + strings.Replace(fmt.Sprintf("%v", this.MonitorDisabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LegacyInterfaceType_Monitor) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LegacyInterfaceType_Monitor{`,
		`Monitor:` + strings.Replace(fmt.Sprintf("%v", this.Monitor), "LinkQualityMonitorConfig", "LinkQualityMonitorConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoopbackInterfaceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoopbackInterfaceType{`,
		`Device:` + fmt.Sprintf("%v", this.Device) + `,`,
		`NodeChoice:` + fmt.Sprintf("%v", this.NodeChoice) + `,`,
		`AddressChoice:` + fmt.Sprintf("%v", this.AddressChoice) + `,`,
		`Mtu:` + fmt.Sprintf("%v", this.Mtu) + `,`,
		`NetworkChoice:` + fmt.Sprintf("%v", this.NetworkChoice) + `,`,
		`Ipv6AddressChoice:` + fmt.Sprintf("%v", this.Ipv6AddressChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoopbackInterfaceType_Cluster) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoopbackInterfaceType_Cluster{`,
		`Cluster:` + strings.Replace(fmt.Sprintf("%v", this.Cluster), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoopbackInterfaceType_Node) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoopbackInterfaceType_Node{`,
		`Node:` + fmt.Sprintf("%v", this.Node) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoopbackInterfaceType_DhcpClient) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoopbackInterfaceType_DhcpClient{`,
		`DhcpClient:` + strings.Replace(fmt.Sprintf("%v", this.DhcpClient), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoopbackInterfaceType_DhcpServer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoopbackInterfaceType_DhcpServer{`,
		`DhcpServer:` + strings.Replace(fmt.Sprintf("%v", this.DhcpServer), "DHCPServerParametersType", "DHCPServerParametersType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoopbackInterfaceType_StaticIp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoopbackInterfaceType_StaticIp{`,
		`StaticIp:` + strings.Replace(fmt.Sprintf("%v", this.StaticIp), "StaticIPParametersType", "StaticIPParametersType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoopbackInterfaceType_SiteLocalNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoopbackInterfaceType_SiteLocalNetwork{`,
		`SiteLocalNetwork:` + strings.Replace(fmt.Sprintf("%v", this.SiteLocalNetwork), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoopbackInterfaceType_SiteLocalInsideNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoopbackInterfaceType_SiteLocalInsideNetwork{`,
		`SiteLocalInsideNetwork:` + strings.Replace(fmt.Sprintf("%v", this.SiteLocalInsideNetwork), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoopbackInterfaceType_IpFabricNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoopbackInterfaceType_IpFabricNetwork{`,
		`IpFabricNetwork:` + strings.Replace(fmt.Sprintf("%v", this.IpFabricNetwork), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoopbackInterfaceType_NoIpv6Address) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoopbackInterfaceType_NoIpv6Address{`,
		`NoIpv6Address:` + strings.Replace(fmt.Sprintf("%v", this.NoIpv6Address), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoopbackInterfaceType_StaticIpv6Address) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoopbackInterfaceType_StaticIpv6Address{`,
		`StaticIpv6Address:` + strings.Replace(fmt.Sprintf("%v", this.StaticIpv6Address), "StaticIPParametersType", "StaticIPParametersType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LinkQualityMonitorConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LinkQualityMonitorConfig{`,
		`}`,
	}, "")
	return s
}
func (this *VhostInterfaceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VhostInterfaceType{`,
		`HostChoice:` + fmt.Sprintf("%v", this.HostChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VhostInterfaceType_NoHost) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VhostInterfaceType_NoHost{`,
		`NoHost:` + strings.Replace(fmt.Sprintf("%v", this.NoHost), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VhostInterfaceType_Vhost) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VhostInterfaceType_Vhost{`,
		`Vhost:` + strings.Replace(fmt.Sprintf("%v", this.Vhost), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VhostInterfaceType_Virtual) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VhostInterfaceType_Virtual{`,
		`Virtual:` + strings.Replace(fmt.Sprintf("%v", this.Virtual), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Layer2VlanInterfaceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Layer2VlanInterfaceType{`,
		`Device:` + fmt.Sprintf("%v", this.Device) + `,`,
		`VlanId:` + fmt.Sprintf("%v", this.VlanId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Layer2SloVlanInterfaceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Layer2SloVlanInterfaceType{`,
		`VlanId:` + fmt.Sprintf("%v", this.VlanId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Layer2SriovInterfaceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Layer2SriovInterfaceType{`,
		`Device:` + fmt.Sprintf("%v", this.Device) + `,`,
		`VlanChoice:` + fmt.Sprintf("%v", this.VlanChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Layer2SriovInterfaceType_Untagged) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Layer2SriovInterfaceType_Untagged{`,
		`Untagged:` + strings.Replace(fmt.Sprintf("%v", this.Untagged), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Layer2SriovInterfaceType_VlanId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Layer2SriovInterfaceType_VlanId{`,
		`VlanId:` + fmt.Sprintf("%v", this.VlanId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Layer2InterfaceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Layer2InterfaceType{`,
		`Layer2InterfaceChoice:` + fmt.Sprintf("%v", this.Layer2InterfaceChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Layer2InterfaceType_L2VlanInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Layer2InterfaceType_L2VlanInterface{`,
		`L2VlanInterface:` + strings.Replace(fmt.Sprintf("%v", this.L2VlanInterface), "Layer2VlanInterfaceType", "Layer2VlanInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Layer2InterfaceType_L2VlanSloInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Layer2InterfaceType_L2VlanSloInterface{`,
		`L2VlanSloInterface:` + strings.Replace(fmt.Sprintf("%v", this.L2VlanSloInterface), "Layer2SloVlanInterfaceType", "Layer2SloVlanInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Layer2InterfaceType_L2SriovInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Layer2InterfaceType_L2SriovInterface{`,
		`L2SriovInterface:` + strings.Replace(fmt.Sprintf("%v", this.L2SriovInterface), "Layer2SriovInterfaceType", "Layer2SriovInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForVirtualNetwork := "[]*ObjectRefType{"
	for _, f := range this.VirtualNetwork {
		repeatedStringForVirtualNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForVirtualNetwork += "}"
	repeatedStringForStaticAddresses := "[]*Ipv4SubnetType{"
	for _, f := range this.StaticAddresses {
		repeatedStringForStaticAddresses += strings.Replace(fmt.Sprintf("%v", f), "Ipv4SubnetType", "schema.Ipv4SubnetType", 1) + ","
	}
	repeatedStringForStaticAddresses += "}"
	repeatedStringForParentNetworkInterface := "[]*ObjectRefType{"
	for _, f := range this.ParentNetworkInterface {
		repeatedStringForParentNetworkInterface += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForParentNetworkInterface += "}"
	repeatedStringForAddressAllocator := "[]*ObjectRefType{"
	for _, f := range this.AddressAllocator {
		repeatedStringForAddressAllocator += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForAddressAllocator += "}"
	repeatedStringForStaticIpv6Addresses := "[]*Ipv6SubnetType{"
	for _, f := range this.StaticIpv6Addresses {
		repeatedStringForStaticIpv6Addresses += strings.Replace(fmt.Sprintf("%v", f), "Ipv6SubnetType", "schema.Ipv6SubnetType", 1) + ","
	}
	repeatedStringForStaticIpv6Addresses += "}"
	keysForInterfaceIpMap := make([]string, 0, len(this.InterfaceIpMap))
	for k, _ := range this.InterfaceIpMap {
		keysForInterfaceIpMap = append(keysForInterfaceIpMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForInterfaceIpMap)
	mapStringForInterfaceIpMap := "map[string]string{"
	for _, k := range keysForInterfaceIpMap {
		mapStringForInterfaceIpMap += fmt.Sprintf("%v: %v,", k, this.InterfaceIpMap[k])
	}
	mapStringForInterfaceIpMap += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Mtu:` + fmt.Sprintf("%v", this.Mtu) + `,`,
		`VirtualNetwork:` + repeatedStringForVirtualNetwork + `,`,
		`DhcpAddress:` + fmt.Sprintf("%v", this.DhcpAddress) + `,`,
		`StaticAddresses:` + repeatedStringForStaticAddresses + `,`,
		`DefaultGateway:` + strings.Replace(this.DefaultGateway.String(), "NetworkInterfaceDFGW", "NetworkInterfaceDFGW", 1) + `,`,
		`DNSServer:` + strings.Replace(this.DNSServer.String(), "NetworkInterfaceDNS", "NetworkInterfaceDNS", 1) + `,`,
		`DHCPServer:` + fmt.Sprintf("%v", this.DHCPServer) + `,`,
		`VlanTagging:` + fmt.Sprintf("%v", this.VlanTagging) + `,`,
		`DeviceName:` + fmt.Sprintf("%v", this.DeviceName) + `,`,
		`ParentNetworkInterface:` + repeatedStringForParentNetworkInterface + `,`,
		`VlanTag:` + fmt.Sprintf("%v", this.VlanTag) + `,`,
		`Tunnel:` + strings.Replace(this.Tunnel.String(), "NetworkInterfaceTunnel", "NetworkInterfaceTunnel", 1) + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`AddressAllocator:` + repeatedStringForAddressAllocator + `,`,
		`DhcpServerParams:` + strings.Replace(this.DhcpServerParams.String(), "DHCPServerParametersType", "DHCPServerParametersType", 1) + `,`,
		`NetworkConfig:` + fmt.Sprintf("%v", this.NetworkConfig) + `,`,
		`InterfaceIpMap:` + mapStringForInterfaceIpMap + `,`,
		`IsPrimary:` + fmt.Sprintf("%v", this.IsPrimary) + `,`,
		`MonitoringChoice:` + fmt.Sprintf("%v", this.MonitoringChoice) + `,`,
		`Ipv6StaticAddresses:` + strings.Replace(this.Ipv6StaticAddresses.String(), "StaticIPParametersType", "StaticIPParametersType", 1) + `,`,
		`VhostType:` + strings.Replace(this.VhostType.String(), "VhostInterfaceType", "VhostInterfaceType", 1) + `,`,
		`Ipv4StaticAddresses:` + strings.Replace(this.Ipv4StaticAddresses.String(), "StaticIPParametersType", "StaticIPParametersType", 1) + `,`,
		`StaticIpv6Addresses:` + repeatedStringForStaticIpv6Addresses + `,`,
		`Ipv6AutoConfig:` + strings.Replace(this.Ipv6AutoConfig.String(), "IPV6AutoConfigType", "IPV6AutoConfigType", 1) + `,`,
		`SegmentMultiplexing:` + fmt.Sprintf("%v", this.SegmentMultiplexing) + `,`,
		`InterfaceChoice:` + fmt.Sprintf("%v", this.InterfaceChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_MonitorDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_MonitorDisabled{`,
		`MonitorDisabled:` + strings.Replace(fmt.Sprintf("%v", this.MonitorDisabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Monitor) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Monitor{`,
		`Monitor:` + strings.Replace(fmt.Sprintf("%v", this.Monitor), "LinkQualityMonitorConfig", "LinkQualityMonitorConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_SegmentationDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_SegmentationDisabled{`,
		`SegmentationDisabled:` + strings.Replace(fmt.Sprintf("%v", this.SegmentationDisabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_SegmentationEnabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_SegmentationEnabled{`,
		`SegmentationEnabled:` + strings.Replace(fmt.Sprintf("%v", this.SegmentationEnabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DedicatedInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DedicatedInterface{`,
		`DedicatedInterface:` + strings.Replace(fmt.Sprintf("%v", this.DedicatedInterface), "DedicatedInterfaceType", "DedicatedInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_EthernetInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_EthernetInterface{`,
		`EthernetInterface:` + strings.Replace(fmt.Sprintf("%v", this.EthernetInterface), "EthernetInterfaceType", "EthernetInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_TunnelInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_TunnelInterface{`,
		`TunnelInterface:` + strings.Replace(fmt.Sprintf("%v", this.TunnelInterface), "TunnelInterfaceType", "TunnelInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Legacy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Legacy{`,
		`Legacy:` + strings.Replace(fmt.Sprintf("%v", this.Legacy), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DedicatedManagementInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DedicatedManagementInterface{`,
		`DedicatedManagementInterface:` + strings.Replace(fmt.Sprintf("%v", this.DedicatedManagementInterface), "DedicatedManagementInterfaceType", "DedicatedManagementInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_LoopbackInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_LoopbackInterface{`,
		`LoopbackInterface:` + strings.Replace(fmt.Sprintf("%v", this.LoopbackInterface), "LoopbackInterfaceType", "LoopbackInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Layer2Interface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Layer2Interface{`,
		`Layer2Interface:` + strings.Replace(fmt.Sprintf("%v", this.Layer2Interface), "Layer2InterfaceType", "Layer2InterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`InterfaceChoice:` + fmt.Sprintf("%v", this.InterfaceChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DedicatedInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DedicatedInterface{`,
		`DedicatedInterface:` + strings.Replace(fmt.Sprintf("%v", this.DedicatedInterface), "DedicatedInterfaceType", "DedicatedInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_EthernetInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_EthernetInterface{`,
		`EthernetInterface:` + strings.Replace(fmt.Sprintf("%v", this.EthernetInterface), "EthernetInterfaceType", "EthernetInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_TunnelInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_TunnelInterface{`,
		`TunnelInterface:` + strings.Replace(fmt.Sprintf("%v", this.TunnelInterface), "TunnelInterfaceType", "TunnelInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_LegacyInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_LegacyInterface{`,
		`LegacyInterface:` + strings.Replace(fmt.Sprintf("%v", this.LegacyInterface), "LegacyInterfaceType", "LegacyInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_DedicatedManagementInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_DedicatedManagementInterface{`,
		`DedicatedManagementInterface:` + strings.Replace(fmt.Sprintf("%v", this.DedicatedManagementInterface), "DedicatedManagementInterfaceType", "DedicatedManagementInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_Layer2Interface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_Layer2Interface{`,
		`Layer2Interface:` + strings.Replace(fmt.Sprintf("%v", this.Layer2Interface), "Layer2InterfaceType", "Layer2InterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`InterfaceChoice:` + fmt.Sprintf("%v", this.InterfaceChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DedicatedInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DedicatedInterface{`,
		`DedicatedInterface:` + strings.Replace(fmt.Sprintf("%v", this.DedicatedInterface), "DedicatedInterfaceType", "DedicatedInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_EthernetInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_EthernetInterface{`,
		`EthernetInterface:` + strings.Replace(fmt.Sprintf("%v", this.EthernetInterface), "EthernetInterfaceType", "EthernetInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_TunnelInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_TunnelInterface{`,
		`TunnelInterface:` + strings.Replace(fmt.Sprintf("%v", this.TunnelInterface), "TunnelInterfaceType", "TunnelInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_LegacyInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_LegacyInterface{`,
		`LegacyInterface:` + strings.Replace(fmt.Sprintf("%v", this.LegacyInterface), "LegacyInterfaceType", "LegacyInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_DedicatedManagementInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_DedicatedManagementInterface{`,
		`DedicatedManagementInterface:` + strings.Replace(fmt.Sprintf("%v", this.DedicatedManagementInterface), "DedicatedManagementInterfaceType", "DedicatedManagementInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_Layer2Interface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_Layer2Interface{`,
		`Layer2Interface:` + strings.Replace(fmt.Sprintf("%v", this.Layer2Interface), "Layer2InterfaceType", "Layer2InterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForVirtualNetwork := "[]*ObjectRefType{"
	for _, f := range this.VirtualNetwork {
		repeatedStringForVirtualNetwork += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForVirtualNetwork += "}"
	repeatedStringForStaticAddresses := "[]*Ipv4SubnetType{"
	for _, f := range this.StaticAddresses {
		repeatedStringForStaticAddresses += strings.Replace(fmt.Sprintf("%v", f), "Ipv4SubnetType", "schema.Ipv4SubnetType", 1) + ","
	}
	repeatedStringForStaticAddresses += "}"
	repeatedStringForParentNetworkInterface := "[]*ObjectRefType{"
	for _, f := range this.ParentNetworkInterface {
		repeatedStringForParentNetworkInterface += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForParentNetworkInterface += "}"
	repeatedStringForAddressAllocator := "[]*ObjectRefType{"
	for _, f := range this.AddressAllocator {
		repeatedStringForAddressAllocator += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForAddressAllocator += "}"
	keysForInterfaceIpMap := make([]string, 0, len(this.InterfaceIpMap))
	for k, _ := range this.InterfaceIpMap {
		keysForInterfaceIpMap = append(keysForInterfaceIpMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForInterfaceIpMap)
	mapStringForInterfaceIpMap := "map[string]string{"
	for _, k := range keysForInterfaceIpMap {
		mapStringForInterfaceIpMap += fmt.Sprintf("%v: %v,", k, this.InterfaceIpMap[k])
	}
	mapStringForInterfaceIpMap += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Mtu:` + fmt.Sprintf("%v", this.Mtu) + `,`,
		`VirtualNetwork:` + repeatedStringForVirtualNetwork + `,`,
		`DhcpAddress:` + fmt.Sprintf("%v", this.DhcpAddress) + `,`,
		`StaticAddresses:` + repeatedStringForStaticAddresses + `,`,
		`DefaultGateway:` + strings.Replace(this.DefaultGateway.String(), "NetworkInterfaceDFGW", "NetworkInterfaceDFGW", 1) + `,`,
		`DNSServer:` + strings.Replace(this.DNSServer.String(), "NetworkInterfaceDNS", "NetworkInterfaceDNS", 1) + `,`,
		`DHCPServer:` + fmt.Sprintf("%v", this.DHCPServer) + `,`,
		`VlanTagging:` + fmt.Sprintf("%v", this.VlanTagging) + `,`,
		`DeviceName:` + fmt.Sprintf("%v", this.DeviceName) + `,`,
		`ParentNetworkInterface:` + repeatedStringForParentNetworkInterface + `,`,
		`VlanTag:` + fmt.Sprintf("%v", this.VlanTag) + `,`,
		`Tunnel:` + strings.Replace(this.Tunnel.String(), "NetworkInterfaceTunnel", "NetworkInterfaceTunnel", 1) + `,`,
		`Priority:` + fmt.Sprintf("%v", this.Priority) + `,`,
		`AddressAllocator:` + repeatedStringForAddressAllocator + `,`,
		`InterfaceChoice:` + fmt.Sprintf("%v", this.InterfaceChoice) + `,`,
		`InterfaceIpMap:` + mapStringForInterfaceIpMap + `,`,
		`IsPrimary:` + fmt.Sprintf("%v", this.IsPrimary) + `,`,
		`MonitoringChoice:` + fmt.Sprintf("%v", this.MonitoringChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DedicatedInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DedicatedInterface{`,
		`DedicatedInterface:` + strings.Replace(fmt.Sprintf("%v", this.DedicatedInterface), "DedicatedInterfaceType", "DedicatedInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_EthernetInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_EthernetInterface{`,
		`EthernetInterface:` + strings.Replace(fmt.Sprintf("%v", this.EthernetInterface), "EthernetInterfaceType", "EthernetInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_TunnelInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_TunnelInterface{`,
		`TunnelInterface:` + strings.Replace(fmt.Sprintf("%v", this.TunnelInterface), "TunnelInterfaceType", "TunnelInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_LegacyInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_LegacyInterface{`,
		`LegacyInterface:` + strings.Replace(fmt.Sprintf("%v", this.LegacyInterface), "LegacyInterfaceType", "LegacyInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_DedicatedManagementInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_DedicatedManagementInterface{`,
		`DedicatedManagementInterface:` + strings.Replace(fmt.Sprintf("%v", this.DedicatedManagementInterface), "DedicatedManagementInterfaceType", "DedicatedManagementInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_Layer2Interface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_Layer2Interface{`,
		`Layer2Interface:` + strings.Replace(fmt.Sprintf("%v", this.Layer2Interface), "Layer2InterfaceType", "Layer2InterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_MonitorDisabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_MonitorDisabled{`,
		`MonitorDisabled:` + strings.Replace(fmt.Sprintf("%v", this.MonitorDisabled), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_Monitor) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_Monitor{`,
		`Monitor:` + strings.Replace(fmt.Sprintf("%v", this.Monitor), "LinkQualityMonitorConfig", "LinkQualityMonitorConfig", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkInterfaceStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkInterfaceStatus{`,
		`UpDown:` + fmt.Sprintf("%v", this.UpDown) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *NetworkInterfaceDFGW) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkInterfaceDFGW: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkInterfaceDFGW: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultGatewayMode", wireType)
			}
			m.DefaultGatewayMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultGatewayMode |= NetworkInterfaceGatewayMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultGatewayAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultGatewayAddress == nil {
				m.DefaultGatewayAddress = &schema.Ipv4AddressType{}
			}
			if err := m.DefaultGatewayAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkInterfaceDNS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkInterfaceDNS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkInterfaceDNS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsMode", wireType)
			}
			m.DnsMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DnsMode |= NetworkInterfaceDNSMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsServer = append(m.DnsServer, &schema.Ipv4AddressType{})
			if err := m.DnsServer[len(m.DnsServer)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkInterfaceTunnel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkInterfaceTunnel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkInterfaceTunnel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tunnel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tunnel = append(m.Tunnel, &schema.ObjectRefType{})
			if err := m.Tunnel[len(m.Tunnel)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPPoolType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPPoolType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPPoolType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclude", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exclude = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPIPV6PoolType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPIPV6PoolType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPIPV6PoolType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclude", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exclude = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPIPV6NetworkType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPIPV6NetworkType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPIPV6NetworkType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkPrefixChoice = &DHCPIPV6NetworkType_NetworkPrefix{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkPrefixAllocator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkPrefixChoice = &DHCPIPV6NetworkType_NetworkPrefixAllocator{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pools = append(m.Pools, &DHCPIPV6PoolType{})
			if err := m.Pools[len(m.Pools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPNetworkType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPNetworkType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPNetworkType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkPrefixChoice = &DHCPNetworkType_NetworkPrefix{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkPrefixAllocator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkPrefixChoice = &DHCPNetworkType_NetworkPrefixAllocator{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pools = append(m.Pools, &DHCPPoolType{})
			if err := m.Pools[len(m.Pools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GatewayChoice = &DHCPNetworkType_FirstAddress{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GatewayChoice = &DHCPNetworkType_LastAddress{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DgwAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GatewayChoice = &DHCPNetworkType_DgwAddress{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SameAsDgw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DnsChoice = &DHCPNetworkType_SameAsDgw{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsChoice = &DHCPNetworkType_DnsAddress{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolSettings", wireType)
			}
			m.PoolSettings = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolSettings |= DHCPPoolSettingType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPInterfaceIPType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPInterfaceIPType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPInterfaceIPType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceIpMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InterfaceIpMap == nil {
				m.InterfaceIpMap = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InterfaceIpMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPInterfaceIPV6Type) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPInterfaceIPV6Type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPInterfaceIPV6Type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceIpMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InterfaceIpMap == nil {
				m.InterfaceIpMap = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InterfaceIpMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPServerParametersType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPServerParametersType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPServerParametersType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpNetworks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DhcpNetworks = append(m.DhcpNetworks, &DHCPNetworkType{})
			if err := m.DhcpNetworks[len(m.DhcpNetworks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutomaticFromStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfacesAddressingChoice = &DHCPServerParametersType_AutomaticFromStart{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutomaticFromEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfacesAddressingChoice = &DHCPServerParametersType_AutomaticFromEnd{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceIpMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DHCPInterfaceIPType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfacesAddressingChoice = &DHCPServerParametersType_InterfaceIpMap{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixedIpMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FixedIpMap == nil {
				m.FixedIpMap = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FixedIpMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpOption82Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DhcpOption82Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPV6AutoConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPV6AutoConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPV6AutoConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AutoconfigChoice = &IPV6AutoConfigType_Host{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Router", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPV6AutoConfigRouterType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AutoconfigChoice = &IPV6AutoConfigType_Router{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPV6AutoConfigRouterType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPV6AutoConfigRouterType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPV6AutoConfigRouterType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressChoice = &IPV6AutoConfigRouterType_NetworkPrefix{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stateful", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DHCPIPV6StatefulServer{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AddressChoice = &IPV6AutoConfigRouterType_Stateful{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DnsConfig == nil {
				m.DnsConfig = &IPV6DnsConfig{}
			}
			if err := m.DnsConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPV6DnsList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPV6DnsList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPV6DnsList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsList = append(m.DnsList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPV6LocalDnsAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPV6LocalDnsAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPV6LocalDnsAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LocalDnsChoice = &IPV6LocalDnsAddress_FirstAddress{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LocalDnsChoice = &IPV6LocalDnsAddress_LastAddress{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfiguredAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalDnsChoice = &IPV6LocalDnsAddress_ConfiguredAddress{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPV6DnsConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPV6DnsConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPV6DnsConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalDns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPV6LocalDnsAddress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DnsChoice = &IPV6DnsConfig_LocalDns{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfiguredList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPV6DnsList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DnsChoice = &IPV6DnsConfig_ConfiguredList{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DHCPIPV6StatefulServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DHCPIPV6StatefulServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DHCPIPV6StatefulServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpNetworks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DhcpNetworks = append(m.DhcpNetworks, &DHCPIPV6NetworkType{})
			if err := m.DhcpNetworks[len(m.DhcpNetworks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutomaticFromStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfacesAddressingChoice = &DHCPIPV6StatefulServer_AutomaticFromStart{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutomaticFromEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfacesAddressingChoice = &DHCPIPV6StatefulServer_AutomaticFromEnd{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceIpMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DHCPInterfaceIPV6Type{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfacesAddressingChoice = &DHCPIPV6StatefulServer_InterfaceIpMap{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixedIpMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FixedIpMap == nil {
				m.FixedIpMap = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.FixedIpMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaticIpParametersNodeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaticIpParametersNodeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaticIpParametersNodeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultGw", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultGw = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsServer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsServer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaticIpParametersClusterType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaticIpParametersClusterType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaticIpParametersClusterType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceIpMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InterfaceIpMap == nil {
				m.InterfaceIpMap = make(map[string]*StaticIpParametersNodeType)
			}
			var mapkey string
			var mapvalue *StaticIpParametersNodeType
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &StaticIpParametersNodeType{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InterfaceIpMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaticIpParametersFleetType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaticIpParametersFleetType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaticIpParametersFleetType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkPrefixAllocator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkPrefixAllocator == nil {
				m.NetworkPrefixAllocator = &views.ObjectRefType{}
			}
			if err := m.NetworkPrefixAllocator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultGw", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultGw = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsServer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DnsServer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaticIPParametersType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaticIPParametersType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaticIPParametersType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeStaticIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StaticIpParametersNodeType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkPrefixChoice = &StaticIPParametersType_NodeStaticIp{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterStaticIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StaticIpParametersClusterType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkPrefixChoice = &StaticIPParametersType_ClusterStaticIp{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FleetStaticIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StaticIpParametersFleetType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkPrefixChoice = &StaticIPParametersType_FleetStaticIp{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DedicatedInterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DedicatedInterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DedicatedInterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Device = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NodeChoice = &DedicatedInterfaceType_Cluster{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeChoice = &DedicatedInterfaceType_Node{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotPrimary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PrimaryChoice = &DedicatedInterfaceType_NotPrimary{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrimary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PrimaryChoice = &DedicatedInterfaceType_IsPrimary{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonitorDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MonitoringChoice = &DedicatedInterfaceType_MonitorDisabled{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monitor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LinkQualityMonitorConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MonitoringChoice = &DedicatedInterfaceType_Monitor{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DedicatedManagementInterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DedicatedManagementInterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DedicatedManagementInterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Device = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NodeChoice = &DedicatedManagementInterfaceType_Cluster{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeChoice = &DedicatedManagementInterfaceType_Node{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EthernetInterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EthernetInterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EthernetInterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Device = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NodeChoice = &EthernetInterfaceType_Cluster{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeChoice = &EthernetInterfaceType_Node{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Untagged", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VlanChoice = &EthernetInterfaceType_Untagged{v}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VlanChoice = &EthernetInterfaceType_VlanId{v}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpClient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AddressChoice = &EthernetInterfaceType_DhcpClient{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DHCPServerParametersType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AddressChoice = &EthernetInterfaceType_DhcpServer{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StaticIPParametersType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AddressChoice = &EthernetInterfaceType_StaticIp{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteLocalNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &EthernetInterfaceType_SiteLocalNetwork{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteLocalInsideNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &EthernetInterfaceType_SiteLocalInsideNetwork{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &EthernetInterfaceType_InsideNetwork{v}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotPrimary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PrimaryChoice = &EthernetInterfaceType_NotPrimary{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrimary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PrimaryChoice = &EthernetInterfaceType_IsPrimary{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &EthernetInterfaceType_StorageNetwork{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonitorDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MonitoringChoice = &EthernetInterfaceType_MonitorDisabled{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monitor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LinkQualityMonitorConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MonitoringChoice = &EthernetInterfaceType_Monitor{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Srv6Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &EthernetInterfaceType_Srv6Network{v}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpFabricNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &EthernetInterfaceType_IpFabricNetwork{v}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &EthernetInterfaceType_SegmentNetwork{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoIpv6Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ipv6AddressChoice = &EthernetInterfaceType_NoIpv6Address{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticIpv6Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StaticIPParametersType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ipv6AddressChoice = &EthernetInterfaceType_StaticIpv6Address{v}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6AutoConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IPV6AutoConfigType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ipv6AddressChoice = &EthernetInterfaceType_Ipv6AutoConfig{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelInterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelInterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelInterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NodeChoice = &TunnelInterfaceType_Cluster{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeChoice = &TunnelInterfaceType_Node{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tunnel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tunnel == nil {
				m.Tunnel = &views.ObjectRefType{}
			}
			if err := m.Tunnel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StaticIp == nil {
				m.StaticIp = &StaticIPParametersType{}
			}
			if err := m.StaticIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteLocalNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &TunnelInterfaceType_SiteLocalNetwork{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteLocalInsideNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &TunnelInterfaceType_SiteLocalInsideNetwork{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &views.ObjectRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &TunnelInterfaceType_InsideNetwork{v}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LegacyInterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LegacyInterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LegacyInterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NetworkInterfaceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualNetwork = append(m.VirtualNetwork, &schema.ObjectRefType{})
			if err := m.VirtualNetwork[len(m.VirtualNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpAddress", wireType)
			}
			m.DhcpAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DhcpAddress |= NetworkInterfaceDHCP(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaticAddresses = append(m.StaticAddresses, &schema.Ipv4SubnetType{})
			if err := m.StaticAddresses[len(m.StaticAddresses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultGateway == nil {
				m.DefaultGateway = &NetworkInterfaceDFGW{}
			}
			if err := m.DefaultGateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNSServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DNSServer == nil {
				m.DNSServer = &NetworkInterfaceDNS{}
			}
			if err := m.DNSServer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DHCPServer", wireType)
			}
			m.DHCPServer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DHCPServer |= NetworkInterfaceDHCPServer(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanTagging", wireType)
			}
			m.VlanTagging = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlanTagging |= NetworkInterfaceVLANTagging(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanTag", wireType)
			}
			m.VlanTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlanTag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tunnel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tunnel == nil {
				m.Tunnel = &NetworkInterfaceTunnel{}
			}
			if err := m.Tunnel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressAllocator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressAllocator = append(m.AddressAllocator, &schema.ObjectRefType{})
			if err := m.AddressAllocator[len(m.AddressAllocator)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonitorDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MonitoringChoice = &LegacyInterfaceType_MonitorDisabled{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monitor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LinkQualityMonitorConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MonitoringChoice = &LegacyInterfaceType_Monitor{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoopbackInterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoopbackInterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoopbackInterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Device = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NodeChoice = &LoopbackInterfaceType_Cluster{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeChoice = &LoopbackInterfaceType_Node{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpClient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AddressChoice = &LoopbackInterfaceType_DhcpClient{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DHCPServerParametersType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AddressChoice = &LoopbackInterfaceType_DhcpServer{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StaticIPParametersType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AddressChoice = &LoopbackInterfaceType_StaticIp{v}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteLocalNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &LoopbackInterfaceType_SiteLocalNetwork{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteLocalInsideNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &LoopbackInterfaceType_SiteLocalInsideNetwork{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpFabricNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.NetworkChoice = &LoopbackInterfaceType_IpFabricNetwork{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoIpv6Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ipv6AddressChoice = &LoopbackInterfaceType_NoIpv6Address{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticIpv6Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StaticIPParametersType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Ipv6AddressChoice = &LoopbackInterfaceType_StaticIpv6Address{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkQualityMonitorConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkQualityMonitorConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkQualityMonitorConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VhostInterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VhostInterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VhostInterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoHost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HostChoice = &VhostInterfaceType_NoHost{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vhost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HostChoice = &VhostInterfaceType_Vhost{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Virtual", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HostChoice = &VhostInterfaceType_Virtual{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Layer2VlanInterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Layer2VlanInterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Layer2VlanInterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Device = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanId", wireType)
			}
			m.VlanId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlanId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Layer2SloVlanInterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Layer2SloVlanInterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Layer2SloVlanInterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanId", wireType)
			}
			m.VlanId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlanId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Layer2SriovInterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Layer2SriovInterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Layer2SriovInterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Device = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Untagged", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VlanChoice = &Layer2SriovInterfaceType_Untagged{v}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VlanChoice = &Layer2SriovInterfaceType_VlanId{v}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Layer2InterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Layer2InterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Layer2InterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2VlanInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Layer2VlanInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Layer2InterfaceChoice = &Layer2InterfaceType_L2VlanInterface{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2VlanSloInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Layer2SloVlanInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Layer2InterfaceChoice = &Layer2InterfaceType_L2VlanSloInterface{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2SriovInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Layer2SriovInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Layer2InterfaceChoice = &Layer2InterfaceType_L2SriovInterface{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NetworkInterfaceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualNetwork = append(m.VirtualNetwork, &schema.ObjectRefType{})
			if err := m.VirtualNetwork[len(m.VirtualNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpAddress", wireType)
			}
			m.DhcpAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DhcpAddress |= NetworkInterfaceDHCP(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaticAddresses = append(m.StaticAddresses, &schema.Ipv4SubnetType{})
			if err := m.StaticAddresses[len(m.StaticAddresses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultGateway == nil {
				m.DefaultGateway = &NetworkInterfaceDFGW{}
			}
			if err := m.DefaultGateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNSServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DNSServer == nil {
				m.DNSServer = &NetworkInterfaceDNS{}
			}
			if err := m.DNSServer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DHCPServer", wireType)
			}
			m.DHCPServer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DHCPServer |= NetworkInterfaceDHCPServer(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanTagging", wireType)
			}
			m.VlanTagging = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlanTagging |= NetworkInterfaceVLANTagging(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentNetworkInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentNetworkInterface = append(m.ParentNetworkInterface, &schema.ObjectRefType{})
			if err := m.ParentNetworkInterface[len(m.ParentNetworkInterface)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanTag", wireType)
			}
			m.VlanTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlanTag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tunnel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tunnel == nil {
				m.Tunnel = &NetworkInterfaceTunnel{}
			}
			if err := m.Tunnel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressAllocator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressAllocator = append(m.AddressAllocator, &schema.ObjectRefType{})
			if err := m.AddressAllocator[len(m.AddressAllocator)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpServerParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DhcpServerParams == nil {
				m.DhcpServerParams = &DHCPServerParametersType{}
			}
			if err := m.DhcpServerParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkConfig", wireType)
			}
			m.NetworkConfig = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkConfig |= InterfaceNetworkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceIpMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InterfaceIpMap == nil {
				m.InterfaceIpMap = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InterfaceIpMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrimary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPrimary = bool(v != 0)
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonitorDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MonitoringChoice = &GlobalSpecType_MonitorDisabled{v}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monitor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LinkQualityMonitorConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MonitoringChoice = &GlobalSpecType_Monitor{v}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6StaticAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ipv6StaticAddresses == nil {
				m.Ipv6StaticAddresses = &StaticIPParametersType{}
			}
			if err := m.Ipv6StaticAddresses.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VhostType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VhostType == nil {
				m.VhostType = &VhostInterfaceType{}
			}
			if err := m.VhostType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4StaticAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ipv4StaticAddresses == nil {
				m.Ipv4StaticAddresses = &StaticIPParametersType{}
			}
			if err := m.Ipv4StaticAddresses.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticIpv6Addresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaticIpv6Addresses = append(m.StaticIpv6Addresses, &schema.Ipv6SubnetType{})
			if err := m.StaticIpv6Addresses[len(m.StaticIpv6Addresses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6AutoConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ipv6AutoConfig == nil {
				m.Ipv6AutoConfig = &IPV6AutoConfigType{}
			}
			if err := m.Ipv6AutoConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentationDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SegmentMultiplexing = &GlobalSpecType_SegmentationDisabled{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentationEnabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SegmentMultiplexing = &GlobalSpecType_SegmentationEnabled{v}
			iNdEx = postIndex
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DedicatedInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GlobalSpecType_DedicatedInterface{v}
			iNdEx = postIndex
		case 1002:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthernetInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EthernetInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GlobalSpecType_EthernetInterface{v}
			iNdEx = postIndex
		case 1003:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TunnelInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GlobalSpecType_TunnelInterface{v}
			iNdEx = postIndex
		case 1004:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Legacy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GlobalSpecType_Legacy{v}
			iNdEx = postIndex
		case 1005:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedManagementInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DedicatedManagementInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GlobalSpecType_DedicatedManagementInterface{v}
			iNdEx = postIndex
		case 1006:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoopbackInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LoopbackInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GlobalSpecType_LoopbackInterface{v}
			iNdEx = postIndex
		case 1008:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer2Interface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Layer2InterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GlobalSpecType_Layer2Interface{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DedicatedInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &CreateSpecType_DedicatedInterface{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthernetInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EthernetInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &CreateSpecType_EthernetInterface{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TunnelInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &CreateSpecType_TunnelInterface{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LegacyInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &CreateSpecType_LegacyInterface{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedManagementInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DedicatedManagementInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &CreateSpecType_DedicatedManagementInterface{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer2Interface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Layer2InterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &CreateSpecType_Layer2Interface{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DedicatedInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &ReplaceSpecType_DedicatedInterface{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthernetInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EthernetInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &ReplaceSpecType_EthernetInterface{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TunnelInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &ReplaceSpecType_TunnelInterface{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LegacyInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &ReplaceSpecType_LegacyInterface{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedManagementInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DedicatedManagementInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &ReplaceSpecType_DedicatedManagementInterface{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer2Interface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Layer2InterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &ReplaceSpecType_Layer2Interface{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NetworkInterfaceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mtu", wireType)
			}
			m.Mtu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mtu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualNetwork = append(m.VirtualNetwork, &schema.ObjectRefType{})
			if err := m.VirtualNetwork[len(m.VirtualNetwork)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpAddress", wireType)
			}
			m.DhcpAddress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DhcpAddress |= NetworkInterfaceDHCP(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaticAddresses = append(m.StaticAddresses, &schema.Ipv4SubnetType{})
			if err := m.StaticAddresses[len(m.StaticAddresses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultGateway", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultGateway == nil {
				m.DefaultGateway = &NetworkInterfaceDFGW{}
			}
			if err := m.DefaultGateway.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DNSServer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DNSServer == nil {
				m.DNSServer = &NetworkInterfaceDNS{}
			}
			if err := m.DNSServer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DHCPServer", wireType)
			}
			m.DHCPServer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DHCPServer |= NetworkInterfaceDHCPServer(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanTagging", wireType)
			}
			m.VlanTagging = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlanTagging |= NetworkInterfaceVLANTagging(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentNetworkInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentNetworkInterface = append(m.ParentNetworkInterface, &schema.ObjectRefType{})
			if err := m.ParentNetworkInterface[len(m.ParentNetworkInterface)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VlanTag", wireType)
			}
			m.VlanTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VlanTag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tunnel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tunnel == nil {
				m.Tunnel = &NetworkInterfaceTunnel{}
			}
			if err := m.Tunnel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressAllocator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddressAllocator = append(m.AddressAllocator, &schema.ObjectRefType{})
			if err := m.AddressAllocator[len(m.AddressAllocator)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DedicatedInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GetSpecType_DedicatedInterface{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthernetInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EthernetInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GetSpecType_EthernetInterface{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TunnelInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GetSpecType_TunnelInterface{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LegacyInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GetSpecType_LegacyInterface{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DedicatedManagementInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DedicatedManagementInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GetSpecType_DedicatedManagementInterface{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer2Interface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Layer2InterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &GetSpecType_Layer2Interface{v}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterfaceIpMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InterfaceIpMap == nil {
				m.InterfaceIpMap = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InterfaceIpMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrimary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPrimary = bool(v != 0)
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonitorDisabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MonitoringChoice = &GetSpecType_MonitorDisabled{v}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Monitor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LinkQualityMonitorConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MonitoringChoice = &GetSpecType_Monitor{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkInterfaceStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkInterfaceStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkInterfaceStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpDown", wireType)
			}
			m.UpDown = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpDown |= NetworkInterfaceUpDown(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
