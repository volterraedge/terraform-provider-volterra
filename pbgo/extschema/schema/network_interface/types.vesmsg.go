//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//
package network_interface

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *CreateSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetInterfaceChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetInterfaceChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.InterfaceChoice == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetInterfaceChoice().(type) {
	case *CreateSpecType_DedicatedInterface:

	case *CreateSpecType_EthernetInterface:
		odrInfos, err = m.GetEthernetInterface().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "ethernet_interface." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	case *CreateSpecType_TunnelInterface:
		odrInfos, err = m.GetTunnelInterface().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "tunnel_interface." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	case *CreateSpecType_LegacyInterface:
		odrInfos, err = m.GetLegacyInterface().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "legacy_interface." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	case *CreateSpecType_DedicatedManagementInterface:

	}

	return drInfos, err
}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) InterfaceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for interface_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["interface_choice"]; exists {
		val := m.GetInterfaceChoice()
		vOpts := append(opts,
			db.WithValidateField("interface_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetInterfaceChoice().(type) {
	case *CreateSpecType_DedicatedInterface:
		if fv, exists := v.FldValidators["interface_choice.dedicated_interface"]; exists {
			val := m.GetInterfaceChoice().(*CreateSpecType_DedicatedInterface).DedicatedInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("dedicated_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_EthernetInterface:
		if fv, exists := v.FldValidators["interface_choice.ethernet_interface"]; exists {
			val := m.GetInterfaceChoice().(*CreateSpecType_EthernetInterface).EthernetInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("ethernet_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_TunnelInterface:
		if fv, exists := v.FldValidators["interface_choice.tunnel_interface"]; exists {
			val := m.GetInterfaceChoice().(*CreateSpecType_TunnelInterface).TunnelInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("tunnel_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_LegacyInterface:
		if fv, exists := v.FldValidators["interface_choice.legacy_interface"]; exists {
			val := m.GetInterfaceChoice().(*CreateSpecType_LegacyInterface).LegacyInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("legacy_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_DedicatedManagementInterface:
		if fv, exists := v.FldValidators["interface_choice.dedicated_management_interface"]; exists {
			val := m.GetInterfaceChoice().(*CreateSpecType_DedicatedManagementInterface).DedicatedManagementInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("dedicated_management_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInterfaceChoice := v.InterfaceChoiceValidationRuleHandler
	rulesInterfaceChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhInterfaceChoice(rulesInterfaceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.interface_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface_choice"] = vFn

	v.FldValidators["interface_choice.dedicated_interface"] = DedicatedInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.ethernet_interface"] = EthernetInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.tunnel_interface"] = TunnelInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.legacy_interface"] = LegacyInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.dedicated_management_interface"] = DedicatedManagementInterfaceTypeValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DHCPInterfaceIPType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DHCPInterfaceIPType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DHCPInterfaceIPType) DeepCopy() *DHCPInterfaceIPType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DHCPInterfaceIPType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DHCPInterfaceIPType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DHCPInterfaceIPType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DHCPInterfaceIPTypeValidator().Validate(ctx, m, opts...)
}

type ValidateDHCPInterfaceIPType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDHCPInterfaceIPType) InterfaceIpMapValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for interface_ip_map")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for interface_ip_map")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for interface_ip_map")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map interface_ip_map")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items interface_ip_map")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDHCPInterfaceIPType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DHCPInterfaceIPType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DHCPInterfaceIPType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["interface_ip_map"]; exists {
		vOpts := append(opts, db.WithValidateField("interface_ip_map"))
		if err := fv(ctx, m.GetInterfaceIpMap(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDHCPInterfaceIPTypeValidator = func() *ValidateDHCPInterfaceIPType {
	v := &ValidateDHCPInterfaceIPType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInterfaceIpMap := v.InterfaceIpMapValidationRuleHandler
	rulesInterfaceIpMap := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len": "128",
		"ves.io.schema.rules.map.keys.string.min_len": "1",
		"ves.io.schema.rules.map.max_pairs":           "64",
		"ves.io.schema.rules.map.values.string.ipv4":  "true",
	}
	vFn, err = vrhInterfaceIpMap(rulesInterfaceIpMap)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPInterfaceIPType.interface_ip_map: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface_ip_map"] = vFn

	return v
}()

func DHCPInterfaceIPTypeValidator() db.Validator {
	return DefaultDHCPInterfaceIPTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DHCPNetworkType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DHCPNetworkType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DHCPNetworkType) DeepCopy() *DHCPNetworkType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DHCPNetworkType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DHCPNetworkType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DHCPNetworkType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DHCPNetworkTypeValidator().Validate(ctx, m, opts...)
}

func (m *DHCPNetworkType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetNetworkPrefixChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *DHCPNetworkType) GetNetworkPrefixChoiceDRefInfo() ([]db.DRefInfo, error) {
	var odrInfos []db.DRefInfo

	switch m.GetNetworkPrefixChoice().(type) {
	case *DHCPNetworkType_NetworkPrefixAllocator:

		vref := m.GetNetworkPrefixAllocator()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("address_allocator.Object")
		odri := db.DRefInfo{
			RefdType:   "address_allocator.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "network_prefix_allocator",
			Ref:        vdRef,
		}
		odrInfos = append(odrInfos, odri)

	}

	return odrInfos, nil
}

// GetNetworkPrefixChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *DHCPNetworkType) GetNetworkPrefixChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetNetworkPrefixChoice().(type) {
	case *DHCPNetworkType_NetworkPrefixAllocator:
		refdType, err := d.TypeForEntryKind("", "", "address_allocator.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: address_allocator")
		}

		vref := m.GetNetworkPrefixAllocator()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "address_allocator.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

type ValidateDHCPNetworkType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDHCPNetworkType) DnsChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dns_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDHCPNetworkType) DnsChoiceDnsAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_DnsAddress, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dns_address")
	}
	return oValidatorFn_DnsAddress, nil
}

func (v *ValidateDHCPNetworkType) GatewayChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for gateway_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDHCPNetworkType) GatewayChoiceDgwAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_DgwAddress, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dgw_address")
	}
	return oValidatorFn_DgwAddress, nil
}

func (v *ValidateDHCPNetworkType) NetworkPrefixChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network_prefix_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDHCPNetworkType) NetworkPrefixChoiceNetworkPrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_NetworkPrefix, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network_prefix")
	}
	return oValidatorFn_NetworkPrefix, nil
}

func (v *ValidateDHCPNetworkType) PoolsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*DHCPPoolType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := DHCPPoolTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for pools")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*DHCPPoolType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*DHCPPoolType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated pools")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items pools")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDHCPNetworkType) PoolSettingsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(DHCPPoolSettingType)
		return int32(i)
	}
	// DHCPPoolSettingType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, DHCPPoolSettingType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for pool_settings")
	}

	return validatorFn, nil
}

func (v *ValidateDHCPNetworkType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DHCPNetworkType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DHCPNetworkType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dns_choice"]; exists {
		val := m.GetDnsChoice()
		vOpts := append(opts,
			db.WithValidateField("dns_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDnsChoice().(type) {
	case *DHCPNetworkType_SameAsDgw:
		if fv, exists := v.FldValidators["dns_choice.same_as_dgw"]; exists {
			val := m.GetDnsChoice().(*DHCPNetworkType_SameAsDgw).SameAsDgw
			vOpts := append(opts,
				db.WithValidateField("dns_choice"),
				db.WithValidateField("same_as_dgw"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DHCPNetworkType_DnsAddress:
		if fv, exists := v.FldValidators["dns_choice.dns_address"]; exists {
			val := m.GetDnsChoice().(*DHCPNetworkType_DnsAddress).DnsAddress
			vOpts := append(opts,
				db.WithValidateField("dns_choice"),
				db.WithValidateField("dns_address"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["gateway_choice"]; exists {
		val := m.GetGatewayChoice()
		vOpts := append(opts,
			db.WithValidateField("gateway_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetGatewayChoice().(type) {
	case *DHCPNetworkType_FirstAddress:
		if fv, exists := v.FldValidators["gateway_choice.first_address"]; exists {
			val := m.GetGatewayChoice().(*DHCPNetworkType_FirstAddress).FirstAddress
			vOpts := append(opts,
				db.WithValidateField("gateway_choice"),
				db.WithValidateField("first_address"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DHCPNetworkType_LastAddress:
		if fv, exists := v.FldValidators["gateway_choice.last_address"]; exists {
			val := m.GetGatewayChoice().(*DHCPNetworkType_LastAddress).LastAddress
			vOpts := append(opts,
				db.WithValidateField("gateway_choice"),
				db.WithValidateField("last_address"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DHCPNetworkType_DgwAddress:
		if fv, exists := v.FldValidators["gateway_choice.dgw_address"]; exists {
			val := m.GetGatewayChoice().(*DHCPNetworkType_DgwAddress).DgwAddress
			vOpts := append(opts,
				db.WithValidateField("gateway_choice"),
				db.WithValidateField("dgw_address"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["network_prefix_choice"]; exists {
		val := m.GetNetworkPrefixChoice()
		vOpts := append(opts,
			db.WithValidateField("network_prefix_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNetworkPrefixChoice().(type) {
	case *DHCPNetworkType_NetworkPrefix:
		if fv, exists := v.FldValidators["network_prefix_choice.network_prefix"]; exists {
			val := m.GetNetworkPrefixChoice().(*DHCPNetworkType_NetworkPrefix).NetworkPrefix
			vOpts := append(opts,
				db.WithValidateField("network_prefix_choice"),
				db.WithValidateField("network_prefix"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DHCPNetworkType_NetworkPrefixAllocator:
		if fv, exists := v.FldValidators["network_prefix_choice.network_prefix_allocator"]; exists {
			val := m.GetNetworkPrefixChoice().(*DHCPNetworkType_NetworkPrefixAllocator).NetworkPrefixAllocator
			vOpts := append(opts,
				db.WithValidateField("network_prefix_choice"),
				db.WithValidateField("network_prefix_allocator"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["pool_settings"]; exists {

		vOpts := append(opts, db.WithValidateField("pool_settings"))
		if err := fv(ctx, m.GetPoolSettings(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["pools"]; exists {
		vOpts := append(opts, db.WithValidateField("pools"))
		if err := fv(ctx, m.GetPools(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDHCPNetworkTypeValidator = func() *ValidateDHCPNetworkType {
	v := &ValidateDHCPNetworkType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDnsChoice := v.DnsChoiceValidationRuleHandler
	rulesDnsChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDnsChoice(rulesDnsChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPNetworkType.dns_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_choice"] = vFn

	vrhDnsChoiceDnsAddress := v.DnsChoiceDnsAddressValidationRuleHandler
	rulesDnsChoiceDnsAddress := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFnMap["dns_choice.dns_address"], err = vrhDnsChoiceDnsAddress(rulesDnsChoiceDnsAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field DHCPNetworkType.dns_choice_dns_address: %s", err)
		panic(errMsg)
	}

	v.FldValidators["dns_choice.dns_address"] = vFnMap["dns_choice.dns_address"]

	vrhGatewayChoice := v.GatewayChoiceValidationRuleHandler
	rulesGatewayChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhGatewayChoice(rulesGatewayChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPNetworkType.gateway_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["gateway_choice"] = vFn

	vrhGatewayChoiceDgwAddress := v.GatewayChoiceDgwAddressValidationRuleHandler
	rulesGatewayChoiceDgwAddress := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFnMap["gateway_choice.dgw_address"], err = vrhGatewayChoiceDgwAddress(rulesGatewayChoiceDgwAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field DHCPNetworkType.gateway_choice_dgw_address: %s", err)
		panic(errMsg)
	}

	v.FldValidators["gateway_choice.dgw_address"] = vFnMap["gateway_choice.dgw_address"]

	vrhNetworkPrefixChoice := v.NetworkPrefixChoiceValidationRuleHandler
	rulesNetworkPrefixChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNetworkPrefixChoice(rulesNetworkPrefixChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPNetworkType.network_prefix_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_prefix_choice"] = vFn

	vrhNetworkPrefixChoiceNetworkPrefix := v.NetworkPrefixChoiceNetworkPrefixValidationRuleHandler
	rulesNetworkPrefixChoiceNetworkPrefix := map[string]string{
		"ves.io.schema.rules.string.ipv4_prefix": "true",
	}
	vFnMap["network_prefix_choice.network_prefix"], err = vrhNetworkPrefixChoiceNetworkPrefix(rulesNetworkPrefixChoiceNetworkPrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field DHCPNetworkType.network_prefix_choice_network_prefix: %s", err)
		panic(errMsg)
	}

	v.FldValidators["network_prefix_choice.network_prefix"] = vFnMap["network_prefix_choice.network_prefix"]

	vrhPools := v.PoolsValidationRuleHandler
	rulesPools := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhPools(rulesPools)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPNetworkType.pools: %s", err)
		panic(errMsg)
	}
	v.FldValidators["pools"] = vFn

	vrhPoolSettings := v.PoolSettingsValidationRuleHandler
	rulesPoolSettings := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPoolSettings(rulesPoolSettings)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPNetworkType.pool_settings: %s", err)
		panic(errMsg)
	}
	v.FldValidators["pool_settings"] = vFn

	v.FldValidators["network_prefix_choice.network_prefix_allocator"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func DHCPNetworkTypeValidator() db.Validator {
	return DefaultDHCPNetworkTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DHCPPoolType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DHCPPoolType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DHCPPoolType) DeepCopy() *DHCPPoolType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DHCPPoolType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DHCPPoolType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DHCPPoolType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DHCPPoolTypeValidator().Validate(ctx, m, opts...)
}

type ValidateDHCPPoolType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDHCPPoolType) StartIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_ip")
	}

	return validatorFn, nil
}

func (v *ValidateDHCPPoolType) EndIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_ip")
	}

	return validatorFn, nil
}

func (v *ValidateDHCPPoolType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DHCPPoolType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DHCPPoolType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["end_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("end_ip"))
		if err := fv(ctx, m.GetEndIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["exclude"]; exists {

		vOpts := append(opts, db.WithValidateField("exclude"))
		if err := fv(ctx, m.GetExclude(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("start_ip"))
		if err := fv(ctx, m.GetStartIp(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDHCPPoolTypeValidator = func() *ValidateDHCPPoolType {
	v := &ValidateDHCPPoolType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStartIp := v.StartIpValidationRuleHandler
	rulesStartIp := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFn, err = vrhStartIp(rulesStartIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPPoolType.start_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_ip"] = vFn

	vrhEndIp := v.EndIpValidationRuleHandler
	rulesEndIp := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFn, err = vrhEndIp(rulesEndIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPPoolType.end_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_ip"] = vFn

	return v
}()

func DHCPPoolTypeValidator() db.Validator {
	return DefaultDHCPPoolTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DHCPServerParametersType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DHCPServerParametersType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DHCPServerParametersType) DeepCopy() *DHCPServerParametersType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DHCPServerParametersType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DHCPServerParametersType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DHCPServerParametersType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DHCPServerParametersTypeValidator().Validate(ctx, m, opts...)
}

func (m *DHCPServerParametersType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetDhcpNetworksDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *DHCPServerParametersType) GetDhcpNetworksDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.DhcpNetworks == nil {
		return []db.DRefInfo{}, nil
	}

	for idx, e := range m.DhcpNetworks {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, dri := range driSet {
			dri.DRField = fmt.Sprintf("dhcp_networks[%v].%s", idx, dri.DRField)
			drInfos = append(drInfos, dri)
		}
	}

	return drInfos, err
}

type ValidateDHCPServerParametersType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDHCPServerParametersType) InterfacesAddressingChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for interfaces_addressing_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDHCPServerParametersType) DhcpNetworksValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*DHCPNetworkType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := DHCPNetworkTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for dhcp_networks")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*DHCPNetworkType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*DHCPNetworkType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated dhcp_networks")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items dhcp_networks")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDHCPServerParametersType) FixedIpMapValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for fixed_ip_map")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for fixed_ip_map")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for fixed_ip_map")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map fixed_ip_map")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items fixed_ip_map")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDHCPServerParametersType) DhcpOption82TagValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dhcp_option82_tag")
	}

	return validatorFn, nil
}

func (v *ValidateDHCPServerParametersType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DHCPServerParametersType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DHCPServerParametersType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dhcp_networks"]; exists {
		vOpts := append(opts, db.WithValidateField("dhcp_networks"))
		if err := fv(ctx, m.GetDhcpNetworks(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dhcp_option82_tag"]; exists {

		vOpts := append(opts, db.WithValidateField("dhcp_option82_tag"))
		if err := fv(ctx, m.GetDhcpOption82Tag(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["fixed_ip_map"]; exists {
		vOpts := append(opts, db.WithValidateField("fixed_ip_map"))
		if err := fv(ctx, m.GetFixedIpMap(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["interfaces_addressing_choice"]; exists {
		val := m.GetInterfacesAddressingChoice()
		vOpts := append(opts,
			db.WithValidateField("interfaces_addressing_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetInterfacesAddressingChoice().(type) {
	case *DHCPServerParametersType_AutomaticFromStart:
		if fv, exists := v.FldValidators["interfaces_addressing_choice.automatic_from_start"]; exists {
			val := m.GetInterfacesAddressingChoice().(*DHCPServerParametersType_AutomaticFromStart).AutomaticFromStart
			vOpts := append(opts,
				db.WithValidateField("interfaces_addressing_choice"),
				db.WithValidateField("automatic_from_start"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DHCPServerParametersType_AutomaticFromEnd:
		if fv, exists := v.FldValidators["interfaces_addressing_choice.automatic_from_end"]; exists {
			val := m.GetInterfacesAddressingChoice().(*DHCPServerParametersType_AutomaticFromEnd).AutomaticFromEnd
			vOpts := append(opts,
				db.WithValidateField("interfaces_addressing_choice"),
				db.WithValidateField("automatic_from_end"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DHCPServerParametersType_InterfaceIpMap:
		if fv, exists := v.FldValidators["interfaces_addressing_choice.interface_ip_map"]; exists {
			val := m.GetInterfacesAddressingChoice().(*DHCPServerParametersType_InterfaceIpMap).InterfaceIpMap
			vOpts := append(opts,
				db.WithValidateField("interfaces_addressing_choice"),
				db.WithValidateField("interface_ip_map"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDHCPServerParametersTypeValidator = func() *ValidateDHCPServerParametersType {
	v := &ValidateDHCPServerParametersType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInterfacesAddressingChoice := v.InterfacesAddressingChoiceValidationRuleHandler
	rulesInterfacesAddressingChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhInterfacesAddressingChoice(rulesInterfacesAddressingChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPServerParametersType.interfaces_addressing_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interfaces_addressing_choice"] = vFn

	vrhDhcpNetworks := v.DhcpNetworksValidationRuleHandler
	rulesDhcpNetworks := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "1",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhDhcpNetworks(rulesDhcpNetworks)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPServerParametersType.dhcp_networks: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dhcp_networks"] = vFn

	vrhFixedIpMap := v.FixedIpMapValidationRuleHandler
	rulesFixedIpMap := map[string]string{
		"ves.io.schema.rules.map.keys.string.mac":    "true",
		"ves.io.schema.rules.map.max_pairs":          "128",
		"ves.io.schema.rules.map.unique_values":      "true",
		"ves.io.schema.rules.map.values.string.ipv4": "true",
	}
	vFn, err = vrhFixedIpMap(rulesFixedIpMap)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPServerParametersType.fixed_ip_map: %s", err)
		panic(errMsg)
	}
	v.FldValidators["fixed_ip_map"] = vFn

	vrhDhcpOption82Tag := v.DhcpOption82TagValidationRuleHandler
	rulesDhcpOption82Tag := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhDhcpOption82Tag(rulesDhcpOption82Tag)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPServerParametersType.dhcp_option82_tag: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dhcp_option82_tag"] = vFn

	v.FldValidators["interfaces_addressing_choice.interface_ip_map"] = DHCPInterfaceIPTypeValidator().Validate

	return v
}()

func DHCPServerParametersTypeValidator() db.Validator {
	return DefaultDHCPServerParametersTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DedicatedInterfaceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DedicatedInterfaceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DedicatedInterfaceType) DeepCopy() *DedicatedInterfaceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DedicatedInterfaceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DedicatedInterfaceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DedicatedInterfaceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DedicatedInterfaceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateDedicatedInterfaceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDedicatedInterfaceType) NodeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDedicatedInterfaceType) NodeChoiceNodeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Node, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node")
	}
	return oValidatorFn_Node, nil
}

func (v *ValidateDedicatedInterfaceType) PrimaryChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for primary_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDedicatedInterfaceType) DeviceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for device")
	}

	return validatorFn, nil
}

func (v *ValidateDedicatedInterfaceType) MtuValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mtu")
	}

	return validatorFn, nil
}

func (v *ValidateDedicatedInterfaceType) PriorityValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for priority")
	}

	return validatorFn, nil
}

func (v *ValidateDedicatedInterfaceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DedicatedInterfaceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DedicatedInterfaceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["device"]; exists {

		vOpts := append(opts, db.WithValidateField("device"))
		if err := fv(ctx, m.GetDevice(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetMonitoringChoice().(type) {
	case *DedicatedInterfaceType_MonitorDisabled:
		if fv, exists := v.FldValidators["monitoring_choice.monitor_disabled"]; exists {
			val := m.GetMonitoringChoice().(*DedicatedInterfaceType_MonitorDisabled).MonitorDisabled
			vOpts := append(opts,
				db.WithValidateField("monitoring_choice"),
				db.WithValidateField("monitor_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DedicatedInterfaceType_Monitor:
		if fv, exists := v.FldValidators["monitoring_choice.monitor"]; exists {
			val := m.GetMonitoringChoice().(*DedicatedInterfaceType_Monitor).Monitor
			vOpts := append(opts,
				db.WithValidateField("monitoring_choice"),
				db.WithValidateField("monitor"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["mtu"]; exists {

		vOpts := append(opts, db.WithValidateField("mtu"))
		if err := fv(ctx, m.GetMtu(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["node_choice"]; exists {
		val := m.GetNodeChoice()
		vOpts := append(opts,
			db.WithValidateField("node_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNodeChoice().(type) {
	case *DedicatedInterfaceType_Cluster:
		if fv, exists := v.FldValidators["node_choice.cluster"]; exists {
			val := m.GetNodeChoice().(*DedicatedInterfaceType_Cluster).Cluster
			vOpts := append(opts,
				db.WithValidateField("node_choice"),
				db.WithValidateField("cluster"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DedicatedInterfaceType_Node:
		if fv, exists := v.FldValidators["node_choice.node"]; exists {
			val := m.GetNodeChoice().(*DedicatedInterfaceType_Node).Node
			vOpts := append(opts,
				db.WithValidateField("node_choice"),
				db.WithValidateField("node"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["primary_choice"]; exists {
		val := m.GetPrimaryChoice()
		vOpts := append(opts,
			db.WithValidateField("primary_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPrimaryChoice().(type) {
	case *DedicatedInterfaceType_NotPrimary:
		if fv, exists := v.FldValidators["primary_choice.not_primary"]; exists {
			val := m.GetPrimaryChoice().(*DedicatedInterfaceType_NotPrimary).NotPrimary
			vOpts := append(opts,
				db.WithValidateField("primary_choice"),
				db.WithValidateField("not_primary"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DedicatedInterfaceType_IsPrimary:
		if fv, exists := v.FldValidators["primary_choice.is_primary"]; exists {
			val := m.GetPrimaryChoice().(*DedicatedInterfaceType_IsPrimary).IsPrimary
			vOpts := append(opts,
				db.WithValidateField("primary_choice"),
				db.WithValidateField("is_primary"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["priority"]; exists {

		vOpts := append(opts, db.WithValidateField("priority"))
		if err := fv(ctx, m.GetPriority(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDedicatedInterfaceTypeValidator = func() *ValidateDedicatedInterfaceType {
	v := &ValidateDedicatedInterfaceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNodeChoice := v.NodeChoiceValidationRuleHandler
	rulesNodeChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNodeChoice(rulesNodeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DedicatedInterfaceType.node_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["node_choice"] = vFn

	vrhNodeChoiceNode := v.NodeChoiceNodeValidationRuleHandler
	rulesNodeChoiceNode := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["node_choice.node"], err = vrhNodeChoiceNode(rulesNodeChoiceNode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field DedicatedInterfaceType.node_choice_node: %s", err)
		panic(errMsg)
	}

	v.FldValidators["node_choice.node"] = vFnMap["node_choice.node"]

	vrhPrimaryChoice := v.PrimaryChoiceValidationRuleHandler
	rulesPrimaryChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPrimaryChoice(rulesPrimaryChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DedicatedInterfaceType.primary_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["primary_choice"] = vFn

	vrhDevice := v.DeviceValidationRuleHandler
	rulesDevice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhDevice(rulesDevice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DedicatedInterfaceType.device: %s", err)
		panic(errMsg)
	}
	v.FldValidators["device"] = vFn

	vrhMtu := v.MtuValidationRuleHandler
	rulesMtu := map[string]string{
		"ves.io.schema.rules.uint32.ranges": "0,512-16384",
	}
	vFn, err = vrhMtu(rulesMtu)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DedicatedInterfaceType.mtu: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mtu"] = vFn

	vrhPriority := v.PriorityValidationRuleHandler
	rulesPriority := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "255",
	}
	vFn, err = vrhPriority(rulesPriority)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DedicatedInterfaceType.priority: %s", err)
		panic(errMsg)
	}
	v.FldValidators["priority"] = vFn

	return v
}()

func DedicatedInterfaceTypeValidator() db.Validator {
	return DefaultDedicatedInterfaceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DedicatedManagementInterfaceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DedicatedManagementInterfaceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DedicatedManagementInterfaceType) DeepCopy() *DedicatedManagementInterfaceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DedicatedManagementInterfaceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DedicatedManagementInterfaceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DedicatedManagementInterfaceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DedicatedManagementInterfaceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateDedicatedManagementInterfaceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDedicatedManagementInterfaceType) NodeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDedicatedManagementInterfaceType) NodeChoiceNodeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Node, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node")
	}
	return oValidatorFn_Node, nil
}

func (v *ValidateDedicatedManagementInterfaceType) DeviceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for device")
	}

	return validatorFn, nil
}

func (v *ValidateDedicatedManagementInterfaceType) MtuValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mtu")
	}

	return validatorFn, nil
}

func (v *ValidateDedicatedManagementInterfaceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DedicatedManagementInterfaceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DedicatedManagementInterfaceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["device"]; exists {

		vOpts := append(opts, db.WithValidateField("device"))
		if err := fv(ctx, m.GetDevice(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mtu"]; exists {

		vOpts := append(opts, db.WithValidateField("mtu"))
		if err := fv(ctx, m.GetMtu(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["node_choice"]; exists {
		val := m.GetNodeChoice()
		vOpts := append(opts,
			db.WithValidateField("node_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNodeChoice().(type) {
	case *DedicatedManagementInterfaceType_Cluster:
		if fv, exists := v.FldValidators["node_choice.cluster"]; exists {
			val := m.GetNodeChoice().(*DedicatedManagementInterfaceType_Cluster).Cluster
			vOpts := append(opts,
				db.WithValidateField("node_choice"),
				db.WithValidateField("cluster"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DedicatedManagementInterfaceType_Node:
		if fv, exists := v.FldValidators["node_choice.node"]; exists {
			val := m.GetNodeChoice().(*DedicatedManagementInterfaceType_Node).Node
			vOpts := append(opts,
				db.WithValidateField("node_choice"),
				db.WithValidateField("node"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDedicatedManagementInterfaceTypeValidator = func() *ValidateDedicatedManagementInterfaceType {
	v := &ValidateDedicatedManagementInterfaceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNodeChoice := v.NodeChoiceValidationRuleHandler
	rulesNodeChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNodeChoice(rulesNodeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DedicatedManagementInterfaceType.node_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["node_choice"] = vFn

	vrhNodeChoiceNode := v.NodeChoiceNodeValidationRuleHandler
	rulesNodeChoiceNode := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["node_choice.node"], err = vrhNodeChoiceNode(rulesNodeChoiceNode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field DedicatedManagementInterfaceType.node_choice_node: %s", err)
		panic(errMsg)
	}

	v.FldValidators["node_choice.node"] = vFnMap["node_choice.node"]

	vrhDevice := v.DeviceValidationRuleHandler
	rulesDevice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhDevice(rulesDevice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DedicatedManagementInterfaceType.device: %s", err)
		panic(errMsg)
	}
	v.FldValidators["device"] = vFn

	vrhMtu := v.MtuValidationRuleHandler
	rulesMtu := map[string]string{
		"ves.io.schema.rules.uint32.ranges": "0,512-16384",
	}
	vFn, err = vrhMtu(rulesMtu)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DedicatedManagementInterfaceType.mtu: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mtu"] = vFn

	return v
}()

func DedicatedManagementInterfaceTypeValidator() db.Validator {
	return DefaultDedicatedManagementInterfaceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *EthernetInterfaceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *EthernetInterfaceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *EthernetInterfaceType) DeepCopy() *EthernetInterfaceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &EthernetInterfaceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *EthernetInterfaceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *EthernetInterfaceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EthernetInterfaceTypeValidator().Validate(ctx, m, opts...)
}

func (m *EthernetInterfaceType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAddressChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetNetworkChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *EthernetInterfaceType) GetAddressChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.AddressChoice == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetAddressChoice().(type) {
	case *EthernetInterfaceType_DhcpClient:

	case *EthernetInterfaceType_DhcpServer:
		odrInfos, err = m.GetDhcpServer().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "dhcp_server." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	case *EthernetInterfaceType_StaticIp:
		odrInfos, err = m.GetStaticIp().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "static_ip." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	}

	return drInfos, err
}

func (m *EthernetInterfaceType) GetNetworkChoiceDRefInfo() ([]db.DRefInfo, error) {
	var odrInfos []db.DRefInfo

	switch m.GetNetworkChoice().(type) {
	case *EthernetInterfaceType_SiteLocalNetwork:

	case *EthernetInterfaceType_SiteLocalInsideNetwork:

	case *EthernetInterfaceType_InsideNetwork:

		vref := m.GetInsideNetwork()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("virtual_network.Object")
		odri := db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "inside_network",
			Ref:        vdRef,
		}
		odrInfos = append(odrInfos, odri)

	case *EthernetInterfaceType_StorageNetwork:

	case *EthernetInterfaceType_Srv6Network:

		vref := m.GetSrv6Network()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("virtual_network.Object")
		odri := db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "srv6_network",
			Ref:        vdRef,
		}
		odrInfos = append(odrInfos, odri)

	}

	return odrInfos, nil
}

// GetNetworkChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *EthernetInterfaceType) GetNetworkChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetNetworkChoice().(type) {
	case *EthernetInterfaceType_SiteLocalNetwork:

	case *EthernetInterfaceType_SiteLocalInsideNetwork:

	case *EthernetInterfaceType_InsideNetwork:
		refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
		}

		vref := m.GetInsideNetwork()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "virtual_network.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	case *EthernetInterfaceType_StorageNetwork:

	case *EthernetInterfaceType_Srv6Network:
		refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
		}

		vref := m.GetSrv6Network()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "virtual_network.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

type ValidateEthernetInterfaceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEthernetInterfaceType) AddressChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address_choice")
	}
	return validatorFn, nil
}

func (v *ValidateEthernetInterfaceType) NetworkChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network_choice")
	}
	return validatorFn, nil
}

func (v *ValidateEthernetInterfaceType) NodeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node_choice")
	}
	return validatorFn, nil
}

func (v *ValidateEthernetInterfaceType) NodeChoiceNodeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Node, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node")
	}
	return oValidatorFn_Node, nil
}

func (v *ValidateEthernetInterfaceType) PrimaryChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for primary_choice")
	}
	return validatorFn, nil
}

func (v *ValidateEthernetInterfaceType) VlanChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vlan_choice")
	}
	return validatorFn, nil
}

func (v *ValidateEthernetInterfaceType) VlanChoiceVlanIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_VlanId, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vlan_id")
	}
	return oValidatorFn_VlanId, nil
}

func (v *ValidateEthernetInterfaceType) DeviceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for device")
	}

	return validatorFn, nil
}

func (v *ValidateEthernetInterfaceType) MtuValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mtu")
	}

	return validatorFn, nil
}

func (v *ValidateEthernetInterfaceType) PriorityValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for priority")
	}

	return validatorFn, nil
}

func (v *ValidateEthernetInterfaceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*EthernetInterfaceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *EthernetInterfaceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address_choice"]; exists {
		val := m.GetAddressChoice()
		vOpts := append(opts,
			db.WithValidateField("address_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAddressChoice().(type) {
	case *EthernetInterfaceType_DhcpClient:
		if fv, exists := v.FldValidators["address_choice.dhcp_client"]; exists {
			val := m.GetAddressChoice().(*EthernetInterfaceType_DhcpClient).DhcpClient
			vOpts := append(opts,
				db.WithValidateField("address_choice"),
				db.WithValidateField("dhcp_client"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EthernetInterfaceType_DhcpServer:
		if fv, exists := v.FldValidators["address_choice.dhcp_server"]; exists {
			val := m.GetAddressChoice().(*EthernetInterfaceType_DhcpServer).DhcpServer
			vOpts := append(opts,
				db.WithValidateField("address_choice"),
				db.WithValidateField("dhcp_server"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EthernetInterfaceType_StaticIp:
		if fv, exists := v.FldValidators["address_choice.static_ip"]; exists {
			val := m.GetAddressChoice().(*EthernetInterfaceType_StaticIp).StaticIp
			vOpts := append(opts,
				db.WithValidateField("address_choice"),
				db.WithValidateField("static_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["device"]; exists {

		vOpts := append(opts, db.WithValidateField("device"))
		if err := fv(ctx, m.GetDevice(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetMonitoringChoice().(type) {
	case *EthernetInterfaceType_MonitorDisabled:
		if fv, exists := v.FldValidators["monitoring_choice.monitor_disabled"]; exists {
			val := m.GetMonitoringChoice().(*EthernetInterfaceType_MonitorDisabled).MonitorDisabled
			vOpts := append(opts,
				db.WithValidateField("monitoring_choice"),
				db.WithValidateField("monitor_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EthernetInterfaceType_Monitor:
		if fv, exists := v.FldValidators["monitoring_choice.monitor"]; exists {
			val := m.GetMonitoringChoice().(*EthernetInterfaceType_Monitor).Monitor
			vOpts := append(opts,
				db.WithValidateField("monitoring_choice"),
				db.WithValidateField("monitor"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["mtu"]; exists {

		vOpts := append(opts, db.WithValidateField("mtu"))
		if err := fv(ctx, m.GetMtu(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_choice"]; exists {
		val := m.GetNetworkChoice()
		vOpts := append(opts,
			db.WithValidateField("network_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNetworkChoice().(type) {
	case *EthernetInterfaceType_SiteLocalNetwork:
		if fv, exists := v.FldValidators["network_choice.site_local_network"]; exists {
			val := m.GetNetworkChoice().(*EthernetInterfaceType_SiteLocalNetwork).SiteLocalNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("site_local_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EthernetInterfaceType_SiteLocalInsideNetwork:
		if fv, exists := v.FldValidators["network_choice.site_local_inside_network"]; exists {
			val := m.GetNetworkChoice().(*EthernetInterfaceType_SiteLocalInsideNetwork).SiteLocalInsideNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("site_local_inside_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EthernetInterfaceType_InsideNetwork:
		if fv, exists := v.FldValidators["network_choice.inside_network"]; exists {
			val := m.GetNetworkChoice().(*EthernetInterfaceType_InsideNetwork).InsideNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("inside_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EthernetInterfaceType_StorageNetwork:
		if fv, exists := v.FldValidators["network_choice.storage_network"]; exists {
			val := m.GetNetworkChoice().(*EthernetInterfaceType_StorageNetwork).StorageNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("storage_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EthernetInterfaceType_Srv6Network:
		if fv, exists := v.FldValidators["network_choice.srv6_network"]; exists {
			val := m.GetNetworkChoice().(*EthernetInterfaceType_Srv6Network).Srv6Network
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("srv6_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["node_choice"]; exists {
		val := m.GetNodeChoice()
		vOpts := append(opts,
			db.WithValidateField("node_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNodeChoice().(type) {
	case *EthernetInterfaceType_Cluster:
		if fv, exists := v.FldValidators["node_choice.cluster"]; exists {
			val := m.GetNodeChoice().(*EthernetInterfaceType_Cluster).Cluster
			vOpts := append(opts,
				db.WithValidateField("node_choice"),
				db.WithValidateField("cluster"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EthernetInterfaceType_Node:
		if fv, exists := v.FldValidators["node_choice.node"]; exists {
			val := m.GetNodeChoice().(*EthernetInterfaceType_Node).Node
			vOpts := append(opts,
				db.WithValidateField("node_choice"),
				db.WithValidateField("node"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["primary_choice"]; exists {
		val := m.GetPrimaryChoice()
		vOpts := append(opts,
			db.WithValidateField("primary_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPrimaryChoice().(type) {
	case *EthernetInterfaceType_NotPrimary:
		if fv, exists := v.FldValidators["primary_choice.not_primary"]; exists {
			val := m.GetPrimaryChoice().(*EthernetInterfaceType_NotPrimary).NotPrimary
			vOpts := append(opts,
				db.WithValidateField("primary_choice"),
				db.WithValidateField("not_primary"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EthernetInterfaceType_IsPrimary:
		if fv, exists := v.FldValidators["primary_choice.is_primary"]; exists {
			val := m.GetPrimaryChoice().(*EthernetInterfaceType_IsPrimary).IsPrimary
			vOpts := append(opts,
				db.WithValidateField("primary_choice"),
				db.WithValidateField("is_primary"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["priority"]; exists {

		vOpts := append(opts, db.WithValidateField("priority"))
		if err := fv(ctx, m.GetPriority(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vlan_choice"]; exists {
		val := m.GetVlanChoice()
		vOpts := append(opts,
			db.WithValidateField("vlan_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetVlanChoice().(type) {
	case *EthernetInterfaceType_Untagged:
		if fv, exists := v.FldValidators["vlan_choice.untagged"]; exists {
			val := m.GetVlanChoice().(*EthernetInterfaceType_Untagged).Untagged
			vOpts := append(opts,
				db.WithValidateField("vlan_choice"),
				db.WithValidateField("untagged"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EthernetInterfaceType_VlanId:
		if fv, exists := v.FldValidators["vlan_choice.vlan_id"]; exists {
			val := m.GetVlanChoice().(*EthernetInterfaceType_VlanId).VlanId
			vOpts := append(opts,
				db.WithValidateField("vlan_choice"),
				db.WithValidateField("vlan_id"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEthernetInterfaceTypeValidator = func() *ValidateEthernetInterfaceType {
	v := &ValidateEthernetInterfaceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAddressChoice := v.AddressChoiceValidationRuleHandler
	rulesAddressChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAddressChoice(rulesAddressChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EthernetInterfaceType.address_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address_choice"] = vFn

	vrhNetworkChoice := v.NetworkChoiceValidationRuleHandler
	rulesNetworkChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNetworkChoice(rulesNetworkChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EthernetInterfaceType.network_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_choice"] = vFn

	vrhNodeChoice := v.NodeChoiceValidationRuleHandler
	rulesNodeChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNodeChoice(rulesNodeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EthernetInterfaceType.node_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["node_choice"] = vFn

	vrhNodeChoiceNode := v.NodeChoiceNodeValidationRuleHandler
	rulesNodeChoiceNode := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["node_choice.node"], err = vrhNodeChoiceNode(rulesNodeChoiceNode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field EthernetInterfaceType.node_choice_node: %s", err)
		panic(errMsg)
	}

	v.FldValidators["node_choice.node"] = vFnMap["node_choice.node"]

	vrhPrimaryChoice := v.PrimaryChoiceValidationRuleHandler
	rulesPrimaryChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPrimaryChoice(rulesPrimaryChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EthernetInterfaceType.primary_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["primary_choice"] = vFn

	vrhVlanChoice := v.VlanChoiceValidationRuleHandler
	rulesVlanChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhVlanChoice(rulesVlanChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EthernetInterfaceType.vlan_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vlan_choice"] = vFn

	vrhVlanChoiceVlanId := v.VlanChoiceVlanIdValidationRuleHandler
	rulesVlanChoiceVlanId := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "4095",
	}
	vFnMap["vlan_choice.vlan_id"], err = vrhVlanChoiceVlanId(rulesVlanChoiceVlanId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field EthernetInterfaceType.vlan_choice_vlan_id: %s", err)
		panic(errMsg)
	}

	v.FldValidators["vlan_choice.vlan_id"] = vFnMap["vlan_choice.vlan_id"]

	vrhDevice := v.DeviceValidationRuleHandler
	rulesDevice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhDevice(rulesDevice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EthernetInterfaceType.device: %s", err)
		panic(errMsg)
	}
	v.FldValidators["device"] = vFn

	vrhMtu := v.MtuValidationRuleHandler
	rulesMtu := map[string]string{
		"ves.io.schema.rules.uint32.ranges": "0,512-16384",
	}
	vFn, err = vrhMtu(rulesMtu)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EthernetInterfaceType.mtu: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mtu"] = vFn

	vrhPriority := v.PriorityValidationRuleHandler
	rulesPriority := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "255",
	}
	vFn, err = vrhPriority(rulesPriority)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EthernetInterfaceType.priority: %s", err)
		panic(errMsg)
	}
	v.FldValidators["priority"] = vFn

	v.FldValidators["address_choice.dhcp_server"] = DHCPServerParametersTypeValidator().Validate
	v.FldValidators["address_choice.static_ip"] = StaticIPParametersTypeValidator().Validate

	v.FldValidators["network_choice.inside_network"] = ves_io_schema_views.ObjectRefTypeValidator().Validate
	v.FldValidators["network_choice.srv6_network"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func EthernetInterfaceTypeValidator() db.Validator {
	return DefaultEthernetInterfaceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GetSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetInterfaceChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetInterfaceChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.InterfaceChoice == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetInterfaceChoice().(type) {
	case *GetSpecType_DedicatedInterface:

	case *GetSpecType_EthernetInterface:
		odrInfos, err = m.GetEthernetInterface().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "ethernet_interface." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	case *GetSpecType_TunnelInterface:
		odrInfos, err = m.GetTunnelInterface().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "tunnel_interface." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	case *GetSpecType_LegacyInterface:
		odrInfos, err = m.GetLegacyInterface().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "legacy_interface." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	case *GetSpecType_DedicatedManagementInterface:

	}

	return drInfos, err
}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) InterfaceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for interface_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["interface_choice"]; exists {
		val := m.GetInterfaceChoice()
		vOpts := append(opts,
			db.WithValidateField("interface_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetInterfaceChoice().(type) {
	case *GetSpecType_DedicatedInterface:
		if fv, exists := v.FldValidators["interface_choice.dedicated_interface"]; exists {
			val := m.GetInterfaceChoice().(*GetSpecType_DedicatedInterface).DedicatedInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("dedicated_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_EthernetInterface:
		if fv, exists := v.FldValidators["interface_choice.ethernet_interface"]; exists {
			val := m.GetInterfaceChoice().(*GetSpecType_EthernetInterface).EthernetInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("ethernet_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_TunnelInterface:
		if fv, exists := v.FldValidators["interface_choice.tunnel_interface"]; exists {
			val := m.GetInterfaceChoice().(*GetSpecType_TunnelInterface).TunnelInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("tunnel_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_LegacyInterface:
		if fv, exists := v.FldValidators["interface_choice.legacy_interface"]; exists {
			val := m.GetInterfaceChoice().(*GetSpecType_LegacyInterface).LegacyInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("legacy_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_DedicatedManagementInterface:
		if fv, exists := v.FldValidators["interface_choice.dedicated_management_interface"]; exists {
			val := m.GetInterfaceChoice().(*GetSpecType_DedicatedManagementInterface).DedicatedManagementInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("dedicated_management_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInterfaceChoice := v.InterfaceChoiceValidationRuleHandler
	rulesInterfaceChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhInterfaceChoice(rulesInterfaceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.interface_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface_choice"] = vFn

	v.FldValidators["interface_choice.dedicated_interface"] = DedicatedInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.ethernet_interface"] = EthernetInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.tunnel_interface"] = TunnelInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.legacy_interface"] = LegacyInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.dedicated_management_interface"] = DedicatedManagementInterfaceTypeValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAddressAllocatorDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDhcpServerParamsDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetInterfaceChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetParentNetworkInterfaceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTunnelDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetVirtualNetworkDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *GlobalSpecType) GetAddressAllocatorDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetAddressAllocator() {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.address_allocator[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "address_allocator.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "address_allocator",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetAddressAllocatorDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetAddressAllocatorDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "address_allocator.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: address_allocator")
	}
	for _, ref := range m.GetAddressAllocator() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetDhcpServerParamsDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.DhcpServerParams == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.DhcpServerParams.GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "dhcp_server_params." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetInterfaceChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.InterfaceChoice == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetInterfaceChoice().(type) {
	case *GlobalSpecType_DedicatedInterface:

	case *GlobalSpecType_EthernetInterface:
		odrInfos, err = m.GetEthernetInterface().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "ethernet_interface." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	case *GlobalSpecType_TunnelInterface:
		odrInfos, err = m.GetTunnelInterface().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "tunnel_interface." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	case *GlobalSpecType_Legacy:

	case *GlobalSpecType_DedicatedManagementInterface:

	}

	return drInfos, err
}

func (m *GlobalSpecType) GetParentNetworkInterfaceDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetParentNetworkInterface() {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.parent_network_interface[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "network_interface.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "parent_network_interface",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetParentNetworkInterfaceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetParentNetworkInterfaceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "network_interface.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: network_interface")
	}
	for _, ref := range m.GetParentNetworkInterface() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetTunnelDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.Tunnel == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.Tunnel.GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "tunnel." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

func (m *GlobalSpecType) GetVirtualNetworkDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetVirtualNetwork() {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.virtual_network[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "virtual_network",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetVirtualNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetVirtualNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}
	for _, ref := range m.GetVirtualNetwork() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) InterfaceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for interface_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) TypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(NetworkInterfaceType)
		return int32(i)
	}
	// NetworkInterfaceType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, NetworkInterfaceType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for type")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) MtuValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mtu")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) VirtualNetworkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for virtual_network")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated virtual_network")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items virtual_network")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) DhcpAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(NetworkInterfaceDHCP)
		return int32(i)
	}
	// NetworkInterfaceDHCP_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, NetworkInterfaceDHCP_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dhcp_address")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) StaticAddressesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.Ipv4SubnetType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.Ipv4SubnetTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for static_addresses")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.Ipv4SubnetType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.Ipv4SubnetType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated static_addresses")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items static_addresses")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) DHCPServerValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(NetworkInterfaceDHCPServer)
		return int32(i)
	}
	// NetworkInterfaceDHCPServer_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, NetworkInterfaceDHCPServer_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for DHCP_server")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) DeviceNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for device_name")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ParentNetworkInterfaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for parent_network_interface")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated parent_network_interface")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items parent_network_interface")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) VlanTagValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vlan_tag")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) PriorityValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for priority")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) AddressAllocatorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for address_allocator")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated address_allocator")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items address_allocator")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) InterfaceIpMapValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for interface_ip_map")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for interface_ip_map")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for interface_ip_map")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map interface_ip_map")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items interface_ip_map")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["DHCP_server"]; exists {

		vOpts := append(opts, db.WithValidateField("DHCP_server"))
		if err := fv(ctx, m.GetDHCPServer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["DNS_server"]; exists {

		vOpts := append(opts, db.WithValidateField("DNS_server"))
		if err := fv(ctx, m.GetDNSServer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["address_allocator"]; exists {
		vOpts := append(opts, db.WithValidateField("address_allocator"))
		if err := fv(ctx, m.GetAddressAllocator(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_gateway"]; exists {

		vOpts := append(opts, db.WithValidateField("default_gateway"))
		if err := fv(ctx, m.GetDefaultGateway(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["device_name"]; exists {

		vOpts := append(opts, db.WithValidateField("device_name"))
		if err := fv(ctx, m.GetDeviceName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dhcp_address"]; exists {

		vOpts := append(opts, db.WithValidateField("dhcp_address"))
		if err := fv(ctx, m.GetDhcpAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dhcp_server_params"]; exists {

		vOpts := append(opts, db.WithValidateField("dhcp_server_params"))
		if err := fv(ctx, m.GetDhcpServerParams(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["interface_choice"]; exists {
		val := m.GetInterfaceChoice()
		vOpts := append(opts,
			db.WithValidateField("interface_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetInterfaceChoice().(type) {
	case *GlobalSpecType_DedicatedInterface:
		if fv, exists := v.FldValidators["interface_choice.dedicated_interface"]; exists {
			val := m.GetInterfaceChoice().(*GlobalSpecType_DedicatedInterface).DedicatedInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("dedicated_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_EthernetInterface:
		if fv, exists := v.FldValidators["interface_choice.ethernet_interface"]; exists {
			val := m.GetInterfaceChoice().(*GlobalSpecType_EthernetInterface).EthernetInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("ethernet_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_TunnelInterface:
		if fv, exists := v.FldValidators["interface_choice.tunnel_interface"]; exists {
			val := m.GetInterfaceChoice().(*GlobalSpecType_TunnelInterface).TunnelInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("tunnel_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Legacy:
		if fv, exists := v.FldValidators["interface_choice.legacy"]; exists {
			val := m.GetInterfaceChoice().(*GlobalSpecType_Legacy).Legacy
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("legacy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_DedicatedManagementInterface:
		if fv, exists := v.FldValidators["interface_choice.dedicated_management_interface"]; exists {
			val := m.GetInterfaceChoice().(*GlobalSpecType_DedicatedManagementInterface).DedicatedManagementInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("dedicated_management_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["interface_ip_map"]; exists {
		vOpts := append(opts, db.WithValidateField("interface_ip_map"))
		if err := fv(ctx, m.GetInterfaceIpMap(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["is_primary"]; exists {

		vOpts := append(opts, db.WithValidateField("is_primary"))
		if err := fv(ctx, m.GetIsPrimary(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetMonitoringChoice().(type) {
	case *GlobalSpecType_MonitorDisabled:
		if fv, exists := v.FldValidators["monitoring_choice.monitor_disabled"]; exists {
			val := m.GetMonitoringChoice().(*GlobalSpecType_MonitorDisabled).MonitorDisabled
			vOpts := append(opts,
				db.WithValidateField("monitoring_choice"),
				db.WithValidateField("monitor_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Monitor:
		if fv, exists := v.FldValidators["monitoring_choice.monitor"]; exists {
			val := m.GetMonitoringChoice().(*GlobalSpecType_Monitor).Monitor
			vOpts := append(opts,
				db.WithValidateField("monitoring_choice"),
				db.WithValidateField("monitor"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["mtu"]; exists {

		vOpts := append(opts, db.WithValidateField("mtu"))
		if err := fv(ctx, m.GetMtu(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_config"]; exists {

		vOpts := append(opts, db.WithValidateField("network_config"))
		if err := fv(ctx, m.GetNetworkConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["parent_network_interface"]; exists {
		vOpts := append(opts, db.WithValidateField("parent_network_interface"))
		if err := fv(ctx, m.GetParentNetworkInterface(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["priority"]; exists {

		vOpts := append(opts, db.WithValidateField("priority"))
		if err := fv(ctx, m.GetPriority(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["static_addresses"]; exists {
		vOpts := append(opts, db.WithValidateField("static_addresses"))
		if err := fv(ctx, m.GetStaticAddresses(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel"))
		if err := fv(ctx, m.GetTunnel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["virtual_network"]; exists {
		vOpts := append(opts, db.WithValidateField("virtual_network"))
		if err := fv(ctx, m.GetVirtualNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vlan_tag"]; exists {

		vOpts := append(opts, db.WithValidateField("vlan_tag"))
		if err := fv(ctx, m.GetVlanTag(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vlan_tagging"]; exists {

		vOpts := append(opts, db.WithValidateField("vlan_tagging"))
		if err := fv(ctx, m.GetVlanTagging(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInterfaceChoice := v.InterfaceChoiceValidationRuleHandler
	rulesInterfaceChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhInterfaceChoice(rulesInterfaceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.interface_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface_choice"] = vFn

	vrhType := v.TypeValidationRuleHandler
	rulesType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhType(rulesType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["type"] = vFn

	vrhMtu := v.MtuValidationRuleHandler
	rulesMtu := map[string]string{
		"ves.io.schema.rules.uint32.ranges": "0,512-16384",
	}
	vFn, err = vrhMtu(rulesMtu)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.mtu: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mtu"] = vFn

	vrhVirtualNetwork := v.VirtualNetworkValidationRuleHandler
	rulesVirtualNetwork := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhVirtualNetwork(rulesVirtualNetwork)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.virtual_network: %s", err)
		panic(errMsg)
	}
	v.FldValidators["virtual_network"] = vFn

	vrhDhcpAddress := v.DhcpAddressValidationRuleHandler
	rulesDhcpAddress := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDhcpAddress(rulesDhcpAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.dhcp_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dhcp_address"] = vFn

	vrhStaticAddresses := v.StaticAddressesValidationRuleHandler
	rulesStaticAddresses := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhStaticAddresses(rulesStaticAddresses)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.static_addresses: %s", err)
		panic(errMsg)
	}
	v.FldValidators["static_addresses"] = vFn

	vrhDHCPServer := v.DHCPServerValidationRuleHandler
	rulesDHCPServer := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDHCPServer(rulesDHCPServer)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.DHCP_server: %s", err)
		panic(errMsg)
	}
	v.FldValidators["DHCP_server"] = vFn

	vrhDeviceName := v.DeviceNameValidationRuleHandler
	rulesDeviceName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDeviceName(rulesDeviceName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.device_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["device_name"] = vFn

	vrhParentNetworkInterface := v.ParentNetworkInterfaceValidationRuleHandler
	rulesParentNetworkInterface := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhParentNetworkInterface(rulesParentNetworkInterface)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.parent_network_interface: %s", err)
		panic(errMsg)
	}
	v.FldValidators["parent_network_interface"] = vFn

	vrhVlanTag := v.VlanTagValidationRuleHandler
	rulesVlanTag := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "4094",
	}
	vFn, err = vrhVlanTag(rulesVlanTag)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.vlan_tag: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vlan_tag"] = vFn

	vrhPriority := v.PriorityValidationRuleHandler
	rulesPriority := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "255",
	}
	vFn, err = vrhPriority(rulesPriority)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.priority: %s", err)
		panic(errMsg)
	}
	v.FldValidators["priority"] = vFn

	vrhAddressAllocator := v.AddressAllocatorValidationRuleHandler
	rulesAddressAllocator := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhAddressAllocator(rulesAddressAllocator)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.address_allocator: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address_allocator"] = vFn

	vrhInterfaceIpMap := v.InterfaceIpMapValidationRuleHandler
	rulesInterfaceIpMap := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len": "128",
		"ves.io.schema.rules.map.keys.string.min_len": "1",
		"ves.io.schema.rules.map.max_pairs":           "64",
		"ves.io.schema.rules.map.values.string.ipv4":  "true",
	}
	vFn, err = vrhInterfaceIpMap(rulesInterfaceIpMap)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.interface_ip_map: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface_ip_map"] = vFn

	v.FldValidators["interface_choice.dedicated_interface"] = DedicatedInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.ethernet_interface"] = EthernetInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.tunnel_interface"] = TunnelInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.dedicated_management_interface"] = DedicatedManagementInterfaceTypeValidator().Validate

	v.FldValidators["default_gateway"] = NetworkInterfaceDFGWValidator().Validate

	v.FldValidators["DNS_server"] = NetworkInterfaceDNSValidator().Validate

	v.FldValidators["tunnel"] = NetworkInterfaceTunnelValidator().Validate

	v.FldValidators["dhcp_server_params"] = DHCPServerParametersTypeValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *LegacyInterfaceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LegacyInterfaceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LegacyInterfaceType) DeepCopy() *LegacyInterfaceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LegacyInterfaceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LegacyInterfaceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LegacyInterfaceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LegacyInterfaceTypeValidator().Validate(ctx, m, opts...)
}

func (m *LegacyInterfaceType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAddressAllocatorDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTunnelDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetVirtualNetworkDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *LegacyInterfaceType) GetAddressAllocatorDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetAddressAllocator() {
		if ref == nil {
			return nil, fmt.Errorf("LegacyInterfaceType.address_allocator[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "address_allocator.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "address_allocator",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetAddressAllocatorDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *LegacyInterfaceType) GetAddressAllocatorDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "address_allocator.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: address_allocator")
	}
	for _, ref := range m.GetAddressAllocator() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *LegacyInterfaceType) GetTunnelDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.Tunnel == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.Tunnel.GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "tunnel." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

func (m *LegacyInterfaceType) GetVirtualNetworkDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetVirtualNetwork() {
		if ref == nil {
			return nil, fmt.Errorf("LegacyInterfaceType.virtual_network[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "virtual_network",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetVirtualNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *LegacyInterfaceType) GetVirtualNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}
	for _, ref := range m.GetVirtualNetwork() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateLegacyInterfaceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLegacyInterfaceType) TypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(NetworkInterfaceType)
		return int32(i)
	}
	// NetworkInterfaceType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, NetworkInterfaceType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for type")
	}

	return validatorFn, nil
}

func (v *ValidateLegacyInterfaceType) MtuValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mtu")
	}

	return validatorFn, nil
}

func (v *ValidateLegacyInterfaceType) VirtualNetworkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for virtual_network")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated virtual_network")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items virtual_network")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateLegacyInterfaceType) DhcpAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(NetworkInterfaceDHCP)
		return int32(i)
	}
	// NetworkInterfaceDHCP_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, NetworkInterfaceDHCP_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dhcp_address")
	}

	return validatorFn, nil
}

func (v *ValidateLegacyInterfaceType) DHCPServerValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(NetworkInterfaceDHCPServer)
		return int32(i)
	}
	// NetworkInterfaceDHCPServer_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, NetworkInterfaceDHCPServer_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for DHCP_server")
	}

	return validatorFn, nil
}

func (v *ValidateLegacyInterfaceType) DeviceNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for device_name")
	}

	return validatorFn, nil
}

func (v *ValidateLegacyInterfaceType) VlanTagValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vlan_tag")
	}

	return validatorFn, nil
}

func (v *ValidateLegacyInterfaceType) PriorityValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for priority")
	}

	return validatorFn, nil
}

func (v *ValidateLegacyInterfaceType) AddressAllocatorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for address_allocator")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated address_allocator")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items address_allocator")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateLegacyInterfaceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LegacyInterfaceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LegacyInterfaceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["DHCP_server"]; exists {

		vOpts := append(opts, db.WithValidateField("DHCP_server"))
		if err := fv(ctx, m.GetDHCPServer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["DNS_server"]; exists {

		vOpts := append(opts, db.WithValidateField("DNS_server"))
		if err := fv(ctx, m.GetDNSServer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["address_allocator"]; exists {
		vOpts := append(opts, db.WithValidateField("address_allocator"))
		if err := fv(ctx, m.GetAddressAllocator(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_gateway"]; exists {

		vOpts := append(opts, db.WithValidateField("default_gateway"))
		if err := fv(ctx, m.GetDefaultGateway(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["device_name"]; exists {

		vOpts := append(opts, db.WithValidateField("device_name"))
		if err := fv(ctx, m.GetDeviceName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dhcp_address"]; exists {

		vOpts := append(opts, db.WithValidateField("dhcp_address"))
		if err := fv(ctx, m.GetDhcpAddress(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetMonitoringChoice().(type) {
	case *LegacyInterfaceType_MonitorDisabled:
		if fv, exists := v.FldValidators["monitoring_choice.monitor_disabled"]; exists {
			val := m.GetMonitoringChoice().(*LegacyInterfaceType_MonitorDisabled).MonitorDisabled
			vOpts := append(opts,
				db.WithValidateField("monitoring_choice"),
				db.WithValidateField("monitor_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *LegacyInterfaceType_Monitor:
		if fv, exists := v.FldValidators["monitoring_choice.monitor"]; exists {
			val := m.GetMonitoringChoice().(*LegacyInterfaceType_Monitor).Monitor
			vOpts := append(opts,
				db.WithValidateField("monitoring_choice"),
				db.WithValidateField("monitor"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["mtu"]; exists {

		vOpts := append(opts, db.WithValidateField("mtu"))
		if err := fv(ctx, m.GetMtu(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["priority"]; exists {

		vOpts := append(opts, db.WithValidateField("priority"))
		if err := fv(ctx, m.GetPriority(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["static_addresses"]; exists {

		vOpts := append(opts, db.WithValidateField("static_addresses"))
		for idx, item := range m.GetStaticAddresses() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tunnel"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel"))
		if err := fv(ctx, m.GetTunnel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["virtual_network"]; exists {
		vOpts := append(opts, db.WithValidateField("virtual_network"))
		if err := fv(ctx, m.GetVirtualNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vlan_tag"]; exists {

		vOpts := append(opts, db.WithValidateField("vlan_tag"))
		if err := fv(ctx, m.GetVlanTag(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vlan_tagging"]; exists {

		vOpts := append(opts, db.WithValidateField("vlan_tagging"))
		if err := fv(ctx, m.GetVlanTagging(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLegacyInterfaceTypeValidator = func() *ValidateLegacyInterfaceType {
	v := &ValidateLegacyInterfaceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhType := v.TypeValidationRuleHandler
	rulesType := map[string]string{
		"ves.io.schema.rules.enum.in":          "[0,1,3]",
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhType(rulesType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LegacyInterfaceType.type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["type"] = vFn

	vrhMtu := v.MtuValidationRuleHandler
	rulesMtu := map[string]string{
		"ves.io.schema.rules.uint32.ranges": "0,512-16384",
	}
	vFn, err = vrhMtu(rulesMtu)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LegacyInterfaceType.mtu: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mtu"] = vFn

	vrhVirtualNetwork := v.VirtualNetworkValidationRuleHandler
	rulesVirtualNetwork := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhVirtualNetwork(rulesVirtualNetwork)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LegacyInterfaceType.virtual_network: %s", err)
		panic(errMsg)
	}
	v.FldValidators["virtual_network"] = vFn

	vrhDhcpAddress := v.DhcpAddressValidationRuleHandler
	rulesDhcpAddress := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDhcpAddress(rulesDhcpAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LegacyInterfaceType.dhcp_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dhcp_address"] = vFn

	vrhDHCPServer := v.DHCPServerValidationRuleHandler
	rulesDHCPServer := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDHCPServer(rulesDHCPServer)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LegacyInterfaceType.DHCP_server: %s", err)
		panic(errMsg)
	}
	v.FldValidators["DHCP_server"] = vFn

	vrhDeviceName := v.DeviceNameValidationRuleHandler
	rulesDeviceName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDeviceName(rulesDeviceName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LegacyInterfaceType.device_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["device_name"] = vFn

	vrhVlanTag := v.VlanTagValidationRuleHandler
	rulesVlanTag := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "4094",
	}
	vFn, err = vrhVlanTag(rulesVlanTag)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LegacyInterfaceType.vlan_tag: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vlan_tag"] = vFn

	vrhPriority := v.PriorityValidationRuleHandler
	rulesPriority := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "255",
	}
	vFn, err = vrhPriority(rulesPriority)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LegacyInterfaceType.priority: %s", err)
		panic(errMsg)
	}
	v.FldValidators["priority"] = vFn

	vrhAddressAllocator := v.AddressAllocatorValidationRuleHandler
	rulesAddressAllocator := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhAddressAllocator(rulesAddressAllocator)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LegacyInterfaceType.address_allocator: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address_allocator"] = vFn

	v.FldValidators["static_addresses"] = ves_io_schema.Ipv4SubnetTypeValidator().Validate

	v.FldValidators["default_gateway"] = NetworkInterfaceDFGWValidator().Validate

	v.FldValidators["DNS_server"] = NetworkInterfaceDNSValidator().Validate

	v.FldValidators["tunnel"] = NetworkInterfaceTunnelValidator().Validate

	return v
}()

func LegacyInterfaceTypeValidator() db.Validator {
	return DefaultLegacyInterfaceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *LinkQualityMonitorConfig) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LinkQualityMonitorConfig) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LinkQualityMonitorConfig) DeepCopy() *LinkQualityMonitorConfig {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LinkQualityMonitorConfig{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LinkQualityMonitorConfig) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LinkQualityMonitorConfig) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LinkQualityMonitorConfigValidator().Validate(ctx, m, opts...)
}

type ValidateLinkQualityMonitorConfig struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLinkQualityMonitorConfig) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LinkQualityMonitorConfig)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LinkQualityMonitorConfig got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLinkQualityMonitorConfigValidator = func() *ValidateLinkQualityMonitorConfig {
	v := &ValidateLinkQualityMonitorConfig{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LinkQualityMonitorConfigValidator() db.Validator {
	return DefaultLinkQualityMonitorConfigValidator
}

// augmented methods on protoc/std generated struct

func (m *NetworkInterfaceDFGW) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NetworkInterfaceDFGW) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NetworkInterfaceDFGW) DeepCopy() *NetworkInterfaceDFGW {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NetworkInterfaceDFGW{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NetworkInterfaceDFGW) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NetworkInterfaceDFGW) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NetworkInterfaceDFGWValidator().Validate(ctx, m, opts...)
}

type ValidateNetworkInterfaceDFGW struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNetworkInterfaceDFGW) DefaultGatewayModeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(NetworkInterfaceGatewayMode)
		return int32(i)
	}
	// NetworkInterfaceGatewayMode_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, NetworkInterfaceGatewayMode_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for default_gateway_mode")
	}

	return validatorFn, nil
}

func (v *ValidateNetworkInterfaceDFGW) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NetworkInterfaceDFGW)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NetworkInterfaceDFGW got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["default_gateway_address"]; exists {

		vOpts := append(opts, db.WithValidateField("default_gateway_address"))
		if err := fv(ctx, m.GetDefaultGatewayAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_gateway_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("default_gateway_mode"))
		if err := fv(ctx, m.GetDefaultGatewayMode(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNetworkInterfaceDFGWValidator = func() *ValidateNetworkInterfaceDFGW {
	v := &ValidateNetworkInterfaceDFGW{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDefaultGatewayMode := v.DefaultGatewayModeValidationRuleHandler
	rulesDefaultGatewayMode := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDefaultGatewayMode(rulesDefaultGatewayMode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for NetworkInterfaceDFGW.default_gateway_mode: %s", err)
		panic(errMsg)
	}
	v.FldValidators["default_gateway_mode"] = vFn

	v.FldValidators["default_gateway_address"] = ves_io_schema.Ipv4AddressTypeValidator().Validate

	return v
}()

func NetworkInterfaceDFGWValidator() db.Validator {
	return DefaultNetworkInterfaceDFGWValidator
}

// augmented methods on protoc/std generated struct

func (m *NetworkInterfaceDNS) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NetworkInterfaceDNS) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NetworkInterfaceDNS) DeepCopy() *NetworkInterfaceDNS {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NetworkInterfaceDNS{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NetworkInterfaceDNS) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NetworkInterfaceDNS) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NetworkInterfaceDNSValidator().Validate(ctx, m, opts...)
}

type ValidateNetworkInterfaceDNS struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNetworkInterfaceDNS) DnsModeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(NetworkInterfaceDNSMode)
		return int32(i)
	}
	// NetworkInterfaceDNSMode_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, NetworkInterfaceDNSMode_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dns_mode")
	}

	return validatorFn, nil
}

func (v *ValidateNetworkInterfaceDNS) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NetworkInterfaceDNS)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NetworkInterfaceDNS got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dns_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_mode"))
		if err := fv(ctx, m.GetDnsMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_server"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_server"))
		for idx, item := range m.GetDnsServer() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNetworkInterfaceDNSValidator = func() *ValidateNetworkInterfaceDNS {
	v := &ValidateNetworkInterfaceDNS{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDnsMode := v.DnsModeValidationRuleHandler
	rulesDnsMode := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDnsMode(rulesDnsMode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for NetworkInterfaceDNS.dns_mode: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_mode"] = vFn

	v.FldValidators["dns_server"] = ves_io_schema.Ipv4AddressTypeValidator().Validate

	return v
}()

func NetworkInterfaceDNSValidator() db.Validator {
	return DefaultNetworkInterfaceDNSValidator
}

// augmented methods on protoc/std generated struct

func (m *NetworkInterfaceStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NetworkInterfaceStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NetworkInterfaceStatus) DeepCopy() *NetworkInterfaceStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NetworkInterfaceStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NetworkInterfaceStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NetworkInterfaceStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NetworkInterfaceStatusValidator().Validate(ctx, m, opts...)
}

type ValidateNetworkInterfaceStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNetworkInterfaceStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NetworkInterfaceStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NetworkInterfaceStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["up_down"]; exists {

		vOpts := append(opts, db.WithValidateField("up_down"))
		if err := fv(ctx, m.GetUpDown(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNetworkInterfaceStatusValidator = func() *ValidateNetworkInterfaceStatus {
	v := &ValidateNetworkInterfaceStatus{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func NetworkInterfaceStatusValidator() db.Validator {
	return DefaultNetworkInterfaceStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *NetworkInterfaceTunnel) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NetworkInterfaceTunnel) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NetworkInterfaceTunnel) DeepCopy() *NetworkInterfaceTunnel {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NetworkInterfaceTunnel{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NetworkInterfaceTunnel) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NetworkInterfaceTunnel) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NetworkInterfaceTunnelValidator().Validate(ctx, m, opts...)
}

func (m *NetworkInterfaceTunnel) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetTunnelDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *NetworkInterfaceTunnel) GetTunnelDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}
	for i, ref := range m.GetTunnel() {
		if ref == nil {
			return nil, fmt.Errorf("NetworkInterfaceTunnel.tunnel[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "tunnel.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "tunnel",
			Ref:        ref,
		})
	}

	return drInfos, nil
}

// GetTunnelDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *NetworkInterfaceTunnel) GetTunnelDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "tunnel.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: tunnel")
	}
	for _, ref := range m.GetTunnel() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateNetworkInterfaceTunnel struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNetworkInterfaceTunnel) TunnelValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for tunnel")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated tunnel")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items tunnel")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateNetworkInterfaceTunnel) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NetworkInterfaceTunnel)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NetworkInterfaceTunnel got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["tunnel"]; exists {
		vOpts := append(opts, db.WithValidateField("tunnel"))
		if err := fv(ctx, m.GetTunnel(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNetworkInterfaceTunnelValidator = func() *ValidateNetworkInterfaceTunnel {
	v := &ValidateNetworkInterfaceTunnel{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTunnel := v.TunnelValidationRuleHandler
	rulesTunnel := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhTunnel(rulesTunnel)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for NetworkInterfaceTunnel.tunnel: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel"] = vFn

	return v
}()

func NetworkInterfaceTunnelValidator() db.Validator {
	return DefaultNetworkInterfaceTunnelValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *ReplaceSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetInterfaceChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetInterfaceChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.InterfaceChoice == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetInterfaceChoice().(type) {
	case *ReplaceSpecType_DedicatedInterface:

	case *ReplaceSpecType_EthernetInterface:
		odrInfos, err = m.GetEthernetInterface().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "ethernet_interface." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	case *ReplaceSpecType_TunnelInterface:
		odrInfos, err = m.GetTunnelInterface().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "tunnel_interface." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	case *ReplaceSpecType_LegacyInterface:
		odrInfos, err = m.GetLegacyInterface().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "legacy_interface." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	case *ReplaceSpecType_DedicatedManagementInterface:

	}

	return drInfos, err
}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) InterfaceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for interface_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["interface_choice"]; exists {
		val := m.GetInterfaceChoice()
		vOpts := append(opts,
			db.WithValidateField("interface_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetInterfaceChoice().(type) {
	case *ReplaceSpecType_DedicatedInterface:
		if fv, exists := v.FldValidators["interface_choice.dedicated_interface"]; exists {
			val := m.GetInterfaceChoice().(*ReplaceSpecType_DedicatedInterface).DedicatedInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("dedicated_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_EthernetInterface:
		if fv, exists := v.FldValidators["interface_choice.ethernet_interface"]; exists {
			val := m.GetInterfaceChoice().(*ReplaceSpecType_EthernetInterface).EthernetInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("ethernet_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_TunnelInterface:
		if fv, exists := v.FldValidators["interface_choice.tunnel_interface"]; exists {
			val := m.GetInterfaceChoice().(*ReplaceSpecType_TunnelInterface).TunnelInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("tunnel_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_LegacyInterface:
		if fv, exists := v.FldValidators["interface_choice.legacy_interface"]; exists {
			val := m.GetInterfaceChoice().(*ReplaceSpecType_LegacyInterface).LegacyInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("legacy_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_DedicatedManagementInterface:
		if fv, exists := v.FldValidators["interface_choice.dedicated_management_interface"]; exists {
			val := m.GetInterfaceChoice().(*ReplaceSpecType_DedicatedManagementInterface).DedicatedManagementInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("dedicated_management_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInterfaceChoice := v.InterfaceChoiceValidationRuleHandler
	rulesInterfaceChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhInterfaceChoice(rulesInterfaceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.interface_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface_choice"] = vFn

	v.FldValidators["interface_choice.dedicated_interface"] = DedicatedInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.ethernet_interface"] = EthernetInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.tunnel_interface"] = TunnelInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.legacy_interface"] = LegacyInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.dedicated_management_interface"] = DedicatedManagementInterfaceTypeValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StaticIPParametersType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StaticIPParametersType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StaticIPParametersType) DeepCopy() *StaticIPParametersType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StaticIPParametersType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StaticIPParametersType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StaticIPParametersType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StaticIPParametersTypeValidator().Validate(ctx, m, opts...)
}

func (m *StaticIPParametersType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetNetworkPrefixChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

// GetDRefInfo for the field's type
func (m *StaticIPParametersType) GetNetworkPrefixChoiceDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.NetworkPrefixChoice == nil {
		return []db.DRefInfo{}, nil
	}

	var odrInfos []db.DRefInfo

	switch m.GetNetworkPrefixChoice().(type) {
	case *StaticIPParametersType_NodeStaticIp:

	case *StaticIPParametersType_ClusterStaticIp:

	case *StaticIPParametersType_FleetStaticIp:
		odrInfos, err = m.GetFleetStaticIp().GetDRefInfo()
		if err != nil {
			return nil, err
		}
		for _, odri := range odrInfos {
			odri.DRField = "fleet_static_ip." + odri.DRField
			drInfos = append(drInfos, odri)
		}

	}

	return drInfos, err
}

type ValidateStaticIPParametersType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStaticIPParametersType) NetworkPrefixChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network_prefix_choice")
	}
	return validatorFn, nil
}

func (v *ValidateStaticIPParametersType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StaticIPParametersType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StaticIPParametersType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["network_prefix_choice"]; exists {
		val := m.GetNetworkPrefixChoice()
		vOpts := append(opts,
			db.WithValidateField("network_prefix_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNetworkPrefixChoice().(type) {
	case *StaticIPParametersType_NodeStaticIp:
		if fv, exists := v.FldValidators["network_prefix_choice.node_static_ip"]; exists {
			val := m.GetNetworkPrefixChoice().(*StaticIPParametersType_NodeStaticIp).NodeStaticIp
			vOpts := append(opts,
				db.WithValidateField("network_prefix_choice"),
				db.WithValidateField("node_static_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StaticIPParametersType_ClusterStaticIp:
		if fv, exists := v.FldValidators["network_prefix_choice.cluster_static_ip"]; exists {
			val := m.GetNetworkPrefixChoice().(*StaticIPParametersType_ClusterStaticIp).ClusterStaticIp
			vOpts := append(opts,
				db.WithValidateField("network_prefix_choice"),
				db.WithValidateField("cluster_static_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StaticIPParametersType_FleetStaticIp:
		if fv, exists := v.FldValidators["network_prefix_choice.fleet_static_ip"]; exists {
			val := m.GetNetworkPrefixChoice().(*StaticIPParametersType_FleetStaticIp).FleetStaticIp
			vOpts := append(opts,
				db.WithValidateField("network_prefix_choice"),
				db.WithValidateField("fleet_static_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStaticIPParametersTypeValidator = func() *ValidateStaticIPParametersType {
	v := &ValidateStaticIPParametersType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNetworkPrefixChoice := v.NetworkPrefixChoiceValidationRuleHandler
	rulesNetworkPrefixChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNetworkPrefixChoice(rulesNetworkPrefixChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StaticIPParametersType.network_prefix_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_prefix_choice"] = vFn

	v.FldValidators["network_prefix_choice.node_static_ip"] = StaticIpParametersNodeTypeValidator().Validate
	v.FldValidators["network_prefix_choice.cluster_static_ip"] = StaticIpParametersClusterTypeValidator().Validate
	v.FldValidators["network_prefix_choice.fleet_static_ip"] = StaticIpParametersFleetTypeValidator().Validate

	return v
}()

func StaticIPParametersTypeValidator() db.Validator {
	return DefaultStaticIPParametersTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StaticIpParametersClusterType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StaticIpParametersClusterType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StaticIpParametersClusterType) DeepCopy() *StaticIpParametersClusterType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StaticIpParametersClusterType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StaticIpParametersClusterType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StaticIpParametersClusterType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StaticIpParametersClusterTypeValidator().Validate(ctx, m, opts...)
}

type ValidateStaticIpParametersClusterType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStaticIpParametersClusterType) InterfaceIpMapValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for interface_ip_map")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]*StaticIpParametersNodeType, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := StaticIpParametersNodeTypeValidator().Validate(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for interface_ip_map")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]*StaticIpParametersNodeType)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]*StaticIpParametersNodeType, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map interface_ip_map")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items interface_ip_map")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateStaticIpParametersClusterType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StaticIpParametersClusterType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StaticIpParametersClusterType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["interface_ip_map"]; exists {
		vOpts := append(opts, db.WithValidateField("interface_ip_map"))
		if err := fv(ctx, m.GetInterfaceIpMap(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStaticIpParametersClusterTypeValidator = func() *ValidateStaticIpParametersClusterType {
	v := &ValidateStaticIpParametersClusterType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInterfaceIpMap := v.InterfaceIpMapValidationRuleHandler
	rulesInterfaceIpMap := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len": "128",
		"ves.io.schema.rules.map.keys.string.min_len": "1",
		"ves.io.schema.rules.map.max_pairs":           "64",
	}
	vFn, err = vrhInterfaceIpMap(rulesInterfaceIpMap)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StaticIpParametersClusterType.interface_ip_map: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface_ip_map"] = vFn

	return v
}()

func StaticIpParametersClusterTypeValidator() db.Validator {
	return DefaultStaticIpParametersClusterTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StaticIpParametersFleetType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StaticIpParametersFleetType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StaticIpParametersFleetType) DeepCopy() *StaticIpParametersFleetType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StaticIpParametersFleetType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StaticIpParametersFleetType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StaticIpParametersFleetType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StaticIpParametersFleetTypeValidator().Validate(ctx, m, opts...)
}

func (m *StaticIpParametersFleetType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetNetworkPrefixAllocatorDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *StaticIpParametersFleetType) GetNetworkPrefixAllocatorDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}

	vref := m.GetNetworkPrefixAllocator()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("address_allocator.Object")
	drInfos = append(drInfos, db.DRefInfo{
		RefdType:   "address_allocator.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "network_prefix_allocator",
		Ref:        vdRef,
	})

	return drInfos, nil
}

// GetNetworkPrefixAllocatorDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *StaticIpParametersFleetType) GetNetworkPrefixAllocatorDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "address_allocator.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: address_allocator")
	}

	vref := m.GetNetworkPrefixAllocator()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "address_allocator.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateStaticIpParametersFleetType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStaticIpParametersFleetType) DefaultGwValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for default_gw")
	}

	return validatorFn, nil
}

func (v *ValidateStaticIpParametersFleetType) DnsServerValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dns_server")
	}

	return validatorFn, nil
}

func (v *ValidateStaticIpParametersFleetType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StaticIpParametersFleetType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StaticIpParametersFleetType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["default_gw"]; exists {

		vOpts := append(opts, db.WithValidateField("default_gw"))
		if err := fv(ctx, m.GetDefaultGw(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_server"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_server"))
		if err := fv(ctx, m.GetDnsServer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_prefix_allocator"]; exists {

		vOpts := append(opts, db.WithValidateField("network_prefix_allocator"))
		if err := fv(ctx, m.GetNetworkPrefixAllocator(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStaticIpParametersFleetTypeValidator = func() *ValidateStaticIpParametersFleetType {
	v := &ValidateStaticIpParametersFleetType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDefaultGw := v.DefaultGwValidationRuleHandler
	rulesDefaultGw := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFn, err = vrhDefaultGw(rulesDefaultGw)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StaticIpParametersFleetType.default_gw: %s", err)
		panic(errMsg)
	}
	v.FldValidators["default_gw"] = vFn

	vrhDnsServer := v.DnsServerValidationRuleHandler
	rulesDnsServer := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFn, err = vrhDnsServer(rulesDnsServer)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StaticIpParametersFleetType.dns_server: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_server"] = vFn

	v.FldValidators["network_prefix_allocator"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func StaticIpParametersFleetTypeValidator() db.Validator {
	return DefaultStaticIpParametersFleetTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StaticIpParametersNodeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StaticIpParametersNodeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StaticIpParametersNodeType) DeepCopy() *StaticIpParametersNodeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StaticIpParametersNodeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StaticIpParametersNodeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StaticIpParametersNodeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StaticIpParametersNodeTypeValidator().Validate(ctx, m, opts...)
}

type ValidateStaticIpParametersNodeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStaticIpParametersNodeType) IpAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip_address")
	}

	return validatorFn, nil
}

func (v *ValidateStaticIpParametersNodeType) DefaultGwValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for default_gw")
	}

	return validatorFn, nil
}

func (v *ValidateStaticIpParametersNodeType) DnsServerValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dns_server")
	}

	return validatorFn, nil
}

func (v *ValidateStaticIpParametersNodeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StaticIpParametersNodeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StaticIpParametersNodeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["default_gw"]; exists {

		vOpts := append(opts, db.WithValidateField("default_gw"))
		if err := fv(ctx, m.GetDefaultGw(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_server"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_server"))
		if err := fv(ctx, m.GetDnsServer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip_address"]; exists {

		vOpts := append(opts, db.WithValidateField("ip_address"))
		if err := fv(ctx, m.GetIpAddress(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStaticIpParametersNodeTypeValidator = func() *ValidateStaticIpParametersNodeType {
	v := &ValidateStaticIpParametersNodeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhIpAddress := v.IpAddressValidationRuleHandler
	rulesIpAddress := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.string.ipv4_prefix": "true",
	}
	vFn, err = vrhIpAddress(rulesIpAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StaticIpParametersNodeType.ip_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip_address"] = vFn

	vrhDefaultGw := v.DefaultGwValidationRuleHandler
	rulesDefaultGw := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFn, err = vrhDefaultGw(rulesDefaultGw)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StaticIpParametersNodeType.default_gw: %s", err)
		panic(errMsg)
	}
	v.FldValidators["default_gw"] = vFn

	vrhDnsServer := v.DnsServerValidationRuleHandler
	rulesDnsServer := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFn, err = vrhDnsServer(rulesDnsServer)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StaticIpParametersNodeType.dns_server: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_server"] = vFn

	return v
}()

func StaticIpParametersNodeTypeValidator() db.Validator {
	return DefaultStaticIpParametersNodeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TunnelInterfaceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TunnelInterfaceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TunnelInterfaceType) DeepCopy() *TunnelInterfaceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TunnelInterfaceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TunnelInterfaceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TunnelInterfaceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TunnelInterfaceTypeValidator().Validate(ctx, m, opts...)
}

func (m *TunnelInterfaceType) GetDRefInfo() ([]db.DRefInfo, error) {
	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetNetworkChoiceDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetStaticIpDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTunnelDRefInfo(); err != nil {
		return nil, err
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil
}

func (m *TunnelInterfaceType) GetNetworkChoiceDRefInfo() ([]db.DRefInfo, error) {
	var odrInfos []db.DRefInfo

	switch m.GetNetworkChoice().(type) {
	case *TunnelInterfaceType_SiteLocalNetwork:

	case *TunnelInterfaceType_SiteLocalInsideNetwork:

	case *TunnelInterfaceType_InsideNetwork:

		vref := m.GetInsideNetwork()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("virtual_network.Object")
		odri := db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "inside_network",
			Ref:        vdRef,
		}
		odrInfos = append(odrInfos, odri)

	}

	return odrInfos, nil
}

// GetNetworkChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *TunnelInterfaceType) GetNetworkChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetNetworkChoice().(type) {
	case *TunnelInterfaceType_SiteLocalNetwork:

	case *TunnelInterfaceType_SiteLocalInsideNetwork:

	case *TunnelInterfaceType_InsideNetwork:
		refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
		}

		vref := m.GetInsideNetwork()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "virtual_network.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *TunnelInterfaceType) GetStaticIpDRefInfo() ([]db.DRefInfo, error) {
	var (
		drInfos, driSet []db.DRefInfo
		err             error
	)
	_ = driSet
	if m.StaticIp == nil {
		return []db.DRefInfo{}, nil
	}

	driSet, err = m.StaticIp.GetDRefInfo()
	if err != nil {
		return nil, err
	}
	for _, dri := range driSet {
		dri.DRField = "static_ip." + dri.DRField
		drInfos = append(drInfos, dri)
	}

	return drInfos, err
}

func (m *TunnelInterfaceType) GetTunnelDRefInfo() ([]db.DRefInfo, error) {
	drInfos := []db.DRefInfo{}

	vref := m.GetTunnel()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("tunnel.Object")
	drInfos = append(drInfos, db.DRefInfo{
		RefdType:   "tunnel.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "tunnel",
		Ref:        vdRef,
	})

	return drInfos, nil
}

// GetTunnelDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *TunnelInterfaceType) GetTunnelDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "tunnel.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: tunnel")
	}

	vref := m.GetTunnel()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "tunnel.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateTunnelInterfaceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTunnelInterfaceType) NetworkChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network_choice")
	}
	return validatorFn, nil
}

func (v *ValidateTunnelInterfaceType) NodeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node_choice")
	}
	return validatorFn, nil
}

func (v *ValidateTunnelInterfaceType) NodeChoiceNodeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Node, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node")
	}
	return oValidatorFn_Node, nil
}

func (v *ValidateTunnelInterfaceType) MtuValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mtu")
	}

	return validatorFn, nil
}

func (v *ValidateTunnelInterfaceType) PriorityValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for priority")
	}

	return validatorFn, nil
}

func (v *ValidateTunnelInterfaceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TunnelInterfaceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TunnelInterfaceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["mtu"]; exists {

		vOpts := append(opts, db.WithValidateField("mtu"))
		if err := fv(ctx, m.GetMtu(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_choice"]; exists {
		val := m.GetNetworkChoice()
		vOpts := append(opts,
			db.WithValidateField("network_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNetworkChoice().(type) {
	case *TunnelInterfaceType_SiteLocalNetwork:
		if fv, exists := v.FldValidators["network_choice.site_local_network"]; exists {
			val := m.GetNetworkChoice().(*TunnelInterfaceType_SiteLocalNetwork).SiteLocalNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("site_local_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TunnelInterfaceType_SiteLocalInsideNetwork:
		if fv, exists := v.FldValidators["network_choice.site_local_inside_network"]; exists {
			val := m.GetNetworkChoice().(*TunnelInterfaceType_SiteLocalInsideNetwork).SiteLocalInsideNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("site_local_inside_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TunnelInterfaceType_InsideNetwork:
		if fv, exists := v.FldValidators["network_choice.inside_network"]; exists {
			val := m.GetNetworkChoice().(*TunnelInterfaceType_InsideNetwork).InsideNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("inside_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["node_choice"]; exists {
		val := m.GetNodeChoice()
		vOpts := append(opts,
			db.WithValidateField("node_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNodeChoice().(type) {
	case *TunnelInterfaceType_Cluster:
		if fv, exists := v.FldValidators["node_choice.cluster"]; exists {
			val := m.GetNodeChoice().(*TunnelInterfaceType_Cluster).Cluster
			vOpts := append(opts,
				db.WithValidateField("node_choice"),
				db.WithValidateField("cluster"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TunnelInterfaceType_Node:
		if fv, exists := v.FldValidators["node_choice.node"]; exists {
			val := m.GetNodeChoice().(*TunnelInterfaceType_Node).Node
			vOpts := append(opts,
				db.WithValidateField("node_choice"),
				db.WithValidateField("node"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["priority"]; exists {

		vOpts := append(opts, db.WithValidateField("priority"))
		if err := fv(ctx, m.GetPriority(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["static_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("static_ip"))
		if err := fv(ctx, m.GetStaticIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel"))
		if err := fv(ctx, m.GetTunnel(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTunnelInterfaceTypeValidator = func() *ValidateTunnelInterfaceType {
	v := &ValidateTunnelInterfaceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNetworkChoice := v.NetworkChoiceValidationRuleHandler
	rulesNetworkChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNetworkChoice(rulesNetworkChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TunnelInterfaceType.network_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_choice"] = vFn

	vrhNodeChoice := v.NodeChoiceValidationRuleHandler
	rulesNodeChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhNodeChoice(rulesNodeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TunnelInterfaceType.node_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["node_choice"] = vFn

	vrhNodeChoiceNode := v.NodeChoiceNodeValidationRuleHandler
	rulesNodeChoiceNode := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["node_choice.node"], err = vrhNodeChoiceNode(rulesNodeChoiceNode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field TunnelInterfaceType.node_choice_node: %s", err)
		panic(errMsg)
	}

	v.FldValidators["node_choice.node"] = vFnMap["node_choice.node"]

	vrhMtu := v.MtuValidationRuleHandler
	rulesMtu := map[string]string{
		"ves.io.schema.rules.uint32.ranges": "0,512-16384",
	}
	vFn, err = vrhMtu(rulesMtu)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TunnelInterfaceType.mtu: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mtu"] = vFn

	vrhPriority := v.PriorityValidationRuleHandler
	rulesPriority := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "255",
	}
	vFn, err = vrhPriority(rulesPriority)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TunnelInterfaceType.priority: %s", err)
		panic(errMsg)
	}
	v.FldValidators["priority"] = vFn

	v.FldValidators["network_choice.inside_network"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["tunnel"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	v.FldValidators["static_ip"] = StaticIPParametersTypeValidator().Validate

	return v
}()

func TunnelInterfaceTypeValidator() db.Validator {
	return DefaultTunnelInterfaceTypeValidator
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}

}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}

}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}

}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}

}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}

}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}

}
