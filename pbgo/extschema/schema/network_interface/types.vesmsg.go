// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package network_interface

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *CreateSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetInterfaceChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *CreateSpecType) GetInterfaceChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetInterfaceChoice() == nil {
		return nil, nil
	}
	switch m.GetInterfaceChoice().(type) {
	case *CreateSpecType_DedicatedInterface:

		return nil, nil

	case *CreateSpecType_EthernetInterface:

		drInfos, err := m.GetEthernetInterface().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetEthernetInterface().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "ethernet_interface." + dri.DRField
		}
		return drInfos, err

	case *CreateSpecType_TunnelInterface:

		drInfos, err := m.GetTunnelInterface().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetTunnelInterface().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "tunnel_interface." + dri.DRField
		}
		return drInfos, err

	case *CreateSpecType_LegacyInterface:

		drInfos, err := m.GetLegacyInterface().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetLegacyInterface().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "legacy_interface." + dri.DRField
		}
		return drInfos, err

	case *CreateSpecType_DedicatedManagementInterface:

		return nil, nil

	case *CreateSpecType_Layer2Interface:

		return nil, nil

	default:
		return nil, nil
	}

}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) InterfaceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for interface_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["interface_choice"]; exists {
		val := m.GetInterfaceChoice()
		vOpts := append(opts,
			db.WithValidateField("interface_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetInterfaceChoice().(type) {
	case *CreateSpecType_DedicatedInterface:
		if fv, exists := v.FldValidators["interface_choice.dedicated_interface"]; exists {
			val := m.GetInterfaceChoice().(*CreateSpecType_DedicatedInterface).DedicatedInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("dedicated_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_EthernetInterface:
		if fv, exists := v.FldValidators["interface_choice.ethernet_interface"]; exists {
			val := m.GetInterfaceChoice().(*CreateSpecType_EthernetInterface).EthernetInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("ethernet_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_TunnelInterface:
		if fv, exists := v.FldValidators["interface_choice.tunnel_interface"]; exists {
			val := m.GetInterfaceChoice().(*CreateSpecType_TunnelInterface).TunnelInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("tunnel_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_LegacyInterface:
		if fv, exists := v.FldValidators["interface_choice.legacy_interface"]; exists {
			val := m.GetInterfaceChoice().(*CreateSpecType_LegacyInterface).LegacyInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("legacy_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_DedicatedManagementInterface:
		if fv, exists := v.FldValidators["interface_choice.dedicated_management_interface"]; exists {
			val := m.GetInterfaceChoice().(*CreateSpecType_DedicatedManagementInterface).DedicatedManagementInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("dedicated_management_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_Layer2Interface:
		if fv, exists := v.FldValidators["interface_choice.layer2_interface"]; exists {
			val := m.GetInterfaceChoice().(*CreateSpecType_Layer2Interface).Layer2Interface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("layer2_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInterfaceChoice := v.InterfaceChoiceValidationRuleHandler
	rulesInterfaceChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhInterfaceChoice(rulesInterfaceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.interface_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface_choice"] = vFn

	v.FldValidators["interface_choice.dedicated_interface"] = DedicatedInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.ethernet_interface"] = EthernetInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.tunnel_interface"] = TunnelInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.legacy_interface"] = LegacyInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.dedicated_management_interface"] = DedicatedManagementInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.layer2_interface"] = Layer2InterfaceTypeValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DHCPIPV6NetworkType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DHCPIPV6NetworkType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DHCPIPV6NetworkType) DeepCopy() *DHCPIPV6NetworkType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DHCPIPV6NetworkType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DHCPIPV6NetworkType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DHCPIPV6NetworkType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DHCPIPV6NetworkTypeValidator().Validate(ctx, m, opts...)
}

func (m *DHCPIPV6NetworkType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetNetworkPrefixChoiceDRefInfo()

}

func (m *DHCPIPV6NetworkType) GetNetworkPrefixChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetNetworkPrefixChoice().(type) {
	case *DHCPIPV6NetworkType_NetworkPrefixAllocator:

		vref := m.GetNetworkPrefixAllocator()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("address_allocator.Object")
		dri := db.DRefInfo{
			RefdType:   "address_allocator.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "network_prefix_allocator",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetNetworkPrefixChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *DHCPIPV6NetworkType) GetNetworkPrefixChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetNetworkPrefixChoice().(type) {
	case *DHCPIPV6NetworkType_NetworkPrefixAllocator:
		refdType, err := d.TypeForEntryKind("", "", "address_allocator.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: address_allocator")
		}

		vref := m.GetNetworkPrefixAllocator()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "address_allocator.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

type ValidateDHCPIPV6NetworkType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDHCPIPV6NetworkType) NetworkPrefixChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network_prefix_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDHCPIPV6NetworkType) NetworkPrefixChoiceNetworkPrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_NetworkPrefix, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network_prefix")
	}
	return oValidatorFn_NetworkPrefix, nil
}

func (v *ValidateDHCPIPV6NetworkType) PoolsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for pools")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*DHCPIPV6PoolType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := DHCPIPV6PoolTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for pools")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*DHCPIPV6PoolType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*DHCPIPV6PoolType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated pools")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items pools")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDHCPIPV6NetworkType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DHCPIPV6NetworkType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DHCPIPV6NetworkType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["network_prefix_choice"]; exists {
		val := m.GetNetworkPrefixChoice()
		vOpts := append(opts,
			db.WithValidateField("network_prefix_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNetworkPrefixChoice().(type) {
	case *DHCPIPV6NetworkType_NetworkPrefix:
		if fv, exists := v.FldValidators["network_prefix_choice.network_prefix"]; exists {
			val := m.GetNetworkPrefixChoice().(*DHCPIPV6NetworkType_NetworkPrefix).NetworkPrefix
			vOpts := append(opts,
				db.WithValidateField("network_prefix_choice"),
				db.WithValidateField("network_prefix"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DHCPIPV6NetworkType_NetworkPrefixAllocator:
		if fv, exists := v.FldValidators["network_prefix_choice.network_prefix_allocator"]; exists {
			val := m.GetNetworkPrefixChoice().(*DHCPIPV6NetworkType_NetworkPrefixAllocator).NetworkPrefixAllocator
			vOpts := append(opts,
				db.WithValidateField("network_prefix_choice"),
				db.WithValidateField("network_prefix_allocator"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["pools"]; exists {
		vOpts := append(opts, db.WithValidateField("pools"))
		if err := fv(ctx, m.GetPools(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDHCPIPV6NetworkTypeValidator = func() *ValidateDHCPIPV6NetworkType {
	v := &ValidateDHCPIPV6NetworkType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNetworkPrefixChoice := v.NetworkPrefixChoiceValidationRuleHandler
	rulesNetworkPrefixChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhNetworkPrefixChoice(rulesNetworkPrefixChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPIPV6NetworkType.network_prefix_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_prefix_choice"] = vFn

	vrhNetworkPrefixChoiceNetworkPrefix := v.NetworkPrefixChoiceNetworkPrefixValidationRuleHandler
	rulesNetworkPrefixChoiceNetworkPrefix := map[string]string{
		"ves.io.schema.rules.string.ipv6_prefix": "true",
	}
	vFnMap["network_prefix_choice.network_prefix"], err = vrhNetworkPrefixChoiceNetworkPrefix(rulesNetworkPrefixChoiceNetworkPrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field DHCPIPV6NetworkType.network_prefix_choice_network_prefix: %s", err)
		panic(errMsg)
	}

	v.FldValidators["network_prefix_choice.network_prefix"] = vFnMap["network_prefix_choice.network_prefix"]

	vrhPools := v.PoolsValidationRuleHandler
	rulesPools := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhPools(rulesPools)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPIPV6NetworkType.pools: %s", err)
		panic(errMsg)
	}
	v.FldValidators["pools"] = vFn

	v.FldValidators["network_prefix_choice.network_prefix_allocator"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func DHCPIPV6NetworkTypeValidator() db.Validator {
	return DefaultDHCPIPV6NetworkTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DHCPIPV6PoolType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DHCPIPV6PoolType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DHCPIPV6PoolType) DeepCopy() *DHCPIPV6PoolType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DHCPIPV6PoolType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DHCPIPV6PoolType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DHCPIPV6PoolType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DHCPIPV6PoolTypeValidator().Validate(ctx, m, opts...)
}

type ValidateDHCPIPV6PoolType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDHCPIPV6PoolType) StartIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_ip")
	}

	return validatorFn, nil
}

func (v *ValidateDHCPIPV6PoolType) EndIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_ip")
	}

	return validatorFn, nil
}

func (v *ValidateDHCPIPV6PoolType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DHCPIPV6PoolType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DHCPIPV6PoolType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["end_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("end_ip"))
		if err := fv(ctx, m.GetEndIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["exclude"]; exists {

		vOpts := append(opts, db.WithValidateField("exclude"))
		if err := fv(ctx, m.GetExclude(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("start_ip"))
		if err := fv(ctx, m.GetStartIp(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDHCPIPV6PoolTypeValidator = func() *ValidateDHCPIPV6PoolType {
	v := &ValidateDHCPIPV6PoolType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStartIp := v.StartIpValidationRuleHandler
	rulesStartIp := map[string]string{
		"ves.io.schema.rules.string.ipv6": "true",
	}
	vFn, err = vrhStartIp(rulesStartIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPIPV6PoolType.start_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_ip"] = vFn

	vrhEndIp := v.EndIpValidationRuleHandler
	rulesEndIp := map[string]string{
		"ves.io.schema.rules.string.ipv6": "true",
	}
	vFn, err = vrhEndIp(rulesEndIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPIPV6PoolType.end_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_ip"] = vFn

	return v
}()

func DHCPIPV6PoolTypeValidator() db.Validator {
	return DefaultDHCPIPV6PoolTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DHCPIPV6StatefulServer) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DHCPIPV6StatefulServer) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DHCPIPV6StatefulServer) DeepCopy() *DHCPIPV6StatefulServer {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DHCPIPV6StatefulServer{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DHCPIPV6StatefulServer) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DHCPIPV6StatefulServer) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DHCPIPV6StatefulServerValidator().Validate(ctx, m, opts...)
}

func (m *DHCPIPV6StatefulServer) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetDhcpNetworksDRefInfo()

}

// GetDRefInfo for the field's type
func (m *DHCPIPV6StatefulServer) GetDhcpNetworksDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDhcpNetworks() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetDhcpNetworks() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetDhcpNetworks() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("dhcp_networks[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateDHCPIPV6StatefulServer struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDHCPIPV6StatefulServer) InterfacesAddressingChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for interfaces_addressing_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDHCPIPV6StatefulServer) DhcpNetworksValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for dhcp_networks")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*DHCPIPV6NetworkType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := DHCPIPV6NetworkTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for dhcp_networks")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*DHCPIPV6NetworkType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*DHCPIPV6NetworkType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated dhcp_networks")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items dhcp_networks")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDHCPIPV6StatefulServer) FixedIpMapValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for fixed_ip_map")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for fixed_ip_map")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for fixed_ip_map")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map fixed_ip_map")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items fixed_ip_map")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDHCPIPV6StatefulServer) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DHCPIPV6StatefulServer)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DHCPIPV6StatefulServer got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dhcp_networks"]; exists {
		vOpts := append(opts, db.WithValidateField("dhcp_networks"))
		if err := fv(ctx, m.GetDhcpNetworks(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["fixed_ip_map"]; exists {
		vOpts := append(opts, db.WithValidateField("fixed_ip_map"))
		if err := fv(ctx, m.GetFixedIpMap(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["interfaces_addressing_choice"]; exists {
		val := m.GetInterfacesAddressingChoice()
		vOpts := append(opts,
			db.WithValidateField("interfaces_addressing_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetInterfacesAddressingChoice().(type) {
	case *DHCPIPV6StatefulServer_AutomaticFromStart:
		if fv, exists := v.FldValidators["interfaces_addressing_choice.automatic_from_start"]; exists {
			val := m.GetInterfacesAddressingChoice().(*DHCPIPV6StatefulServer_AutomaticFromStart).AutomaticFromStart
			vOpts := append(opts,
				db.WithValidateField("interfaces_addressing_choice"),
				db.WithValidateField("automatic_from_start"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DHCPIPV6StatefulServer_AutomaticFromEnd:
		if fv, exists := v.FldValidators["interfaces_addressing_choice.automatic_from_end"]; exists {
			val := m.GetInterfacesAddressingChoice().(*DHCPIPV6StatefulServer_AutomaticFromEnd).AutomaticFromEnd
			vOpts := append(opts,
				db.WithValidateField("interfaces_addressing_choice"),
				db.WithValidateField("automatic_from_end"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DHCPIPV6StatefulServer_InterfaceIpMap:
		if fv, exists := v.FldValidators["interfaces_addressing_choice.interface_ip_map"]; exists {
			val := m.GetInterfacesAddressingChoice().(*DHCPIPV6StatefulServer_InterfaceIpMap).InterfaceIpMap
			vOpts := append(opts,
				db.WithValidateField("interfaces_addressing_choice"),
				db.WithValidateField("interface_ip_map"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDHCPIPV6StatefulServerValidator = func() *ValidateDHCPIPV6StatefulServer {
	v := &ValidateDHCPIPV6StatefulServer{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInterfacesAddressingChoice := v.InterfacesAddressingChoiceValidationRuleHandler
	rulesInterfacesAddressingChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhInterfacesAddressingChoice(rulesInterfacesAddressingChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPIPV6StatefulServer.interfaces_addressing_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interfaces_addressing_choice"] = vFn

	vrhDhcpNetworks := v.DhcpNetworksValidationRuleHandler
	rulesDhcpNetworks := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "1",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhDhcpNetworks(rulesDhcpNetworks)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPIPV6StatefulServer.dhcp_networks: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dhcp_networks"] = vFn

	vrhFixedIpMap := v.FixedIpMapValidationRuleHandler
	rulesFixedIpMap := map[string]string{
		"ves.io.schema.rules.map.keys.string.mac":    "true",
		"ves.io.schema.rules.map.max_pairs":          "128",
		"ves.io.schema.rules.map.unique_values":      "true",
		"ves.io.schema.rules.map.values.string.ipv6": "true",
	}
	vFn, err = vrhFixedIpMap(rulesFixedIpMap)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPIPV6StatefulServer.fixed_ip_map: %s", err)
		panic(errMsg)
	}
	v.FldValidators["fixed_ip_map"] = vFn

	v.FldValidators["interfaces_addressing_choice.interface_ip_map"] = DHCPInterfaceIPV6TypeValidator().Validate

	return v
}()

func DHCPIPV6StatefulServerValidator() db.Validator {
	return DefaultDHCPIPV6StatefulServerValidator
}

// augmented methods on protoc/std generated struct

func (m *DHCPInterfaceIPType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DHCPInterfaceIPType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DHCPInterfaceIPType) DeepCopy() *DHCPInterfaceIPType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DHCPInterfaceIPType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DHCPInterfaceIPType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DHCPInterfaceIPType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DHCPInterfaceIPTypeValidator().Validate(ctx, m, opts...)
}

type ValidateDHCPInterfaceIPType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDHCPInterfaceIPType) InterfaceIpMapValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for interface_ip_map")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for interface_ip_map")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for interface_ip_map")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map interface_ip_map")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items interface_ip_map")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDHCPInterfaceIPType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DHCPInterfaceIPType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DHCPInterfaceIPType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["interface_ip_map"]; exists {
		vOpts := append(opts, db.WithValidateField("interface_ip_map"))
		if err := fv(ctx, m.GetInterfaceIpMap(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDHCPInterfaceIPTypeValidator = func() *ValidateDHCPInterfaceIPType {
	v := &ValidateDHCPInterfaceIPType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInterfaceIpMap := v.InterfaceIpMapValidationRuleHandler
	rulesInterfaceIpMap := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len": "128",
		"ves.io.schema.rules.map.keys.string.min_len": "1",
		"ves.io.schema.rules.map.max_pairs":           "64",
		"ves.io.schema.rules.map.values.string.ipv4":  "true",
	}
	vFn, err = vrhInterfaceIpMap(rulesInterfaceIpMap)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPInterfaceIPType.interface_ip_map: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface_ip_map"] = vFn

	return v
}()

func DHCPInterfaceIPTypeValidator() db.Validator {
	return DefaultDHCPInterfaceIPTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DHCPInterfaceIPV6Type) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DHCPInterfaceIPV6Type) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DHCPInterfaceIPV6Type) DeepCopy() *DHCPInterfaceIPV6Type {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DHCPInterfaceIPV6Type{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DHCPInterfaceIPV6Type) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DHCPInterfaceIPV6Type) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DHCPInterfaceIPV6TypeValidator().Validate(ctx, m, opts...)
}

type ValidateDHCPInterfaceIPV6Type struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDHCPInterfaceIPV6Type) InterfaceIpMapValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for interface_ip_map")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for interface_ip_map")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for interface_ip_map")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map interface_ip_map")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items interface_ip_map")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDHCPInterfaceIPV6Type) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DHCPInterfaceIPV6Type)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DHCPInterfaceIPV6Type got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["interface_ip_map"]; exists {
		vOpts := append(opts, db.WithValidateField("interface_ip_map"))
		if err := fv(ctx, m.GetInterfaceIpMap(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDHCPInterfaceIPV6TypeValidator = func() *ValidateDHCPInterfaceIPV6Type {
	v := &ValidateDHCPInterfaceIPV6Type{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInterfaceIpMap := v.InterfaceIpMapValidationRuleHandler
	rulesInterfaceIpMap := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len": "128",
		"ves.io.schema.rules.map.keys.string.min_len": "1",
		"ves.io.schema.rules.map.max_pairs":           "64",
		"ves.io.schema.rules.map.values.string.ipv6":  "true",
	}
	vFn, err = vrhInterfaceIpMap(rulesInterfaceIpMap)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPInterfaceIPV6Type.interface_ip_map: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface_ip_map"] = vFn

	return v
}()

func DHCPInterfaceIPV6TypeValidator() db.Validator {
	return DefaultDHCPInterfaceIPV6TypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DHCPNetworkType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DHCPNetworkType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DHCPNetworkType) DeepCopy() *DHCPNetworkType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DHCPNetworkType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DHCPNetworkType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DHCPNetworkType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DHCPNetworkTypeValidator().Validate(ctx, m, opts...)
}

func (m *DHCPNetworkType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetNetworkPrefixChoiceDRefInfo()

}

func (m *DHCPNetworkType) GetNetworkPrefixChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetNetworkPrefixChoice().(type) {
	case *DHCPNetworkType_NetworkPrefixAllocator:

		vref := m.GetNetworkPrefixAllocator()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("address_allocator.Object")
		dri := db.DRefInfo{
			RefdType:   "address_allocator.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "network_prefix_allocator",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetNetworkPrefixChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *DHCPNetworkType) GetNetworkPrefixChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetNetworkPrefixChoice().(type) {
	case *DHCPNetworkType_NetworkPrefixAllocator:
		refdType, err := d.TypeForEntryKind("", "", "address_allocator.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: address_allocator")
		}

		vref := m.GetNetworkPrefixAllocator()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "address_allocator.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

type ValidateDHCPNetworkType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDHCPNetworkType) DnsChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dns_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDHCPNetworkType) DnsChoiceDnsAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_DnsAddress, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dns_address")
	}
	return oValidatorFn_DnsAddress, nil
}

func (v *ValidateDHCPNetworkType) GatewayChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for gateway_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDHCPNetworkType) GatewayChoiceDgwAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_DgwAddress, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dgw_address")
	}
	return oValidatorFn_DgwAddress, nil
}

func (v *ValidateDHCPNetworkType) NetworkPrefixChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network_prefix_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDHCPNetworkType) NetworkPrefixChoiceNetworkPrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_NetworkPrefix, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network_prefix")
	}
	return oValidatorFn_NetworkPrefix, nil
}

func (v *ValidateDHCPNetworkType) PoolsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for pools")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*DHCPPoolType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := DHCPPoolTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for pools")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*DHCPPoolType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*DHCPPoolType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated pools")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items pools")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDHCPNetworkType) PoolSettingsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(DHCPPoolSettingType)
		return int32(i)
	}
	// DHCPPoolSettingType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, DHCPPoolSettingType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for pool_settings")
	}

	return validatorFn, nil
}

func (v *ValidateDHCPNetworkType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DHCPNetworkType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DHCPNetworkType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dns_choice"]; exists {
		val := m.GetDnsChoice()
		vOpts := append(opts,
			db.WithValidateField("dns_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDnsChoice().(type) {
	case *DHCPNetworkType_SameAsDgw:
		if fv, exists := v.FldValidators["dns_choice.same_as_dgw"]; exists {
			val := m.GetDnsChoice().(*DHCPNetworkType_SameAsDgw).SameAsDgw
			vOpts := append(opts,
				db.WithValidateField("dns_choice"),
				db.WithValidateField("same_as_dgw"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DHCPNetworkType_DnsAddress:
		if fv, exists := v.FldValidators["dns_choice.dns_address"]; exists {
			val := m.GetDnsChoice().(*DHCPNetworkType_DnsAddress).DnsAddress
			vOpts := append(opts,
				db.WithValidateField("dns_choice"),
				db.WithValidateField("dns_address"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["gateway_choice"]; exists {
		val := m.GetGatewayChoice()
		vOpts := append(opts,
			db.WithValidateField("gateway_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetGatewayChoice().(type) {
	case *DHCPNetworkType_FirstAddress:
		if fv, exists := v.FldValidators["gateway_choice.first_address"]; exists {
			val := m.GetGatewayChoice().(*DHCPNetworkType_FirstAddress).FirstAddress
			vOpts := append(opts,
				db.WithValidateField("gateway_choice"),
				db.WithValidateField("first_address"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DHCPNetworkType_LastAddress:
		if fv, exists := v.FldValidators["gateway_choice.last_address"]; exists {
			val := m.GetGatewayChoice().(*DHCPNetworkType_LastAddress).LastAddress
			vOpts := append(opts,
				db.WithValidateField("gateway_choice"),
				db.WithValidateField("last_address"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DHCPNetworkType_DgwAddress:
		if fv, exists := v.FldValidators["gateway_choice.dgw_address"]; exists {
			val := m.GetGatewayChoice().(*DHCPNetworkType_DgwAddress).DgwAddress
			vOpts := append(opts,
				db.WithValidateField("gateway_choice"),
				db.WithValidateField("dgw_address"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["network_prefix_choice"]; exists {
		val := m.GetNetworkPrefixChoice()
		vOpts := append(opts,
			db.WithValidateField("network_prefix_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNetworkPrefixChoice().(type) {
	case *DHCPNetworkType_NetworkPrefix:
		if fv, exists := v.FldValidators["network_prefix_choice.network_prefix"]; exists {
			val := m.GetNetworkPrefixChoice().(*DHCPNetworkType_NetworkPrefix).NetworkPrefix
			vOpts := append(opts,
				db.WithValidateField("network_prefix_choice"),
				db.WithValidateField("network_prefix"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DHCPNetworkType_NetworkPrefixAllocator:
		if fv, exists := v.FldValidators["network_prefix_choice.network_prefix_allocator"]; exists {
			val := m.GetNetworkPrefixChoice().(*DHCPNetworkType_NetworkPrefixAllocator).NetworkPrefixAllocator
			vOpts := append(opts,
				db.WithValidateField("network_prefix_choice"),
				db.WithValidateField("network_prefix_allocator"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["pool_settings"]; exists {

		vOpts := append(opts, db.WithValidateField("pool_settings"))
		if err := fv(ctx, m.GetPoolSettings(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["pools"]; exists {
		vOpts := append(opts, db.WithValidateField("pools"))
		if err := fv(ctx, m.GetPools(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDHCPNetworkTypeValidator = func() *ValidateDHCPNetworkType {
	v := &ValidateDHCPNetworkType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDnsChoice := v.DnsChoiceValidationRuleHandler
	rulesDnsChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDnsChoice(rulesDnsChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPNetworkType.dns_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_choice"] = vFn

	vrhDnsChoiceDnsAddress := v.DnsChoiceDnsAddressValidationRuleHandler
	rulesDnsChoiceDnsAddress := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFnMap["dns_choice.dns_address"], err = vrhDnsChoiceDnsAddress(rulesDnsChoiceDnsAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field DHCPNetworkType.dns_choice_dns_address: %s", err)
		panic(errMsg)
	}

	v.FldValidators["dns_choice.dns_address"] = vFnMap["dns_choice.dns_address"]

	vrhGatewayChoice := v.GatewayChoiceValidationRuleHandler
	rulesGatewayChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhGatewayChoice(rulesGatewayChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPNetworkType.gateway_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["gateway_choice"] = vFn

	vrhGatewayChoiceDgwAddress := v.GatewayChoiceDgwAddressValidationRuleHandler
	rulesGatewayChoiceDgwAddress := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFnMap["gateway_choice.dgw_address"], err = vrhGatewayChoiceDgwAddress(rulesGatewayChoiceDgwAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field DHCPNetworkType.gateway_choice_dgw_address: %s", err)
		panic(errMsg)
	}

	v.FldValidators["gateway_choice.dgw_address"] = vFnMap["gateway_choice.dgw_address"]

	vrhNetworkPrefixChoice := v.NetworkPrefixChoiceValidationRuleHandler
	rulesNetworkPrefixChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhNetworkPrefixChoice(rulesNetworkPrefixChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPNetworkType.network_prefix_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_prefix_choice"] = vFn

	vrhNetworkPrefixChoiceNetworkPrefix := v.NetworkPrefixChoiceNetworkPrefixValidationRuleHandler
	rulesNetworkPrefixChoiceNetworkPrefix := map[string]string{
		"ves.io.schema.rules.string.ipv4_prefix": "true",
	}
	vFnMap["network_prefix_choice.network_prefix"], err = vrhNetworkPrefixChoiceNetworkPrefix(rulesNetworkPrefixChoiceNetworkPrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field DHCPNetworkType.network_prefix_choice_network_prefix: %s", err)
		panic(errMsg)
	}

	v.FldValidators["network_prefix_choice.network_prefix"] = vFnMap["network_prefix_choice.network_prefix"]

	vrhPools := v.PoolsValidationRuleHandler
	rulesPools := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhPools(rulesPools)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPNetworkType.pools: %s", err)
		panic(errMsg)
	}
	v.FldValidators["pools"] = vFn

	vrhPoolSettings := v.PoolSettingsValidationRuleHandler
	rulesPoolSettings := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhPoolSettings(rulesPoolSettings)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPNetworkType.pool_settings: %s", err)
		panic(errMsg)
	}
	v.FldValidators["pool_settings"] = vFn

	v.FldValidators["network_prefix_choice.network_prefix_allocator"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func DHCPNetworkTypeValidator() db.Validator {
	return DefaultDHCPNetworkTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DHCPPoolType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DHCPPoolType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DHCPPoolType) DeepCopy() *DHCPPoolType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DHCPPoolType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DHCPPoolType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DHCPPoolType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DHCPPoolTypeValidator().Validate(ctx, m, opts...)
}

type ValidateDHCPPoolType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDHCPPoolType) StartIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_ip")
	}

	return validatorFn, nil
}

func (v *ValidateDHCPPoolType) EndIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_ip")
	}

	return validatorFn, nil
}

func (v *ValidateDHCPPoolType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DHCPPoolType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DHCPPoolType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["end_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("end_ip"))
		if err := fv(ctx, m.GetEndIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["exclude"]; exists {

		vOpts := append(opts, db.WithValidateField("exclude"))
		if err := fv(ctx, m.GetExclude(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("start_ip"))
		if err := fv(ctx, m.GetStartIp(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDHCPPoolTypeValidator = func() *ValidateDHCPPoolType {
	v := &ValidateDHCPPoolType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStartIp := v.StartIpValidationRuleHandler
	rulesStartIp := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFn, err = vrhStartIp(rulesStartIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPPoolType.start_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_ip"] = vFn

	vrhEndIp := v.EndIpValidationRuleHandler
	rulesEndIp := map[string]string{
		"ves.io.schema.rules.string.ipv4": "true",
	}
	vFn, err = vrhEndIp(rulesEndIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPPoolType.end_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_ip"] = vFn

	return v
}()

func DHCPPoolTypeValidator() db.Validator {
	return DefaultDHCPPoolTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DHCPServerParametersType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DHCPServerParametersType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DHCPServerParametersType) DeepCopy() *DHCPServerParametersType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DHCPServerParametersType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DHCPServerParametersType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DHCPServerParametersType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DHCPServerParametersTypeValidator().Validate(ctx, m, opts...)
}

func (m *DHCPServerParametersType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetDhcpNetworksDRefInfo()

}

// GetDRefInfo for the field's type
func (m *DHCPServerParametersType) GetDhcpNetworksDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDhcpNetworks() == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	for idx, e := range m.GetDhcpNetworks() {
		driSet, err := e.GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetDhcpNetworks() GetDRefInfo() FAILED")
		}
		for i := range driSet {
			dri := &driSet[i]
			dri.DRField = fmt.Sprintf("dhcp_networks[%v].%s", idx, dri.DRField)
		}
		drInfos = append(drInfos, driSet...)
	}
	return drInfos, nil

}

type ValidateDHCPServerParametersType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDHCPServerParametersType) InterfacesAddressingChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for interfaces_addressing_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDHCPServerParametersType) DhcpNetworksValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for dhcp_networks")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*DHCPNetworkType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := DHCPNetworkTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for dhcp_networks")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*DHCPNetworkType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*DHCPNetworkType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated dhcp_networks")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items dhcp_networks")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDHCPServerParametersType) FixedIpMapValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for fixed_ip_map")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for fixed_ip_map")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for fixed_ip_map")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map fixed_ip_map")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items fixed_ip_map")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateDHCPServerParametersType) DhcpOption82TagValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dhcp_option82_tag")
	}

	return validatorFn, nil
}

func (v *ValidateDHCPServerParametersType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DHCPServerParametersType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DHCPServerParametersType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dhcp_networks"]; exists {
		vOpts := append(opts, db.WithValidateField("dhcp_networks"))
		if err := fv(ctx, m.GetDhcpNetworks(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dhcp_option82_tag"]; exists {

		vOpts := append(opts, db.WithValidateField("dhcp_option82_tag"))
		if err := fv(ctx, m.GetDhcpOption82Tag(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["fixed_ip_map"]; exists {
		vOpts := append(opts, db.WithValidateField("fixed_ip_map"))
		if err := fv(ctx, m.GetFixedIpMap(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["interfaces_addressing_choice"]; exists {
		val := m.GetInterfacesAddressingChoice()
		vOpts := append(opts,
			db.WithValidateField("interfaces_addressing_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetInterfacesAddressingChoice().(type) {
	case *DHCPServerParametersType_AutomaticFromStart:
		if fv, exists := v.FldValidators["interfaces_addressing_choice.automatic_from_start"]; exists {
			val := m.GetInterfacesAddressingChoice().(*DHCPServerParametersType_AutomaticFromStart).AutomaticFromStart
			vOpts := append(opts,
				db.WithValidateField("interfaces_addressing_choice"),
				db.WithValidateField("automatic_from_start"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DHCPServerParametersType_AutomaticFromEnd:
		if fv, exists := v.FldValidators["interfaces_addressing_choice.automatic_from_end"]; exists {
			val := m.GetInterfacesAddressingChoice().(*DHCPServerParametersType_AutomaticFromEnd).AutomaticFromEnd
			vOpts := append(opts,
				db.WithValidateField("interfaces_addressing_choice"),
				db.WithValidateField("automatic_from_end"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DHCPServerParametersType_InterfaceIpMap:
		if fv, exists := v.FldValidators["interfaces_addressing_choice.interface_ip_map"]; exists {
			val := m.GetInterfacesAddressingChoice().(*DHCPServerParametersType_InterfaceIpMap).InterfaceIpMap
			vOpts := append(opts,
				db.WithValidateField("interfaces_addressing_choice"),
				db.WithValidateField("interface_ip_map"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDHCPServerParametersTypeValidator = func() *ValidateDHCPServerParametersType {
	v := &ValidateDHCPServerParametersType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInterfacesAddressingChoice := v.InterfacesAddressingChoiceValidationRuleHandler
	rulesInterfacesAddressingChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhInterfacesAddressingChoice(rulesInterfacesAddressingChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPServerParametersType.interfaces_addressing_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interfaces_addressing_choice"] = vFn

	vrhDhcpNetworks := v.DhcpNetworksValidationRuleHandler
	rulesDhcpNetworks := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "1",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhDhcpNetworks(rulesDhcpNetworks)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPServerParametersType.dhcp_networks: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dhcp_networks"] = vFn

	vrhFixedIpMap := v.FixedIpMapValidationRuleHandler
	rulesFixedIpMap := map[string]string{
		"ves.io.schema.rules.map.keys.string.mac":    "true",
		"ves.io.schema.rules.map.max_pairs":          "128",
		"ves.io.schema.rules.map.unique_values":      "true",
		"ves.io.schema.rules.map.values.string.ipv4": "true",
	}
	vFn, err = vrhFixedIpMap(rulesFixedIpMap)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPServerParametersType.fixed_ip_map: %s", err)
		panic(errMsg)
	}
	v.FldValidators["fixed_ip_map"] = vFn

	vrhDhcpOption82Tag := v.DhcpOption82TagValidationRuleHandler
	rulesDhcpOption82Tag := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
	}
	vFn, err = vrhDhcpOption82Tag(rulesDhcpOption82Tag)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DHCPServerParametersType.dhcp_option82_tag: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dhcp_option82_tag"] = vFn

	v.FldValidators["interfaces_addressing_choice.interface_ip_map"] = DHCPInterfaceIPTypeValidator().Validate

	return v
}()

func DHCPServerParametersTypeValidator() db.Validator {
	return DefaultDHCPServerParametersTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DedicatedInterfaceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DedicatedInterfaceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DedicatedInterfaceType) DeepCopy() *DedicatedInterfaceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DedicatedInterfaceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DedicatedInterfaceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DedicatedInterfaceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DedicatedInterfaceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateDedicatedInterfaceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDedicatedInterfaceType) NodeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDedicatedInterfaceType) NodeChoiceNodeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Node, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node")
	}
	return oValidatorFn_Node, nil
}

func (v *ValidateDedicatedInterfaceType) PrimaryChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for primary_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDedicatedInterfaceType) DeviceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for device")
	}

	return validatorFn, nil
}

func (v *ValidateDedicatedInterfaceType) MtuValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mtu")
	}

	return validatorFn, nil
}

func (v *ValidateDedicatedInterfaceType) PriorityValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for priority")
	}

	return validatorFn, nil
}

func (v *ValidateDedicatedInterfaceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DedicatedInterfaceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DedicatedInterfaceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["device"]; exists {

		vOpts := append(opts, db.WithValidateField("device"))
		if err := fv(ctx, m.GetDevice(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetMonitoringChoice().(type) {
	case *DedicatedInterfaceType_MonitorDisabled:
		if fv, exists := v.FldValidators["monitoring_choice.monitor_disabled"]; exists {
			val := m.GetMonitoringChoice().(*DedicatedInterfaceType_MonitorDisabled).MonitorDisabled
			vOpts := append(opts,
				db.WithValidateField("monitoring_choice"),
				db.WithValidateField("monitor_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DedicatedInterfaceType_Monitor:
		if fv, exists := v.FldValidators["monitoring_choice.monitor"]; exists {
			val := m.GetMonitoringChoice().(*DedicatedInterfaceType_Monitor).Monitor
			vOpts := append(opts,
				db.WithValidateField("monitoring_choice"),
				db.WithValidateField("monitor"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["mtu"]; exists {

		vOpts := append(opts, db.WithValidateField("mtu"))
		if err := fv(ctx, m.GetMtu(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["node_choice"]; exists {
		val := m.GetNodeChoice()
		vOpts := append(opts,
			db.WithValidateField("node_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNodeChoice().(type) {
	case *DedicatedInterfaceType_Cluster:
		if fv, exists := v.FldValidators["node_choice.cluster"]; exists {
			val := m.GetNodeChoice().(*DedicatedInterfaceType_Cluster).Cluster
			vOpts := append(opts,
				db.WithValidateField("node_choice"),
				db.WithValidateField("cluster"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DedicatedInterfaceType_Node:
		if fv, exists := v.FldValidators["node_choice.node"]; exists {
			val := m.GetNodeChoice().(*DedicatedInterfaceType_Node).Node
			vOpts := append(opts,
				db.WithValidateField("node_choice"),
				db.WithValidateField("node"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["primary_choice"]; exists {
		val := m.GetPrimaryChoice()
		vOpts := append(opts,
			db.WithValidateField("primary_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPrimaryChoice().(type) {
	case *DedicatedInterfaceType_NotPrimary:
		if fv, exists := v.FldValidators["primary_choice.not_primary"]; exists {
			val := m.GetPrimaryChoice().(*DedicatedInterfaceType_NotPrimary).NotPrimary
			vOpts := append(opts,
				db.WithValidateField("primary_choice"),
				db.WithValidateField("not_primary"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DedicatedInterfaceType_IsPrimary:
		if fv, exists := v.FldValidators["primary_choice.is_primary"]; exists {
			val := m.GetPrimaryChoice().(*DedicatedInterfaceType_IsPrimary).IsPrimary
			vOpts := append(opts,
				db.WithValidateField("primary_choice"),
				db.WithValidateField("is_primary"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["priority"]; exists {

		vOpts := append(opts, db.WithValidateField("priority"))
		if err := fv(ctx, m.GetPriority(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDedicatedInterfaceTypeValidator = func() *ValidateDedicatedInterfaceType {
	v := &ValidateDedicatedInterfaceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNodeChoice := v.NodeChoiceValidationRuleHandler
	rulesNodeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhNodeChoice(rulesNodeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DedicatedInterfaceType.node_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["node_choice"] = vFn

	vrhNodeChoiceNode := v.NodeChoiceNodeValidationRuleHandler
	rulesNodeChoiceNode := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["node_choice.node"], err = vrhNodeChoiceNode(rulesNodeChoiceNode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field DedicatedInterfaceType.node_choice_node: %s", err)
		panic(errMsg)
	}

	v.FldValidators["node_choice.node"] = vFnMap["node_choice.node"]

	vrhPrimaryChoice := v.PrimaryChoiceValidationRuleHandler
	rulesPrimaryChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPrimaryChoice(rulesPrimaryChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DedicatedInterfaceType.primary_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["primary_choice"] = vFn

	vrhDevice := v.DeviceValidationRuleHandler
	rulesDevice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhDevice(rulesDevice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DedicatedInterfaceType.device: %s", err)
		panic(errMsg)
	}
	v.FldValidators["device"] = vFn

	vrhMtu := v.MtuValidationRuleHandler
	rulesMtu := map[string]string{
		"ves.io.schema.rules.uint32.ranges": "0,512-16384",
	}
	vFn, err = vrhMtu(rulesMtu)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DedicatedInterfaceType.mtu: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mtu"] = vFn

	vrhPriority := v.PriorityValidationRuleHandler
	rulesPriority := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "255",
	}
	vFn, err = vrhPriority(rulesPriority)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DedicatedInterfaceType.priority: %s", err)
		panic(errMsg)
	}
	v.FldValidators["priority"] = vFn

	return v
}()

func DedicatedInterfaceTypeValidator() db.Validator {
	return DefaultDedicatedInterfaceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DedicatedManagementInterfaceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DedicatedManagementInterfaceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DedicatedManagementInterfaceType) DeepCopy() *DedicatedManagementInterfaceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DedicatedManagementInterfaceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DedicatedManagementInterfaceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DedicatedManagementInterfaceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DedicatedManagementInterfaceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateDedicatedManagementInterfaceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDedicatedManagementInterfaceType) NodeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDedicatedManagementInterfaceType) NodeChoiceNodeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Node, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node")
	}
	return oValidatorFn_Node, nil
}

func (v *ValidateDedicatedManagementInterfaceType) DeviceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for device")
	}

	return validatorFn, nil
}

func (v *ValidateDedicatedManagementInterfaceType) MtuValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mtu")
	}

	return validatorFn, nil
}

func (v *ValidateDedicatedManagementInterfaceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DedicatedManagementInterfaceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DedicatedManagementInterfaceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["device"]; exists {

		vOpts := append(opts, db.WithValidateField("device"))
		if err := fv(ctx, m.GetDevice(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mtu"]; exists {

		vOpts := append(opts, db.WithValidateField("mtu"))
		if err := fv(ctx, m.GetMtu(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["node_choice"]; exists {
		val := m.GetNodeChoice()
		vOpts := append(opts,
			db.WithValidateField("node_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNodeChoice().(type) {
	case *DedicatedManagementInterfaceType_Cluster:
		if fv, exists := v.FldValidators["node_choice.cluster"]; exists {
			val := m.GetNodeChoice().(*DedicatedManagementInterfaceType_Cluster).Cluster
			vOpts := append(opts,
				db.WithValidateField("node_choice"),
				db.WithValidateField("cluster"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DedicatedManagementInterfaceType_Node:
		if fv, exists := v.FldValidators["node_choice.node"]; exists {
			val := m.GetNodeChoice().(*DedicatedManagementInterfaceType_Node).Node
			vOpts := append(opts,
				db.WithValidateField("node_choice"),
				db.WithValidateField("node"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDedicatedManagementInterfaceTypeValidator = func() *ValidateDedicatedManagementInterfaceType {
	v := &ValidateDedicatedManagementInterfaceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNodeChoice := v.NodeChoiceValidationRuleHandler
	rulesNodeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhNodeChoice(rulesNodeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DedicatedManagementInterfaceType.node_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["node_choice"] = vFn

	vrhNodeChoiceNode := v.NodeChoiceNodeValidationRuleHandler
	rulesNodeChoiceNode := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["node_choice.node"], err = vrhNodeChoiceNode(rulesNodeChoiceNode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field DedicatedManagementInterfaceType.node_choice_node: %s", err)
		panic(errMsg)
	}

	v.FldValidators["node_choice.node"] = vFnMap["node_choice.node"]

	vrhDevice := v.DeviceValidationRuleHandler
	rulesDevice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhDevice(rulesDevice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DedicatedManagementInterfaceType.device: %s", err)
		panic(errMsg)
	}
	v.FldValidators["device"] = vFn

	vrhMtu := v.MtuValidationRuleHandler
	rulesMtu := map[string]string{
		"ves.io.schema.rules.uint32.ranges": "0,512-16384",
	}
	vFn, err = vrhMtu(rulesMtu)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DedicatedManagementInterfaceType.mtu: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mtu"] = vFn

	return v
}()

func DedicatedManagementInterfaceTypeValidator() db.Validator {
	return DefaultDedicatedManagementInterfaceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *EthernetInterfaceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *EthernetInterfaceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *EthernetInterfaceType) DeepCopy() *EthernetInterfaceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &EthernetInterfaceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *EthernetInterfaceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *EthernetInterfaceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EthernetInterfaceTypeValidator().Validate(ctx, m, opts...)
}

func (m *EthernetInterfaceType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAddressChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAddressChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetIpv6AddressChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetIpv6AddressChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetNetworkChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetNetworkChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *EthernetInterfaceType) GetAddressChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAddressChoice() == nil {
		return nil, nil
	}
	switch m.GetAddressChoice().(type) {
	case *EthernetInterfaceType_DhcpClient:

		return nil, nil

	case *EthernetInterfaceType_DhcpServer:

		drInfos, err := m.GetDhcpServer().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetDhcpServer().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "dhcp_server." + dri.DRField
		}
		return drInfos, err

	case *EthernetInterfaceType_StaticIp:

		drInfos, err := m.GetStaticIp().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetStaticIp().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "static_ip." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *EthernetInterfaceType) GetIpv6AddressChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetIpv6AddressChoice() == nil {
		return nil, nil
	}
	switch m.GetIpv6AddressChoice().(type) {
	case *EthernetInterfaceType_NoIpv6Address:

		return nil, nil

	case *EthernetInterfaceType_StaticIpv6Address:

		drInfos, err := m.GetStaticIpv6Address().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetStaticIpv6Address().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "static_ipv6_address." + dri.DRField
		}
		return drInfos, err

	case *EthernetInterfaceType_Ipv6AutoConfig:

		drInfos, err := m.GetIpv6AutoConfig().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetIpv6AutoConfig().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "ipv6_auto_config." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

func (m *EthernetInterfaceType) GetNetworkChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetNetworkChoice().(type) {
	case *EthernetInterfaceType_SiteLocalNetwork:

		return nil, nil

	case *EthernetInterfaceType_SiteLocalInsideNetwork:

		return nil, nil

	case *EthernetInterfaceType_InsideNetwork:

		vref := m.GetInsideNetwork()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("virtual_network.Object")
		dri := db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "inside_network",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	case *EthernetInterfaceType_StorageNetwork:

		return nil, nil

	case *EthernetInterfaceType_Srv6Network:

		vref := m.GetSrv6Network()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("virtual_network.Object")
		dri := db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "srv6_network",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	case *EthernetInterfaceType_IpFabricNetwork:

		return nil, nil

	case *EthernetInterfaceType_SegmentNetwork:

		vref := m.GetSegmentNetwork()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("segment.Object")
		dri := db.DRefInfo{
			RefdType:   "segment.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "segment_network",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetNetworkChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *EthernetInterfaceType) GetNetworkChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetNetworkChoice().(type) {
	case *EthernetInterfaceType_SiteLocalNetwork:

	case *EthernetInterfaceType_SiteLocalInsideNetwork:

	case *EthernetInterfaceType_InsideNetwork:
		refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
		}

		vref := m.GetInsideNetwork()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "virtual_network.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	case *EthernetInterfaceType_StorageNetwork:

	case *EthernetInterfaceType_Srv6Network:
		refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
		}

		vref := m.GetSrv6Network()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "virtual_network.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	case *EthernetInterfaceType_IpFabricNetwork:

	case *EthernetInterfaceType_SegmentNetwork:
		refdType, err := d.TypeForEntryKind("", "", "segment.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: segment")
		}

		vref := m.GetSegmentNetwork()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "segment.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

type ValidateEthernetInterfaceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEthernetInterfaceType) AddressChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address_choice")
	}
	return validatorFn, nil
}

func (v *ValidateEthernetInterfaceType) NetworkChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network_choice")
	}
	return validatorFn, nil
}

func (v *ValidateEthernetInterfaceType) NodeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node_choice")
	}
	return validatorFn, nil
}

func (v *ValidateEthernetInterfaceType) NodeChoiceNodeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Node, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node")
	}
	return oValidatorFn_Node, nil
}

func (v *ValidateEthernetInterfaceType) PrimaryChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for primary_choice")
	}
	return validatorFn, nil
}

func (v *ValidateEthernetInterfaceType) VlanChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vlan_choice")
	}
	return validatorFn, nil
}

func (v *ValidateEthernetInterfaceType) VlanChoiceVlanIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_VlanId, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vlan_id")
	}
	return oValidatorFn_VlanId, nil
}

func (v *ValidateEthernetInterfaceType) DeviceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for device")
	}

	return validatorFn, nil
}

func (v *ValidateEthernetInterfaceType) MtuValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mtu")
	}

	return validatorFn, nil
}

func (v *ValidateEthernetInterfaceType) PriorityValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for priority")
	}

	return validatorFn, nil
}

func (v *ValidateEthernetInterfaceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*EthernetInterfaceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *EthernetInterfaceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address_choice"]; exists {
		val := m.GetAddressChoice()
		vOpts := append(opts,
			db.WithValidateField("address_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAddressChoice().(type) {
	case *EthernetInterfaceType_DhcpClient:
		if fv, exists := v.FldValidators["address_choice.dhcp_client"]; exists {
			val := m.GetAddressChoice().(*EthernetInterfaceType_DhcpClient).DhcpClient
			vOpts := append(opts,
				db.WithValidateField("address_choice"),
				db.WithValidateField("dhcp_client"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EthernetInterfaceType_DhcpServer:
		if fv, exists := v.FldValidators["address_choice.dhcp_server"]; exists {
			val := m.GetAddressChoice().(*EthernetInterfaceType_DhcpServer).DhcpServer
			vOpts := append(opts,
				db.WithValidateField("address_choice"),
				db.WithValidateField("dhcp_server"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EthernetInterfaceType_StaticIp:
		if fv, exists := v.FldValidators["address_choice.static_ip"]; exists {
			val := m.GetAddressChoice().(*EthernetInterfaceType_StaticIp).StaticIp
			vOpts := append(opts,
				db.WithValidateField("address_choice"),
				db.WithValidateField("static_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["device"]; exists {

		vOpts := append(opts, db.WithValidateField("device"))
		if err := fv(ctx, m.GetDevice(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetIpv6AddressChoice().(type) {
	case *EthernetInterfaceType_NoIpv6Address:
		if fv, exists := v.FldValidators["ipv6_address_choice.no_ipv6_address"]; exists {
			val := m.GetIpv6AddressChoice().(*EthernetInterfaceType_NoIpv6Address).NoIpv6Address
			vOpts := append(opts,
				db.WithValidateField("ipv6_address_choice"),
				db.WithValidateField("no_ipv6_address"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EthernetInterfaceType_StaticIpv6Address:
		if fv, exists := v.FldValidators["ipv6_address_choice.static_ipv6_address"]; exists {
			val := m.GetIpv6AddressChoice().(*EthernetInterfaceType_StaticIpv6Address).StaticIpv6Address
			vOpts := append(opts,
				db.WithValidateField("ipv6_address_choice"),
				db.WithValidateField("static_ipv6_address"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EthernetInterfaceType_Ipv6AutoConfig:
		if fv, exists := v.FldValidators["ipv6_address_choice.ipv6_auto_config"]; exists {
			val := m.GetIpv6AddressChoice().(*EthernetInterfaceType_Ipv6AutoConfig).Ipv6AutoConfig
			vOpts := append(opts,
				db.WithValidateField("ipv6_address_choice"),
				db.WithValidateField("ipv6_auto_config"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	switch m.GetMonitoringChoice().(type) {
	case *EthernetInterfaceType_MonitorDisabled:
		if fv, exists := v.FldValidators["monitoring_choice.monitor_disabled"]; exists {
			val := m.GetMonitoringChoice().(*EthernetInterfaceType_MonitorDisabled).MonitorDisabled
			vOpts := append(opts,
				db.WithValidateField("monitoring_choice"),
				db.WithValidateField("monitor_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EthernetInterfaceType_Monitor:
		if fv, exists := v.FldValidators["monitoring_choice.monitor"]; exists {
			val := m.GetMonitoringChoice().(*EthernetInterfaceType_Monitor).Monitor
			vOpts := append(opts,
				db.WithValidateField("monitoring_choice"),
				db.WithValidateField("monitor"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["mtu"]; exists {

		vOpts := append(opts, db.WithValidateField("mtu"))
		if err := fv(ctx, m.GetMtu(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_choice"]; exists {
		val := m.GetNetworkChoice()
		vOpts := append(opts,
			db.WithValidateField("network_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNetworkChoice().(type) {
	case *EthernetInterfaceType_SiteLocalNetwork:
		if fv, exists := v.FldValidators["network_choice.site_local_network"]; exists {
			val := m.GetNetworkChoice().(*EthernetInterfaceType_SiteLocalNetwork).SiteLocalNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("site_local_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EthernetInterfaceType_SiteLocalInsideNetwork:
		if fv, exists := v.FldValidators["network_choice.site_local_inside_network"]; exists {
			val := m.GetNetworkChoice().(*EthernetInterfaceType_SiteLocalInsideNetwork).SiteLocalInsideNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("site_local_inside_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EthernetInterfaceType_InsideNetwork:
		if fv, exists := v.FldValidators["network_choice.inside_network"]; exists {
			val := m.GetNetworkChoice().(*EthernetInterfaceType_InsideNetwork).InsideNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("inside_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EthernetInterfaceType_StorageNetwork:
		if fv, exists := v.FldValidators["network_choice.storage_network"]; exists {
			val := m.GetNetworkChoice().(*EthernetInterfaceType_StorageNetwork).StorageNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("storage_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EthernetInterfaceType_Srv6Network:
		if fv, exists := v.FldValidators["network_choice.srv6_network"]; exists {
			val := m.GetNetworkChoice().(*EthernetInterfaceType_Srv6Network).Srv6Network
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("srv6_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EthernetInterfaceType_IpFabricNetwork:
		if fv, exists := v.FldValidators["network_choice.ip_fabric_network"]; exists {
			val := m.GetNetworkChoice().(*EthernetInterfaceType_IpFabricNetwork).IpFabricNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("ip_fabric_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EthernetInterfaceType_SegmentNetwork:
		if fv, exists := v.FldValidators["network_choice.segment_network"]; exists {
			val := m.GetNetworkChoice().(*EthernetInterfaceType_SegmentNetwork).SegmentNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("segment_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["node_choice"]; exists {
		val := m.GetNodeChoice()
		vOpts := append(opts,
			db.WithValidateField("node_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNodeChoice().(type) {
	case *EthernetInterfaceType_Cluster:
		if fv, exists := v.FldValidators["node_choice.cluster"]; exists {
			val := m.GetNodeChoice().(*EthernetInterfaceType_Cluster).Cluster
			vOpts := append(opts,
				db.WithValidateField("node_choice"),
				db.WithValidateField("cluster"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EthernetInterfaceType_Node:
		if fv, exists := v.FldValidators["node_choice.node"]; exists {
			val := m.GetNodeChoice().(*EthernetInterfaceType_Node).Node
			vOpts := append(opts,
				db.WithValidateField("node_choice"),
				db.WithValidateField("node"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["primary_choice"]; exists {
		val := m.GetPrimaryChoice()
		vOpts := append(opts,
			db.WithValidateField("primary_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPrimaryChoice().(type) {
	case *EthernetInterfaceType_NotPrimary:
		if fv, exists := v.FldValidators["primary_choice.not_primary"]; exists {
			val := m.GetPrimaryChoice().(*EthernetInterfaceType_NotPrimary).NotPrimary
			vOpts := append(opts,
				db.WithValidateField("primary_choice"),
				db.WithValidateField("not_primary"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EthernetInterfaceType_IsPrimary:
		if fv, exists := v.FldValidators["primary_choice.is_primary"]; exists {
			val := m.GetPrimaryChoice().(*EthernetInterfaceType_IsPrimary).IsPrimary
			vOpts := append(opts,
				db.WithValidateField("primary_choice"),
				db.WithValidateField("is_primary"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["priority"]; exists {

		vOpts := append(opts, db.WithValidateField("priority"))
		if err := fv(ctx, m.GetPriority(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vlan_choice"]; exists {
		val := m.GetVlanChoice()
		vOpts := append(opts,
			db.WithValidateField("vlan_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetVlanChoice().(type) {
	case *EthernetInterfaceType_Untagged:
		if fv, exists := v.FldValidators["vlan_choice.untagged"]; exists {
			val := m.GetVlanChoice().(*EthernetInterfaceType_Untagged).Untagged
			vOpts := append(opts,
				db.WithValidateField("vlan_choice"),
				db.WithValidateField("untagged"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *EthernetInterfaceType_VlanId:
		if fv, exists := v.FldValidators["vlan_choice.vlan_id"]; exists {
			val := m.GetVlanChoice().(*EthernetInterfaceType_VlanId).VlanId
			vOpts := append(opts,
				db.WithValidateField("vlan_choice"),
				db.WithValidateField("vlan_id"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEthernetInterfaceTypeValidator = func() *ValidateEthernetInterfaceType {
	v := &ValidateEthernetInterfaceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAddressChoice := v.AddressChoiceValidationRuleHandler
	rulesAddressChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAddressChoice(rulesAddressChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EthernetInterfaceType.address_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address_choice"] = vFn

	vrhNetworkChoice := v.NetworkChoiceValidationRuleHandler
	rulesNetworkChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhNetworkChoice(rulesNetworkChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EthernetInterfaceType.network_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_choice"] = vFn

	vrhNodeChoice := v.NodeChoiceValidationRuleHandler
	rulesNodeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhNodeChoice(rulesNodeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EthernetInterfaceType.node_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["node_choice"] = vFn

	vrhNodeChoiceNode := v.NodeChoiceNodeValidationRuleHandler
	rulesNodeChoiceNode := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["node_choice.node"], err = vrhNodeChoiceNode(rulesNodeChoiceNode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field EthernetInterfaceType.node_choice_node: %s", err)
		panic(errMsg)
	}

	v.FldValidators["node_choice.node"] = vFnMap["node_choice.node"]

	vrhPrimaryChoice := v.PrimaryChoiceValidationRuleHandler
	rulesPrimaryChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPrimaryChoice(rulesPrimaryChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EthernetInterfaceType.primary_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["primary_choice"] = vFn

	vrhVlanChoice := v.VlanChoiceValidationRuleHandler
	rulesVlanChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhVlanChoice(rulesVlanChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EthernetInterfaceType.vlan_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vlan_choice"] = vFn

	vrhVlanChoiceVlanId := v.VlanChoiceVlanIdValidationRuleHandler
	rulesVlanChoiceVlanId := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "4095",
	}
	vFnMap["vlan_choice.vlan_id"], err = vrhVlanChoiceVlanId(rulesVlanChoiceVlanId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field EthernetInterfaceType.vlan_choice_vlan_id: %s", err)
		panic(errMsg)
	}

	v.FldValidators["vlan_choice.vlan_id"] = vFnMap["vlan_choice.vlan_id"]

	vrhDevice := v.DeviceValidationRuleHandler
	rulesDevice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhDevice(rulesDevice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EthernetInterfaceType.device: %s", err)
		panic(errMsg)
	}
	v.FldValidators["device"] = vFn

	vrhMtu := v.MtuValidationRuleHandler
	rulesMtu := map[string]string{
		"ves.io.schema.rules.uint32.ranges": "0,512-16384",
	}
	vFn, err = vrhMtu(rulesMtu)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EthernetInterfaceType.mtu: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mtu"] = vFn

	vrhPriority := v.PriorityValidationRuleHandler
	rulesPriority := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "255",
	}
	vFn, err = vrhPriority(rulesPriority)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EthernetInterfaceType.priority: %s", err)
		panic(errMsg)
	}
	v.FldValidators["priority"] = vFn

	v.FldValidators["address_choice.dhcp_server"] = DHCPServerParametersTypeValidator().Validate
	v.FldValidators["address_choice.static_ip"] = StaticIPParametersTypeValidator().Validate

	v.FldValidators["ipv6_address_choice.static_ipv6_address"] = StaticIPParametersTypeValidator().Validate
	v.FldValidators["ipv6_address_choice.ipv6_auto_config"] = IPV6AutoConfigTypeValidator().Validate

	v.FldValidators["network_choice.inside_network"] = ves_io_schema_views.ObjectRefTypeValidator().Validate
	v.FldValidators["network_choice.srv6_network"] = ves_io_schema_views.ObjectRefTypeValidator().Validate
	v.FldValidators["network_choice.segment_network"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func EthernetInterfaceTypeValidator() db.Validator {
	return DefaultEthernetInterfaceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GetSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAddressAllocatorDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAddressAllocatorDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetInterfaceChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetInterfaceChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetParentNetworkInterfaceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetParentNetworkInterfaceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTunnelDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTunnelDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetVirtualNetworkDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetVirtualNetworkDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *GetSpecType) GetAddressAllocatorDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetAddressAllocator()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.address_allocator[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "address_allocator.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "address_allocator",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetAddressAllocatorDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetAddressAllocatorDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "address_allocator.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: address_allocator")
	}
	for _, ref := range m.GetAddressAllocator() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetInterfaceChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetInterfaceChoice() == nil {
		return nil, nil
	}
	switch m.GetInterfaceChoice().(type) {
	case *GetSpecType_DedicatedInterface:

		return nil, nil

	case *GetSpecType_EthernetInterface:

		drInfos, err := m.GetEthernetInterface().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetEthernetInterface().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "ethernet_interface." + dri.DRField
		}
		return drInfos, err

	case *GetSpecType_TunnelInterface:

		drInfos, err := m.GetTunnelInterface().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetTunnelInterface().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "tunnel_interface." + dri.DRField
		}
		return drInfos, err

	case *GetSpecType_LegacyInterface:

		drInfos, err := m.GetLegacyInterface().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetLegacyInterface().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "legacy_interface." + dri.DRField
		}
		return drInfos, err

	case *GetSpecType_DedicatedManagementInterface:

		return nil, nil

	case *GetSpecType_Layer2Interface:

		return nil, nil

	default:
		return nil, nil
	}

}

func (m *GetSpecType) GetParentNetworkInterfaceDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetParentNetworkInterface()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.parent_network_interface[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "network_interface.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "parent_network_interface",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetParentNetworkInterfaceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetParentNetworkInterfaceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "network_interface.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: network_interface")
	}
	for _, ref := range m.GetParentNetworkInterface() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GetSpecType) GetTunnelDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTunnel() == nil {
		return nil, nil
	}

	drInfos, err := m.GetTunnel().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetTunnel().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "tunnel." + dri.DRField
	}
	return drInfos, err

}

func (m *GetSpecType) GetVirtualNetworkDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetVirtualNetwork()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.virtual_network[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "virtual_network",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetVirtualNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetVirtualNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}
	for _, ref := range m.GetVirtualNetwork() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) InterfaceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for interface_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) TypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(NetworkInterfaceType)
		return int32(i)
	}
	// NetworkInterfaceType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, NetworkInterfaceType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for type")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) MtuValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mtu")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) VirtualNetworkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for virtual_network")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for virtual_network")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated virtual_network")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items virtual_network")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) DhcpAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(NetworkInterfaceDHCP)
		return int32(i)
	}
	// NetworkInterfaceDHCP_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, NetworkInterfaceDHCP_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dhcp_address")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) StaticAddressesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for static_addresses")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.Ipv4SubnetType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.Ipv4SubnetTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for static_addresses")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.Ipv4SubnetType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.Ipv4SubnetType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated static_addresses")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items static_addresses")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) DHCPServerValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(NetworkInterfaceDHCPServer)
		return int32(i)
	}
	// NetworkInterfaceDHCPServer_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, NetworkInterfaceDHCPServer_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for DHCP_server")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) DeviceNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for device_name")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) ParentNetworkInterfaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for parent_network_interface")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for parent_network_interface")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated parent_network_interface")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items parent_network_interface")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) VlanTagValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vlan_tag")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) PriorityValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for priority")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) AddressAllocatorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for address_allocator")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for address_allocator")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated address_allocator")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items address_allocator")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) InterfaceIpMapValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for interface_ip_map")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for interface_ip_map")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for interface_ip_map")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map interface_ip_map")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items interface_ip_map")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["DHCP_server"]; exists {

		vOpts := append(opts, db.WithValidateField("DHCP_server"))
		if err := fv(ctx, m.GetDHCPServer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["DNS_server"]; exists {

		vOpts := append(opts, db.WithValidateField("DNS_server"))
		if err := fv(ctx, m.GetDNSServer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["address_allocator"]; exists {
		vOpts := append(opts, db.WithValidateField("address_allocator"))
		if err := fv(ctx, m.GetAddressAllocator(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_gateway"]; exists {

		vOpts := append(opts, db.WithValidateField("default_gateway"))
		if err := fv(ctx, m.GetDefaultGateway(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["device_name"]; exists {

		vOpts := append(opts, db.WithValidateField("device_name"))
		if err := fv(ctx, m.GetDeviceName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dhcp_address"]; exists {

		vOpts := append(opts, db.WithValidateField("dhcp_address"))
		if err := fv(ctx, m.GetDhcpAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["interface_choice"]; exists {
		val := m.GetInterfaceChoice()
		vOpts := append(opts,
			db.WithValidateField("interface_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetInterfaceChoice().(type) {
	case *GetSpecType_DedicatedInterface:
		if fv, exists := v.FldValidators["interface_choice.dedicated_interface"]; exists {
			val := m.GetInterfaceChoice().(*GetSpecType_DedicatedInterface).DedicatedInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("dedicated_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_EthernetInterface:
		if fv, exists := v.FldValidators["interface_choice.ethernet_interface"]; exists {
			val := m.GetInterfaceChoice().(*GetSpecType_EthernetInterface).EthernetInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("ethernet_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_TunnelInterface:
		if fv, exists := v.FldValidators["interface_choice.tunnel_interface"]; exists {
			val := m.GetInterfaceChoice().(*GetSpecType_TunnelInterface).TunnelInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("tunnel_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_LegacyInterface:
		if fv, exists := v.FldValidators["interface_choice.legacy_interface"]; exists {
			val := m.GetInterfaceChoice().(*GetSpecType_LegacyInterface).LegacyInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("legacy_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_DedicatedManagementInterface:
		if fv, exists := v.FldValidators["interface_choice.dedicated_management_interface"]; exists {
			val := m.GetInterfaceChoice().(*GetSpecType_DedicatedManagementInterface).DedicatedManagementInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("dedicated_management_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Layer2Interface:
		if fv, exists := v.FldValidators["interface_choice.layer2_interface"]; exists {
			val := m.GetInterfaceChoice().(*GetSpecType_Layer2Interface).Layer2Interface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("layer2_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["interface_ip_map"]; exists {
		vOpts := append(opts, db.WithValidateField("interface_ip_map"))
		if err := fv(ctx, m.GetInterfaceIpMap(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["is_primary"]; exists {

		vOpts := append(opts, db.WithValidateField("is_primary"))
		if err := fv(ctx, m.GetIsPrimary(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetMonitoringChoice().(type) {
	case *GetSpecType_MonitorDisabled:
		if fv, exists := v.FldValidators["monitoring_choice.monitor_disabled"]; exists {
			val := m.GetMonitoringChoice().(*GetSpecType_MonitorDisabled).MonitorDisabled
			vOpts := append(opts,
				db.WithValidateField("monitoring_choice"),
				db.WithValidateField("monitor_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Monitor:
		if fv, exists := v.FldValidators["monitoring_choice.monitor"]; exists {
			val := m.GetMonitoringChoice().(*GetSpecType_Monitor).Monitor
			vOpts := append(opts,
				db.WithValidateField("monitoring_choice"),
				db.WithValidateField("monitor"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["mtu"]; exists {

		vOpts := append(opts, db.WithValidateField("mtu"))
		if err := fv(ctx, m.GetMtu(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["parent_network_interface"]; exists {
		vOpts := append(opts, db.WithValidateField("parent_network_interface"))
		if err := fv(ctx, m.GetParentNetworkInterface(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["priority"]; exists {

		vOpts := append(opts, db.WithValidateField("priority"))
		if err := fv(ctx, m.GetPriority(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["static_addresses"]; exists {
		vOpts := append(opts, db.WithValidateField("static_addresses"))
		if err := fv(ctx, m.GetStaticAddresses(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel"))
		if err := fv(ctx, m.GetTunnel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["virtual_network"]; exists {
		vOpts := append(opts, db.WithValidateField("virtual_network"))
		if err := fv(ctx, m.GetVirtualNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vlan_tag"]; exists {

		vOpts := append(opts, db.WithValidateField("vlan_tag"))
		if err := fv(ctx, m.GetVlanTag(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vlan_tagging"]; exists {

		vOpts := append(opts, db.WithValidateField("vlan_tagging"))
		if err := fv(ctx, m.GetVlanTagging(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInterfaceChoice := v.InterfaceChoiceValidationRuleHandler
	rulesInterfaceChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhInterfaceChoice(rulesInterfaceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.interface_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface_choice"] = vFn

	vrhType := v.TypeValidationRuleHandler
	rulesType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhType(rulesType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["type"] = vFn

	vrhMtu := v.MtuValidationRuleHandler
	rulesMtu := map[string]string{
		"ves.io.schema.rules.uint32.ranges": "0,512-16384",
	}
	vFn, err = vrhMtu(rulesMtu)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.mtu: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mtu"] = vFn

	vrhVirtualNetwork := v.VirtualNetworkValidationRuleHandler
	rulesVirtualNetwork := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhVirtualNetwork(rulesVirtualNetwork)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.virtual_network: %s", err)
		panic(errMsg)
	}
	v.FldValidators["virtual_network"] = vFn

	vrhDhcpAddress := v.DhcpAddressValidationRuleHandler
	rulesDhcpAddress := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDhcpAddress(rulesDhcpAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.dhcp_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dhcp_address"] = vFn

	vrhStaticAddresses := v.StaticAddressesValidationRuleHandler
	rulesStaticAddresses := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhStaticAddresses(rulesStaticAddresses)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.static_addresses: %s", err)
		panic(errMsg)
	}
	v.FldValidators["static_addresses"] = vFn

	vrhDHCPServer := v.DHCPServerValidationRuleHandler
	rulesDHCPServer := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDHCPServer(rulesDHCPServer)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.DHCP_server: %s", err)
		panic(errMsg)
	}
	v.FldValidators["DHCP_server"] = vFn

	vrhDeviceName := v.DeviceNameValidationRuleHandler
	rulesDeviceName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDeviceName(rulesDeviceName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.device_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["device_name"] = vFn

	vrhParentNetworkInterface := v.ParentNetworkInterfaceValidationRuleHandler
	rulesParentNetworkInterface := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhParentNetworkInterface(rulesParentNetworkInterface)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.parent_network_interface: %s", err)
		panic(errMsg)
	}
	v.FldValidators["parent_network_interface"] = vFn

	vrhVlanTag := v.VlanTagValidationRuleHandler
	rulesVlanTag := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "4094",
	}
	vFn, err = vrhVlanTag(rulesVlanTag)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.vlan_tag: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vlan_tag"] = vFn

	vrhPriority := v.PriorityValidationRuleHandler
	rulesPriority := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "255",
	}
	vFn, err = vrhPriority(rulesPriority)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.priority: %s", err)
		panic(errMsg)
	}
	v.FldValidators["priority"] = vFn

	vrhAddressAllocator := v.AddressAllocatorValidationRuleHandler
	rulesAddressAllocator := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhAddressAllocator(rulesAddressAllocator)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.address_allocator: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address_allocator"] = vFn

	vrhInterfaceIpMap := v.InterfaceIpMapValidationRuleHandler
	rulesInterfaceIpMap := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len": "128",
		"ves.io.schema.rules.map.keys.string.min_len": "1",
		"ves.io.schema.rules.map.max_pairs":           "64",
		"ves.io.schema.rules.map.values.string.ipv4":  "true",
	}
	vFn, err = vrhInterfaceIpMap(rulesInterfaceIpMap)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.interface_ip_map: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface_ip_map"] = vFn

	v.FldValidators["interface_choice.dedicated_interface"] = DedicatedInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.ethernet_interface"] = EthernetInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.tunnel_interface"] = TunnelInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.legacy_interface"] = LegacyInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.dedicated_management_interface"] = DedicatedManagementInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.layer2_interface"] = Layer2InterfaceTypeValidator().Validate

	v.FldValidators["default_gateway"] = NetworkInterfaceDFGWValidator().Validate

	v.FldValidators["DNS_server"] = NetworkInterfaceDNSValidator().Validate

	v.FldValidators["tunnel"] = NetworkInterfaceTunnelValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAddressAllocatorDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAddressAllocatorDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetDhcpServerParamsDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetDhcpServerParamsDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetInterfaceChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetInterfaceChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetIpv4StaticAddressesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetIpv4StaticAddressesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetIpv6AutoConfigDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetIpv6AutoConfigDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetIpv6StaticAddressesDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetIpv6StaticAddressesDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetParentNetworkInterfaceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetParentNetworkInterfaceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTunnelDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTunnelDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetVirtualNetworkDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetVirtualNetworkDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *GlobalSpecType) GetAddressAllocatorDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetAddressAllocator()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.address_allocator[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "address_allocator.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "address_allocator",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetAddressAllocatorDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetAddressAllocatorDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "address_allocator.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: address_allocator")
	}
	for _, ref := range m.GetAddressAllocator() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetDhcpServerParamsDRefInfo() ([]db.DRefInfo, error) {
	if m.GetDhcpServerParams() == nil {
		return nil, nil
	}

	drInfos, err := m.GetDhcpServerParams().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetDhcpServerParams().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "dhcp_server_params." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetInterfaceChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetInterfaceChoice() == nil {
		return nil, nil
	}
	switch m.GetInterfaceChoice().(type) {
	case *GlobalSpecType_DedicatedInterface:

		return nil, nil

	case *GlobalSpecType_EthernetInterface:

		drInfos, err := m.GetEthernetInterface().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetEthernetInterface().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "ethernet_interface." + dri.DRField
		}
		return drInfos, err

	case *GlobalSpecType_TunnelInterface:

		drInfos, err := m.GetTunnelInterface().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetTunnelInterface().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "tunnel_interface." + dri.DRField
		}
		return drInfos, err

	case *GlobalSpecType_Legacy:

		return nil, nil

	case *GlobalSpecType_DedicatedManagementInterface:

		return nil, nil

	case *GlobalSpecType_LoopbackInterface:

		drInfos, err := m.GetLoopbackInterface().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetLoopbackInterface().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "loopback_interface." + dri.DRField
		}
		return drInfos, err

	case *GlobalSpecType_Layer2Interface:

		return nil, nil

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetIpv4StaticAddressesDRefInfo() ([]db.DRefInfo, error) {
	if m.GetIpv4StaticAddresses() == nil {
		return nil, nil
	}

	drInfos, err := m.GetIpv4StaticAddresses().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetIpv4StaticAddresses().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "ipv4_static_addresses." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetIpv6AutoConfigDRefInfo() ([]db.DRefInfo, error) {
	if m.GetIpv6AutoConfig() == nil {
		return nil, nil
	}

	drInfos, err := m.GetIpv6AutoConfig().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetIpv6AutoConfig().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "ipv6_auto_config." + dri.DRField
	}
	return drInfos, err

}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetIpv6StaticAddressesDRefInfo() ([]db.DRefInfo, error) {
	if m.GetIpv6StaticAddresses() == nil {
		return nil, nil
	}

	drInfos, err := m.GetIpv6StaticAddresses().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetIpv6StaticAddresses().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "ipv6_static_addresses." + dri.DRField
	}
	return drInfos, err

}

func (m *GlobalSpecType) GetParentNetworkInterfaceDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetParentNetworkInterface()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.parent_network_interface[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "network_interface.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "parent_network_interface",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetParentNetworkInterfaceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetParentNetworkInterfaceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "network_interface.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: network_interface")
	}
	for _, ref := range m.GetParentNetworkInterface() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *GlobalSpecType) GetTunnelDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTunnel() == nil {
		return nil, nil
	}

	drInfos, err := m.GetTunnel().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetTunnel().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "tunnel." + dri.DRField
	}
	return drInfos, err

}

func (m *GlobalSpecType) GetVirtualNetworkDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetVirtualNetwork()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.virtual_network[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "virtual_network",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetVirtualNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetVirtualNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}
	for _, ref := range m.GetVirtualNetwork() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) InterfaceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for interface_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) TypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(NetworkInterfaceType)
		return int32(i)
	}
	// NetworkInterfaceType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, NetworkInterfaceType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for type")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) MtuValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mtu")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) VirtualNetworkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for virtual_network")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for virtual_network")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated virtual_network")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items virtual_network")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) DhcpAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(NetworkInterfaceDHCP)
		return int32(i)
	}
	// NetworkInterfaceDHCP_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, NetworkInterfaceDHCP_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dhcp_address")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) StaticAddressesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for static_addresses")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.Ipv4SubnetType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.Ipv4SubnetTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for static_addresses")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.Ipv4SubnetType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.Ipv4SubnetType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated static_addresses")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items static_addresses")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) DHCPServerValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(NetworkInterfaceDHCPServer)
		return int32(i)
	}
	// NetworkInterfaceDHCPServer_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, NetworkInterfaceDHCPServer_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for DHCP_server")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) DeviceNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for device_name")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ParentNetworkInterfaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for parent_network_interface")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for parent_network_interface")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated parent_network_interface")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items parent_network_interface")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) VlanTagValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vlan_tag")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) PriorityValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for priority")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) AddressAllocatorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for address_allocator")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for address_allocator")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated address_allocator")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items address_allocator")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) InterfaceIpMapValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for interface_ip_map")
	}
	itemValRules := db.GetMapStringValueRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemValRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item value ValidationRuleHandler for interface_ip_map")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]string, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := itemValFn(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for interface_ip_map")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]string)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]string, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map interface_ip_map")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items interface_ip_map")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) StaticIpv6AddressesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for static_ipv6_addresses")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.Ipv6SubnetType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.Ipv6SubnetTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for static_ipv6_addresses")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.Ipv6SubnetType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.Ipv6SubnetType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated static_ipv6_addresses")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items static_ipv6_addresses")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["DHCP_server"]; exists {

		vOpts := append(opts, db.WithValidateField("DHCP_server"))
		if err := fv(ctx, m.GetDHCPServer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["DNS_server"]; exists {

		vOpts := append(opts, db.WithValidateField("DNS_server"))
		if err := fv(ctx, m.GetDNSServer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["address_allocator"]; exists {
		vOpts := append(opts, db.WithValidateField("address_allocator"))
		if err := fv(ctx, m.GetAddressAllocator(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_gateway"]; exists {

		vOpts := append(opts, db.WithValidateField("default_gateway"))
		if err := fv(ctx, m.GetDefaultGateway(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["device_name"]; exists {

		vOpts := append(opts, db.WithValidateField("device_name"))
		if err := fv(ctx, m.GetDeviceName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dhcp_address"]; exists {

		vOpts := append(opts, db.WithValidateField("dhcp_address"))
		if err := fv(ctx, m.GetDhcpAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dhcp_server_params"]; exists {

		vOpts := append(opts, db.WithValidateField("dhcp_server_params"))
		if err := fv(ctx, m.GetDhcpServerParams(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["interface_choice"]; exists {
		val := m.GetInterfaceChoice()
		vOpts := append(opts,
			db.WithValidateField("interface_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetInterfaceChoice().(type) {
	case *GlobalSpecType_DedicatedInterface:
		if fv, exists := v.FldValidators["interface_choice.dedicated_interface"]; exists {
			val := m.GetInterfaceChoice().(*GlobalSpecType_DedicatedInterface).DedicatedInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("dedicated_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_EthernetInterface:
		if fv, exists := v.FldValidators["interface_choice.ethernet_interface"]; exists {
			val := m.GetInterfaceChoice().(*GlobalSpecType_EthernetInterface).EthernetInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("ethernet_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_TunnelInterface:
		if fv, exists := v.FldValidators["interface_choice.tunnel_interface"]; exists {
			val := m.GetInterfaceChoice().(*GlobalSpecType_TunnelInterface).TunnelInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("tunnel_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Legacy:
		if fv, exists := v.FldValidators["interface_choice.legacy"]; exists {
			val := m.GetInterfaceChoice().(*GlobalSpecType_Legacy).Legacy
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("legacy"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_DedicatedManagementInterface:
		if fv, exists := v.FldValidators["interface_choice.dedicated_management_interface"]; exists {
			val := m.GetInterfaceChoice().(*GlobalSpecType_DedicatedManagementInterface).DedicatedManagementInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("dedicated_management_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_LoopbackInterface:
		if fv, exists := v.FldValidators["interface_choice.loopback_interface"]; exists {
			val := m.GetInterfaceChoice().(*GlobalSpecType_LoopbackInterface).LoopbackInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("loopback_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Layer2Interface:
		if fv, exists := v.FldValidators["interface_choice.layer2_interface"]; exists {
			val := m.GetInterfaceChoice().(*GlobalSpecType_Layer2Interface).Layer2Interface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("layer2_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["interface_ip_map"]; exists {
		vOpts := append(opts, db.WithValidateField("interface_ip_map"))
		if err := fv(ctx, m.GetInterfaceIpMap(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ipv4_static_addresses"]; exists {

		vOpts := append(opts, db.WithValidateField("ipv4_static_addresses"))
		if err := fv(ctx, m.GetIpv4StaticAddresses(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ipv6_auto_config"]; exists {

		vOpts := append(opts, db.WithValidateField("ipv6_auto_config"))
		if err := fv(ctx, m.GetIpv6AutoConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ipv6_static_addresses"]; exists {

		vOpts := append(opts, db.WithValidateField("ipv6_static_addresses"))
		if err := fv(ctx, m.GetIpv6StaticAddresses(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["is_primary"]; exists {

		vOpts := append(opts, db.WithValidateField("is_primary"))
		if err := fv(ctx, m.GetIsPrimary(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetMonitoringChoice().(type) {
	case *GlobalSpecType_MonitorDisabled:
		if fv, exists := v.FldValidators["monitoring_choice.monitor_disabled"]; exists {
			val := m.GetMonitoringChoice().(*GlobalSpecType_MonitorDisabled).MonitorDisabled
			vOpts := append(opts,
				db.WithValidateField("monitoring_choice"),
				db.WithValidateField("monitor_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Monitor:
		if fv, exists := v.FldValidators["monitoring_choice.monitor"]; exists {
			val := m.GetMonitoringChoice().(*GlobalSpecType_Monitor).Monitor
			vOpts := append(opts,
				db.WithValidateField("monitoring_choice"),
				db.WithValidateField("monitor"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["mtu"]; exists {

		vOpts := append(opts, db.WithValidateField("mtu"))
		if err := fv(ctx, m.GetMtu(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_config"]; exists {

		vOpts := append(opts, db.WithValidateField("network_config"))
		if err := fv(ctx, m.GetNetworkConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["parent_network_interface"]; exists {
		vOpts := append(opts, db.WithValidateField("parent_network_interface"))
		if err := fv(ctx, m.GetParentNetworkInterface(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["priority"]; exists {

		vOpts := append(opts, db.WithValidateField("priority"))
		if err := fv(ctx, m.GetPriority(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetSegmentMultiplexing().(type) {
	case *GlobalSpecType_SegmentationDisabled:
		if fv, exists := v.FldValidators["segment_multiplexing.segmentation_disabled"]; exists {
			val := m.GetSegmentMultiplexing().(*GlobalSpecType_SegmentationDisabled).SegmentationDisabled
			vOpts := append(opts,
				db.WithValidateField("segment_multiplexing"),
				db.WithValidateField("segmentation_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_SegmentationEnabled:
		if fv, exists := v.FldValidators["segment_multiplexing.segmentation_enabled"]; exists {
			val := m.GetSegmentMultiplexing().(*GlobalSpecType_SegmentationEnabled).SegmentationEnabled
			vOpts := append(opts,
				db.WithValidateField("segment_multiplexing"),
				db.WithValidateField("segmentation_enabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["static_addresses"]; exists {
		vOpts := append(opts, db.WithValidateField("static_addresses"))
		if err := fv(ctx, m.GetStaticAddresses(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["static_ipv6_addresses"]; exists {
		vOpts := append(opts, db.WithValidateField("static_ipv6_addresses"))
		if err := fv(ctx, m.GetStaticIpv6Addresses(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel"))
		if err := fv(ctx, m.GetTunnel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vhost_type"]; exists {

		vOpts := append(opts, db.WithValidateField("vhost_type"))
		if err := fv(ctx, m.GetVhostType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["virtual_network"]; exists {
		vOpts := append(opts, db.WithValidateField("virtual_network"))
		if err := fv(ctx, m.GetVirtualNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vlan_tag"]; exists {

		vOpts := append(opts, db.WithValidateField("vlan_tag"))
		if err := fv(ctx, m.GetVlanTag(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vlan_tagging"]; exists {

		vOpts := append(opts, db.WithValidateField("vlan_tagging"))
		if err := fv(ctx, m.GetVlanTagging(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInterfaceChoice := v.InterfaceChoiceValidationRuleHandler
	rulesInterfaceChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhInterfaceChoice(rulesInterfaceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.interface_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface_choice"] = vFn

	vrhType := v.TypeValidationRuleHandler
	rulesType := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhType(rulesType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["type"] = vFn

	vrhMtu := v.MtuValidationRuleHandler
	rulesMtu := map[string]string{
		"ves.io.schema.rules.uint32.ranges": "0,512-16384",
	}
	vFn, err = vrhMtu(rulesMtu)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.mtu: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mtu"] = vFn

	vrhVirtualNetwork := v.VirtualNetworkValidationRuleHandler
	rulesVirtualNetwork := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhVirtualNetwork(rulesVirtualNetwork)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.virtual_network: %s", err)
		panic(errMsg)
	}
	v.FldValidators["virtual_network"] = vFn

	vrhDhcpAddress := v.DhcpAddressValidationRuleHandler
	rulesDhcpAddress := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDhcpAddress(rulesDhcpAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.dhcp_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dhcp_address"] = vFn

	vrhStaticAddresses := v.StaticAddressesValidationRuleHandler
	rulesStaticAddresses := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhStaticAddresses(rulesStaticAddresses)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.static_addresses: %s", err)
		panic(errMsg)
	}
	v.FldValidators["static_addresses"] = vFn

	vrhDHCPServer := v.DHCPServerValidationRuleHandler
	rulesDHCPServer := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDHCPServer(rulesDHCPServer)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.DHCP_server: %s", err)
		panic(errMsg)
	}
	v.FldValidators["DHCP_server"] = vFn

	vrhDeviceName := v.DeviceNameValidationRuleHandler
	rulesDeviceName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDeviceName(rulesDeviceName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.device_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["device_name"] = vFn

	vrhParentNetworkInterface := v.ParentNetworkInterfaceValidationRuleHandler
	rulesParentNetworkInterface := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhParentNetworkInterface(rulesParentNetworkInterface)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.parent_network_interface: %s", err)
		panic(errMsg)
	}
	v.FldValidators["parent_network_interface"] = vFn

	vrhVlanTag := v.VlanTagValidationRuleHandler
	rulesVlanTag := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "4094",
	}
	vFn, err = vrhVlanTag(rulesVlanTag)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.vlan_tag: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vlan_tag"] = vFn

	vrhPriority := v.PriorityValidationRuleHandler
	rulesPriority := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "255",
	}
	vFn, err = vrhPriority(rulesPriority)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.priority: %s", err)
		panic(errMsg)
	}
	v.FldValidators["priority"] = vFn

	vrhAddressAllocator := v.AddressAllocatorValidationRuleHandler
	rulesAddressAllocator := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhAddressAllocator(rulesAddressAllocator)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.address_allocator: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address_allocator"] = vFn

	vrhInterfaceIpMap := v.InterfaceIpMapValidationRuleHandler
	rulesInterfaceIpMap := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len": "128",
		"ves.io.schema.rules.map.keys.string.min_len": "1",
		"ves.io.schema.rules.map.max_pairs":           "64",
		"ves.io.schema.rules.map.values.string.ipv4":  "true",
	}
	vFn, err = vrhInterfaceIpMap(rulesInterfaceIpMap)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.interface_ip_map: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface_ip_map"] = vFn

	vrhStaticIpv6Addresses := v.StaticIpv6AddressesValidationRuleHandler
	rulesStaticIpv6Addresses := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhStaticIpv6Addresses(rulesStaticIpv6Addresses)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.static_ipv6_addresses: %s", err)
		panic(errMsg)
	}
	v.FldValidators["static_ipv6_addresses"] = vFn

	v.FldValidators["interface_choice.dedicated_interface"] = DedicatedInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.ethernet_interface"] = EthernetInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.tunnel_interface"] = TunnelInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.dedicated_management_interface"] = DedicatedManagementInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.loopback_interface"] = LoopbackInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.layer2_interface"] = Layer2InterfaceTypeValidator().Validate

	v.FldValidators["default_gateway"] = NetworkInterfaceDFGWValidator().Validate

	v.FldValidators["DNS_server"] = NetworkInterfaceDNSValidator().Validate

	v.FldValidators["tunnel"] = NetworkInterfaceTunnelValidator().Validate

	v.FldValidators["dhcp_server_params"] = DHCPServerParametersTypeValidator().Validate

	v.FldValidators["ipv6_static_addresses"] = StaticIPParametersTypeValidator().Validate

	v.FldValidators["vhost_type"] = VhostInterfaceTypeValidator().Validate

	v.FldValidators["ipv4_static_addresses"] = StaticIPParametersTypeValidator().Validate

	v.FldValidators["ipv6_auto_config"] = IPV6AutoConfigTypeValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *IPV6AutoConfigRouterType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IPV6AutoConfigRouterType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IPV6AutoConfigRouterType) DeepCopy() *IPV6AutoConfigRouterType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IPV6AutoConfigRouterType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IPV6AutoConfigRouterType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IPV6AutoConfigRouterType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IPV6AutoConfigRouterTypeValidator().Validate(ctx, m, opts...)
}

func (m *IPV6AutoConfigRouterType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetAddressChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *IPV6AutoConfigRouterType) GetAddressChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAddressChoice() == nil {
		return nil, nil
	}
	switch m.GetAddressChoice().(type) {
	case *IPV6AutoConfigRouterType_Stateful:

		drInfos, err := m.GetStateful().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetStateful().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "stateful." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateIPV6AutoConfigRouterType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIPV6AutoConfigRouterType) AddressChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address_choice")
	}
	return validatorFn, nil
}

func (v *ValidateIPV6AutoConfigRouterType) AddressChoiceNetworkPrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_NetworkPrefix, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network_prefix")
	}
	return oValidatorFn_NetworkPrefix, nil
}

func (v *ValidateIPV6AutoConfigRouterType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IPV6AutoConfigRouterType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IPV6AutoConfigRouterType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address_choice"]; exists {
		val := m.GetAddressChoice()
		vOpts := append(opts,
			db.WithValidateField("address_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAddressChoice().(type) {
	case *IPV6AutoConfigRouterType_NetworkPrefix:
		if fv, exists := v.FldValidators["address_choice.network_prefix"]; exists {
			val := m.GetAddressChoice().(*IPV6AutoConfigRouterType_NetworkPrefix).NetworkPrefix
			vOpts := append(opts,
				db.WithValidateField("address_choice"),
				db.WithValidateField("network_prefix"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *IPV6AutoConfigRouterType_Stateful:
		if fv, exists := v.FldValidators["address_choice.stateful"]; exists {
			val := m.GetAddressChoice().(*IPV6AutoConfigRouterType_Stateful).Stateful
			vOpts := append(opts,
				db.WithValidateField("address_choice"),
				db.WithValidateField("stateful"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["dns_config"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_config"))
		if err := fv(ctx, m.GetDnsConfig(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIPV6AutoConfigRouterTypeValidator = func() *ValidateIPV6AutoConfigRouterType {
	v := &ValidateIPV6AutoConfigRouterType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAddressChoice := v.AddressChoiceValidationRuleHandler
	rulesAddressChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAddressChoice(rulesAddressChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IPV6AutoConfigRouterType.address_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address_choice"] = vFn

	vrhAddressChoiceNetworkPrefix := v.AddressChoiceNetworkPrefixValidationRuleHandler
	rulesAddressChoiceNetworkPrefix := map[string]string{
		"ves.io.schema.rules.string.ipv6_prefix": "true",
	}
	vFnMap["address_choice.network_prefix"], err = vrhAddressChoiceNetworkPrefix(rulesAddressChoiceNetworkPrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field IPV6AutoConfigRouterType.address_choice_network_prefix: %s", err)
		panic(errMsg)
	}

	v.FldValidators["address_choice.network_prefix"] = vFnMap["address_choice.network_prefix"]

	v.FldValidators["address_choice.stateful"] = DHCPIPV6StatefulServerValidator().Validate

	v.FldValidators["dns_config"] = IPV6DnsConfigValidator().Validate

	return v
}()

func IPV6AutoConfigRouterTypeValidator() db.Validator {
	return DefaultIPV6AutoConfigRouterTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *IPV6AutoConfigType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IPV6AutoConfigType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IPV6AutoConfigType) DeepCopy() *IPV6AutoConfigType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IPV6AutoConfigType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IPV6AutoConfigType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IPV6AutoConfigType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IPV6AutoConfigTypeValidator().Validate(ctx, m, opts...)
}

func (m *IPV6AutoConfigType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetAutoconfigChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *IPV6AutoConfigType) GetAutoconfigChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAutoconfigChoice() == nil {
		return nil, nil
	}
	switch m.GetAutoconfigChoice().(type) {
	case *IPV6AutoConfigType_Host:

		return nil, nil

	case *IPV6AutoConfigType_Router:

		drInfos, err := m.GetRouter().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetRouter().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "router." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateIPV6AutoConfigType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIPV6AutoConfigType) AutoconfigChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for autoconfig_choice")
	}
	return validatorFn, nil
}

func (v *ValidateIPV6AutoConfigType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IPV6AutoConfigType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IPV6AutoConfigType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["autoconfig_choice"]; exists {
		val := m.GetAutoconfigChoice()
		vOpts := append(opts,
			db.WithValidateField("autoconfig_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAutoconfigChoice().(type) {
	case *IPV6AutoConfigType_Host:
		if fv, exists := v.FldValidators["autoconfig_choice.host"]; exists {
			val := m.GetAutoconfigChoice().(*IPV6AutoConfigType_Host).Host
			vOpts := append(opts,
				db.WithValidateField("autoconfig_choice"),
				db.WithValidateField("host"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *IPV6AutoConfigType_Router:
		if fv, exists := v.FldValidators["autoconfig_choice.router"]; exists {
			val := m.GetAutoconfigChoice().(*IPV6AutoConfigType_Router).Router
			vOpts := append(opts,
				db.WithValidateField("autoconfig_choice"),
				db.WithValidateField("router"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIPV6AutoConfigTypeValidator = func() *ValidateIPV6AutoConfigType {
	v := &ValidateIPV6AutoConfigType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAutoconfigChoice := v.AutoconfigChoiceValidationRuleHandler
	rulesAutoconfigChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAutoconfigChoice(rulesAutoconfigChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IPV6AutoConfigType.autoconfig_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["autoconfig_choice"] = vFn

	v.FldValidators["autoconfig_choice.router"] = IPV6AutoConfigRouterTypeValidator().Validate

	return v
}()

func IPV6AutoConfigTypeValidator() db.Validator {
	return DefaultIPV6AutoConfigTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *IPV6DnsConfig) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IPV6DnsConfig) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IPV6DnsConfig) DeepCopy() *IPV6DnsConfig {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IPV6DnsConfig{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IPV6DnsConfig) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IPV6DnsConfig) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IPV6DnsConfigValidator().Validate(ctx, m, opts...)
}

type ValidateIPV6DnsConfig struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIPV6DnsConfig) DnsChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dns_choice")
	}
	return validatorFn, nil
}

func (v *ValidateIPV6DnsConfig) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IPV6DnsConfig)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IPV6DnsConfig got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dns_choice"]; exists {
		val := m.GetDnsChoice()
		vOpts := append(opts,
			db.WithValidateField("dns_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDnsChoice().(type) {
	case *IPV6DnsConfig_LocalDns:
		if fv, exists := v.FldValidators["dns_choice.local_dns"]; exists {
			val := m.GetDnsChoice().(*IPV6DnsConfig_LocalDns).LocalDns
			vOpts := append(opts,
				db.WithValidateField("dns_choice"),
				db.WithValidateField("local_dns"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *IPV6DnsConfig_ConfiguredList:
		if fv, exists := v.FldValidators["dns_choice.configured_list"]; exists {
			val := m.GetDnsChoice().(*IPV6DnsConfig_ConfiguredList).ConfiguredList
			vOpts := append(opts,
				db.WithValidateField("dns_choice"),
				db.WithValidateField("configured_list"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIPV6DnsConfigValidator = func() *ValidateIPV6DnsConfig {
	v := &ValidateIPV6DnsConfig{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDnsChoice := v.DnsChoiceValidationRuleHandler
	rulesDnsChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDnsChoice(rulesDnsChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IPV6DnsConfig.dns_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_choice"] = vFn

	v.FldValidators["dns_choice.local_dns"] = IPV6LocalDnsAddressValidator().Validate
	v.FldValidators["dns_choice.configured_list"] = IPV6DnsListValidator().Validate

	return v
}()

func IPV6DnsConfigValidator() db.Validator {
	return DefaultIPV6DnsConfigValidator
}

// augmented methods on protoc/std generated struct

func (m *IPV6DnsList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IPV6DnsList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IPV6DnsList) DeepCopy() *IPV6DnsList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IPV6DnsList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IPV6DnsList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IPV6DnsList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IPV6DnsListValidator().Validate(ctx, m, opts...)
}

type ValidateIPV6DnsList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIPV6DnsList) DnsListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for dns_list")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for dns_list")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated dns_list")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items dns_list")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateIPV6DnsList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IPV6DnsList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IPV6DnsList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dns_list"]; exists {
		vOpts := append(opts, db.WithValidateField("dns_list"))
		if err := fv(ctx, m.GetDnsList(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIPV6DnsListValidator = func() *ValidateIPV6DnsList {
	v := &ValidateIPV6DnsList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDnsList := v.DnsListValidationRuleHandler
	rulesDnsList := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "4",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
		"ves.io.schema.rules.string.ipv6":        "true",
	}
	vFn, err = vrhDnsList(rulesDnsList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IPV6DnsList.dns_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_list"] = vFn

	return v
}()

func IPV6DnsListValidator() db.Validator {
	return DefaultIPV6DnsListValidator
}

// augmented methods on protoc/std generated struct

func (m *IPV6LocalDnsAddress) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IPV6LocalDnsAddress) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IPV6LocalDnsAddress) DeepCopy() *IPV6LocalDnsAddress {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IPV6LocalDnsAddress{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IPV6LocalDnsAddress) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IPV6LocalDnsAddress) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IPV6LocalDnsAddressValidator().Validate(ctx, m, opts...)
}

type ValidateIPV6LocalDnsAddress struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIPV6LocalDnsAddress) LocalDnsChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for local_dns_choice")
	}
	return validatorFn, nil
}

func (v *ValidateIPV6LocalDnsAddress) LocalDnsChoiceConfiguredAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_ConfiguredAddress, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for configured_address")
	}
	return oValidatorFn_ConfiguredAddress, nil
}

func (v *ValidateIPV6LocalDnsAddress) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IPV6LocalDnsAddress)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IPV6LocalDnsAddress got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["local_dns_choice"]; exists {
		val := m.GetLocalDnsChoice()
		vOpts := append(opts,
			db.WithValidateField("local_dns_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLocalDnsChoice().(type) {
	case *IPV6LocalDnsAddress_FirstAddress:
		if fv, exists := v.FldValidators["local_dns_choice.first_address"]; exists {
			val := m.GetLocalDnsChoice().(*IPV6LocalDnsAddress_FirstAddress).FirstAddress
			vOpts := append(opts,
				db.WithValidateField("local_dns_choice"),
				db.WithValidateField("first_address"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *IPV6LocalDnsAddress_LastAddress:
		if fv, exists := v.FldValidators["local_dns_choice.last_address"]; exists {
			val := m.GetLocalDnsChoice().(*IPV6LocalDnsAddress_LastAddress).LastAddress
			vOpts := append(opts,
				db.WithValidateField("local_dns_choice"),
				db.WithValidateField("last_address"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *IPV6LocalDnsAddress_ConfiguredAddress:
		if fv, exists := v.FldValidators["local_dns_choice.configured_address"]; exists {
			val := m.GetLocalDnsChoice().(*IPV6LocalDnsAddress_ConfiguredAddress).ConfiguredAddress
			vOpts := append(opts,
				db.WithValidateField("local_dns_choice"),
				db.WithValidateField("configured_address"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIPV6LocalDnsAddressValidator = func() *ValidateIPV6LocalDnsAddress {
	v := &ValidateIPV6LocalDnsAddress{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhLocalDnsChoice := v.LocalDnsChoiceValidationRuleHandler
	rulesLocalDnsChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLocalDnsChoice(rulesLocalDnsChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IPV6LocalDnsAddress.local_dns_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["local_dns_choice"] = vFn

	vrhLocalDnsChoiceConfiguredAddress := v.LocalDnsChoiceConfiguredAddressValidationRuleHandler
	rulesLocalDnsChoiceConfiguredAddress := map[string]string{
		"ves.io.schema.rules.string.ipv6": "true",
	}
	vFnMap["local_dns_choice.configured_address"], err = vrhLocalDnsChoiceConfiguredAddress(rulesLocalDnsChoiceConfiguredAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field IPV6LocalDnsAddress.local_dns_choice_configured_address: %s", err)
		panic(errMsg)
	}

	v.FldValidators["local_dns_choice.configured_address"] = vFnMap["local_dns_choice.configured_address"]

	return v
}()

func IPV6LocalDnsAddressValidator() db.Validator {
	return DefaultIPV6LocalDnsAddressValidator
}

// augmented methods on protoc/std generated struct

func (m *Layer2InterfaceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Layer2InterfaceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Layer2InterfaceType) DeepCopy() *Layer2InterfaceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Layer2InterfaceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Layer2InterfaceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Layer2InterfaceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return Layer2InterfaceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateLayer2InterfaceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLayer2InterfaceType) Layer2InterfaceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for layer2_interface_choice")
	}
	return validatorFn, nil
}

func (v *ValidateLayer2InterfaceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Layer2InterfaceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Layer2InterfaceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["layer2_interface_choice"]; exists {
		val := m.GetLayer2InterfaceChoice()
		vOpts := append(opts,
			db.WithValidateField("layer2_interface_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetLayer2InterfaceChoice().(type) {
	case *Layer2InterfaceType_L2VlanInterface:
		if fv, exists := v.FldValidators["layer2_interface_choice.l2vlan_interface"]; exists {
			val := m.GetLayer2InterfaceChoice().(*Layer2InterfaceType_L2VlanInterface).L2VlanInterface
			vOpts := append(opts,
				db.WithValidateField("layer2_interface_choice"),
				db.WithValidateField("l2vlan_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Layer2InterfaceType_L2VlanSloInterface:
		if fv, exists := v.FldValidators["layer2_interface_choice.l2vlan_slo_interface"]; exists {
			val := m.GetLayer2InterfaceChoice().(*Layer2InterfaceType_L2VlanSloInterface).L2VlanSloInterface
			vOpts := append(opts,
				db.WithValidateField("layer2_interface_choice"),
				db.WithValidateField("l2vlan_slo_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Layer2InterfaceType_L2SriovInterface:
		if fv, exists := v.FldValidators["layer2_interface_choice.l2sriov_interface"]; exists {
			val := m.GetLayer2InterfaceChoice().(*Layer2InterfaceType_L2SriovInterface).L2SriovInterface
			vOpts := append(opts,
				db.WithValidateField("layer2_interface_choice"),
				db.WithValidateField("l2sriov_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLayer2InterfaceTypeValidator = func() *ValidateLayer2InterfaceType {
	v := &ValidateLayer2InterfaceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhLayer2InterfaceChoice := v.Layer2InterfaceChoiceValidationRuleHandler
	rulesLayer2InterfaceChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhLayer2InterfaceChoice(rulesLayer2InterfaceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Layer2InterfaceType.layer2_interface_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["layer2_interface_choice"] = vFn

	v.FldValidators["layer2_interface_choice.l2vlan_interface"] = Layer2VlanInterfaceTypeValidator().Validate
	v.FldValidators["layer2_interface_choice.l2vlan_slo_interface"] = Layer2SloVlanInterfaceTypeValidator().Validate
	v.FldValidators["layer2_interface_choice.l2sriov_interface"] = Layer2SriovInterfaceTypeValidator().Validate

	return v
}()

func Layer2InterfaceTypeValidator() db.Validator {
	return DefaultLayer2InterfaceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *Layer2SloVlanInterfaceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Layer2SloVlanInterfaceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Layer2SloVlanInterfaceType) DeepCopy() *Layer2SloVlanInterfaceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Layer2SloVlanInterfaceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Layer2SloVlanInterfaceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Layer2SloVlanInterfaceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return Layer2SloVlanInterfaceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateLayer2SloVlanInterfaceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLayer2SloVlanInterfaceType) VlanIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vlan_id")
	}

	return validatorFn, nil
}

func (v *ValidateLayer2SloVlanInterfaceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Layer2SloVlanInterfaceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Layer2SloVlanInterfaceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["vlan_id"]; exists {

		vOpts := append(opts, db.WithValidateField("vlan_id"))
		if err := fv(ctx, m.GetVlanId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLayer2SloVlanInterfaceTypeValidator = func() *ValidateLayer2SloVlanInterfaceType {
	v := &ValidateLayer2SloVlanInterfaceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhVlanId := v.VlanIdValidationRuleHandler
	rulesVlanId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "1",
		"ves.io.schema.rules.uint32.lte":       "4095",
	}
	vFn, err = vrhVlanId(rulesVlanId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Layer2SloVlanInterfaceType.vlan_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vlan_id"] = vFn

	return v
}()

func Layer2SloVlanInterfaceTypeValidator() db.Validator {
	return DefaultLayer2SloVlanInterfaceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *Layer2SriovInterfaceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Layer2SriovInterfaceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Layer2SriovInterfaceType) DeepCopy() *Layer2SriovInterfaceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Layer2SriovInterfaceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Layer2SriovInterfaceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Layer2SriovInterfaceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return Layer2SriovInterfaceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateLayer2SriovInterfaceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLayer2SriovInterfaceType) VlanChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vlan_choice")
	}
	return validatorFn, nil
}

func (v *ValidateLayer2SriovInterfaceType) VlanChoiceVlanIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_VlanId, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vlan_id")
	}
	return oValidatorFn_VlanId, nil
}

func (v *ValidateLayer2SriovInterfaceType) DeviceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for device")
	}

	return validatorFn, nil
}

func (v *ValidateLayer2SriovInterfaceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Layer2SriovInterfaceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Layer2SriovInterfaceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["device"]; exists {

		vOpts := append(opts, db.WithValidateField("device"))
		if err := fv(ctx, m.GetDevice(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vlan_choice"]; exists {
		val := m.GetVlanChoice()
		vOpts := append(opts,
			db.WithValidateField("vlan_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetVlanChoice().(type) {
	case *Layer2SriovInterfaceType_Untagged:
		if fv, exists := v.FldValidators["vlan_choice.untagged"]; exists {
			val := m.GetVlanChoice().(*Layer2SriovInterfaceType_Untagged).Untagged
			vOpts := append(opts,
				db.WithValidateField("vlan_choice"),
				db.WithValidateField("untagged"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *Layer2SriovInterfaceType_VlanId:
		if fv, exists := v.FldValidators["vlan_choice.vlan_id"]; exists {
			val := m.GetVlanChoice().(*Layer2SriovInterfaceType_VlanId).VlanId
			vOpts := append(opts,
				db.WithValidateField("vlan_choice"),
				db.WithValidateField("vlan_id"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLayer2SriovInterfaceTypeValidator = func() *ValidateLayer2SriovInterfaceType {
	v := &ValidateLayer2SriovInterfaceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhVlanChoice := v.VlanChoiceValidationRuleHandler
	rulesVlanChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhVlanChoice(rulesVlanChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Layer2SriovInterfaceType.vlan_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vlan_choice"] = vFn

	vrhVlanChoiceVlanId := v.VlanChoiceVlanIdValidationRuleHandler
	rulesVlanChoiceVlanId := map[string]string{
		"ves.io.schema.rules.uint32.gte": "1",
		"ves.io.schema.rules.uint32.lte": "4095",
	}
	vFnMap["vlan_choice.vlan_id"], err = vrhVlanChoiceVlanId(rulesVlanChoiceVlanId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field Layer2SriovInterfaceType.vlan_choice_vlan_id: %s", err)
		panic(errMsg)
	}

	v.FldValidators["vlan_choice.vlan_id"] = vFnMap["vlan_choice.vlan_id"]

	vrhDevice := v.DeviceValidationRuleHandler
	rulesDevice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhDevice(rulesDevice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Layer2SriovInterfaceType.device: %s", err)
		panic(errMsg)
	}
	v.FldValidators["device"] = vFn

	return v
}()

func Layer2SriovInterfaceTypeValidator() db.Validator {
	return DefaultLayer2SriovInterfaceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *Layer2VlanInterfaceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Layer2VlanInterfaceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Layer2VlanInterfaceType) DeepCopy() *Layer2VlanInterfaceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Layer2VlanInterfaceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Layer2VlanInterfaceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Layer2VlanInterfaceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return Layer2VlanInterfaceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateLayer2VlanInterfaceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLayer2VlanInterfaceType) DeviceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for device")
	}

	return validatorFn, nil
}

func (v *ValidateLayer2VlanInterfaceType) VlanIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vlan_id")
	}

	return validatorFn, nil
}

func (v *ValidateLayer2VlanInterfaceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Layer2VlanInterfaceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Layer2VlanInterfaceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["device"]; exists {

		vOpts := append(opts, db.WithValidateField("device"))
		if err := fv(ctx, m.GetDevice(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vlan_id"]; exists {

		vOpts := append(opts, db.WithValidateField("vlan_id"))
		if err := fv(ctx, m.GetVlanId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLayer2VlanInterfaceTypeValidator = func() *ValidateLayer2VlanInterfaceType {
	v := &ValidateLayer2VlanInterfaceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDevice := v.DeviceValidationRuleHandler
	rulesDevice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhDevice(rulesDevice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Layer2VlanInterfaceType.device: %s", err)
		panic(errMsg)
	}
	v.FldValidators["device"] = vFn

	vrhVlanId := v.VlanIdValidationRuleHandler
	rulesVlanId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "1",
		"ves.io.schema.rules.uint32.lte":       "4095",
	}
	vFn, err = vrhVlanId(rulesVlanId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Layer2VlanInterfaceType.vlan_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vlan_id"] = vFn

	return v
}()

func Layer2VlanInterfaceTypeValidator() db.Validator {
	return DefaultLayer2VlanInterfaceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *LegacyInterfaceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LegacyInterfaceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LegacyInterfaceType) DeepCopy() *LegacyInterfaceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LegacyInterfaceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LegacyInterfaceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LegacyInterfaceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LegacyInterfaceTypeValidator().Validate(ctx, m, opts...)
}

func (m *LegacyInterfaceType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAddressAllocatorDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAddressAllocatorDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTunnelDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTunnelDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetVirtualNetworkDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetVirtualNetworkDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *LegacyInterfaceType) GetAddressAllocatorDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetAddressAllocator()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("LegacyInterfaceType.address_allocator[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "address_allocator.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "address_allocator",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetAddressAllocatorDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *LegacyInterfaceType) GetAddressAllocatorDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "address_allocator.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: address_allocator")
	}
	for _, ref := range m.GetAddressAllocator() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *LegacyInterfaceType) GetTunnelDRefInfo() ([]db.DRefInfo, error) {
	if m.GetTunnel() == nil {
		return nil, nil
	}

	drInfos, err := m.GetTunnel().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetTunnel().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "tunnel." + dri.DRField
	}
	return drInfos, err

}

func (m *LegacyInterfaceType) GetVirtualNetworkDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetVirtualNetwork()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("LegacyInterfaceType.virtual_network[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "virtual_network",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetVirtualNetworkDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *LegacyInterfaceType) GetVirtualNetworkDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
	}
	for _, ref := range m.GetVirtualNetwork() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateLegacyInterfaceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLegacyInterfaceType) TypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(NetworkInterfaceType)
		return int32(i)
	}
	// NetworkInterfaceType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, NetworkInterfaceType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for type")
	}

	return validatorFn, nil
}

func (v *ValidateLegacyInterfaceType) MtuValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mtu")
	}

	return validatorFn, nil
}

func (v *ValidateLegacyInterfaceType) VirtualNetworkValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for virtual_network")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for virtual_network")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated virtual_network")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items virtual_network")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateLegacyInterfaceType) DhcpAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(NetworkInterfaceDHCP)
		return int32(i)
	}
	// NetworkInterfaceDHCP_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, NetworkInterfaceDHCP_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dhcp_address")
	}

	return validatorFn, nil
}

func (v *ValidateLegacyInterfaceType) DHCPServerValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(NetworkInterfaceDHCPServer)
		return int32(i)
	}
	// NetworkInterfaceDHCPServer_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, NetworkInterfaceDHCPServer_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for DHCP_server")
	}

	return validatorFn, nil
}

func (v *ValidateLegacyInterfaceType) DeviceNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for device_name")
	}

	return validatorFn, nil
}

func (v *ValidateLegacyInterfaceType) VlanTagValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for vlan_tag")
	}

	return validatorFn, nil
}

func (v *ValidateLegacyInterfaceType) PriorityValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for priority")
	}

	return validatorFn, nil
}

func (v *ValidateLegacyInterfaceType) AddressAllocatorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for address_allocator")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for address_allocator")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated address_allocator")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items address_allocator")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateLegacyInterfaceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LegacyInterfaceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LegacyInterfaceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["DHCP_server"]; exists {

		vOpts := append(opts, db.WithValidateField("DHCP_server"))
		if err := fv(ctx, m.GetDHCPServer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["DNS_server"]; exists {

		vOpts := append(opts, db.WithValidateField("DNS_server"))
		if err := fv(ctx, m.GetDNSServer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["address_allocator"]; exists {
		vOpts := append(opts, db.WithValidateField("address_allocator"))
		if err := fv(ctx, m.GetAddressAllocator(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_gateway"]; exists {

		vOpts := append(opts, db.WithValidateField("default_gateway"))
		if err := fv(ctx, m.GetDefaultGateway(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["device_name"]; exists {

		vOpts := append(opts, db.WithValidateField("device_name"))
		if err := fv(ctx, m.GetDeviceName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dhcp_address"]; exists {

		vOpts := append(opts, db.WithValidateField("dhcp_address"))
		if err := fv(ctx, m.GetDhcpAddress(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetMonitoringChoice().(type) {
	case *LegacyInterfaceType_MonitorDisabled:
		if fv, exists := v.FldValidators["monitoring_choice.monitor_disabled"]; exists {
			val := m.GetMonitoringChoice().(*LegacyInterfaceType_MonitorDisabled).MonitorDisabled
			vOpts := append(opts,
				db.WithValidateField("monitoring_choice"),
				db.WithValidateField("monitor_disabled"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *LegacyInterfaceType_Monitor:
		if fv, exists := v.FldValidators["monitoring_choice.monitor"]; exists {
			val := m.GetMonitoringChoice().(*LegacyInterfaceType_Monitor).Monitor
			vOpts := append(opts,
				db.WithValidateField("monitoring_choice"),
				db.WithValidateField("monitor"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["mtu"]; exists {

		vOpts := append(opts, db.WithValidateField("mtu"))
		if err := fv(ctx, m.GetMtu(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["priority"]; exists {

		vOpts := append(opts, db.WithValidateField("priority"))
		if err := fv(ctx, m.GetPriority(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["static_addresses"]; exists {

		vOpts := append(opts, db.WithValidateField("static_addresses"))
		for idx, item := range m.GetStaticAddresses() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tunnel"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel"))
		if err := fv(ctx, m.GetTunnel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["virtual_network"]; exists {
		vOpts := append(opts, db.WithValidateField("virtual_network"))
		if err := fv(ctx, m.GetVirtualNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vlan_tag"]; exists {

		vOpts := append(opts, db.WithValidateField("vlan_tag"))
		if err := fv(ctx, m.GetVlanTag(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vlan_tagging"]; exists {

		vOpts := append(opts, db.WithValidateField("vlan_tagging"))
		if err := fv(ctx, m.GetVlanTagging(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLegacyInterfaceTypeValidator = func() *ValidateLegacyInterfaceType {
	v := &ValidateLegacyInterfaceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhType := v.TypeValidationRuleHandler
	rulesType := map[string]string{
		"ves.io.schema.rules.enum.in":          "[0,1,3]",
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhType(rulesType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LegacyInterfaceType.type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["type"] = vFn

	vrhMtu := v.MtuValidationRuleHandler
	rulesMtu := map[string]string{
		"ves.io.schema.rules.uint32.ranges": "0,512-16384",
	}
	vFn, err = vrhMtu(rulesMtu)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LegacyInterfaceType.mtu: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mtu"] = vFn

	vrhVirtualNetwork := v.VirtualNetworkValidationRuleHandler
	rulesVirtualNetwork := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhVirtualNetwork(rulesVirtualNetwork)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LegacyInterfaceType.virtual_network: %s", err)
		panic(errMsg)
	}
	v.FldValidators["virtual_network"] = vFn

	vrhDhcpAddress := v.DhcpAddressValidationRuleHandler
	rulesDhcpAddress := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDhcpAddress(rulesDhcpAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LegacyInterfaceType.dhcp_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dhcp_address"] = vFn

	vrhDHCPServer := v.DHCPServerValidationRuleHandler
	rulesDHCPServer := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDHCPServer(rulesDHCPServer)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LegacyInterfaceType.DHCP_server: %s", err)
		panic(errMsg)
	}
	v.FldValidators["DHCP_server"] = vFn

	vrhDeviceName := v.DeviceNameValidationRuleHandler
	rulesDeviceName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDeviceName(rulesDeviceName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LegacyInterfaceType.device_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["device_name"] = vFn

	vrhVlanTag := v.VlanTagValidationRuleHandler
	rulesVlanTag := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "4094",
	}
	vFn, err = vrhVlanTag(rulesVlanTag)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LegacyInterfaceType.vlan_tag: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vlan_tag"] = vFn

	vrhPriority := v.PriorityValidationRuleHandler
	rulesPriority := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "255",
	}
	vFn, err = vrhPriority(rulesPriority)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LegacyInterfaceType.priority: %s", err)
		panic(errMsg)
	}
	v.FldValidators["priority"] = vFn

	vrhAddressAllocator := v.AddressAllocatorValidationRuleHandler
	rulesAddressAllocator := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhAddressAllocator(rulesAddressAllocator)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LegacyInterfaceType.address_allocator: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address_allocator"] = vFn

	v.FldValidators["static_addresses"] = ves_io_schema.Ipv4SubnetTypeValidator().Validate

	v.FldValidators["default_gateway"] = NetworkInterfaceDFGWValidator().Validate

	v.FldValidators["DNS_server"] = NetworkInterfaceDNSValidator().Validate

	v.FldValidators["tunnel"] = NetworkInterfaceTunnelValidator().Validate

	return v
}()

func LegacyInterfaceTypeValidator() db.Validator {
	return DefaultLegacyInterfaceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *LinkQualityMonitorConfig) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LinkQualityMonitorConfig) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LinkQualityMonitorConfig) DeepCopy() *LinkQualityMonitorConfig {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LinkQualityMonitorConfig{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LinkQualityMonitorConfig) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LinkQualityMonitorConfig) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LinkQualityMonitorConfigValidator().Validate(ctx, m, opts...)
}

type ValidateLinkQualityMonitorConfig struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLinkQualityMonitorConfig) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LinkQualityMonitorConfig)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LinkQualityMonitorConfig got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLinkQualityMonitorConfigValidator = func() *ValidateLinkQualityMonitorConfig {
	v := &ValidateLinkQualityMonitorConfig{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LinkQualityMonitorConfigValidator() db.Validator {
	return DefaultLinkQualityMonitorConfigValidator
}

// augmented methods on protoc/std generated struct

func (m *LoopbackInterfaceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LoopbackInterfaceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LoopbackInterfaceType) DeepCopy() *LoopbackInterfaceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LoopbackInterfaceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LoopbackInterfaceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LoopbackInterfaceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LoopbackInterfaceTypeValidator().Validate(ctx, m, opts...)
}

func (m *LoopbackInterfaceType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetAddressChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetAddressChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetIpv6AddressChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetIpv6AddressChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

// GetDRefInfo for the field's type
func (m *LoopbackInterfaceType) GetAddressChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetAddressChoice() == nil {
		return nil, nil
	}
	switch m.GetAddressChoice().(type) {
	case *LoopbackInterfaceType_DhcpClient:

		return nil, nil

	case *LoopbackInterfaceType_DhcpServer:

		drInfos, err := m.GetDhcpServer().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetDhcpServer().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "dhcp_server." + dri.DRField
		}
		return drInfos, err

	case *LoopbackInterfaceType_StaticIp:

		drInfos, err := m.GetStaticIp().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetStaticIp().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "static_ip." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

// GetDRefInfo for the field's type
func (m *LoopbackInterfaceType) GetIpv6AddressChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetIpv6AddressChoice() == nil {
		return nil, nil
	}
	switch m.GetIpv6AddressChoice().(type) {
	case *LoopbackInterfaceType_NoIpv6Address:

		return nil, nil

	case *LoopbackInterfaceType_StaticIpv6Address:

		drInfos, err := m.GetStaticIpv6Address().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetStaticIpv6Address().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "static_ipv6_address." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateLoopbackInterfaceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLoopbackInterfaceType) AddressChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address_choice")
	}
	return validatorFn, nil
}

func (v *ValidateLoopbackInterfaceType) NetworkChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network_choice")
	}
	return validatorFn, nil
}

func (v *ValidateLoopbackInterfaceType) NodeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node_choice")
	}
	return validatorFn, nil
}

func (v *ValidateLoopbackInterfaceType) NodeChoiceNodeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Node, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node")
	}
	return oValidatorFn_Node, nil
}

func (v *ValidateLoopbackInterfaceType) DeviceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for device")
	}

	return validatorFn, nil
}

func (v *ValidateLoopbackInterfaceType) MtuValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mtu")
	}

	return validatorFn, nil
}

func (v *ValidateLoopbackInterfaceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LoopbackInterfaceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LoopbackInterfaceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address_choice"]; exists {
		val := m.GetAddressChoice()
		vOpts := append(opts,
			db.WithValidateField("address_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAddressChoice().(type) {
	case *LoopbackInterfaceType_DhcpClient:
		if fv, exists := v.FldValidators["address_choice.dhcp_client"]; exists {
			val := m.GetAddressChoice().(*LoopbackInterfaceType_DhcpClient).DhcpClient
			vOpts := append(opts,
				db.WithValidateField("address_choice"),
				db.WithValidateField("dhcp_client"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *LoopbackInterfaceType_DhcpServer:
		if fv, exists := v.FldValidators["address_choice.dhcp_server"]; exists {
			val := m.GetAddressChoice().(*LoopbackInterfaceType_DhcpServer).DhcpServer
			vOpts := append(opts,
				db.WithValidateField("address_choice"),
				db.WithValidateField("dhcp_server"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *LoopbackInterfaceType_StaticIp:
		if fv, exists := v.FldValidators["address_choice.static_ip"]; exists {
			val := m.GetAddressChoice().(*LoopbackInterfaceType_StaticIp).StaticIp
			vOpts := append(opts,
				db.WithValidateField("address_choice"),
				db.WithValidateField("static_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["device"]; exists {

		vOpts := append(opts, db.WithValidateField("device"))
		if err := fv(ctx, m.GetDevice(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetIpv6AddressChoice().(type) {
	case *LoopbackInterfaceType_NoIpv6Address:
		if fv, exists := v.FldValidators["ipv6_address_choice.no_ipv6_address"]; exists {
			val := m.GetIpv6AddressChoice().(*LoopbackInterfaceType_NoIpv6Address).NoIpv6Address
			vOpts := append(opts,
				db.WithValidateField("ipv6_address_choice"),
				db.WithValidateField("no_ipv6_address"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *LoopbackInterfaceType_StaticIpv6Address:
		if fv, exists := v.FldValidators["ipv6_address_choice.static_ipv6_address"]; exists {
			val := m.GetIpv6AddressChoice().(*LoopbackInterfaceType_StaticIpv6Address).StaticIpv6Address
			vOpts := append(opts,
				db.WithValidateField("ipv6_address_choice"),
				db.WithValidateField("static_ipv6_address"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["mtu"]; exists {

		vOpts := append(opts, db.WithValidateField("mtu"))
		if err := fv(ctx, m.GetMtu(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_choice"]; exists {
		val := m.GetNetworkChoice()
		vOpts := append(opts,
			db.WithValidateField("network_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNetworkChoice().(type) {
	case *LoopbackInterfaceType_SiteLocalNetwork:
		if fv, exists := v.FldValidators["network_choice.site_local_network"]; exists {
			val := m.GetNetworkChoice().(*LoopbackInterfaceType_SiteLocalNetwork).SiteLocalNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("site_local_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *LoopbackInterfaceType_SiteLocalInsideNetwork:
		if fv, exists := v.FldValidators["network_choice.site_local_inside_network"]; exists {
			val := m.GetNetworkChoice().(*LoopbackInterfaceType_SiteLocalInsideNetwork).SiteLocalInsideNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("site_local_inside_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *LoopbackInterfaceType_IpFabricNetwork:
		if fv, exists := v.FldValidators["network_choice.ip_fabric_network"]; exists {
			val := m.GetNetworkChoice().(*LoopbackInterfaceType_IpFabricNetwork).IpFabricNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("ip_fabric_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["node_choice"]; exists {
		val := m.GetNodeChoice()
		vOpts := append(opts,
			db.WithValidateField("node_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNodeChoice().(type) {
	case *LoopbackInterfaceType_Cluster:
		if fv, exists := v.FldValidators["node_choice.cluster"]; exists {
			val := m.GetNodeChoice().(*LoopbackInterfaceType_Cluster).Cluster
			vOpts := append(opts,
				db.WithValidateField("node_choice"),
				db.WithValidateField("cluster"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *LoopbackInterfaceType_Node:
		if fv, exists := v.FldValidators["node_choice.node"]; exists {
			val := m.GetNodeChoice().(*LoopbackInterfaceType_Node).Node
			vOpts := append(opts,
				db.WithValidateField("node_choice"),
				db.WithValidateField("node"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLoopbackInterfaceTypeValidator = func() *ValidateLoopbackInterfaceType {
	v := &ValidateLoopbackInterfaceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAddressChoice := v.AddressChoiceValidationRuleHandler
	rulesAddressChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAddressChoice(rulesAddressChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LoopbackInterfaceType.address_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address_choice"] = vFn

	vrhNetworkChoice := v.NetworkChoiceValidationRuleHandler
	rulesNetworkChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhNetworkChoice(rulesNetworkChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LoopbackInterfaceType.network_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_choice"] = vFn

	vrhNodeChoice := v.NodeChoiceValidationRuleHandler
	rulesNodeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhNodeChoice(rulesNodeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LoopbackInterfaceType.node_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["node_choice"] = vFn

	vrhNodeChoiceNode := v.NodeChoiceNodeValidationRuleHandler
	rulesNodeChoiceNode := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["node_choice.node"], err = vrhNodeChoiceNode(rulesNodeChoiceNode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field LoopbackInterfaceType.node_choice_node: %s", err)
		panic(errMsg)
	}

	v.FldValidators["node_choice.node"] = vFnMap["node_choice.node"]

	vrhDevice := v.DeviceValidationRuleHandler
	rulesDevice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "64",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhDevice(rulesDevice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LoopbackInterfaceType.device: %s", err)
		panic(errMsg)
	}
	v.FldValidators["device"] = vFn

	vrhMtu := v.MtuValidationRuleHandler
	rulesMtu := map[string]string{
		"ves.io.schema.rules.uint32.ranges": "0,512-16384",
	}
	vFn, err = vrhMtu(rulesMtu)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for LoopbackInterfaceType.mtu: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mtu"] = vFn

	v.FldValidators["address_choice.dhcp_server"] = DHCPServerParametersTypeValidator().Validate
	v.FldValidators["address_choice.static_ip"] = StaticIPParametersTypeValidator().Validate

	v.FldValidators["ipv6_address_choice.static_ipv6_address"] = StaticIPParametersTypeValidator().Validate

	return v
}()

func LoopbackInterfaceTypeValidator() db.Validator {
	return DefaultLoopbackInterfaceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *NetworkInterfaceDFGW) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NetworkInterfaceDFGW) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NetworkInterfaceDFGW) DeepCopy() *NetworkInterfaceDFGW {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NetworkInterfaceDFGW{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NetworkInterfaceDFGW) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NetworkInterfaceDFGW) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NetworkInterfaceDFGWValidator().Validate(ctx, m, opts...)
}

type ValidateNetworkInterfaceDFGW struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNetworkInterfaceDFGW) DefaultGatewayModeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(NetworkInterfaceGatewayMode)
		return int32(i)
	}
	// NetworkInterfaceGatewayMode_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, NetworkInterfaceGatewayMode_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for default_gateway_mode")
	}

	return validatorFn, nil
}

func (v *ValidateNetworkInterfaceDFGW) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NetworkInterfaceDFGW)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NetworkInterfaceDFGW got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["default_gateway_address"]; exists {

		vOpts := append(opts, db.WithValidateField("default_gateway_address"))
		if err := fv(ctx, m.GetDefaultGatewayAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_gateway_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("default_gateway_mode"))
		if err := fv(ctx, m.GetDefaultGatewayMode(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNetworkInterfaceDFGWValidator = func() *ValidateNetworkInterfaceDFGW {
	v := &ValidateNetworkInterfaceDFGW{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDefaultGatewayMode := v.DefaultGatewayModeValidationRuleHandler
	rulesDefaultGatewayMode := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDefaultGatewayMode(rulesDefaultGatewayMode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for NetworkInterfaceDFGW.default_gateway_mode: %s", err)
		panic(errMsg)
	}
	v.FldValidators["default_gateway_mode"] = vFn

	v.FldValidators["default_gateway_address"] = ves_io_schema.Ipv4AddressTypeValidator().Validate

	return v
}()

func NetworkInterfaceDFGWValidator() db.Validator {
	return DefaultNetworkInterfaceDFGWValidator
}

// augmented methods on protoc/std generated struct

func (m *NetworkInterfaceDNS) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NetworkInterfaceDNS) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NetworkInterfaceDNS) DeepCopy() *NetworkInterfaceDNS {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NetworkInterfaceDNS{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NetworkInterfaceDNS) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NetworkInterfaceDNS) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NetworkInterfaceDNSValidator().Validate(ctx, m, opts...)
}

type ValidateNetworkInterfaceDNS struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNetworkInterfaceDNS) DnsModeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(NetworkInterfaceDNSMode)
		return int32(i)
	}
	// NetworkInterfaceDNSMode_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, NetworkInterfaceDNSMode_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dns_mode")
	}

	return validatorFn, nil
}

func (v *ValidateNetworkInterfaceDNS) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NetworkInterfaceDNS)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NetworkInterfaceDNS got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["dns_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_mode"))
		if err := fv(ctx, m.GetDnsMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_server"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_server"))
		for idx, item := range m.GetDnsServer() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNetworkInterfaceDNSValidator = func() *ValidateNetworkInterfaceDNS {
	v := &ValidateNetworkInterfaceDNS{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDnsMode := v.DnsModeValidationRuleHandler
	rulesDnsMode := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDnsMode(rulesDnsMode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for NetworkInterfaceDNS.dns_mode: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_mode"] = vFn

	v.FldValidators["dns_server"] = ves_io_schema.Ipv4AddressTypeValidator().Validate

	return v
}()

func NetworkInterfaceDNSValidator() db.Validator {
	return DefaultNetworkInterfaceDNSValidator
}

// augmented methods on protoc/std generated struct

func (m *NetworkInterfaceStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NetworkInterfaceStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NetworkInterfaceStatus) DeepCopy() *NetworkInterfaceStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NetworkInterfaceStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NetworkInterfaceStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NetworkInterfaceStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NetworkInterfaceStatusValidator().Validate(ctx, m, opts...)
}

type ValidateNetworkInterfaceStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNetworkInterfaceStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NetworkInterfaceStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NetworkInterfaceStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["up_down"]; exists {

		vOpts := append(opts, db.WithValidateField("up_down"))
		if err := fv(ctx, m.GetUpDown(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNetworkInterfaceStatusValidator = func() *ValidateNetworkInterfaceStatus {
	v := &ValidateNetworkInterfaceStatus{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func NetworkInterfaceStatusValidator() db.Validator {
	return DefaultNetworkInterfaceStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *NetworkInterfaceTunnel) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NetworkInterfaceTunnel) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NetworkInterfaceTunnel) DeepCopy() *NetworkInterfaceTunnel {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NetworkInterfaceTunnel{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NetworkInterfaceTunnel) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NetworkInterfaceTunnel) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NetworkInterfaceTunnelValidator().Validate(ctx, m, opts...)
}

func (m *NetworkInterfaceTunnel) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetTunnelDRefInfo()

}

func (m *NetworkInterfaceTunnel) GetTunnelDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetTunnel()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("NetworkInterfaceTunnel.tunnel[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "tunnel.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "tunnel",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetTunnelDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *NetworkInterfaceTunnel) GetTunnelDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "tunnel.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: tunnel")
	}
	for _, ref := range m.GetTunnel() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateNetworkInterfaceTunnel struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNetworkInterfaceTunnel) TunnelValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for tunnel")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for tunnel")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated tunnel")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items tunnel")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateNetworkInterfaceTunnel) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NetworkInterfaceTunnel)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NetworkInterfaceTunnel got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["tunnel"]; exists {
		vOpts := append(opts, db.WithValidateField("tunnel"))
		if err := fv(ctx, m.GetTunnel(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNetworkInterfaceTunnelValidator = func() *ValidateNetworkInterfaceTunnel {
	v := &ValidateNetworkInterfaceTunnel{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhTunnel := v.TunnelValidationRuleHandler
	rulesTunnel := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhTunnel(rulesTunnel)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for NetworkInterfaceTunnel.tunnel: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel"] = vFn

	return v
}()

func NetworkInterfaceTunnelValidator() db.Validator {
	return DefaultNetworkInterfaceTunnelValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *ReplaceSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetInterfaceChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *ReplaceSpecType) GetInterfaceChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetInterfaceChoice() == nil {
		return nil, nil
	}
	switch m.GetInterfaceChoice().(type) {
	case *ReplaceSpecType_DedicatedInterface:

		return nil, nil

	case *ReplaceSpecType_EthernetInterface:

		drInfos, err := m.GetEthernetInterface().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetEthernetInterface().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "ethernet_interface." + dri.DRField
		}
		return drInfos, err

	case *ReplaceSpecType_TunnelInterface:

		drInfos, err := m.GetTunnelInterface().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetTunnelInterface().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "tunnel_interface." + dri.DRField
		}
		return drInfos, err

	case *ReplaceSpecType_LegacyInterface:

		drInfos, err := m.GetLegacyInterface().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetLegacyInterface().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "legacy_interface." + dri.DRField
		}
		return drInfos, err

	case *ReplaceSpecType_DedicatedManagementInterface:

		return nil, nil

	case *ReplaceSpecType_Layer2Interface:

		return nil, nil

	default:
		return nil, nil
	}

}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) InterfaceChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for interface_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["interface_choice"]; exists {
		val := m.GetInterfaceChoice()
		vOpts := append(opts,
			db.WithValidateField("interface_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetInterfaceChoice().(type) {
	case *ReplaceSpecType_DedicatedInterface:
		if fv, exists := v.FldValidators["interface_choice.dedicated_interface"]; exists {
			val := m.GetInterfaceChoice().(*ReplaceSpecType_DedicatedInterface).DedicatedInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("dedicated_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_EthernetInterface:
		if fv, exists := v.FldValidators["interface_choice.ethernet_interface"]; exists {
			val := m.GetInterfaceChoice().(*ReplaceSpecType_EthernetInterface).EthernetInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("ethernet_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_TunnelInterface:
		if fv, exists := v.FldValidators["interface_choice.tunnel_interface"]; exists {
			val := m.GetInterfaceChoice().(*ReplaceSpecType_TunnelInterface).TunnelInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("tunnel_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_LegacyInterface:
		if fv, exists := v.FldValidators["interface_choice.legacy_interface"]; exists {
			val := m.GetInterfaceChoice().(*ReplaceSpecType_LegacyInterface).LegacyInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("legacy_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_DedicatedManagementInterface:
		if fv, exists := v.FldValidators["interface_choice.dedicated_management_interface"]; exists {
			val := m.GetInterfaceChoice().(*ReplaceSpecType_DedicatedManagementInterface).DedicatedManagementInterface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("dedicated_management_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_Layer2Interface:
		if fv, exists := v.FldValidators["interface_choice.layer2_interface"]; exists {
			val := m.GetInterfaceChoice().(*ReplaceSpecType_Layer2Interface).Layer2Interface
			vOpts := append(opts,
				db.WithValidateField("interface_choice"),
				db.WithValidateField("layer2_interface"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInterfaceChoice := v.InterfaceChoiceValidationRuleHandler
	rulesInterfaceChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhInterfaceChoice(rulesInterfaceChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.interface_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface_choice"] = vFn

	v.FldValidators["interface_choice.dedicated_interface"] = DedicatedInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.ethernet_interface"] = EthernetInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.tunnel_interface"] = TunnelInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.legacy_interface"] = LegacyInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.dedicated_management_interface"] = DedicatedManagementInterfaceTypeValidator().Validate
	v.FldValidators["interface_choice.layer2_interface"] = Layer2InterfaceTypeValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StaticIPParametersType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StaticIPParametersType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StaticIPParametersType) DeepCopy() *StaticIPParametersType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StaticIPParametersType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StaticIPParametersType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StaticIPParametersType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StaticIPParametersTypeValidator().Validate(ctx, m, opts...)
}

func (m *StaticIPParametersType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetNetworkPrefixChoiceDRefInfo()

}

// GetDRefInfo for the field's type
func (m *StaticIPParametersType) GetNetworkPrefixChoiceDRefInfo() ([]db.DRefInfo, error) {
	if m.GetNetworkPrefixChoice() == nil {
		return nil, nil
	}
	switch m.GetNetworkPrefixChoice().(type) {
	case *StaticIPParametersType_NodeStaticIp:

		return nil, nil

	case *StaticIPParametersType_ClusterStaticIp:

		return nil, nil

	case *StaticIPParametersType_FleetStaticIp:

		drInfos, err := m.GetFleetStaticIp().GetDRefInfo()
		if err != nil {
			return nil, errors.Wrap(err, "GetFleetStaticIp().GetDRefInfo() FAILED")
		}
		for i := range drInfos {
			dri := &drInfos[i]
			dri.DRField = "fleet_static_ip." + dri.DRField
		}
		return drInfos, err

	default:
		return nil, nil
	}

}

type ValidateStaticIPParametersType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStaticIPParametersType) NetworkPrefixChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network_prefix_choice")
	}
	return validatorFn, nil
}

func (v *ValidateStaticIPParametersType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StaticIPParametersType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StaticIPParametersType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["network_prefix_choice"]; exists {
		val := m.GetNetworkPrefixChoice()
		vOpts := append(opts,
			db.WithValidateField("network_prefix_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNetworkPrefixChoice().(type) {
	case *StaticIPParametersType_NodeStaticIp:
		if fv, exists := v.FldValidators["network_prefix_choice.node_static_ip"]; exists {
			val := m.GetNetworkPrefixChoice().(*StaticIPParametersType_NodeStaticIp).NodeStaticIp
			vOpts := append(opts,
				db.WithValidateField("network_prefix_choice"),
				db.WithValidateField("node_static_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StaticIPParametersType_ClusterStaticIp:
		if fv, exists := v.FldValidators["network_prefix_choice.cluster_static_ip"]; exists {
			val := m.GetNetworkPrefixChoice().(*StaticIPParametersType_ClusterStaticIp).ClusterStaticIp
			vOpts := append(opts,
				db.WithValidateField("network_prefix_choice"),
				db.WithValidateField("cluster_static_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *StaticIPParametersType_FleetStaticIp:
		if fv, exists := v.FldValidators["network_prefix_choice.fleet_static_ip"]; exists {
			val := m.GetNetworkPrefixChoice().(*StaticIPParametersType_FleetStaticIp).FleetStaticIp
			vOpts := append(opts,
				db.WithValidateField("network_prefix_choice"),
				db.WithValidateField("fleet_static_ip"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStaticIPParametersTypeValidator = func() *ValidateStaticIPParametersType {
	v := &ValidateStaticIPParametersType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNetworkPrefixChoice := v.NetworkPrefixChoiceValidationRuleHandler
	rulesNetworkPrefixChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhNetworkPrefixChoice(rulesNetworkPrefixChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StaticIPParametersType.network_prefix_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_prefix_choice"] = vFn

	v.FldValidators["network_prefix_choice.node_static_ip"] = StaticIpParametersNodeTypeValidator().Validate
	v.FldValidators["network_prefix_choice.cluster_static_ip"] = StaticIpParametersClusterTypeValidator().Validate
	v.FldValidators["network_prefix_choice.fleet_static_ip"] = StaticIpParametersFleetTypeValidator().Validate

	return v
}()

func StaticIPParametersTypeValidator() db.Validator {
	return DefaultStaticIPParametersTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StaticIpParametersClusterType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StaticIpParametersClusterType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StaticIpParametersClusterType) DeepCopy() *StaticIpParametersClusterType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StaticIpParametersClusterType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StaticIpParametersClusterType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StaticIpParametersClusterType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StaticIpParametersClusterTypeValidator().Validate(ctx, m, opts...)
}

type ValidateStaticIpParametersClusterType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStaticIpParametersClusterType) InterfaceIpMapValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemKeyRules := db.GetMapStringKeyRules(rules)
	itemKeyFn, err := db.NewStringValidationRuleHandler(itemKeyRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item key ValidationRuleHandler for interface_ip_map")
	}
	itemsValidatorFn := func(ctx context.Context, kv map[string]*StaticIpParametersNodeType, opts ...db.ValidateOpt) error {
		for key, value := range kv {
			if err := itemKeyFn(ctx, key, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element with key %v", key))
			}
			if err := StaticIpParametersNodeTypeValidator().Validate(ctx, value, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("value for element with key %v", key))
			}
		}
		return nil
	}
	mapValFn, err := db.NewMapValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Map ValidationRuleHandler for interface_ip_map")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.(map[string]*StaticIpParametersNodeType)
		if !ok {
			return fmt.Errorf("Map validation expected map[ string ]*StaticIpParametersNodeType, got %T", val)
		}
		if err := mapValFn(ctx, len(elems), opts...); err != nil {
			return errors.Wrap(err, "map interface_ip_map")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items interface_ip_map")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateStaticIpParametersClusterType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StaticIpParametersClusterType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StaticIpParametersClusterType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["interface_ip_map"]; exists {
		vOpts := append(opts, db.WithValidateField("interface_ip_map"))
		if err := fv(ctx, m.GetInterfaceIpMap(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStaticIpParametersClusterTypeValidator = func() *ValidateStaticIpParametersClusterType {
	v := &ValidateStaticIpParametersClusterType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInterfaceIpMap := v.InterfaceIpMapValidationRuleHandler
	rulesInterfaceIpMap := map[string]string{
		"ves.io.schema.rules.map.keys.string.max_len": "128",
		"ves.io.schema.rules.map.keys.string.min_len": "1",
		"ves.io.schema.rules.map.max_pairs":           "128",
	}
	vFn, err = vrhInterfaceIpMap(rulesInterfaceIpMap)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StaticIpParametersClusterType.interface_ip_map: %s", err)
		panic(errMsg)
	}
	v.FldValidators["interface_ip_map"] = vFn

	return v
}()

func StaticIpParametersClusterTypeValidator() db.Validator {
	return DefaultStaticIpParametersClusterTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StaticIpParametersFleetType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StaticIpParametersFleetType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StaticIpParametersFleetType) DeepCopy() *StaticIpParametersFleetType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StaticIpParametersFleetType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StaticIpParametersFleetType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StaticIpParametersFleetType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StaticIpParametersFleetTypeValidator().Validate(ctx, m, opts...)
}

func (m *StaticIpParametersFleetType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return m.GetNetworkPrefixAllocatorDRefInfo()

}

func (m *StaticIpParametersFleetType) GetNetworkPrefixAllocatorDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetNetworkPrefixAllocator()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("address_allocator.Object")
	dri := db.DRefInfo{
		RefdType:   "address_allocator.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "network_prefix_allocator",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetNetworkPrefixAllocatorDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *StaticIpParametersFleetType) GetNetworkPrefixAllocatorDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "address_allocator.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: address_allocator")
	}

	vref := m.GetNetworkPrefixAllocator()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "address_allocator.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateStaticIpParametersFleetType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStaticIpParametersFleetType) DefaultGwValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for default_gw")
	}

	return validatorFn, nil
}

func (v *ValidateStaticIpParametersFleetType) DnsServerValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dns_server")
	}

	return validatorFn, nil
}

func (v *ValidateStaticIpParametersFleetType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StaticIpParametersFleetType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StaticIpParametersFleetType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["default_gw"]; exists {

		vOpts := append(opts, db.WithValidateField("default_gw"))
		if err := fv(ctx, m.GetDefaultGw(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_server"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_server"))
		if err := fv(ctx, m.GetDnsServer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_prefix_allocator"]; exists {

		vOpts := append(opts, db.WithValidateField("network_prefix_allocator"))
		if err := fv(ctx, m.GetNetworkPrefixAllocator(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStaticIpParametersFleetTypeValidator = func() *ValidateStaticIpParametersFleetType {
	v := &ValidateStaticIpParametersFleetType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDefaultGw := v.DefaultGwValidationRuleHandler
	rulesDefaultGw := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhDefaultGw(rulesDefaultGw)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StaticIpParametersFleetType.default_gw: %s", err)
		panic(errMsg)
	}
	v.FldValidators["default_gw"] = vFn

	vrhDnsServer := v.DnsServerValidationRuleHandler
	rulesDnsServer := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhDnsServer(rulesDnsServer)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StaticIpParametersFleetType.dns_server: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_server"] = vFn

	v.FldValidators["network_prefix_allocator"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func StaticIpParametersFleetTypeValidator() db.Validator {
	return DefaultStaticIpParametersFleetTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *StaticIpParametersNodeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StaticIpParametersNodeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StaticIpParametersNodeType) DeepCopy() *StaticIpParametersNodeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StaticIpParametersNodeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StaticIpParametersNodeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StaticIpParametersNodeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StaticIpParametersNodeTypeValidator().Validate(ctx, m, opts...)
}

type ValidateStaticIpParametersNodeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStaticIpParametersNodeType) IpAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ip_address")
	}

	return validatorFn, nil
}

func (v *ValidateStaticIpParametersNodeType) DefaultGwValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for default_gw")
	}

	return validatorFn, nil
}

func (v *ValidateStaticIpParametersNodeType) DnsServerValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for dns_server")
	}

	return validatorFn, nil
}

func (v *ValidateStaticIpParametersNodeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StaticIpParametersNodeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StaticIpParametersNodeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["default_gw"]; exists {

		vOpts := append(opts, db.WithValidateField("default_gw"))
		if err := fv(ctx, m.GetDefaultGw(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["dns_server"]; exists {

		vOpts := append(opts, db.WithValidateField("dns_server"))
		if err := fv(ctx, m.GetDnsServer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip_address"]; exists {

		vOpts := append(opts, db.WithValidateField("ip_address"))
		if err := fv(ctx, m.GetIpAddress(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStaticIpParametersNodeTypeValidator = func() *ValidateStaticIpParametersNodeType {
	v := &ValidateStaticIpParametersNodeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhIpAddress := v.IpAddressValidationRuleHandler
	rulesIpAddress := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.ip_prefix": "true",
	}
	vFn, err = vrhIpAddress(rulesIpAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StaticIpParametersNodeType.ip_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ip_address"] = vFn

	vrhDefaultGw := v.DefaultGwValidationRuleHandler
	rulesDefaultGw := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhDefaultGw(rulesDefaultGw)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StaticIpParametersNodeType.default_gw: %s", err)
		panic(errMsg)
	}
	v.FldValidators["default_gw"] = vFn

	vrhDnsServer := v.DnsServerValidationRuleHandler
	rulesDnsServer := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhDnsServer(rulesDnsServer)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for StaticIpParametersNodeType.dns_server: %s", err)
		panic(errMsg)
	}
	v.FldValidators["dns_server"] = vFn

	return v
}()

func StaticIpParametersNodeTypeValidator() db.Validator {
	return DefaultStaticIpParametersNodeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *TunnelInterfaceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TunnelInterfaceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TunnelInterfaceType) DeepCopy() *TunnelInterfaceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TunnelInterfaceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TunnelInterfaceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TunnelInterfaceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TunnelInterfaceTypeValidator().Validate(ctx, m, opts...)
}

func (m *TunnelInterfaceType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetNetworkChoiceDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetNetworkChoiceDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetStaticIpDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetStaticIpDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetTunnelDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetTunnelDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *TunnelInterfaceType) GetNetworkChoiceDRefInfo() ([]db.DRefInfo, error) {
	switch m.GetNetworkChoice().(type) {
	case *TunnelInterfaceType_SiteLocalNetwork:

		return nil, nil

	case *TunnelInterfaceType_SiteLocalInsideNetwork:

		return nil, nil

	case *TunnelInterfaceType_InsideNetwork:

		vref := m.GetInsideNetwork()
		if vref == nil {
			return nil, nil
		}
		vdRef := db.NewDirectRefForView(vref)
		vdRef.SetKind("virtual_network.Object")
		dri := db.DRefInfo{
			RefdType:   "virtual_network.Object",
			RefdTenant: vref.Tenant,
			RefdNS:     vref.Namespace,
			RefdName:   vref.Name,
			DRField:    "inside_network",
			Ref:        vdRef,
		}
		return []db.DRefInfo{dri}, nil

	default:
		return nil, nil
	}
}

// GetNetworkChoiceDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *TunnelInterfaceType) GetNetworkChoiceDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry

	switch m.GetNetworkChoice().(type) {
	case *TunnelInterfaceType_SiteLocalNetwork:

	case *TunnelInterfaceType_SiteLocalInsideNetwork:

	case *TunnelInterfaceType_InsideNetwork:
		refdType, err := d.TypeForEntryKind("", "", "virtual_network.Object")
		if err != nil {
			return nil, errors.Wrap(err, "Cannot find type for kind: virtual_network")
		}

		vref := m.GetInsideNetwork()
		if vref == nil {
			return nil, nil
		}
		ref := &ves_io_schema.ObjectRefType{
			Kind:      "virtual_network.Object",
			Tenant:    vref.Tenant,
			Namespace: vref.Namespace,
			Name:      vref.Name,
		}
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}

	}

	return entries, nil
}

// GetDRefInfo for the field's type
func (m *TunnelInterfaceType) GetStaticIpDRefInfo() ([]db.DRefInfo, error) {
	if m.GetStaticIp() == nil {
		return nil, nil
	}

	drInfos, err := m.GetStaticIp().GetDRefInfo()
	if err != nil {
		return nil, errors.Wrap(err, "GetStaticIp().GetDRefInfo() FAILED")
	}
	for i := range drInfos {
		dri := &drInfos[i]
		dri.DRField = "static_ip." + dri.DRField
	}
	return drInfos, err

}

func (m *TunnelInterfaceType) GetTunnelDRefInfo() ([]db.DRefInfo, error) {

	vref := m.GetTunnel()
	if vref == nil {
		return nil, nil
	}
	vdRef := db.NewDirectRefForView(vref)
	vdRef.SetKind("tunnel.Object")
	dri := db.DRefInfo{
		RefdType:   "tunnel.Object",
		RefdTenant: vref.Tenant,
		RefdNS:     vref.Namespace,
		RefdName:   vref.Name,
		DRField:    "tunnel",
		Ref:        vdRef,
	}
	return []db.DRefInfo{dri}, nil

}

// GetTunnelDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *TunnelInterfaceType) GetTunnelDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "tunnel.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: tunnel")
	}

	vref := m.GetTunnel()
	if vref == nil {
		return nil, nil
	}
	ref := &ves_io_schema.ObjectRefType{
		Kind:      "tunnel.Object",
		Tenant:    vref.Tenant,
		Namespace: vref.Namespace,
		Name:      vref.Name,
	}
	refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
	if err != nil {
		return nil, errors.Wrap(err, "Getting referred entry")
	}
	if refdEnt != nil {
		entries = append(entries, refdEnt)
	}

	return entries, nil
}

type ValidateTunnelInterfaceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTunnelInterfaceType) NetworkChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for network_choice")
	}
	return validatorFn, nil
}

func (v *ValidateTunnelInterfaceType) NodeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node_choice")
	}
	return validatorFn, nil
}

func (v *ValidateTunnelInterfaceType) NodeChoiceNodeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Node, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for node")
	}
	return oValidatorFn_Node, nil
}

func (v *ValidateTunnelInterfaceType) TunnelValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for tunnel")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := ves_io_schema_views.ObjectRefTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateTunnelInterfaceType) StaticIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	reqdValidatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "MessageValidationRuleHandler for static_ip")
	}
	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if err := reqdValidatorFn(ctx, val, opts...); err != nil {
			return err
		}

		if err := StaticIPParametersTypeValidator().Validate(ctx, val, opts...); err != nil {
			return err
		}

		return nil
	}

	return validatorFn, nil
}

func (v *ValidateTunnelInterfaceType) MtuValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for mtu")
	}

	return validatorFn, nil
}

func (v *ValidateTunnelInterfaceType) PriorityValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for priority")
	}

	return validatorFn, nil
}

func (v *ValidateTunnelInterfaceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TunnelInterfaceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TunnelInterfaceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["mtu"]; exists {

		vOpts := append(opts, db.WithValidateField("mtu"))
		if err := fv(ctx, m.GetMtu(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_choice"]; exists {
		val := m.GetNetworkChoice()
		vOpts := append(opts,
			db.WithValidateField("network_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNetworkChoice().(type) {
	case *TunnelInterfaceType_SiteLocalNetwork:
		if fv, exists := v.FldValidators["network_choice.site_local_network"]; exists {
			val := m.GetNetworkChoice().(*TunnelInterfaceType_SiteLocalNetwork).SiteLocalNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("site_local_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TunnelInterfaceType_SiteLocalInsideNetwork:
		if fv, exists := v.FldValidators["network_choice.site_local_inside_network"]; exists {
			val := m.GetNetworkChoice().(*TunnelInterfaceType_SiteLocalInsideNetwork).SiteLocalInsideNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("site_local_inside_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TunnelInterfaceType_InsideNetwork:
		if fv, exists := v.FldValidators["network_choice.inside_network"]; exists {
			val := m.GetNetworkChoice().(*TunnelInterfaceType_InsideNetwork).InsideNetwork
			vOpts := append(opts,
				db.WithValidateField("network_choice"),
				db.WithValidateField("inside_network"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["node_choice"]; exists {
		val := m.GetNodeChoice()
		vOpts := append(opts,
			db.WithValidateField("node_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetNodeChoice().(type) {
	case *TunnelInterfaceType_Cluster:
		if fv, exists := v.FldValidators["node_choice.cluster"]; exists {
			val := m.GetNodeChoice().(*TunnelInterfaceType_Cluster).Cluster
			vOpts := append(opts,
				db.WithValidateField("node_choice"),
				db.WithValidateField("cluster"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *TunnelInterfaceType_Node:
		if fv, exists := v.FldValidators["node_choice.node"]; exists {
			val := m.GetNodeChoice().(*TunnelInterfaceType_Node).Node
			vOpts := append(opts,
				db.WithValidateField("node_choice"),
				db.WithValidateField("node"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["priority"]; exists {

		vOpts := append(opts, db.WithValidateField("priority"))
		if err := fv(ctx, m.GetPriority(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["static_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("static_ip"))
		if err := fv(ctx, m.GetStaticIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel"))
		if err := fv(ctx, m.GetTunnel(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTunnelInterfaceTypeValidator = func() *ValidateTunnelInterfaceType {
	v := &ValidateTunnelInterfaceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNetworkChoice := v.NetworkChoiceValidationRuleHandler
	rulesNetworkChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhNetworkChoice(rulesNetworkChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TunnelInterfaceType.network_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["network_choice"] = vFn

	vrhNodeChoice := v.NodeChoiceValidationRuleHandler
	rulesNodeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhNodeChoice(rulesNodeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TunnelInterfaceType.node_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["node_choice"] = vFn

	vrhNodeChoiceNode := v.NodeChoiceNodeValidationRuleHandler
	rulesNodeChoiceNode := map[string]string{
		"ves.io.schema.rules.string.max_len": "64",
		"ves.io.schema.rules.string.min_len": "1",
	}
	vFnMap["node_choice.node"], err = vrhNodeChoiceNode(rulesNodeChoiceNode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field TunnelInterfaceType.node_choice_node: %s", err)
		panic(errMsg)
	}

	v.FldValidators["node_choice.node"] = vFnMap["node_choice.node"]

	vrhTunnel := v.TunnelValidationRuleHandler
	rulesTunnel := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhTunnel(rulesTunnel)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TunnelInterfaceType.tunnel: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel"] = vFn

	vrhStaticIp := v.StaticIpValidationRuleHandler
	rulesStaticIp := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhStaticIp(rulesStaticIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TunnelInterfaceType.static_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["static_ip"] = vFn

	vrhMtu := v.MtuValidationRuleHandler
	rulesMtu := map[string]string{
		"ves.io.schema.rules.uint32.ranges": "0,512-16384",
	}
	vFn, err = vrhMtu(rulesMtu)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TunnelInterfaceType.mtu: %s", err)
		panic(errMsg)
	}
	v.FldValidators["mtu"] = vFn

	vrhPriority := v.PriorityValidationRuleHandler
	rulesPriority := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "255",
	}
	vFn, err = vrhPriority(rulesPriority)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for TunnelInterfaceType.priority: %s", err)
		panic(errMsg)
	}
	v.FldValidators["priority"] = vFn

	v.FldValidators["network_choice.inside_network"] = ves_io_schema_views.ObjectRefTypeValidator().Validate

	return v
}()

func TunnelInterfaceTypeValidator() db.Validator {
	return DefaultTunnelInterfaceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VhostInterfaceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VhostInterfaceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VhostInterfaceType) DeepCopy() *VhostInterfaceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VhostInterfaceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VhostInterfaceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VhostInterfaceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VhostInterfaceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVhostInterfaceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVhostInterfaceType) HostChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for host_choice")
	}
	return validatorFn, nil
}

func (v *ValidateVhostInterfaceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VhostInterfaceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VhostInterfaceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["host_choice"]; exists {
		val := m.GetHostChoice()
		vOpts := append(opts,
			db.WithValidateField("host_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetHostChoice().(type) {
	case *VhostInterfaceType_NoHost:
		if fv, exists := v.FldValidators["host_choice.no_host"]; exists {
			val := m.GetHostChoice().(*VhostInterfaceType_NoHost).NoHost
			vOpts := append(opts,
				db.WithValidateField("host_choice"),
				db.WithValidateField("no_host"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *VhostInterfaceType_Vhost:
		if fv, exists := v.FldValidators["host_choice.vhost"]; exists {
			val := m.GetHostChoice().(*VhostInterfaceType_Vhost).Vhost
			vOpts := append(opts,
				db.WithValidateField("host_choice"),
				db.WithValidateField("vhost"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *VhostInterfaceType_Virtual:
		if fv, exists := v.FldValidators["host_choice.virtual"]; exists {
			val := m.GetHostChoice().(*VhostInterfaceType_Virtual).Virtual
			vOpts := append(opts,
				db.WithValidateField("host_choice"),
				db.WithValidateField("virtual"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVhostInterfaceTypeValidator = func() *ValidateVhostInterfaceType {
	v := &ValidateVhostInterfaceType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHostChoice := v.HostChoiceValidationRuleHandler
	rulesHostChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhHostChoice(rulesHostChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VhostInterfaceType.host_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["host_choice"] = vFn

	return v
}()

func VhostInterfaceTypeValidator() db.Validator {
	return DefaultVhostInterfaceTypeValidator
}

func (m *CreateSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}

}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *CreateSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *CreateSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *CreateSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetMonitoringChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.MonitoringChoice.(type) {
	case nil:
		o.MonitoringChoice = nil

	case *GetSpecType_Monitor:
		o.MonitoringChoice = &GlobalSpecType_Monitor{Monitor: of.Monitor}

	case *GetSpecType_MonitorDisabled:
		o.MonitoringChoice = &GlobalSpecType_MonitorDisabled{MonitorDisabled: of.MonitorDisabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetMonitoringChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.MonitoringChoice.(type) {
	case nil:
		r.MonitoringChoice = nil

	case *GlobalSpecType_Monitor:
		r.MonitoringChoice = &GetSpecType_Monitor{Monitor: of.Monitor}

	case *GlobalSpecType_MonitorDisabled:
		r.MonitoringChoice = &GetSpecType_MonitorDisabled{MonitorDisabled: of.MonitorDisabled}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *GetSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.DHCPServer = f.GetDHCPServer()
	m.DNSServer = f.GetDNSServer()
	m.AddressAllocator = f.GetAddressAllocator()
	m.DefaultGateway = f.GetDefaultGateway()
	m.DeviceName = f.GetDeviceName()
	m.DhcpAddress = f.GetDhcpAddress()

	m.InterfaceIpMap = f.GetInterfaceIpMap()
	m.IsPrimary = f.GetIsPrimary()
	m.GetMonitoringChoiceFromGlobalSpecType(f)
	m.Mtu = f.GetMtu()
	m.ParentNetworkInterface = f.GetParentNetworkInterface()
	m.Priority = f.GetPriority()
	m.StaticAddresses = f.GetStaticAddresses()
	m.Tunnel = f.GetTunnel()
	m.Type = f.GetType()
	m.VirtualNetwork = f.GetVirtualNetwork()
	m.VlanTag = f.GetVlanTag()
	m.VlanTagging = f.GetVlanTagging()
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *GetSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *GetSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.DHCPServer = m1.DHCPServer
	f.DNSServer = m1.DNSServer
	f.AddressAllocator = m1.AddressAllocator
	f.DefaultGateway = m1.DefaultGateway
	f.DeviceName = m1.DeviceName
	f.DhcpAddress = m1.DhcpAddress

	f.InterfaceIpMap = m1.InterfaceIpMap
	f.IsPrimary = m1.IsPrimary
	m1.SetMonitoringChoiceToGlobalSpecType(f)
	f.Mtu = m1.Mtu
	f.ParentNetworkInterface = m1.ParentNetworkInterface
	f.Priority = m1.Priority
	f.StaticAddresses = m1.StaticAddresses
	f.Tunnel = m1.Tunnel
	f.Type = m1.Type
	f.VirtualNetwork = m1.VirtualNetwork
	f.VlanTag = m1.VlanTag
	f.VlanTagging = m1.VlanTagging
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *GetSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}

}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}
