// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/tunnel/types.proto

package tunnel

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Tunnel Type
//
// x-displayName: "Tunnel Type"
// Supported tunnel types are IPSec
type TunnelType int32

const (
	// x-displayName: "IPSEC with PSK"
	// IPSEC tunnel type with PSK
	IPSEC_PSK TunnelType = 0
)

var TunnelType_name = map[int32]string{
	0: "IPSEC_PSK",
}

var TunnelType_value = map[string]int32{
	"IPSEC_PSK": 0,
}

func (TunnelType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{0}
}

// IPSec tunnel configuration parameters
//
// x-displayName: "IPSEC tunnel parameters"
// Configuration for IPSec encapsulation are:
// 1. PSK - pre shared key to be used by IKE
type IpsecTunnelParams struct {
	// IPSec Pre shared key
	//
	// x-displayName: "Ipsec PSK"
	// Pre shared key, valid for tunnel type IPSEC_PSK, SA are computed by IKE dynamically
	IpsecPsk *schema.SecretType `protobuf:"bytes,1,opt,name=ipsec_psk,json=ipsecPsk,proto3" json:"ipsec_psk,omitempty"`
}

func (m *IpsecTunnelParams) Reset()      { *m = IpsecTunnelParams{} }
func (*IpsecTunnelParams) ProtoMessage() {}
func (*IpsecTunnelParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{0}
}
func (m *IpsecTunnelParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpsecTunnelParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IpsecTunnelParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpsecTunnelParams.Merge(m, src)
}
func (m *IpsecTunnelParams) XXX_Size() int {
	return m.Size()
}
func (m *IpsecTunnelParams) XXX_DiscardUnknown() {
	xxx_messageInfo_IpsecTunnelParams.DiscardUnknown(m)
}

var xxx_messageInfo_IpsecTunnelParams proto.InternalMessageInfo

func (m *IpsecTunnelParams) GetIpsecPsk() *schema.SecretType {
	if m != nil {
		return m.IpsecPsk
	}
	return nil
}

// Tunnel Parameters
//
// x-displayName: "Tunnel Parameters"
// Tunnel configuration parameters for supported encapsulation
// 1. IPSec is supported with PSK for which PSK can be configured
type TunnelParams struct {
	// Type
	//
	// x-displayName: "Type"
	// Type of tunnel params
	//
	// Types that are valid to be assigned to Type:
	//	*TunnelParams_Ipsec
	Type isTunnelParams_Type `protobuf_oneof:"type"`
}

func (m *TunnelParams) Reset()      { *m = TunnelParams{} }
func (*TunnelParams) ProtoMessage() {}
func (*TunnelParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{1}
}
func (m *TunnelParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunnelParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TunnelParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelParams.Merge(m, src)
}
func (m *TunnelParams) XXX_Size() int {
	return m.Size()
}
func (m *TunnelParams) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelParams.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelParams proto.InternalMessageInfo

type isTunnelParams_Type interface {
	isTunnelParams_Type()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type TunnelParams_Ipsec struct {
	Ipsec *IpsecTunnelParams `protobuf:"bytes,1,opt,name=ipsec,proto3,oneof" json:"ipsec,omitempty"`
}

func (*TunnelParams_Ipsec) isTunnelParams_Type() {}

func (m *TunnelParams) GetType() isTunnelParams_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *TunnelParams) GetIpsec() *IpsecTunnelParams {
	if x, ok := m.GetType().(*TunnelParams_Ipsec); ok {
		return x.Ipsec
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TunnelParams) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TunnelParams_Ipsec)(nil),
	}
}

// Interface Type
//
// x-displayName: "Interface Type"
// Provides the local interface to pick up source IP and network for transporting encapsulated packet
type InterfaceType struct {
	// Local Interface
	//
	// x-displayName: "Local Interface"
	// Local interface to be used for filling in source information of IP and network for transport
	LocalIntf []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=local_intf,json=localIntf,proto3" json:"local_intf,omitempty"`
}

func (m *InterfaceType) Reset()      { *m = InterfaceType{} }
func (*InterfaceType) ProtoMessage() {}
func (*InterfaceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{2}
}
func (m *InterfaceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InterfaceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceType.Merge(m, src)
}
func (m *InterfaceType) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceType proto.InternalMessageInfo

func (m *InterfaceType) GetLocalIntf() []*schema.ObjectRefType {
	if m != nil {
		return m.LocalIntf
	}
	return nil
}

// Local IP Address Type
//
// x-displayName: "Local IP Address Type"
// Provides the configuration to pick up source IP and network for transporting encapsulated packet
type LocalIpAddressType struct {
	// Type
	//
	// x-displayName: "Type"
	// Options to choose local IP address
	//
	// Types that are valid to be assigned to Type:
	//	*LocalIpAddressType_IpAddress
	//	*LocalIpAddressType_Auto
	Type isLocalIpAddressType_Type `protobuf_oneof:"type"`
	// Local Virtual Network
	//
	// x-displayName: "Local Virtual Network"
	// x-required
	// Local Virtual network to be used for transporting encapsulated packets
	VirtualNetworkType *schema.VirtualNetworkSelectorType `protobuf:"bytes,3,opt,name=virtual_network_type,json=virtualNetworkType,proto3" json:"virtual_network_type,omitempty"`
}

func (m *LocalIpAddressType) Reset()      { *m = LocalIpAddressType{} }
func (*LocalIpAddressType) ProtoMessage() {}
func (*LocalIpAddressType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{3}
}
func (m *LocalIpAddressType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalIpAddressType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LocalIpAddressType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalIpAddressType.Merge(m, src)
}
func (m *LocalIpAddressType) XXX_Size() int {
	return m.Size()
}
func (m *LocalIpAddressType) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalIpAddressType.DiscardUnknown(m)
}

var xxx_messageInfo_LocalIpAddressType proto.InternalMessageInfo

type isLocalIpAddressType_Type interface {
	isLocalIpAddressType_Type()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type LocalIpAddressType_IpAddress struct {
	IpAddress *schema.IpAddressType `protobuf:"bytes,1,opt,name=ip_address,json=ipAddress,proto3,oneof" json:"ip_address,omitempty"`
}
type LocalIpAddressType_Auto struct {
	Auto *schema.Empty `protobuf:"bytes,2,opt,name=auto,proto3,oneof" json:"auto,omitempty"`
}

func (*LocalIpAddressType_IpAddress) isLocalIpAddressType_Type() {}
func (*LocalIpAddressType_Auto) isLocalIpAddressType_Type()      {}

func (m *LocalIpAddressType) GetType() isLocalIpAddressType_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *LocalIpAddressType) GetIpAddress() *schema.IpAddressType {
	if x, ok := m.GetType().(*LocalIpAddressType_IpAddress); ok {
		return x.IpAddress
	}
	return nil
}

func (m *LocalIpAddressType) GetAuto() *schema.Empty {
	if x, ok := m.GetType().(*LocalIpAddressType_Auto); ok {
		return x.Auto
	}
	return nil
}

func (m *LocalIpAddressType) GetVirtualNetworkType() *schema.VirtualNetworkSelectorType {
	if m != nil {
		return m.VirtualNetworkType
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LocalIpAddressType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LocalIpAddressType_IpAddress)(nil),
		(*LocalIpAddressType_Auto)(nil),
	}
}

// Local IP Address Selector
//
// x-displayName: "Local IP Address Selector"
// Defines the options to select local ip address and virtual network for tunnel object
// Options available are -
// 1. Local Interface - Network Interface from which IP address and network will be selected
// 2. IP Address - IP address and network can be configured explicitly
type LocalIpAddressSelector struct {
	// Type
	//
	// x-displayName: "Type"
	// Choice to pick up local ip address for tunnel
	//
	// Types that are valid to be assigned to Type:
	//	*LocalIpAddressSelector_Intf
	//	*LocalIpAddressSelector_IpAddress
	Type isLocalIpAddressSelector_Type `protobuf_oneof:"type"`
}

func (m *LocalIpAddressSelector) Reset()      { *m = LocalIpAddressSelector{} }
func (*LocalIpAddressSelector) ProtoMessage() {}
func (*LocalIpAddressSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{4}
}
func (m *LocalIpAddressSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalIpAddressSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LocalIpAddressSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalIpAddressSelector.Merge(m, src)
}
func (m *LocalIpAddressSelector) XXX_Size() int {
	return m.Size()
}
func (m *LocalIpAddressSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalIpAddressSelector.DiscardUnknown(m)
}

var xxx_messageInfo_LocalIpAddressSelector proto.InternalMessageInfo

type isLocalIpAddressSelector_Type interface {
	isLocalIpAddressSelector_Type()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type LocalIpAddressSelector_Intf struct {
	Intf *InterfaceType `protobuf:"bytes,1,opt,name=intf,proto3,oneof" json:"intf,omitempty"`
}
type LocalIpAddressSelector_IpAddress struct {
	IpAddress *LocalIpAddressType `protobuf:"bytes,2,opt,name=ip_address,json=ipAddress,proto3,oneof" json:"ip_address,omitempty"`
}

func (*LocalIpAddressSelector_Intf) isLocalIpAddressSelector_Type()      {}
func (*LocalIpAddressSelector_IpAddress) isLocalIpAddressSelector_Type() {}

func (m *LocalIpAddressSelector) GetType() isLocalIpAddressSelector_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *LocalIpAddressSelector) GetIntf() *InterfaceType {
	if x, ok := m.GetType().(*LocalIpAddressSelector_Intf); ok {
		return x.Intf
	}
	return nil
}

func (m *LocalIpAddressSelector) GetIpAddress() *LocalIpAddressType {
	if x, ok := m.GetType().(*LocalIpAddressSelector_IpAddress); ok {
		return x.IpAddress
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LocalIpAddressSelector) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LocalIpAddressSelector_Intf)(nil),
		(*LocalIpAddressSelector_IpAddress)(nil),
	}
}

// Remote Node Atributes
//
// x-displayName: "Remote Node Attributes"
// Remote node attributes specify parameters needed to be configured for remote node
type RemoteNodeAttributes struct {
	// IP Address
	//
	// x-displayName: "IP Address"
	// IP address of remote node
	Ip *schema.IpAddressType `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
}

func (m *RemoteNodeAttributes) Reset()      { *m = RemoteNodeAttributes{} }
func (*RemoteNodeAttributes) ProtoMessage() {}
func (*RemoteNodeAttributes) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{5}
}
func (m *RemoteNodeAttributes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteNodeAttributes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RemoteNodeAttributes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteNodeAttributes.Merge(m, src)
}
func (m *RemoteNodeAttributes) XXX_Size() int {
	return m.Size()
}
func (m *RemoteNodeAttributes) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteNodeAttributes.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteNodeAttributes proto.InternalMessageInfo

func (m *RemoteNodeAttributes) GetIp() *schema.IpAddressType {
	if m != nil {
		return m.Ip
	}
	return nil
}

// Remote Endpoint Type
//
// x-displayName: "Remote Endpoint Type"
// Provides a map of ver node name to remote node attributes
// Ver node should use these attributes to configure as remote tunnel
type RemoteEndpointType struct {
	// Remote Endpoints
	//
	// x-displayName: "Remote Endpoints"
	// Map of remote attributes to which tunnel will be established on per site node basis
	// Every node can have a different attributes and IP address to connect to
	// Key is ver node name and value is Remote node attributes
	Endpoints map[string]*RemoteNodeAttributes `protobuf:"bytes,2,rep,name=endpoints,proto3" json:"endpoints,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *RemoteEndpointType) Reset()      { *m = RemoteEndpointType{} }
func (*RemoteEndpointType) ProtoMessage() {}
func (*RemoteEndpointType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{6}
}
func (m *RemoteEndpointType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteEndpointType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RemoteEndpointType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteEndpointType.Merge(m, src)
}
func (m *RemoteEndpointType) XXX_Size() int {
	return m.Size()
}
func (m *RemoteEndpointType) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteEndpointType.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteEndpointType proto.InternalMessageInfo

func (m *RemoteEndpointType) GetEndpoints() map[string]*RemoteNodeAttributes {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

// Remote IP Address Selector
//
// x-displayName: "Remote IP Address Selector"
// Defines the options to select remote ip address for tunnel object
// Options available are -
// 1. IP Address - Specifies the remote IP to which tunnel has to be connected
// 2. Remote endpoint - Is a map of IP address on per ver node basis
type RemoteIpAddressSelector struct {
	// Type
	//
	// x-displayName: "Type"
	// Options to select remote ip address
	//
	// Types that are valid to be assigned to Type:
	//	*RemoteIpAddressSelector_Ip
	//	*RemoteIpAddressSelector_Endpoints
	Type isRemoteIpAddressSelector_Type `protobuf_oneof:"type"`
}

func (m *RemoteIpAddressSelector) Reset()      { *m = RemoteIpAddressSelector{} }
func (*RemoteIpAddressSelector) ProtoMessage() {}
func (*RemoteIpAddressSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{7}
}
func (m *RemoteIpAddressSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteIpAddressSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RemoteIpAddressSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteIpAddressSelector.Merge(m, src)
}
func (m *RemoteIpAddressSelector) XXX_Size() int {
	return m.Size()
}
func (m *RemoteIpAddressSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteIpAddressSelector.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteIpAddressSelector proto.InternalMessageInfo

type isRemoteIpAddressSelector_Type interface {
	isRemoteIpAddressSelector_Type()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type RemoteIpAddressSelector_Ip struct {
	Ip *schema.IpAddressType `protobuf:"bytes,1,opt,name=ip,proto3,oneof" json:"ip,omitempty"`
}
type RemoteIpAddressSelector_Endpoints struct {
	Endpoints *RemoteEndpointType `protobuf:"bytes,2,opt,name=endpoints,proto3,oneof" json:"endpoints,omitempty"`
}

func (*RemoteIpAddressSelector_Ip) isRemoteIpAddressSelector_Type()        {}
func (*RemoteIpAddressSelector_Endpoints) isRemoteIpAddressSelector_Type() {}

func (m *RemoteIpAddressSelector) GetType() isRemoteIpAddressSelector_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *RemoteIpAddressSelector) GetIp() *schema.IpAddressType {
	if x, ok := m.GetType().(*RemoteIpAddressSelector_Ip); ok {
		return x.Ip
	}
	return nil
}

func (m *RemoteIpAddressSelector) GetEndpoints() *RemoteEndpointType {
	if x, ok := m.GetType().(*RemoteIpAddressSelector_Endpoints); ok {
		return x.Endpoints
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RemoteIpAddressSelector) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RemoteIpAddressSelector_Ip)(nil),
		(*RemoteIpAddressSelector_Endpoints)(nil),
	}
}

// Tunnel specification
//
// x-displayName: "Specification"
// Desired state of Tunnel
type GlobalSpecType struct {
	// Tunnel Type
	//
	// x-displayName: "Tunnel Type"
	// x-required
	// Tunnel type supported is IPSEC with pre-shared key (IPSEC_PSK)
	TunnelType TunnelType `protobuf:"varint,1,opt,name=tunnel_type,json=tunnelType,proto3,enum=ves.io.schema.tunnel.TunnelType" json:"tunnel_type,omitempty"`
	// Local IP Address selector
	//
	// x-displayName: "Local IP Address selector"
	// x-required
	// Selects local IP address configuration for tunnel
	LocalIp *LocalIpAddressSelector `protobuf:"bytes,7,opt,name=local_ip,json=localIp,proto3" json:"local_ip,omitempty"`
	// Remore IP Address Selector
	//
	// x-displayName: "Remote IP Address Selector"
	// x-required
	// Selects remote endpoint IP address configuration for tunnel
	RemoteIp *RemoteIpAddressSelector `protobuf:"bytes,8,opt,name=remote_ip,json=remoteIp,proto3" json:"remote_ip,omitempty"`
	// Tunnel Parameters
	//
	// x-displayName: "Tunnel Parameters"
	// Configuration for supported tunnel types
	Params *TunnelParams `protobuf:"bytes,6,opt,name=params,proto3" json:"params,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{8}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetTunnelType() TunnelType {
	if m != nil {
		return m.TunnelType
	}
	return IPSEC_PSK
}

func (m *GlobalSpecType) GetLocalIp() *LocalIpAddressSelector {
	if m != nil {
		return m.LocalIp
	}
	return nil
}

func (m *GlobalSpecType) GetRemoteIp() *RemoteIpAddressSelector {
	if m != nil {
		return m.RemoteIp
	}
	return nil
}

func (m *GlobalSpecType) GetParams() *TunnelParams {
	if m != nil {
		return m.Params
	}
	return nil
}

// Create tunnel
//
// x-displayName: "Create Tunnel"
// Create tunnel in a given namespace. If one already exist it will give a error.
type CreateSpecType struct {
	TunnelType TunnelType               `protobuf:"varint,1,opt,name=tunnel_type,json=tunnelType,proto3,enum=ves.io.schema.tunnel.TunnelType" json:"tunnel_type,omitempty"`
	LocalIp    *LocalIpAddressSelector  `protobuf:"bytes,7,opt,name=local_ip,json=localIp,proto3" json:"local_ip,omitempty"`
	RemoteIp   *RemoteIpAddressSelector `protobuf:"bytes,8,opt,name=remote_ip,json=remoteIp,proto3" json:"remote_ip,omitempty"`
	Params     *TunnelParams            `protobuf:"bytes,6,opt,name=params,proto3" json:"params,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{9}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

func (m *CreateSpecType) GetTunnelType() TunnelType {
	if m != nil {
		return m.TunnelType
	}
	return IPSEC_PSK
}

func (m *CreateSpecType) GetLocalIp() *LocalIpAddressSelector {
	if m != nil {
		return m.LocalIp
	}
	return nil
}

func (m *CreateSpecType) GetRemoteIp() *RemoteIpAddressSelector {
	if m != nil {
		return m.RemoteIp
	}
	return nil
}

func (m *CreateSpecType) GetParams() *TunnelParams {
	if m != nil {
		return m.Params
	}
	return nil
}

// Replace tunnel
//
// x-displayName: "Replace Tunnel"
// Replace tunnel in a given namespace.
type ReplaceSpecType struct {
	TunnelType TunnelType               `protobuf:"varint,1,opt,name=tunnel_type,json=tunnelType,proto3,enum=ves.io.schema.tunnel.TunnelType" json:"tunnel_type,omitempty"`
	LocalIp    *LocalIpAddressSelector  `protobuf:"bytes,7,opt,name=local_ip,json=localIp,proto3" json:"local_ip,omitempty"`
	RemoteIp   *RemoteIpAddressSelector `protobuf:"bytes,8,opt,name=remote_ip,json=remoteIp,proto3" json:"remote_ip,omitempty"`
	Params     *TunnelParams            `protobuf:"bytes,6,opt,name=params,proto3" json:"params,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{10}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

func (m *ReplaceSpecType) GetTunnelType() TunnelType {
	if m != nil {
		return m.TunnelType
	}
	return IPSEC_PSK
}

func (m *ReplaceSpecType) GetLocalIp() *LocalIpAddressSelector {
	if m != nil {
		return m.LocalIp
	}
	return nil
}

func (m *ReplaceSpecType) GetRemoteIp() *RemoteIpAddressSelector {
	if m != nil {
		return m.RemoteIp
	}
	return nil
}

func (m *ReplaceSpecType) GetParams() *TunnelParams {
	if m != nil {
		return m.Params
	}
	return nil
}

// Get tunnel
//
// x-displayName: "Get Tunnel"
// Get Tunnel in a given namespace.
type GetSpecType struct {
	TunnelType TunnelType               `protobuf:"varint,1,opt,name=tunnel_type,json=tunnelType,proto3,enum=ves.io.schema.tunnel.TunnelType" json:"tunnel_type,omitempty"`
	LocalIp    *LocalIpAddressSelector  `protobuf:"bytes,7,opt,name=local_ip,json=localIp,proto3" json:"local_ip,omitempty"`
	RemoteIp   *RemoteIpAddressSelector `protobuf:"bytes,8,opt,name=remote_ip,json=remoteIp,proto3" json:"remote_ip,omitempty"`
	Params     *TunnelParams            `protobuf:"bytes,6,opt,name=params,proto3" json:"params,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{11}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

func (m *GetSpecType) GetTunnelType() TunnelType {
	if m != nil {
		return m.TunnelType
	}
	return IPSEC_PSK
}

func (m *GetSpecType) GetLocalIp() *LocalIpAddressSelector {
	if m != nil {
		return m.LocalIp
	}
	return nil
}

func (m *GetSpecType) GetRemoteIp() *RemoteIpAddressSelector {
	if m != nil {
		return m.RemoteIp
	}
	return nil
}

func (m *GetSpecType) GetParams() *TunnelParams {
	if m != nil {
		return m.Params
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.tunnel.TunnelType", TunnelType_name, TunnelType_value)
	golang_proto.RegisterEnum("ves.io.schema.tunnel.TunnelType", TunnelType_name, TunnelType_value)
	proto.RegisterType((*IpsecTunnelParams)(nil), "ves.io.schema.tunnel.IpsecTunnelParams")
	golang_proto.RegisterType((*IpsecTunnelParams)(nil), "ves.io.schema.tunnel.IpsecTunnelParams")
	proto.RegisterType((*TunnelParams)(nil), "ves.io.schema.tunnel.TunnelParams")
	golang_proto.RegisterType((*TunnelParams)(nil), "ves.io.schema.tunnel.TunnelParams")
	proto.RegisterType((*InterfaceType)(nil), "ves.io.schema.tunnel.InterfaceType")
	golang_proto.RegisterType((*InterfaceType)(nil), "ves.io.schema.tunnel.InterfaceType")
	proto.RegisterType((*LocalIpAddressType)(nil), "ves.io.schema.tunnel.LocalIpAddressType")
	golang_proto.RegisterType((*LocalIpAddressType)(nil), "ves.io.schema.tunnel.LocalIpAddressType")
	proto.RegisterType((*LocalIpAddressSelector)(nil), "ves.io.schema.tunnel.LocalIpAddressSelector")
	golang_proto.RegisterType((*LocalIpAddressSelector)(nil), "ves.io.schema.tunnel.LocalIpAddressSelector")
	proto.RegisterType((*RemoteNodeAttributes)(nil), "ves.io.schema.tunnel.RemoteNodeAttributes")
	golang_proto.RegisterType((*RemoteNodeAttributes)(nil), "ves.io.schema.tunnel.RemoteNodeAttributes")
	proto.RegisterType((*RemoteEndpointType)(nil), "ves.io.schema.tunnel.RemoteEndpointType")
	golang_proto.RegisterType((*RemoteEndpointType)(nil), "ves.io.schema.tunnel.RemoteEndpointType")
	proto.RegisterMapType((map[string]*RemoteNodeAttributes)(nil), "ves.io.schema.tunnel.RemoteEndpointType.EndpointsEntry")
	golang_proto.RegisterMapType((map[string]*RemoteNodeAttributes)(nil), "ves.io.schema.tunnel.RemoteEndpointType.EndpointsEntry")
	proto.RegisterType((*RemoteIpAddressSelector)(nil), "ves.io.schema.tunnel.RemoteIpAddressSelector")
	golang_proto.RegisterType((*RemoteIpAddressSelector)(nil), "ves.io.schema.tunnel.RemoteIpAddressSelector")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.tunnel.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.tunnel.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.tunnel.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.tunnel.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.tunnel.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.tunnel.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.tunnel.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.tunnel.GetSpecType")
}

func init() { proto.RegisterFile("ves.io/schema/tunnel/types.proto", fileDescriptor_6fc6059a22f3fcf5) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/tunnel/types.proto", fileDescriptor_6fc6059a22f3fcf5)
}

var fileDescriptor_6fc6059a22f3fcf5 = []byte{
	// 1142 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0xc1, 0x6f, 0x1b, 0xc5,
	0x17, 0xde, 0x59, 0xaf, 0xdd, 0xf5, 0x38, 0xcd, 0x6f, 0x33, 0x8a, 0x7e, 0x75, 0x4d, 0xb5, 0x5a,
	0x96, 0x03, 0x21, 0x4a, 0xd6, 0x10, 0x50, 0x01, 0x4b, 0x94, 0x26, 0x25, 0x4a, 0xec, 0xa2, 0x10,
	0x6d, 0x2a, 0x0e, 0xf4, 0x60, 0xad, 0xed, 0xb1, 0xb3, 0x64, 0xbd, 0xb3, 0xda, 0x1d, 0xbb, 0xe4,
	0x80, 0x14, 0x71, 0x42, 0x3e, 0x21, 0x8e, 0xfd, 0x0b, 0x10, 0x5c, 0x11, 0x20, 0xec, 0x43, 0x84,
	0x84, 0x54, 0x2a, 0x81, 0x72, 0xcc, 0xb1, 0x71, 0x2e, 0xd0, 0x53, 0x0f, 0x70, 0x47, 0x33, 0xb3,
	0x4e, 0x58, 0x3b, 0x8d, 0x52, 0x8e, 0xa8, 0xb7, 0x9d, 0x79, 0xef, 0x7d, 0xef, 0xbd, 0xef, 0x7d,
	0xfb, 0xd6, 0x86, 0x46, 0x17, 0x47, 0x96, 0x4b, 0x8a, 0x51, 0x7d, 0x1b, 0xb7, 0x9d, 0x22, 0xed,
	0xf8, 0x3e, 0xf6, 0x8a, 0x74, 0x37, 0xc0, 0x91, 0x15, 0x84, 0x84, 0x12, 0x34, 0x2b, 0x3c, 0x2c,
	0xe1, 0x61, 0x09, 0x8f, 0xc2, 0x62, 0xcb, 0xa5, 0xdb, 0x9d, 0x9a, 0x55, 0x27, 0xed, 0x62, 0x8b,
	0xb4, 0x48, 0x91, 0x3b, 0xd7, 0x3a, 0x4d, 0x7e, 0xe2, 0x07, 0xfe, 0x24, 0x40, 0x0a, 0x57, 0x92,
	0x69, 0x7c, 0x4c, 0x63, 0xc3, 0x0b, 0x49, 0x03, 0x09, 0xa8, 0x4b, 0xfc, 0x38, 0x75, 0xe1, 0xea,
	0x58, 0x71, 0xa7, 0x55, 0x15, 0xae, 0x25, 0x4d, 0x5d, 0xc7, 0x73, 0x1b, 0x0e, 0xc5, 0xb1, 0x75,
	0xac, 0xab, 0xae, 0x8b, 0xef, 0x55, 0x13, 0xd0, 0xe6, 0x6d, 0x38, 0x53, 0x0e, 0x22, 0x5c, 0xbf,
	0xc3, 0xdb, 0xd9, 0x74, 0x42, 0xa7, 0x1d, 0xa1, 0xeb, 0x30, 0xeb, 0xb2, 0xcb, 0x6a, 0x10, 0xed,
	0xe4, 0x81, 0x01, 0xe6, 0x72, 0x4b, 0x57, 0xad, 0x64, 0xfb, 0x5b, 0xb8, 0x1e, 0x62, 0x7a, 0x67,
	0x37, 0xc0, 0xb6, 0xca, 0x7d, 0x37, 0xa3, 0x1d, 0xb3, 0x05, 0xa7, 0x12, 0x38, 0xef, 0xc2, 0x34,
	0xb7, 0xc5, 0x18, 0x2f, 0x5b, 0x67, 0x51, 0x68, 0x4d, 0xe4, 0x5f, 0x97, 0x6c, 0x11, 0xb7, 0xa2,
	0x41, 0x85, 0x35, 0x8b, 0xd4, 0xfd, 0x3e, 0x00, 0x07, 0x7d, 0x20, 0x57, 0x14, 0x55, 0xd6, 0x52,
	0xa6, 0x07, 0x2f, 0x97, 0x7d, 0x8a, 0xc3, 0xa6, 0x53, 0xc7, 0xac, 0x06, 0x74, 0x17, 0x42, 0x8f,
	0xd4, 0x1d, 0xaf, 0xea, 0xfa, 0xb4, 0x99, 0x07, 0x46, 0x6a, 0x2e, 0xb7, 0x74, 0x6d, 0x2c, 0xdd,
	0x07, 0xb5, 0x8f, 0x71, 0x9d, 0xda, 0xb8, 0xc9, 0x22, 0x56, 0xf4, 0xaf, 0x3f, 0x9d, 0xf1, 0x31,
	0xbd, 0x47, 0xc2, 0x1d, 0x16, 0x24, 0xb0, 0x7e, 0xfc, 0x63, 0x3f, 0x95, 0xfe, 0x12, 0xc8, 0x1a,
	0xb0, 0xb3, 0x1c, 0xaf, 0xec, 0xd3, 0xa6, 0xf9, 0x27, 0x80, 0xe8, 0x7d, 0x7e, 0x0a, 0x96, 0x1b,
	0x8d, 0x10, 0x47, 0x11, 0xcf, 0xf9, 0x0e, 0x84, 0x6e, 0x50, 0x75, 0xc4, 0x4d, 0xdc, 0xe2, 0x78,
	0xce, 0x44, 0xc4, 0xba, 0x64, 0x67, 0xdd, 0xd1, 0x05, 0x9a, 0x87, 0x8a, 0xd3, 0xa1, 0x24, 0x2f,
	0xf3, 0xc0, 0xd9, 0xb1, 0xc0, 0xd5, 0x76, 0x40, 0x77, 0xd7, 0x25, 0x9b, 0xfb, 0xa0, 0xbb, 0x70,
	0xb6, 0xeb, 0x86, 0xb4, 0xe3, 0x78, 0xd5, 0x51, 0xcd, 0x8c, 0x97, 0x7c, 0x8a, 0xc7, 0xbe, 0x32,
	0x16, 0xfb, 0xa1, 0x70, 0xdd, 0x10, 0x9e, 0x5b, 0xd8, 0xc3, 0x75, 0x4a, 0x42, 0x3e, 0x2b, 0xd4,
	0x4d, 0xd8, 0x38, 0x13, 0xe3, 0x24, 0x2b, 0x15, 0x45, 0x55, 0xb4, 0xb4, 0xf9, 0x1d, 0x80, 0xff,
	0x4f, 0xb6, 0x3d, 0x82, 0x42, 0x6f, 0x43, 0x25, 0x26, 0x9a, 0xe5, 0x7f, 0xe9, 0x29, 0x73, 0xfd,
	0xe7, 0x84, 0x58, 0x2b, 0x2c, 0x04, 0x95, 0x13, 0xac, 0x89, 0xe6, 0xe7, 0xce, 0x06, 0x98, 0xe4,
	0x3c, 0xc1, 0xe0, 0x44, 0xe1, 0xa9, 0x8a, 0xa2, 0xa6, 0x34, 0xc5, 0xa4, 0x70, 0xd6, 0xc6, 0x6d,
	0x42, 0xf1, 0x06, 0x69, 0xe0, 0x65, 0x4a, 0x43, 0xb7, 0xd6, 0xa1, 0x38, 0x42, 0x0b, 0x50, 0x76,
	0x83, 0x8b, 0x0c, 0xca, 0x96, 0xdd, 0xa0, 0x64, 0xfd, 0xd4, 0x07, 0x08, 0x6a, 0x30, 0x27, 0xb0,
	0x0c, 0x06, 0x86, 0xc0, 0x6b, 0x0f, 0xfb, 0x60, 0x16, 0x22, 0x08, 0xcb, 0x9b, 0x46, 0x1c, 0x51,
	0x50, 0x18, 0xae, 0xf9, 0x5b, 0x0a, 0x22, 0xe1, 0xba, 0xea, 0x37, 0x02, 0xe2, 0xfa, 0xfc, 0xed,
	0x40, 0xbf, 0xca, 0x30, 0x8b, 0xe3, 0x0b, 0xd6, 0x2f, 0x53, 0xe6, 0x9b, 0x67, 0xf7, 0x3b, 0x19,
	0x6d, 0x8d, 0x0e, 0xd1, 0xaa, 0x4f, 0xc3, 0xdd, 0x95, 0xbf, 0x00, 0x53, 0xe8, 0xd4, 0x7d, 0x90,
	0x35, 0x2f, 0x85, 0x69, 0x0d, 0xe4, 0xf7, 0x64, 0x76, 0x91, 0xb9, 0x0f, 0x52, 0xda, 0x1e, 0x18,
	0x3e, 0xfa, 0x39, 0xf5, 0x5e, 0x6f, 0x00, 0x6e, 0xa2, 0x1b, 0x8f, 0xfb, 0xa0, 0xc4, 0x0a, 0x36,
	0x9a, 0x24, 0x34, 0x62, 0x78, 0x63, 0x2b, 0xc0, 0x75, 0xb7, 0xe9, 0xe2, 0x86, 0xe1, 0x44, 0x46,
	0xe4, 0x52, 0x5c, 0xf2, 0x49, 0x03, 0x2f, 0xf0, 0x47, 0xc3, 0x8d, 0x0c, 0xb1, 0x19, 0x1c, 0xcf,
	0x60, 0x40, 0xd3, 0xbd, 0x01, 0x80, 0x48, 0x1d, 0xf6, 0x81, 0xc2, 0x80, 0xd8, 0x15, 0xec, 0x0d,
	0x40, 0x06, 0x29, 0x0f, 0xfa, 0x40, 0x62, 0xc7, 0x4c, 0x6f, 0x00, 0x64, 0x95, 0x67, 0x2d, 0xf5,
	0x06, 0xe0, 0x7a, 0xe1, 0x8d, 0xc7, 0x7d, 0xf0, 0x6a, 0xcc, 0x96, 0x73, 0x42, 0xbb, 0x28, 0x61,
	0x1b, 0xc7, 0x65, 0x18, 0xc4, 0x37, 0x1c, 0xa3, 0xe5, 0x76, 0xb1, 0x6f, 0xf8, 0x31, 0xb0, 0xd6,
	0x1b, 0x80, 0xa9, 0x02, 0x1c, 0xf6, 0x41, 0x46, 0xec, 0x95, 0x93, 0x6c, 0x05, 0x85, 0xcd, 0xd6,
	0x3e, 0x65, 0xb0, 0xb0, 0x0d, 0xa7, 0x93, 0xa4, 0x20, 0x0d, 0xa6, 0x76, 0xf0, 0x2e, 0x9f, 0x6b,
	0xd6, 0x66, 0x8f, 0xe8, 0x26, 0x4c, 0x77, 0x1d, 0xaf, 0x83, 0x63, 0x79, 0xcd, 0x9f, 0x47, 0x77,
	0x52, 0x23, 0xb6, 0x08, 0x2c, 0xc9, 0x6f, 0x01, 0xf3, 0x1b, 0x00, 0xaf, 0x08, 0x9f, 0xc9, 0x17,
	0xc0, 0xba, 0xa8, 0x94, 0xd6, 0x25, 0x26, 0x26, 0xb4, 0x9e, 0x14, 0xc1, 0x39, 0xa2, 0x9f, 0x14,
	0x01, 0x13, 0xfd, 0x49, 0xf0, 0x53, 0x45, 0xff, 0x8b, 0x0c, 0xa7, 0xd7, 0x3c, 0x52, 0x73, 0x3c,
	0x36, 0x66, 0x2e, 0xbd, 0x0d, 0x98, 0x13, 0xa0, 0x62, 0x59, 0xb0, 0x6a, 0xa7, 0x97, 0x8c, 0xb3,
	0xd3, 0x8a, 0xfd, 0xcb, 0xf7, 0x41, 0x8e, 0x4b, 0xea, 0x33, 0x90, 0x2a, 0x00, 0xc9, 0x86, 0xf4,
	0xc4, 0x80, 0xd6, 0xa0, 0x1a, 0x2f, 0xd9, 0x20, 0x7f, 0x89, 0xf7, 0xb0, 0x70, 0x91, 0x17, 0x77,
	0x44, 0x9a, 0x7d, 0x49, 0xac, 0xd4, 0x00, 0x55, 0x60, 0x36, 0xe4, 0x6d, 0x32, 0x24, 0x95, 0x23,
	0x2d, 0x9e, 0xc7, 0xc6, 0x24, 0x94, 0x1a, 0xc6, 0x06, 0x54, 0x82, 0x99, 0x80, 0x7f, 0x35, 0xf2,
	0x19, 0x0e, 0x64, 0x9e, 0xd7, 0x9f, 0xf8, 0xbe, 0xd8, 0x71, 0x84, 0xf8, 0x98, 0x08, 0xfe, 0xc4,
	0xce, 0xab, 0x28, 0x6a, 0x5a, 0xcb, 0x98, 0xdf, 0xcb, 0x70, 0xfa, 0x56, 0x88, 0x1d, 0x8a, 0x4f,
	0xb8, 0x5c, 0xfe, 0x57, 0x5c, 0xfe, 0xa7, 0xe9, 0x2b, 0xcd, 0x3c, 0xbc, 0x31, 0x26, 0x39, 0xf3,
	0x07, 0x19, 0xfe, 0xcf, 0xc6, 0x81, 0xe7, 0xd4, 0x9f, 0x53, 0xf7, 0x8c, 0xd4, 0x7d, 0x2b, 0xc3,
	0xdc, 0x1a, 0xa6, 0xcf, 0x69, 0x7b, 0x26, 0xda, 0xe6, 0x5f, 0x84, 0xf0, 0xb4, 0x7b, 0x74, 0x19,
	0x66, 0xcb, 0x9b, 0x5b, 0xab, 0xb7, 0xaa, 0x9b, 0x5b, 0xb7, 0x35, 0xc9, 0x54, 0x54, 0xa0, 0x81,
	0x95, 0xcf, 0xc1, 0xc1, 0x91, 0x2e, 0x1d, 0x1e, 0xe9, 0xd2, 0x93, 0x23, 0x1d, 0xec, 0x0d, 0x75,
	0xf0, 0xd5, 0x50, 0x07, 0x0f, 0x86, 0x3a, 0x38, 0x18, 0xea, 0xe0, 0x70, 0xa8, 0x83, 0x47, 0x43,
	0x1d, 0xfc, 0x3e, 0xd4, 0xa5, 0x27, 0x43, 0x1d, 0x7c, 0x71, 0xac, 0x4b, 0xfb, 0xc7, 0x3a, 0x38,
	0x38, 0xd6, 0xa5, 0xc3, 0x63, 0x5d, 0xfa, 0xa8, 0xd2, 0x22, 0xc1, 0x4e, 0xcb, 0xea, 0x12, 0x8f,
	0xe2, 0x30, 0x74, 0xac, 0x4e, 0x54, 0xe4, 0x0f, 0x4d, 0x12, 0xb6, 0x17, 0x83, 0x90, 0x74, 0xdd,
	0x06, 0x0e, 0x17, 0x47, 0xe6, 0x62, 0x50, 0x6b, 0x91, 0x22, 0xfe, 0x84, 0xc6, 0xbf, 0xb9, 0x13,
	0x7f, 0x28, 0x6a, 0x19, 0xfe, 0xab, 0xfb, 0xf5, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x08, 0xaf,
	0xac, 0xd8, 0x6f, 0x0c, 0x00, 0x00,
}

func (x TunnelType) String() string {
	s, ok := TunnelType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *IpsecTunnelParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpsecTunnelParams)
	if !ok {
		that2, ok := that.(IpsecTunnelParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpsecPsk.Equal(that1.IpsecPsk) {
		return false
	}
	return true
}
func (this *TunnelParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TunnelParams)
	if !ok {
		that2, ok := that.(TunnelParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Type == nil {
		if this.Type != nil {
			return false
		}
	} else if this.Type == nil {
		return false
	} else if !this.Type.Equal(that1.Type) {
		return false
	}
	return true
}
func (this *TunnelParams_Ipsec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TunnelParams_Ipsec)
	if !ok {
		that2, ok := that.(TunnelParams_Ipsec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipsec.Equal(that1.Ipsec) {
		return false
	}
	return true
}
func (this *InterfaceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceType)
	if !ok {
		that2, ok := that.(InterfaceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.LocalIntf) != len(that1.LocalIntf) {
		return false
	}
	for i := range this.LocalIntf {
		if !this.LocalIntf[i].Equal(that1.LocalIntf[i]) {
			return false
		}
	}
	return true
}
func (this *LocalIpAddressType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalIpAddressType)
	if !ok {
		that2, ok := that.(LocalIpAddressType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Type == nil {
		if this.Type != nil {
			return false
		}
	} else if this.Type == nil {
		return false
	} else if !this.Type.Equal(that1.Type) {
		return false
	}
	if !this.VirtualNetworkType.Equal(that1.VirtualNetworkType) {
		return false
	}
	return true
}
func (this *LocalIpAddressType_IpAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalIpAddressType_IpAddress)
	if !ok {
		that2, ok := that.(LocalIpAddressType_IpAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpAddress.Equal(that1.IpAddress) {
		return false
	}
	return true
}
func (this *LocalIpAddressType_Auto) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalIpAddressType_Auto)
	if !ok {
		that2, ok := that.(LocalIpAddressType_Auto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Auto.Equal(that1.Auto) {
		return false
	}
	return true
}
func (this *LocalIpAddressSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalIpAddressSelector)
	if !ok {
		that2, ok := that.(LocalIpAddressSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Type == nil {
		if this.Type != nil {
			return false
		}
	} else if this.Type == nil {
		return false
	} else if !this.Type.Equal(that1.Type) {
		return false
	}
	return true
}
func (this *LocalIpAddressSelector_Intf) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalIpAddressSelector_Intf)
	if !ok {
		that2, ok := that.(LocalIpAddressSelector_Intf)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Intf.Equal(that1.Intf) {
		return false
	}
	return true
}
func (this *LocalIpAddressSelector_IpAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalIpAddressSelector_IpAddress)
	if !ok {
		that2, ok := that.(LocalIpAddressSelector_IpAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpAddress.Equal(that1.IpAddress) {
		return false
	}
	return true
}
func (this *RemoteNodeAttributes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemoteNodeAttributes)
	if !ok {
		that2, ok := that.(RemoteNodeAttributes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ip.Equal(that1.Ip) {
		return false
	}
	return true
}
func (this *RemoteEndpointType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemoteEndpointType)
	if !ok {
		that2, ok := that.(RemoteEndpointType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Endpoints) != len(that1.Endpoints) {
		return false
	}
	for i := range this.Endpoints {
		if !this.Endpoints[i].Equal(that1.Endpoints[i]) {
			return false
		}
	}
	return true
}
func (this *RemoteIpAddressSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemoteIpAddressSelector)
	if !ok {
		that2, ok := that.(RemoteIpAddressSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Type == nil {
		if this.Type != nil {
			return false
		}
	} else if this.Type == nil {
		return false
	} else if !this.Type.Equal(that1.Type) {
		return false
	}
	return true
}
func (this *RemoteIpAddressSelector_Ip) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemoteIpAddressSelector_Ip)
	if !ok {
		that2, ok := that.(RemoteIpAddressSelector_Ip)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ip.Equal(that1.Ip) {
		return false
	}
	return true
}
func (this *RemoteIpAddressSelector_Endpoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemoteIpAddressSelector_Endpoints)
	if !ok {
		that2, ok := that.(RemoteIpAddressSelector_Endpoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Endpoints.Equal(that1.Endpoints) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TunnelType != that1.TunnelType {
		return false
	}
	if !this.LocalIp.Equal(that1.LocalIp) {
		return false
	}
	if !this.RemoteIp.Equal(that1.RemoteIp) {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TunnelType != that1.TunnelType {
		return false
	}
	if !this.LocalIp.Equal(that1.LocalIp) {
		return false
	}
	if !this.RemoteIp.Equal(that1.RemoteIp) {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TunnelType != that1.TunnelType {
		return false
	}
	if !this.LocalIp.Equal(that1.LocalIp) {
		return false
	}
	if !this.RemoteIp.Equal(that1.RemoteIp) {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TunnelType != that1.TunnelType {
		return false
	}
	if !this.LocalIp.Equal(that1.LocalIp) {
		return false
	}
	if !this.RemoteIp.Equal(that1.RemoteIp) {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	return true
}
func (this *IpsecTunnelParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tunnel.IpsecTunnelParams{")
	if this.IpsecPsk != nil {
		s = append(s, "IpsecPsk: "+fmt.Sprintf("%#v", this.IpsecPsk)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TunnelParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tunnel.TunnelParams{")
	if this.Type != nil {
		s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TunnelParams_Ipsec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.TunnelParams_Ipsec{` +
		`Ipsec:` + fmt.Sprintf("%#v", this.Ipsec) + `}`}, ", ")
	return s
}
func (this *InterfaceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tunnel.InterfaceType{")
	if this.LocalIntf != nil {
		s = append(s, "LocalIntf: "+fmt.Sprintf("%#v", this.LocalIntf)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LocalIpAddressType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tunnel.LocalIpAddressType{")
	if this.Type != nil {
		s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	}
	if this.VirtualNetworkType != nil {
		s = append(s, "VirtualNetworkType: "+fmt.Sprintf("%#v", this.VirtualNetworkType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LocalIpAddressType_IpAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.LocalIpAddressType_IpAddress{` +
		`IpAddress:` + fmt.Sprintf("%#v", this.IpAddress) + `}`}, ", ")
	return s
}
func (this *LocalIpAddressType_Auto) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.LocalIpAddressType_Auto{` +
		`Auto:` + fmt.Sprintf("%#v", this.Auto) + `}`}, ", ")
	return s
}
func (this *LocalIpAddressSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tunnel.LocalIpAddressSelector{")
	if this.Type != nil {
		s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LocalIpAddressSelector_Intf) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.LocalIpAddressSelector_Intf{` +
		`Intf:` + fmt.Sprintf("%#v", this.Intf) + `}`}, ", ")
	return s
}
func (this *LocalIpAddressSelector_IpAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.LocalIpAddressSelector_IpAddress{` +
		`IpAddress:` + fmt.Sprintf("%#v", this.IpAddress) + `}`}, ", ")
	return s
}
func (this *RemoteNodeAttributes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tunnel.RemoteNodeAttributes{")
	if this.Ip != nil {
		s = append(s, "Ip: "+fmt.Sprintf("%#v", this.Ip)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RemoteEndpointType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tunnel.RemoteEndpointType{")
	keysForEndpoints := make([]string, 0, len(this.Endpoints))
	for k, _ := range this.Endpoints {
		keysForEndpoints = append(keysForEndpoints, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEndpoints)
	mapStringForEndpoints := "map[string]*RemoteNodeAttributes{"
	for _, k := range keysForEndpoints {
		mapStringForEndpoints += fmt.Sprintf("%#v: %#v,", k, this.Endpoints[k])
	}
	mapStringForEndpoints += "}"
	if this.Endpoints != nil {
		s = append(s, "Endpoints: "+mapStringForEndpoints+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RemoteIpAddressSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tunnel.RemoteIpAddressSelector{")
	if this.Type != nil {
		s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RemoteIpAddressSelector_Ip) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.RemoteIpAddressSelector_Ip{` +
		`Ip:` + fmt.Sprintf("%#v", this.Ip) + `}`}, ", ")
	return s
}
func (this *RemoteIpAddressSelector_Endpoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.RemoteIpAddressSelector_Endpoints{` +
		`Endpoints:` + fmt.Sprintf("%#v", this.Endpoints) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tunnel.GlobalSpecType{")
	s = append(s, "TunnelType: "+fmt.Sprintf("%#v", this.TunnelType)+",\n")
	if this.LocalIp != nil {
		s = append(s, "LocalIp: "+fmt.Sprintf("%#v", this.LocalIp)+",\n")
	}
	if this.RemoteIp != nil {
		s = append(s, "RemoteIp: "+fmt.Sprintf("%#v", this.RemoteIp)+",\n")
	}
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tunnel.CreateSpecType{")
	s = append(s, "TunnelType: "+fmt.Sprintf("%#v", this.TunnelType)+",\n")
	if this.LocalIp != nil {
		s = append(s, "LocalIp: "+fmt.Sprintf("%#v", this.LocalIp)+",\n")
	}
	if this.RemoteIp != nil {
		s = append(s, "RemoteIp: "+fmt.Sprintf("%#v", this.RemoteIp)+",\n")
	}
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tunnel.ReplaceSpecType{")
	s = append(s, "TunnelType: "+fmt.Sprintf("%#v", this.TunnelType)+",\n")
	if this.LocalIp != nil {
		s = append(s, "LocalIp: "+fmt.Sprintf("%#v", this.LocalIp)+",\n")
	}
	if this.RemoteIp != nil {
		s = append(s, "RemoteIp: "+fmt.Sprintf("%#v", this.RemoteIp)+",\n")
	}
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tunnel.GetSpecType{")
	s = append(s, "TunnelType: "+fmt.Sprintf("%#v", this.TunnelType)+",\n")
	if this.LocalIp != nil {
		s = append(s, "LocalIp: "+fmt.Sprintf("%#v", this.LocalIp)+",\n")
	}
	if this.RemoteIp != nil {
		s = append(s, "RemoteIp: "+fmt.Sprintf("%#v", this.RemoteIp)+",\n")
	}
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *IpsecTunnelParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecTunnelParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpsecTunnelParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IpsecPsk != nil {
		{
			size, err := m.IpsecPsk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TunnelParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size := m.Type.Size()
			i -= size
			if _, err := m.Type.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *TunnelParams_Ipsec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelParams_Ipsec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ipsec != nil {
		{
			size, err := m.Ipsec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *InterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LocalIntf) > 0 {
		for iNdEx := len(m.LocalIntf) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LocalIntf[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LocalIpAddressType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalIpAddressType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalIpAddressType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VirtualNetworkType != nil {
		{
			size, err := m.VirtualNetworkType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != nil {
		{
			size := m.Type.Size()
			i -= size
			if _, err := m.Type.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *LocalIpAddressType_IpAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalIpAddressType_IpAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpAddress != nil {
		{
			size, err := m.IpAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *LocalIpAddressType_Auto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalIpAddressType_Auto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Auto != nil {
		{
			size, err := m.Auto.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *LocalIpAddressSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalIpAddressSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalIpAddressSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size := m.Type.Size()
			i -= size
			if _, err := m.Type.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *LocalIpAddressSelector_Intf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalIpAddressSelector_Intf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Intf != nil {
		{
			size, err := m.Intf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *LocalIpAddressSelector_IpAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalIpAddressSelector_IpAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpAddress != nil {
		{
			size, err := m.IpAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *RemoteNodeAttributes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteNodeAttributes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteNodeAttributes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ip != nil {
		{
			size, err := m.Ip.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemoteEndpointType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteEndpointType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteEndpointType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Endpoints) > 0 {
		keysForEndpoints := make([]string, 0, len(m.Endpoints))
		for k := range m.Endpoints {
			keysForEndpoints = append(keysForEndpoints, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForEndpoints)
		for iNdEx := len(keysForEndpoints) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Endpoints[string(keysForEndpoints[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTypes(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForEndpoints[iNdEx])
			copy(dAtA[i:], keysForEndpoints[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForEndpoints[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *RemoteIpAddressSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteIpAddressSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteIpAddressSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size := m.Type.Size()
			i -= size
			if _, err := m.Type.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RemoteIpAddressSelector_Ip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteIpAddressSelector_Ip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ip != nil {
		{
			size, err := m.Ip.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *RemoteIpAddressSelector_Endpoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteIpAddressSelector_Endpoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Endpoints != nil {
		{
			size, err := m.Endpoints.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RemoteIp != nil {
		{
			size, err := m.RemoteIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.LocalIp != nil {
		{
			size, err := m.LocalIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.TunnelType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RemoteIp != nil {
		{
			size, err := m.RemoteIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.LocalIp != nil {
		{
			size, err := m.LocalIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.TunnelType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RemoteIp != nil {
		{
			size, err := m.RemoteIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.LocalIp != nil {
		{
			size, err := m.LocalIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.TunnelType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RemoteIp != nil {
		{
			size, err := m.RemoteIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.LocalIp != nil {
		{
			size, err := m.LocalIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.TunnelType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *IpsecTunnelParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpsecPsk != nil {
		l = m.IpsecPsk.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *TunnelParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *TunnelParams_Ipsec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ipsec != nil {
		l = m.Ipsec.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *InterfaceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LocalIntf) > 0 {
		for _, e := range m.LocalIntf {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *LocalIpAddressType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	if m.VirtualNetworkType != nil {
		l = m.VirtualNetworkType.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *LocalIpAddressType_IpAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpAddress != nil {
		l = m.IpAddress.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LocalIpAddressType_Auto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Auto != nil {
		l = m.Auto.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LocalIpAddressSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *LocalIpAddressSelector_Intf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Intf != nil {
		l = m.Intf.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LocalIpAddressSelector_IpAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpAddress != nil {
		l = m.IpAddress.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RemoteNodeAttributes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ip != nil {
		l = m.Ip.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RemoteEndpointType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Endpoints) > 0 {
		for k, v := range m.Endpoints {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RemoteIpAddressSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *RemoteIpAddressSelector_Ip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ip != nil {
		l = m.Ip.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RemoteIpAddressSelector_Endpoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Endpoints != nil {
		l = m.Endpoints.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TunnelType != 0 {
		n += 1 + sovTypes(uint64(m.TunnelType))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LocalIp != nil {
		l = m.LocalIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RemoteIp != nil {
		l = m.RemoteIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TunnelType != 0 {
		n += 1 + sovTypes(uint64(m.TunnelType))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LocalIp != nil {
		l = m.LocalIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RemoteIp != nil {
		l = m.RemoteIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TunnelType != 0 {
		n += 1 + sovTypes(uint64(m.TunnelType))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LocalIp != nil {
		l = m.LocalIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RemoteIp != nil {
		l = m.RemoteIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TunnelType != 0 {
		n += 1 + sovTypes(uint64(m.TunnelType))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LocalIp != nil {
		l = m.LocalIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RemoteIp != nil {
		l = m.RemoteIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *IpsecTunnelParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpsecTunnelParams{`,
		`IpsecPsk:` + strings.Replace(fmt.Sprintf("%v", this.IpsecPsk), "SecretType", "schema.SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TunnelParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TunnelParams{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TunnelParams_Ipsec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TunnelParams_Ipsec{`,
		`Ipsec:` + strings.Replace(fmt.Sprintf("%v", this.Ipsec), "IpsecTunnelParams", "IpsecTunnelParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLocalIntf := "[]*ObjectRefType{"
	for _, f := range this.LocalIntf {
		repeatedStringForLocalIntf += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForLocalIntf += "}"
	s := strings.Join([]string{`&InterfaceType{`,
		`LocalIntf:` + repeatedStringForLocalIntf + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalIpAddressType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalIpAddressType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`VirtualNetworkType:` + strings.Replace(fmt.Sprintf("%v", this.VirtualNetworkType), "VirtualNetworkSelectorType", "schema.VirtualNetworkSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalIpAddressType_IpAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalIpAddressType_IpAddress{`,
		`IpAddress:` + strings.Replace(fmt.Sprintf("%v", this.IpAddress), "IpAddressType", "schema.IpAddressType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalIpAddressType_Auto) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalIpAddressType_Auto{`,
		`Auto:` + strings.Replace(fmt.Sprintf("%v", this.Auto), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalIpAddressSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalIpAddressSelector{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalIpAddressSelector_Intf) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalIpAddressSelector_Intf{`,
		`Intf:` + strings.Replace(fmt.Sprintf("%v", this.Intf), "InterfaceType", "InterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalIpAddressSelector_IpAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalIpAddressSelector_IpAddress{`,
		`IpAddress:` + strings.Replace(fmt.Sprintf("%v", this.IpAddress), "LocalIpAddressType", "LocalIpAddressType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RemoteNodeAttributes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RemoteNodeAttributes{`,
		`Ip:` + strings.Replace(fmt.Sprintf("%v", this.Ip), "IpAddressType", "schema.IpAddressType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RemoteEndpointType) String() string {
	if this == nil {
		return "nil"
	}
	keysForEndpoints := make([]string, 0, len(this.Endpoints))
	for k, _ := range this.Endpoints {
		keysForEndpoints = append(keysForEndpoints, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEndpoints)
	mapStringForEndpoints := "map[string]*RemoteNodeAttributes{"
	for _, k := range keysForEndpoints {
		mapStringForEndpoints += fmt.Sprintf("%v: %v,", k, this.Endpoints[k])
	}
	mapStringForEndpoints += "}"
	s := strings.Join([]string{`&RemoteEndpointType{`,
		`Endpoints:` + mapStringForEndpoints + `,`,
		`}`,
	}, "")
	return s
}
func (this *RemoteIpAddressSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RemoteIpAddressSelector{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RemoteIpAddressSelector_Ip) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RemoteIpAddressSelector_Ip{`,
		`Ip:` + strings.Replace(fmt.Sprintf("%v", this.Ip), "IpAddressType", "schema.IpAddressType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RemoteIpAddressSelector_Endpoints) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RemoteIpAddressSelector_Endpoints{`,
		`Endpoints:` + strings.Replace(fmt.Sprintf("%v", this.Endpoints), "RemoteEndpointType", "RemoteEndpointType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`TunnelType:` + fmt.Sprintf("%v", this.TunnelType) + `,`,
		`Params:` + strings.Replace(this.Params.String(), "TunnelParams", "TunnelParams", 1) + `,`,
		`LocalIp:` + strings.Replace(this.LocalIp.String(), "LocalIpAddressSelector", "LocalIpAddressSelector", 1) + `,`,
		`RemoteIp:` + strings.Replace(this.RemoteIp.String(), "RemoteIpAddressSelector", "RemoteIpAddressSelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`TunnelType:` + fmt.Sprintf("%v", this.TunnelType) + `,`,
		`Params:` + strings.Replace(this.Params.String(), "TunnelParams", "TunnelParams", 1) + `,`,
		`LocalIp:` + strings.Replace(this.LocalIp.String(), "LocalIpAddressSelector", "LocalIpAddressSelector", 1) + `,`,
		`RemoteIp:` + strings.Replace(this.RemoteIp.String(), "RemoteIpAddressSelector", "RemoteIpAddressSelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`TunnelType:` + fmt.Sprintf("%v", this.TunnelType) + `,`,
		`Params:` + strings.Replace(this.Params.String(), "TunnelParams", "TunnelParams", 1) + `,`,
		`LocalIp:` + strings.Replace(this.LocalIp.String(), "LocalIpAddressSelector", "LocalIpAddressSelector", 1) + `,`,
		`RemoteIp:` + strings.Replace(this.RemoteIp.String(), "RemoteIpAddressSelector", "RemoteIpAddressSelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`TunnelType:` + fmt.Sprintf("%v", this.TunnelType) + `,`,
		`Params:` + strings.Replace(this.Params.String(), "TunnelParams", "TunnelParams", 1) + `,`,
		`LocalIp:` + strings.Replace(this.LocalIp.String(), "LocalIpAddressSelector", "LocalIpAddressSelector", 1) + `,`,
		`RemoteIp:` + strings.Replace(this.RemoteIp.String(), "RemoteIpAddressSelector", "RemoteIpAddressSelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *IpsecTunnelParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecTunnelParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecTunnelParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpsecPsk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpsecPsk == nil {
				m.IpsecPsk = &schema.SecretType{}
			}
			if err := m.IpsecPsk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipsec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IpsecTunnelParams{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &TunnelParams_Ipsec{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalIntf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalIntf = append(m.LocalIntf, &schema.ObjectRefType{})
			if err := m.LocalIntf[len(m.LocalIntf)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalIpAddressType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalIpAddressType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalIpAddressType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.IpAddressType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &LocalIpAddressType_IpAddress{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auto", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &LocalIpAddressType_Auto{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualNetworkType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualNetworkType == nil {
				m.VirtualNetworkType = &schema.VirtualNetworkSelectorType{}
			}
			if err := m.VirtualNetworkType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalIpAddressSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalIpAddressSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalIpAddressSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &LocalIpAddressSelector_Intf{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LocalIpAddressType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &LocalIpAddressSelector_IpAddress{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteNodeAttributes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteNodeAttributes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteNodeAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ip == nil {
				m.Ip = &schema.IpAddressType{}
			}
			if err := m.Ip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteEndpointType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteEndpointType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteEndpointType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endpoints == nil {
				m.Endpoints = make(map[string]*RemoteNodeAttributes)
			}
			var mapkey string
			var mapvalue *RemoteNodeAttributes
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RemoteNodeAttributes{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Endpoints[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteIpAddressSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteIpAddressSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteIpAddressSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.IpAddressType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &RemoteIpAddressSelector_Ip{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RemoteEndpointType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &RemoteIpAddressSelector_Endpoints{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelType", wireType)
			}
			m.TunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelType |= TunnelType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &TunnelParams{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalIp == nil {
				m.LocalIp = &LocalIpAddressSelector{}
			}
			if err := m.LocalIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoteIp == nil {
				m.RemoteIp = &RemoteIpAddressSelector{}
			}
			if err := m.RemoteIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelType", wireType)
			}
			m.TunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelType |= TunnelType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &TunnelParams{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalIp == nil {
				m.LocalIp = &LocalIpAddressSelector{}
			}
			if err := m.LocalIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoteIp == nil {
				m.RemoteIp = &RemoteIpAddressSelector{}
			}
			if err := m.RemoteIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelType", wireType)
			}
			m.TunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelType |= TunnelType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &TunnelParams{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalIp == nil {
				m.LocalIp = &LocalIpAddressSelector{}
			}
			if err := m.LocalIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoteIp == nil {
				m.RemoteIp = &RemoteIpAddressSelector{}
			}
			if err := m.RemoteIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelType", wireType)
			}
			m.TunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelType |= TunnelType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &TunnelParams{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalIp == nil {
				m.LocalIp = &LocalIpAddressSelector{}
			}
			if err := m.LocalIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoteIp == nil {
				m.RemoteIp = &RemoteIpAddressSelector{}
			}
			if err := m.RemoteIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
