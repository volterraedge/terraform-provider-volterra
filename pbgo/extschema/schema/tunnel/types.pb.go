// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/tunnel/types.proto

package tunnel

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AWS TGW VPN Tunnel Type
//
// x-displayName: "AWS TGW VPN Tunnel Type"
// This defines AWS TGW VPN Tunnel type for which the config exists
type DeploymentVPNTunnelType int32

const (
	// x-displayName: "VPN Tunnel Hub"
	// VPN Tunnel Type - HUB
	HUB DeploymentVPNTunnelType = 0
	// x-displayName: "VPN Tunnel Services"
	// VPN Tunnel Type - Services
	SERVICES DeploymentVPNTunnelType = 1
)

var DeploymentVPNTunnelType_name = map[int32]string{
	0: "HUB",
	1: "SERVICES",
}

var DeploymentVPNTunnelType_value = map[string]int32{
	"HUB":      0,
	"SERVICES": 1,
}

func (DeploymentVPNTunnelType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{0}
}

// Tunnel Type
//
// x-displayName: "Tunnel Type"
// Supported tunnel types are IPSec
type TunnelType int32

const (
	// x-displayName: "IPSEC with PSK"
	// IPSEC tunnel type with PSK
	IPSEC_PSK TunnelType = 0
	// x-displayName: "GRE"
	// GRE tunnel type
	GRE TunnelType = 2
)

var TunnelType_name = map[int32]string{
	0: "IPSEC_PSK",
	2: "GRE",
}

var TunnelType_value = map[string]int32{
	"IPSEC_PSK": 0,
	"GRE":       2,
}

func (TunnelType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{1}
}

// IKE proposal
//
// x-displayName: "IKE Proposal Selection"
// Set of Encryption, Authentication, PRF and DH groups to be used for establishing IKE connection with peer
type IKEProposal struct {
	//Encryption Algorithms
	//
	// x-displayName: "Configure Encryption Algorithms"
	// Select Encrytion algorithms for IKE SA.
	EncryptionAlgos []schema.EncryptionAlgorithm `protobuf:"varint,1,rep,packed,name=encryption_algos,json=encryptionAlgos,proto3,enum=ves.io.schema.EncryptionAlgorithm" json:"encryption_algos,omitempty"`
	// Authentication Algorithms
	//
	// x-displayName: "Configure Authentication Algorithms"
	// Select Authentication algorithms for IKE SA.
	AuthenticationAlgos []schema.AuthenticationAlgorithm `protobuf:"varint,2,rep,packed,name=authentication_algos,json=authenticationAlgos,proto3,enum=ves.io.schema.AuthenticationAlgorithm" json:"authentication_algos,omitempty"`
	// PseudoRandomFunction
	//
	// x-displayName: "Configure PseudoRandomFunction"
	// Select PseudoRandomFunction for IKE SA.
	Prf []schema.PseudoRandomFunction `protobuf:"varint,3,rep,packed,name=prf,proto3,enum=ves.io.schema.PseudoRandomFunction" json:"prf,omitempty"`
	// DiffieHellman Group
	//
	// x-displayName: "Configure DH group"
	// Select DH Group for IKE SA.
	DhGroups []schema.DHGroup `protobuf:"varint,4,rep,packed,name=dh_groups,json=dhGroups,proto3,enum=ves.io.schema.DHGroup" json:"dh_groups,omitempty"`
}

func (m *IKEProposal) Reset()      { *m = IKEProposal{} }
func (*IKEProposal) ProtoMessage() {}
func (*IKEProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{0}
}
func (m *IKEProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IKEProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IKEProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IKEProposal.Merge(m, src)
}
func (m *IKEProposal) XXX_Size() int {
	return m.Size()
}
func (m *IKEProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_IKEProposal.DiscardUnknown(m)
}

var xxx_messageInfo_IKEProposal proto.InternalMessageInfo

func (m *IKEProposal) GetEncryptionAlgos() []schema.EncryptionAlgorithm {
	if m != nil {
		return m.EncryptionAlgos
	}
	return nil
}

func (m *IKEProposal) GetAuthenticationAlgos() []schema.AuthenticationAlgorithm {
	if m != nil {
		return m.AuthenticationAlgos
	}
	return nil
}

func (m *IKEProposal) GetPrf() []schema.PseudoRandomFunction {
	if m != nil {
		return m.Prf
	}
	return nil
}

func (m *IKEProposal) GetDhGroups() []schema.DHGroup {
	if m != nil {
		return m.DhGroups
	}
	return nil
}

// ESP Proposal
//
// x-displayName: "ESP Proposal Selection"
// Set of Encryption, Authentication and DH groups to be used for establishing IKE connection with peer
type ESPProposal struct {
	//Encryption Algorithms
	//
	// x-displayName: "Configure Encryption Algorithms"
	// Select Encrytion algorithms for IKE SA.
	EncryptionAlgos []schema.EncryptionAlgorithm `protobuf:"varint,1,rep,packed,name=encryption_algos,json=encryptionAlgos,proto3,enum=ves.io.schema.EncryptionAlgorithm" json:"encryption_algos,omitempty"`
	// Authentication Algorithms
	//
	// x-displayName: "Configure Authentication Algorithms"
	// Select Authentication algorithms for IKE SA.
	AuthenticationAlgos []schema.AuthenticationAlgorithm `protobuf:"varint,2,rep,packed,name=authentication_algos,json=authenticationAlgos,proto3,enum=ves.io.schema.AuthenticationAlgorithm" json:"authentication_algos,omitempty"`
	// DH Groups
	//
	// x-displayName: "Diffie Hellman Groups"
	// Select DH Groups
	DhGroups []schema.DHGroup `protobuf:"varint,3,rep,packed,name=dh_groups,json=dhGroups,proto3,enum=ves.io.schema.DHGroup" json:"dh_groups,omitempty"`
}

func (m *ESPProposal) Reset()      { *m = ESPProposal{} }
func (*ESPProposal) ProtoMessage() {}
func (*ESPProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{1}
}
func (m *ESPProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ESPProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ESPProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ESPProposal.Merge(m, src)
}
func (m *ESPProposal) XXX_Size() int {
	return m.Size()
}
func (m *ESPProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_ESPProposal.DiscardUnknown(m)
}

var xxx_messageInfo_ESPProposal proto.InternalMessageInfo

func (m *ESPProposal) GetEncryptionAlgos() []schema.EncryptionAlgorithm {
	if m != nil {
		return m.EncryptionAlgos
	}
	return nil
}

func (m *ESPProposal) GetAuthenticationAlgos() []schema.AuthenticationAlgorithm {
	if m != nil {
		return m.AuthenticationAlgos
	}
	return nil
}

func (m *ESPProposal) GetDhGroups() []schema.DHGroup {
	if m != nil {
		return m.DhGroups
	}
	return nil
}

// IPSec tunnel configuration parameters
//
// x-displayName: "IPSEC tunnel parameters"
// Configuration for IPSec encapsulation are:
// 1. PSK - pre shared key to be used by IKE
type IpsecTunnelParams struct {
	// IPSec Pre shared key
	//
	// x-displayName: "Ipsec PSK"
	// Pre shared key, valid for tunnel type IPSEC_PSK, SA are computed by IKE dynamically
	IpsecPsk *schema.SecretType `protobuf:"bytes,1,opt,name=ipsec_psk,json=ipsecPsk,proto3" json:"ipsec_psk,omitempty"`
	// Tunnel Initiator
	//
	// x-displayName: "Tunnel Initiator"
	// Set this if the node has to act as IPSec Tunnel Initiator. If not set, this node will wait for remote to connect
	TunnelInitiator *schema.Empty `protobuf:"bytes,2,opt,name=tunnel_initiator,json=tunnelInitiator,proto3" json:"tunnel_initiator,omitempty"`
	// IKE Proposals
	//
	// x-displayName: "IKE Proposals"
	// Set of Encryption, Authentication, PRF and DH groups to be used for establishing IKE connection with peer
	IkeProposal *IKEProposal `protobuf:"bytes,3,opt,name=ike_proposal,json=ikeProposal,proto3" json:"ike_proposal,omitempty"`
	// ESP Proposals
	//
	// x-displayName: "ESP Proposals"
	// Set of Encryption, Authentication and DH groups to be used for establishing IKE connection with peer
	EspProposal *ESPProposal `protobuf:"bytes,4,opt,name=esp_proposal,json=espProposal,proto3" json:"esp_proposal,omitempty"`
	// Local IKE ID
	//
	// x-displayName: "Local IKE ID"
	// Identifier that is used by IEE protocol to identify local end tunnel endpoint with the peer
	LocalIkeId string `protobuf:"bytes,6,opt,name=local_ike_id,json=localIkeId,proto3" json:"local_ike_id,omitempty"`
	// Remote IKE ID
	//
	// x-displayName: "Remote IKE ID"
	// Identifier that is used by IEE protocol to identify Remote end tunnel endpoint
	RemoteIkeId string `protobuf:"bytes,7,opt,name=remote_ike_id,json=remoteIkeId,proto3" json:"remote_ike_id,omitempty"`
	// IKE Key Lifetime
	//
	// x-displayName: "IKE Key Lifetime"
	// IKE Keys used for protection IKE session will be regenerated after this Lifetime. Value of 0 disables this feature.
	IkePhase1KeyLifetime uint32 `protobuf:"varint,8,opt,name=ike_phase1_key_lifetime,json=ikePhase1KeyLifetime,proto3" json:"ike_phase1_key_lifetime,omitempty"`
	// IKE Reauthentication Timeout
	//
	// x-displayName: "IKE Reauthentication Timeout"
	// IKE session with the peer will be re-authenticated/re-established after this timeout. Value of 0 disables this feature.
	IkeReauthTimeout uint32 `protobuf:"varint,9,opt,name=ike_reauth_timeout,json=ikeReauthTimeout,proto3" json:"ike_reauth_timeout,omitempty"`
	// IKE Child SA Key Lifetime
	//
	// x-displayName: "IKE IKE Child SA Key Lifetime"
	// IKE Keys used for protection Child SA session will be regenerated after this Lifetime. Value of 0 disables this feature.
	IkePhase2KeyLifetime uint32 `protobuf:"varint,10,opt,name=ike_phase2_key_lifetime,json=ikePhase2KeyLifetime,proto3" json:"ike_phase2_key_lifetime,omitempty"`
	// DPD Keep Alive timer
	//
	// x-displayName: "DPD Keep Alive Time(seconds)"
	// Configure DPD keep alive timer value in seconds. 0 implies disabled
	DpdKeepAliveTimer uint32 `protobuf:"varint,11,opt,name=dpd_keep_alive_timer,json=dpdKeepAliveTimer,proto3" json:"dpd_keep_alive_timer,omitempty"`
	// IKE Phase1 Profile
	//
	// x-displayName: "IKE Phase1 Profile"
	// Reference to IKE Phase1 Profile
	IkePhase1Profile []*schema.ObjectRefType `protobuf:"bytes,14,rep,name=ike_phase1_profile,json=ikePhase1Profile,proto3" json:"ike_phase1_profile,omitempty"`
	// IKE Phase2 Profile
	//
	// x-displayName: "IKE Phase2 Profile"
	// Reference to IKE Phase2 Profile
	IkePhase2Profile []*schema.ObjectRefType `protobuf:"bytes,15,rep,name=ike_phase2_profile,json=ikePhase2Profile,proto3" json:"ike_phase2_profile,omitempty"`
}

func (m *IpsecTunnelParams) Reset()      { *m = IpsecTunnelParams{} }
func (*IpsecTunnelParams) ProtoMessage() {}
func (*IpsecTunnelParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{2}
}
func (m *IpsecTunnelParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpsecTunnelParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IpsecTunnelParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpsecTunnelParams.Merge(m, src)
}
func (m *IpsecTunnelParams) XXX_Size() int {
	return m.Size()
}
func (m *IpsecTunnelParams) XXX_DiscardUnknown() {
	xxx_messageInfo_IpsecTunnelParams.DiscardUnknown(m)
}

var xxx_messageInfo_IpsecTunnelParams proto.InternalMessageInfo

func (m *IpsecTunnelParams) GetIpsecPsk() *schema.SecretType {
	if m != nil {
		return m.IpsecPsk
	}
	return nil
}

func (m *IpsecTunnelParams) GetTunnelInitiator() *schema.Empty {
	if m != nil {
		return m.TunnelInitiator
	}
	return nil
}

func (m *IpsecTunnelParams) GetIkeProposal() *IKEProposal {
	if m != nil {
		return m.IkeProposal
	}
	return nil
}

func (m *IpsecTunnelParams) GetEspProposal() *ESPProposal {
	if m != nil {
		return m.EspProposal
	}
	return nil
}

func (m *IpsecTunnelParams) GetLocalIkeId() string {
	if m != nil {
		return m.LocalIkeId
	}
	return ""
}

func (m *IpsecTunnelParams) GetRemoteIkeId() string {
	if m != nil {
		return m.RemoteIkeId
	}
	return ""
}

func (m *IpsecTunnelParams) GetIkePhase1KeyLifetime() uint32 {
	if m != nil {
		return m.IkePhase1KeyLifetime
	}
	return 0
}

func (m *IpsecTunnelParams) GetIkeReauthTimeout() uint32 {
	if m != nil {
		return m.IkeReauthTimeout
	}
	return 0
}

func (m *IpsecTunnelParams) GetIkePhase2KeyLifetime() uint32 {
	if m != nil {
		return m.IkePhase2KeyLifetime
	}
	return 0
}

func (m *IpsecTunnelParams) GetDpdKeepAliveTimer() uint32 {
	if m != nil {
		return m.DpdKeepAliveTimer
	}
	return 0
}

func (m *IpsecTunnelParams) GetIkePhase1Profile() []*schema.ObjectRefType {
	if m != nil {
		return m.IkePhase1Profile
	}
	return nil
}

func (m *IpsecTunnelParams) GetIkePhase2Profile() []*schema.ObjectRefType {
	if m != nil {
		return m.IkePhase2Profile
	}
	return nil
}

// Tunnel Parameters
//
// x-displayName: "Tunnel Parameters"
// Tunnel configuration parameters for supported encapsulation
// 1. IPSec is supported with PSK for which PSK can be configured
type TunnelParams struct {
	// Type
	//
	// x-displayName: "Type"
	// Type of tunnel params
	//
	// Types that are valid to be assigned to Type:
	//	*TunnelParams_Ipsec
	Type isTunnelParams_Type `protobuf_oneof:"type"`
}

func (m *TunnelParams) Reset()      { *m = TunnelParams{} }
func (*TunnelParams) ProtoMessage() {}
func (*TunnelParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{3}
}
func (m *TunnelParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunnelParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TunnelParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelParams.Merge(m, src)
}
func (m *TunnelParams) XXX_Size() int {
	return m.Size()
}
func (m *TunnelParams) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelParams.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelParams proto.InternalMessageInfo

type isTunnelParams_Type interface {
	isTunnelParams_Type()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type TunnelParams_Ipsec struct {
	Ipsec *IpsecTunnelParams `protobuf:"bytes,1,opt,name=ipsec,proto3,oneof" json:"ipsec,omitempty"`
}

func (*TunnelParams_Ipsec) isTunnelParams_Type() {}

func (m *TunnelParams) GetType() isTunnelParams_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *TunnelParams) GetIpsec() *IpsecTunnelParams {
	if x, ok := m.GetType().(*TunnelParams_Ipsec); ok {
		return x.Ipsec
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TunnelParams) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TunnelParams_Ipsec)(nil),
	}
}

// Interface Type
//
// x-displayName: "Interface Type"
// Provides the local interface to pick up source IP and network for transporting encapsulated packet
type InterfaceType struct {
	// Local Interface
	//
	// x-displayName: "Local Interface"
	// Local interface to be used for filling in source information of IP and network for transport
	LocalIntf []*schema.ObjectRefType `protobuf:"bytes,1,rep,name=local_intf,json=localIntf,proto3" json:"local_intf,omitempty"`
}

func (m *InterfaceType) Reset()      { *m = InterfaceType{} }
func (*InterfaceType) ProtoMessage() {}
func (*InterfaceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{4}
}
func (m *InterfaceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InterfaceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceType.Merge(m, src)
}
func (m *InterfaceType) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceType) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceType.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceType proto.InternalMessageInfo

func (m *InterfaceType) GetLocalIntf() []*schema.ObjectRefType {
	if m != nil {
		return m.LocalIntf
	}
	return nil
}

// Local IP Address Type
//
// x-displayName: "Local IP Address Type"
// Provides the configuration to pick up source IP and network for transporting encapsulated packet
type LocalIpAddressType struct {
	// Type
	//
	// x-required
	// x-displayName: "Type"
	// Options to choose local IP address
	//
	// Types that are valid to be assigned to Type:
	//	*LocalIpAddressType_IpAddress
	//	*LocalIpAddressType_Auto
	Type isLocalIpAddressType_Type `protobuf_oneof:"type"`
	// Local Virtual Network
	//
	// x-displayName: "Local Virtual Network"
	// x-required
	// Local Virtual network to be used for transporting encapsulated packets
	VirtualNetworkType *schema.VirtualNetworkSelectorType `protobuf:"bytes,3,opt,name=virtual_network_type,json=virtualNetworkType,proto3" json:"virtual_network_type,omitempty"`
}

func (m *LocalIpAddressType) Reset()      { *m = LocalIpAddressType{} }
func (*LocalIpAddressType) ProtoMessage() {}
func (*LocalIpAddressType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{5}
}
func (m *LocalIpAddressType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalIpAddressType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LocalIpAddressType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalIpAddressType.Merge(m, src)
}
func (m *LocalIpAddressType) XXX_Size() int {
	return m.Size()
}
func (m *LocalIpAddressType) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalIpAddressType.DiscardUnknown(m)
}

var xxx_messageInfo_LocalIpAddressType proto.InternalMessageInfo

type isLocalIpAddressType_Type interface {
	isLocalIpAddressType_Type()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type LocalIpAddressType_IpAddress struct {
	IpAddress *schema.IpAddressType `protobuf:"bytes,1,opt,name=ip_address,json=ipAddress,proto3,oneof" json:"ip_address,omitempty"`
}
type LocalIpAddressType_Auto struct {
	Auto *schema.Empty `protobuf:"bytes,2,opt,name=auto,proto3,oneof" json:"auto,omitempty"`
}

func (*LocalIpAddressType_IpAddress) isLocalIpAddressType_Type() {}
func (*LocalIpAddressType_Auto) isLocalIpAddressType_Type()      {}

func (m *LocalIpAddressType) GetType() isLocalIpAddressType_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *LocalIpAddressType) GetIpAddress() *schema.IpAddressType {
	if x, ok := m.GetType().(*LocalIpAddressType_IpAddress); ok {
		return x.IpAddress
	}
	return nil
}

func (m *LocalIpAddressType) GetAuto() *schema.Empty {
	if x, ok := m.GetType().(*LocalIpAddressType_Auto); ok {
		return x.Auto
	}
	return nil
}

func (m *LocalIpAddressType) GetVirtualNetworkType() *schema.VirtualNetworkSelectorType {
	if m != nil {
		return m.VirtualNetworkType
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LocalIpAddressType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LocalIpAddressType_IpAddress)(nil),
		(*LocalIpAddressType_Auto)(nil),
	}
}

// Local IP Address Selector
//
// x-displayName: "Local IP Address Selector"
// Defines the options to select local ip address and virtual network for tunnel object
// Options available are -
// 1. Local Interface - Network Interface from which IP address and network will be selected
// 2. IP Address - IP address and network can be configured explicitly
type LocalIpAddressSelector struct {
	// Type
	//
	// x-displayName: "Type"
	// Choice to pick up local ip address for tunnel
	//
	// Types that are valid to be assigned to Type:
	//	*LocalIpAddressSelector_Intf
	//	*LocalIpAddressSelector_IpAddress
	//	*LocalIpAddressSelector_NodeInterface
	Type isLocalIpAddressSelector_Type `protobuf_oneof:"type"`
}

func (m *LocalIpAddressSelector) Reset()      { *m = LocalIpAddressSelector{} }
func (*LocalIpAddressSelector) ProtoMessage() {}
func (*LocalIpAddressSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{6}
}
func (m *LocalIpAddressSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalIpAddressSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LocalIpAddressSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalIpAddressSelector.Merge(m, src)
}
func (m *LocalIpAddressSelector) XXX_Size() int {
	return m.Size()
}
func (m *LocalIpAddressSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalIpAddressSelector.DiscardUnknown(m)
}

var xxx_messageInfo_LocalIpAddressSelector proto.InternalMessageInfo

type isLocalIpAddressSelector_Type interface {
	isLocalIpAddressSelector_Type()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type LocalIpAddressSelector_Intf struct {
	Intf *InterfaceType `protobuf:"bytes,1,opt,name=intf,proto3,oneof" json:"intf,omitempty"`
}
type LocalIpAddressSelector_IpAddress struct {
	IpAddress *LocalIpAddressType `protobuf:"bytes,2,opt,name=ip_address,json=ipAddress,proto3,oneof" json:"ip_address,omitempty"`
}
type LocalIpAddressSelector_NodeInterface struct {
	NodeInterface *schema.NodeInterfaceType `protobuf:"bytes,4,opt,name=node_interface,json=nodeInterface,proto3,oneof" json:"node_interface,omitempty"`
}

func (*LocalIpAddressSelector_Intf) isLocalIpAddressSelector_Type()          {}
func (*LocalIpAddressSelector_IpAddress) isLocalIpAddressSelector_Type()     {}
func (*LocalIpAddressSelector_NodeInterface) isLocalIpAddressSelector_Type() {}

func (m *LocalIpAddressSelector) GetType() isLocalIpAddressSelector_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *LocalIpAddressSelector) GetIntf() *InterfaceType {
	if x, ok := m.GetType().(*LocalIpAddressSelector_Intf); ok {
		return x.Intf
	}
	return nil
}

func (m *LocalIpAddressSelector) GetIpAddress() *LocalIpAddressType {
	if x, ok := m.GetType().(*LocalIpAddressSelector_IpAddress); ok {
		return x.IpAddress
	}
	return nil
}

func (m *LocalIpAddressSelector) GetNodeInterface() *schema.NodeInterfaceType {
	if x, ok := m.GetType().(*LocalIpAddressSelector_NodeInterface); ok {
		return x.NodeInterface
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LocalIpAddressSelector) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LocalIpAddressSelector_Intf)(nil),
		(*LocalIpAddressSelector_IpAddress)(nil),
		(*LocalIpAddressSelector_NodeInterface)(nil),
	}
}

// Remote Node Atributes
//
// x-displayName: "Remote Node Attributes"
// Remote node attributes specify parameters needed to be configured for remote node
type RemoteNodeAttributes struct {
	// IP Address
	//
	// x-displayName: "IP Address"
	// IP address of remote node
	Ip *schema.IpAddressType `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
}

func (m *RemoteNodeAttributes) Reset()      { *m = RemoteNodeAttributes{} }
func (*RemoteNodeAttributes) ProtoMessage() {}
func (*RemoteNodeAttributes) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{7}
}
func (m *RemoteNodeAttributes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteNodeAttributes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RemoteNodeAttributes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteNodeAttributes.Merge(m, src)
}
func (m *RemoteNodeAttributes) XXX_Size() int {
	return m.Size()
}
func (m *RemoteNodeAttributes) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteNodeAttributes.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteNodeAttributes proto.InternalMessageInfo

func (m *RemoteNodeAttributes) GetIp() *schema.IpAddressType {
	if m != nil {
		return m.Ip
	}
	return nil
}

// Remote Endpoint Type
//
// x-displayName: "Remote Endpoint Type"
// Provides a map of ver node name to remote node attributes
// Ver node should use these attributes to configure as remote tunnel
type RemoteEndpointType struct {
	// Remote Endpoints
	//
	// x-displayName: "Remote Endpoints"
	// Map of remote attributes to which tunnel will be established on per site node basis
	// Every node can have a different attributes and IP address to connect to
	// Key is ver node name and value is Remote node attributes
	Endpoints map[string]*RemoteNodeAttributes `protobuf:"bytes,2,rep,name=endpoints,proto3" json:"endpoints,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *RemoteEndpointType) Reset()      { *m = RemoteEndpointType{} }
func (*RemoteEndpointType) ProtoMessage() {}
func (*RemoteEndpointType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{8}
}
func (m *RemoteEndpointType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteEndpointType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RemoteEndpointType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteEndpointType.Merge(m, src)
}
func (m *RemoteEndpointType) XXX_Size() int {
	return m.Size()
}
func (m *RemoteEndpointType) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteEndpointType.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteEndpointType proto.InternalMessageInfo

func (m *RemoteEndpointType) GetEndpoints() map[string]*RemoteNodeAttributes {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

// Remote IP Address Selector
//
// x-displayName: "Remote IP Address Selector"
// Defines the options to select remote ip address for tunnel object
// Options available are -
// 1. IP Address - Specifies the remote IP to which tunnel has to be connected
// 2. Remote endpoint - Is a map of IP address on per ver node basis
type RemoteIpAddressSelector struct {
	// Type
	//
	// x-displayName: "Type"
	// Options to select remote ip address
	//
	// Types that are valid to be assigned to Type:
	//	*RemoteIpAddressSelector_Ip
	//	*RemoteIpAddressSelector_Endpoints
	Type isRemoteIpAddressSelector_Type `protobuf_oneof:"type"`
}

func (m *RemoteIpAddressSelector) Reset()      { *m = RemoteIpAddressSelector{} }
func (*RemoteIpAddressSelector) ProtoMessage() {}
func (*RemoteIpAddressSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{9}
}
func (m *RemoteIpAddressSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteIpAddressSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RemoteIpAddressSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteIpAddressSelector.Merge(m, src)
}
func (m *RemoteIpAddressSelector) XXX_Size() int {
	return m.Size()
}
func (m *RemoteIpAddressSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteIpAddressSelector.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteIpAddressSelector proto.InternalMessageInfo

type isRemoteIpAddressSelector_Type interface {
	isRemoteIpAddressSelector_Type()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type RemoteIpAddressSelector_Ip struct {
	Ip *schema.IpAddressType `protobuf:"bytes,1,opt,name=ip,proto3,oneof" json:"ip,omitempty"`
}
type RemoteIpAddressSelector_Endpoints struct {
	Endpoints *RemoteEndpointType `protobuf:"bytes,2,opt,name=endpoints,proto3,oneof" json:"endpoints,omitempty"`
}

func (*RemoteIpAddressSelector_Ip) isRemoteIpAddressSelector_Type()        {}
func (*RemoteIpAddressSelector_Endpoints) isRemoteIpAddressSelector_Type() {}

func (m *RemoteIpAddressSelector) GetType() isRemoteIpAddressSelector_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *RemoteIpAddressSelector) GetIp() *schema.IpAddressType {
	if x, ok := m.GetType().(*RemoteIpAddressSelector_Ip); ok {
		return x.Ip
	}
	return nil
}

func (m *RemoteIpAddressSelector) GetEndpoints() *RemoteEndpointType {
	if x, ok := m.GetType().(*RemoteIpAddressSelector_Endpoints); ok {
		return x.Endpoints
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RemoteIpAddressSelector) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RemoteIpAddressSelector_Ip)(nil),
		(*RemoteIpAddressSelector_Endpoints)(nil),
	}
}

// Tunnel specification
//
// x-displayName: "Specification"
// Desired state of Tunnel
type GlobalSpecType struct {
	// Tunnel Type
	//
	// x-displayName: "Tunnel Type"
	// x-required
	// Tunnel type supported is IPSEC with pre-shared key (IPSEC_PSK)
	TunnelType TunnelType `protobuf:"varint,1,opt,name=tunnel_type,json=tunnelType,proto3,enum=ves.io.schema.tunnel.TunnelType" json:"tunnel_type,omitempty"`
	// Local IP Address selector
	//
	// x-displayName: "Local IP Address selector"
	// x-required
	// Selects local IP address configuration for tunnel
	LocalIp *LocalIpAddressSelector `protobuf:"bytes,7,opt,name=local_ip,json=localIp,proto3" json:"local_ip,omitempty"`
	// Remore IP Address Selector
	//
	// x-displayName: "Remote IP Address Selector"
	// x-required
	// Selects remote endpoint IP address configuration for tunnel
	RemoteIp *RemoteIpAddressSelector `protobuf:"bytes,8,opt,name=remote_ip,json=remoteIp,proto3" json:"remote_ip,omitempty"`
	// Tunnel Parameters
	//
	// x-displayName: "Tunnel Parameters"
	// Configuration for supported tunnel types
	Params *TunnelParams `protobuf:"bytes,6,opt,name=params,proto3" json:"params,omitempty"`
	// Tunnel Attribute
	//
	// x-displayName: "Tunnel Attribute"
	// x-required
	// Tunnel Attribute
	//
	// Types that are valid to be assigned to TunnelAttribute:
	//	*GlobalSpecType_DefaultTunnelAttribute
	//	*GlobalSpecType_TunnelToAwsTgw
	TunnelAttribute isGlobalSpecType_TunnelAttribute `protobuf_oneof:"tunnel_attribute"`
	// AWS TGW VPN Tunnel Parameters
	//
	// x-displayName: "AWS TGW Tunnel Parameters"
	// AWS TGW Hub/Services VPN Tunnel demarcation
	DeploymentVpnTunnelType DeploymentVPNTunnelType `protobuf:"varint,12,opt,name=deployment_vpn_tunnel_type,json=deploymentVpnTunnelType,proto3,enum=ves.io.schema.tunnel.DeploymentVPNTunnelType" json:"deployment_vpn_tunnel_type,omitempty"`
	// ConfigureType
	//
	// x-displayName: "Configure Type"
	// Defines the source of this tunnel configuration
	CfgType *ConfigureType `protobuf:"bytes,20,opt,name=cfg_type,json=cfgType,proto3" json:"cfg_type,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{10}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_TunnelAttribute interface {
	isGlobalSpecType_TunnelAttribute()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_DefaultTunnelAttribute struct {
	DefaultTunnelAttribute *schema.Empty `protobuf:"bytes,10,opt,name=default_tunnel_attribute,json=defaultTunnelAttribute,proto3,oneof" json:"default_tunnel_attribute,omitempty"`
}
type GlobalSpecType_TunnelToAwsTgw struct {
	TunnelToAwsTgw *schema.Empty `protobuf:"bytes,11,opt,name=tunnel_to_aws_tgw,json=tunnelToAwsTgw,proto3,oneof" json:"tunnel_to_aws_tgw,omitempty"`
}

func (*GlobalSpecType_DefaultTunnelAttribute) isGlobalSpecType_TunnelAttribute() {}
func (*GlobalSpecType_TunnelToAwsTgw) isGlobalSpecType_TunnelAttribute()         {}

func (m *GlobalSpecType) GetTunnelAttribute() isGlobalSpecType_TunnelAttribute {
	if m != nil {
		return m.TunnelAttribute
	}
	return nil
}

func (m *GlobalSpecType) GetTunnelType() TunnelType {
	if m != nil {
		return m.TunnelType
	}
	return IPSEC_PSK
}

func (m *GlobalSpecType) GetLocalIp() *LocalIpAddressSelector {
	if m != nil {
		return m.LocalIp
	}
	return nil
}

func (m *GlobalSpecType) GetRemoteIp() *RemoteIpAddressSelector {
	if m != nil {
		return m.RemoteIp
	}
	return nil
}

func (m *GlobalSpecType) GetParams() *TunnelParams {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *GlobalSpecType) GetDefaultTunnelAttribute() *schema.Empty {
	if x, ok := m.GetTunnelAttribute().(*GlobalSpecType_DefaultTunnelAttribute); ok {
		return x.DefaultTunnelAttribute
	}
	return nil
}

func (m *GlobalSpecType) GetTunnelToAwsTgw() *schema.Empty {
	if x, ok := m.GetTunnelAttribute().(*GlobalSpecType_TunnelToAwsTgw); ok {
		return x.TunnelToAwsTgw
	}
	return nil
}

func (m *GlobalSpecType) GetDeploymentVpnTunnelType() DeploymentVPNTunnelType {
	if m != nil {
		return m.DeploymentVpnTunnelType
	}
	return HUB
}

func (m *GlobalSpecType) GetCfgType() *ConfigureType {
	if m != nil {
		return m.CfgType
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_DefaultTunnelAttribute)(nil),
		(*GlobalSpecType_TunnelToAwsTgw)(nil),
	}
}

// ConfigureType
//
// x-displayName: "Configure Type"
// Defines the source of this tunnel configuration
type ConfigureType struct {
	// ConfigureType
	//
	// x-displayName: "ConfigureType"
	// Defines the source of this tunnel configuration
	//
	// Types that are valid to be assigned to CfgType:
	//	*ConfigureType_ExtConnIpsec
	//	*ConfigureType_ExtConnGre
	CfgType isConfigureType_CfgType `protobuf_oneof:"cfg_type"`
}

func (m *ConfigureType) Reset()      { *m = ConfigureType{} }
func (*ConfigureType) ProtoMessage() {}
func (*ConfigureType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{11}
}
func (m *ConfigureType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigureType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConfigureType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigureType.Merge(m, src)
}
func (m *ConfigureType) XXX_Size() int {
	return m.Size()
}
func (m *ConfigureType) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigureType.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigureType proto.InternalMessageInfo

type isConfigureType_CfgType interface {
	isConfigureType_CfgType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ConfigureType_ExtConnIpsec struct {
	ExtConnIpsec *schema.Empty `protobuf:"bytes,2,opt,name=ext_conn_ipsec,json=extConnIpsec,proto3,oneof" json:"ext_conn_ipsec,omitempty"`
}
type ConfigureType_ExtConnGre struct {
	ExtConnGre *schema.Empty `protobuf:"bytes,3,opt,name=ext_conn_gre,json=extConnGre,proto3,oneof" json:"ext_conn_gre,omitempty"`
}

func (*ConfigureType_ExtConnIpsec) isConfigureType_CfgType() {}
func (*ConfigureType_ExtConnGre) isConfigureType_CfgType()   {}

func (m *ConfigureType) GetCfgType() isConfigureType_CfgType {
	if m != nil {
		return m.CfgType
	}
	return nil
}

func (m *ConfigureType) GetExtConnIpsec() *schema.Empty {
	if x, ok := m.GetCfgType().(*ConfigureType_ExtConnIpsec); ok {
		return x.ExtConnIpsec
	}
	return nil
}

func (m *ConfigureType) GetExtConnGre() *schema.Empty {
	if x, ok := m.GetCfgType().(*ConfigureType_ExtConnGre); ok {
		return x.ExtConnGre
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ConfigureType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ConfigureType_ExtConnIpsec)(nil),
		(*ConfigureType_ExtConnGre)(nil),
	}
}

// Create tunnel
//
// x-displayName: "Create Tunnel"
// Create tunnel in a given namespace. If one already exist it will give a error.
type CreateSpecType struct {
	TunnelType TunnelType               `protobuf:"varint,1,opt,name=tunnel_type,json=tunnelType,proto3,enum=ves.io.schema.tunnel.TunnelType" json:"tunnel_type,omitempty"`
	LocalIp    *LocalIpAddressSelector  `protobuf:"bytes,7,opt,name=local_ip,json=localIp,proto3" json:"local_ip,omitempty"`
	RemoteIp   *RemoteIpAddressSelector `protobuf:"bytes,8,opt,name=remote_ip,json=remoteIp,proto3" json:"remote_ip,omitempty"`
	Params     *TunnelParams            `protobuf:"bytes,6,opt,name=params,proto3" json:"params,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{12}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

func (m *CreateSpecType) GetTunnelType() TunnelType {
	if m != nil {
		return m.TunnelType
	}
	return IPSEC_PSK
}

func (m *CreateSpecType) GetLocalIp() *LocalIpAddressSelector {
	if m != nil {
		return m.LocalIp
	}
	return nil
}

func (m *CreateSpecType) GetRemoteIp() *RemoteIpAddressSelector {
	if m != nil {
		return m.RemoteIp
	}
	return nil
}

func (m *CreateSpecType) GetParams() *TunnelParams {
	if m != nil {
		return m.Params
	}
	return nil
}

// Replace tunnel
//
// x-displayName: "Replace Tunnel"
// Replace tunnel in a given namespace.
type ReplaceSpecType struct {
	TunnelType TunnelType               `protobuf:"varint,1,opt,name=tunnel_type,json=tunnelType,proto3,enum=ves.io.schema.tunnel.TunnelType" json:"tunnel_type,omitempty"`
	LocalIp    *LocalIpAddressSelector  `protobuf:"bytes,7,opt,name=local_ip,json=localIp,proto3" json:"local_ip,omitempty"`
	RemoteIp   *RemoteIpAddressSelector `protobuf:"bytes,8,opt,name=remote_ip,json=remoteIp,proto3" json:"remote_ip,omitempty"`
	Params     *TunnelParams            `protobuf:"bytes,6,opt,name=params,proto3" json:"params,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{13}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

func (m *ReplaceSpecType) GetTunnelType() TunnelType {
	if m != nil {
		return m.TunnelType
	}
	return IPSEC_PSK
}

func (m *ReplaceSpecType) GetLocalIp() *LocalIpAddressSelector {
	if m != nil {
		return m.LocalIp
	}
	return nil
}

func (m *ReplaceSpecType) GetRemoteIp() *RemoteIpAddressSelector {
	if m != nil {
		return m.RemoteIp
	}
	return nil
}

func (m *ReplaceSpecType) GetParams() *TunnelParams {
	if m != nil {
		return m.Params
	}
	return nil
}

// Get tunnel
//
// x-displayName: "Get Tunnel"
// Get Tunnel in a given namespace.
type GetSpecType struct {
	TunnelType TunnelType               `protobuf:"varint,1,opt,name=tunnel_type,json=tunnelType,proto3,enum=ves.io.schema.tunnel.TunnelType" json:"tunnel_type,omitempty"`
	LocalIp    *LocalIpAddressSelector  `protobuf:"bytes,7,opt,name=local_ip,json=localIp,proto3" json:"local_ip,omitempty"`
	RemoteIp   *RemoteIpAddressSelector `protobuf:"bytes,8,opt,name=remote_ip,json=remoteIp,proto3" json:"remote_ip,omitempty"`
	Params     *TunnelParams            `protobuf:"bytes,6,opt,name=params,proto3" json:"params,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_6fc6059a22f3fcf5, []int{14}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

func (m *GetSpecType) GetTunnelType() TunnelType {
	if m != nil {
		return m.TunnelType
	}
	return IPSEC_PSK
}

func (m *GetSpecType) GetLocalIp() *LocalIpAddressSelector {
	if m != nil {
		return m.LocalIp
	}
	return nil
}

func (m *GetSpecType) GetRemoteIp() *RemoteIpAddressSelector {
	if m != nil {
		return m.RemoteIp
	}
	return nil
}

func (m *GetSpecType) GetParams() *TunnelParams {
	if m != nil {
		return m.Params
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.tunnel.DeploymentVPNTunnelType", DeploymentVPNTunnelType_name, DeploymentVPNTunnelType_value)
	golang_proto.RegisterEnum("ves.io.schema.tunnel.DeploymentVPNTunnelType", DeploymentVPNTunnelType_name, DeploymentVPNTunnelType_value)
	proto.RegisterEnum("ves.io.schema.tunnel.TunnelType", TunnelType_name, TunnelType_value)
	golang_proto.RegisterEnum("ves.io.schema.tunnel.TunnelType", TunnelType_name, TunnelType_value)
	proto.RegisterType((*IKEProposal)(nil), "ves.io.schema.tunnel.IKEProposal")
	golang_proto.RegisterType((*IKEProposal)(nil), "ves.io.schema.tunnel.IKEProposal")
	proto.RegisterType((*ESPProposal)(nil), "ves.io.schema.tunnel.ESPProposal")
	golang_proto.RegisterType((*ESPProposal)(nil), "ves.io.schema.tunnel.ESPProposal")
	proto.RegisterType((*IpsecTunnelParams)(nil), "ves.io.schema.tunnel.IpsecTunnelParams")
	golang_proto.RegisterType((*IpsecTunnelParams)(nil), "ves.io.schema.tunnel.IpsecTunnelParams")
	proto.RegisterType((*TunnelParams)(nil), "ves.io.schema.tunnel.TunnelParams")
	golang_proto.RegisterType((*TunnelParams)(nil), "ves.io.schema.tunnel.TunnelParams")
	proto.RegisterType((*InterfaceType)(nil), "ves.io.schema.tunnel.InterfaceType")
	golang_proto.RegisterType((*InterfaceType)(nil), "ves.io.schema.tunnel.InterfaceType")
	proto.RegisterType((*LocalIpAddressType)(nil), "ves.io.schema.tunnel.LocalIpAddressType")
	golang_proto.RegisterType((*LocalIpAddressType)(nil), "ves.io.schema.tunnel.LocalIpAddressType")
	proto.RegisterType((*LocalIpAddressSelector)(nil), "ves.io.schema.tunnel.LocalIpAddressSelector")
	golang_proto.RegisterType((*LocalIpAddressSelector)(nil), "ves.io.schema.tunnel.LocalIpAddressSelector")
	proto.RegisterType((*RemoteNodeAttributes)(nil), "ves.io.schema.tunnel.RemoteNodeAttributes")
	golang_proto.RegisterType((*RemoteNodeAttributes)(nil), "ves.io.schema.tunnel.RemoteNodeAttributes")
	proto.RegisterType((*RemoteEndpointType)(nil), "ves.io.schema.tunnel.RemoteEndpointType")
	golang_proto.RegisterType((*RemoteEndpointType)(nil), "ves.io.schema.tunnel.RemoteEndpointType")
	proto.RegisterMapType((map[string]*RemoteNodeAttributes)(nil), "ves.io.schema.tunnel.RemoteEndpointType.EndpointsEntry")
	golang_proto.RegisterMapType((map[string]*RemoteNodeAttributes)(nil), "ves.io.schema.tunnel.RemoteEndpointType.EndpointsEntry")
	proto.RegisterType((*RemoteIpAddressSelector)(nil), "ves.io.schema.tunnel.RemoteIpAddressSelector")
	golang_proto.RegisterType((*RemoteIpAddressSelector)(nil), "ves.io.schema.tunnel.RemoteIpAddressSelector")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.tunnel.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.tunnel.GlobalSpecType")
	proto.RegisterType((*ConfigureType)(nil), "ves.io.schema.tunnel.ConfigureType")
	golang_proto.RegisterType((*ConfigureType)(nil), "ves.io.schema.tunnel.ConfigureType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.tunnel.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.tunnel.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.tunnel.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.tunnel.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.tunnel.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.tunnel.GetSpecType")
}

func init() { proto.RegisterFile("ves.io/schema/tunnel/types.proto", fileDescriptor_6fc6059a22f3fcf5) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/tunnel/types.proto", fileDescriptor_6fc6059a22f3fcf5)
}

var fileDescriptor_6fc6059a22f3fcf5 = []byte{
	// 1874 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0x4f, 0x6c, 0x23, 0x57,
	0x19, 0xf7, 0x1b, 0x4f, 0x12, 0xfb, 0xb3, 0xe3, 0x9d, 0x3c, 0xa2, 0x5d, 0xd7, 0xad, 0xac, 0xc1,
	0x15, 0x25, 0x44, 0x59, 0x67, 0xe3, 0x85, 0x52, 0xa2, 0xd2, 0x36, 0xc9, 0x9a, 0xc4, 0xde, 0xb2,
	0x6b, 0x4d, 0x96, 0x45, 0xd0, 0xc3, 0x68, 0xe2, 0x79, 0x76, 0xa6, 0x1e, 0xcf, 0x7b, 0x9a, 0x79,
	0x76, 0x36, 0x87, 0x4a, 0x2b, 0x2e, 0x54, 0x39, 0x21, 0x8e, 0xbd, 0x72, 0x41, 0xcb, 0x0d, 0x21,
	0x81, 0x70, 0x84, 0x22, 0x24, 0xa4, 0xaa, 0x12, 0x28, 0xc7, 0x3d, 0x76, 0xbd, 0x97, 0x52, 0x71,
	0xe8, 0x01, 0xee, 0xe8, 0xbd, 0x19, 0x3b, 0x1e, 0x67, 0x13, 0x52, 0x6e, 0xa0, 0xde, 0xe6, 0xbd,
	0xef, 0xfb, 0x7e, 0xef, 0x7b, 0xbf, 0xef, 0xcf, 0xfb, 0x6c, 0xd0, 0xfb, 0x24, 0x28, 0x3b, 0x74,
	0x35, 0x68, 0xee, 0x93, 0xae, 0xb5, 0xca, 0x7b, 0x9e, 0x47, 0xdc, 0x55, 0x7e, 0xc8, 0x48, 0x50,
	0x66, 0x3e, 0xe5, 0x14, 0x2f, 0x86, 0x1a, 0xe5, 0x50, 0xa3, 0x1c, 0x6a, 0x14, 0x6e, 0xb6, 0x1d,
	0xbe, 0xdf, 0xdb, 0x2b, 0x37, 0x69, 0x77, 0xb5, 0x4d, 0xdb, 0x74, 0x55, 0x2a, 0xef, 0xf5, 0x5a,
	0x72, 0x25, 0x17, 0xf2, 0x2b, 0x04, 0x29, 0x14, 0xe2, 0xc7, 0x34, 0xfd, 0x43, 0xc6, 0x47, 0xb2,
	0x1b, 0x71, 0x99, 0x47, 0x78, 0x24, 0x78, 0x39, 0x2e, 0xa0, 0x8c, 0x3b, 0xd4, 0x8b, 0xdc, 0x2a,
	0xbc, 0x34, 0xe5, 0xf8, 0x99, 0xc7, 0x85, 0x57, 0xe2, 0xa2, 0xbe, 0xe5, 0x3a, 0xb6, 0xc5, 0x49,
	0x24, 0x9d, 0xba, 0x71, 0xdf, 0x21, 0x07, 0x66, 0x0c, 0xba, 0xf4, 0x2b, 0x05, 0x32, 0xb5, 0xbb,
	0xd5, 0x86, 0x4f, 0x19, 0x0d, 0x2c, 0x17, 0xff, 0x10, 0x34, 0xe2, 0x49, 0x97, 0x1d, 0xea, 0x99,
	0x96, 0xdb, 0xa6, 0x41, 0x1e, 0xe9, 0xc9, 0xa5, 0x5c, 0xa5, 0x54, 0x8e, 0x93, 0x53, 0x1d, 0xab,
	0x6d, 0xb8, 0x6d, 0xea, 0x3b, 0x7c, 0xbf, 0x6b, 0x5c, 0x23, 0xb1, 0xcd, 0x00, 0xff, 0x04, 0x16,
	0xad, 0x1e, 0xdf, 0x27, 0x1e, 0x77, 0x9a, 0xd6, 0x04, 0xa4, 0x22, 0x21, 0x5f, 0x9b, 0x82, 0xdc,
	0x88, 0xa9, 0x9e, 0xc1, 0x7e, 0xcd, 0x3a, 0x27, 0x08, 0xf0, 0x77, 0x20, 0xc9, 0xfc, 0x56, 0x3e,
	0x29, 0x91, 0x5e, 0x9d, 0x42, 0x6a, 0x04, 0xa4, 0x67, 0x53, 0xc3, 0xf2, 0x6c, 0xda, 0xfd, 0x41,
	0xcf, 0x6b, 0x0a, 0x33, 0x43, 0xe8, 0xe3, 0xdb, 0x90, 0xb6, 0xf7, 0xcd, 0xb6, 0x4f, 0x7b, 0x2c,
	0xc8, 0xab, 0xd2, 0xf8, 0xfa, 0x94, 0xf1, 0x9d, 0x9d, 0x6d, 0x21, 0x36, 0x52, 0xf6, 0xbe, 0xfc,
	0x08, 0x4a, 0xff, 0x40, 0x90, 0xa9, 0xee, 0x36, 0xfe, 0x07, 0x59, 0x8a, 0x5d, 0x37, 0x79, 0xc5,
	0xeb, 0xfe, 0x76, 0x16, 0x16, 0x6a, 0x2c, 0x20, 0xcd, 0x07, 0xb2, 0x00, 0x1a, 0x96, 0x6f, 0x75,
	0x03, 0xfc, 0x26, 0xa4, 0x1d, 0xb1, 0x69, 0xb2, 0xa0, 0x93, 0x47, 0x3a, 0x5a, 0xca, 0x54, 0x5e,
	0x9a, 0x82, 0xda, 0x25, 0x4d, 0x9f, 0xf0, 0x07, 0x87, 0x8c, 0x6c, 0xaa, 0xa7, 0x03, 0x84, 0x8c,
	0x94, 0xb4, 0x68, 0x04, 0x1d, 0x5c, 0x05, 0x2d, 0x2c, 0x27, 0xd3, 0xf1, 0x1c, 0xee, 0x58, 0x9c,
	0xfa, 0x79, 0x45, 0x82, 0x2c, 0x4e, 0x53, 0xd6, 0x65, 0xfc, 0x70, 0x53, 0xfd, 0x4c, 0xd8, 0x5f,
	0x0b, 0x6d, 0x6a, 0x23, 0x13, 0x5c, 0x87, 0xac, 0xd3, 0x21, 0x26, 0x8b, 0x22, 0x91, 0x4f, 0x4a,
	0x88, 0xaf, 0x97, 0x5f, 0x54, 0xb8, 0xe5, 0x89, 0xc4, 0x8e, 0xf0, 0x32, 0x4e, 0x87, 0x8c, 0xa3,
	0x58, 0x87, 0x2c, 0x09, 0xd8, 0x19, 0x96, 0x7a, 0x19, 0xd6, 0x44, 0xf8, 0x47, 0x58, 0x24, 0x60,
	0x63, 0xac, 0xd7, 0x20, 0xeb, 0xd2, 0xa6, 0xe5, 0x9a, 0xc2, 0x3b, 0xc7, 0xce, 0xcf, 0xea, 0x68,
	0x29, 0x1d, 0x29, 0x82, 0x94, 0xd4, 0x3a, 0xa4, 0x66, 0xe3, 0x25, 0x98, 0xf7, 0x49, 0x97, 0x72,
	0x32, 0x52, 0x9c, 0x9b, 0x50, 0xcc, 0x84, 0xa2, 0x50, 0xf3, 0x6d, 0xb8, 0x21, 0x6f, 0xba, 0x6f,
	0x05, 0x64, 0xcd, 0xec, 0x90, 0x43, 0xd3, 0x75, 0x5a, 0x84, 0x3b, 0x5d, 0x92, 0x4f, 0xe9, 0x68,
	0x69, 0x7e, 0x33, 0x25, 0x6c, 0x3e, 0x3c, 0x46, 0x8a, 0xb1, 0x28, 0x6e, 0x25, 0xf5, 0xee, 0x92,
	0xc3, 0x77, 0x23, 0x2d, 0xfc, 0x3a, 0x60, 0x01, 0xe0, 0x13, 0x91, 0x17, 0xa6, 0xd8, 0xa2, 0x3d,
	0x9e, 0x4f, 0xc7, 0x6c, 0x93, 0x86, 0xe6, 0x74, 0x88, 0x21, 0x55, 0x1e, 0x84, 0x1a, 0xb1, 0x83,
	0x2b, 0xf1, 0x83, 0xe1, 0xa2, 0x83, 0x2b, 0x93, 0x07, 0x6f, 0xc2, 0xa2, 0xcd, 0x6c, 0xb3, 0x43,
	0x08, 0x33, 0x2d, 0xd7, 0xe9, 0x13, 0x79, 0xb8, 0x9f, 0xcf, 0x48, 0xeb, 0x85, 0xc8, 0x1a, 0xfd,
	0xf1, 0xef, 0x27, 0x49, 0x75, 0x59, 0xc9, 0x27, 0x8d, 0x05, 0x9b, 0xd9, 0x77, 0x09, 0x61, 0x1b,
	0x42, 0x59, 0xb8, 0xe1, 0xe3, 0x1f, 0x87, 0xce, 0x47, 0xb7, 0x67, 0x3e, 0x6d, 0x39, 0x2e, 0xc9,
	0xe7, 0xf4, 0xe4, 0x52, 0xa6, 0xf2, 0xca, 0x54, 0x84, 0xee, 0xef, 0xbd, 0x4f, 0x9a, 0xdc, 0x20,
	0x2d, 0x99, 0x78, 0x99, 0x27, 0x1f, 0xa8, 0x4e, 0x87, 0xac, 0x49, 0x46, 0xb5, 0x31, 0x33, 0x8d,
	0x10, 0x22, 0x06, 0x5c, 0x19, 0x03, 0x5f, 0xbb, 0x3a, 0x70, 0x25, 0x0e, 0x5c, 0x89, 0x80, 0x4b,
	0x6d, 0xc8, 0xc6, 0xca, 0xe5, 0x6d, 0x98, 0x91, 0xc9, 0x1f, 0x95, 0xca, 0x37, 0x2f, 0x48, 0xd1,
	0xe9, 0x32, 0xdb, 0x49, 0x18, 0xa1, 0xdd, 0xa6, 0x06, 0xaa, 0xe8, 0xf4, 0x38, 0x75, 0x32, 0x40,
	0xe8, 0x74, 0x80, 0x94, 0xba, 0x9a, 0x52, 0xb4, 0x64, 0xc9, 0x85, 0xf9, 0x9a, 0xc7, 0x89, 0xdf,
	0xb2, 0x9a, 0x44, 0x38, 0x86, 0xdf, 0x03, 0x88, 0x72, 0xcf, 0xe3, 0x2d, 0xd9, 0x87, 0xfe, 0xd3,
	0x55, 0x8a, 0x4f, 0x3e, 0x58, 0xf0, 0x08, 0x3f, 0xa0, 0x7e, 0x47, 0x18, 0x85, 0x58, 0x22, 0x1e,
	0x33, 0xbf, 0x44, 0x8a, 0x86, 0x8c, 0x74, 0x98, 0xb1, 0x1e, 0x6f, 0x95, 0xfe, 0x89, 0x00, 0xbf,
	0x2b, 0x57, 0x6c, 0xc3, 0xb6, 0x7d, 0x12, 0x04, 0xf2, 0xcc, 0xef, 0x03, 0x38, 0xcc, 0xb4, 0xc2,
	0x9d, 0xe8, 0x8a, 0xd3, 0x67, 0xc6, 0x2c, 0x76, 0x12, 0x46, 0xda, 0x19, 0x6d, 0xe0, 0x65, 0x50,
	0xad, 0x1e, 0xa7, 0x97, 0x75, 0x80, 0x9d, 0x84, 0x21, 0x75, 0xf0, 0x7b, 0xb0, 0xd8, 0x77, 0x7c,
	0xde, 0xb3, 0x5c, 0x73, 0xe4, 0xb3, 0xe0, 0x25, 0x2a, 0xfd, 0x6f, 0x4d, 0xd9, 0x3e, 0x0c, 0x55,
	0xef, 0x85, 0x9a, 0xbb, 0xc4, 0x25, 0x4d, 0x4e, 0x7d, 0xe1, 0x81, 0x81, 0xfb, 0x31, 0x99, 0x64,
	0x62, 0x9a, 0x64, 0xb5, 0xae, 0xa6, 0x54, 0x6d, 0xa6, 0xf4, 0x73, 0x05, 0xae, 0xc7, 0xaf, 0x3d,
	0x82, 0xc2, 0xdf, 0x03, 0x35, 0x22, 0x5a, 0x9c, 0xff, 0xea, 0x05, 0x71, 0x9d, 0x8c, 0x90, 0xb8,
	0x8a, 0x30, 0xc1, 0xb5, 0x18, 0x6b, 0xe1, 0xe5, 0x97, 0x5e, 0x0c, 0x70, 0x9e, 0xf3, 0x38, 0x83,
	0xf7, 0x21, 0xe7, 0x51, 0x9b, 0x9c, 0x85, 0x2f, 0x6a, 0x5f, 0xfa, 0x14, 0xdc, 0x3d, 0x6a, 0x93,
	0x98, 0x33, 0x61, 0xaf, 0xd9, 0x49, 0x18, 0xf3, 0xde, 0xa4, 0xe8, 0x1c, 0x13, 0xc9, 0xba, 0x9a,
	0x4a, 0x6a, 0x6a, 0x89, 0xc3, 0xa2, 0x21, 0xdb, 0x92, 0x40, 0xda, 0xe0, 0xdc, 0x77, 0xf6, 0x7a,
	0x9c, 0x04, 0x78, 0x05, 0x14, 0x87, 0x5d, 0x25, 0xf2, 0x86, 0xe2, 0xb0, 0xf5, 0xf2, 0x9f, 0x07,
	0x08, 0x83, 0x06, 0x99, 0x10, 0x4b, 0x17, 0x60, 0x18, 0xad, 0x7d, 0x32, 0x40, 0x8b, 0x80, 0x01,
	0x6a, 0x0d, 0x3d, 0xb2, 0x28, 0xa8, 0x02, 0xb7, 0xf4, 0xb7, 0x24, 0xe0, 0x50, 0xb5, 0xea, 0xd9,
	0x8c, 0x3a, 0x9e, 0x7c, 0x55, 0xf0, 0x5f, 0x15, 0x48, 0x93, 0x68, 0x23, 0x7c, 0x1f, 0x33, 0x95,
	0xef, 0xbe, 0x98, 0xc0, 0xf3, 0xd6, 0xe5, 0xd1, 0x22, 0xa8, 0x7a, 0xdc, 0x3f, 0xdc, 0xfc, 0x97,
	0x6c, 0x41, 0xd9, 0x8f, 0x50, 0xba, 0x34, 0xe7, 0xcf, 0x68, 0x28, 0xff, 0x58, 0x11, 0x1b, 0xb3,
	0x1f, 0xa1, 0xa4, 0xf6, 0x18, 0x0d, 0x3f, 0xfd, 0x4b, 0xf2, 0xce, 0xd1, 0x31, 0x7a, 0x07, 0xbf,
	0xf5, 0xf9, 0x00, 0xad, 0x0b, 0x87, 0xf5, 0x16, 0xf5, 0xf5, 0x08, 0x5e, 0xdf, 0x65, 0xa4, 0xe9,
	0xb4, 0x1c, 0x62, 0xeb, 0x56, 0xa0, 0x07, 0x0e, 0x27, 0xeb, 0x82, 0xcf, 0x15, 0xf9, 0xa9, 0x3b,
	0x81, 0x1e, 0xce, 0x59, 0x96, 0xab, 0x0b, 0xa0, 0xdc, 0xd1, 0x31, 0x02, 0x9c, 0x1a, 0x0e, 0x90,
	0x2a, 0x80, 0xc4, 0x16, 0x1c, 0x1d, 0xa3, 0x59, 0xac, 0x7e, 0x3c, 0x40, 0x09, 0xb1, 0x9c, 0x3d,
	0x3a, 0x46, 0x4a, 0x4a, 0x9e, 0xba, 0x7e, 0x74, 0x8c, 0x5e, 0x2f, 0x7c, 0xfb, 0xf3, 0x01, 0xba,
	0x15, 0xb1, 0x65, 0x8d, 0x69, 0x0f, 0x5d, 0xd8, 0x27, 0x91, 0x1b, 0x3a, 0xf5, 0x74, 0x4b, 0x6f,
	0x3b, 0x7d, 0xe2, 0xe9, 0x5e, 0x04, 0xac, 0x1d, 0x1d, 0xa3, 0x6c, 0x01, 0x86, 0x03, 0x34, 0x1b,
	0xbe, 0xc7, 0xe3, 0xd3, 0x0a, 0xaa, 0x88, 0xad, 0x71, 0xc6, 0x60, 0x61, 0x1f, 0x72, 0x71, 0x52,
	0xb0, 0x06, 0xc9, 0x0e, 0x39, 0x94, 0x71, 0x4d, 0x1b, 0xe2, 0x13, 0xbf, 0x03, 0x33, 0x7d, 0xcb,
	0xed, 0x91, 0x28, 0x5f, 0x97, 0x2f, 0xa3, 0x3b, 0x9e, 0x23, 0x46, 0x68, 0xb8, 0xae, 0xbc, 0x81,
	0x4a, 0xbf, 0x41, 0x70, 0x23, 0xd4, 0x39, 0x5f, 0x51, 0xe5, 0xab, 0xa6, 0xd2, 0x4e, 0x42, 0x24,
	0x13, 0xde, 0x89, 0x27, 0xc1, 0x25, 0x55, 0x74, 0x3e, 0x09, 0x44, 0x15, 0x8d, 0x8d, 0x2f, 0x4c,
	0xfa, 0x3f, 0xcd, 0x40, 0x6e, 0xdb, 0xa5, 0x7b, 0x96, 0x2b, 0xc2, 0x2c, 0x53, 0xef, 0x3e, 0x64,
	0xa2, 0x01, 0x46, 0x76, 0x1f, 0xe1, 0x6d, 0xee, 0x5c, 0xb5, 0x45, 0xc7, 0x86, 0x0d, 0x5d, 0x56,
	0x5b, 0x56, 0xa4, 0xd4, 0xdc, 0xcf, 0x90, 0x5a, 0x50, 0x12, 0x8a, 0x01, 0x7c, 0x2c, 0xc1, 0xdb,
	0x90, 0x8a, 0xda, 0x36, 0x93, 0x53, 0x40, 0xa6, 0xb2, 0x72, 0x95, 0x56, 0x30, 0x62, 0xcd, 0x98,
	0x0b, 0x9b, 0x34, 0xc3, 0x75, 0x48, 0x8f, 0x66, 0x0a, 0x26, 0x67, 0x83, 0x4c, 0xe5, 0xe6, 0x65,
	0x74, 0x9c, 0x87, 0x4a, 0x45, 0x83, 0x07, 0xc3, 0xeb, 0x30, 0xcb, 0xe4, 0x3b, 0x24, 0x27, 0x98,
	0xcc, 0xb9, 0x79, 0x36, 0x76, 0xc1, 0xf0, 0xc5, 0x32, 0x22, 0x0b, 0xdc, 0x80, 0xbc, 0x4d, 0x5a,
	0x56, 0xcf, 0xe5, 0x66, 0xc4, 0xd4, 0x38, 0x6f, 0xe5, 0xe4, 0x70, 0x71, 0xa3, 0xbf, 0x1e, 0xd9,
	0x85, 0xb0, 0xe3, 0x04, 0xc2, 0x1b, 0xb0, 0x30, 0xe2, 0x9c, 0x9a, 0xd6, 0x41, 0x60, 0xf2, 0xf6,
	0x81, 0x1c, 0x23, 0x2e, 0x86, 0xca, 0x45, 0x0c, 0xd3, 0x8d, 0x83, 0xe0, 0x41, 0xfb, 0x00, 0xbf,
	0x0f, 0x05, 0x9b, 0x30, 0x97, 0x1e, 0x76, 0x89, 0xc7, 0xcd, 0x3e, 0xf3, 0xcc, 0xc9, 0x28, 0x66,
	0x65, 0x14, 0x2f, 0x60, 0xeb, 0xce, 0xd8, 0xee, 0x61, 0xe3, 0xde, 0x59, 0x48, 0x8d, 0x1b, 0x67,
	0x80, 0x0f, 0x99, 0x77, 0x26, 0xc0, 0x77, 0x20, 0xd5, 0x6c, 0xb5, 0x43, 0xe4, 0xc5, 0xcb, 0x5e,
	0x87, 0x2d, 0xea, 0xb5, 0x9c, 0x76, 0xcf, 0x9f, 0x68, 0xc8, 0xc6, 0x5c, 0xb3, 0xd5, 0x96, 0xcb,
	0x6f, 0x8c, 0x27, 0xe5, 0x31, 0x7d, 0x78, 0xe1, 0x64, 0x80, 0xe0, 0x74, 0x80, 0xd2, 0xc3, 0x01,
	0x9a, 0x59, 0xbb, 0xb5, 0xb2, 0xb6, 0x16, 0x0e, 0x03, 0x61, 0xba, 0x86, 0x6f, 0x56, 0x5d, 0x4d,
	0xcd, 0x68, 0xb3, 0x75, 0x35, 0x95, 0xd6, 0xa0, 0xf4, 0x04, 0xc1, 0x7c, 0xec, 0x14, 0xfc, 0x26,
	0xe4, 0xc8, 0x23, 0x6e, 0x36, 0xa9, 0xe7, 0x99, 0xe1, 0x60, 0x72, 0xf9, 0xe3, 0x9b, 0x25, 0x8f,
	0xf8, 0x16, 0xf5, 0x3c, 0x39, 0xa1, 0xe0, 0x37, 0x20, 0x3b, 0xb6, 0x6e, 0xfb, 0xa3, 0xc7, 0xf7,
	0x22, 0x5b, 0x88, 0x6c, 0xb7, 0x7d, 0xb2, 0xf9, 0xf2, 0x19, 0x29, 0xf8, 0xda, 0xc9, 0x00, 0x29,
	0xe2, 0x87, 0xc1, 0x70, 0x80, 0x92, 0x95, 0x95, 0xdb, 0x75, 0x35, 0x85, 0x34, 0xa5, 0xf4, 0x7b,
	0x05, 0x72, 0x5b, 0x3e, 0xb1, 0x38, 0x19, 0x57, 0xdb, 0xc6, 0x7f, 0x55, 0x6d, 0xff, 0xd7, 0xf5,
	0xb5, 0xbe, 0xf0, 0xc9, 0x5b, 0x53, 0x4d, 0xa9, 0xf4, 0x07, 0x05, 0xae, 0x19, 0x84, 0xb9, 0x56,
	0xf3, 0x2b, 0xea, 0xbe, 0x24, 0x75, 0xbf, 0x53, 0x20, 0xb3, 0x4d, 0xf8, 0x57, 0xb4, 0x7d, 0x29,
	0xda, 0x96, 0x6f, 0xc1, 0x8d, 0x0b, 0xfa, 0x22, 0x9e, 0x83, 0xe4, 0xce, 0x8f, 0x36, 0xb5, 0x04,
	0xce, 0x42, 0x6a, 0xb7, 0x6a, 0x3c, 0xac, 0x6d, 0x55, 0x77, 0x35, 0xb4, 0xbc, 0x0c, 0x30, 0xa1,
	0x34, 0x0f, 0xe9, 0x5a, 0x63, 0xb7, 0xba, 0x65, 0x36, 0x76, 0xef, 0x6a, 0x09, 0x61, 0xb3, 0x6d,
	0x54, 0x35, 0xa5, 0x24, 0x3a, 0x01, 0xda, 0xfc, 0x10, 0x9d, 0x3e, 0x2b, 0x26, 0x9e, 0x3e, 0x2b,
	0x26, 0xbe, 0x78, 0x56, 0x44, 0x8f, 0x87, 0x45, 0xf4, 0xeb, 0x61, 0x11, 0x7d, 0x3c, 0x2c, 0xa2,
	0xd3, 0x61, 0x11, 0x3d, 0x1d, 0x16, 0xd1, 0xa7, 0xc3, 0x22, 0xfa, 0x6c, 0x58, 0x4c, 0x7c, 0x31,
	0x2c, 0xa2, 0x5f, 0x3c, 0x2f, 0x26, 0x4e, 0x9e, 0x17, 0xd1, 0xe9, 0xf3, 0x62, 0xe2, 0xe9, 0xf3,
	0x62, 0xe2, 0xa7, 0xf5, 0x36, 0x65, 0x9d, 0x76, 0xb9, 0x4f, 0x5d, 0x4e, 0x7c, 0xdf, 0x2a, 0xf7,
	0x82, 0x55, 0xf9, 0xd1, 0xa2, 0x7e, 0xf7, 0x26, 0xf3, 0x69, 0xdf, 0xb1, 0x89, 0x7f, 0x73, 0x24,
	0x5e, 0x65, 0x7b, 0x6d, 0xba, 0x4a, 0x1e, 0xf1, 0xe8, 0xef, 0xb1, 0xd8, 0xff, 0x82, 0x7b, 0xb3,
	0xf2, 0x0f, 0xb2, 0xdb, 0xff, 0x0e, 0x00, 0x00, 0xff, 0xff, 0xc3, 0xba, 0xab, 0xb7, 0x36, 0x14,
	0x00, 0x00,
}

func (x DeploymentVPNTunnelType) String() string {
	s, ok := DeploymentVPNTunnelType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TunnelType) String() string {
	s, ok := TunnelType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *IKEProposal) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IKEProposal)
	if !ok {
		that2, ok := that.(IKEProposal)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.EncryptionAlgos) != len(that1.EncryptionAlgos) {
		return false
	}
	for i := range this.EncryptionAlgos {
		if this.EncryptionAlgos[i] != that1.EncryptionAlgos[i] {
			return false
		}
	}
	if len(this.AuthenticationAlgos) != len(that1.AuthenticationAlgos) {
		return false
	}
	for i := range this.AuthenticationAlgos {
		if this.AuthenticationAlgos[i] != that1.AuthenticationAlgos[i] {
			return false
		}
	}
	if len(this.Prf) != len(that1.Prf) {
		return false
	}
	for i := range this.Prf {
		if this.Prf[i] != that1.Prf[i] {
			return false
		}
	}
	if len(this.DhGroups) != len(that1.DhGroups) {
		return false
	}
	for i := range this.DhGroups {
		if this.DhGroups[i] != that1.DhGroups[i] {
			return false
		}
	}
	return true
}
func (this *ESPProposal) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ESPProposal)
	if !ok {
		that2, ok := that.(ESPProposal)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.EncryptionAlgos) != len(that1.EncryptionAlgos) {
		return false
	}
	for i := range this.EncryptionAlgos {
		if this.EncryptionAlgos[i] != that1.EncryptionAlgos[i] {
			return false
		}
	}
	if len(this.AuthenticationAlgos) != len(that1.AuthenticationAlgos) {
		return false
	}
	for i := range this.AuthenticationAlgos {
		if this.AuthenticationAlgos[i] != that1.AuthenticationAlgos[i] {
			return false
		}
	}
	if len(this.DhGroups) != len(that1.DhGroups) {
		return false
	}
	for i := range this.DhGroups {
		if this.DhGroups[i] != that1.DhGroups[i] {
			return false
		}
	}
	return true
}
func (this *IpsecTunnelParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpsecTunnelParams)
	if !ok {
		that2, ok := that.(IpsecTunnelParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpsecPsk.Equal(that1.IpsecPsk) {
		return false
	}
	if !this.TunnelInitiator.Equal(that1.TunnelInitiator) {
		return false
	}
	if !this.IkeProposal.Equal(that1.IkeProposal) {
		return false
	}
	if !this.EspProposal.Equal(that1.EspProposal) {
		return false
	}
	if this.LocalIkeId != that1.LocalIkeId {
		return false
	}
	if this.RemoteIkeId != that1.RemoteIkeId {
		return false
	}
	if this.IkePhase1KeyLifetime != that1.IkePhase1KeyLifetime {
		return false
	}
	if this.IkeReauthTimeout != that1.IkeReauthTimeout {
		return false
	}
	if this.IkePhase2KeyLifetime != that1.IkePhase2KeyLifetime {
		return false
	}
	if this.DpdKeepAliveTimer != that1.DpdKeepAliveTimer {
		return false
	}
	if len(this.IkePhase1Profile) != len(that1.IkePhase1Profile) {
		return false
	}
	for i := range this.IkePhase1Profile {
		if !this.IkePhase1Profile[i].Equal(that1.IkePhase1Profile[i]) {
			return false
		}
	}
	if len(this.IkePhase2Profile) != len(that1.IkePhase2Profile) {
		return false
	}
	for i := range this.IkePhase2Profile {
		if !this.IkePhase2Profile[i].Equal(that1.IkePhase2Profile[i]) {
			return false
		}
	}
	return true
}
func (this *TunnelParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TunnelParams)
	if !ok {
		that2, ok := that.(TunnelParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Type == nil {
		if this.Type != nil {
			return false
		}
	} else if this.Type == nil {
		return false
	} else if !this.Type.Equal(that1.Type) {
		return false
	}
	return true
}
func (this *TunnelParams_Ipsec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TunnelParams_Ipsec)
	if !ok {
		that2, ok := that.(TunnelParams_Ipsec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipsec.Equal(that1.Ipsec) {
		return false
	}
	return true
}
func (this *InterfaceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceType)
	if !ok {
		that2, ok := that.(InterfaceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.LocalIntf) != len(that1.LocalIntf) {
		return false
	}
	for i := range this.LocalIntf {
		if !this.LocalIntf[i].Equal(that1.LocalIntf[i]) {
			return false
		}
	}
	return true
}
func (this *LocalIpAddressType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalIpAddressType)
	if !ok {
		that2, ok := that.(LocalIpAddressType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Type == nil {
		if this.Type != nil {
			return false
		}
	} else if this.Type == nil {
		return false
	} else if !this.Type.Equal(that1.Type) {
		return false
	}
	if !this.VirtualNetworkType.Equal(that1.VirtualNetworkType) {
		return false
	}
	return true
}
func (this *LocalIpAddressType_IpAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalIpAddressType_IpAddress)
	if !ok {
		that2, ok := that.(LocalIpAddressType_IpAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpAddress.Equal(that1.IpAddress) {
		return false
	}
	return true
}
func (this *LocalIpAddressType_Auto) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalIpAddressType_Auto)
	if !ok {
		that2, ok := that.(LocalIpAddressType_Auto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Auto.Equal(that1.Auto) {
		return false
	}
	return true
}
func (this *LocalIpAddressSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalIpAddressSelector)
	if !ok {
		that2, ok := that.(LocalIpAddressSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Type == nil {
		if this.Type != nil {
			return false
		}
	} else if this.Type == nil {
		return false
	} else if !this.Type.Equal(that1.Type) {
		return false
	}
	return true
}
func (this *LocalIpAddressSelector_Intf) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalIpAddressSelector_Intf)
	if !ok {
		that2, ok := that.(LocalIpAddressSelector_Intf)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Intf.Equal(that1.Intf) {
		return false
	}
	return true
}
func (this *LocalIpAddressSelector_IpAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalIpAddressSelector_IpAddress)
	if !ok {
		that2, ok := that.(LocalIpAddressSelector_IpAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IpAddress.Equal(that1.IpAddress) {
		return false
	}
	return true
}
func (this *LocalIpAddressSelector_NodeInterface) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalIpAddressSelector_NodeInterface)
	if !ok {
		that2, ok := that.(LocalIpAddressSelector_NodeInterface)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NodeInterface.Equal(that1.NodeInterface) {
		return false
	}
	return true
}
func (this *RemoteNodeAttributes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemoteNodeAttributes)
	if !ok {
		that2, ok := that.(RemoteNodeAttributes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ip.Equal(that1.Ip) {
		return false
	}
	return true
}
func (this *RemoteEndpointType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemoteEndpointType)
	if !ok {
		that2, ok := that.(RemoteEndpointType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Endpoints) != len(that1.Endpoints) {
		return false
	}
	for i := range this.Endpoints {
		if !this.Endpoints[i].Equal(that1.Endpoints[i]) {
			return false
		}
	}
	return true
}
func (this *RemoteIpAddressSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemoteIpAddressSelector)
	if !ok {
		that2, ok := that.(RemoteIpAddressSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Type == nil {
		if this.Type != nil {
			return false
		}
	} else if this.Type == nil {
		return false
	} else if !this.Type.Equal(that1.Type) {
		return false
	}
	return true
}
func (this *RemoteIpAddressSelector_Ip) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemoteIpAddressSelector_Ip)
	if !ok {
		that2, ok := that.(RemoteIpAddressSelector_Ip)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ip.Equal(that1.Ip) {
		return false
	}
	return true
}
func (this *RemoteIpAddressSelector_Endpoints) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemoteIpAddressSelector_Endpoints)
	if !ok {
		that2, ok := that.(RemoteIpAddressSelector_Endpoints)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Endpoints.Equal(that1.Endpoints) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TunnelType != that1.TunnelType {
		return false
	}
	if !this.LocalIp.Equal(that1.LocalIp) {
		return false
	}
	if !this.RemoteIp.Equal(that1.RemoteIp) {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	if that1.TunnelAttribute == nil {
		if this.TunnelAttribute != nil {
			return false
		}
	} else if this.TunnelAttribute == nil {
		return false
	} else if !this.TunnelAttribute.Equal(that1.TunnelAttribute) {
		return false
	}
	if this.DeploymentVpnTunnelType != that1.DeploymentVpnTunnelType {
		return false
	}
	if !this.CfgType.Equal(that1.CfgType) {
		return false
	}
	return true
}
func (this *GlobalSpecType_DefaultTunnelAttribute) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_DefaultTunnelAttribute)
	if !ok {
		that2, ok := that.(GlobalSpecType_DefaultTunnelAttribute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultTunnelAttribute.Equal(that1.DefaultTunnelAttribute) {
		return false
	}
	return true
}
func (this *GlobalSpecType_TunnelToAwsTgw) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_TunnelToAwsTgw)
	if !ok {
		that2, ok := that.(GlobalSpecType_TunnelToAwsTgw)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TunnelToAwsTgw.Equal(that1.TunnelToAwsTgw) {
		return false
	}
	return true
}
func (this *ConfigureType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConfigureType)
	if !ok {
		that2, ok := that.(ConfigureType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.CfgType == nil {
		if this.CfgType != nil {
			return false
		}
	} else if this.CfgType == nil {
		return false
	} else if !this.CfgType.Equal(that1.CfgType) {
		return false
	}
	return true
}
func (this *ConfigureType_ExtConnIpsec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConfigureType_ExtConnIpsec)
	if !ok {
		that2, ok := that.(ConfigureType_ExtConnIpsec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExtConnIpsec.Equal(that1.ExtConnIpsec) {
		return false
	}
	return true
}
func (this *ConfigureType_ExtConnGre) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConfigureType_ExtConnGre)
	if !ok {
		that2, ok := that.(ConfigureType_ExtConnGre)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExtConnGre.Equal(that1.ExtConnGre) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TunnelType != that1.TunnelType {
		return false
	}
	if !this.LocalIp.Equal(that1.LocalIp) {
		return false
	}
	if !this.RemoteIp.Equal(that1.RemoteIp) {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TunnelType != that1.TunnelType {
		return false
	}
	if !this.LocalIp.Equal(that1.LocalIp) {
		return false
	}
	if !this.RemoteIp.Equal(that1.RemoteIp) {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TunnelType != that1.TunnelType {
		return false
	}
	if !this.LocalIp.Equal(that1.LocalIp) {
		return false
	}
	if !this.RemoteIp.Equal(that1.RemoteIp) {
		return false
	}
	if !this.Params.Equal(that1.Params) {
		return false
	}
	return true
}
func (this *IKEProposal) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tunnel.IKEProposal{")
	s = append(s, "EncryptionAlgos: "+fmt.Sprintf("%#v", this.EncryptionAlgos)+",\n")
	s = append(s, "AuthenticationAlgos: "+fmt.Sprintf("%#v", this.AuthenticationAlgos)+",\n")
	s = append(s, "Prf: "+fmt.Sprintf("%#v", this.Prf)+",\n")
	s = append(s, "DhGroups: "+fmt.Sprintf("%#v", this.DhGroups)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ESPProposal) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tunnel.ESPProposal{")
	s = append(s, "EncryptionAlgos: "+fmt.Sprintf("%#v", this.EncryptionAlgos)+",\n")
	s = append(s, "AuthenticationAlgos: "+fmt.Sprintf("%#v", this.AuthenticationAlgos)+",\n")
	s = append(s, "DhGroups: "+fmt.Sprintf("%#v", this.DhGroups)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IpsecTunnelParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&tunnel.IpsecTunnelParams{")
	if this.IpsecPsk != nil {
		s = append(s, "IpsecPsk: "+fmt.Sprintf("%#v", this.IpsecPsk)+",\n")
	}
	if this.TunnelInitiator != nil {
		s = append(s, "TunnelInitiator: "+fmt.Sprintf("%#v", this.TunnelInitiator)+",\n")
	}
	if this.IkeProposal != nil {
		s = append(s, "IkeProposal: "+fmt.Sprintf("%#v", this.IkeProposal)+",\n")
	}
	if this.EspProposal != nil {
		s = append(s, "EspProposal: "+fmt.Sprintf("%#v", this.EspProposal)+",\n")
	}
	s = append(s, "LocalIkeId: "+fmt.Sprintf("%#v", this.LocalIkeId)+",\n")
	s = append(s, "RemoteIkeId: "+fmt.Sprintf("%#v", this.RemoteIkeId)+",\n")
	s = append(s, "IkePhase1KeyLifetime: "+fmt.Sprintf("%#v", this.IkePhase1KeyLifetime)+",\n")
	s = append(s, "IkeReauthTimeout: "+fmt.Sprintf("%#v", this.IkeReauthTimeout)+",\n")
	s = append(s, "IkePhase2KeyLifetime: "+fmt.Sprintf("%#v", this.IkePhase2KeyLifetime)+",\n")
	s = append(s, "DpdKeepAliveTimer: "+fmt.Sprintf("%#v", this.DpdKeepAliveTimer)+",\n")
	if this.IkePhase1Profile != nil {
		s = append(s, "IkePhase1Profile: "+fmt.Sprintf("%#v", this.IkePhase1Profile)+",\n")
	}
	if this.IkePhase2Profile != nil {
		s = append(s, "IkePhase2Profile: "+fmt.Sprintf("%#v", this.IkePhase2Profile)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TunnelParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tunnel.TunnelParams{")
	if this.Type != nil {
		s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TunnelParams_Ipsec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.TunnelParams_Ipsec{` +
		`Ipsec:` + fmt.Sprintf("%#v", this.Ipsec) + `}`}, ", ")
	return s
}
func (this *InterfaceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tunnel.InterfaceType{")
	if this.LocalIntf != nil {
		s = append(s, "LocalIntf: "+fmt.Sprintf("%#v", this.LocalIntf)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LocalIpAddressType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tunnel.LocalIpAddressType{")
	if this.Type != nil {
		s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	}
	if this.VirtualNetworkType != nil {
		s = append(s, "VirtualNetworkType: "+fmt.Sprintf("%#v", this.VirtualNetworkType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LocalIpAddressType_IpAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.LocalIpAddressType_IpAddress{` +
		`IpAddress:` + fmt.Sprintf("%#v", this.IpAddress) + `}`}, ", ")
	return s
}
func (this *LocalIpAddressType_Auto) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.LocalIpAddressType_Auto{` +
		`Auto:` + fmt.Sprintf("%#v", this.Auto) + `}`}, ", ")
	return s
}
func (this *LocalIpAddressSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&tunnel.LocalIpAddressSelector{")
	if this.Type != nil {
		s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LocalIpAddressSelector_Intf) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.LocalIpAddressSelector_Intf{` +
		`Intf:` + fmt.Sprintf("%#v", this.Intf) + `}`}, ", ")
	return s
}
func (this *LocalIpAddressSelector_IpAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.LocalIpAddressSelector_IpAddress{` +
		`IpAddress:` + fmt.Sprintf("%#v", this.IpAddress) + `}`}, ", ")
	return s
}
func (this *LocalIpAddressSelector_NodeInterface) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.LocalIpAddressSelector_NodeInterface{` +
		`NodeInterface:` + fmt.Sprintf("%#v", this.NodeInterface) + `}`}, ", ")
	return s
}
func (this *RemoteNodeAttributes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tunnel.RemoteNodeAttributes{")
	if this.Ip != nil {
		s = append(s, "Ip: "+fmt.Sprintf("%#v", this.Ip)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RemoteEndpointType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&tunnel.RemoteEndpointType{")
	keysForEndpoints := make([]string, 0, len(this.Endpoints))
	for k, _ := range this.Endpoints {
		keysForEndpoints = append(keysForEndpoints, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEndpoints)
	mapStringForEndpoints := "map[string]*RemoteNodeAttributes{"
	for _, k := range keysForEndpoints {
		mapStringForEndpoints += fmt.Sprintf("%#v: %#v,", k, this.Endpoints[k])
	}
	mapStringForEndpoints += "}"
	if this.Endpoints != nil {
		s = append(s, "Endpoints: "+mapStringForEndpoints+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RemoteIpAddressSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tunnel.RemoteIpAddressSelector{")
	if this.Type != nil {
		s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RemoteIpAddressSelector_Ip) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.RemoteIpAddressSelector_Ip{` +
		`Ip:` + fmt.Sprintf("%#v", this.Ip) + `}`}, ", ")
	return s
}
func (this *RemoteIpAddressSelector_Endpoints) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.RemoteIpAddressSelector_Endpoints{` +
		`Endpoints:` + fmt.Sprintf("%#v", this.Endpoints) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&tunnel.GlobalSpecType{")
	s = append(s, "TunnelType: "+fmt.Sprintf("%#v", this.TunnelType)+",\n")
	if this.LocalIp != nil {
		s = append(s, "LocalIp: "+fmt.Sprintf("%#v", this.LocalIp)+",\n")
	}
	if this.RemoteIp != nil {
		s = append(s, "RemoteIp: "+fmt.Sprintf("%#v", this.RemoteIp)+",\n")
	}
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	if this.TunnelAttribute != nil {
		s = append(s, "TunnelAttribute: "+fmt.Sprintf("%#v", this.TunnelAttribute)+",\n")
	}
	s = append(s, "DeploymentVpnTunnelType: "+fmt.Sprintf("%#v", this.DeploymentVpnTunnelType)+",\n")
	if this.CfgType != nil {
		s = append(s, "CfgType: "+fmt.Sprintf("%#v", this.CfgType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_DefaultTunnelAttribute) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.GlobalSpecType_DefaultTunnelAttribute{` +
		`DefaultTunnelAttribute:` + fmt.Sprintf("%#v", this.DefaultTunnelAttribute) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_TunnelToAwsTgw) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.GlobalSpecType_TunnelToAwsTgw{` +
		`TunnelToAwsTgw:` + fmt.Sprintf("%#v", this.TunnelToAwsTgw) + `}`}, ", ")
	return s
}
func (this *ConfigureType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&tunnel.ConfigureType{")
	if this.CfgType != nil {
		s = append(s, "CfgType: "+fmt.Sprintf("%#v", this.CfgType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConfigureType_ExtConnIpsec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.ConfigureType_ExtConnIpsec{` +
		`ExtConnIpsec:` + fmt.Sprintf("%#v", this.ExtConnIpsec) + `}`}, ", ")
	return s
}
func (this *ConfigureType_ExtConnGre) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&tunnel.ConfigureType_ExtConnGre{` +
		`ExtConnGre:` + fmt.Sprintf("%#v", this.ExtConnGre) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tunnel.CreateSpecType{")
	s = append(s, "TunnelType: "+fmt.Sprintf("%#v", this.TunnelType)+",\n")
	if this.LocalIp != nil {
		s = append(s, "LocalIp: "+fmt.Sprintf("%#v", this.LocalIp)+",\n")
	}
	if this.RemoteIp != nil {
		s = append(s, "RemoteIp: "+fmt.Sprintf("%#v", this.RemoteIp)+",\n")
	}
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tunnel.ReplaceSpecType{")
	s = append(s, "TunnelType: "+fmt.Sprintf("%#v", this.TunnelType)+",\n")
	if this.LocalIp != nil {
		s = append(s, "LocalIp: "+fmt.Sprintf("%#v", this.LocalIp)+",\n")
	}
	if this.RemoteIp != nil {
		s = append(s, "RemoteIp: "+fmt.Sprintf("%#v", this.RemoteIp)+",\n")
	}
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&tunnel.GetSpecType{")
	s = append(s, "TunnelType: "+fmt.Sprintf("%#v", this.TunnelType)+",\n")
	if this.LocalIp != nil {
		s = append(s, "LocalIp: "+fmt.Sprintf("%#v", this.LocalIp)+",\n")
	}
	if this.RemoteIp != nil {
		s = append(s, "RemoteIp: "+fmt.Sprintf("%#v", this.RemoteIp)+",\n")
	}
	if this.Params != nil {
		s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *IKEProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IKEProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IKEProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DhGroups) > 0 {
		dAtA2 := make([]byte, len(m.DhGroups)*10)
		var j1 int
		for _, num := range m.DhGroups {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintTypes(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Prf) > 0 {
		dAtA4 := make([]byte, len(m.Prf)*10)
		var j3 int
		for _, num := range m.Prf {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintTypes(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AuthenticationAlgos) > 0 {
		dAtA6 := make([]byte, len(m.AuthenticationAlgos)*10)
		var j5 int
		for _, num := range m.AuthenticationAlgos {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintTypes(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EncryptionAlgos) > 0 {
		dAtA8 := make([]byte, len(m.EncryptionAlgos)*10)
		var j7 int
		for _, num := range m.EncryptionAlgos {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintTypes(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ESPProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ESPProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ESPProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DhGroups) > 0 {
		dAtA10 := make([]byte, len(m.DhGroups)*10)
		var j9 int
		for _, num := range m.DhGroups {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintTypes(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AuthenticationAlgos) > 0 {
		dAtA12 := make([]byte, len(m.AuthenticationAlgos)*10)
		var j11 int
		for _, num := range m.AuthenticationAlgos {
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintTypes(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EncryptionAlgos) > 0 {
		dAtA14 := make([]byte, len(m.EncryptionAlgos)*10)
		var j13 int
		for _, num := range m.EncryptionAlgos {
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintTypes(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IpsecTunnelParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecTunnelParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpsecTunnelParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IkePhase2Profile) > 0 {
		for iNdEx := len(m.IkePhase2Profile) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IkePhase2Profile[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.IkePhase1Profile) > 0 {
		for iNdEx := len(m.IkePhase1Profile) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IkePhase1Profile[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if m.DpdKeepAliveTimer != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DpdKeepAliveTimer))
		i--
		dAtA[i] = 0x58
	}
	if m.IkePhase2KeyLifetime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.IkePhase2KeyLifetime))
		i--
		dAtA[i] = 0x50
	}
	if m.IkeReauthTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.IkeReauthTimeout))
		i--
		dAtA[i] = 0x48
	}
	if m.IkePhase1KeyLifetime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.IkePhase1KeyLifetime))
		i--
		dAtA[i] = 0x40
	}
	if len(m.RemoteIkeId) > 0 {
		i -= len(m.RemoteIkeId)
		copy(dAtA[i:], m.RemoteIkeId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RemoteIkeId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.LocalIkeId) > 0 {
		i -= len(m.LocalIkeId)
		copy(dAtA[i:], m.LocalIkeId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LocalIkeId)))
		i--
		dAtA[i] = 0x32
	}
	if m.EspProposal != nil {
		{
			size, err := m.EspProposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.IkeProposal != nil {
		{
			size, err := m.IkeProposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TunnelInitiator != nil {
		{
			size, err := m.TunnelInitiator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.IpsecPsk != nil {
		{
			size, err := m.IpsecPsk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TunnelParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size := m.Type.Size()
			i -= size
			if _, err := m.Type.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *TunnelParams_Ipsec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelParams_Ipsec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ipsec != nil {
		{
			size, err := m.Ipsec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *InterfaceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LocalIntf) > 0 {
		for iNdEx := len(m.LocalIntf) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LocalIntf[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LocalIpAddressType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalIpAddressType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalIpAddressType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VirtualNetworkType != nil {
		{
			size, err := m.VirtualNetworkType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != nil {
		{
			size := m.Type.Size()
			i -= size
			if _, err := m.Type.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *LocalIpAddressType_IpAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalIpAddressType_IpAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpAddress != nil {
		{
			size, err := m.IpAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *LocalIpAddressType_Auto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalIpAddressType_Auto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Auto != nil {
		{
			size, err := m.Auto.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *LocalIpAddressSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalIpAddressSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalIpAddressSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size := m.Type.Size()
			i -= size
			if _, err := m.Type.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *LocalIpAddressSelector_Intf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalIpAddressSelector_Intf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Intf != nil {
		{
			size, err := m.Intf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *LocalIpAddressSelector_IpAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalIpAddressSelector_IpAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IpAddress != nil {
		{
			size, err := m.IpAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *LocalIpAddressSelector_NodeInterface) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalIpAddressSelector_NodeInterface) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NodeInterface != nil {
		{
			size, err := m.NodeInterface.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *RemoteNodeAttributes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteNodeAttributes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteNodeAttributes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ip != nil {
		{
			size, err := m.Ip.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemoteEndpointType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteEndpointType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteEndpointType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Endpoints) > 0 {
		keysForEndpoints := make([]string, 0, len(m.Endpoints))
		for k := range m.Endpoints {
			keysForEndpoints = append(keysForEndpoints, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForEndpoints)
		for iNdEx := len(keysForEndpoints) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Endpoints[string(keysForEndpoints[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTypes(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForEndpoints[iNdEx])
			copy(dAtA[i:], keysForEndpoints[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForEndpoints[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *RemoteIpAddressSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteIpAddressSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteIpAddressSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size := m.Type.Size()
			i -= size
			if _, err := m.Type.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RemoteIpAddressSelector_Ip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteIpAddressSelector_Ip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ip != nil {
		{
			size, err := m.Ip.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *RemoteIpAddressSelector_Endpoints) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteIpAddressSelector_Endpoints) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Endpoints != nil {
		{
			size, err := m.Endpoints.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CfgType != nil {
		{
			size, err := m.CfgType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.DeploymentVpnTunnelType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DeploymentVpnTunnelType))
		i--
		dAtA[i] = 0x60
	}
	if m.TunnelAttribute != nil {
		{
			size := m.TunnelAttribute.Size()
			i -= size
			if _, err := m.TunnelAttribute.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.RemoteIp != nil {
		{
			size, err := m.RemoteIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.LocalIp != nil {
		{
			size, err := m.LocalIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.TunnelType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_DefaultTunnelAttribute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_DefaultTunnelAttribute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultTunnelAttribute != nil {
		{
			size, err := m.DefaultTunnelAttribute.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_TunnelToAwsTgw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_TunnelToAwsTgw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TunnelToAwsTgw != nil {
		{
			size, err := m.TunnelToAwsTgw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *ConfigureType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigureType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigureType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CfgType != nil {
		{
			size := m.CfgType.Size()
			i -= size
			if _, err := m.CfgType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ConfigureType_ExtConnIpsec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigureType_ExtConnIpsec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ExtConnIpsec != nil {
		{
			size, err := m.ExtConnIpsec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ConfigureType_ExtConnGre) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigureType_ExtConnGre) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ExtConnGre != nil {
		{
			size, err := m.ExtConnGre.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RemoteIp != nil {
		{
			size, err := m.RemoteIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.LocalIp != nil {
		{
			size, err := m.LocalIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.TunnelType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RemoteIp != nil {
		{
			size, err := m.RemoteIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.LocalIp != nil {
		{
			size, err := m.LocalIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.TunnelType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RemoteIp != nil {
		{
			size, err := m.RemoteIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.LocalIp != nil {
		{
			size, err := m.LocalIp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.TunnelType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *IKEProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EncryptionAlgos) > 0 {
		l = 0
		for _, e := range m.EncryptionAlgos {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.AuthenticationAlgos) > 0 {
		l = 0
		for _, e := range m.AuthenticationAlgos {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.Prf) > 0 {
		l = 0
		for _, e := range m.Prf {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.DhGroups) > 0 {
		l = 0
		for _, e := range m.DhGroups {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *ESPProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EncryptionAlgos) > 0 {
		l = 0
		for _, e := range m.EncryptionAlgos {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.AuthenticationAlgos) > 0 {
		l = 0
		for _, e := range m.AuthenticationAlgos {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.DhGroups) > 0 {
		l = 0
		for _, e := range m.DhGroups {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *IpsecTunnelParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpsecPsk != nil {
		l = m.IpsecPsk.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TunnelInitiator != nil {
		l = m.TunnelInitiator.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IkeProposal != nil {
		l = m.IkeProposal.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EspProposal != nil {
		l = m.EspProposal.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.LocalIkeId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RemoteIkeId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IkePhase1KeyLifetime != 0 {
		n += 1 + sovTypes(uint64(m.IkePhase1KeyLifetime))
	}
	if m.IkeReauthTimeout != 0 {
		n += 1 + sovTypes(uint64(m.IkeReauthTimeout))
	}
	if m.IkePhase2KeyLifetime != 0 {
		n += 1 + sovTypes(uint64(m.IkePhase2KeyLifetime))
	}
	if m.DpdKeepAliveTimer != 0 {
		n += 1 + sovTypes(uint64(m.DpdKeepAliveTimer))
	}
	if len(m.IkePhase1Profile) > 0 {
		for _, e := range m.IkePhase1Profile {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.IkePhase2Profile) > 0 {
		for _, e := range m.IkePhase2Profile {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *TunnelParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *TunnelParams_Ipsec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ipsec != nil {
		l = m.Ipsec.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *InterfaceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LocalIntf) > 0 {
		for _, e := range m.LocalIntf {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *LocalIpAddressType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	if m.VirtualNetworkType != nil {
		l = m.VirtualNetworkType.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *LocalIpAddressType_IpAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpAddress != nil {
		l = m.IpAddress.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LocalIpAddressType_Auto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Auto != nil {
		l = m.Auto.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LocalIpAddressSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *LocalIpAddressSelector_Intf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Intf != nil {
		l = m.Intf.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LocalIpAddressSelector_IpAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IpAddress != nil {
		l = m.IpAddress.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *LocalIpAddressSelector_NodeInterface) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeInterface != nil {
		l = m.NodeInterface.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RemoteNodeAttributes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ip != nil {
		l = m.Ip.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RemoteEndpointType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Endpoints) > 0 {
		for k, v := range m.Endpoints {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RemoteIpAddressSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *RemoteIpAddressSelector_Ip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ip != nil {
		l = m.Ip.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RemoteIpAddressSelector_Endpoints) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Endpoints != nil {
		l = m.Endpoints.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TunnelType != 0 {
		n += 1 + sovTypes(uint64(m.TunnelType))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LocalIp != nil {
		l = m.LocalIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RemoteIp != nil {
		l = m.RemoteIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TunnelAttribute != nil {
		n += m.TunnelAttribute.Size()
	}
	if m.DeploymentVpnTunnelType != 0 {
		n += 1 + sovTypes(uint64(m.DeploymentVpnTunnelType))
	}
	if m.CfgType != nil {
		l = m.CfgType.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType_DefaultTunnelAttribute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultTunnelAttribute != nil {
		l = m.DefaultTunnelAttribute.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_TunnelToAwsTgw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TunnelToAwsTgw != nil {
		l = m.TunnelToAwsTgw.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ConfigureType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CfgType != nil {
		n += m.CfgType.Size()
	}
	return n
}

func (m *ConfigureType_ExtConnIpsec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExtConnIpsec != nil {
		l = m.ExtConnIpsec.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ConfigureType_ExtConnGre) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExtConnGre != nil {
		l = m.ExtConnGre.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TunnelType != 0 {
		n += 1 + sovTypes(uint64(m.TunnelType))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LocalIp != nil {
		l = m.LocalIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RemoteIp != nil {
		l = m.RemoteIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TunnelType != 0 {
		n += 1 + sovTypes(uint64(m.TunnelType))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LocalIp != nil {
		l = m.LocalIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RemoteIp != nil {
		l = m.RemoteIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TunnelType != 0 {
		n += 1 + sovTypes(uint64(m.TunnelType))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LocalIp != nil {
		l = m.LocalIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RemoteIp != nil {
		l = m.RemoteIp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *IKEProposal) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IKEProposal{`,
		`EncryptionAlgos:` + fmt.Sprintf("%v", this.EncryptionAlgos) + `,`,
		`AuthenticationAlgos:` + fmt.Sprintf("%v", this.AuthenticationAlgos) + `,`,
		`Prf:` + fmt.Sprintf("%v", this.Prf) + `,`,
		`DhGroups:` + fmt.Sprintf("%v", this.DhGroups) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ESPProposal) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ESPProposal{`,
		`EncryptionAlgos:` + fmt.Sprintf("%v", this.EncryptionAlgos) + `,`,
		`AuthenticationAlgos:` + fmt.Sprintf("%v", this.AuthenticationAlgos) + `,`,
		`DhGroups:` + fmt.Sprintf("%v", this.DhGroups) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpsecTunnelParams) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForIkePhase1Profile := "[]*ObjectRefType{"
	for _, f := range this.IkePhase1Profile {
		repeatedStringForIkePhase1Profile += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForIkePhase1Profile += "}"
	repeatedStringForIkePhase2Profile := "[]*ObjectRefType{"
	for _, f := range this.IkePhase2Profile {
		repeatedStringForIkePhase2Profile += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForIkePhase2Profile += "}"
	s := strings.Join([]string{`&IpsecTunnelParams{`,
		`IpsecPsk:` + strings.Replace(fmt.Sprintf("%v", this.IpsecPsk), "SecretType", "schema.SecretType", 1) + `,`,
		`TunnelInitiator:` + strings.Replace(fmt.Sprintf("%v", this.TunnelInitiator), "Empty", "schema.Empty", 1) + `,`,
		`IkeProposal:` + strings.Replace(this.IkeProposal.String(), "IKEProposal", "IKEProposal", 1) + `,`,
		`EspProposal:` + strings.Replace(this.EspProposal.String(), "ESPProposal", "ESPProposal", 1) + `,`,
		`LocalIkeId:` + fmt.Sprintf("%v", this.LocalIkeId) + `,`,
		`RemoteIkeId:` + fmt.Sprintf("%v", this.RemoteIkeId) + `,`,
		`IkePhase1KeyLifetime:` + fmt.Sprintf("%v", this.IkePhase1KeyLifetime) + `,`,
		`IkeReauthTimeout:` + fmt.Sprintf("%v", this.IkeReauthTimeout) + `,`,
		`IkePhase2KeyLifetime:` + fmt.Sprintf("%v", this.IkePhase2KeyLifetime) + `,`,
		`DpdKeepAliveTimer:` + fmt.Sprintf("%v", this.DpdKeepAliveTimer) + `,`,
		`IkePhase1Profile:` + repeatedStringForIkePhase1Profile + `,`,
		`IkePhase2Profile:` + repeatedStringForIkePhase2Profile + `,`,
		`}`,
	}, "")
	return s
}
func (this *TunnelParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TunnelParams{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TunnelParams_Ipsec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TunnelParams_Ipsec{`,
		`Ipsec:` + strings.Replace(fmt.Sprintf("%v", this.Ipsec), "IpsecTunnelParams", "IpsecTunnelParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLocalIntf := "[]*ObjectRefType{"
	for _, f := range this.LocalIntf {
		repeatedStringForLocalIntf += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForLocalIntf += "}"
	s := strings.Join([]string{`&InterfaceType{`,
		`LocalIntf:` + repeatedStringForLocalIntf + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalIpAddressType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalIpAddressType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`VirtualNetworkType:` + strings.Replace(fmt.Sprintf("%v", this.VirtualNetworkType), "VirtualNetworkSelectorType", "schema.VirtualNetworkSelectorType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalIpAddressType_IpAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalIpAddressType_IpAddress{`,
		`IpAddress:` + strings.Replace(fmt.Sprintf("%v", this.IpAddress), "IpAddressType", "schema.IpAddressType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalIpAddressType_Auto) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalIpAddressType_Auto{`,
		`Auto:` + strings.Replace(fmt.Sprintf("%v", this.Auto), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalIpAddressSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalIpAddressSelector{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalIpAddressSelector_Intf) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalIpAddressSelector_Intf{`,
		`Intf:` + strings.Replace(fmt.Sprintf("%v", this.Intf), "InterfaceType", "InterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalIpAddressSelector_IpAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalIpAddressSelector_IpAddress{`,
		`IpAddress:` + strings.Replace(fmt.Sprintf("%v", this.IpAddress), "LocalIpAddressType", "LocalIpAddressType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalIpAddressSelector_NodeInterface) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LocalIpAddressSelector_NodeInterface{`,
		`NodeInterface:` + strings.Replace(fmt.Sprintf("%v", this.NodeInterface), "NodeInterfaceType", "schema.NodeInterfaceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RemoteNodeAttributes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RemoteNodeAttributes{`,
		`Ip:` + strings.Replace(fmt.Sprintf("%v", this.Ip), "IpAddressType", "schema.IpAddressType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RemoteEndpointType) String() string {
	if this == nil {
		return "nil"
	}
	keysForEndpoints := make([]string, 0, len(this.Endpoints))
	for k, _ := range this.Endpoints {
		keysForEndpoints = append(keysForEndpoints, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEndpoints)
	mapStringForEndpoints := "map[string]*RemoteNodeAttributes{"
	for _, k := range keysForEndpoints {
		mapStringForEndpoints += fmt.Sprintf("%v: %v,", k, this.Endpoints[k])
	}
	mapStringForEndpoints += "}"
	s := strings.Join([]string{`&RemoteEndpointType{`,
		`Endpoints:` + mapStringForEndpoints + `,`,
		`}`,
	}, "")
	return s
}
func (this *RemoteIpAddressSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RemoteIpAddressSelector{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RemoteIpAddressSelector_Ip) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RemoteIpAddressSelector_Ip{`,
		`Ip:` + strings.Replace(fmt.Sprintf("%v", this.Ip), "IpAddressType", "schema.IpAddressType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RemoteIpAddressSelector_Endpoints) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RemoteIpAddressSelector_Endpoints{`,
		`Endpoints:` + strings.Replace(fmt.Sprintf("%v", this.Endpoints), "RemoteEndpointType", "RemoteEndpointType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`TunnelType:` + fmt.Sprintf("%v", this.TunnelType) + `,`,
		`Params:` + strings.Replace(this.Params.String(), "TunnelParams", "TunnelParams", 1) + `,`,
		`LocalIp:` + strings.Replace(this.LocalIp.String(), "LocalIpAddressSelector", "LocalIpAddressSelector", 1) + `,`,
		`RemoteIp:` + strings.Replace(this.RemoteIp.String(), "RemoteIpAddressSelector", "RemoteIpAddressSelector", 1) + `,`,
		`TunnelAttribute:` + fmt.Sprintf("%v", this.TunnelAttribute) + `,`,
		`DeploymentVpnTunnelType:` + fmt.Sprintf("%v", this.DeploymentVpnTunnelType) + `,`,
		`CfgType:` + strings.Replace(this.CfgType.String(), "ConfigureType", "ConfigureType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_DefaultTunnelAttribute) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_DefaultTunnelAttribute{`,
		`DefaultTunnelAttribute:` + strings.Replace(fmt.Sprintf("%v", this.DefaultTunnelAttribute), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_TunnelToAwsTgw) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_TunnelToAwsTgw{`,
		`TunnelToAwsTgw:` + strings.Replace(fmt.Sprintf("%v", this.TunnelToAwsTgw), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConfigureType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConfigureType{`,
		`CfgType:` + fmt.Sprintf("%v", this.CfgType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConfigureType_ExtConnIpsec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConfigureType_ExtConnIpsec{`,
		`ExtConnIpsec:` + strings.Replace(fmt.Sprintf("%v", this.ExtConnIpsec), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConfigureType_ExtConnGre) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConfigureType_ExtConnGre{`,
		`ExtConnGre:` + strings.Replace(fmt.Sprintf("%v", this.ExtConnGre), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`TunnelType:` + fmt.Sprintf("%v", this.TunnelType) + `,`,
		`Params:` + strings.Replace(this.Params.String(), "TunnelParams", "TunnelParams", 1) + `,`,
		`LocalIp:` + strings.Replace(this.LocalIp.String(), "LocalIpAddressSelector", "LocalIpAddressSelector", 1) + `,`,
		`RemoteIp:` + strings.Replace(this.RemoteIp.String(), "RemoteIpAddressSelector", "RemoteIpAddressSelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`TunnelType:` + fmt.Sprintf("%v", this.TunnelType) + `,`,
		`Params:` + strings.Replace(this.Params.String(), "TunnelParams", "TunnelParams", 1) + `,`,
		`LocalIp:` + strings.Replace(this.LocalIp.String(), "LocalIpAddressSelector", "LocalIpAddressSelector", 1) + `,`,
		`RemoteIp:` + strings.Replace(this.RemoteIp.String(), "RemoteIpAddressSelector", "RemoteIpAddressSelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`TunnelType:` + fmt.Sprintf("%v", this.TunnelType) + `,`,
		`Params:` + strings.Replace(this.Params.String(), "TunnelParams", "TunnelParams", 1) + `,`,
		`LocalIp:` + strings.Replace(this.LocalIp.String(), "LocalIpAddressSelector", "LocalIpAddressSelector", 1) + `,`,
		`RemoteIp:` + strings.Replace(this.RemoteIp.String(), "RemoteIpAddressSelector", "RemoteIpAddressSelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *IKEProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IKEProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IKEProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v schema.EncryptionAlgorithm
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= schema.EncryptionAlgorithm(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EncryptionAlgos = append(m.EncryptionAlgos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.EncryptionAlgos) == 0 {
					m.EncryptionAlgos = make([]schema.EncryptionAlgorithm, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v schema.EncryptionAlgorithm
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= schema.EncryptionAlgorithm(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EncryptionAlgos = append(m.EncryptionAlgos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionAlgos", wireType)
			}
		case 2:
			if wireType == 0 {
				var v schema.AuthenticationAlgorithm
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= schema.AuthenticationAlgorithm(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AuthenticationAlgos = append(m.AuthenticationAlgos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.AuthenticationAlgos) == 0 {
					m.AuthenticationAlgos = make([]schema.AuthenticationAlgorithm, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v schema.AuthenticationAlgorithm
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= schema.AuthenticationAlgorithm(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AuthenticationAlgos = append(m.AuthenticationAlgos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationAlgos", wireType)
			}
		case 3:
			if wireType == 0 {
				var v schema.PseudoRandomFunction
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= schema.PseudoRandomFunction(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Prf = append(m.Prf, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Prf) == 0 {
					m.Prf = make([]schema.PseudoRandomFunction, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v schema.PseudoRandomFunction
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= schema.PseudoRandomFunction(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Prf = append(m.Prf, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Prf", wireType)
			}
		case 4:
			if wireType == 0 {
				var v schema.DHGroup
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= schema.DHGroup(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DhGroups = append(m.DhGroups, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.DhGroups) == 0 {
					m.DhGroups = make([]schema.DHGroup, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v schema.DHGroup
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= schema.DHGroup(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DhGroups = append(m.DhGroups, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DhGroups", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ESPProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ESPProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ESPProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v schema.EncryptionAlgorithm
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= schema.EncryptionAlgorithm(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EncryptionAlgos = append(m.EncryptionAlgos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.EncryptionAlgos) == 0 {
					m.EncryptionAlgos = make([]schema.EncryptionAlgorithm, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v schema.EncryptionAlgorithm
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= schema.EncryptionAlgorithm(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EncryptionAlgos = append(m.EncryptionAlgos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionAlgos", wireType)
			}
		case 2:
			if wireType == 0 {
				var v schema.AuthenticationAlgorithm
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= schema.AuthenticationAlgorithm(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AuthenticationAlgos = append(m.AuthenticationAlgos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.AuthenticationAlgos) == 0 {
					m.AuthenticationAlgos = make([]schema.AuthenticationAlgorithm, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v schema.AuthenticationAlgorithm
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= schema.AuthenticationAlgorithm(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AuthenticationAlgos = append(m.AuthenticationAlgos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthenticationAlgos", wireType)
			}
		case 3:
			if wireType == 0 {
				var v schema.DHGroup
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= schema.DHGroup(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DhGroups = append(m.DhGroups, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.DhGroups) == 0 {
					m.DhGroups = make([]schema.DHGroup, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v schema.DHGroup
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= schema.DHGroup(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DhGroups = append(m.DhGroups, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DhGroups", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecTunnelParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecTunnelParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecTunnelParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpsecPsk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpsecPsk == nil {
				m.IpsecPsk = &schema.SecretType{}
			}
			if err := m.IpsecPsk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelInitiator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TunnelInitiator == nil {
				m.TunnelInitiator = &schema.Empty{}
			}
			if err := m.TunnelInitiator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IkeProposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IkeProposal == nil {
				m.IkeProposal = &IKEProposal{}
			}
			if err := m.IkeProposal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EspProposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EspProposal == nil {
				m.EspProposal = &ESPProposal{}
			}
			if err := m.EspProposal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalIkeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalIkeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteIkeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteIkeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IkePhase1KeyLifetime", wireType)
			}
			m.IkePhase1KeyLifetime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IkePhase1KeyLifetime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IkeReauthTimeout", wireType)
			}
			m.IkeReauthTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IkeReauthTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IkePhase2KeyLifetime", wireType)
			}
			m.IkePhase2KeyLifetime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IkePhase2KeyLifetime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DpdKeepAliveTimer", wireType)
			}
			m.DpdKeepAliveTimer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DpdKeepAliveTimer |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IkePhase1Profile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IkePhase1Profile = append(m.IkePhase1Profile, &schema.ObjectRefType{})
			if err := m.IkePhase1Profile[len(m.IkePhase1Profile)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IkePhase2Profile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IkePhase2Profile = append(m.IkePhase2Profile, &schema.ObjectRefType{})
			if err := m.IkePhase2Profile[len(m.IkePhase2Profile)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipsec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IpsecTunnelParams{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &TunnelParams_Ipsec{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalIntf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalIntf = append(m.LocalIntf, &schema.ObjectRefType{})
			if err := m.LocalIntf[len(m.LocalIntf)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalIpAddressType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalIpAddressType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalIpAddressType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.IpAddressType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &LocalIpAddressType_IpAddress{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auto", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &LocalIpAddressType_Auto{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualNetworkType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VirtualNetworkType == nil {
				m.VirtualNetworkType = &schema.VirtualNetworkSelectorType{}
			}
			if err := m.VirtualNetworkType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalIpAddressSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalIpAddressSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalIpAddressSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &LocalIpAddressSelector_Intf{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LocalIpAddressType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &LocalIpAddressSelector_IpAddress{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeInterface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.NodeInterfaceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &LocalIpAddressSelector_NodeInterface{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteNodeAttributes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteNodeAttributes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteNodeAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ip == nil {
				m.Ip = &schema.IpAddressType{}
			}
			if err := m.Ip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteEndpointType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteEndpointType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteEndpointType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endpoints == nil {
				m.Endpoints = make(map[string]*RemoteNodeAttributes)
			}
			var mapkey string
			var mapvalue *RemoteNodeAttributes
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RemoteNodeAttributes{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Endpoints[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteIpAddressSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteIpAddressSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteIpAddressSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.IpAddressType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &RemoteIpAddressSelector_Ip{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RemoteEndpointType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &RemoteIpAddressSelector_Endpoints{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelType", wireType)
			}
			m.TunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelType |= TunnelType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &TunnelParams{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalIp == nil {
				m.LocalIp = &LocalIpAddressSelector{}
			}
			if err := m.LocalIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoteIp == nil {
				m.RemoteIp = &RemoteIpAddressSelector{}
			}
			if err := m.RemoteIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultTunnelAttribute", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TunnelAttribute = &GlobalSpecType_DefaultTunnelAttribute{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelToAwsTgw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TunnelAttribute = &GlobalSpecType_TunnelToAwsTgw{v}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentVpnTunnelType", wireType)
			}
			m.DeploymentVpnTunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeploymentVpnTunnelType |= DeploymentVPNTunnelType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CfgType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CfgType == nil {
				m.CfgType = &ConfigureType{}
			}
			if err := m.CfgType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigureType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigureType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigureType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtConnIpsec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CfgType = &ConfigureType_ExtConnIpsec{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtConnGre", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CfgType = &ConfigureType_ExtConnGre{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelType", wireType)
			}
			m.TunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelType |= TunnelType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &TunnelParams{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalIp == nil {
				m.LocalIp = &LocalIpAddressSelector{}
			}
			if err := m.LocalIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoteIp == nil {
				m.RemoteIp = &RemoteIpAddressSelector{}
			}
			if err := m.RemoteIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelType", wireType)
			}
			m.TunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelType |= TunnelType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &TunnelParams{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalIp == nil {
				m.LocalIp = &LocalIpAddressSelector{}
			}
			if err := m.LocalIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoteIp == nil {
				m.RemoteIp = &RemoteIpAddressSelector{}
			}
			if err := m.RemoteIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelType", wireType)
			}
			m.TunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelType |= TunnelType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &TunnelParams{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalIp == nil {
				m.LocalIp = &LocalIpAddressSelector{}
			}
			if err := m.LocalIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteIp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoteIp == nil {
				m.RemoteIp = &RemoteIpAddressSelector{}
			}
			if err := m.RemoteIp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
