//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//

package waf

import (
	"bytes"
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"

	"github.com/gogo/protobuf/proto"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"google.golang.org/grpc"

	"gopkg.volterra.us/stdlib/client"
	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/errors"
	"gopkg.volterra.us/stdlib/server"
	"gopkg.volterra.us/stdlib/svcfw"
)

var (
	_ = fmt.Sprintf("dummy for fmt import use")
)

// Create WAFMonitoringAPI GRPC Client satisfying server.CustomClient
type WAFMonitoringAPIGrpcClient struct {
	conn       *grpc.ClientConn
	grpcClient WAFMonitoringAPIClient
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error)
}

func (c *WAFMonitoringAPIGrpcClient) doRPCClientRuleHitsMetrics(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &RuleHitsCountRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.waf.RuleHitsCountRequest", yamlReq)
	}
	rsp, err := c.grpcClient.ClientRuleHitsMetrics(ctx, req, opts...)
	return rsp, err
}

func (c *WAFMonitoringAPIGrpcClient) doRPCClientSecurityEventsMetrics(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SecurityEventsCountRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.waf.SecurityEventsCountRequest", yamlReq)
	}
	rsp, err := c.grpcClient.ClientSecurityEventsMetrics(ctx, req, opts...)
	return rsp, err
}

func (c *WAFMonitoringAPIGrpcClient) doRPCServerRuleHitsMetrics(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &RuleHitsCountRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.waf.RuleHitsCountRequest", yamlReq)
	}
	rsp, err := c.grpcClient.ServerRuleHitsMetrics(ctx, req, opts...)
	return rsp, err
}

func (c *WAFMonitoringAPIGrpcClient) doRPCServerSecurityEventsMetrics(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SecurityEventsCountRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.waf.SecurityEventsCountRequest", yamlReq)
	}
	rsp, err := c.grpcClient.ServerSecurityEventsMetrics(ctx, req, opts...)
	return rsp, err
}

func (c *WAFMonitoringAPIGrpcClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	if cco.YAMLReq == "" {
		return nil, fmt.Errorf("Error, empty request body")
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := rpcFn(ctx, cco.YAMLReq, cco.GrpcCallOpts...)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using GRPC")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func NewWAFMonitoringAPIGrpcClient(cc *grpc.ClientConn) server.CustomClient {
	ccl := &WAFMonitoringAPIGrpcClient{
		conn:       cc,
		grpcClient: NewWAFMonitoringAPIClient(cc),
	}
	rpcFns := make(map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error))
	rpcFns["ClientRuleHitsMetrics"] = ccl.doRPCClientRuleHitsMetrics

	rpcFns["ClientSecurityEventsMetrics"] = ccl.doRPCClientSecurityEventsMetrics

	rpcFns["ServerRuleHitsMetrics"] = ccl.doRPCServerRuleHitsMetrics

	rpcFns["ServerSecurityEventsMetrics"] = ccl.doRPCServerSecurityEventsMetrics

	ccl.rpcFns = rpcFns

	return ccl
}

// Create WAFMonitoringAPI REST Client satisfying server.CustomClient
type WAFMonitoringAPIRestClient struct {
	baseURL string
	client  http.Client
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error)
}

func (c *WAFMonitoringAPIRestClient) doRPCClientRuleHitsMetrics(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &RuleHitsCountRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.waf.RuleHitsCountRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		newReq, err := http.NewRequest(http.MethodPost, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP POST request for custom API")
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("group_by", fmt.Sprintf("%v", req.GroupBy))
		q.Add("label_filter", fmt.Sprintf("%v", req.LabelFilter))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("range", fmt.Sprintf("%v", req.Range))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))
		q.Add("step", fmt.Sprintf("%v", req.Step))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &RuleHitsCountResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.waf.RuleHitsCountResponse", body)
	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *WAFMonitoringAPIRestClient) doRPCClientSecurityEventsMetrics(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SecurityEventsCountRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.waf.SecurityEventsCountRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		newReq, err := http.NewRequest(http.MethodPost, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP POST request for custom API")
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("group_by", fmt.Sprintf("%v", req.GroupBy))
		q.Add("label_filter", fmt.Sprintf("%v", req.LabelFilter))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("range", fmt.Sprintf("%v", req.Range))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))
		q.Add("step", fmt.Sprintf("%v", req.Step))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SecurityEventsCountResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.waf.SecurityEventsCountResponse", body)
	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *WAFMonitoringAPIRestClient) doRPCServerRuleHitsMetrics(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &RuleHitsCountRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.waf.RuleHitsCountRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		newReq, err := http.NewRequest(http.MethodPost, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP POST request for custom API")
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("group_by", fmt.Sprintf("%v", req.GroupBy))
		q.Add("label_filter", fmt.Sprintf("%v", req.LabelFilter))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("range", fmt.Sprintf("%v", req.Range))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))
		q.Add("step", fmt.Sprintf("%v", req.Step))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &RuleHitsCountResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.waf.RuleHitsCountResponse", body)
	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *WAFMonitoringAPIRestClient) doRPCServerSecurityEventsMetrics(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SecurityEventsCountRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.waf.SecurityEventsCountRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post":
		jsn, err := req.ToJSON()
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		newReq, err := http.NewRequest(http.MethodPost, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP POST request for custom API")
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("group_by", fmt.Sprintf("%v", req.GroupBy))
		q.Add("label_filter", fmt.Sprintf("%v", req.LabelFilter))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("range", fmt.Sprintf("%v", req.Range))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))
		q.Add("step", fmt.Sprintf("%v", req.Step))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	if rsp.StatusCode != http.StatusOK {
		body, err := ioutil.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := ioutil.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SecurityEventsCountResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, fmt.Errorf("JSON Response %s is not of type *ves.io.schema.waf.SecurityEventsCountResponse", body)
	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *WAFMonitoringAPIRestClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	rsp, err := rpcFn(ctx, cco)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using Rest")
	}
	return rsp, nil
}

func NewWAFMonitoringAPIRestClient(baseURL string, hc http.Client) server.CustomClient {
	ccl := &WAFMonitoringAPIRestClient{
		baseURL: baseURL,
		client:  hc,
	}

	rpcFns := make(map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error))
	rpcFns["ClientRuleHitsMetrics"] = ccl.doRPCClientRuleHitsMetrics

	rpcFns["ClientSecurityEventsMetrics"] = ccl.doRPCClientSecurityEventsMetrics

	rpcFns["ServerRuleHitsMetrics"] = ccl.doRPCServerRuleHitsMetrics

	rpcFns["ServerSecurityEventsMetrics"] = ccl.doRPCServerSecurityEventsMetrics

	ccl.rpcFns = rpcFns

	return ccl
}

// Create WAFMonitoringAPIInprocClient

// INPROC Client (satisfying WAFMonitoringAPIClient interface)
type WAFMonitoringAPIInprocClient struct {
	svc svcfw.Service
}

func (c *WAFMonitoringAPIInprocClient) ClientRuleHitsMetrics(ctx context.Context, in *RuleHitsCountRequest, opts ...grpc.CallOption) (*RuleHitsCountResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.waf.WAFMonitoringAPI")
	cah, ok := ah.(WAFMonitoringAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *WAFMonitoringAPISrv", ah)
	}

	var (
		rsp *RuleHitsCountResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.waf.RuleHitsCountRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'WAFMonitoringAPI.ClientRuleHitsMetrics' operation on 'waf'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.waf.WAFMonitoringAPI.ClientRuleHitsMetrics"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.ClientRuleHitsMetrics(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.waf.RuleHitsCountResponse", rsp)...)

	return rsp, nil
}
func (c *WAFMonitoringAPIInprocClient) ClientSecurityEventsMetrics(ctx context.Context, in *SecurityEventsCountRequest, opts ...grpc.CallOption) (*SecurityEventsCountResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.waf.WAFMonitoringAPI")
	cah, ok := ah.(WAFMonitoringAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *WAFMonitoringAPISrv", ah)
	}

	var (
		rsp *SecurityEventsCountResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.waf.SecurityEventsCountRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'WAFMonitoringAPI.ClientSecurityEventsMetrics' operation on 'waf'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.waf.WAFMonitoringAPI.ClientSecurityEventsMetrics"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.ClientSecurityEventsMetrics(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.waf.SecurityEventsCountResponse", rsp)...)

	return rsp, nil
}
func (c *WAFMonitoringAPIInprocClient) ServerRuleHitsMetrics(ctx context.Context, in *RuleHitsCountRequest, opts ...grpc.CallOption) (*RuleHitsCountResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.waf.WAFMonitoringAPI")
	cah, ok := ah.(WAFMonitoringAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *WAFMonitoringAPISrv", ah)
	}

	var (
		rsp *RuleHitsCountResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.waf.RuleHitsCountRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'WAFMonitoringAPI.ServerRuleHitsMetrics' operation on 'waf'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.waf.WAFMonitoringAPI.ServerRuleHitsMetrics"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.ServerRuleHitsMetrics(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.waf.RuleHitsCountResponse", rsp)...)

	return rsp, nil
}
func (c *WAFMonitoringAPIInprocClient) ServerSecurityEventsMetrics(ctx context.Context, in *SecurityEventsCountRequest, opts ...grpc.CallOption) (*SecurityEventsCountResponse, error) {
	ah := c.svc.GetAPIHandler("ves.io.schema.waf.WAFMonitoringAPI")
	cah, ok := ah.(WAFMonitoringAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *WAFMonitoringAPISrv", ah)
	}

	var (
		rsp *SecurityEventsCountResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, c.svc, "ves.io.schema.waf.SecurityEventsCountRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'WAFMonitoringAPI.ServerSecurityEventsMetrics' operation on 'waf'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if c.svc.Config().EnableAPIValidation {
		if rvFn := c.svc.GetRPCValidator("ves.io.schema.waf.WAFMonitoringAPI.ServerSecurityEventsMetrics"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.ServerSecurityEventsMetrics(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, c.svc, "ves.io.schema.waf.SecurityEventsCountResponse", rsp)...)

	return rsp, nil
}

func NewWAFMonitoringAPIInprocClient(svc svcfw.Service) WAFMonitoringAPIClient {
	return &WAFMonitoringAPIInprocClient{svc: svc}
}

// RegisterGwWAFMonitoringAPIHandler registers with grpc-gw with an inproc-client backing so that
// rest to grpc happens without a grpc.Dial (thus avoiding additional certs for mTLS)
func RegisterGwWAFMonitoringAPIHandler(ctx context.Context, mux *runtime.ServeMux, svc interface{}) error {
	s, ok := svc.(svcfw.Service)
	if !ok {
		return fmt.Errorf("svc is not svcfw.Service")
	}
	return RegisterWAFMonitoringAPIHandlerClient(ctx, mux, NewWAFMonitoringAPIInprocClient(s))
}

var WAFMonitoringAPISwaggerJSON string = `{
    "swagger": "2.0",
    "info": {
        "title": "WAF Monitoring APIs",
        "description": "APIs to get monitoring information about WAF instances on virtual-host basis. \nIt gets data for a given virtual host based on any WAF instance attached to virtual host or route used by virtual host.",
        "version": "version not set"
    },
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "tags": null,
    "paths": {
        "/public/namespaces/{namespace}/wafs/metrics/client/rule_hits": {
            "post": {
                "summary": "ClientRuleHitsMetrics",
                "description": "Get number of rule hits per client for a given namespace.\nThe rule hits counter can be aggregated based on one or more labels listed here.\nNAMESPACE, APP_TYPE, VIRTUAL_HOST, SITE, SERVICE, INSTANCE, WAF_INSTANCE_ID, RULE_ID, RULE_SEVERITY, RULE_TAG.",
                "operationId": "ves.io.schema.waf.WAFMonitoringAPI.ClientRuleHitsMetrics",
                "responses": {
                    "200": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/wafRuleHitsCountResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/wafRuleHitsCountRequest"
                        }
                    }
                ],
                "tags": [
                    "WAFMonitoringAPI"
                ],
                "x-ves-proto-rpc": "ves.io.schema.waf.WAFMonitoringAPI.ClientRuleHitsMetrics"
            },
            "x-displayname": "WAF Monitoring API",
            "x-ves-proto-service": "ves.io.schema.waf.WAFMonitoringAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/wafs/metrics/client/security_events": {
            "post": {
                "summary": "ClientSecurityEventsMetrics",
                "description": "Get number of security events per client for a given namespace.\nThe security events counter can be aggregated based on one or more labels listed here.\nNAMESPACE, APP_TYPE, VIRTUAL_HOST, SITE, SERVICE, INSTANCE, WAF_INSTANCE_ID, WAF_MODE.",
                "operationId": "ves.io.schema.waf.WAFMonitoringAPI.ClientSecurityEventsMetrics",
                "responses": {
                    "200": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/wafSecurityEventsCountResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/wafSecurityEventsCountRequest"
                        }
                    }
                ],
                "tags": [
                    "WAFMonitoringAPI"
                ],
                "x-ves-proto-rpc": "ves.io.schema.waf.WAFMonitoringAPI.ClientSecurityEventsMetrics"
            },
            "x-displayname": "WAF Monitoring API",
            "x-ves-proto-service": "ves.io.schema.waf.WAFMonitoringAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/wafs/metrics/server/rule_hits": {
            "post": {
                "summary": "ServerRuleHitsMetrics",
                "description": "Get number of rule hits per server for a given namespace.\nThe rule hits counter can be aggregated based on one or more labels listed here.\nNAMESPACE, APP_TYPE, VIRTUAL_HOST, SITE, SERVICE, INSTANCE, WAF_INSTANCE_ID, RULE_ID, RULE_SEVERITY, RULE_TAG.",
                "operationId": "ves.io.schema.waf.WAFMonitoringAPI.ServerRuleHitsMetrics",
                "responses": {
                    "200": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/wafRuleHitsCountResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/wafRuleHitsCountRequest"
                        }
                    }
                ],
                "tags": [
                    "WAFMonitoringAPI"
                ],
                "x-ves-proto-rpc": "ves.io.schema.waf.WAFMonitoringAPI.ServerRuleHitsMetrics"
            },
            "x-displayname": "WAF Monitoring API",
            "x-ves-proto-service": "ves.io.schema.waf.WAFMonitoringAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/wafs/metrics/server/security_events": {
            "post": {
                "summary": "ServerSecurityEventsMetrics",
                "description": "Get number of security events per server for a given namespace.\nThe security events counter can be aggregated based on one or more labels listed here.\nNAMESPACE, APP_TYPE, VIRTUAL_HOST, SITE, SERVICE, INSTANCE, WAF_INSTANCE_ID, WAF_MODE.",
                "operationId": "ves.io.schema.waf.WAFMonitoringAPI.ServerSecurityEventsMetrics",
                "responses": {
                    "200": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/wafSecurityEventsCountResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/wafSecurityEventsCountRequest"
                        }
                    }
                ],
                "tags": [
                    "WAFMonitoringAPI"
                ],
                "x-ves-proto-rpc": "ves.io.schema.waf.WAFMonitoringAPI.ServerSecurityEventsMetrics"
            },
            "x-displayname": "WAF Monitoring API",
            "x-ves-proto-service": "ves.io.schema.waf.WAFMonitoringAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        }
    },
    "definitions": {
        "schemawafMetricLabelOp": {
            "type": "string",
            "description": "The operator to use when querying WAF metrics with labels.\nQuery can choose to either select a label if it matches a given value OR\nif it done not match a given value. This is done by choosing the EQ or NEQ operator \nin MetricLabelFilter\n\nEqual to\nNot Equal to",
            "title": "WAF Metric Label Operator",
            "enum": [
                "EQ",
                "NEQ"
            ],
            "default": "EQ",
            "x-displayname": "WAF Metric Label Operator",
            "x-ves-proto-enum": "ves.io.schema.waf.MetricLabelOp"
        },
        "schemawafMetricValue": {
            "type": "object",
            "description": "Value returned for a WAF Metrics query",
            "title": "Metric Value",
            "x-displayname": "Metric Value",
            "x-ves-proto-message": "ves.io.schema.waf.MetricValue",
            "properties": {
                "timestamp": {
                    "type": "number",
                    "description": " timestamp\n\nExample: - \"1570007981\"-",
                    "title": "Timestamp",
                    "format": "double",
                    "x-displayname": "Timestamp",
                    "x-ves-example": "1570007981"
                },
                "value": {
                    "type": "string",
                    "description": " value\n\nExample: - \"15\"-",
                    "title": "Value",
                    "x-displayname": "Value",
                    "x-ves-example": "15"
                }
            }
        },
        "wafMetricLabel": {
            "type": "string",
            "description": "Labels in the WAF metrics.\n\nRule hits counter and the security events counter can be sliced and diced based\non one or more labels listed below.\n\nNamespace in which this WAF instance is running\nAppType configured on the virtual_host under which this WAF instance is running\nVirtual host under which this WAF instance is running\nSite from which this WAF instance is reporting the metrics\nService for which this WAF instance is reporting the metrics\nRegion from which the client's accesses caused WAF metrics to be generated\nWAF instance ID\nRuleID of the rule that was hit to cause this metric to be generated\nRule severity of the rule that was hit to cause this metric to be generated\nRule tag of the rule that was hit to cause this metric to be generated\nBlock or AlertOnly\nType of the Bot (crawler, scanner, script)\nName of the Bot associated with the waf rule",
            "enum": [
                "NAMESPACE",
                "APP_TYPE",
                "VIRTUAL_HOST",
                "SITE",
                "SERVICE",
                "INSTANCE",
                "WAF_INSTANCE_ID",
                "RULE_ID",
                "RULE_SEVERITY",
                "RULE_TAG",
                "WAF_MODE",
                "BOT_TYPE",
                "BOT_NAME"
            ],
            "default": "NAMESPACE",
            "x-displayname": "WAF Metric Label",
            "x-ves-proto-enum": "ves.io.schema.waf.MetricLabel"
        },
        "wafMetricLabelFilter": {
            "type": "object",
            "description": "Label based filtering of WAF metrics.\n\nWAF metrics are tagged with labels mentioned in MetricLabel.\nMetric label filter can be specified to query specific metrics based on label match",
            "x-displayname": "WAF Metric Label Filter",
            "x-ves-proto-message": "ves.io.schema.waf.MetricLabelFilter",
            "properties": {
                "label": {
                    "description": " Label name which is one out of the labels defined in MetricLabel enum.",
                    "title": "Label",
                    "$ref": "#/definitions/wafMetricLabel",
                    "x-displayname": "Label"
                },
                "op": {
                    "description": " Operator to evaluate the label in this filter",
                    "title": "Operator",
                    "$ref": "#/definitions/schemawafMetricLabelOp",
                    "x-displayname": "Operator"
                },
                "value": {
                    "type": "string",
                    "description": " Value to be compared with\n\nExample: - \"blogging-app-namespace-1\"-",
                    "title": "Value",
                    "x-displayname": "Value",
                    "x-ves-example": "blogging-app-namespace-1"
                }
            }
        },
        "wafRuleHitsCountRequest": {
            "type": "object",
            "description": "Request to get number of rule hits per client/server for a given namespace.",
            "title": "RuleHitsCountRequest",
            "x-displayname": "Rule Hits Count Request",
            "x-ves-proto-message": "ves.io.schema.waf.RuleHitsCountRequest",
            "properties": {
                "end_time": {
                    "type": "string",
                    "description": " end time of metric collection from which data will be considered.\n Format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"1570007981\"-",
                    "title": "End time",
                    "x-displayname": "End Time",
                    "x-ves-example": "1570007981"
                },
                "group_by": {
                    "type": "array",
                    "description": " Aggregate data by one of more labels listed here.\n NAMESPACE, APP_TYPE, VIRTUAL_HOST, SITE, SERVICE, INSTANCE, WAF_INSTANCE_ID, RULE_ID, RULE_SEVERITY, RULE_TAG.\n\n Optional: If not specified, then the rule hits are aggregated/grouped by VIRTUAL_HOST.",
                    "title": "Group by",
                    "items": {
                        "$ref": "#/definitions/wafMetricLabel"
                    },
                    "x-displayname": "Group By"
                },
                "label_filter": {
                    "type": "array",
                    "description": " List of label filter expressions of the form \"label\" Op \"value\".\n Response will only contain data that matches all the conditions specified in the label_filter.\n One or more of the following labels can be specified in the label_filter.\n APP_TYPE, VIRTUAL_HOST, SITE, SERVICE, INSTANCE, WAF_INSTANCE_ID, RULE_ID, RULE_SEVERITY, RULE_TAG.\n\n Optional: If not specified, then the metrics will be filtered only based on the namespace in the request.",
                    "title": "Label Filter",
                    "items": {
                        "$ref": "#/definitions/wafMetricLabelFilter"
                    },
                    "x-displayname": "Label Filter"
                },
                "namespace": {
                    "type": "string",
                    "description": " namespace is used to scope the WAF rule hits for the given namespace.\n\nExample: - \"bloggin-app-namespace-1\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "bloggin-app-namespace-1"
                },
                "range": {
                    "type": "string",
                    "description": " range decides how far to go back in time to fetch values for each step.\n For example, if the range is 5m, then for step t1, query will be evaluated for t1-5m and for\n t2, query will be evaluated for t2-5m and so on.\n Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days\n\n Note: For non-timeseries query, i.e., for step=end_time-start_time, range should be set to end_time-start_time\n\n Optional: If not specified, range is set to 5m\n\nExample: - \"50m\"-",
                    "title": "Range",
                    "x-displayname": "Range",
                    "x-ves-example": "50m"
                },
                "start_time": {
                    "type": "string",
                    "description": " start time of metric collection from which data will be considered.\n Format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"1570007981\"-",
                    "title": "Start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "1570007981"
                },
                "step": {
                    "type": "string",
                    "description": " step is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.\n The timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn \u003c= end_time.\n Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days\n\n Optional: If not specified, then step size is evaluated to \u003cend_time - start_time\u003e\n\nExample: - \"5m\"-",
                    "title": "Step",
                    "x-displayname": "Step",
                    "x-ves-example": "5m"
                }
            }
        },
        "wafRuleHitsCountResponse": {
            "type": "object",
            "description": "Number of rule hits for each unique combination of group_by labels in the RuleHitsCountRequest.",
            "title": "RuleHitsCountResponse",
            "x-displayname": "Rule Hits Count Response",
            "x-ves-proto-message": "ves.io.schema.waf.RuleHitsCountResponse",
            "properties": {
                "data": {
                    "type": "array",
                    "description": " List of rule hits counter data",
                    "title": "Rule hits counter",
                    "items": {
                        "$ref": "#/definitions/wafRuleHitsCounter"
                    },
                    "x-displayname": "Rule hits counter"
                }
            }
        },
        "wafRuleHitsCounter": {
            "type": "object",
            "description": "RuleHitsCounter contains the timeseries data of rule hits counter.",
            "title": "Rule Hits Counter",
            "x-displayname": "Rule Hits Counter",
            "x-ves-proto-message": "ves.io.schema.waf.RuleHitsCounter",
            "properties": {
                "id": {
                    "description": " Rule Hits ID is the associated info for rule hits count",
                    "title": "Rule Hits ID",
                    "$ref": "#/definitions/wafRuleHitsId",
                    "x-displayname": "Rule Hits ID"
                },
                "metric": {
                    "type": "array",
                    "description": " List of metric values",
                    "title": "Metric Values",
                    "items": {
                        "$ref": "#/definitions/schemawafMetricValue"
                    },
                    "x-displayname": "Metric Values"
                }
            }
        },
        "wafRuleHitsId": {
            "type": "object",
            "description": "RuleHitsId uniquely identifies an entry in the response for rule_hits metrics query.\nRule hits counter is aggregated based on the MetricLabel specified in the group_by field in the request.\nTherefore, only the fields that corresponds to the MetricLabel in the group_by will have non-empty\nvalue in the response.",
            "title": "RuleHitsId",
            "x-displayname": "Rule Hits ID",
            "x-ves-proto-message": "ves.io.schema.waf.RuleHitsId",
            "properties": {
                "app_type": {
                    "type": "string",
                    "description": " AppType configured on the virtual_host under which this WAF instance is running\n\nExample: - \"blogging-app\"-",
                    "title": "AppType",
                    "x-displayname": "AppType",
                    "x-ves-example": "blogging-app"
                },
                "bot_name": {
                    "type": "string",
                    "description": " Name of the Bot associated with the waf rule\n\nExample: - \"whatweb\"-",
                    "title": "Bot Name",
                    "x-displayname": "Bot Name",
                    "x-ves-example": "whatweb"
                },
                "bot_type": {
                    "type": "string",
                    "description": " Type of Bot (crawler, scanner, script)\n\nExample: - \"scanner\"-",
                    "title": "Bot Type",
                    "x-displayname": "Bot Type",
                    "x-ves-example": "scanner"
                },
                "instance": {
                    "type": "string",
                    "description": " Region from which the client's accesses caused WAF metrics to be generated\n\nExample: - \"India\"-",
                    "title": "Instance",
                    "x-displayname": "Instance",
                    "x-ves-example": "India"
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace in which this WAF instance is running\n\nExample: - \"blogging-app-namespace-1\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "blogging-app-namespace-1"
                },
                "rule_id": {
                    "type": "string",
                    "description": " RuleID of the rule that was hit to cause this metric to be generated\n\nExample: - \"941210\"-",
                    "title": "Rule ID",
                    "x-displayname": "Rule ID",
                    "x-ves-example": "941210"
                },
                "rule_severity": {
                    "type": "string",
                    "description": " Rule severity of the rule that was hit to cause this metric to be generated\n\nExample: - \"CRITICAL\"-",
                    "title": "Rule Severity",
                    "x-displayname": "Rule Severity",
                    "x-ves-example": "CRITICAL"
                },
                "rule_tag": {
                    "type": "string",
                    "description": " Rule tag of the rule that was hit to cause this metric to be generated\n\nExample: - \"CAPEC-272\"-",
                    "title": "Rule Tag",
                    "x-displayname": "Rule Tag",
                    "x-ves-example": "CAPEC-272"
                },
                "service": {
                    "type": "string",
                    "description": " Service for which this WAF instance is reporting the metrics\n\nExample: - \"N:greatblogs-ce\"-",
                    "title": "Service",
                    "x-displayname": "Service",
                    "x-ves-example": "N:greatblogs-ce"
                },
                "site": {
                    "type": "string",
                    "description": " Site from which this WAF instance is reporting the metrics\n\nExample: - \"greatblogs-ce\"-",
                    "title": "Site",
                    "x-displayname": "Site",
                    "x-ves-example": "greatblogs-ce"
                },
                "virtual_host": {
                    "type": "string",
                    "description": " Virtual host under which this WAF instance is running\n\nExample: - \"VS:greatblogs-vhost\"-",
                    "title": "Virtual Host",
                    "x-displayname": "Virtual Host",
                    "x-ves-example": "VS:greatblogs-vhost"
                },
                "waf_instance_id": {
                    "type": "string",
                    "description": " WAF instance ID\n\nExample: - \"blogging-app-namespace-1:generated-waf-rules-greatblogs-waf\"-",
                    "title": "WAF Instance ID",
                    "x-displayname": "WAF Instance ID",
                    "x-ves-example": "blogging-app-namespace-1:generated-waf-rules-greatblogs-waf"
                }
            }
        },
        "wafSecurityEventsCountRequest": {
            "type": "object",
            "description": "Request to get number of security events per client/server for a given namespace.",
            "title": "SecurityEventsCountRequest",
            "x-displayname": "Security Events Count Request",
            "x-ves-proto-message": "ves.io.schema.waf.SecurityEventsCountRequest",
            "properties": {
                "end_time": {
                    "type": "string",
                    "description": " end time of metric collection from which data will be considered.\n Format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"1570007981\"-",
                    "title": "End time",
                    "x-displayname": "End Time",
                    "x-ves-example": "1570007981"
                },
                "group_by": {
                    "type": "array",
                    "description": " Aggregate data by one or more labels listed here.\n NAMESPACE, APP_TYPE, VIRTUAL_HOST, SITE, SERVICE, INSTANCE, WAF_INSTANCE_ID, WAF_MODE.\n\n Optional: If not specified, then the rule hits are aggregated/grouped by VIRTUAL_HOST.",
                    "title": "Group by",
                    "items": {
                        "$ref": "#/definitions/wafMetricLabel"
                    },
                    "x-displayname": "Group By"
                },
                "label_filter": {
                    "type": "array",
                    "description": " List of label filter expressions of the form \"label\" Op \"value\".\n Response will only contain data that matches all the conditions specified in the label_filter.\n One or more of the following labels can be specified in the label_filter.\n APP_TYPE, VIRTUAL_HOST, SITE, SERVICE, INSTANCE, WAF_INSTANCE_ID, WAF_MODE.\n\n Optional: If not specified, then the metrics will be filtered only based on the namespace in the request.",
                    "title": "Label Filter",
                    "items": {
                        "$ref": "#/definitions/wafMetricLabelFilter"
                    },
                    "x-displayname": "Label Filter"
                },
                "namespace": {
                    "type": "string",
                    "description": " namespace is used to scope the WAF security events for the given namespace.\n\nExample: - \"bloggin-app-namespace-1\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "bloggin-app-namespace-1"
                },
                "range": {
                    "type": "string",
                    "description": " range decides how far to go back in time to fetch values for each step.\n For example, if the range is 5m, then for step t1, query will be evaluated for t1-5m and for\n t2, query will be evaluated for t2-5m and so on.\n Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days\n\n Note: For non-timeseries query, i.e., for step=end_time-start_time, range should be set to end_time-start_time\n\n Optional: If not specified, range is set to 5m\n\nExample: - \"45m\"-",
                    "title": "Range",
                    "x-displayname": "Range",
                    "x-ves-example": "45m"
                },
                "start_time": {
                    "type": "string",
                    "description": " start time of metric collection from which data will be considered.\n Format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"1570007981\"-",
                    "title": "Start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "1570007981"
                },
                "step": {
                    "type": "string",
                    "description": " step is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.\n The timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn \u003c= end_time.\n Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days\n\n Optional: If not specified, then step size is evaluated to \u003cend_time - start_time\u003e\n\nExample: - \"15m\"-",
                    "title": "Step",
                    "x-displayname": "Step",
                    "x-ves-example": "15m"
                }
            }
        },
        "wafSecurityEventsCountResponse": {
            "type": "object",
            "description": "Number of security events for each unique combination of group_by labels in the SecurityEventsCountRequest.",
            "title": "SecurityEventsCountResponse",
            "x-displayname": "Security Events Count Response",
            "x-ves-proto-message": "ves.io.schema.waf.SecurityEventsCountResponse",
            "properties": {
                "data": {
                    "type": "array",
                    "description": " List of security events counter data",
                    "title": "Security events counter data",
                    "items": {
                        "$ref": "#/definitions/wafSecurityEventsCounter"
                    },
                    "x-displayname": "Security events counter data"
                }
            }
        },
        "wafSecurityEventsCounter": {
            "type": "object",
            "description": "SecurityEventsCounter contains the timeseries data of security events counter.",
            "title": "Security Events Counter",
            "x-displayname": "Security Events Counter",
            "x-ves-proto-message": "ves.io.schema.waf.SecurityEventsCounter",
            "properties": {
                "id": {
                    "description": " Security Event ID is the associated info for security events count",
                    "title": "Security Events ID",
                    "$ref": "#/definitions/wafSecurityEventsId",
                    "x-displayname": "Security Events ID"
                },
                "metric": {
                    "type": "array",
                    "description": " List of metric values",
                    "title": "Metric Values",
                    "items": {
                        "$ref": "#/definitions/schemawafMetricValue"
                    },
                    "x-displayname": "Metric Values"
                }
            }
        },
        "wafSecurityEventsId": {
            "type": "object",
            "description": "SecurityEventsId uniquely identifies an entry in the response for rule_hits metrics query.\nsecurity events counter is aggregated based on the MetricLabel specified in the group_by field in the request.\nTherefore, only the fields that corresponds to the MetricLabel in the group_by will have non-empty\nvalue in the response.",
            "title": "SecurityEventsId",
            "x-displayname": "Security Events ID",
            "x-ves-proto-message": "ves.io.schema.waf.SecurityEventsId",
            "properties": {
                "app_type": {
                    "type": "string",
                    "description": " AppType configured on the vhost under which this WAF instance is running\n\nExample: - \"blogging-app\"-",
                    "title": "AppType",
                    "x-displayname": "AppType",
                    "x-ves-example": "blogging-app"
                },
                "bot_name": {
                    "type": "string",
                    "description": " Name of the Bot associated with the waf rule\n\nExample: - \"whatweb\"-",
                    "title": "Bot Name",
                    "x-displayname": "Bot Name",
                    "x-ves-example": "whatweb"
                },
                "bot_type": {
                    "type": "string",
                    "description": " Type of Bot (crawler, scanner, script)\n\nExample: - \"scanner\"-",
                    "title": "Bot Type",
                    "x-displayname": "Bot Type",
                    "x-ves-example": "scanner"
                },
                "instance": {
                    "type": "string",
                    "description": " Region from which the client's accesses caused WAF metrics to be generated\n\nExample: - \"India\"-",
                    "title": "Instance",
                    "x-displayname": "Instance",
                    "x-ves-example": "India"
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace in which this WAF instance is running\n\nExample: - \"blogging-app-namespace-1\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "blogging-app-namespace-1"
                },
                "service": {
                    "type": "string",
                    "description": " Service for which this WAF instance is reporting the metrics\n\nExample: - \"N:greatblogs-ce\"-",
                    "title": "Service",
                    "x-displayname": "Service",
                    "x-ves-example": "N:greatblogs-ce"
                },
                "site": {
                    "type": "string",
                    "description": " Site from which this WAF instance is reporting the metrics\n\nExample: - \"greatblogs-ce\"-",
                    "title": "Site",
                    "x-displayname": "Site",
                    "x-ves-example": "greatblogs-ce"
                },
                "virtual_host": {
                    "type": "string",
                    "description": " Virtual host under which this WAF instance is running\n\nExample: - \"VS:greatblogs-vhost\"-",
                    "title": "Virtual Host",
                    "x-displayname": "Virtual Host",
                    "x-ves-example": "VS:greatblogs-vhost"
                },
                "waf_instance_id": {
                    "type": "string",
                    "description": " WAF instance ID\n\nExample: - \"blogging-app-namespace-1:generated-waf-rules-greatblogs-waf\"-",
                    "title": "WAF Instance ID",
                    "x-displayname": "WAF Instance ID",
                    "x-ves-example": "blogging-app-namespace-1:generated-waf-rules-greatblogs-waf"
                },
                "waf_mode": {
                    "type": "string",
                    "description": " Block or AlertOnly\n\nExample: - \"Block\"-",
                    "title": "WAF Mode",
                    "x-displayname": "WAF Mode",
                    "x-ves-example": "Block"
                }
            }
        }
    },
    "x-displayname": "WAF",
    "x-ves-proto-file": "ves.io/schema/waf/public_waf_monitoring.proto"
}`
