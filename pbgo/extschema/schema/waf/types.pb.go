// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/waf/types.proto

package waf

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// CMS Type
//
// x-displayName: "Content Management System Type"
// The content management system used to build the target application.
type ContentManagementSystemType int32

const (
	// x-displayName: "Drupal"
	// Drupal CMS
	DRUPAL ContentManagementSystemType = 0
	// x-displayName: "Wordpress"
	// Wordpress CMS
	WORDPRESS ContentManagementSystemType = 1
	// x-displayName: "Nextcloud"
	// Nextcloud CMS
	NEXTCLOUD ContentManagementSystemType = 2
	// x-displayName: "Dokuwiki"
	// Dokuwiki CMS
	DOKUWIKI ContentManagementSystemType = 3
	// x-displayName: "CPanel"
	// CPanel CMS
	CPANEL ContentManagementSystemType = 4
)

var ContentManagementSystemType_name = map[int32]string{
	0: "DRUPAL",
	1: "WORDPRESS",
	2: "NEXTCLOUD",
	3: "DOKUWIKI",
	4: "CPANEL",
}

var ContentManagementSystemType_value = map[string]int32{
	"DRUPAL":    0,
	"WORDPRESS": 1,
	"NEXTCLOUD": 2,
	"DOKUWIKI":  3,
	"CPANEL":    4,
}

func (ContentManagementSystemType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9b9450f480a697d8, []int{0}
}

// Languages Type
//
// x-displayName: "Languages Type"
// languages used to build the target application.
type LanguageType int32

const (
	// x-displayName: "PHP"
	// PHP language
	PHP LanguageType = 0
	// x-displayName: "Java"
	// Java language
	JAVA LanguageType = 1
)

var LanguageType_name = map[int32]string{
	0: "PHP",
	1: "JAVA",
}

var LanguageType_value = map[string]int32{
	"PHP":  0,
	"JAVA": 1,
}

func (LanguageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9b9450f480a697d8, []int{1}
}

// Web Server Type
//
// x-displayName: "Web Server Type"
// The Web Server used to build the target application.
type WebServerType int32

const (
	// x-displayName: "IIS"
	// IIS Webserver
	IIS WebServerType = 0
)

var WebServerType_name = map[int32]string{
	0: "IIS",
}

var WebServerType_value = map[string]int32{
	"IIS": 0,
}

func (WebServerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9b9450f480a697d8, []int{2}
}

// Detection Tags
//
// x-displayName: "Disabled Detection Tags"
// To optimize by having only relevant rules configured for a WAF instance, WAF can be configured to explicitly disable certain types of attacks.
// The different attack types for which WAF instance can be configured to not include rules.
type DetectionTagType int32

const (
	// x-displayName: "Data Leakage"
	// Responses from the server will be analyzed to check whether any sensitive data is leaked.
	DATA_LEAKAGE DetectionTagType = 0
	// x-displayName: "SQL Injection"
	// SQL Injection attack
	SQLI_ATTACK DetectionTagType = 1
	// x-displayName: "Cross Site Scripting"
	// Cross Site Scripting attack
	XSS_ATTACK DetectionTagType = 2
	// x-displayName: "HTTP Protocol Header Attack"
	// Generic HTTP protocol header attacks
	PROTOCOL_ATTACK DetectionTagType = 3
	// x-displayName: "RCE Attack"
	// Remote Code Execution attack
	RCE_ATTACK DetectionTagType = 4
	// x-displayName: "PHP Attack"
	// Attacks associated with PHP
	PHP_ATTACK DetectionTagType = 5
	// x-displayName: "DOS Attack"
	// Denial of Service
	DOS_ATTACK DetectionTagType = 6
	// x-displayName: "RFI Attack"
	// Remote File Inclusion
	RFI_ATTACK DetectionTagType = 7
	// x-displayName: "LFI Attack"
	// Local File Inclusion
	LFI_ATTACK DetectionTagType = 8
	// x-displayName: "Scanners"
	// Known Scanners
	SCANNER DetectionTagType = 9
	// x-displayName: "Session Fixation"
	// HTTP Session Fixation
	SESSION_FIXATION DetectionTagType = 10
	// x-displayName: "Known Scripts"
	// Known scripts access by automated tool
	KNOWN_SCRIPTS DetectionTagType = 11
	// x-displayName: "Crawlers"
	// Crawlers accessing the server
	CRAWLERS DetectionTagType = 12
)

var DetectionTagType_name = map[int32]string{
	0:  "DATA_LEAKAGE",
	1:  "SQLI_ATTACK",
	2:  "XSS_ATTACK",
	3:  "PROTOCOL_ATTACK",
	4:  "RCE_ATTACK",
	5:  "PHP_ATTACK",
	6:  "DOS_ATTACK",
	7:  "RFI_ATTACK",
	8:  "LFI_ATTACK",
	9:  "SCANNER",
	10: "SESSION_FIXATION",
	11: "KNOWN_SCRIPTS",
	12: "CRAWLERS",
}

var DetectionTagType_value = map[string]int32{
	"DATA_LEAKAGE":     0,
	"SQLI_ATTACK":      1,
	"XSS_ATTACK":       2,
	"PROTOCOL_ATTACK":  3,
	"RCE_ATTACK":       4,
	"PHP_ATTACK":       5,
	"DOS_ATTACK":       6,
	"RFI_ATTACK":       7,
	"LFI_ATTACK":       8,
	"SCANNER":          9,
	"SESSION_FIXATION": 10,
	"KNOWN_SCRIPTS":    11,
	"CRAWLERS":         12,
}

func (DetectionTagType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9b9450f480a697d8, []int{3}
}

// Labels in the WAF metrics.
//
// x-displayName: "WAF Metric Label"
// Rule hits counter and the security events counter can be sliced and diced based
// on one or more labels listed below.
type MetricLabel int32

const (
	// x-displayName: "Namespace"
	// Namespace in which this WAF instance is running
	NAMESPACE MetricLabel = 0
	// x-displayName: "AppType"
	// AppType configured on the virtual_host under which this WAF instance is running
	APP_TYPE MetricLabel = 1
	// x-displayName: "Virtual Host"
	// Virtual host under which this WAF instance is running
	VIRTUAL_HOST MetricLabel = 2
	// x-displayName: "Site"
	// Site from which this WAF instance is reporting the metrics
	SITE MetricLabel = 3
	// x-displayName: "Service"
	// Service for which this WAF instance is reporting the metrics
	SERVICE MetricLabel = 4
	// x-displayName: "Instance"
	// Region from which the client's accesses caused WAF metrics to be generated
	INSTANCE MetricLabel = 5
	// x-displayName: "WAF Instance ID"
	// WAF instance ID
	WAF_INSTANCE_ID MetricLabel = 6
	// x-displayName: "Rule ID"
	// RuleID of the rule that was hit to cause this metric to be generated
	RULE_ID MetricLabel = 7
	// x-displayName: "Rule Severity"
	// Rule severity of the rule that was hit to cause this metric to be generated
	RULE_SEVERITY MetricLabel = 8
	// x-displayName: "Rule Tag"
	// Rule tag of the rule that was hit to cause this metric to be generated
	RULE_TAG MetricLabel = 9
	// x-displayName: "WAF Mode"
	// Block or AlertOnly
	WAF_MODE MetricLabel = 10
	// x-displayName: "Bot Type"
	// Type of the Bot (crawler, scanner, script)
	BOT_TYPE MetricLabel = 11
	// x-displayName: "Bot Name"
	// Name of the Bot associated with the waf rule
	BOT_NAME MetricLabel = 12
)

var MetricLabel_name = map[int32]string{
	0:  "NAMESPACE",
	1:  "APP_TYPE",
	2:  "VIRTUAL_HOST",
	3:  "SITE",
	4:  "SERVICE",
	5:  "INSTANCE",
	6:  "WAF_INSTANCE_ID",
	7:  "RULE_ID",
	8:  "RULE_SEVERITY",
	9:  "RULE_TAG",
	10: "WAF_MODE",
	11: "BOT_TYPE",
	12: "BOT_NAME",
}

var MetricLabel_value = map[string]int32{
	"NAMESPACE":       0,
	"APP_TYPE":        1,
	"VIRTUAL_HOST":    2,
	"SITE":            3,
	"SERVICE":         4,
	"INSTANCE":        5,
	"WAF_INSTANCE_ID": 6,
	"RULE_ID":         7,
	"RULE_SEVERITY":   8,
	"RULE_TAG":        9,
	"WAF_MODE":        10,
	"BOT_TYPE":        11,
	"BOT_NAME":        12,
}

func (MetricLabel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9b9450f480a697d8, []int{4}
}

// WAF Metric Label Operator
//
// x-displayName: "WAF Metric Label Operator"
// The operator to use when querying WAF metrics with labels.
// Query can choose to either select a label if it matches a given value OR
// if it done not match a given value. This is done by choosing the EQ or NEQ operator
// in MetricLabelFilter
type MetricLabelOp int32

const (
	// x-displayName: "Equal To"
	// Equal to
	EQ MetricLabelOp = 0
	// x-displayName: "Not Equal To"
	// Not Equal to
	NEQ MetricLabelOp = 1
)

var MetricLabelOp_name = map[int32]string{
	0: "EQ",
	1: "NEQ",
}

var MetricLabelOp_value = map[string]int32{
	"EQ":  0,
	"NEQ": 1,
}

func (MetricLabelOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9b9450f480a697d8, []int{5}
}

// AppProfile
//
// x-displayName: "App Profile"
// AppProfile contains different properties of the target App being protected by this WAF instance. For eg
// there can be multiple CMS type supported by this WAF instance and if enabled , rules for
// those CMS type will be enabled . Volterra WAF Rules Processor uses this information to include/exclude WAF
// security rules which are relevant for this App Profile.
type AppProfile struct {
	// Languages
	//
	// x-displayName: "Languages"
	// The languages used to build the target application.
	Language []LanguageType `protobuf:"varint,2,rep,packed,name=language,proto3,enum=ves.io.schema.waf.LanguageType" json:"language,omitempty"`
	// Content Management System Type
	//
	// x-displayName: "Content Management System Type"
	// The content management system used to build the target application.
	Cms []ContentManagementSystemType `protobuf:"varint,3,rep,packed,name=cms,proto3,enum=ves.io.schema.waf.ContentManagementSystemType" json:"cms,omitempty"`
	// Web Server Type
	//
	// x-displayName: "Web Server Type"
	// The Web Server used to build the target application.
	Webserver []WebServerType `protobuf:"varint,4,rep,packed,name=webserver,proto3,enum=ves.io.schema.waf.WebServerType" json:"webserver,omitempty"`
}

func (m *AppProfile) Reset()      { *m = AppProfile{} }
func (*AppProfile) ProtoMessage() {}
func (*AppProfile) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b9450f480a697d8, []int{0}
}
func (m *AppProfile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppProfile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AppProfile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppProfile.Merge(m, src)
}
func (m *AppProfile) XXX_Size() int {
	return m.Size()
}
func (m *AppProfile) XXX_DiscardUnknown() {
	xxx_messageInfo_AppProfile.DiscardUnknown(m)
}

var xxx_messageInfo_AppProfile proto.InternalMessageInfo

func (m *AppProfile) GetLanguage() []LanguageType {
	if m != nil {
		return m.Language
	}
	return nil
}

func (m *AppProfile) GetCms() []ContentManagementSystemType {
	if m != nil {
		return m.Cms
	}
	return nil
}

func (m *AppProfile) GetWebserver() []WebServerType {
	if m != nil {
		return m.Webserver
	}
	return nil
}

// Disabled Detection Tags
//
// x-displayName: "Disabled Detection Tags"
// To optimize WAF performance by having only relevant rules configured for a WAF instance, WAF can be configured to explicitly disable certain types of attacks.
// This can be done by configuring this list of attacks types for which the user wants to disable detection.
type DisabledDetectionTags struct {
	// detection_tag_type
	//
	// x-displayName: "Detection Tag"
	// List of detection tags to be disabled
	DetectionTagType []DetectionTagType `protobuf:"varint,1,rep,packed,name=detection_tag_type,json=detectionTagType,proto3,enum=ves.io.schema.waf.DetectionTagType" json:"detection_tag_type,omitempty"`
}

func (m *DisabledDetectionTags) Reset()      { *m = DisabledDetectionTags{} }
func (*DisabledDetectionTags) ProtoMessage() {}
func (*DisabledDetectionTags) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b9450f480a697d8, []int{1}
}
func (m *DisabledDetectionTags) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DisabledDetectionTags) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DisabledDetectionTags) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DisabledDetectionTags.Merge(m, src)
}
func (m *DisabledDetectionTags) XXX_Size() int {
	return m.Size()
}
func (m *DisabledDetectionTags) XXX_DiscardUnknown() {
	xxx_messageInfo_DisabledDetectionTags.DiscardUnknown(m)
}

var xxx_messageInfo_DisabledDetectionTags proto.InternalMessageInfo

func (m *DisabledDetectionTags) GetDetectionTagType() []DetectionTagType {
	if m != nil {
		return m.DetectionTagType
	}
	return nil
}

// GlobalSpecType
//
// x-displayName: "WAF Specification"
type GlobalSpecType struct {
	// app_profile
	//
	// x-displayName: "App Profile"
	// Details of the apps which are going through this WAF instance.
	AppProfile *AppProfile `protobuf:"bytes,1,opt,name=app_profile,json=appProfile,proto3" json:"app_profile,omitempty"`
	// mode
	//
	// x-displayName: "Mode"
	// Mode of this WAF instance , will be either in blocked or alert mode.
	Mode schema.WafModeType `protobuf:"varint,4,opt,name=mode,proto3,enum=ves.io.schema.WafModeType" json:"mode,omitempty"`
	// disabled_detection_tags
	//
	// x-displayName: "Disabled Detections"
	// DisabledDetectionTags will allow user to selectively disable the Security Rules associated with Tags
	DisabledDetectionTags *DisabledDetectionTags `protobuf:"bytes,5,opt,name=disabled_detection_tags,json=disabledDetectionTags,proto3" json:"disabled_detection_tags,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b9450f480a697d8, []int{2}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetAppProfile() *AppProfile {
	if m != nil {
		return m.AppProfile
	}
	return nil
}

func (m *GlobalSpecType) GetMode() schema.WafModeType {
	if m != nil {
		return m.Mode
	}
	return schema.BLOCK
}

func (m *GlobalSpecType) GetDisabledDetectionTags() *DisabledDetectionTags {
	if m != nil {
		return m.DisabledDetectionTags
	}
	return nil
}

// Create WAF
//
// x-displayName: "Create WAF"
// WAF object is used to create a WAF instance associated with a VHOST or ROUTE
// A WAF instance can be shared by multiple "virtual_host" or "route"
// A "virtual_host" or "route" shall refer to one WAF instance
type CreateSpecType struct {
	AppProfile            *AppProfile            `protobuf:"bytes,1,opt,name=app_profile,json=appProfile,proto3" json:"app_profile,omitempty"`
	Mode                  schema.WafModeType     `protobuf:"varint,4,opt,name=mode,proto3,enum=ves.io.schema.WafModeType" json:"mode,omitempty"`
	DisabledDetectionTags *DisabledDetectionTags `protobuf:"bytes,5,opt,name=disabled_detection_tags,json=disabledDetectionTags,proto3" json:"disabled_detection_tags,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b9450f480a697d8, []int{3}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

func (m *CreateSpecType) GetAppProfile() *AppProfile {
	if m != nil {
		return m.AppProfile
	}
	return nil
}

func (m *CreateSpecType) GetMode() schema.WafModeType {
	if m != nil {
		return m.Mode
	}
	return schema.BLOCK
}

func (m *CreateSpecType) GetDisabledDetectionTags() *DisabledDetectionTags {
	if m != nil {
		return m.DisabledDetectionTags
	}
	return nil
}

// Replace WAF
//
// x-displayName: "Replace WAF"
// Update the configuration by replacing the existing spec with the provided one.
// For read-then-write operations a resourceVersion mismatch will occur if the object was modified between the read and write.
type ReplaceSpecType struct {
	AppProfile            *AppProfile            `protobuf:"bytes,1,opt,name=app_profile,json=appProfile,proto3" json:"app_profile,omitempty"`
	Mode                  schema.WafModeType     `protobuf:"varint,4,opt,name=mode,proto3,enum=ves.io.schema.WafModeType" json:"mode,omitempty"`
	DisabledDetectionTags *DisabledDetectionTags `protobuf:"bytes,5,opt,name=disabled_detection_tags,json=disabledDetectionTags,proto3" json:"disabled_detection_tags,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b9450f480a697d8, []int{4}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

func (m *ReplaceSpecType) GetAppProfile() *AppProfile {
	if m != nil {
		return m.AppProfile
	}
	return nil
}

func (m *ReplaceSpecType) GetMode() schema.WafModeType {
	if m != nil {
		return m.Mode
	}
	return schema.BLOCK
}

func (m *ReplaceSpecType) GetDisabledDetectionTags() *DisabledDetectionTags {
	if m != nil {
		return m.DisabledDetectionTags
	}
	return nil
}

// Get WAF
//
// x-displayName: "Get WAF"
// Get WAF will read the configuration from namespace metadata.namespace
type GetSpecType struct {
	AppProfile            *AppProfile            `protobuf:"bytes,1,opt,name=app_profile,json=appProfile,proto3" json:"app_profile,omitempty"`
	Mode                  schema.WafModeType     `protobuf:"varint,4,opt,name=mode,proto3,enum=ves.io.schema.WafModeType" json:"mode,omitempty"`
	DisabledDetectionTags *DisabledDetectionTags `protobuf:"bytes,5,opt,name=disabled_detection_tags,json=disabledDetectionTags,proto3" json:"disabled_detection_tags,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b9450f480a697d8, []int{5}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

func (m *GetSpecType) GetAppProfile() *AppProfile {
	if m != nil {
		return m.AppProfile
	}
	return nil
}

func (m *GetSpecType) GetMode() schema.WafModeType {
	if m != nil {
		return m.Mode
	}
	return schema.BLOCK
}

func (m *GetSpecType) GetDisabledDetectionTags() *DisabledDetectionTags {
	if m != nil {
		return m.DisabledDetectionTags
	}
	return nil
}

// Label based filtering of WAF metrics.
//
// x-displayName: "WAF Metric Label Filter"
// WAF metrics are tagged with labels mentioned in MetricLabel.
// Metric label filter can be specified to query specific metrics based on label match
type MetricLabelFilter struct {
	// Label
	//
	// x-displayName: "Label"
	// Label name which is one out of the labels defined in MetricLabel enum.
	Label MetricLabel `protobuf:"varint,1,opt,name=label,proto3,enum=ves.io.schema.waf.MetricLabel" json:"label,omitempty"`
	// Operator
	//
	// x-displayName: "Operator"
	// Operator to evaluate the label in this filter
	Op MetricLabelOp `protobuf:"varint,2,opt,name=op,proto3,enum=ves.io.schema.waf.MetricLabelOp" json:"op,omitempty"`
	// Value
	//
	// x-displayName: "Value"
	// x-example: "blogging-app-namespace-1"
	// Value to be compared with
	Value string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *MetricLabelFilter) Reset()      { *m = MetricLabelFilter{} }
func (*MetricLabelFilter) ProtoMessage() {}
func (*MetricLabelFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b9450f480a697d8, []int{6}
}
func (m *MetricLabelFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricLabelFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MetricLabelFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricLabelFilter.Merge(m, src)
}
func (m *MetricLabelFilter) XXX_Size() int {
	return m.Size()
}
func (m *MetricLabelFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricLabelFilter.DiscardUnknown(m)
}

var xxx_messageInfo_MetricLabelFilter proto.InternalMessageInfo

func (m *MetricLabelFilter) GetLabel() MetricLabel {
	if m != nil {
		return m.Label
	}
	return NAMESPACE
}

func (m *MetricLabelFilter) GetOp() MetricLabelOp {
	if m != nil {
		return m.Op
	}
	return EQ
}

func (m *MetricLabelFilter) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Metric Value
//
// x-displayName: "Metric Value"
// Value returned for a WAF Metrics query
type MetricValue struct {
	// Timestamp
	//
	// x-displayName: "Timestamp"
	// x-example: "1570007981"
	// timestamp
	Timestamp float64 `protobuf:"fixed64,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Value
	//
	// x-displayName: "Value"
	// x-example: "15"
	// value
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *MetricValue) Reset()      { *m = MetricValue{} }
func (*MetricValue) ProtoMessage() {}
func (*MetricValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b9450f480a697d8, []int{7}
}
func (m *MetricValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MetricValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricValue.Merge(m, src)
}
func (m *MetricValue) XXX_Size() int {
	return m.Size()
}
func (m *MetricValue) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricValue.DiscardUnknown(m)
}

var xxx_messageInfo_MetricValue proto.InternalMessageInfo

func (m *MetricValue) GetTimestamp() float64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *MetricValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// RuleHitsId
//
// x-displayName: "Rule Hits ID"
// RuleHitsId uniquely identifies an entry in the response for rule_hits metrics query.
// Rule hits counter is aggregated based on the MetricLabel specified in the group_by field in the request.
// Therefore, only the fields that corresponds to the MetricLabel in the group_by will have non-empty
// value in the response.
type RuleHitsId struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "blogging-app-namespace-1"
	// Namespace in which this WAF instance is running
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// AppType
	//
	// x-displayName: "AppType"
	// x-example: "blogging-app"
	// AppType configured on the virtual_host under which this WAF instance is running
	AppType string `protobuf:"bytes,2,opt,name=app_type,json=appType,proto3" json:"app_type,omitempty"`
	// Virtual Host
	//
	// x-displayName: "Virtual Host"
	// x-example: "VS:greatblogs-vhost"
	// Virtual host under which this WAF instance is running
	VirtualHost string `protobuf:"bytes,3,opt,name=virtual_host,json=virtualHost,proto3" json:"virtual_host,omitempty"`
	// Site
	//
	// x-displayName: "Site"
	// x-example: "greatblogs-ce"
	// Site from which this WAF instance is reporting the metrics
	Site string `protobuf:"bytes,4,opt,name=site,proto3" json:"site,omitempty"`
	// Service
	//
	// x-displayName: "Service"
	// x-example: "N:greatblogs-ce"
	// Service for which this WAF instance is reporting the metrics
	Service string `protobuf:"bytes,5,opt,name=service,proto3" json:"service,omitempty"`
	// Instance
	//
	// x-displayName: "Instance"
	// x-example: "India"
	// Region from which the client's accesses caused WAF metrics to be generated
	Instance string `protobuf:"bytes,6,opt,name=instance,proto3" json:"instance,omitempty"`
	// WAF Instance ID
	//
	// x-displayName: "WAF Instance ID"
	// x-example: "blogging-app-namespace-1:generated-waf-rules-greatblogs-waf"
	// WAF instance ID
	WafInstanceId string `protobuf:"bytes,7,opt,name=waf_instance_id,json=wafInstanceId,proto3" json:"waf_instance_id,omitempty"`
	// Rule ID
	//
	// x-displayName: "Rule ID"
	// x-example: "941210"
	// RuleID of the rule that was hit to cause this metric to be generated
	RuleId string `protobuf:"bytes,8,opt,name=rule_id,json=ruleId,proto3" json:"rule_id,omitempty"`
	// Rule Severity
	//
	// x-displayName: "Rule Severity"
	// x-example: "CRITICAL"
	// Rule severity of the rule that was hit to cause this metric to be generated
	RuleSeverity string `protobuf:"bytes,9,opt,name=rule_severity,json=ruleSeverity,proto3" json:"rule_severity,omitempty"`
	// Rule Tag
	//
	// x-displayName: "Rule Tag"
	// x-example: "CAPEC-272"
	// Rule tag of the rule that was hit to cause this metric to be generated
	RuleTag string `protobuf:"bytes,10,opt,name=rule_tag,json=ruleTag,proto3" json:"rule_tag,omitempty"`
	// Bot Type
	//
	// x-displayName: "Bot Type"
	// x-example: "scanner"
	// Type of Bot (crawler, scanner, script)
	BotType string `protobuf:"bytes,11,opt,name=bot_type,json=botType,proto3" json:"bot_type,omitempty"`
	// Bot Name
	//
	// x-displayName: "Bot Name"
	// x-example: "whatweb"
	// Name of the Bot associated with the waf rule
	BotName string `protobuf:"bytes,12,opt,name=bot_name,json=botName,proto3" json:"bot_name,omitempty"`
}

func (m *RuleHitsId) Reset()      { *m = RuleHitsId{} }
func (*RuleHitsId) ProtoMessage() {}
func (*RuleHitsId) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b9450f480a697d8, []int{8}
}
func (m *RuleHitsId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuleHitsId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RuleHitsId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuleHitsId.Merge(m, src)
}
func (m *RuleHitsId) XXX_Size() int {
	return m.Size()
}
func (m *RuleHitsId) XXX_DiscardUnknown() {
	xxx_messageInfo_RuleHitsId.DiscardUnknown(m)
}

var xxx_messageInfo_RuleHitsId proto.InternalMessageInfo

func (m *RuleHitsId) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *RuleHitsId) GetAppType() string {
	if m != nil {
		return m.AppType
	}
	return ""
}

func (m *RuleHitsId) GetVirtualHost() string {
	if m != nil {
		return m.VirtualHost
	}
	return ""
}

func (m *RuleHitsId) GetSite() string {
	if m != nil {
		return m.Site
	}
	return ""
}

func (m *RuleHitsId) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

func (m *RuleHitsId) GetInstance() string {
	if m != nil {
		return m.Instance
	}
	return ""
}

func (m *RuleHitsId) GetWafInstanceId() string {
	if m != nil {
		return m.WafInstanceId
	}
	return ""
}

func (m *RuleHitsId) GetRuleId() string {
	if m != nil {
		return m.RuleId
	}
	return ""
}

func (m *RuleHitsId) GetRuleSeverity() string {
	if m != nil {
		return m.RuleSeverity
	}
	return ""
}

func (m *RuleHitsId) GetRuleTag() string {
	if m != nil {
		return m.RuleTag
	}
	return ""
}

func (m *RuleHitsId) GetBotType() string {
	if m != nil {
		return m.BotType
	}
	return ""
}

func (m *RuleHitsId) GetBotName() string {
	if m != nil {
		return m.BotName
	}
	return ""
}

// Rule Hits Counter
//
// x-displayName: "Rule Hits Counter"
// RuleHitsCounter contains the timeseries data of rule hits counter.
type RuleHitsCounter struct {
	// Rule Hits ID
	//
	// x-displayName: "Rule Hits ID"
	// Rule Hits ID is the associated info for rule hits count
	Id *RuleHitsId `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Metric Values
	//
	// x-displayName: "Metric Values"
	// List of metric values
	Metric []*MetricValue `protobuf:"bytes,2,rep,name=metric,proto3" json:"metric,omitempty"`
}

func (m *RuleHitsCounter) Reset()      { *m = RuleHitsCounter{} }
func (*RuleHitsCounter) ProtoMessage() {}
func (*RuleHitsCounter) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b9450f480a697d8, []int{9}
}
func (m *RuleHitsCounter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuleHitsCounter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RuleHitsCounter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuleHitsCounter.Merge(m, src)
}
func (m *RuleHitsCounter) XXX_Size() int {
	return m.Size()
}
func (m *RuleHitsCounter) XXX_DiscardUnknown() {
	xxx_messageInfo_RuleHitsCounter.DiscardUnknown(m)
}

var xxx_messageInfo_RuleHitsCounter proto.InternalMessageInfo

func (m *RuleHitsCounter) GetId() *RuleHitsId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *RuleHitsCounter) GetMetric() []*MetricValue {
	if m != nil {
		return m.Metric
	}
	return nil
}

// SecurityEventsId
//
// x-displayName: "Security Events ID"
// SecurityEventsId uniquely identifies an entry in the response for rule_hits metrics query.
// security events counter is aggregated based on the MetricLabel specified in the group_by field in the request.
// Therefore, only the fields that corresponds to the MetricLabel in the group_by will have non-empty
// value in the response.
type SecurityEventsId struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "blogging-app-namespace-1"
	// Namespace in which this WAF instance is running
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// AppType
	//
	// x-displayName: "AppType"
	// x-example: "blogging-app"
	// AppType configured on the vhost under which this WAF instance is running
	AppType string `protobuf:"bytes,2,opt,name=app_type,json=appType,proto3" json:"app_type,omitempty"`
	// Virtual Host
	//
	// x-displayName: "Virtual Host"
	// x-example: "VS:greatblogs-vhost"
	// Virtual host under which this WAF instance is running
	VirtualHost string `protobuf:"bytes,3,opt,name=virtual_host,json=virtualHost,proto3" json:"virtual_host,omitempty"`
	// Site
	//
	// x-displayName: "Site"
	// x-example: "greatblogs-ce"
	// Site from which this WAF instance is reporting the metrics
	Site string `protobuf:"bytes,4,opt,name=site,proto3" json:"site,omitempty"`
	// Service
	//
	// x-displayName: "Service"
	// x-example: "N:greatblogs-ce"
	// Service for which this WAF instance is reporting the metrics
	Service string `protobuf:"bytes,5,opt,name=service,proto3" json:"service,omitempty"`
	// Instance
	//
	// x-displayName: "Instance"
	// x-example: "India"
	// Region from which the client's accesses caused WAF metrics to be generated
	Instance string `protobuf:"bytes,6,opt,name=instance,proto3" json:"instance,omitempty"`
	// WAF Instance ID
	//
	// x-displayName: "WAF Instance ID"
	// x-example: "blogging-app-namespace-1:generated-waf-rules-greatblogs-waf"
	// WAF instance ID
	WafInstanceId string `protobuf:"bytes,7,opt,name=waf_instance_id,json=wafInstanceId,proto3" json:"waf_instance_id,omitempty"`
	// WAF Mode
	//
	// x-displayName: "WAF Mode"
	// x-example: "Block"
	// Block or AlertOnly
	WafMode string `protobuf:"bytes,8,opt,name=waf_mode,json=wafMode,proto3" json:"waf_mode,omitempty"`
	// Bot Type
	//
	// x-displayName: "Bot Type"
	// x-example: "scanner"
	// Type of Bot (crawler, scanner, script)
	BotType string `protobuf:"bytes,9,opt,name=bot_type,json=botType,proto3" json:"bot_type,omitempty"`
	// Bot Name
	//
	// x-displayName: "Bot Name"
	// x-example: "whatweb"
	// Name of the Bot associated with the waf rule
	BotName string `protobuf:"bytes,10,opt,name=bot_name,json=botName,proto3" json:"bot_name,omitempty"`
}

func (m *SecurityEventsId) Reset()      { *m = SecurityEventsId{} }
func (*SecurityEventsId) ProtoMessage() {}
func (*SecurityEventsId) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b9450f480a697d8, []int{10}
}
func (m *SecurityEventsId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityEventsId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SecurityEventsId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityEventsId.Merge(m, src)
}
func (m *SecurityEventsId) XXX_Size() int {
	return m.Size()
}
func (m *SecurityEventsId) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityEventsId.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityEventsId proto.InternalMessageInfo

func (m *SecurityEventsId) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *SecurityEventsId) GetAppType() string {
	if m != nil {
		return m.AppType
	}
	return ""
}

func (m *SecurityEventsId) GetVirtualHost() string {
	if m != nil {
		return m.VirtualHost
	}
	return ""
}

func (m *SecurityEventsId) GetSite() string {
	if m != nil {
		return m.Site
	}
	return ""
}

func (m *SecurityEventsId) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

func (m *SecurityEventsId) GetInstance() string {
	if m != nil {
		return m.Instance
	}
	return ""
}

func (m *SecurityEventsId) GetWafInstanceId() string {
	if m != nil {
		return m.WafInstanceId
	}
	return ""
}

func (m *SecurityEventsId) GetWafMode() string {
	if m != nil {
		return m.WafMode
	}
	return ""
}

func (m *SecurityEventsId) GetBotType() string {
	if m != nil {
		return m.BotType
	}
	return ""
}

func (m *SecurityEventsId) GetBotName() string {
	if m != nil {
		return m.BotName
	}
	return ""
}

// Security Events Counter
//
// x-displayName: "Security Events Counter"
// SecurityEventsCounter contains the timeseries data of security events counter.
type SecurityEventsCounter struct {
	// Security Events ID
	//
	// x-displayName: "Security Events ID"
	// Security Event ID is the associated info for security events count
	Id *SecurityEventsId `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Metric Values
	//
	// x-displayName: "Metric Values"
	// List of metric values
	Metric []*MetricValue `protobuf:"bytes,2,rep,name=metric,proto3" json:"metric,omitempty"`
}

func (m *SecurityEventsCounter) Reset()      { *m = SecurityEventsCounter{} }
func (*SecurityEventsCounter) ProtoMessage() {}
func (*SecurityEventsCounter) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b9450f480a697d8, []int{11}
}
func (m *SecurityEventsCounter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityEventsCounter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SecurityEventsCounter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityEventsCounter.Merge(m, src)
}
func (m *SecurityEventsCounter) XXX_Size() int {
	return m.Size()
}
func (m *SecurityEventsCounter) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityEventsCounter.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityEventsCounter proto.InternalMessageInfo

func (m *SecurityEventsCounter) GetId() *SecurityEventsId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SecurityEventsCounter) GetMetric() []*MetricValue {
	if m != nil {
		return m.Metric
	}
	return nil
}

// SecurityEventAggregation
//
// x-displayName: "Security Event Aggregation"
// Aggregation request to provide analytics data over the security events response
type SecurityEventAggregation struct {
	// name
	//
	// x-displayName: "Name"
	// x-example: "date_bucket"
	//
	// user-defined name for the aggregation. This name is used to uniquely identify the
	// aggregations in the response.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// step
	//
	// x-displayName: "Step"
	// x-example: "5m"
	//
	// step is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.
	// The timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn <= end_time.
	// Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days
	//
	// Optional: If not specified, then step size is evaluated to <end_time - start_time>
	Step string `protobuf:"bytes,2,opt,name=step,proto3" json:"step,omitempty"`
}

func (m *SecurityEventAggregation) Reset()      { *m = SecurityEventAggregation{} }
func (*SecurityEventAggregation) ProtoMessage() {}
func (*SecurityEventAggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b9450f480a697d8, []int{12}
}
func (m *SecurityEventAggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityEventAggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SecurityEventAggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityEventAggregation.Merge(m, src)
}
func (m *SecurityEventAggregation) XXX_Size() int {
	return m.Size()
}
func (m *SecurityEventAggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityEventAggregation.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityEventAggregation proto.InternalMessageInfo

func (m *SecurityEventAggregation) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SecurityEventAggregation) GetStep() string {
	if m != nil {
		return m.Step
	}
	return ""
}

func init() {
	proto.RegisterEnum("ves.io.schema.waf.ContentManagementSystemType", ContentManagementSystemType_name, ContentManagementSystemType_value)
	proto.RegisterEnum("ves.io.schema.waf.LanguageType", LanguageType_name, LanguageType_value)
	proto.RegisterEnum("ves.io.schema.waf.WebServerType", WebServerType_name, WebServerType_value)
	proto.RegisterEnum("ves.io.schema.waf.DetectionTagType", DetectionTagType_name, DetectionTagType_value)
	proto.RegisterEnum("ves.io.schema.waf.MetricLabel", MetricLabel_name, MetricLabel_value)
	proto.RegisterEnum("ves.io.schema.waf.MetricLabelOp", MetricLabelOp_name, MetricLabelOp_value)
	proto.RegisterType((*AppProfile)(nil), "ves.io.schema.waf.AppProfile")
	proto.RegisterType((*DisabledDetectionTags)(nil), "ves.io.schema.waf.DisabledDetectionTags")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.waf.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.waf.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.waf.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.waf.GetSpecType")
	proto.RegisterType((*MetricLabelFilter)(nil), "ves.io.schema.waf.MetricLabelFilter")
	proto.RegisterType((*MetricValue)(nil), "ves.io.schema.waf.MetricValue")
	proto.RegisterType((*RuleHitsId)(nil), "ves.io.schema.waf.RuleHitsId")
	proto.RegisterType((*RuleHitsCounter)(nil), "ves.io.schema.waf.RuleHitsCounter")
	proto.RegisterType((*SecurityEventsId)(nil), "ves.io.schema.waf.SecurityEventsId")
	proto.RegisterType((*SecurityEventsCounter)(nil), "ves.io.schema.waf.SecurityEventsCounter")
	proto.RegisterType((*SecurityEventAggregation)(nil), "ves.io.schema.waf.SecurityEventAggregation")
}

func init() { proto.RegisterFile("ves.io/schema/waf/types.proto", fileDescriptor_9b9450f480a697d8) }

var fileDescriptor_9b9450f480a697d8 = []byte{
	// 1369 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x57, 0xcf, 0x6f, 0xdb, 0x46,
	0x16, 0xd6, 0x48, 0xb2, 0x7e, 0x3c, 0xc9, 0xf6, 0x78, 0x36, 0x41, 0x18, 0x27, 0xd1, 0x2a, 0x0a,
	0xb0, 0x30, 0x0c, 0x58, 0x5a, 0x38, 0x8b, 0x3d, 0xec, 0x21, 0x00, 0x2d, 0xd1, 0x36, 0x63, 0x59,
	0x52, 0x48, 0xda, 0x4e, 0x16, 0x28, 0xd8, 0x91, 0x38, 0x62, 0x88, 0x4a, 0x22, 0x41, 0x52, 0x72,
	0x7c, 0x6b, 0x81, 0xfe, 0x01, 0x6d, 0xff, 0x8a, 0x5e, 0x7b, 0xed, 0xa9, 0xc7, 0xa2, 0x87, 0x22,
	0xc7, 0x1c, 0x1b, 0xe5, 0xd2, 0x5c, 0xda, 0xa0, 0x40, 0x7b, 0x2e, 0x66, 0x28, 0x59, 0x96, 0xad,
	0xfa, 0xd2, 0x5b, 0x72, 0x9b, 0xef, 0xfd, 0xf8, 0xde, 0xbc, 0xf7, 0x8d, 0x46, 0x43, 0xb8, 0x37,
	0x62, 0x41, 0xd9, 0x71, 0x2b, 0x41, 0xe7, 0x39, 0xeb, 0xd3, 0xca, 0x29, 0xed, 0x56, 0xc2, 0x33,
	0x8f, 0x05, 0x65, 0xcf, 0x77, 0x43, 0x97, 0xac, 0x45, 0xee, 0x72, 0xe4, 0x2e, 0x9f, 0xd2, 0xee,
	0xfa, 0x96, 0xed, 0x84, 0xcf, 0x87, 0xed, 0x72, 0xc7, 0xed, 0x57, 0x6c, 0xd7, 0x76, 0x2b, 0x22,
	0xb2, 0x3d, 0xec, 0x0a, 0x24, 0x80, 0x58, 0x45, 0x0c, 0xeb, 0x77, 0xe6, 0x0b, 0xb8, 0x5e, 0xe8,
	0xb8, 0x83, 0x09, 0xfd, 0xfa, 0xed, 0x79, 0xe7, 0x85, 0xca, 0xeb, 0x77, 0xe7, 0x5d, 0x23, 0xda,
	0x73, 0x2c, 0x1a, 0xb2, 0x89, 0xb7, 0x78, 0xc9, 0xeb, 0xb0, 0x53, 0x73, 0x8e, 0xba, 0xf4, 0x2b,
	0x02, 0x90, 0x3d, 0xaf, 0xe5, 0xbb, 0x5d, 0xa7, 0xc7, 0xc8, 0x1e, 0x64, 0x7a, 0x74, 0x60, 0x0f,
	0xa9, 0xcd, 0xa4, 0x78, 0x31, 0xb1, 0xb1, 0xb2, 0xfd, 0xcf, 0xf2, 0x95, 0xde, 0xca, 0xf5, 0x49,
	0x88, 0x71, 0xe6, 0xb1, 0x1d, 0xf8, 0xf6, 0xed, 0x77, 0x89, 0xa5, 0xaf, 0x50, 0x5c, 0x42, 0xda,
	0x79, 0x32, 0xa9, 0x43, 0xa2, 0xd3, 0x0f, 0xa4, 0x84, 0xe0, 0x28, 0x2f, 0xe0, 0xa8, 0xba, 0x83,
	0x90, 0x0d, 0xc2, 0x43, 0x3a, 0xa0, 0x36, 0xeb, 0xb3, 0x41, 0xa8, 0x9f, 0x05, 0x21, 0xeb, 0x5f,
	0xa1, 0xe4, 0x34, 0xe4, 0x31, 0x64, 0x4f, 0x59, 0x3b, 0x60, 0xfe, 0x88, 0xf9, 0x52, 0x52, 0x70,
	0x16, 0x17, 0x70, 0x9e, 0xb0, 0xb6, 0x2e, 0x62, 0xae, 0xb0, 0xcc, 0xd2, 0x4b, 0x23, 0xb8, 0x59,
	0x73, 0x02, 0xda, 0xee, 0x31, 0xab, 0xc6, 0x42, 0xd6, 0xe1, 0xd3, 0x30, 0xa8, 0x1d, 0x90, 0x8f,
	0x80, 0x58, 0x53, 0x83, 0x19, 0x52, 0xdb, 0xe4, 0x73, 0x96, 0x90, 0xa8, 0xf6, 0x60, 0x41, 0xb5,
	0x8b, 0xd9, 0x57, 0x0a, 0x62, 0xeb, 0x92, 0xb7, 0x34, 0x46, 0xb0, 0xb2, 0xd7, 0x73, 0xdb, 0xb4,
	0xa7, 0x7b, 0xac, 0xc3, 0x4d, 0xe4, 0x11, 0xe4, 0xa8, 0xe7, 0x99, 0x5e, 0x34, 0x7c, 0x09, 0x15,
	0xd1, 0x46, 0x6e, 0xfb, 0xde, 0x82, 0x52, 0x33, 0x85, 0x34, 0xa0, 0x33, 0xb5, 0xca, 0x90, 0xec,
	0xbb, 0x16, 0x93, 0x92, 0x45, 0xb4, 0xb1, 0xb2, 0xbd, 0x7e, 0x29, 0xf1, 0x84, 0x76, 0x0f, 0x5d,
	0x4b, 0x88, 0xa4, 0x89, 0x38, 0xf2, 0x31, 0xdc, 0xb2, 0x26, 0xad, 0x9b, 0x73, 0xad, 0x06, 0xd2,
	0x92, 0xa8, 0xbd, 0xb1, 0xa8, 0xcd, 0x45, 0xc3, 0xd2, 0x6e, 0x5a, 0x8b, 0xcc, 0xa5, 0xdf, 0x11,
	0xac, 0x54, 0x7d, 0x46, 0x43, 0xf6, 0xfe, 0x36, 0xf9, 0xbf, 0xb5, 0x1f, 0x1e, 0x5d, 0x52, 0xb2,
	0xf4, 0x07, 0x82, 0x55, 0x8d, 0x79, 0x3d, 0xda, 0xf9, 0xc0, 0x1a, 0xff, 0x0d, 0x41, 0x6e, 0x8f,
	0x85, 0x1f, 0x56, 0xd3, 0x5f, 0x22, 0x58, 0x3b, 0x64, 0xa1, 0xef, 0x74, 0xea, 0xb4, 0xcd, 0x7a,
	0xbb, 0x4e, 0x2f, 0x64, 0x3e, 0xf9, 0x0f, 0x2c, 0xf5, 0x38, 0x14, 0x4d, 0xaf, 0x6c, 0x17, 0x16,
	0x14, 0xbe, 0x90, 0xa4, 0x45, 0xc1, 0xe4, 0xdf, 0x10, 0x77, 0x3d, 0x29, 0x2e, 0x52, 0x8a, 0xd7,
	0xa7, 0x34, 0x3d, 0x2d, 0xee, 0x7a, 0xe4, 0x06, 0x2c, 0x8d, 0x68, 0x6f, 0xc8, 0xa4, 0x44, 0x11,
	0x6d, 0x64, 0xb5, 0x08, 0x94, 0x64, 0xc8, 0x45, 0xa1, 0xc7, 0x1c, 0x92, 0xbb, 0x90, 0x0d, 0x9d,
	0x3e, 0x0b, 0x42, 0xda, 0xf7, 0xc4, 0x86, 0x90, 0x36, 0x33, 0xcc, 0x28, 0xe2, 0x17, 0x29, 0xde,
	0xc6, 0x01, 0xb4, 0x61, 0x8f, 0xed, 0x3b, 0x61, 0xa0, 0x5a, 0x9c, 0x62, 0x40, 0xfb, 0x2c, 0xf0,
	0x68, 0x27, 0x12, 0x32, 0xab, 0xcd, 0x0c, 0xe4, 0x36, 0x64, 0xb8, 0xd0, 0xe2, 0x8e, 0x8c, 0x58,
	0xd2, 0xd4, 0xf3, 0xc4, 0x19, 0xb8, 0x0f, 0xf9, 0x91, 0xe3, 0x87, 0x43, 0xda, 0x33, 0x9f, 0xbb,
	0x41, 0x38, 0xd9, 0x67, 0x6e, 0x62, 0xdb, 0x77, 0x83, 0x90, 0x10, 0x48, 0x06, 0x4e, 0x18, 0xc9,
	0x9c, 0xd5, 0xc4, 0x9a, 0x48, 0x90, 0xe6, 0x57, 0xb4, 0xd3, 0x61, 0x42, 0xba, 0xac, 0x36, 0x85,
	0x64, 0x1d, 0x32, 0xce, 0x20, 0x08, 0xe9, 0xa0, 0xc3, 0xa4, 0x94, 0x70, 0x9d, 0x63, 0xf2, 0x2f,
	0x58, 0x3d, 0xa5, 0x5d, 0x73, 0x8a, 0x4d, 0xc7, 0x92, 0xd2, 0x22, 0x64, 0xf9, 0x94, 0x76, 0xd5,
	0x89, 0x55, 0xb5, 0xc8, 0x2d, 0x48, 0xfb, 0xc3, 0x9e, 0xf0, 0x67, 0x84, 0x3f, 0xc5, 0xa1, 0x6a,
	0x91, 0x07, 0xb0, 0x2c, 0x1c, 0x01, 0x1b, 0x31, 0xdf, 0x09, 0xcf, 0xa4, 0xac, 0x70, 0xe7, 0xb9,
	0x51, 0x9f, 0xd8, 0x78, 0xb7, 0x22, 0x28, 0xa4, 0xb6, 0x04, 0xd1, 0xe6, 0x38, 0x36, 0xa8, 0xcd,
	0x5d, 0x6d, 0x37, 0x8c, 0x06, 0x91, 0x8b, 0x5c, 0x6d, 0x37, 0x14, 0x83, 0x98, 0xb8, 0xf8, 0xd0,
	0xa4, 0xfc, 0xb9, 0xab, 0x41, 0xfb, 0xac, 0xf4, 0x02, 0x56, 0xa7, 0xa3, 0xae, 0xba, 0xc3, 0x01,
	0x3f, 0x3f, 0x5b, 0x10, 0x77, 0xac, 0x6b, 0x7e, 0x31, 0x33, 0x69, 0xb4, 0xb8, 0x63, 0x91, 0xff,
	0x42, 0xaa, 0x2f, 0x04, 0x17, 0x7f, 0xd4, 0xb9, 0x6b, 0xce, 0x9b, 0x38, 0x11, 0xda, 0x24, 0xba,
	0xf4, 0x4d, 0x1c, 0xb0, 0xce, 0x3a, 0x43, 0xde, 0x97, 0x32, 0x62, 0x83, 0xf7, 0x50, 0xeb, 0xdb,
	0x90, 0xe1, 0x71, 0xe2, 0x22, 0x89, 0xc4, 0x4e, 0x9f, 0x46, 0x37, 0xc7, 0x9c, 0x5a, 0xd9, 0xbf,
	0x56, 0x0b, 0xe6, 0xd5, 0xfa, 0x1c, 0xc1, 0xcd, 0xf9, 0x99, 0x4d, 0x45, 0x7b, 0x78, 0x41, 0xb4,
	0x45, 0x8f, 0x84, 0xcb, 0x93, 0xfe, 0x5b, 0xd2, 0xed, 0x80, 0x34, 0xc7, 0x27, 0xdb, 0xb6, 0xcf,
	0x6c, 0xca, 0xaf, 0x2a, 0x3e, 0x65, 0xb1, 0xf3, 0x48, 0x3c, 0xb1, 0x16, 0x93, 0x0f, 0x99, 0x37,
	0xd1, 0x4c, 0xac, 0x37, 0x29, 0xdc, 0xb9, 0xe6, 0xe9, 0x45, 0x00, 0x52, 0x35, 0xed, 0xa8, 0x25,
	0xd7, 0x71, 0x8c, 0x2c, 0x43, 0xf6, 0xa4, 0xa9, 0xd5, 0x5a, 0x9a, 0xa2, 0xeb, 0x18, 0x71, 0xd8,
	0x50, 0x9e, 0x1a, 0xd5, 0x7a, 0xf3, 0xa8, 0x86, 0xe3, 0x24, 0x0f, 0x99, 0x5a, 0xf3, 0xe0, 0xe8,
	0x44, 0x3d, 0x50, 0x71, 0x82, 0xe7, 0x55, 0x5b, 0x72, 0x43, 0xa9, 0xe3, 0xe4, 0xe6, 0x7d, 0xc8,
	0x5f, 0x7c, 0x21, 0x92, 0x34, 0x24, 0x5a, 0xfb, 0x2d, 0x1c, 0x23, 0x19, 0x48, 0x3e, 0x96, 0x8f,
	0x65, 0x8c, 0x36, 0x25, 0x58, 0x9e, 0x7b, 0xac, 0xf1, 0x18, 0x55, 0xd5, 0x71, 0x6c, 0xf3, 0x17,
	0x04, 0xf8, 0xf2, 0xcb, 0x8a, 0x60, 0xc8, 0xd7, 0x64, 0x43, 0x36, 0xeb, 0x8a, 0x7c, 0x20, 0xef,
	0x29, 0x38, 0x46, 0x56, 0x21, 0xa7, 0x3f, 0xa9, 0xab, 0xa6, 0x6c, 0x18, 0x72, 0xf5, 0x00, 0x23,
	0xb2, 0x02, 0xf0, 0x54, 0xd7, 0xa7, 0x38, 0x4e, 0xfe, 0x01, 0xab, 0x2d, 0xad, 0x69, 0x34, 0xab,
	0xcd, 0xfa, 0xd4, 0x98, 0xe0, 0x41, 0x5a, 0x55, 0x99, 0xe2, 0x24, 0xc7, 0xad, 0xfd, 0xd6, 0x14,
	0x2f, 0x71, 0x5c, 0x6b, 0x9e, 0x93, 0xa4, 0x44, 0xfc, 0xee, 0x79, 0x91, 0x34, 0xc7, 0xf5, 0x19,
	0xce, 0x90, 0x1c, 0xa4, 0xf5, 0xaa, 0xdc, 0x68, 0x28, 0x1a, 0xce, 0x92, 0x1b, 0x80, 0x75, 0x45,
	0xd7, 0xd5, 0x66, 0xc3, 0xdc, 0x55, 0x9f, 0xca, 0x86, 0xda, 0x6c, 0x60, 0x20, 0x6b, 0xb0, 0x7c,
	0xd0, 0x68, 0x9e, 0x34, 0x4c, 0xbd, 0xaa, 0xa9, 0x2d, 0x43, 0xc7, 0x39, 0x3e, 0xb9, 0xaa, 0x26,
	0x9f, 0xd4, 0x15, 0x4d, 0xc7, 0xf9, 0xcd, 0x1f, 0xd1, 0xf4, 0xe6, 0x16, 0x97, 0xbc, 0x18, 0xb3,
	0x7c, 0xa8, 0xe8, 0x2d, 0xb9, 0xca, 0x1b, 0xcd, 0x43, 0x46, 0x6e, 0xb5, 0x4c, 0xe3, 0x59, 0x4b,
	0xc1, 0x88, 0x0f, 0xe2, 0x58, 0xd5, 0x8c, 0x23, 0xb9, 0x6e, 0xee, 0x37, 0x75, 0x03, 0xc7, 0xf9,
	0x4c, 0x75, 0xd5, 0x50, 0x70, 0x42, 0x6c, 0x46, 0xd1, 0x8e, 0xd5, 0xaa, 0x82, 0x93, 0x3c, 0x4d,
	0x6d, 0xe8, 0x86, 0xdc, 0xa8, 0x2a, 0x78, 0x89, 0x0f, 0xe3, 0x44, 0xde, 0x35, 0xa7, 0x16, 0x53,
	0xad, 0xe1, 0x14, 0x8f, 0xd7, 0x8e, 0xea, 0x02, 0xa4, 0xf9, 0x36, 0x05, 0xd0, 0x95, 0x63, 0x45,
	0x53, 0x8d, 0x67, 0x38, 0xc3, 0x29, 0x84, 0xc9, 0x90, 0xf7, 0x70, 0x96, 0x23, 0x4e, 0x71, 0xd8,
	0xac, 0x29, 0x18, 0x38, 0xda, 0x69, 0x1a, 0xd1, 0xae, 0x72, 0x53, 0xc4, 0xb7, 0x8d, 0xf3, 0x9b,
	0x45, 0x58, 0x9e, 0xfb, 0xd3, 0x22, 0x29, 0x88, 0x2b, 0x4f, 0x70, 0x8c, 0x6b, 0xdc, 0x50, 0x9e,
	0x60, 0xb4, 0xf3, 0x19, 0x7a, 0xf9, 0xba, 0x10, 0x7b, 0xf5, 0xba, 0x10, 0x7b, 0xf7, 0xba, 0x80,
	0x3e, 0x1d, 0x17, 0xd0, 0xd7, 0xe3, 0x02, 0xfa, 0x7e, 0x5c, 0x40, 0x2f, 0xc7, 0x05, 0xf4, 0x6a,
	0x5c, 0x40, 0x3f, 0x8d, 0x0b, 0xe8, 0xe7, 0x71, 0x21, 0xf6, 0x6e, 0x5c, 0x40, 0x5f, 0xbc, 0x29,
	0xc4, 0x5e, 0xbe, 0x29, 0xc4, 0x5e, 0xbd, 0x29, 0xc4, 0xfe, 0xbf, 0x67, 0xbb, 0xde, 0x27, 0x76,
	0x79, 0xe4, 0xf2, 0xbf, 0x5c, 0x9f, 0x96, 0x87, 0x41, 0x45, 0x2c, 0xba, 0xae, 0xdf, 0xdf, 0xf2,
	0x7c, 0x77, 0xe4, 0x58, 0xcc, 0xdf, 0x9a, 0xba, 0x2b, 0x5e, 0xdb, 0x76, 0x2b, 0xec, 0x45, 0x38,
	0xf9, 0x00, 0x9a, 0x7d, 0xbe, 0xb5, 0x53, 0xe2, 0xfb, 0xe7, 0xe1, 0x9f, 0x01, 0x00, 0x00, 0xff,
	0xff, 0xe4, 0xad, 0x23, 0x0c, 0xda, 0x0d, 0x00, 0x00,
}

func (x ContentManagementSystemType) String() string {
	s, ok := ContentManagementSystemType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x LanguageType) String() string {
	s, ok := LanguageType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x WebServerType) String() string {
	s, ok := WebServerType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DetectionTagType) String() string {
	s, ok := DetectionTagType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MetricLabel) String() string {
	s, ok := MetricLabel_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MetricLabelOp) String() string {
	s, ok := MetricLabelOp_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *AppProfile) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AppProfile)
	if !ok {
		that2, ok := that.(AppProfile)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Language) != len(that1.Language) {
		return false
	}
	for i := range this.Language {
		if this.Language[i] != that1.Language[i] {
			return false
		}
	}
	if len(this.Cms) != len(that1.Cms) {
		return false
	}
	for i := range this.Cms {
		if this.Cms[i] != that1.Cms[i] {
			return false
		}
	}
	if len(this.Webserver) != len(that1.Webserver) {
		return false
	}
	for i := range this.Webserver {
		if this.Webserver[i] != that1.Webserver[i] {
			return false
		}
	}
	return true
}
func (this *DisabledDetectionTags) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DisabledDetectionTags)
	if !ok {
		that2, ok := that.(DisabledDetectionTags)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.DetectionTagType) != len(that1.DetectionTagType) {
		return false
	}
	for i := range this.DetectionTagType {
		if this.DetectionTagType[i] != that1.DetectionTagType[i] {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AppProfile.Equal(that1.AppProfile) {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if !this.DisabledDetectionTags.Equal(that1.DisabledDetectionTags) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AppProfile.Equal(that1.AppProfile) {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if !this.DisabledDetectionTags.Equal(that1.DisabledDetectionTags) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AppProfile.Equal(that1.AppProfile) {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if !this.DisabledDetectionTags.Equal(that1.DisabledDetectionTags) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AppProfile.Equal(that1.AppProfile) {
		return false
	}
	if this.Mode != that1.Mode {
		return false
	}
	if !this.DisabledDetectionTags.Equal(that1.DisabledDetectionTags) {
		return false
	}
	return true
}
func (this *MetricLabelFilter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetricLabelFilter)
	if !ok {
		that2, ok := that.(MetricLabelFilter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Label != that1.Label {
		return false
	}
	if this.Op != that1.Op {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *MetricValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetricValue)
	if !ok {
		that2, ok := that.(MetricValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *RuleHitsId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RuleHitsId)
	if !ok {
		that2, ok := that.(RuleHitsId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.AppType != that1.AppType {
		return false
	}
	if this.VirtualHost != that1.VirtualHost {
		return false
	}
	if this.Site != that1.Site {
		return false
	}
	if this.Service != that1.Service {
		return false
	}
	if this.Instance != that1.Instance {
		return false
	}
	if this.WafInstanceId != that1.WafInstanceId {
		return false
	}
	if this.RuleId != that1.RuleId {
		return false
	}
	if this.RuleSeverity != that1.RuleSeverity {
		return false
	}
	if this.RuleTag != that1.RuleTag {
		return false
	}
	if this.BotType != that1.BotType {
		return false
	}
	if this.BotName != that1.BotName {
		return false
	}
	return true
}
func (this *RuleHitsCounter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RuleHitsCounter)
	if !ok {
		that2, ok := that.(RuleHitsCounter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	if len(this.Metric) != len(that1.Metric) {
		return false
	}
	for i := range this.Metric {
		if !this.Metric[i].Equal(that1.Metric[i]) {
			return false
		}
	}
	return true
}
func (this *SecurityEventsId) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityEventsId)
	if !ok {
		that2, ok := that.(SecurityEventsId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.AppType != that1.AppType {
		return false
	}
	if this.VirtualHost != that1.VirtualHost {
		return false
	}
	if this.Site != that1.Site {
		return false
	}
	if this.Service != that1.Service {
		return false
	}
	if this.Instance != that1.Instance {
		return false
	}
	if this.WafInstanceId != that1.WafInstanceId {
		return false
	}
	if this.WafMode != that1.WafMode {
		return false
	}
	if this.BotType != that1.BotType {
		return false
	}
	if this.BotName != that1.BotName {
		return false
	}
	return true
}
func (this *SecurityEventsCounter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityEventsCounter)
	if !ok {
		that2, ok := that.(SecurityEventsCounter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Id.Equal(that1.Id) {
		return false
	}
	if len(this.Metric) != len(that1.Metric) {
		return false
	}
	for i := range this.Metric {
		if !this.Metric[i].Equal(that1.Metric[i]) {
			return false
		}
	}
	return true
}
func (this *SecurityEventAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityEventAggregation)
	if !ok {
		that2, ok := that.(SecurityEventAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Step != that1.Step {
		return false
	}
	return true
}
func (this *AppProfile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&waf.AppProfile{")
	s = append(s, "Language: "+fmt.Sprintf("%#v", this.Language)+",\n")
	s = append(s, "Cms: "+fmt.Sprintf("%#v", this.Cms)+",\n")
	s = append(s, "Webserver: "+fmt.Sprintf("%#v", this.Webserver)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DisabledDetectionTags) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&waf.DisabledDetectionTags{")
	s = append(s, "DetectionTagType: "+fmt.Sprintf("%#v", this.DetectionTagType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&waf.GlobalSpecType{")
	if this.AppProfile != nil {
		s = append(s, "AppProfile: "+fmt.Sprintf("%#v", this.AppProfile)+",\n")
	}
	s = append(s, "Mode: "+fmt.Sprintf("%#v", this.Mode)+",\n")
	if this.DisabledDetectionTags != nil {
		s = append(s, "DisabledDetectionTags: "+fmt.Sprintf("%#v", this.DisabledDetectionTags)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&waf.CreateSpecType{")
	if this.AppProfile != nil {
		s = append(s, "AppProfile: "+fmt.Sprintf("%#v", this.AppProfile)+",\n")
	}
	s = append(s, "Mode: "+fmt.Sprintf("%#v", this.Mode)+",\n")
	if this.DisabledDetectionTags != nil {
		s = append(s, "DisabledDetectionTags: "+fmt.Sprintf("%#v", this.DisabledDetectionTags)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&waf.ReplaceSpecType{")
	if this.AppProfile != nil {
		s = append(s, "AppProfile: "+fmt.Sprintf("%#v", this.AppProfile)+",\n")
	}
	s = append(s, "Mode: "+fmt.Sprintf("%#v", this.Mode)+",\n")
	if this.DisabledDetectionTags != nil {
		s = append(s, "DisabledDetectionTags: "+fmt.Sprintf("%#v", this.DisabledDetectionTags)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&waf.GetSpecType{")
	if this.AppProfile != nil {
		s = append(s, "AppProfile: "+fmt.Sprintf("%#v", this.AppProfile)+",\n")
	}
	s = append(s, "Mode: "+fmt.Sprintf("%#v", this.Mode)+",\n")
	if this.DisabledDetectionTags != nil {
		s = append(s, "DisabledDetectionTags: "+fmt.Sprintf("%#v", this.DisabledDetectionTags)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MetricLabelFilter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&waf.MetricLabelFilter{")
	s = append(s, "Label: "+fmt.Sprintf("%#v", this.Label)+",\n")
	s = append(s, "Op: "+fmt.Sprintf("%#v", this.Op)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MetricValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&waf.MetricValue{")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RuleHitsId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&waf.RuleHitsId{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "AppType: "+fmt.Sprintf("%#v", this.AppType)+",\n")
	s = append(s, "VirtualHost: "+fmt.Sprintf("%#v", this.VirtualHost)+",\n")
	s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	s = append(s, "Service: "+fmt.Sprintf("%#v", this.Service)+",\n")
	s = append(s, "Instance: "+fmt.Sprintf("%#v", this.Instance)+",\n")
	s = append(s, "WafInstanceId: "+fmt.Sprintf("%#v", this.WafInstanceId)+",\n")
	s = append(s, "RuleId: "+fmt.Sprintf("%#v", this.RuleId)+",\n")
	s = append(s, "RuleSeverity: "+fmt.Sprintf("%#v", this.RuleSeverity)+",\n")
	s = append(s, "RuleTag: "+fmt.Sprintf("%#v", this.RuleTag)+",\n")
	s = append(s, "BotType: "+fmt.Sprintf("%#v", this.BotType)+",\n")
	s = append(s, "BotName: "+fmt.Sprintf("%#v", this.BotName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RuleHitsCounter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&waf.RuleHitsCounter{")
	if this.Id != nil {
		s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	}
	if this.Metric != nil {
		s = append(s, "Metric: "+fmt.Sprintf("%#v", this.Metric)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SecurityEventsId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&waf.SecurityEventsId{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "AppType: "+fmt.Sprintf("%#v", this.AppType)+",\n")
	s = append(s, "VirtualHost: "+fmt.Sprintf("%#v", this.VirtualHost)+",\n")
	s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	s = append(s, "Service: "+fmt.Sprintf("%#v", this.Service)+",\n")
	s = append(s, "Instance: "+fmt.Sprintf("%#v", this.Instance)+",\n")
	s = append(s, "WafInstanceId: "+fmt.Sprintf("%#v", this.WafInstanceId)+",\n")
	s = append(s, "WafMode: "+fmt.Sprintf("%#v", this.WafMode)+",\n")
	s = append(s, "BotType: "+fmt.Sprintf("%#v", this.BotType)+",\n")
	s = append(s, "BotName: "+fmt.Sprintf("%#v", this.BotName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SecurityEventsCounter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&waf.SecurityEventsCounter{")
	if this.Id != nil {
		s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	}
	if this.Metric != nil {
		s = append(s, "Metric: "+fmt.Sprintf("%#v", this.Metric)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SecurityEventAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&waf.SecurityEventAggregation{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Step: "+fmt.Sprintf("%#v", this.Step)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *AppProfile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppProfile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppProfile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Webserver) > 0 {
		dAtA2 := make([]byte, len(m.Webserver)*10)
		var j1 int
		for _, num := range m.Webserver {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintTypes(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Cms) > 0 {
		dAtA4 := make([]byte, len(m.Cms)*10)
		var j3 int
		for _, num := range m.Cms {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintTypes(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Language) > 0 {
		dAtA6 := make([]byte, len(m.Language)*10)
		var j5 int
		for _, num := range m.Language {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintTypes(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *DisabledDetectionTags) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DisabledDetectionTags) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DisabledDetectionTags) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DetectionTagType) > 0 {
		dAtA8 := make([]byte, len(m.DetectionTagType)*10)
		var j7 int
		for _, num := range m.DetectionTagType {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintTypes(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DisabledDetectionTags != nil {
		{
			size, err := m.DisabledDetectionTags.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Mode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x20
	}
	if m.AppProfile != nil {
		{
			size, err := m.AppProfile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DisabledDetectionTags != nil {
		{
			size, err := m.DisabledDetectionTags.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Mode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x20
	}
	if m.AppProfile != nil {
		{
			size, err := m.AppProfile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DisabledDetectionTags != nil {
		{
			size, err := m.DisabledDetectionTags.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Mode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x20
	}
	if m.AppProfile != nil {
		{
			size, err := m.AppProfile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DisabledDetectionTags != nil {
		{
			size, err := m.DisabledDetectionTags.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Mode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x20
	}
	if m.AppProfile != nil {
		{
			size, err := m.AppProfile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetricLabelFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricLabelFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricLabelFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Op != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x10
	}
	if m.Label != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Label))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MetricValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Timestamp))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *RuleHitsId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleHitsId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RuleHitsId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BotName) > 0 {
		i -= len(m.BotName)
		copy(dAtA[i:], m.BotName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BotName)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.BotType) > 0 {
		i -= len(m.BotType)
		copy(dAtA[i:], m.BotType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BotType)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.RuleTag) > 0 {
		i -= len(m.RuleTag)
		copy(dAtA[i:], m.RuleTag)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RuleTag)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.RuleSeverity) > 0 {
		i -= len(m.RuleSeverity)
		copy(dAtA[i:], m.RuleSeverity)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RuleSeverity)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.RuleId) > 0 {
		i -= len(m.RuleId)
		copy(dAtA[i:], m.RuleId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RuleId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.WafInstanceId) > 0 {
		i -= len(m.WafInstanceId)
		copy(dAtA[i:], m.WafInstanceId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.WafInstanceId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Instance) > 0 {
		i -= len(m.Instance)
		copy(dAtA[i:], m.Instance)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Instance)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Service) > 0 {
		i -= len(m.Service)
		copy(dAtA[i:], m.Service)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Service)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Site) > 0 {
		i -= len(m.Site)
		copy(dAtA[i:], m.Site)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Site)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.VirtualHost) > 0 {
		i -= len(m.VirtualHost)
		copy(dAtA[i:], m.VirtualHost)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VirtualHost)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AppType) > 0 {
		i -= len(m.AppType)
		copy(dAtA[i:], m.AppType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AppType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RuleHitsCounter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleHitsCounter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RuleHitsCounter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metric) > 0 {
		for iNdEx := len(m.Metric) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Metric[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityEventsId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityEventsId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityEventsId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BotName) > 0 {
		i -= len(m.BotName)
		copy(dAtA[i:], m.BotName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BotName)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.BotType) > 0 {
		i -= len(m.BotType)
		copy(dAtA[i:], m.BotType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BotType)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.WafMode) > 0 {
		i -= len(m.WafMode)
		copy(dAtA[i:], m.WafMode)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.WafMode)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.WafInstanceId) > 0 {
		i -= len(m.WafInstanceId)
		copy(dAtA[i:], m.WafInstanceId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.WafInstanceId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Instance) > 0 {
		i -= len(m.Instance)
		copy(dAtA[i:], m.Instance)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Instance)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Service) > 0 {
		i -= len(m.Service)
		copy(dAtA[i:], m.Service)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Service)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Site) > 0 {
		i -= len(m.Site)
		copy(dAtA[i:], m.Site)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Site)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.VirtualHost) > 0 {
		i -= len(m.VirtualHost)
		copy(dAtA[i:], m.VirtualHost)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VirtualHost)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AppType) > 0 {
		i -= len(m.AppType)
		copy(dAtA[i:], m.AppType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AppType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityEventsCounter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityEventsCounter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityEventsCounter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metric) > 0 {
		for iNdEx := len(m.Metric) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Metric[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityEventAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityEventAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityEventAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Step) > 0 {
		i -= len(m.Step)
		copy(dAtA[i:], m.Step)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Step)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AppProfile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Language) > 0 {
		l = 0
		for _, e := range m.Language {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.Cms) > 0 {
		l = 0
		for _, e := range m.Cms {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.Webserver) > 0 {
		l = 0
		for _, e := range m.Webserver {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *DisabledDetectionTags) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DetectionTagType) > 0 {
		l = 0
		for _, e := range m.DetectionTagType {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppProfile != nil {
		l = m.AppProfile.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Mode != 0 {
		n += 1 + sovTypes(uint64(m.Mode))
	}
	if m.DisabledDetectionTags != nil {
		l = m.DisabledDetectionTags.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppProfile != nil {
		l = m.AppProfile.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Mode != 0 {
		n += 1 + sovTypes(uint64(m.Mode))
	}
	if m.DisabledDetectionTags != nil {
		l = m.DisabledDetectionTags.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppProfile != nil {
		l = m.AppProfile.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Mode != 0 {
		n += 1 + sovTypes(uint64(m.Mode))
	}
	if m.DisabledDetectionTags != nil {
		l = m.DisabledDetectionTags.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppProfile != nil {
		l = m.AppProfile.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Mode != 0 {
		n += 1 + sovTypes(uint64(m.Mode))
	}
	if m.DisabledDetectionTags != nil {
		l = m.DisabledDetectionTags.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MetricLabelFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Label != 0 {
		n += 1 + sovTypes(uint64(m.Label))
	}
	if m.Op != 0 {
		n += 1 + sovTypes(uint64(m.Op))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MetricValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 9
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RuleHitsId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AppType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VirtualHost)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Site)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Service)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.WafInstanceId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RuleId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RuleSeverity)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RuleTag)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BotType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BotName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RuleHitsCounter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Metric) > 0 {
		for _, e := range m.Metric {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *SecurityEventsId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AppType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VirtualHost)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Site)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Service)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Instance)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.WafInstanceId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.WafMode)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BotType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BotName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SecurityEventsCounter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Metric) > 0 {
		for _, e := range m.Metric {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *SecurityEventAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Step)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AppProfile) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AppProfile{`,
		`Language:` + fmt.Sprintf("%v", this.Language) + `,`,
		`Cms:` + fmt.Sprintf("%v", this.Cms) + `,`,
		`Webserver:` + fmt.Sprintf("%v", this.Webserver) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DisabledDetectionTags) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DisabledDetectionTags{`,
		`DetectionTagType:` + fmt.Sprintf("%v", this.DetectionTagType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`AppProfile:` + strings.Replace(this.AppProfile.String(), "AppProfile", "AppProfile", 1) + `,`,
		`Mode:` + fmt.Sprintf("%v", this.Mode) + `,`,
		`DisabledDetectionTags:` + strings.Replace(this.DisabledDetectionTags.String(), "DisabledDetectionTags", "DisabledDetectionTags", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`AppProfile:` + strings.Replace(this.AppProfile.String(), "AppProfile", "AppProfile", 1) + `,`,
		`Mode:` + fmt.Sprintf("%v", this.Mode) + `,`,
		`DisabledDetectionTags:` + strings.Replace(this.DisabledDetectionTags.String(), "DisabledDetectionTags", "DisabledDetectionTags", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`AppProfile:` + strings.Replace(this.AppProfile.String(), "AppProfile", "AppProfile", 1) + `,`,
		`Mode:` + fmt.Sprintf("%v", this.Mode) + `,`,
		`DisabledDetectionTags:` + strings.Replace(this.DisabledDetectionTags.String(), "DisabledDetectionTags", "DisabledDetectionTags", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`AppProfile:` + strings.Replace(this.AppProfile.String(), "AppProfile", "AppProfile", 1) + `,`,
		`Mode:` + fmt.Sprintf("%v", this.Mode) + `,`,
		`DisabledDetectionTags:` + strings.Replace(this.DisabledDetectionTags.String(), "DisabledDetectionTags", "DisabledDetectionTags", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricLabelFilter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MetricLabelFilter{`,
		`Label:` + fmt.Sprintf("%v", this.Label) + `,`,
		`Op:` + fmt.Sprintf("%v", this.Op) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MetricValue{`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RuleHitsId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RuleHitsId{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`AppType:` + fmt.Sprintf("%v", this.AppType) + `,`,
		`VirtualHost:` + fmt.Sprintf("%v", this.VirtualHost) + `,`,
		`Site:` + fmt.Sprintf("%v", this.Site) + `,`,
		`Service:` + fmt.Sprintf("%v", this.Service) + `,`,
		`Instance:` + fmt.Sprintf("%v", this.Instance) + `,`,
		`WafInstanceId:` + fmt.Sprintf("%v", this.WafInstanceId) + `,`,
		`RuleId:` + fmt.Sprintf("%v", this.RuleId) + `,`,
		`RuleSeverity:` + fmt.Sprintf("%v", this.RuleSeverity) + `,`,
		`RuleTag:` + fmt.Sprintf("%v", this.RuleTag) + `,`,
		`BotType:` + fmt.Sprintf("%v", this.BotType) + `,`,
		`BotName:` + fmt.Sprintf("%v", this.BotName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RuleHitsCounter) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMetric := "[]*MetricValue{"
	for _, f := range this.Metric {
		repeatedStringForMetric += strings.Replace(f.String(), "MetricValue", "MetricValue", 1) + ","
	}
	repeatedStringForMetric += "}"
	s := strings.Join([]string{`&RuleHitsCounter{`,
		`Id:` + strings.Replace(this.Id.String(), "RuleHitsId", "RuleHitsId", 1) + `,`,
		`Metric:` + repeatedStringForMetric + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityEventsId) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SecurityEventsId{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`AppType:` + fmt.Sprintf("%v", this.AppType) + `,`,
		`VirtualHost:` + fmt.Sprintf("%v", this.VirtualHost) + `,`,
		`Site:` + fmt.Sprintf("%v", this.Site) + `,`,
		`Service:` + fmt.Sprintf("%v", this.Service) + `,`,
		`Instance:` + fmt.Sprintf("%v", this.Instance) + `,`,
		`WafInstanceId:` + fmt.Sprintf("%v", this.WafInstanceId) + `,`,
		`WafMode:` + fmt.Sprintf("%v", this.WafMode) + `,`,
		`BotType:` + fmt.Sprintf("%v", this.BotType) + `,`,
		`BotName:` + fmt.Sprintf("%v", this.BotName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityEventsCounter) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMetric := "[]*MetricValue{"
	for _, f := range this.Metric {
		repeatedStringForMetric += strings.Replace(f.String(), "MetricValue", "MetricValue", 1) + ","
	}
	repeatedStringForMetric += "}"
	s := strings.Join([]string{`&SecurityEventsCounter{`,
		`Id:` + strings.Replace(this.Id.String(), "SecurityEventsId", "SecurityEventsId", 1) + `,`,
		`Metric:` + repeatedStringForMetric + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityEventAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SecurityEventAggregation{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Step:` + fmt.Sprintf("%v", this.Step) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AppProfile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppProfile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppProfile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType == 0 {
				var v LanguageType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= LanguageType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Language = append(m.Language, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Language) == 0 {
					m.Language = make([]LanguageType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v LanguageType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= LanguageType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Language = append(m.Language, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
		case 3:
			if wireType == 0 {
				var v ContentManagementSystemType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ContentManagementSystemType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cms = append(m.Cms, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Cms) == 0 {
					m.Cms = make([]ContentManagementSystemType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ContentManagementSystemType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ContentManagementSystemType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cms = append(m.Cms, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cms", wireType)
			}
		case 4:
			if wireType == 0 {
				var v WebServerType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= WebServerType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Webserver = append(m.Webserver, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Webserver) == 0 {
					m.Webserver = make([]WebServerType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v WebServerType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= WebServerType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Webserver = append(m.Webserver, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Webserver", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DisabledDetectionTags) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DisabledDetectionTags: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DisabledDetectionTags: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v DetectionTagType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= DetectionTagType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DetectionTagType = append(m.DetectionTagType, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.DetectionTagType) == 0 {
					m.DetectionTagType = make([]DetectionTagType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v DetectionTagType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= DetectionTagType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DetectionTagType = append(m.DetectionTagType, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectionTagType", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppProfile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppProfile == nil {
				m.AppProfile = &AppProfile{}
			}
			if err := m.AppProfile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= schema.WafModeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisabledDetectionTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DisabledDetectionTags == nil {
				m.DisabledDetectionTags = &DisabledDetectionTags{}
			}
			if err := m.DisabledDetectionTags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppProfile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppProfile == nil {
				m.AppProfile = &AppProfile{}
			}
			if err := m.AppProfile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= schema.WafModeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisabledDetectionTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DisabledDetectionTags == nil {
				m.DisabledDetectionTags = &DisabledDetectionTags{}
			}
			if err := m.DisabledDetectionTags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppProfile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppProfile == nil {
				m.AppProfile = &AppProfile{}
			}
			if err := m.AppProfile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= schema.WafModeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisabledDetectionTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DisabledDetectionTags == nil {
				m.DisabledDetectionTags = &DisabledDetectionTags{}
			}
			if err := m.DisabledDetectionTags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppProfile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AppProfile == nil {
				m.AppProfile = &AppProfile{}
			}
			if err := m.AppProfile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= schema.WafModeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisabledDetectionTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DisabledDetectionTags == nil {
				m.DisabledDetectionTags = &DisabledDetectionTags{}
			}
			if err := m.DisabledDetectionTags.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricLabelFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricLabelFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricLabelFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			m.Label = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Label |= MetricLabel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= MetricLabelOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Timestamp = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuleHitsId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuleHitsId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuleHitsId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualHost", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualHost = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafInstanceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WafInstanceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleSeverity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleSeverity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BotType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BotName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuleHitsCounter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuleHitsCounter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuleHitsCounter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &RuleHitsId{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metric = append(m.Metric, &MetricValue{})
			if err := m.Metric[len(m.Metric)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityEventsId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityEventsId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityEventsId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualHost", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualHost = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Instance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafInstanceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WafInstanceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WafMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BotType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BotName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityEventsCounter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityEventsCounter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityEventsCounter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &SecurityEventsId{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metric = append(m.Metric, &MetricValue{})
			if err := m.Metric[len(m.Metric)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityEventAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityEventAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityEventAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Step = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
