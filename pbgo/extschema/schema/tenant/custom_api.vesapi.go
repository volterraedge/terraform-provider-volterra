// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package tenant

import (
	bytes "bytes"
	"context"
	"fmt"
	io "io"
	"net/http"
	"strings"

	"github.com/gogo/protobuf/proto"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	google_api "google.golang.org/genproto/googleapis/api/httpbody"
	"google.golang.org/grpc"

	"gopkg.volterra.us/stdlib/client"
	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/errors"
	"gopkg.volterra.us/stdlib/server"
	"gopkg.volterra.us/stdlib/svcfw"

	ves_io_schema_views_tenant_configuration "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/tenant_configuration"
)

var (
	_ = fmt.Sprintf("dummy for fmt import use")
)

// Create CustomAPI GRPC Client satisfying server.CustomClient
type CustomAPIGrpcClient struct {
	conn       *grpc.ClientConn
	grpcClient CustomAPIClient
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error)
}

func (c *CustomAPIGrpcClient) doRPCAssignDomainOwner(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &AssignDomainOwnerRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.AssignDomainOwnerRequest", yamlReq)
	}
	rsp, err := c.grpcClient.AssignDomainOwner(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCCreateDebugUser(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &CreateDebugUserRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.CreateDebugUserRequest", yamlReq)
	}
	rsp, err := c.grpcClient.CreateDebugUser(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCDeleteDebugUser(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty", yamlReq)
	}
	rsp, err := c.grpcClient.DeleteDebugUser(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCDeleteImage(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty", yamlReq)
	}
	rsp, err := c.grpcClient.DeleteImage(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCDeleteTenant(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &DeleteTenantRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.DeleteTenantRequest", yamlReq)
	}
	rsp, err := c.grpcClient.DeleteTenant(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCDisableTenantLevelOTP(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty", yamlReq)
	}
	rsp, err := c.grpcClient.DisableTenantLevelOTP(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCEnableTenantLevelOTP(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty", yamlReq)
	}
	rsp, err := c.grpcClient.EnableTenantLevelOTP(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCGetDebugUser(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty", yamlReq)
	}
	rsp, err := c.grpcClient.GetDebugUser(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCGetFavIcon(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty", yamlReq)
	}
	rsp, err := c.grpcClient.GetFavIcon(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCGetIDMSettings(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty", yamlReq)
	}
	rsp, err := c.grpcClient.GetIDMSettings(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCGetImage(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty", yamlReq)
	}
	rsp, err := c.grpcClient.GetImage(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCGetLastLoginMap(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty", yamlReq)
	}
	rsp, err := c.grpcClient.GetLastLoginMap(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCGetLoginEvents(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetLoginEventsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.GetLoginEventsRequest", yamlReq)
	}
	rsp, err := c.grpcClient.GetLoginEvents(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCGetLoginEventsInTimeFrame(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetLoginEventsInTimeFrameRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.GetLoginEventsInTimeFrameRequest", yamlReq)
	}
	rsp, err := c.grpcClient.GetLoginEventsInTimeFrame(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCGetLogo(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty", yamlReq)
	}
	rsp, err := c.grpcClient.GetLogo(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCGetPasswordPolicy(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetPasswordPolicyRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.GetPasswordPolicyRequest", yamlReq)
	}
	rsp, err := c.grpcClient.GetPasswordPolicy(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCGetSupportInfo(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty", yamlReq)
	}
	rsp, err := c.grpcClient.GetSupportInfo(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCGetTenantEscalationDoc(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty", yamlReq)
	}
	rsp, err := c.grpcClient.GetTenantEscalationDoc(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCGetTenantSettings(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty", yamlReq)
	}
	rsp, err := c.grpcClient.GetTenantSettings(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCListInactiveUsers(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty", yamlReq)
	}
	rsp, err := c.grpcClient.ListInactiveUsers(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCLookupCname(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &LookupCnameRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.LookupCnameRequest", yamlReq)
	}
	rsp, err := c.grpcClient.LookupCname(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCSetBillingInfo(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SetBillingInfoRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.SetBillingInfoRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SetBillingInfo(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCUnassignDomainOwner(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &UnassignDomainOwnerRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.UnassignDomainOwnerRequest", yamlReq)
	}
	rsp, err := c.grpcClient.UnassignDomainOwner(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCUpdateIDMSettings(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &ves_io_schema_views_tenant_configuration.GlobalSpecType{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.tenant_configuration.GlobalSpecType", yamlReq)
	}
	rsp, err := c.grpcClient.UpdateIDMSettings(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCUpdateImage(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &UpdateImageRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.UpdateImageRequest", yamlReq)
	}
	rsp, err := c.grpcClient.UpdateImage(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCUpdateTenantSettings(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &UpdateTenantSettingsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.UpdateTenantSettingsRequest", yamlReq)
	}
	rsp, err := c.grpcClient.UpdateTenantSettings(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	if cco.YAMLReq == "" {
		return nil, fmt.Errorf("Error, empty request body")
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := rpcFn(ctx, cco.YAMLReq, cco.GrpcCallOpts...)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using GRPC")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func NewCustomAPIGrpcClient(cc *grpc.ClientConn) server.CustomClient {
	ccl := &CustomAPIGrpcClient{
		conn:       cc,
		grpcClient: NewCustomAPIClient(cc),
	}
	rpcFns := make(map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error))
	rpcFns["AssignDomainOwner"] = ccl.doRPCAssignDomainOwner

	rpcFns["CreateDebugUser"] = ccl.doRPCCreateDebugUser

	rpcFns["DeleteDebugUser"] = ccl.doRPCDeleteDebugUser

	rpcFns["DeleteImage"] = ccl.doRPCDeleteImage

	rpcFns["DeleteTenant"] = ccl.doRPCDeleteTenant

	rpcFns["DisableTenantLevelOTP"] = ccl.doRPCDisableTenantLevelOTP

	rpcFns["EnableTenantLevelOTP"] = ccl.doRPCEnableTenantLevelOTP

	rpcFns["GetDebugUser"] = ccl.doRPCGetDebugUser

	rpcFns["GetFavIcon"] = ccl.doRPCGetFavIcon

	rpcFns["GetIDMSettings"] = ccl.doRPCGetIDMSettings

	rpcFns["GetImage"] = ccl.doRPCGetImage

	rpcFns["GetLastLoginMap"] = ccl.doRPCGetLastLoginMap

	rpcFns["GetLoginEvents"] = ccl.doRPCGetLoginEvents

	rpcFns["GetLoginEventsInTimeFrame"] = ccl.doRPCGetLoginEventsInTimeFrame

	rpcFns["GetLogo"] = ccl.doRPCGetLogo

	rpcFns["GetPasswordPolicy"] = ccl.doRPCGetPasswordPolicy

	rpcFns["GetSupportInfo"] = ccl.doRPCGetSupportInfo

	rpcFns["GetTenantEscalationDoc"] = ccl.doRPCGetTenantEscalationDoc

	rpcFns["GetTenantSettings"] = ccl.doRPCGetTenantSettings

	rpcFns["ListInactiveUsers"] = ccl.doRPCListInactiveUsers

	rpcFns["LookupCname"] = ccl.doRPCLookupCname

	rpcFns["SetBillingInfo"] = ccl.doRPCSetBillingInfo

	rpcFns["UnassignDomainOwner"] = ccl.doRPCUnassignDomainOwner

	rpcFns["UpdateIDMSettings"] = ccl.doRPCUpdateIDMSettings

	rpcFns["UpdateImage"] = ccl.doRPCUpdateImage

	rpcFns["UpdateTenantSettings"] = ccl.doRPCUpdateTenantSettings

	ccl.rpcFns = rpcFns

	return ccl
}

// Create CustomAPI REST Client satisfying server.CustomClient
type CustomAPIRestClient struct {
	baseURL string
	client  http.Client
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error)
}

func (c *CustomAPIRestClient) doRPCAssignDomainOwner(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &AssignDomainOwnerRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.AssignDomainOwnerRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("email", fmt.Sprintf("%v", req.Email))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &Empty{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.tenant.Empty", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCCreateDebugUser(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &CreateDebugUserRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.CreateDebugUserRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		for _, item := range req.NsRoles {
			q.Add("ns_roles", fmt.Sprintf("%v", item))
		}

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &Empty{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.tenant.Empty", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCDeleteDebugUser(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &Empty{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.tenant.Empty", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCDeleteImage(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &Empty{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.tenant.Empty", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCDeleteTenant(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &DeleteTenantRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.DeleteTenantRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("email", fmt.Sprintf("%v", req.Email))
		q.Add("feedback", fmt.Sprintf("%v", req.Feedback))
		q.Add("name", fmt.Sprintf("%v", req.Name))
		q.Add("reason", fmt.Sprintf("%v", req.Reason))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &StatusResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.tenant.StatusResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCDisableTenantLevelOTP(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &Empty{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.tenant.Empty", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCEnableTenantLevelOTP(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &Empty{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.tenant.Empty", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCGetDebugUser(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &DebugUser{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.tenant.DebugUser", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCGetFavIcon(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &google_api.HttpBody{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		// server strips HTTP Body proto message and sends only data, re-build it here
		pbRsp.ContentType = rsp.Header.Get("Content-Type")
		pbRsp.Data = body

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCGetIDMSettings(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &ves_io_schema_views_tenant_configuration.GlobalSpecType{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.views.tenant_configuration.GlobalSpecType", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCGetImage(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &google_api.HttpBody{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		// server strips HTTP Body proto message and sends only data, re-build it here
		pbRsp.ContentType = rsp.Header.Get("Content-Type")
		pbRsp.Data = body

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCGetLastLoginMap(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LastLoginMap{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.tenant.LastLoginMap", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCGetLoginEvents(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetLoginEventsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.GetLoginEventsRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("first", fmt.Sprintf("%v", req.First))
		q.Add("max", fmt.Sprintf("%v", req.Max))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LoginEventsMap{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.tenant.LoginEventsMap", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCGetLoginEventsInTimeFrame(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetLoginEventsInTimeFrameRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.GetLoginEventsInTimeFrameRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("end", fmt.Sprintf("%v", req.End))
		q.Add("first", fmt.Sprintf("%v", req.First))
		q.Add("max", fmt.Sprintf("%v", req.Max))
		q.Add("start", fmt.Sprintf("%v", req.Start))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LoginEventsMap{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.tenant.LoginEventsMap", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCGetLogo(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &google_api.HttpBody{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		// server strips HTTP Body proto message and sends only data, re-build it here
		pbRsp.ContentType = rsp.Header.Get("Content-Type")
		pbRsp.Data = body

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCGetPasswordPolicy(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetPasswordPolicyRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.GetPasswordPolicyRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("realm_id", fmt.Sprintf("%v", req.RealmId))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &PasswordPolicyPublicAccess{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.tenant.PasswordPolicyPublicAccess", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCGetSupportInfo(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SupportInfo{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.tenant.SupportInfo", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCGetTenantEscalationDoc(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &google_api.HttpBody{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		// server strips HTTP Body proto message and sends only data, re-build it here
		pbRsp.ContentType = rsp.Header.Get("Content-Type")
		pbRsp.Data = body

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCGetTenantSettings(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &TenantSettingsResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.tenant.TenantSettingsResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCListInactiveUsers(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.Empty: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &UserList{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.tenant.UserList", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCLookupCname(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &LookupCnameRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.LookupCnameRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("cname", fmt.Sprintf("%v", req.Cname))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &StatusResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.tenant.StatusResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCSetBillingInfo(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SetBillingInfoRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.SetBillingInfoRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("company_contact", fmt.Sprintf("%v", req.CompanyContact))
		q.Add("company_name", fmt.Sprintf("%v", req.CompanyName))
		q.Add("contact_number", fmt.Sprintf("%v", req.ContactNumber))
		q.Add("customer_contact", fmt.Sprintf("%v", req.CustomerContact))
		q.Add("first_name", fmt.Sprintf("%v", req.FirstName))
		q.Add("last_name", fmt.Sprintf("%v", req.LastName))
		q.Add("locale", fmt.Sprintf("%v", req.Locale))
		q.Add("payment_address", fmt.Sprintf("%v", req.PaymentAddress))
		q.Add("payment_provider_token", fmt.Sprintf("%v", req.PaymentProviderToken))
		q.Add("tos_accepted", fmt.Sprintf("%v", req.TosAccepted))
		q.Add("tos_accepted_at", fmt.Sprintf("%v", req.TosAcceptedAt))
		q.Add("tos_version", fmt.Sprintf("%v", req.TosVersion))
		q.Add("usage_plan", fmt.Sprintf("%v", req.UsagePlan))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &StatusResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.tenant.StatusResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCUnassignDomainOwner(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &UnassignDomainOwnerRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.UnassignDomainOwnerRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("email", fmt.Sprintf("%v", req.Email))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &Empty{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.tenant.Empty", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCUpdateIDMSettings(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &ves_io_schema_views_tenant_configuration.GlobalSpecType{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.views.tenant_configuration.GlobalSpecType: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("basic_configuration", fmt.Sprintf("%v", req.BasicConfiguration))
		q.Add("brute_force_detection_settings", fmt.Sprintf("%v", req.BruteForceDetectionSettings))
		q.Add("password_policy", fmt.Sprintf("%v", req.PasswordPolicy))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &Empty{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.tenant.Empty", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCUpdateImage(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &UpdateImageRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.UpdateImageRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("content_type", fmt.Sprintf("%v", req.ContentType))
		q.Add("image", fmt.Sprintf("%v", req.Image))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &Empty{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.tenant.Empty", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCUpdateTenantSettings(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &UpdateTenantSettingsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.tenant.UpdateTenantSettingsRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("max_credentials_expiry", fmt.Sprintf("%v", req.MaxCredentialsExpiry))
		q.Add("otp_enabled", fmt.Sprintf("%v", req.OtpEnabled))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &UpdateTenantSettingsResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.tenant.UpdateTenantSettingsResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	rsp, err := rpcFn(ctx, cco)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using Rest")
	}
	return rsp, nil
}

func NewCustomAPIRestClient(baseURL string, hc http.Client) server.CustomClient {
	ccl := &CustomAPIRestClient{
		baseURL: baseURL,
		client:  hc,
	}

	rpcFns := make(map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error))
	rpcFns["AssignDomainOwner"] = ccl.doRPCAssignDomainOwner

	rpcFns["CreateDebugUser"] = ccl.doRPCCreateDebugUser

	rpcFns["DeleteDebugUser"] = ccl.doRPCDeleteDebugUser

	rpcFns["DeleteImage"] = ccl.doRPCDeleteImage

	rpcFns["DeleteTenant"] = ccl.doRPCDeleteTenant

	rpcFns["DisableTenantLevelOTP"] = ccl.doRPCDisableTenantLevelOTP

	rpcFns["EnableTenantLevelOTP"] = ccl.doRPCEnableTenantLevelOTP

	rpcFns["GetDebugUser"] = ccl.doRPCGetDebugUser

	rpcFns["GetFavIcon"] = ccl.doRPCGetFavIcon

	rpcFns["GetIDMSettings"] = ccl.doRPCGetIDMSettings

	rpcFns["GetImage"] = ccl.doRPCGetImage

	rpcFns["GetLastLoginMap"] = ccl.doRPCGetLastLoginMap

	rpcFns["GetLoginEvents"] = ccl.doRPCGetLoginEvents

	rpcFns["GetLoginEventsInTimeFrame"] = ccl.doRPCGetLoginEventsInTimeFrame

	rpcFns["GetLogo"] = ccl.doRPCGetLogo

	rpcFns["GetPasswordPolicy"] = ccl.doRPCGetPasswordPolicy

	rpcFns["GetSupportInfo"] = ccl.doRPCGetSupportInfo

	rpcFns["GetTenantEscalationDoc"] = ccl.doRPCGetTenantEscalationDoc

	rpcFns["GetTenantSettings"] = ccl.doRPCGetTenantSettings

	rpcFns["ListInactiveUsers"] = ccl.doRPCListInactiveUsers

	rpcFns["LookupCname"] = ccl.doRPCLookupCname

	rpcFns["SetBillingInfo"] = ccl.doRPCSetBillingInfo

	rpcFns["UnassignDomainOwner"] = ccl.doRPCUnassignDomainOwner

	rpcFns["UpdateIDMSettings"] = ccl.doRPCUpdateIDMSettings

	rpcFns["UpdateImage"] = ccl.doRPCUpdateImage

	rpcFns["UpdateTenantSettings"] = ccl.doRPCUpdateTenantSettings

	ccl.rpcFns = rpcFns

	return ccl
}

// Create customAPIInprocClient

// INPROC Client (satisfying CustomAPIClient interface)
type customAPIInprocClient struct {
	CustomAPIServer
}

func (c *customAPIInprocClient) AssignDomainOwner(ctx context.Context, in *AssignDomainOwnerRequest, opts ...grpc.CallOption) (*Empty, error) {
	return c.CustomAPIServer.AssignDomainOwner(ctx, in)
}
func (c *customAPIInprocClient) CreateDebugUser(ctx context.Context, in *CreateDebugUserRequest, opts ...grpc.CallOption) (*Empty, error) {
	return c.CustomAPIServer.CreateDebugUser(ctx, in)
}
func (c *customAPIInprocClient) DeleteDebugUser(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	return c.CustomAPIServer.DeleteDebugUser(ctx, in)
}
func (c *customAPIInprocClient) DeleteImage(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	return c.CustomAPIServer.DeleteImage(ctx, in)
}
func (c *customAPIInprocClient) DeleteTenant(ctx context.Context, in *DeleteTenantRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	return c.CustomAPIServer.DeleteTenant(ctx, in)
}
func (c *customAPIInprocClient) DisableTenantLevelOTP(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	return c.CustomAPIServer.DisableTenantLevelOTP(ctx, in)
}
func (c *customAPIInprocClient) EnableTenantLevelOTP(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	return c.CustomAPIServer.EnableTenantLevelOTP(ctx, in)
}
func (c *customAPIInprocClient) GetDebugUser(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DebugUser, error) {
	return c.CustomAPIServer.GetDebugUser(ctx, in)
}
func (c *customAPIInprocClient) GetFavIcon(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*google_api.HttpBody, error) {
	return c.CustomAPIServer.GetFavIcon(ctx, in)
}
func (c *customAPIInprocClient) GetIDMSettings(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ves_io_schema_views_tenant_configuration.GlobalSpecType, error) {
	return c.CustomAPIServer.GetIDMSettings(ctx, in)
}
func (c *customAPIInprocClient) GetImage(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*google_api.HttpBody, error) {
	return c.CustomAPIServer.GetImage(ctx, in)
}
func (c *customAPIInprocClient) GetLastLoginMap(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*LastLoginMap, error) {
	return c.CustomAPIServer.GetLastLoginMap(ctx, in)
}
func (c *customAPIInprocClient) GetLoginEvents(ctx context.Context, in *GetLoginEventsRequest, opts ...grpc.CallOption) (*LoginEventsMap, error) {
	return c.CustomAPIServer.GetLoginEvents(ctx, in)
}
func (c *customAPIInprocClient) GetLoginEventsInTimeFrame(ctx context.Context, in *GetLoginEventsInTimeFrameRequest, opts ...grpc.CallOption) (*LoginEventsMap, error) {
	return c.CustomAPIServer.GetLoginEventsInTimeFrame(ctx, in)
}
func (c *customAPIInprocClient) GetLogo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*google_api.HttpBody, error) {
	return c.CustomAPIServer.GetLogo(ctx, in)
}
func (c *customAPIInprocClient) GetPasswordPolicy(ctx context.Context, in *GetPasswordPolicyRequest, opts ...grpc.CallOption) (*PasswordPolicyPublicAccess, error) {
	return c.CustomAPIServer.GetPasswordPolicy(ctx, in)
}
func (c *customAPIInprocClient) GetSupportInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*SupportInfo, error) {
	return c.CustomAPIServer.GetSupportInfo(ctx, in)
}
func (c *customAPIInprocClient) GetTenantEscalationDoc(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*google_api.HttpBody, error) {
	return c.CustomAPIServer.GetTenantEscalationDoc(ctx, in)
}
func (c *customAPIInprocClient) GetTenantSettings(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*TenantSettingsResponse, error) {
	return c.CustomAPIServer.GetTenantSettings(ctx, in)
}
func (c *customAPIInprocClient) ListInactiveUsers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*UserList, error) {
	return c.CustomAPIServer.ListInactiveUsers(ctx, in)
}
func (c *customAPIInprocClient) LookupCname(ctx context.Context, in *LookupCnameRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	return c.CustomAPIServer.LookupCname(ctx, in)
}
func (c *customAPIInprocClient) SetBillingInfo(ctx context.Context, in *SetBillingInfoRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	return c.CustomAPIServer.SetBillingInfo(ctx, in)
}
func (c *customAPIInprocClient) UnassignDomainOwner(ctx context.Context, in *UnassignDomainOwnerRequest, opts ...grpc.CallOption) (*Empty, error) {
	return c.CustomAPIServer.UnassignDomainOwner(ctx, in)
}
func (c *customAPIInprocClient) UpdateIDMSettings(ctx context.Context, in *ves_io_schema_views_tenant_configuration.GlobalSpecType, opts ...grpc.CallOption) (*Empty, error) {
	return c.CustomAPIServer.UpdateIDMSettings(ctx, in)
}
func (c *customAPIInprocClient) UpdateImage(ctx context.Context, in *UpdateImageRequest, opts ...grpc.CallOption) (*Empty, error) {
	return c.CustomAPIServer.UpdateImage(ctx, in)
}
func (c *customAPIInprocClient) UpdateTenantSettings(ctx context.Context, in *UpdateTenantSettingsRequest, opts ...grpc.CallOption) (*UpdateTenantSettingsResponse, error) {
	return c.CustomAPIServer.UpdateTenantSettings(ctx, in)
}

func NewCustomAPIInprocClient(svc svcfw.Service) CustomAPIClient {
	return &customAPIInprocClient{CustomAPIServer: NewCustomAPIServer(svc)}
}

// RegisterGwCustomAPIHandler registers with grpc-gw with an inproc-client backing so that
// rest to grpc happens without a grpc.Dial (thus avoiding additional certs for mTLS)
func RegisterGwCustomAPIHandler(ctx context.Context, mux *runtime.ServeMux, svc interface{}) error {
	s, ok := svc.(svcfw.Service)
	if !ok {
		return fmt.Errorf("svc is not svcfw.Service")
	}
	return RegisterCustomAPIHandlerClient(ctx, mux, NewCustomAPIInprocClient(s))
}

// Create customAPISrv

// SERVER (satisfying CustomAPIServer interface)
type customAPISrv struct {
	svc svcfw.Service
}

func (s *customAPISrv) AssignDomainOwner(ctx context.Context, in *AssignDomainOwnerRequest) (*Empty, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *Empty
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.AssignDomainOwnerRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.AssignDomainOwner' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.AssignDomainOwner"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.AssignDomainOwner(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.tenant.Empty", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) CreateDebugUser(ctx context.Context, in *CreateDebugUserRequest) (*Empty, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *Empty
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.CreateDebugUserRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.CreateDebugUser' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.CreateDebugUser"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.CreateDebugUser(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.tenant.Empty", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) DeleteDebugUser(ctx context.Context, in *Empty) (*Empty, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *Empty
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.Empty", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.DeleteDebugUser' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.DeleteDebugUser"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.DeleteDebugUser(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.tenant.Empty", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) DeleteImage(ctx context.Context, in *Empty) (*Empty, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *Empty
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.Empty", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.DeleteImage' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.DeleteImage"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.DeleteImage(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.tenant.Empty", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) DeleteTenant(ctx context.Context, in *DeleteTenantRequest) (*StatusResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *StatusResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.DeleteTenantRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.DeleteTenant' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.DeleteTenant"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.DeleteTenant(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.tenant.StatusResponse", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) DisableTenantLevelOTP(ctx context.Context, in *Empty) (*Empty, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *Empty
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.Empty", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.DisableTenantLevelOTP' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.DisableTenantLevelOTP"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.DisableTenantLevelOTP(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.tenant.Empty", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) EnableTenantLevelOTP(ctx context.Context, in *Empty) (*Empty, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *Empty
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.Empty", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.EnableTenantLevelOTP' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.EnableTenantLevelOTP"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.EnableTenantLevelOTP(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.tenant.Empty", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) GetDebugUser(ctx context.Context, in *Empty) (*DebugUser, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *DebugUser
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.Empty", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.GetDebugUser' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.GetDebugUser"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetDebugUser(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.tenant.DebugUser", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) GetFavIcon(ctx context.Context, in *Empty) (*google_api.HttpBody, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *google_api.HttpBody
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.Empty", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.GetFavIcon' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.GetFavIcon"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetFavIcon(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "google.api.HttpBody", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) GetIDMSettings(ctx context.Context, in *Empty) (*ves_io_schema_views_tenant_configuration.GlobalSpecType, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *ves_io_schema_views_tenant_configuration.GlobalSpecType
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.Empty", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.GetIDMSettings' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.GetIDMSettings"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetIDMSettings(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.views.tenant_configuration.GlobalSpecType", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) GetImage(ctx context.Context, in *Empty) (*google_api.HttpBody, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *google_api.HttpBody
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.Empty", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.GetImage' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.GetImage"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetImage(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "google.api.HttpBody", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) GetLastLoginMap(ctx context.Context, in *Empty) (*LastLoginMap, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *LastLoginMap
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.Empty", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.GetLastLoginMap' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.GetLastLoginMap"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetLastLoginMap(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.tenant.LastLoginMap", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) GetLoginEvents(ctx context.Context, in *GetLoginEventsRequest) (*LoginEventsMap, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *LoginEventsMap
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.GetLoginEventsRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.GetLoginEvents' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.GetLoginEvents"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetLoginEvents(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.tenant.LoginEventsMap", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) GetLoginEventsInTimeFrame(ctx context.Context, in *GetLoginEventsInTimeFrameRequest) (*LoginEventsMap, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *LoginEventsMap
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.GetLoginEventsInTimeFrameRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.GetLoginEventsInTimeFrame' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.GetLoginEventsInTimeFrame"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetLoginEventsInTimeFrame(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.tenant.LoginEventsMap", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) GetLogo(ctx context.Context, in *Empty) (*google_api.HttpBody, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *google_api.HttpBody
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.Empty", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.GetLogo' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.GetLogo"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetLogo(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "google.api.HttpBody", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) GetPasswordPolicy(ctx context.Context, in *GetPasswordPolicyRequest) (*PasswordPolicyPublicAccess, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *PasswordPolicyPublicAccess
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.GetPasswordPolicyRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.GetPasswordPolicy' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.GetPasswordPolicy"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetPasswordPolicy(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.tenant.PasswordPolicyPublicAccess", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) GetSupportInfo(ctx context.Context, in *Empty) (*SupportInfo, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *SupportInfo
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.Empty", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.GetSupportInfo' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.GetSupportInfo"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetSupportInfo(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.tenant.SupportInfo", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) GetTenantEscalationDoc(ctx context.Context, in *Empty) (*google_api.HttpBody, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *google_api.HttpBody
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.Empty", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.GetTenantEscalationDoc' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.GetTenantEscalationDoc"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetTenantEscalationDoc(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "google.api.HttpBody", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) GetTenantSettings(ctx context.Context, in *Empty) (*TenantSettingsResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *TenantSettingsResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.Empty", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.GetTenantSettings' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.GetTenantSettings"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetTenantSettings(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.tenant.TenantSettingsResponse", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) ListInactiveUsers(ctx context.Context, in *Empty) (*UserList, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *UserList
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.Empty", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.ListInactiveUsers' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.ListInactiveUsers"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.ListInactiveUsers(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.tenant.UserList", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) LookupCname(ctx context.Context, in *LookupCnameRequest) (*StatusResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *StatusResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.LookupCnameRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.LookupCname' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.LookupCname"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.LookupCname(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.tenant.StatusResponse", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) SetBillingInfo(ctx context.Context, in *SetBillingInfoRequest) (*StatusResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *StatusResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.SetBillingInfoRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.SetBillingInfo' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.SetBillingInfo"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SetBillingInfo(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.tenant.StatusResponse", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) UnassignDomainOwner(ctx context.Context, in *UnassignDomainOwnerRequest) (*Empty, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *Empty
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.UnassignDomainOwnerRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.UnassignDomainOwner' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.UnassignDomainOwner"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.UnassignDomainOwner(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.tenant.Empty", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) UpdateIDMSettings(ctx context.Context, in *ves_io_schema_views_tenant_configuration.GlobalSpecType) (*Empty, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *Empty
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.views.tenant_configuration.GlobalSpecType", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.UpdateIDMSettings' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.UpdateIDMSettings"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.UpdateIDMSettings(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.tenant.Empty", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) UpdateImage(ctx context.Context, in *UpdateImageRequest) (*Empty, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *Empty
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.UpdateImageRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.UpdateImage' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.UpdateImage"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.UpdateImage(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.tenant.Empty", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) UpdateTenantSettings(ctx context.Context, in *UpdateTenantSettingsRequest) (*UpdateTenantSettingsResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.tenant.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *UpdateTenantSettingsResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.tenant.UpdateTenantSettingsRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.UpdateTenantSettings' operation on 'tenant'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.tenant.CustomAPI.UpdateTenantSettings"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.UpdateTenantSettings(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.tenant.UpdateTenantSettingsResponse", rsp)...)

	return rsp, nil
}

func NewCustomAPIServer(svc svcfw.Service) CustomAPIServer {
	return &customAPISrv{svc: svc}
}

var CustomAPISwaggerJSON string = `{
    "swagger": "2.0",
    "info": {
        "title": "Tenant",
        "description": "Package for working with Tenant representation.",
        "version": "version not set"
    },
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "tags": [],
    "paths": {
        "/no_auth/cname/lookup": {
            "get": {
                "summary": "Lookup cname",
                "description": "Checks if a cname is available.",
                "operationId": "ves.io.schema.tenant.CustomAPI.LookupCname",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/tenantStatusResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "cname",
                        "description": "x-example: \"domain1\"\nCname to look-uo",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "x-displayname": "Cname"
                    },
                    {
                        "name": "namespace",
                        "description": "x-example: \"system\"\nNamespace to query",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "x-displayname": "Namespace"
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-lookupcname"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.LookupCname"
            },
            "x-displayname": "Tenant Custom API",
            "x-ves-proto-service": "ves.io.schema.tenant.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/no_auth/tenant/idm/settings/password_policy": {
            "get": {
                "summary": "GetPasswordPolicy",
                "description": "GetPasswordPolicy returns password policy for tenant.",
                "operationId": "ves.io.schema.tenant.CustomAPI.GetPasswordPolicy",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/tenantPasswordPolicyPublicAccess"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "realm_id",
                        "description": "x-example: \"3d05688b-f560-4f70-9af1-384a0ec0ff15\"\nuser's email",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "x-displayname": "Email"
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-getpasswordpolicy"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.GetPasswordPolicy"
            },
            "x-displayname": "Tenant Custom API",
            "x-ves-proto-service": "ves.io.schema.tenant.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/tenant/billing-info": {
            "put": {
                "summary": "Update billing plan for the tenant",
                "description": "Updates billing plan for the specific tenant.",
                "operationId": "ves.io.schema.tenant.CustomAPI.SetBillingInfo",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/tenantStatusResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/tenantSetBillingInfoRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-setbillinginfo"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.SetBillingInfo"
            },
            "x-displayname": "Tenant Custom API",
            "x-ves-proto-service": "ves.io.schema.tenant.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/tenant/debug/user": {
            "get": {
                "summary": "GetDebugUser",
                "description": "GetDebugUser returns information about tenant's debug user\nDeprecated: this and other debugUser RPCs are deprecated",
                "operationId": "ves.io.schema.tenant.CustomAPI.GetDebugUser",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/tenantDebugUser"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-getdebuguser"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.GetDebugUser"
            },
            "delete": {
                "summary": "DeleteDebugUser",
                "description": "DeleteDebugUser deletes tenant's debug user.\nDeprecated: this and other debugUser RPCs are deprecated",
                "operationId": "ves.io.schema.tenant.CustomAPI.DeleteDebugUser",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/schematenantEmpty"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-deletedebuguser"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.DeleteDebugUser"
            },
            "post": {
                "summary": "CreateDebugUser",
                "description": "CreateDebugUser creates tenant's debug user. Debug user can be disabled or deleter later.\nDeprecated: this and other debugUser RPCs are deprecated",
                "operationId": "ves.io.schema.tenant.CustomAPI.CreateDebugUser",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/schematenantEmpty"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/tenantCreateDebugUserRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-createdebuguser"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.CreateDebugUser"
            },
            "x-displayname": "Tenant Custom API",
            "x-ves-proto-service": "ves.io.schema.tenant.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/tenant/domain_owner/assign": {
            "post": {
                "summary": "Assign domain owner",
                "description": "Assign domain owner tries to assign domain owner to user in the request. It checks that requester is domain owner as well.\nIt implies such steps:\n1) mark user as domain owner\n2) if user is SSO\n - mark user as volterra managed\n - send update password email\n3) set admin roles in system, shared, * namespaces\nNOTE: previous roles (which was explicitly assigned to this user) will be deleted",
                "operationId": "ves.io.schema.tenant.CustomAPI.AssignDomainOwner",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/schematenantEmpty"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/tenantAssignDomainOwnerRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-assigndomainowner"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.AssignDomainOwner"
            },
            "x-displayname": "Tenant Custom API",
            "x-ves-proto-service": "ves.io.schema.tenant.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/tenant/domain_owner/unassign": {
            "post": {
                "summary": "Unassign domain owner",
                "description": "Unassign domain owner tries to remove domain owner privilege from user in the request.\nIt checks that requester is domain owner.\nIt implies such steps:\n1) remove domain owner boolean flag\n2) if tenant has SSO enabled:\n - mark user as SSO\n - delete password credential\n - delete OTP credential (if exists)\nNOTE: previously granted roles (including admin roles) will be retained",
                "operationId": "ves.io.schema.tenant.CustomAPI.UnassignDomainOwner",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/schematenantEmpty"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/tenantUnassignDomainOwnerRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-unassigndomainowner"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.UnassignDomainOwner"
            },
            "x-displayname": "Tenant Custom API",
            "x-ves-proto-service": "ves.io.schema.tenant.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/tenant/idm/events/last_login": {
            "get": {
                "summary": "GetLastLoginMap",
                "description": "GetLastLoginMap returns last login timestamp for each user within a tenant.",
                "operationId": "ves.io.schema.tenant.CustomAPI.GetLastLoginMap",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/tenantLastLoginMap"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-getlastloginmap"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.GetLastLoginMap"
            },
            "x-displayname": "Tenant Custom API",
            "x-ves-proto-service": "ves.io.schema.tenant.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/tenant/idm/events/login": {
            "get": {
                "summary": "GetLoginEvents",
                "description": "GetLoginEvents returns login events for specified in config period of time. It consider all users within current tenant.\nLogin events are extracted directly from IDM.",
                "operationId": "ves.io.schema.tenant.CustomAPI.GetLoginEvents",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/tenantLoginEventsMap"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "first",
                        "description": "x-example: \"100\"\nStart offset",
                        "in": "query",
                        "required": false,
                        "type": "integer",
                        "format": "int64",
                        "x-displayname": "First"
                    },
                    {
                        "name": "max",
                        "description": "x-example: \"25\"\nRecords per page",
                        "in": "query",
                        "required": false,
                        "type": "integer",
                        "format": "int64",
                        "x-displayname": "Max"
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-getloginevents"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.GetLoginEvents"
            },
            "x-displayname": "Tenant Custom API",
            "x-ves-proto-service": "ves.io.schema.tenant.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/tenant/idm/events/login_in_time": {
            "post": {
                "summary": "GetLoginEventsInTimeFrame",
                "description": "GetLoginEventsInTimeFrame returns login events for specified period of time. It consider all users specified by context tenant.",
                "operationId": "ves.io.schema.tenant.CustomAPI.GetLoginEventsInTimeFrame",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/tenantLoginEventsMap"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/tenantGetLoginEventsInTimeFrameRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-getlogineventsintimeframe"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.GetLoginEventsInTimeFrame"
            },
            "x-displayname": "Tenant Custom API",
            "x-ves-proto-service": "ves.io.schema.tenant.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/tenant/idm/settings": {
            "get": {
                "summary": "GetIDMSettings",
                "description": "GetIDMSettings returns IDM settings for tenant. IDM settings contains info like password policy,\nbrute-force detection policy, etc...",
                "operationId": "ves.io.schema.tenant.CustomAPI.GetIDMSettings",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/viewstenant_configurationGlobalSpecType"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-getidmsettings"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.GetIDMSettings"
            },
            "put": {
                "summary": "UpdateIDMSettings",
                "description": "UpdateIDMSettings allows to adjust IDM settings for tenant, like password policy, brute-force detection policy, etc...",
                "operationId": "ves.io.schema.tenant.CustomAPI.UpdateIDMSettings",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/schematenantEmpty"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/viewstenant_configurationGlobalSpecType"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-updateidmsettings"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.UpdateIDMSettings"
            },
            "x-displayname": "Tenant Custom API",
            "x-ves-proto-service": "ves.io.schema.tenant.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/tenant/idm/users/inactive": {
            "get": {
                "summary": "ListInactiveUsers",
                "description": "Returns list of users for which no login events was found for specified in config period of time.\nIt consider all users within current tenant.",
                "operationId": "ves.io.schema.tenant.CustomAPI.ListInactiveUsers",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/tenantUserList"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-listinactiveusers"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.ListInactiveUsers"
            },
            "x-displayname": "Tenant Custom API",
            "x-ves-proto-service": "ves.io.schema.tenant.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/tenant/lookup": {
            "get": {
                "summary": "Lookup cname",
                "description": "Checks if a cname is available.",
                "operationId": "ves.io.schema.tenant.CustomAPI.LookupCname",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/tenantStatusResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "cname",
                        "description": "x-example: \"domain1\"\nCname to look-uo",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "x-displayname": "Cname"
                    },
                    {
                        "name": "namespace",
                        "description": "x-example: \"system\"\nNamespace to query",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "x-displayname": "Namespace"
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-lookupcname"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.LookupCname"
            },
            "x-displayname": "Tenant Custom API",
            "x-ves-proto-service": "ves.io.schema.tenant.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/tenant/request-delete": {
            "post": {
                "summary": "Delete Tenant",
                "description": "Request to mark Tenant for deletion queue, after approve it will completely removed from the system.",
                "operationId": "ves.io.schema.tenant.CustomAPI.DeleteTenant",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/tenantStatusResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/tenantDeleteTenantRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-deletetenant"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.DeleteTenant"
            },
            "x-displayname": "Tenant Custom API",
            "x-ves-proto-service": "ves.io.schema.tenant.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/tenant/settings": {
            "get": {
                "summary": "Tenant Settings",
                "description": "Receive current tenant settings.",
                "operationId": "ves.io.schema.tenant.CustomAPI.GetTenantSettings",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/tenantTenantSettingsResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-gettenantsettings"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.GetTenantSettings"
            },
            "put": {
                "summary": "Tenant Settings",
                "description": "Tenant settings",
                "operationId": "ves.io.schema.tenant.CustomAPI.UpdateTenantSettings",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/tenantUpdateTenantSettingsResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/tenantUpdateTenantSettingsRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-updatetenantsettings"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.UpdateTenantSettings"
            },
            "x-displayname": "Tenant Custom API",
            "x-ves-proto-service": "ves.io.schema.tenant.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/tenant/settings/otp/disable": {
            "put": {
                "summary": "Disable tenant level OTP",
                "description": "Disable tenant level OTP disables OTP on tenant-level. After it's disabled it's up to user whether to enable OTP.",
                "operationId": "ves.io.schema.tenant.CustomAPI.DisableTenantLevelOTP",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/schematenantEmpty"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schematenantEmpty"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-disabletenantlevelotp"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.DisableTenantLevelOTP"
            },
            "x-displayname": "Tenant Custom API",
            "x-ves-proto-service": "ves.io.schema.tenant.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/tenant/settings/otp/enable": {
            "put": {
                "summary": "Enable tenant level OTP",
                "description": "Enable tenant level OTP enables OTP on tenant-level. It enforces each user within a tenant to enable OTP.",
                "operationId": "ves.io.schema.tenant.CustomAPI.EnableTenantLevelOTP",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/schematenantEmpty"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/schematenantEmpty"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-enabletenantlevelotp"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.EnableTenantLevelOTP"
            },
            "x-displayname": "Tenant Custom API",
            "x-ves-proto-service": "ves.io.schema.tenant.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/tenant/settings/tenant/favicon": {
            "get": {
                "summary": "Tenant favicon",
                "description": "Receive current tenant favicon.",
                "operationId": "ves.io.schema.tenant.CustomAPI.GetFavIcon",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/apiHttpBody"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-getfavicon"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.GetFavIcon"
            },
            "x-displayname": "Tenant Custom API",
            "x-ves-proto-service": "ves.io.schema.tenant.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/tenant/settings/tenant/image": {
            "get": {
                "summary": "Tenant profile image",
                "description": "Receive current tenant profile image.",
                "operationId": "ves.io.schema.tenant.CustomAPI.GetImage",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/apiHttpBody"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-getimage"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.GetImage"
            },
            "delete": {
                "summary": "Delete tenant profile image",
                "description": "Delete profile image for the tenant entity.",
                "operationId": "ves.io.schema.tenant.CustomAPI.DeleteImage",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/schematenantEmpty"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-deleteimage"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.DeleteImage"
            },
            "put": {
                "summary": "Update tenant profile image",
                "description": "Uploads new profile image for the tenant entity.",
                "operationId": "ves.io.schema.tenant.CustomAPI.UpdateImage",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/schematenantEmpty"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/tenantUpdateImageRequest"
                        }
                    }
                ],
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-updateimage"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.UpdateImage"
            },
            "x-displayname": "Tenant Custom API",
            "x-ves-proto-service": "ves.io.schema.tenant.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/tenant/settings/tenant/logo": {
            "get": {
                "summary": "Tenant logo",
                "description": "Receive current tenant logo.",
                "operationId": "ves.io.schema.tenant.CustomAPI.GetLogo",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/apiHttpBody"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-getlogo"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.GetLogo"
            },
            "x-displayname": "Tenant Custom API",
            "x-ves-proto-service": "ves.io.schema.tenant.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/tenant/support-info": {
            "get": {
                "summary": "Support Info",
                "description": "Receive support information for tenant",
                "operationId": "ves.io.schema.tenant.CustomAPI.GetSupportInfo",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/tenantSupportInfo"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-getsupportinfo"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.GetSupportInfo"
            },
            "x-displayname": "Tenant Custom API",
            "x-ves-proto-service": "ves.io.schema.tenant.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/tenant/tenant-escalation-doc": {
            "get": {
                "summary": "Tenant escalation document",
                "description": "Receive current tenant escalation document.",
                "operationId": "ves.io.schema.tenant.CustomAPI.GetTenantEscalationDoc",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/apiHttpBody"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://www.volterra.io/docs/reference/api-ref/ves-io-schema-tenant-customapi-gettenantescalationdoc"
                },
                "x-ves-proto-rpc": "ves.io.schema.tenant.CustomAPI.GetTenantEscalationDoc"
            },
            "x-displayname": "Tenant Custom API",
            "x-ves-proto-service": "ves.io.schema.tenant.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        }
    },
    "definitions": {
        "apiHttpBody": {
            "type": "object",
            "description": "Message that represents an arbitrary HTTP body. It should only be used for\npayload formats that can't be represented as JSON, such as raw binary or\nan HTML page.\n\n\nThis message can be used both in streaming and non-streaming API methods in\nthe request as well as the response.\n\nIt can be used as a top-level request field, which is convenient if one\nwants to extract parameters from either the URL or HTTP template into the\nrequest fields and also want access to the raw HTTP body.\n\nExample:\n\n    message GetResourceRequest {\n      // A unique request id.\n      string request_id = 1;\n\n      // The raw HTTP body is bound to this field.\n      google.api.HttpBody http_body = 2;\n    }\n\n    service ResourceService {\n      rpc GetResource(GetResourceRequest) returns (google.api.HttpBody);\n      rpc UpdateResource(google.api.HttpBody) returns\n      (google.protobuf.Empty);\n    }\n\nExample with streaming methods:\n\n    service CaldavService {\n      rpc GetCalendar(stream google.api.HttpBody)\n        returns (stream google.api.HttpBody);\n      rpc UpdateCalendar(stream google.api.HttpBody)\n        returns (stream google.api.HttpBody);\n    }\n\nUse of this type only changes how the request and response bodies are\nhandled, all other features will continue to work unchanged.",
            "properties": {
                "content_type": {
                    "type": "string",
                    "description": "The HTTP Content-Type header value specifying the content type of the body."
                },
                "data": {
                    "type": "string",
                    "description": "The HTTP request/response body as raw binary.",
                    "format": "byte"
                },
                "extensions": {
                    "type": "array",
                    "description": "Application specific response metadata. Must be set in the first response\nfor streaming APIs.",
                    "items": {
                        "$ref": "#/definitions/protobufAny"
                    }
                }
            }
        },
        "contactContactType": {
            "type": "string",
            "description": "Determines the contact type\n\nIndicates snail mail address (used for correspondence)\nIndicates billing address (this address will appear on invoices)\nIndicates contact used for a payment method (this address is used when charging a payment method)",
            "title": "Contact Type",
            "enum": [
                "MAILING",
                "BILLING",
                "PAYMENT"
            ],
            "default": "MAILING",
            "x-displayname": "Contact Type",
            "x-ves-proto-enum": "ves.io.schema.contact.ContactType"
        },
        "protobufAny": {
            "type": "object",
            "description": "-Any- contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := \u0026pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an -Any- value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field -@type- which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n-value- which holds the custom JSON in addition to the -@type-\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
            "properties": {
                "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n-path/google.protobuf.Duration-). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme -http-, -https-, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, -https- is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than -http-, -https- (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                    "type": "string",
                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                    "format": "byte"
                }
            }
        },
        "schemaNamespaceRoleType": {
            "type": "object",
            "description": "Allows linking namespaces and roles",
            "title": "Namespace role",
            "x-displayname": "Namespace Role",
            "x-ves-proto-message": "ves.io.schema.NamespaceRoleType",
            "properties": {
                "namespace": {
                    "type": "string",
                    "description": " Namespace the role applies to\n '*' value implies all namespaces\n\nExample: - \"ns1\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "Namespace",
                    "maxLength": 256,
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                },
                "role": {
                    "type": "string",
                    "description": " Users role for this namespace\n\nExample: - \"ves-io-monitor-role\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_len: 256\n  ves.io.schema.rules.string.ves_object_name: true\n",
                    "title": "Role",
                    "maxLength": 256,
                    "x-displayname": "Role",
                    "x-ves-example": "ves-io-monitor-role",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_len": "256",
                        "ves.io.schema.rules.string.ves_object_name": "true"
                    }
                }
            }
        },
        "schemacontactGlobalSpecType": {
            "type": "object",
            "description": "Instance of one single contact that can be used to communicate with customers.\nDepending on contact type we use these details to send general communication (regular, physical mail) or invoices.",
            "title": "Contact",
            "x-displayname": "Contact",
            "x-ves-proto-message": "ves.io.schema.contact.GlobalSpecType",
            "properties": {
                "address1": {
                    "type": "string",
                    "description": "\n\nExample: - \"1234 Main road\"-",
                    "title": "address1",
                    "x-displayname": "Address Line 1",
                    "x-ves-example": "1234 Main road"
                },
                "address2": {
                    "type": "string",
                    "description": "\n\nExample: - \"P.O BOX 56\"-",
                    "title": "address2",
                    "x-displayname": "Address Line 2",
                    "x-ves-example": "P.O BOX 56"
                },
                "city": {
                    "type": "string",
                    "description": "\n\nExample: - \"Sunnyvale\"-",
                    "title": "city",
                    "x-displayname": "City",
                    "x-ves-example": "Sunnyvale"
                },
                "contact_type": {
                    "description": " type of the contact (snail mail, billing)",
                    "title": "contact_type",
                    "$ref": "#/definitions/contactContactType",
                    "x-displayname": "Contact Type"
                },
                "country": {
                    "type": "string",
                    "description": "\n\nExample: - \"US\"-",
                    "title": "country",
                    "x-displayname": "Country",
                    "x-ves-example": "US"
                },
                "county": {
                    "type": "string",
                    "description": "\n\nExample: - \"Santa Clara\"-",
                    "title": "county",
                    "x-displayname": "County",
                    "x-ves-example": "Santa Clara"
                },
                "phone_number": {
                    "type": "string",
                    "description": "\n\nExample: - \"+11234567890\"-",
                    "title": "phone_number",
                    "x-displayname": "Phone Number",
                    "x-ves-example": "+11234567890"
                },
                "state": {
                    "type": "string",
                    "description": "\n\nExample: - \"California\"-",
                    "title": "state",
                    "x-displayname": "State",
                    "x-ves-example": "California"
                },
                "state_code": {
                    "type": "string",
                    "description": "\n\nExample: - \"CA\"-",
                    "title": "state code",
                    "x-displayname": "State Code",
                    "x-ves-example": "CA"
                },
                "zip_code": {
                    "type": "string",
                    "description": "\n\nExample: - \"95054\"-",
                    "title": "zip_code",
                    "x-displayname": "ZIP code",
                    "x-ves-example": "95054"
                }
            }
        },
        "schematenantEmpty": {
            "type": "object",
            "description": "This can be used for messages where no values are needed",
            "title": "Empty",
            "x-displayname": "Empty",
            "x-ves-proto-message": "ves.io.schema.tenant.Empty"
        },
        "schematenantFSMState": {
            "type": "string",
            "description": "Tenant states https://gitlab.com/volterra/ves.io/eywa/-/wikis/Tenant-State-Machine.\n\n - StateUndefined: StateUndefined\n\nTenant state when it was created without any state.\n - StateCreating: StateCreating\n\nTenant state of initial bootstrapping tenant, registering tenant in other service and\npre-create default objects for the tenant like default namespaces, default roles etc.\n - StateCreateFailed: StateCreateFailed\n\nTenant state when initial bootstrapping was failed by some reason and must be retried\nafter issue is solved.\n - StateInactive: StateInactive\n\nTenant state when initial creation is completed and we have trigger next stage of tenant\nregistration like creating support account, billing account in third party services.\n - StateActive: StateActive\n\nTenant state of completely registered tenant and available to use.\n - StateSuspended: StateSuspended\n\nTenant state of suspended tenant by some reason like not finished billing payments,\nmanually suspended by administrator, etc.\n - StateDisabled: StateDisabled\n\nTenant state of disabled tenant which are in pre-deletion state.\n - StateConfiguring: StateConfiguring\n\nConfiguring state of the specific tenant, can be set for instance if tenant is setting up billing account, etc..\n - StateConfiguringFailed: StateConfiguringFailed\n\nConfiguring state of the specific tenant, can be set for instance if tenant is setting up billing account, etc..",
            "title": "States",
            "enum": [
                "StateUndefined",
                "StateCreating",
                "StateCreateFailed",
                "StateInactive",
                "StateActive",
                "StateSuspended",
                "StateDisabled",
                "StateConfiguring",
                "StateConfiguringFailed"
            ],
            "default": "StateUndefined",
            "x-displayname": "States",
            "x-ves-proto-enum": "ves.io.schema.tenant.FSMState"
        },
        "tenantAssignDomainOwnerRequest": {
            "type": "object",
            "description": "Domain owner assignment request",
            "title": "Domain owner assignment request",
            "x-displayname": "Domain owner assignment request",
            "x-ves-proto-message": "ves.io.schema.tenant.AssignDomainOwnerRequest",
            "properties": {
                "email": {
                    "type": "string",
                    "description": " assign domain owner to user with this email\n\nExample: - \"joe.doe@acme.com\"-",
                    "title": "Email",
                    "x-displayname": "Email",
                    "x-ves-example": "joe.doe@acme.com"
                }
            }
        },
        "tenantCreateDebugUserRequest": {
            "type": "object",
            "description": "Request to create a debug user. Such user can help debugging issues.",
            "title": "CreateDebugUserRequest",
            "x-displayname": "CreateDebugUserRequest",
            "x-ves-proto-message": "ves.io.schema.tenant.CreateDebugUserRequest",
            "properties": {
                "ns_roles": {
                    "type": "array",
                    "description": " Namespace roles contains set of roles, with which debug user will be created.",
                    "title": "Namespace roles",
                    "items": {
                        "$ref": "#/definitions/schemaNamespaceRoleType"
                    },
                    "x-displayname": "Namespace roles"
                }
            }
        },
        "tenantCredentialsExpiry": {
            "type": "object",
            "description": "CredentialsExpiry is a struct that holds max expiration days setting for the different credentials.",
            "title": "CredentialsExpiry",
            "x-displayname": "CredentialsExpiry",
            "x-ves-proto-message": "ves.io.schema.tenant.CredentialsExpiry",
            "properties": {
                "max_api_certificate_expiry_days": {
                    "type": "integer",
                    "description": " Certificate expiry period as days\n\nExample: - \"90\"-",
                    "title": "Certificate expiry period",
                    "format": "int32",
                    "x-displayname": "Certificate expiry period",
                    "x-ves-example": "90"
                },
                "max_api_token_expiry_days": {
                    "type": "integer",
                    "description": " Token expiry period as days\n\nExample: - \"90\"-",
                    "title": "Token expiry period",
                    "format": "int32",
                    "x-displayname": "Token expiry period",
                    "x-ves-example": "90"
                },
                "max_kube_config_expiry_days": {
                    "type": "integer",
                    "description": " TokeKubeconfign expiry period as days\n\nExample: - \"90\"-",
                    "title": "Kubeconfig expiry period",
                    "format": "int32",
                    "x-displayname": "Kubeconfig expiry period",
                    "x-ves-example": "90"
                }
            }
        },
        "tenantDebugUser": {
            "type": "object",
            "x-ves-proto-message": "ves.io.schema.tenant.DebugUser",
            "properties": {
                "email": {
                    "type": "string",
                    "description": " user's email\n\nExample: - \"joe.doe@acme.com\"-",
                    "title": "email",
                    "x-displayname": "Email",
                    "x-ves-example": "joe.doe@acme.com"
                },
                "enabled": {
                    "type": "boolean",
                    "description": " if set to true means that user enabled in IDM.",
                    "title": "Enabled",
                    "format": "boolean",
                    "x-displayname": "Enabled"
                },
                "first_name": {
                    "type": "string",
                    "description": " user's first name\n\nExample: - \"Joe\"-",
                    "title": "first_name",
                    "x-displayname": "First Name",
                    "x-ves-example": "Joe"
                },
                "last_name": {
                    "type": "string",
                    "description": " user's last name\n\nExample: - \"Doe\"-",
                    "title": "last_name",
                    "x-displayname": "Last Name",
                    "x-ves-example": "Doe"
                }
            }
        },
        "tenantDeleteTenantRequest": {
            "type": "object",
            "description": "Request for marking Tenant for deletion.",
            "title": "DeleteTenantRequest",
            "x-displayname": "DeleteTenantRequest",
            "x-ves-proto-message": "ves.io.schema.tenant.DeleteTenantRequest",
            "properties": {
                "email": {
                    "type": "string",
                    "description": " Email of freemium account which need to be deleted.\n\nExample: - \"test@test.com\"-",
                    "title": "Email",
                    "x-displayname": "Email",
                    "x-ves-example": "test@test.com"
                },
                "feedback": {
                    "type": "string",
                    "description": " Feedback from the customer related to reason of account deletion.\n\nExample: - \"Customers feedback\"-",
                    "title": "Feedback",
                    "x-displayname": "Feedback",
                    "x-ves-example": "Customers feedback"
                },
                "name": {
                    "type": "string",
                    "description": " Tenant name marked for deletion.\n\nExample: - \"tenant-1\"-",
                    "title": "Name",
                    "x-displayname": "Name",
                    "x-ves-example": "tenant-1"
                },
                "reason": {
                    "description": " Predefined reason of account deletion.",
                    "title": "Reason",
                    "$ref": "#/definitions/tenantDeletionReason",
                    "x-displayname": "Reason"
                }
            }
        },
        "tenantDeletionReason": {
            "type": "string",
            "description": "List of available reason for account deletion.\n\n - REASON_UNKNOWN: Unknown reason\n\nUnknown reason\n - REASON_SWITCH_TO_FREE_PLAN: Switch to free plan\n\nSwitch to free plan\n - REASON_NO_LONGER_NEEDED: No longer needed\n\nNo longer needed\n - REASON_NOT_JUSTIFY_COSTS: Too expensive\n\nToo expensive\n - REASON_DIFFICULT_TO_USE: Difficult to use\n\nDifficult to use",
            "title": "DeletionReason",
            "enum": [
                "REASON_UNKNOWN",
                "REASON_SWITCH_TO_FREE_PLAN",
                "REASON_NO_LONGER_NEEDED",
                "REASON_NOT_JUSTIFY_COSTS",
                "REASON_DIFFICULT_TO_USE"
            ],
            "default": "REASON_UNKNOWN",
            "x-displayname": "DeletionReason",
            "x-ves-proto-enum": "ves.io.schema.tenant.DeletionReason"
        },
        "tenantGetLoginEventsInTimeFrameRequest": {
            "type": "object",
            "description": "Contains fields to retrieve events in timeframe",
            "title": "GetLoginEventsInTimeFrameRequest",
            "x-displayname": "GetLoginEventsInTimeFrameRequest",
            "x-ves-proto-message": "ves.io.schema.tenant.GetLoginEventsInTimeFrameRequest",
            "properties": {
                "end": {
                    "type": "string",
                    "description": " End time\n\nExample: - \"2020-04-20T12:32:51.341959216Z\"-",
                    "title": "End",
                    "format": "date-time",
                    "x-displayname": "End",
                    "x-ves-example": "2020-04-20T12:32:51.341959216Z"
                },
                "first": {
                    "type": "integer",
                    "description": " Records per page\n\nExample: - \"25\"-",
                    "title": "Max",
                    "format": "int64",
                    "x-displayname": "Max",
                    "x-ves-example": "25"
                },
                "max": {
                    "type": "integer",
                    "description": " Records per page\n\nExample: - \"25\"-",
                    "title": "Max",
                    "format": "int64",
                    "x-displayname": "Max",
                    "x-ves-example": "25"
                },
                "start": {
                    "type": "string",
                    "description": " Start time\n\nExample: - \"2020-04-20T12:32:51.341959216Z\"-",
                    "title": "Start",
                    "format": "date-time",
                    "x-displayname": "Start",
                    "x-ves-example": "2020-04-20T12:32:51.341959216Z"
                }
            }
        },
        "tenantLastLoginMap": {
            "type": "object",
            "description": "Last login map",
            "title": "Last login map",
            "x-displayname": "Last login map",
            "x-ves-proto-message": "ves.io.schema.tenant.LastLoginMap",
            "properties": {
                "last_login_map": {
                    "type": "object",
                    "description": " Login map username-\u003etimestamp",
                    "title": "Last login map",
                    "x-displayname": "Last login map"
                }
            }
        },
        "tenantLoginEvent": {
            "type": "object",
            "description": "x-displayName: \"LoginEvent\"\nContains information about specific login event, like when exactly it happened, from which IP address, etc...",
            "title": "LoginEvent",
            "properties": {
                "auth_method": {
                    "type": "string",
                    "description": "x-displayName: \"Authentication method\"\nx-example: \"SSO\"\nAuthentication method",
                    "title": "Authentication method"
                },
                "error": {
                    "type": "string",
                    "description": "x-displayName: \"Error\"\nx-example: \"OK\"\nLogin error (if any)",
                    "title": "Error"
                },
                "ip_address": {
                    "type": "string",
                    "description": "x-displayName: \"IP address\"\nx-example: \"127.0.0.1\"\nIP address the login accessed from",
                    "title": "IP address"
                },
                "session_id": {
                    "type": "string",
                    "description": "x-displayName: \"Session\"\nx-example: \"55cabe9e-9e10-486f-97bf-05c655d6fea9\"\nSession",
                    "title": "Session"
                },
                "time": {
                    "type": "string",
                    "description": "x-displayName: \"Time\"\nx-example: \"2020-04-20T12:32:51.341959216Z\"\nLogin event time",
                    "title": "Time",
                    "format": "date-time"
                },
                "username": {
                    "type": "string",
                    "description": "x-displayName: \"Username\"\nx-example: \"joe.doe\"\nUsername of the login",
                    "title": "Username"
                }
            }
        },
        "tenantLoginEvents": {
            "type": "object",
            "description": "x-displayName: \"LoginEvents\"\nContains list of login events.",
            "title": "LoginEvents",
            "properties": {
                "login_events": {
                    "type": "array",
                    "description": "x-displayName: \"Login events\"\nCollection of login events based on input filter",
                    "title": "Login events",
                    "items": {
                        "$ref": "#/definitions/tenantLoginEvent"
                    }
                }
            }
        },
        "tenantLoginEventsMap": {
            "type": "object",
            "description": "LoginEventsMap is a map from username to list of login events. In can be useful have login events grouped by usernames.",
            "title": "LoginEventsMap",
            "x-displayname": "LoginEventsMap",
            "x-ves-proto-message": "ves.io.schema.tenant.LoginEventsMap",
            "properties": {
                "login_events_map": {
                    "type": "object",
                    "description": " Map of login events based on input filter group by username",
                    "title": "Login map",
                    "x-displayname": "Login map"
                }
            }
        },
        "tenantOtpStatus": {
            "type": "string",
            "description": "OtpStatus can be either enabled/disabled or processing.\nApplying new policy can take time, especially if tenant has many users so for this purpose processing state is introduced.\n\n - OTP_DISABLED: OTP_DISABLED\n\nOTP disabled\n - OTP_ENABLED: OTP_ENABLED\n\nOTP enabled\n - OTP_PROCESSING: OTP_PROCESSING\n\nOTP is being updated\n - OTP_PROCESS_DISABLING: OTP_PROCESSING\n\nOTP is being updated to be disabled",
            "title": "OtpStatus",
            "enum": [
                "OTP_DISABLED",
                "OTP_ENABLED",
                "OTP_PROCESSING",
                "OTP_PROCESS_DISABLING"
            ],
            "default": "OTP_DISABLED",
            "x-displayname": "OtpStatus",
            "x-ves-proto-enum": "ves.io.schema.tenant.OtpStatus"
        },
        "tenantPasswordPolicyPublicAccess": {
            "type": "object",
            "description": "PasswordPolicyPublicAccess contains subset of password policy settings. This settings will be available publicly\nwithout authentication.",
            "title": "PasswordPolicyPublicAccess",
            "x-displayname": "PasswordPolicyPublicAccess",
            "x-ves-proto-message": "ves.io.schema.tenant.PasswordPolicyPublicAccess",
            "properties": {
                "digits": {
                    "type": "integer",
                    "description": " Number of digits\n\nExample: - \"1\"-",
                    "title": "Digits",
                    "format": "int64",
                    "x-displayname": "Digits",
                    "x-ves-example": "1"
                },
                "lowercase_characters": {
                    "type": "integer",
                    "description": " Number of lowercase characters\n\nExample: - \"1\"-",
                    "title": "lowercase_characters",
                    "format": "int64",
                    "x-displayname": "lowercase_characters",
                    "x-ves-example": "1"
                },
                "minimum_length": {
                    "type": "integer",
                    "description": " Minimum password length\n\nExample: - \"1\"-",
                    "title": "minimum_length",
                    "format": "int64",
                    "x-displayname": "minimum_length",
                    "x-ves-example": "1"
                },
                "not_recently_used": {
                    "type": "integer",
                    "description": " Number of previous passwords to check for equality - if match found the password is rejected\n\nExample: - \"1\"-",
                    "title": "not_recently_used",
                    "format": "int64",
                    "x-displayname": "not_recently_used",
                    "x-ves-example": "1"
                },
                "not_username": {
                    "type": "boolean",
                    "description": " If true then username must not appear in the password string",
                    "title": "not_username",
                    "format": "boolean",
                    "x-displayname": "not_username"
                },
                "special_characters": {
                    "type": "integer",
                    "description": " Number of special characters\n\nExample: - \"1\"-",
                    "title": "special_characters",
                    "format": "int64",
                    "x-displayname": "special_characters",
                    "x-ves-example": "1"
                },
                "uppercase_characters": {
                    "type": "integer",
                    "description": " Number of uppercase characters\n\nExample: - \"1\"-",
                    "title": "uppercase_characters",
                    "format": "int64",
                    "x-displayname": "uppercase_characters",
                    "x-ves-example": "1"
                }
            }
        },
        "tenantSetBillingInfoRequest": {
            "type": "object",
            "description": "Request to update tenant billing pan",
            "title": "UpdateBillingPlanRequest",
            "x-displayname": "UpdateBillingPlanRequest",
            "x-ves-proto-message": "ves.io.schema.tenant.SetBillingInfoRequest",
            "properties": {
                "company_contact": {
                    "description": " contact details of the enterprise customer",
                    "title": "company contact",
                    "$ref": "#/definitions/schemacontactGlobalSpecType",
                    "x-displayname": "Company Contact"
                },
                "company_name": {
                    "type": "string",
                    "description": " company name (enterprise only)\n\nExample: - \"ACME Ltd.\"-",
                    "title": "company name",
                    "x-displayname": "Company Name",
                    "x-ves-example": "ACME Ltd."
                },
                "contact_number": {
                    "type": "string",
                    "description": " phone contact number\n obsolete\n\nExample: - \"+11234567890\"-",
                    "title": "contact_number",
                    "x-displayname": "Contact Number",
                    "x-ves-example": "+11234567890"
                },
                "customer_contact": {
                    "description": " contact details of the customer",
                    "title": "customer contact",
                    "$ref": "#/definitions/schemacontactGlobalSpecType",
                    "x-displayname": "Customer Contact"
                },
                "first_name": {
                    "type": "string",
                    "description": " first name of the customer\n obsolete\n\nExample: - \"John\"-",
                    "title": "first_name",
                    "x-displayname": "First Name",
                    "x-ves-example": "John"
                },
                "last_name": {
                    "type": "string",
                    "description": " last name of the customer (the superuser)\n obsolete\n\nExample: - \"Doe\"-",
                    "title": "last_name",
                    "x-displayname": "Last Name",
                    "x-ves-example": "Doe"
                },
                "locale": {
                    "type": "string",
                    "description": " locale of this sign up\n\nExample: - \"en-us\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "locale",
                    "x-displayname": "Locale",
                    "x-ves-example": "en-us",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "payment_address": {
                    "description": " address associated with the credit card details provided using the payment_provider_token\n if no billing address is provided then any address tokenized with payment_provider_token will be used - including an empty address.",
                    "title": "billing_address",
                    "$ref": "#/definitions/schemacontactGlobalSpecType",
                    "x-displayname": "Payment Address"
                },
                "payment_provider_token": {
                    "type": "string",
                    "description": " payment provider token (for credit card details)\n\nExample: - \"tok_1234567890\"-",
                    "title": "payment_provider_token",
                    "x-displayname": "Payment Provider Token",
                    "x-ves-example": "tok_1234567890"
                },
                "tos_accepted": {
                    "type": "string",
                    "description": " t\u0026c accepted date as millis from 01/01/1970 UTC\n\nExample: - \"1569926163000\"-",
                    "title": "tos_accepted",
                    "format": "int64",
                    "x-displayname": "TOS Accepted",
                    "x-ves-example": "1569926163000"
                },
                "tos_accepted_at": {
                    "type": "string",
                    "description": " tos accepted timestamp.\n\nExample: - \"2020-04-20T12:32:51.341959216Z\"-",
                    "title": "tos_accepted_at",
                    "format": "date-time",
                    "x-displayname": "TOSAcceptedAt",
                    "x-ves-example": "2020-04-20T12:32:51.341959216Z"
                },
                "tos_version": {
                    "type": "string",
                    "description": " indicates the version of ToS customer approved during signup. Any new version will require the customer to re-approve during login.\n\nExample: - \"v1.2\"-",
                    "title": "version of terms of services the customer accepted",
                    "x-displayname": "TOS version",
                    "x-ves-example": "v1.2"
                },
                "usage_plan": {
                    "type": "string",
                    "description": " Updates usage plan for specific tenant to complete configuration part.\n\nExample: - \"plan-1\"-",
                    "title": "UsagePlan",
                    "x-displayname": "UsagePlan",
                    "x-ves-example": "plan-1"
                }
            }
        },
        "tenantStatusResponse": {
            "type": "object",
            "description": "LookupCnameResponse sets the response format based on the availability of cname.\n\nIt can return any of these three types of errors.\nEEXISTS =\u003e cname exists.\nEOK =\u003e valid request. However, cname does not exist.\nEUNKNOWN =\u003e internal error in fetching tenants info.",
            "x-displayname": "LookupCnameResponse",
            "x-ves-proto-message": "ves.io.schema.tenant.StatusResponse"
        },
        "tenantSupportInfo": {
            "type": "object",
            "description": "Support Info contains support information for tenant",
            "title": "Support Info",
            "x-displayname": "Support Info",
            "x-ves-proto-message": "ves.io.schema.tenant.SupportInfo",
            "properties": {
                "support_email_address": {
                    "type": "string",
                    "description": " Support Email address for tenant",
                    "title": "Support email address",
                    "x-displayname": "Support email address"
                }
            }
        },
        "tenantTenantSettingsResponse": {
            "type": "object",
            "description": "Defines tenant specific settings.",
            "title": "TenantSettingsResponse",
            "x-displayname": "TenantSettingsResponse",
            "x-ves-proto-message": "ves.io.schema.tenant.TenantSettingsResponse",
            "properties": {
                "active_plan_transition_id": {
                    "type": "string",
                    "description": " Id of the plan transition request which is currently in state CREATING.\n\nExample: - \"7e1ba0f9-26dc-4397-97b3-b600df2097d3\"-",
                    "x-displayname": "ActivePlanTransitionId",
                    "x-ves-example": "7e1ba0f9-26dc-4397-97b3-b600df2097d3"
                },
                "company_name": {
                    "type": "string",
                    "description": " Company name of the tenant.",
                    "title": "CompanyName",
                    "x-displayname": "Company Name"
                },
                "domain": {
                    "type": "string",
                    "description": " Domain of the tenant.",
                    "title": "Domain",
                    "x-displayname": "Domain"
                },
                "max_credentials_expiry": {
                    "description": " max expiration days setting for the different credentials.",
                    "$ref": "#/definitions/tenantCredentialsExpiry",
                    "x-displayname": "MaxCredentialsExpiry"
                },
                "name": {
                    "type": "string",
                    "description": " name will represent name of the tenant that is being accessed\n\nExample: - \"tenant1\"-",
                    "title": "Name",
                    "x-displayname": "Name",
                    "x-ves-example": "tenant1"
                },
                "original_tenant": {
                    "type": "string",
                    "description": " orginal_tenant represent tenant id where the user belongs to\n\nExample: - \"tenant1\"-",
                    "title": "Original Tenant",
                    "x-displayname": "Original Tenant",
                    "x-ves-example": "tenant1"
                },
                "otp_enabled": {
                    "type": "boolean",
                    "description": " OTP configuration for tenant scope.",
                    "title": "OTP Enabled",
                    "format": "boolean",
                    "x-displayname": "OTP Enabled"
                },
                "otp_status": {
                    "description": " OTP Status contains information about otp's status. It can be enabled, disabled or processing.",
                    "title": "OTP Status",
                    "$ref": "#/definitions/tenantOtpStatus",
                    "x-displayname": "OTP Status"
                },
                "scim_enabled": {
                    "type": "boolean",
                    "description": " Flag to show SCIM is enabled for specific tenant.",
                    "title": "scim_enabled",
                    "format": "boolean",
                    "x-displayname": "SCIM Enabled"
                },
                "sso_enabled": {
                    "type": "boolean",
                    "description": " Flag to show SSO is enabled for specific tenant.",
                    "title": "SSO Enabled",
                    "format": "boolean",
                    "x-displayname": "SSO Enabled"
                },
                "state": {
                    "description": " Tenant state",
                    "title": "State",
                    "$ref": "#/definitions/schematenantFSMState",
                    "x-displayname": "State"
                }
            }
        },
        "tenantUnassignDomainOwnerRequest": {
            "type": "object",
            "description": "Domain owner assignment request",
            "title": "Domain owner un-assignment request",
            "x-displayname": "Domain owner un-assignment request",
            "x-ves-proto-message": "ves.io.schema.tenant.UnassignDomainOwnerRequest",
            "properties": {
                "email": {
                    "type": "string",
                    "description": " remove domain owner privilege from user with this email\n\nExample: - \"joe.doe@acme.com\"-",
                    "title": "Email",
                    "x-displayname": "Email",
                    "x-ves-example": "joe.doe@acme.com"
                }
            }
        },
        "tenantUpdateImageRequest": {
            "type": "object",
            "description": "Update user image request",
            "title": "Update user image request",
            "x-displayname": "Update user image request",
            "x-ves-proto-message": "ves.io.schema.tenant.UpdateImageRequest",
            "properties": {
                "content_type": {
                    "type": "string",
                    "description": " Type of uploading image.\n\nExample: - \"image/jpeg\"-",
                    "x-displayname": "ContentType",
                    "x-ves-example": "image/jpeg"
                },
                "image": {
                    "type": "string",
                    "description": " Blob of the tenant profile image.\n\nExample: - \"dXNlci1pbWFnZS5qcGVn\"-",
                    "format": "byte",
                    "x-displayname": "Image",
                    "x-ves-example": "dXNlci1pbWFnZS5qcGVn"
                }
            }
        },
        "tenantUpdateTenantSettingsRequest": {
            "type": "object",
            "description": "Request to update tenant settings for specific tenant.",
            "title": "UpdateTenantSettingsRequest",
            "x-displayname": "UpdateTenantSettingsRequest",
            "x-ves-proto-message": "ves.io.schema.tenant.UpdateTenantSettingsRequest",
            "properties": {
                "max_credentials_expiry": {
                    "description": " max expiration days setting for the different credentials.",
                    "$ref": "#/definitions/tenantCredentialsExpiry",
                    "x-displayname": "MaxCredentialsExpiry"
                },
                "otp_enabled": {
                    "type": "boolean",
                    "description": " OTP configuration for tenant scope.",
                    "title": "OTP Enabled",
                    "format": "boolean",
                    "x-displayname": "OTP Enabled"
                }
            }
        },
        "tenantUpdateTenantSettingsResponse": {
            "type": "object",
            "description": "Defines tenant specific settings.",
            "title": "TenantSettingsResponse",
            "x-displayname": "TenantSettingsResponse",
            "x-ves-proto-message": "ves.io.schema.tenant.UpdateTenantSettingsResponse",
            "properties": {
                "max_credentials_expiry": {
                    "description": " max expiration days setting for the different credentials.",
                    "$ref": "#/definitions/tenantCredentialsExpiry",
                    "x-displayname": "MaxCredentialsExpiry"
                },
                "otp_enabled": {
                    "type": "boolean",
                    "description": " OTP configuration for tenant scope.",
                    "title": "OTP Enabled",
                    "format": "boolean",
                    "x-displayname": "OTP Enabled"
                },
                "otp_status": {
                    "description": " OTP Status contains information about otp's status. It can be enabled, disabled or processing.",
                    "title": "OTP Status",
                    "$ref": "#/definitions/tenantOtpStatus",
                    "x-displayname": "OTP Status"
                },
                "scim_enabled": {
                    "type": "boolean",
                    "description": " Flag to show SCIM is enabled for specific tenant.",
                    "title": "scim_enabled",
                    "format": "boolean",
                    "x-displayname": "SCIM Enabled"
                },
                "sso_enabled": {
                    "type": "boolean",
                    "description": " Flag to show SSO is enabled for specific tenant.",
                    "title": "SSO Enabled",
                    "format": "boolean",
                    "x-displayname": "SSO Enabled"
                },
                "validation_errors": {
                    "type": "array",
                    "description": " x-displayName : \"Validation errors\"\n collection of validation errors",
                    "title": "validation errors",
                    "items": {
                        "$ref": "#/definitions/tenantValidationErrorField"
                    }
                }
            }
        },
        "tenantUser": {
            "type": "object",
            "description": "Login user representation. Currently users are identified by their email.",
            "title": "User",
            "x-displayname": "User",
            "x-ves-proto-message": "ves.io.schema.tenant.User",
            "properties": {
                "email": {
                    "type": "string",
                    "description": " user's email\n\nExample: - \"joe.doe@acme.com\"-",
                    "title": "email",
                    "x-displayname": "Email",
                    "x-ves-example": "joe.doe@acme.com"
                }
            }
        },
        "tenantUserList": {
            "type": "object",
            "description": "Collection of users",
            "title": "User list",
            "x-displayname": "User list",
            "x-ves-proto-message": "ves.io.schema.tenant.UserList",
            "properties": {
                "users": {
                    "type": "array",
                    "description": " Collection of users",
                    "title": "Users",
                    "items": {
                        "$ref": "#/definitions/tenantUser"
                    },
                    "x-displayname": "Users"
                }
            }
        },
        "tenantValidationErrorField": {
            "type": "object",
            "description": "Contains information on a single validation error",
            "title": "Validation error field",
            "x-displayname": "Validation error field",
            "x-ves-proto-message": "ves.io.schema.tenant.ValidationErrorField",
            "properties": {
                "error_field": {
                    "type": "string",
                    "description": " path indicates the field that is not valid\n\nExample: - \"max_credentials_expiry\"-",
                    "title": "Error field",
                    "x-displayname": "Error field",
                    "x-ves-example": "max_credentials_expiry"
                },
                "error_message": {
                    "type": "string",
                    "description": " more descriptive error message\n\nExample: - \"max_credentials_expiry code should be less \u003c 0 \"-",
                    "title": "Error message",
                    "x-displayname": "Error message",
                    "x-ves-example": "max_credentials_expiry code should be less \u003c 0 "
                }
            }
        },
        "tenant_configurationBasicConfiguration": {
            "type": "object",
            "title": "BasicConfiguration",
            "x-displayname": "BasicConfiguration",
            "x-ves-proto-message": "ves.io.schema.views.tenant_configuration.BasicConfiguration",
            "properties": {
                "display_name": {
                    "type": "string",
                    "description": " Tenant display name in the login screen\n\nExample: - \"value\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 255\n",
                    "title": "Display Name",
                    "maxLength": 255,
                    "x-displayname": "Display Name",
                    "x-ves-example": "value",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "255"
                    }
                }
            }
        },
        "tenant_configurationBruteForceDetectionSettings": {
            "type": "object",
            "title": "BruteForceDetectionSettings",
            "x-displayname": "BruteForceDetectionSettings",
            "x-ves-proto-message": "ves.io.schema.views.tenant_configuration.BruteForceDetectionSettings",
            "properties": {
                "max_login_failures": {
                    "type": "integer",
                    "description": " How many failures before wait is triggered.\n When login failure count is hit, user will be temporarily locked for a max duration of 15 minutes.\n\nExample: - \"5\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.lte: 30\n",
                    "title": "Max Login Failures",
                    "format": "int64",
                    "x-displayname": "Max Login Failures",
                    "x-ves-example": "5",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.lte": "30"
                    }
                }
            }
        },
        "tenant_configurationPasswordPolicy": {
            "type": "object",
            "title": "PasswordPolicy",
            "x-displayname": "PasswordPolicy",
            "x-ves-proto-message": "ves.io.schema.views.tenant_configuration.PasswordPolicy",
            "properties": {
                "digits": {
                    "type": "integer",
                    "description": " The number of digits required to be in the password string.\n\nExample: - \"1\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.lte: 16\n",
                    "title": "Digits",
                    "format": "int64",
                    "x-displayname": "Min Number Of Digits",
                    "x-ves-example": "1",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.lte": "16"
                    }
                },
                "expire_password": {
                    "type": "integer",
                    "description": " The number of days for which the password is valid.\n After the number of days has expired, the user is required to change their password.\n\nExample: - \"30\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.lte: 1080\n",
                    "title": "Expire Password",
                    "format": "int64",
                    "x-displayname": "Expire Password",
                    "x-ves-example": "30",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.lte": "1080"
                    }
                },
                "lowercase_characters": {
                    "type": "integer",
                    "description": " The number of lower case letters required to be in the password string.\n\nExample: - \"8\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.lte: 16\n",
                    "title": "Lowercase Characters",
                    "format": "int64",
                    "x-displayname": "Min Number Of Lowercase Characters",
                    "x-ves-example": "8",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.lte": "16"
                    }
                },
                "minimum_length": {
                    "type": "integer",
                    "description": " Minimum length of password.\n\nExample: - \"12\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.uint32.gte: 7\n",
                    "title": "Minimum Length",
                    "format": "int64",
                    "x-displayname": "Minimum Length",
                    "x-ves-example": "12",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.uint32.gte": "7"
                    }
                },
                "not_recently_used": {
                    "type": "integer",
                    "description": " This policy is used to restrict user from using previously used passwords.\n Number that's set determines number of last passwords which user cannot use as new password.\n\nExample: - \"2\"-",
                    "title": "Not Recently Used",
                    "format": "int64",
                    "x-displayname": "Not Recently Used",
                    "x-ves-example": "2"
                },
                "not_username": {
                    "type": "boolean",
                    "description": " When set, the password is not allowed to be the same as the username.",
                    "title": "Not Username",
                    "format": "boolean",
                    "x-displayname": "Not Username"
                },
                "special_characters": {
                    "type": "integer",
                    "description": " The number of special characters like '?!#%$' required to be in the password string.\n\nExample: - \"1\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.lte: 16\n",
                    "title": "Special Characters",
                    "format": "int64",
                    "x-displayname": "Min Number Of Special Characters",
                    "x-ves-example": "1",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.lte": "16"
                    }
                },
                "uppercase_characters": {
                    "type": "integer",
                    "description": " The number of upper case letters required to be in the password string.\n\nExample: - \"2\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.lte: 16\n",
                    "title": "Uppercase Characters",
                    "format": "int64",
                    "x-displayname": "Min Number Of Uppercase Characters",
                    "x-ves-example": "2",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.lte": "16"
                    }
                }
            }
        },
        "viewstenant_configurationGlobalSpecType": {
            "type": "object",
            "description": "Shape of the tenant configuration specification",
            "title": "GlobalSpecType",
            "x-displayname": "Global Specification",
            "x-ves-proto-message": "ves.io.schema.views.tenant_configuration.GlobalSpecType",
            "properties": {
                "basic_configuration": {
                    "description": " Basic configuration contains general parameters which can be adjusted within tenant.",
                    "title": "Basic Configuration",
                    "$ref": "#/definitions/tenant_configurationBasicConfiguration",
                    "x-displayname": "Basic Configuration"
                },
                "brute_force_detection_settings": {
                    "description": " Our brute force detection system uses temporary lockout algorithm.\n Temporary lockout will disable a users account for a time period after an attack is detected;\n the time period for which the account is disabled increases the longer the attack continues.\n You can adjust some parameters of the brute force detection system.",
                    "title": "Brute Force Detection Settings",
                    "$ref": "#/definitions/tenant_configurationBruteForceDetectionSettings",
                    "x-displayname": "Brute Force Detection Settings"
                },
                "password_policy": {
                    "description": " Password policy allows you to configure your own password policy within tenant.\n Each user within tenant will have to comply with the configured policy when they set or update the password.",
                    "title": "Password Policy",
                    "$ref": "#/definitions/tenant_configurationPasswordPolicy",
                    "x-displayname": "Password Policy"
                }
            }
        }
    },
    "x-displayname": "Tenant",
    "x-ves-proto-file": "ves.io/schema/tenant/custom_api.proto"
}`
