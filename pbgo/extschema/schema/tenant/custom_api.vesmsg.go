// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package tenant

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AssignDomainOwnerRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AssignDomainOwnerRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AssignDomainOwnerRequest) DeepCopy() *AssignDomainOwnerRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AssignDomainOwnerRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AssignDomainOwnerRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AssignDomainOwnerRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AssignDomainOwnerRequestValidator().Validate(ctx, m, opts...)
}

type ValidateAssignDomainOwnerRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAssignDomainOwnerRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AssignDomainOwnerRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AssignDomainOwnerRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["email"]; exists {

		vOpts := append(opts, db.WithValidateField("email"))
		if err := fv(ctx, m.GetEmail(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAssignDomainOwnerRequestValidator = func() *ValidateAssignDomainOwnerRequest {
	v := &ValidateAssignDomainOwnerRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AssignDomainOwnerRequestValidator() db.Validator {
	return DefaultAssignDomainOwnerRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *DeleteTenantRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DeleteTenantRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DeleteTenantRequest) DeepCopy() *DeleteTenantRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DeleteTenantRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DeleteTenantRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DeleteTenantRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DeleteTenantRequestValidator().Validate(ctx, m, opts...)
}

type ValidateDeleteTenantRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDeleteTenantRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DeleteTenantRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DeleteTenantRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["email"]; exists {

		vOpts := append(opts, db.WithValidateField("email"))
		if err := fv(ctx, m.GetEmail(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["feedback"]; exists {

		vOpts := append(opts, db.WithValidateField("feedback"))
		if err := fv(ctx, m.GetFeedback(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["reason"]; exists {

		vOpts := append(opts, db.WithValidateField("reason"))
		if err := fv(ctx, m.GetReason(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDeleteTenantRequestValidator = func() *ValidateDeleteTenantRequest {
	v := &ValidateDeleteTenantRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DeleteTenantRequestValidator() db.Validator {
	return DefaultDeleteTenantRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *DisableTenantResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DisableTenantResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DisableTenantResponse) DeepCopy() *DisableTenantResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DisableTenantResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DisableTenantResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DisableTenantResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DisableTenantResponseValidator().Validate(ctx, m, opts...)
}

type ValidateDisableTenantResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDisableTenantResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DisableTenantResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DisableTenantResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["job_id"]; exists {

		vOpts := append(opts, db.WithValidateField("job_id"))
		if err := fv(ctx, m.GetJobId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDisableTenantResponseValidator = func() *ValidateDisableTenantResponse {
	v := &ValidateDisableTenantResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DisableTenantResponseValidator() db.Validator {
	return DefaultDisableTenantResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *EscalationDocResp) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *EscalationDocResp) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *EscalationDocResp) DeepCopy() *EscalationDocResp {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &EscalationDocResp{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *EscalationDocResp) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *EscalationDocResp) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EscalationDocRespValidator().Validate(ctx, m, opts...)
}

type ValidateEscalationDocResp struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEscalationDocResp) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*EscalationDocResp)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *EscalationDocResp got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["url"]; exists {

		vOpts := append(opts, db.WithValidateField("url"))
		if err := fv(ctx, m.GetUrl(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEscalationDocRespValidator = func() *ValidateEscalationDocResp {
	v := &ValidateEscalationDocResp{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func EscalationDocRespValidator() db.Validator {
	return DefaultEscalationDocRespValidator
}

// augmented methods on protoc/std generated struct

func (m *GetLoginEventsInTimeFrameRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetLoginEventsInTimeFrameRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetLoginEventsInTimeFrameRequest) DeepCopy() *GetLoginEventsInTimeFrameRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetLoginEventsInTimeFrameRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetLoginEventsInTimeFrameRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetLoginEventsInTimeFrameRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetLoginEventsInTimeFrameRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGetLoginEventsInTimeFrameRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetLoginEventsInTimeFrameRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetLoginEventsInTimeFrameRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetLoginEventsInTimeFrameRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["end"]; exists {

		vOpts := append(opts, db.WithValidateField("end"))
		if err := fv(ctx, m.GetEnd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["first"]; exists {

		vOpts := append(opts, db.WithValidateField("first"))
		if err := fv(ctx, m.GetFirst(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max"]; exists {

		vOpts := append(opts, db.WithValidateField("max"))
		if err := fv(ctx, m.GetMax(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start"]; exists {

		vOpts := append(opts, db.WithValidateField("start"))
		if err := fv(ctx, m.GetStart(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetLoginEventsInTimeFrameRequestValidator = func() *ValidateGetLoginEventsInTimeFrameRequest {
	v := &ValidateGetLoginEventsInTimeFrameRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetLoginEventsInTimeFrameRequestValidator() db.Validator {
	return DefaultGetLoginEventsInTimeFrameRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GetLoginEventsRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetLoginEventsRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetLoginEventsRequest) DeepCopy() *GetLoginEventsRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetLoginEventsRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetLoginEventsRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetLoginEventsRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetLoginEventsRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGetLoginEventsRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetLoginEventsRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetLoginEventsRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetLoginEventsRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["first"]; exists {

		vOpts := append(opts, db.WithValidateField("first"))
		if err := fv(ctx, m.GetFirst(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max"]; exists {

		vOpts := append(opts, db.WithValidateField("max"))
		if err := fv(ctx, m.GetMax(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetLoginEventsRequestValidator = func() *ValidateGetLoginEventsRequest {
	v := &ValidateGetLoginEventsRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetLoginEventsRequestValidator() db.Validator {
	return DefaultGetLoginEventsRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GetPasswordPolicyRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetPasswordPolicyRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetPasswordPolicyRequest) DeepCopy() *GetPasswordPolicyRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetPasswordPolicyRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetPasswordPolicyRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetPasswordPolicyRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetPasswordPolicyRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGetPasswordPolicyRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetPasswordPolicyRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetPasswordPolicyRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetPasswordPolicyRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["realm_id"]; exists {

		vOpts := append(opts, db.WithValidateField("realm_id"))
		if err := fv(ctx, m.GetRealmId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetPasswordPolicyRequestValidator = func() *ValidateGetPasswordPolicyRequest {
	v := &ValidateGetPasswordPolicyRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GetPasswordPolicyRequestValidator() db.Validator {
	return DefaultGetPasswordPolicyRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *LastLoginMap) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LastLoginMap) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LastLoginMap) DeepCopy() *LastLoginMap {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LastLoginMap{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LastLoginMap) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LastLoginMap) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LastLoginMapValidator().Validate(ctx, m, opts...)
}

type ValidateLastLoginMap struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLastLoginMap) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LastLoginMap)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LastLoginMap got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["last_login_map"]; exists {

		vOpts := append(opts, db.WithValidateField("last_login_map"))
		for key, value := range m.GetLastLoginMap() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLastLoginMapValidator = func() *ValidateLastLoginMap {
	v := &ValidateLastLoginMap{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LastLoginMapValidator() db.Validator {
	return DefaultLastLoginMapValidator
}

// augmented methods on protoc/std generated struct

func (m *LoginEvent) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LoginEvent) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LoginEvent) DeepCopy() *LoginEvent {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LoginEvent{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LoginEvent) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LoginEvent) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LoginEventValidator().Validate(ctx, m, opts...)
}

type ValidateLoginEvent struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLoginEvent) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LoginEvent)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LoginEvent got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["auth_method"]; exists {

		vOpts := append(opts, db.WithValidateField("auth_method"))
		if err := fv(ctx, m.GetAuthMethod(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["error"]; exists {

		vOpts := append(opts, db.WithValidateField("error"))
		if err := fv(ctx, m.GetError(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip_address"]; exists {

		vOpts := append(opts, db.WithValidateField("ip_address"))
		if err := fv(ctx, m.GetIpAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["session_id"]; exists {

		vOpts := append(opts, db.WithValidateField("session_id"))
		if err := fv(ctx, m.GetSessionId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["time"]; exists {

		vOpts := append(opts, db.WithValidateField("time"))
		if err := fv(ctx, m.GetTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["username"]; exists {

		vOpts := append(opts, db.WithValidateField("username"))
		if err := fv(ctx, m.GetUsername(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLoginEventValidator = func() *ValidateLoginEvent {
	v := &ValidateLoginEvent{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LoginEventValidator() db.Validator {
	return DefaultLoginEventValidator
}

// augmented methods on protoc/std generated struct

func (m *LoginEvents) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LoginEvents) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LoginEvents) DeepCopy() *LoginEvents {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LoginEvents{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LoginEvents) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LoginEvents) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LoginEventsValidator().Validate(ctx, m, opts...)
}

type ValidateLoginEvents struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLoginEvents) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LoginEvents)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LoginEvents got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["login_events"]; exists {

		vOpts := append(opts, db.WithValidateField("login_events"))
		for idx, item := range m.GetLoginEvents() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLoginEventsValidator = func() *ValidateLoginEvents {
	v := &ValidateLoginEvents{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LoginEventsValidator() db.Validator {
	return DefaultLoginEventsValidator
}

// augmented methods on protoc/std generated struct

func (m *LoginEventsMap) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LoginEventsMap) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LoginEventsMap) DeepCopy() *LoginEventsMap {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LoginEventsMap{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LoginEventsMap) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LoginEventsMap) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LoginEventsMapValidator().Validate(ctx, m, opts...)
}

type ValidateLoginEventsMap struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLoginEventsMap) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LoginEventsMap)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LoginEventsMap got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["login_events_map"]; exists {

		vOpts := append(opts, db.WithValidateField("login_events_map"))
		for key, value := range m.GetLoginEventsMap() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLoginEventsMapValidator = func() *ValidateLoginEventsMap {
	v := &ValidateLoginEventsMap{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LoginEventsMapValidator() db.Validator {
	return DefaultLoginEventsMapValidator
}

// augmented methods on protoc/std generated struct

func (m *LookupCnameRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LookupCnameRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LookupCnameRequest) DeepCopy() *LookupCnameRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LookupCnameRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LookupCnameRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LookupCnameRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LookupCnameRequestValidator().Validate(ctx, m, opts...)
}

type ValidateLookupCnameRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLookupCnameRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LookupCnameRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LookupCnameRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cname"]; exists {

		vOpts := append(opts, db.WithValidateField("cname"))
		if err := fv(ctx, m.GetCname(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLookupCnameRequestValidator = func() *ValidateLookupCnameRequest {
	v := &ValidateLookupCnameRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LookupCnameRequestValidator() db.Validator {
	return DefaultLookupCnameRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *PasswordPolicyPublicAccess) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PasswordPolicyPublicAccess) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PasswordPolicyPublicAccess) DeepCopy() *PasswordPolicyPublicAccess {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PasswordPolicyPublicAccess{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PasswordPolicyPublicAccess) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PasswordPolicyPublicAccess) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PasswordPolicyPublicAccessValidator().Validate(ctx, m, opts...)
}

type ValidatePasswordPolicyPublicAccess struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePasswordPolicyPublicAccess) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PasswordPolicyPublicAccess)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PasswordPolicyPublicAccess got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["digits"]; exists {

		vOpts := append(opts, db.WithValidateField("digits"))
		if err := fv(ctx, m.GetDigits(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["lowercase_characters"]; exists {

		vOpts := append(opts, db.WithValidateField("lowercase_characters"))
		if err := fv(ctx, m.GetLowercaseCharacters(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["minimum_length"]; exists {

		vOpts := append(opts, db.WithValidateField("minimum_length"))
		if err := fv(ctx, m.GetMinimumLength(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["not_recently_used"]; exists {

		vOpts := append(opts, db.WithValidateField("not_recently_used"))
		if err := fv(ctx, m.GetNotRecentlyUsed(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["not_username"]; exists {

		vOpts := append(opts, db.WithValidateField("not_username"))
		if err := fv(ctx, m.GetNotUsername(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["special_characters"]; exists {

		vOpts := append(opts, db.WithValidateField("special_characters"))
		if err := fv(ctx, m.GetSpecialCharacters(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["uppercase_characters"]; exists {

		vOpts := append(opts, db.WithValidateField("uppercase_characters"))
		if err := fv(ctx, m.GetUppercaseCharacters(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPasswordPolicyPublicAccessValidator = func() *ValidatePasswordPolicyPublicAccess {
	v := &ValidatePasswordPolicyPublicAccess{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func PasswordPolicyPublicAccessValidator() db.Validator {
	return DefaultPasswordPolicyPublicAccessValidator
}

// augmented methods on protoc/std generated struct

func (m *StatusResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StatusResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StatusResponse) DeepCopy() *StatusResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StatusResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StatusResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StatusResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StatusResponseValidator().Validate(ctx, m, opts...)
}

type ValidateStatusResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStatusResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StatusResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StatusResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStatusResponseValidator = func() *ValidateStatusResponse {
	v := &ValidateStatusResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func StatusResponseValidator() db.Validator {
	return DefaultStatusResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *SupportInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SupportInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SupportInfo) DeepCopy() *SupportInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SupportInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SupportInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SupportInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SupportInfoValidator().Validate(ctx, m, opts...)
}

type ValidateSupportInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSupportInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SupportInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SupportInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["support_email_address"]; exists {

		vOpts := append(opts, db.WithValidateField("support_email_address"))
		if err := fv(ctx, m.GetSupportEmailAddress(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSupportInfoValidator = func() *ValidateSupportInfo {
	v := &ValidateSupportInfo{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SupportInfoValidator() db.Validator {
	return DefaultSupportInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *TenantSettingsResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TenantSettingsResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TenantSettingsResponse) DeepCopy() *TenantSettingsResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TenantSettingsResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TenantSettingsResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TenantSettingsResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TenantSettingsResponseValidator().Validate(ctx, m, opts...)
}

type ValidateTenantSettingsResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTenantSettingsResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TenantSettingsResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TenantSettingsResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["active_plan_transition_id"]; exists {

		vOpts := append(opts, db.WithValidateField("active_plan_transition_id"))
		if err := fv(ctx, m.GetActivePlanTransitionId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["company_name"]; exists {

		vOpts := append(opts, db.WithValidateField("company_name"))
		if err := fv(ctx, m.GetCompanyName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["domain"]; exists {

		vOpts := append(opts, db.WithValidateField("domain"))
		if err := fv(ctx, m.GetDomain(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_credentials_expiry"]; exists {

		vOpts := append(opts, db.WithValidateField("max_credentials_expiry"))
		if err := fv(ctx, m.GetMaxCredentialsExpiry(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["original_tenant"]; exists {

		vOpts := append(opts, db.WithValidateField("original_tenant"))
		if err := fv(ctx, m.GetOriginalTenant(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["otp_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("otp_enabled"))
		if err := fv(ctx, m.GetOtpEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["otp_status"]; exists {

		vOpts := append(opts, db.WithValidateField("otp_status"))
		if err := fv(ctx, m.GetOtpStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["scim_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("scim_enabled"))
		if err := fv(ctx, m.GetScimEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sso_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("sso_enabled"))
		if err := fv(ctx, m.GetSsoEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTenantSettingsResponseValidator = func() *ValidateTenantSettingsResponse {
	v := &ValidateTenantSettingsResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func TenantSettingsResponseValidator() db.Validator {
	return DefaultTenantSettingsResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *UnassignDomainOwnerRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UnassignDomainOwnerRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UnassignDomainOwnerRequest) DeepCopy() *UnassignDomainOwnerRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UnassignDomainOwnerRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UnassignDomainOwnerRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UnassignDomainOwnerRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UnassignDomainOwnerRequestValidator().Validate(ctx, m, opts...)
}

type ValidateUnassignDomainOwnerRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUnassignDomainOwnerRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UnassignDomainOwnerRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UnassignDomainOwnerRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["email"]; exists {

		vOpts := append(opts, db.WithValidateField("email"))
		if err := fv(ctx, m.GetEmail(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUnassignDomainOwnerRequestValidator = func() *ValidateUnassignDomainOwnerRequest {
	v := &ValidateUnassignDomainOwnerRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UnassignDomainOwnerRequestValidator() db.Validator {
	return DefaultUnassignDomainOwnerRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *UpdateImageRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpdateImageRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpdateImageRequest) String() string {
	if m == nil {
		return ""
	}
	copy := m.DeepCopy()
	copy.Redact(context.Background())
	return copy.string()
}

func (m *UpdateImageRequest) GoString() string {
	copy := m.DeepCopy()
	copy.Redact(context.Background())
	return copy.goString()
}

// Redact squashes sensitive info in m (in-place)
func (m *UpdateImageRequest) Redact(ctx context.Context) error {
	// clear fields with confidential option set (at message or field level)
	if m == nil {
		return nil
	}

	m.Image = []byte{}

	return nil
}

func (m *UpdateImageRequest) DeepCopy() *UpdateImageRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpdateImageRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpdateImageRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpdateImageRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpdateImageRequestValidator().Validate(ctx, m, opts...)
}

type ValidateUpdateImageRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpdateImageRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpdateImageRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpdateImageRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["content_type"]; exists {

		vOpts := append(opts, db.WithValidateField("content_type"))
		if err := fv(ctx, m.GetContentType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["image"]; exists {

		vOpts := append(opts, db.WithValidateField("image"))
		if err := fv(ctx, m.GetImage(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpdateImageRequestValidator = func() *ValidateUpdateImageRequest {
	v := &ValidateUpdateImageRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UpdateImageRequestValidator() db.Validator {
	return DefaultUpdateImageRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *UpdateTenantSettingsRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpdateTenantSettingsRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpdateTenantSettingsRequest) DeepCopy() *UpdateTenantSettingsRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpdateTenantSettingsRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpdateTenantSettingsRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpdateTenantSettingsRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpdateTenantSettingsRequestValidator().Validate(ctx, m, opts...)
}

type ValidateUpdateTenantSettingsRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpdateTenantSettingsRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpdateTenantSettingsRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpdateTenantSettingsRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["max_credentials_expiry"]; exists {

		vOpts := append(opts, db.WithValidateField("max_credentials_expiry"))
		if err := fv(ctx, m.GetMaxCredentialsExpiry(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["otp_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("otp_enabled"))
		if err := fv(ctx, m.GetOtpEnabled(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpdateTenantSettingsRequestValidator = func() *ValidateUpdateTenantSettingsRequest {
	v := &ValidateUpdateTenantSettingsRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UpdateTenantSettingsRequestValidator() db.Validator {
	return DefaultUpdateTenantSettingsRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *UpdateTenantSettingsResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UpdateTenantSettingsResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UpdateTenantSettingsResponse) DeepCopy() *UpdateTenantSettingsResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UpdateTenantSettingsResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UpdateTenantSettingsResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UpdateTenantSettingsResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UpdateTenantSettingsResponseValidator().Validate(ctx, m, opts...)
}

type ValidateUpdateTenantSettingsResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUpdateTenantSettingsResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UpdateTenantSettingsResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UpdateTenantSettingsResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["max_credentials_expiry"]; exists {

		vOpts := append(opts, db.WithValidateField("max_credentials_expiry"))
		if err := fv(ctx, m.GetMaxCredentialsExpiry(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["otp_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("otp_enabled"))
		if err := fv(ctx, m.GetOtpEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["otp_status"]; exists {

		vOpts := append(opts, db.WithValidateField("otp_status"))
		if err := fv(ctx, m.GetOtpStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["scim_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("scim_enabled"))
		if err := fv(ctx, m.GetScimEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sso_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("sso_enabled"))
		if err := fv(ctx, m.GetSsoEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["validation_errors"]; exists {

		vOpts := append(opts, db.WithValidateField("validation_errors"))
		for idx, item := range m.GetValidationErrors() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUpdateTenantSettingsResponseValidator = func() *ValidateUpdateTenantSettingsResponse {
	v := &ValidateUpdateTenantSettingsResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UpdateTenantSettingsResponseValidator() db.Validator {
	return DefaultUpdateTenantSettingsResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *User) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *User) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *User) DeepCopy() *User {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &User{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *User) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *User) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UserValidator().Validate(ctx, m, opts...)
}

type ValidateUser struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUser) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*User)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *User got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["email"]; exists {

		vOpts := append(opts, db.WithValidateField("email"))
		if err := fv(ctx, m.GetEmail(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUserValidator = func() *ValidateUser {
	v := &ValidateUser{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UserValidator() db.Validator {
	return DefaultUserValidator
}

// augmented methods on protoc/std generated struct

func (m *UserList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UserList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UserList) DeepCopy() *UserList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UserList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UserList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UserList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UserListValidator().Validate(ctx, m, opts...)
}

type ValidateUserList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUserList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UserList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UserList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["users"]; exists {

		vOpts := append(opts, db.WithValidateField("users"))
		for idx, item := range m.GetUsers() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUserListValidator = func() *ValidateUserList {
	v := &ValidateUserList{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UserListValidator() db.Validator {
	return DefaultUserListValidator
}

// augmented methods on protoc/std generated struct

func (m *ValidationErrorField) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ValidationErrorField) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ValidationErrorField) DeepCopy() *ValidationErrorField {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ValidationErrorField{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ValidationErrorField) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ValidationErrorField) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ValidationErrorFieldValidator().Validate(ctx, m, opts...)
}

type ValidateValidationErrorField struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateValidationErrorField) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ValidationErrorField)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ValidationErrorField got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["error_field"]; exists {

		vOpts := append(opts, db.WithValidateField("error_field"))
		if err := fv(ctx, m.GetErrorField(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["error_message"]; exists {

		vOpts := append(opts, db.WithValidateField("error_message"))
		if err := fv(ctx, m.GetErrorMessage(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultValidationErrorFieldValidator = func() *ValidateValidationErrorField {
	v := &ValidateValidationErrorField{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ValidationErrorFieldValidator() db.Validator {
	return DefaultValidationErrorFieldValidator
}
