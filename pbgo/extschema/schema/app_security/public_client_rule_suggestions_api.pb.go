// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/app_security/public_client_rule_suggestions_api.proto

// Application Security Monitoring APIs
//
// x-displayName: "Application Security Monitoring APIs"
// APIs to get application security events and metrics on virtual-host basis.
// Security events may be generated for following reasons:
// 1. Service policy hits with action "deny"
// 2. Rate limiting
// 3. Javascript challenge failure

package app_security

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/app_security/metrics"
	policy "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/policy"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/vesenv"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	common_security "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/common_security"
	common_waf "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/common_waf"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views/http_loadbalancer"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// GetSuggestedBlockClientRuleReq
//
// x-displayName: "Get Suggested Block Client Rule Request"
// Get suggested blocking SimpleClientSrcRule for a given IP/ASN
type GetSuggestedBlockClientRuleReq struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "shared"
	// Namespace of the App type for current request
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Name
	//
	// x-displayName: "HTTP Load Balancer Name"
	// x-example: "ves-io-frontend"
	// HTTP load balancer for which this WAF exclusion will be applied
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// ip prefix
	//
	// x-displayName: "IP Prefix"
	// x-example: "192.168.20.0/24"
	// x-required
	// IP prefix string.
	IpPrefix string `protobuf:"bytes,4,opt,name=ip_prefix,json=ipPrefix,proto3" json:"ip_prefix,omitempty"`
	// as number
	//
	// x-displayName: "AS Number"
	// x-required
	// x-example: "4683"
	// RFC 6793 defined 4-byte AS number
	AsNumber uint32 `protobuf:"varint,5,opt,name=as_number,json=asNumber,proto3" json:"as_number,omitempty"`
	// Description
	//
	// x-displayName: "AS Description"
	// x-example: "as-description"
	// AS description
	AsDescription string `protobuf:"bytes,6,opt,name=as_description,json=asDescription,proto3" json:"as_description,omitempty"`
	// user id
	//
	// x-displayName: "User Id"
	// x-example: "abc"
	// User id of blocked client.
	UserId string `protobuf:"bytes,7,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *GetSuggestedBlockClientRuleReq) Reset()      { *m = GetSuggestedBlockClientRuleReq{} }
func (*GetSuggestedBlockClientRuleReq) ProtoMessage() {}
func (*GetSuggestedBlockClientRuleReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_f85284fe14c5efa1, []int{0}
}
func (m *GetSuggestedBlockClientRuleReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSuggestedBlockClientRuleReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSuggestedBlockClientRuleReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSuggestedBlockClientRuleReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSuggestedBlockClientRuleReq.Merge(m, src)
}
func (m *GetSuggestedBlockClientRuleReq) XXX_Size() int {
	return m.Size()
}
func (m *GetSuggestedBlockClientRuleReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSuggestedBlockClientRuleReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetSuggestedBlockClientRuleReq proto.InternalMessageInfo

func (m *GetSuggestedBlockClientRuleReq) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *GetSuggestedBlockClientRuleReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetSuggestedBlockClientRuleReq) GetIpPrefix() string {
	if m != nil {
		return m.IpPrefix
	}
	return ""
}

func (m *GetSuggestedBlockClientRuleReq) GetAsNumber() uint32 {
	if m != nil {
		return m.AsNumber
	}
	return 0
}

func (m *GetSuggestedBlockClientRuleReq) GetAsDescription() string {
	if m != nil {
		return m.AsDescription
	}
	return ""
}

func (m *GetSuggestedBlockClientRuleReq) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

// GetSuggestedBlockClientRuleRsp
//
// x-displayName: "Get Suggested Block Client Rule Response"
// Get suggested blocking SimpleClientSrcRule for a given IP/ASN
type GetSuggestedBlockClientRuleRsp struct {
	// SimpleClientSrcRule
	//
	// x-displayName: "Simple Client Source Rule"
	// Simple client source rule specifies the IP/ASN to be blocked
	Rule *common_waf.SimpleClientSrcRule `protobuf:"bytes,1,opt,name=rule,proto3" json:"rule,omitempty"`
	// Name
	//
	// x-displayName: "HTTP Load Balancer Name"
	// x-example: "ves-io-frontend"
	// HTTP load balancer for which this WAF exclusion will be applied
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// FoundExistingRule
	//
	// x-displayName: "Found existing rule"
	// Specifies if an existing rule to block this client already exists with same match conditions
	FoundExistingRule *schema.Empty `protobuf:"bytes,3,opt,name=found_existing_rule,json=foundExistingRule,proto3" json:"found_existing_rule,omitempty"`
}

func (m *GetSuggestedBlockClientRuleRsp) Reset()      { *m = GetSuggestedBlockClientRuleRsp{} }
func (*GetSuggestedBlockClientRuleRsp) ProtoMessage() {}
func (*GetSuggestedBlockClientRuleRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_f85284fe14c5efa1, []int{1}
}
func (m *GetSuggestedBlockClientRuleRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSuggestedBlockClientRuleRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSuggestedBlockClientRuleRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSuggestedBlockClientRuleRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSuggestedBlockClientRuleRsp.Merge(m, src)
}
func (m *GetSuggestedBlockClientRuleRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetSuggestedBlockClientRuleRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSuggestedBlockClientRuleRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetSuggestedBlockClientRuleRsp proto.InternalMessageInfo

func (m *GetSuggestedBlockClientRuleRsp) GetRule() *common_waf.SimpleClientSrcRule {
	if m != nil {
		return m.Rule
	}
	return nil
}

func (m *GetSuggestedBlockClientRuleRsp) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetSuggestedBlockClientRuleRsp) GetFoundExistingRule() *schema.Empty {
	if m != nil {
		return m.FoundExistingRule
	}
	return nil
}

// GetSuggestedTrustClientRuleReq
//
// x-displayName: "Get Suggested Trust Client Rule Request"
// Get suggested blocking SimpleClientSrcRule for a given IP/ASN
type GetSuggestedTrustClientRuleReq struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "shared"
	// Namespace of the App type for current request
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Name
	//
	// x-displayName: "HTTP Load Balancer Name"
	// x-example: "ves-io-frontend"
	// HTTP load balancer for which this client blocking rule will be applied
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// ip prefix
	//
	// x-displayName: "IP Prefix"
	// x-example: "192.168.20.0/24"
	// x-required
	// IP prefix string.
	IpPrefix string `protobuf:"bytes,4,opt,name=ip_prefix,json=ipPrefix,proto3" json:"ip_prefix,omitempty"`
	// as number
	//
	// x-displayName: "AS Number"
	// x-required
	// x-example: "4683"
	// RFC 6793 defined 4-byte AS number
	AsNumber uint32 `protobuf:"varint,5,opt,name=as_number,json=asNumber,proto3" json:"as_number,omitempty"`
	// Description
	//
	// x-displayName: "AS Description"
	// x-example: "as-description"
	// AS description
	AsDescription string `protobuf:"bytes,6,opt,name=as_description,json=asDescription,proto3" json:"as_description,omitempty"`
	// Security Event Types
	//
	// x-displayName: "Security Event Types"
	// x-example: "[WAF_SEC_EVENT]"
	// List of Security Event types that should stop being generated for this client
	SecEventTypes []SecEventType `protobuf:"varint,7,rep,packed,name=sec_event_types,json=secEventTypes,proto3,enum=ves.io.schema.app_security.SecEventType" json:"sec_event_types,omitempty"`
	// user id
	//
	// x-displayName: "User Id"
	// x-example: "abc"
	// User id of trusted client.
	UserId string `protobuf:"bytes,8,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// Security Event Name
	//
	// x-displayName: "Security Event Name"
	// x-example: "Malicious User Mitigation"
	// The name of Security Event
	SecEventName string `protobuf:"bytes,10,opt,name=sec_event_name,json=secEventName,proto3" json:"sec_event_name,omitempty"`
	// IP Reputation Security Event
	//
	// x-displayName: "IP Reputation Security Event"
	// x-example: "true"
	// Indicates whether the security event is ip reputation
	IpReputation bool `protobuf:"varint,11,opt,name=ip_reputation,json=ipReputation,proto3" json:"ip_reputation,omitempty"`
	// Threat Mesh Security Event
	//
	// x-displayName: "Threat Mesh Security Event"
	// x-example: "true"
	// Indicates whether the security event is threat mesh
	ThreatMesh bool `protobuf:"varint,12,opt,name=threat_mesh,json=threatMesh,proto3" json:"threat_mesh,omitempty"`
}

func (m *GetSuggestedTrustClientRuleReq) Reset()      { *m = GetSuggestedTrustClientRuleReq{} }
func (*GetSuggestedTrustClientRuleReq) ProtoMessage() {}
func (*GetSuggestedTrustClientRuleReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_f85284fe14c5efa1, []int{2}
}
func (m *GetSuggestedTrustClientRuleReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSuggestedTrustClientRuleReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSuggestedTrustClientRuleReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSuggestedTrustClientRuleReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSuggestedTrustClientRuleReq.Merge(m, src)
}
func (m *GetSuggestedTrustClientRuleReq) XXX_Size() int {
	return m.Size()
}
func (m *GetSuggestedTrustClientRuleReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSuggestedTrustClientRuleReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetSuggestedTrustClientRuleReq proto.InternalMessageInfo

func (m *GetSuggestedTrustClientRuleReq) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *GetSuggestedTrustClientRuleReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetSuggestedTrustClientRuleReq) GetIpPrefix() string {
	if m != nil {
		return m.IpPrefix
	}
	return ""
}

func (m *GetSuggestedTrustClientRuleReq) GetAsNumber() uint32 {
	if m != nil {
		return m.AsNumber
	}
	return 0
}

func (m *GetSuggestedTrustClientRuleReq) GetAsDescription() string {
	if m != nil {
		return m.AsDescription
	}
	return ""
}

func (m *GetSuggestedTrustClientRuleReq) GetSecEventTypes() []SecEventType {
	if m != nil {
		return m.SecEventTypes
	}
	return nil
}

func (m *GetSuggestedTrustClientRuleReq) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *GetSuggestedTrustClientRuleReq) GetSecEventName() string {
	if m != nil {
		return m.SecEventName
	}
	return ""
}

func (m *GetSuggestedTrustClientRuleReq) GetIpReputation() bool {
	if m != nil {
		return m.IpReputation
	}
	return false
}

func (m *GetSuggestedTrustClientRuleReq) GetThreatMesh() bool {
	if m != nil {
		return m.ThreatMesh
	}
	return false
}

// GetSuggestedTrustClientRuleRsp
//
// x-displayName: "Get Suggested Trust Client Rule Response"
// Get suggested SimpleClientSrcRule to trust a given IP/ASN
type GetSuggestedTrustClientRuleRsp struct {
	// SimpleClientSrcRule
	//
	// x-displayName: "Simple Client Source Rule"
	// Simple client source rule specifies the IP/ASN to be trusted
	Rule *common_waf.SimpleClientSrcRule `protobuf:"bytes,1,opt,name=rule,proto3" json:"rule,omitempty"`
	// Name
	//
	// x-displayName: "HTTP Load Balancer Name"
	// x-example: "ves-io-frontend"
	// HTTP load balancer for which this client rule will be applied
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// FoundExistingRule
	//
	// x-displayName: "Found existing rule"
	// Specifies if an existing rule to trust this client already exists with same match conditions
	FoundExistingRule *schema.Empty `protobuf:"bytes,3,opt,name=found_existing_rule,json=foundExistingRule,proto3" json:"found_existing_rule,omitempty"`
}

func (m *GetSuggestedTrustClientRuleRsp) Reset()      { *m = GetSuggestedTrustClientRuleRsp{} }
func (*GetSuggestedTrustClientRuleRsp) ProtoMessage() {}
func (*GetSuggestedTrustClientRuleRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_f85284fe14c5efa1, []int{3}
}
func (m *GetSuggestedTrustClientRuleRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSuggestedTrustClientRuleRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSuggestedTrustClientRuleRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSuggestedTrustClientRuleRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSuggestedTrustClientRuleRsp.Merge(m, src)
}
func (m *GetSuggestedTrustClientRuleRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetSuggestedTrustClientRuleRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSuggestedTrustClientRuleRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetSuggestedTrustClientRuleRsp proto.InternalMessageInfo

func (m *GetSuggestedTrustClientRuleRsp) GetRule() *common_waf.SimpleClientSrcRule {
	if m != nil {
		return m.Rule
	}
	return nil
}

func (m *GetSuggestedTrustClientRuleRsp) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetSuggestedTrustClientRuleRsp) GetFoundExistingRule() *schema.Empty {
	if m != nil {
		return m.FoundExistingRule
	}
	return nil
}

// GetSuggestedDDoSMitigtionRuleReq
//
// x-displayName: "Get Suggested DDoS Mitigtion Rule Request"
// Get suggested blocking DDoSMitigtionRule for a given IP/ASN/Country/TLS
type GetSuggestedDDoSMitigtionRuleReq struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "shared"
	// Namespace of the App type for current request
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Name
	//
	// x-displayName: "Load Balancer Name"
	// x-example: "ves-io-frontend"
	// load balancer for which this WAF exclusion will be applied
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// prefix_list
	//
	// x-displayName: "IPv4 Prefix List"
	// Addresses that are covered by the given list of IPv4 prefixes
	IpPrefixList *policy.PrefixMatchList `protobuf:"bytes,3,opt,name=ip_prefix_list,json=ipPrefixList,proto3" json:"ip_prefix_list,omitempty"`
	// asn_list
	//
	// x-displayName: "ASN List"
	// Addresses that belong to the ASNs in the given list
	// The ASN is obtained by performing a lookup for the source IPv4 Address in a GeoIP DB.
	AsnList *policy.AsnMatchList `protobuf:"bytes,4,opt,name=asn_list,json=asnList,proto3" json:"asn_list,omitempty"`
	// country_list
	//
	// x-displayName: "Country List"
	// Sources that are located in one of the countries in the given list
	CountryList []policy.CountryCode `protobuf:"varint,5,rep,packed,name=country_list,json=countryList,proto3,enum=ves.io.schema.policy.CountryCode" json:"country_list,omitempty"`
	// TLS JA3 fingerprint matcher
	//
	// x-displayName: "JA3 TLS Fingerprint Matcher"
	// TLS JA3 fingerprints to be matched.
	// The predicate evaluates to true if the TLS fingerprint matches any of the exact values or classes of known TLS fingerprints.
	TlsFingerprintMatcher *policy.TlsFingerprintMatcherType `protobuf:"bytes,6,opt,name=tls_fingerprint_matcher,json=tlsFingerprintMatcher,proto3" json:"tls_fingerprint_matcher,omitempty"`
	// TLS JA4 fingerprint matcher
	//
	// x-displayName: "JA4 TLS Fingerprint Matcher"
	// TLS JA4 fingerprints to be matched.
	// The predicate evaluates to true if source JA4 TLS fingerprint matches any of the exact values of JA4 TLS fingerprints.
	Ja4TlsFingerprintMatcher *policy.JA4TlsFingerprintMatcherType `protobuf:"bytes,7,opt,name=ja4_tls_fingerprint_matcher,json=ja4TlsFingerprintMatcher,proto3" json:"ja4_tls_fingerprint_matcher,omitempty"`
}

func (m *GetSuggestedDDoSMitigtionRuleReq) Reset()      { *m = GetSuggestedDDoSMitigtionRuleReq{} }
func (*GetSuggestedDDoSMitigtionRuleReq) ProtoMessage() {}
func (*GetSuggestedDDoSMitigtionRuleReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_f85284fe14c5efa1, []int{4}
}
func (m *GetSuggestedDDoSMitigtionRuleReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSuggestedDDoSMitigtionRuleReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSuggestedDDoSMitigtionRuleReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSuggestedDDoSMitigtionRuleReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSuggestedDDoSMitigtionRuleReq.Merge(m, src)
}
func (m *GetSuggestedDDoSMitigtionRuleReq) XXX_Size() int {
	return m.Size()
}
func (m *GetSuggestedDDoSMitigtionRuleReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSuggestedDDoSMitigtionRuleReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetSuggestedDDoSMitigtionRuleReq proto.InternalMessageInfo

func (m *GetSuggestedDDoSMitigtionRuleReq) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *GetSuggestedDDoSMitigtionRuleReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetSuggestedDDoSMitigtionRuleReq) GetIpPrefixList() *policy.PrefixMatchList {
	if m != nil {
		return m.IpPrefixList
	}
	return nil
}

func (m *GetSuggestedDDoSMitigtionRuleReq) GetAsnList() *policy.AsnMatchList {
	if m != nil {
		return m.AsnList
	}
	return nil
}

func (m *GetSuggestedDDoSMitigtionRuleReq) GetCountryList() []policy.CountryCode {
	if m != nil {
		return m.CountryList
	}
	return nil
}

func (m *GetSuggestedDDoSMitigtionRuleReq) GetTlsFingerprintMatcher() *policy.TlsFingerprintMatcherType {
	if m != nil {
		return m.TlsFingerprintMatcher
	}
	return nil
}

func (m *GetSuggestedDDoSMitigtionRuleReq) GetJa4TlsFingerprintMatcher() *policy.JA4TlsFingerprintMatcherType {
	if m != nil {
		return m.Ja4TlsFingerprintMatcher
	}
	return nil
}

// GetSuggestedDDoSMitigtionRuleRsp
//
// x-displayName: "Get Suggested DDoS Mitigtion Rule Response"
// Get suggested DDoS Mitigtion Rule for a given IP/ASN/Country/TLS
type GetSuggestedDDoSMitigtionRuleRsp struct {
	// mitigation_rule
	//
	// x-displayName: "DDoS Mitigation Rule"
	// Service policy rule specifies the IP/ASN/Region/TLS to be blocked
	MitigationRule *common_security.DDoSMitigationRule `protobuf:"bytes,1,opt,name=mitigation_rule,json=mitigationRule,proto3" json:"mitigation_rule,omitempty"`
	// Name
	//
	// x-displayName: "DDoS Mitigation Rule Name"
	// x-example: "ves-io-ddos-mitigation-rule"
	// HTTP load balancer for which this DDoS Mitigation Rule will be applied
	MitigationRuleName string `protobuf:"bytes,2,opt,name=mitigation_rule_name,json=mitigationRuleName,proto3" json:"mitigation_rule_name,omitempty"`
	// FoundExistingRule
	//
	// x-displayName: "Found existing rule"
	// Specifies if an existing rule to block this client already exists with same match conditions
	FoundExistingMitigationRule *schema.Empty `protobuf:"bytes,3,opt,name=found_existing_mitigation_rule,json=foundExistingMitigationRule,proto3" json:"found_existing_mitigation_rule,omitempty"`
}

func (m *GetSuggestedDDoSMitigtionRuleRsp) Reset()      { *m = GetSuggestedDDoSMitigtionRuleRsp{} }
func (*GetSuggestedDDoSMitigtionRuleRsp) ProtoMessage() {}
func (*GetSuggestedDDoSMitigtionRuleRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_f85284fe14c5efa1, []int{5}
}
func (m *GetSuggestedDDoSMitigtionRuleRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSuggestedDDoSMitigtionRuleRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSuggestedDDoSMitigtionRuleRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSuggestedDDoSMitigtionRuleRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSuggestedDDoSMitigtionRuleRsp.Merge(m, src)
}
func (m *GetSuggestedDDoSMitigtionRuleRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetSuggestedDDoSMitigtionRuleRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSuggestedDDoSMitigtionRuleRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetSuggestedDDoSMitigtionRuleRsp proto.InternalMessageInfo

func (m *GetSuggestedDDoSMitigtionRuleRsp) GetMitigationRule() *common_security.DDoSMitigationRule {
	if m != nil {
		return m.MitigationRule
	}
	return nil
}

func (m *GetSuggestedDDoSMitigtionRuleRsp) GetMitigationRuleName() string {
	if m != nil {
		return m.MitigationRuleName
	}
	return ""
}

func (m *GetSuggestedDDoSMitigtionRuleRsp) GetFoundExistingMitigationRule() *schema.Empty {
	if m != nil {
		return m.FoundExistingMitigationRule
	}
	return nil
}

func init() {
	proto.RegisterType((*GetSuggestedBlockClientRuleReq)(nil), "ves.io.schema.app_security.GetSuggestedBlockClientRuleReq")
	golang_proto.RegisterType((*GetSuggestedBlockClientRuleReq)(nil), "ves.io.schema.app_security.GetSuggestedBlockClientRuleReq")
	proto.RegisterType((*GetSuggestedBlockClientRuleRsp)(nil), "ves.io.schema.app_security.GetSuggestedBlockClientRuleRsp")
	golang_proto.RegisterType((*GetSuggestedBlockClientRuleRsp)(nil), "ves.io.schema.app_security.GetSuggestedBlockClientRuleRsp")
	proto.RegisterType((*GetSuggestedTrustClientRuleReq)(nil), "ves.io.schema.app_security.GetSuggestedTrustClientRuleReq")
	golang_proto.RegisterType((*GetSuggestedTrustClientRuleReq)(nil), "ves.io.schema.app_security.GetSuggestedTrustClientRuleReq")
	proto.RegisterType((*GetSuggestedTrustClientRuleRsp)(nil), "ves.io.schema.app_security.GetSuggestedTrustClientRuleRsp")
	golang_proto.RegisterType((*GetSuggestedTrustClientRuleRsp)(nil), "ves.io.schema.app_security.GetSuggestedTrustClientRuleRsp")
	proto.RegisterType((*GetSuggestedDDoSMitigtionRuleReq)(nil), "ves.io.schema.app_security.GetSuggestedDDoSMitigtionRuleReq")
	golang_proto.RegisterType((*GetSuggestedDDoSMitigtionRuleReq)(nil), "ves.io.schema.app_security.GetSuggestedDDoSMitigtionRuleReq")
	proto.RegisterType((*GetSuggestedDDoSMitigtionRuleRsp)(nil), "ves.io.schema.app_security.GetSuggestedDDoSMitigtionRuleRsp")
	golang_proto.RegisterType((*GetSuggestedDDoSMitigtionRuleRsp)(nil), "ves.io.schema.app_security.GetSuggestedDDoSMitigtionRuleRsp")
}

func init() {
	proto.RegisterFile("ves.io/schema/app_security/public_client_rule_suggestions_api.proto", fileDescriptor_f85284fe14c5efa1)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/app_security/public_client_rule_suggestions_api.proto", fileDescriptor_f85284fe14c5efa1)
}

var fileDescriptor_f85284fe14c5efa1 = []byte{
	// 1310 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x58, 0xcd, 0x6f, 0xdc, 0x44,
	0x14, 0x8f, 0x37, 0xdb, 0x7c, 0x4c, 0x3e, 0x5a, 0x4c, 0x51, 0xcd, 0xa6, 0x72, 0xd3, 0x6d, 0x81,
	0xa8, 0x62, 0x6d, 0x9a, 0xb6, 0x80, 0x2a, 0x90, 0xc8, 0x47, 0x5b, 0x15, 0x48, 0x1b, 0xed, 0x06,
	0x01, 0xbd, 0x98, 0x59, 0x7b, 0xd6, 0x3b, 0xad, 0xed, 0x99, 0xce, 0x8c, 0xd3, 0x44, 0xa8, 0x52,
	0xd5, 0x23, 0x07, 0xc4, 0xa7, 0xe8, 0x81, 0x3f, 0xa0, 0x17, 0x2e, 0x5c, 0x90, 0x28, 0x12, 0x95,
	0x38, 0xc0, 0x09, 0x15, 0xb8, 0xf4, 0x48, 0x37, 0x1c, 0xe0, 0xd6, 0x7f, 0x00, 0x09, 0x79, 0xbc,
	0xd9, 0xb5, 0x9d, 0x8d, 0x9b, 0x26, 0x48, 0x11, 0xdc, 0xc6, 0xf3, 0xde, 0xfb, 0xbd, 0x37, 0xbf,
	0xf9, 0xbd, 0x99, 0xd9, 0x05, 0x73, 0xcb, 0x88, 0x1b, 0x98, 0x98, 0xdc, 0x6e, 0x22, 0x1f, 0x9a,
	0x90, 0x52, 0x8b, 0x23, 0x3b, 0x64, 0x58, 0xac, 0x9a, 0x34, 0xac, 0x7b, 0xd8, 0xb6, 0x6c, 0x0f,
	0xa3, 0x40, 0x58, 0x2c, 0xf4, 0x90, 0xc5, 0x43, 0xd7, 0x45, 0x5c, 0x60, 0x12, 0x70, 0x0b, 0x52,
	0x6c, 0x50, 0x46, 0x04, 0x51, 0x4b, 0x31, 0x88, 0x11, 0x83, 0x18, 0x49, 0x90, 0x52, 0xc5, 0xc5,
	0xa2, 0x19, 0xd6, 0x0d, 0x9b, 0xf8, 0xa6, 0x4b, 0x5c, 0x62, 0xca, 0x90, 0x7a, 0xd8, 0x90, 0x5f,
	0xf2, 0x43, 0x8e, 0x62, 0xa8, 0xd2, 0x41, 0x97, 0x10, 0xd7, 0x43, 0x26, 0xa4, 0xd8, 0x84, 0x41,
	0x40, 0x04, 0x94, 0xc9, 0xda, 0x56, 0x23, 0xa7, 0x5a, 0x1f, 0x09, 0x86, 0x6d, 0x6e, 0x8a, 0x55,
	0x8a, 0xd6, 0xfd, 0x9f, 0xcd, 0xf1, 0x4f, 0xfa, 0x1d, 0x48, 0xfb, 0x05, 0x48, 0xb4, 0x0d, 0x13,
	0x69, 0x03, 0xa1, 0xc9, 0x6a, 0x26, 0xd3, 0x46, 0x4a, 0x3c, 0x6c, 0xa7, 0x71, 0x9f, 0x4e, 0x7b,
	0x24, 0x4d, 0x07, 0xd3, 0xa6, 0x65, 0xe8, 0x61, 0x07, 0x0a, 0xd4, 0xb6, 0x96, 0x33, 0x56, 0xc4,
	0x51, 0xb0, 0x9c, 0x49, 0xff, 0x72, 0xc6, 0x07, 0xa3, 0x6b, 0xdc, 0xb4, 0x89, 0xef, 0x93, 0xa0,
	0xbb, 0xca, 0xf5, 0x81, 0x95, 0xcc, 0x7d, 0x2a, 0x27, 0xf2, 0x1a, 0x6c, 0x24, 0x86, 0xa9, 0xb0,
	0xe3, 0xbd, 0xc2, 0x9a, 0x42, 0x50, 0xcb, 0x23, 0xd0, 0xa9, 0x43, 0x0f, 0x06, 0x36, 0x62, 0xa9,
	0x55, 0x1e, 0xea, 0x15, 0x92, 0x70, 0x28, 0xff, 0xad, 0x00, 0xfd, 0x1c, 0x12, 0xb5, 0x58, 0x57,
	0xc8, 0x99, 0xf5, 0x88, 0x7d, 0x65, 0x4e, 0x2a, 0xae, 0x1a, 0x7a, 0xa8, 0x8a, 0xae, 0xaa, 0x07,
	0xc1, 0x70, 0x00, 0x7d, 0xc4, 0x29, 0xb4, 0x91, 0xa6, 0x4c, 0x2a, 0x53, 0xc3, 0xd5, 0xee, 0x84,
	0xaa, 0x82, 0x62, 0xf4, 0xa1, 0x15, 0xa4, 0x41, 0x8e, 0xd5, 0xe7, 0xc0, 0x30, 0xa6, 0x16, 0x65,
	0xa8, 0x81, 0x57, 0xb4, 0x62, 0x64, 0x98, 0x05, 0xdf, 0xfe, 0x75, 0xb7, 0x7f, 0x0f, 0xeb, 0xbf,
	0xad, 0x28, 0xd5, 0x21, 0x4c, 0x17, 0xa5, 0x4d, 0x9d, 0x02, 0xc3, 0x90, 0x5b, 0x41, 0xe8, 0xd7,
	0x11, 0xd3, 0xf6, 0x4c, 0x2a, 0x53, 0x63, 0xb3, 0x23, 0x91, 0xe3, 0xc0, 0xb1, 0xa2, 0xf6, 0xe5,
	0xf7, 0x5a, 0x75, 0x08, 0xf2, 0x0b, 0xd2, 0xa8, 0x1e, 0x07, 0xe3, 0x90, 0x5b, 0x0e, 0xe2, 0x36,
	0xc3, 0x72, 0x17, 0xb4, 0x81, 0x14, 0xae, 0x76, 0xa3, 0x50, 0x1d, 0x83, 0x7c, 0xbe, 0xeb, 0xa0,
	0x1e, 0x01, 0x83, 0x21, 0x47, 0xcc, 0xc2, 0x8e, 0x36, 0xb8, 0xc1, 0x77, 0x20, 0x32, 0x9d, 0x77,
	0xca, 0x3f, 0x3c, 0x62, 0xfd, 0x9c, 0xaa, 0xe7, 0x40, 0x31, 0xea, 0x3d, 0xb9, 0xf4, 0x91, 0xe9,
	0x13, 0x46, 0xba, 0xd9, 0x24, 0xa5, 0x46, 0x77, 0xc7, 0x8c, 0x1a, 0xf6, 0xa9, 0x87, 0x62, 0x88,
	0x1a, 0xb3, 0x25, 0x8a, 0x04, 0xe8, 0x49, 0xd5, 0x3c, 0x78, 0xb2, 0x41, 0xc2, 0xc0, 0xb1, 0xd0,
	0x0a, 0xe6, 0x02, 0x07, 0xae, 0xec, 0x73, 0xad, 0x5f, 0xe6, 0xda, 0x9f, 0xc9, 0x75, 0xc6, 0xa7,
	0x62, 0xb5, 0xfa, 0x84, 0x0c, 0x38, 0xd3, 0xf6, 0x8f, 0xf0, 0xcb, 0xbf, 0xf4, 0xa7, 0x57, 0xb1,
	0xc4, 0x42, 0x2e, 0xfe, 0x1f, 0xbb, 0xd8, 0x00, 0x7b, 0x39, 0xb2, 0x2d, 0xb4, 0x1c, 0x9d, 0x81,
	0x52, 0xb9, 0xda, 0xe0, 0x64, 0xff, 0xd4, 0xf8, 0xf4, 0x94, 0xb1, 0xf9, 0xa9, 0x67, 0xd4, 0x90,
	0x7d, 0x26, 0x8a, 0x58, 0x5a, 0xa5, 0x68, 0x76, 0xbf, 0x44, 0xff, 0x44, 0x29, 0xec, 0x2b, 0xae,
	0x8f, 0x34, 0xa5, 0x3a, 0xc6, 0x13, 0x3e, 0x3c, 0xa9, 0x96, 0xa1, 0xcd, 0xd4, 0xa2, 0x1e, 0x05,
	0xe3, 0xdd, 0x62, 0x24, 0x61, 0x40, 0x12, 0x36, 0xba, 0x8e, 0x75, 0x21, 0x22, 0xee, 0x08, 0x18,
	0xc3, 0xd4, 0x62, 0x88, 0x86, 0xf1, 0xe9, 0xa9, 0x8d, 0x4c, 0x2a, 0x53, 0x43, 0xd5, 0x51, 0x4c,
	0xab, 0x9d, 0x39, 0xf5, 0x10, 0x18, 0x11, 0x4d, 0x86, 0xa0, 0xb0, 0x7c, 0xc4, 0x9b, 0xda, 0xa8,
	0x74, 0x01, 0xf1, 0xd4, 0x02, 0xe2, 0xcd, 0x0d, 0xca, 0xcc, 0xee, 0xe9, 0x7f, 0x43, 0x99, 0xb7,
	0x8a, 0x60, 0x32, 0xb9, 0x8a, 0xf9, 0x79, 0x52, 0x5b, 0xc0, 0x02, 0xbb, 0x11, 0x09, 0xdb, 0xd7,
	0xe6, 0x1b, 0x60, 0xbc, 0xa3, 0x4d, 0xcb, 0xc3, 0x5c, 0xb4, 0xeb, 0x7a, 0x26, 0x53, 0x57, 0x7c,
	0x27, 0x18, 0xb1, 0x50, 0x17, 0xa0, 0xb0, 0x9b, 0x6f, 0x62, 0x2e, 0xa2, 0xad, 0x88, 0xa7, 0xa2,
	0x2f, 0xf5, 0x55, 0x30, 0x04, 0x79, 0x10, 0xc3, 0x14, 0x25, 0x4c, 0xb9, 0x37, 0xcc, 0x0c, 0x0f,
	0xba, 0x18, 0x83, 0x90, 0x07, 0x32, 0xfc, 0x12, 0x18, 0xb5, 0x49, 0x18, 0x08, 0xb6, 0x1a, 0x43,
	0xec, 0x91, 0xf2, 0x3c, 0xdc, 0x1b, 0x62, 0x2e, 0xf6, 0x9c, 0x23, 0x4e, 0x52, 0x97, 0xaf, 0x25,
	0x74, 0x39, 0xd2, 0x06, 0x93, 0xd8, 0x2e, 0x38, 0x20, 0x3c, 0x6e, 0x35, 0x70, 0xe0, 0x22, 0x46,
	0x19, 0x0e, 0x84, 0xe5, 0x47, 0x15, 0x20, 0x26, 0x3b, 0x67, 0x64, 0xda, 0xec, 0x9d, 0x66, 0xc9,
	0xe3, 0x67, 0xbb, 0x31, 0x0b, 0x71, 0x48, 0x24, 0xf4, 0xea, 0x53, 0xa2, 0x97, 0x49, 0xbd, 0x0a,
	0x26, 0x2e, 0xc3, 0x93, 0xd6, 0x66, 0xc9, 0x06, 0x65, 0xb2, 0xe9, 0xde, 0xc9, 0x5e, 0x9f, 0x39,
	0xb9, 0x79, 0x3e, 0xed, 0x32, 0xec, 0x6d, 0x2d, 0x7f, 0x5c, 0x78, 0x94, 0x34, 0x38, 0x55, 0xdf,
	0x03, 0x7b, 0xfd, 0x68, 0x4e, 0x36, 0x8d, 0x95, 0x50, 0xfb, 0x4b, 0x79, 0x6a, 0xef, 0x9c, 0x03,
	0x1d, 0x4c, 0xd8, 0x01, 0x1d, 0xf7, 0x53, 0xdf, 0xea, 0x0b, 0x60, 0x7f, 0x26, 0x83, 0x95, 0x90,
	0x9b, 0x9a, 0xf6, 0x96, 0xfd, 0xfd, 0x2e, 0xd0, 0x33, 0x9d, 0x91, 0x2d, 0x31, 0xaf, 0x49, 0x26,
	0x52, 0x4d, 0x92, 0x2e, 0x6e, 0xfa, 0xc3, 0xbd, 0x40, 0x9b, 0xa1, 0xb4, 0xd6, 0xae, 0xbf, 0xdb,
	0xee, 0x33, 0x8b, 0xe7, 0xd5, 0xaf, 0x0a, 0x60, 0x22, 0xe7, 0xae, 0x52, 0x4f, 0xe7, 0x9d, 0x88,
	0xf9, 0x97, 0x7c, 0x69, 0xdb, 0xb1, 0x9c, 0x96, 0x3f, 0x57, 0x5a, 0x3f, 0x6a, 0x2f, 0x36, 0x4e,
	0xad, 0xd8, 0x95, 0x6b, 0x10, 0xd2, 0x0a, 0x17, 0x30, 0x70, 0x20, 0x73, 0x2a, 0x3e, 0x09, 0xb0,
	0x20, 0xec, 0xf9, 0xe8, 0xa1, 0x56, 0xc1, 0xa4, 0x42, 0x19, 0x59, 0x59, 0xad, 0xac, 0xc3, 0x56,
	0x18, 0x82, 0xce, 0xcd, 0xdf, 0xfe, 0xf8, 0xb4, 0xf0, 0x56, 0x79, 0xb1, 0xfd, 0xd8, 0x35, 0x3b,
	0x6d, 0xcf, 0xcd, 0xf7, 0x3b, 0xe3, 0xeb, 0x1b, 0x5f, 0x39, 0x6d, 0xf3, 0x75, 0xb3, 0x1e, 0xd5,
	0xd3, 0x7e, 0x23, 0x9b, 0xdd, 0xe7, 0xf1, 0x69, 0xe5, 0x98, 0xfa, 0x75, 0x01, 0x1c, 0xce, 0x29,
	0xfd, 0x2c, 0x61, 0x73, 0xf3, 0x17, 0x76, 0x8d, 0xb5, 0xcf, 0x76, 0xca, 0xda, 0x52, 0xf9, 0xe2,
	0x23, 0x58, 0xb3, 0x9d, 0xe0, 0xb1, 0x49, 0xcb, 0x8a, 0x2c, 0x73, 0xed, 0x6c, 0x9d, 0xae, 0x8d,
	0x6f, 0x90, 0xd2, 0xb6, 0x63, 0x77, 0x5b, 0x64, 0x22, 0xaa, 0x67, 0x6b, 0x22, 0xcb, 0x94, 0xfe,
	0xb8, 0x22, 0xfb, 0x97, 0x59, 0xdb, 0x4d, 0x91, 0xe5, 0x90, 0xf6, 0x4d, 0x21, 0xfd, 0xb6, 0xd9,
	0x78, 0x4c, 0xab, 0xaf, 0x6c, 0x75, 0xd5, 0xbd, 0x5e, 0x14, 0xa5, 0x1d, 0x44, 0x73, 0x5a, 0xbe,
	0xb5, 0x55, 0xd6, 0x70, 0xd0, 0x60, 0x90, 0x0b, 0x16, 0xda, 0x22, 0x64, 0xa8, 0xcb, 0xda, 0x3b,
	0xe5, 0xda, 0xb6, 0xb5, 0xe6, 0x38, 0x84, 0x27, 0x2e, 0x94, 0x0c, 0x73, 0xdf, 0x15, 0xc0, 0xd1,
	0x7c, 0xe6, 0xda, 0x8a, 0xdb, 0x4d, 0xfe, 0xbe, 0xd8, 0x29, 0x7f, 0x6f, 0x97, 0xab, 0xdb, 0x55,
	0x5d, 0x2e, 0x7d, 0x25, 0xf3, 0xee, 0x1d, 0xa5, 0xff, 0xd7, 0x3b, 0xca, 0xe1, 0x9c, 0xe5, 0x5d,
	0xac, 0x5f, 0x46, 0xb6, 0xb8, 0xf9, 0xb3, 0x56, 0xd8, 0xa7, 0xcc, 0x7e, 0xa0, 0xdc, 0x7b, 0xa0,
	0xf7, 0xdd, 0x7f, 0xa0, 0xf7, 0x3d, 0x7c, 0xa0, 0x2b, 0x37, 0x5a, 0xba, 0x72, 0xbb, 0xa5, 0x2b,
	0x3f, 0xb5, 0x74, 0xe5, 0x5e, 0x4b, 0x57, 0x7e, 0x6f, 0xe9, 0xca, 0x9f, 0x2d, 0xbd, 0xef, 0x61,
	0x4b, 0x57, 0x3e, 0x5a, 0xd3, 0xfb, 0xee, 0xae, 0xe9, 0xca, 0xbd, 0x35, 0xbd, 0xef, 0xfe, 0x9a,
	0xde, 0x77, 0x69, 0xd1, 0x25, 0xf4, 0x8a, 0x6b, 0x2c, 0x13, 0x4f, 0x20, 0xc6, 0xa0, 0x11, 0x72,
	0x53, 0x0e, 0x1a, 0x84, 0xf9, 0x51, 0xbf, 0x2d, 0x63, 0x07, 0xb1, 0xca, 0xba, 0xd9, 0xa4, 0x75,
	0x97, 0x98, 0x68, 0x45, 0xb4, 0x7f, 0xaa, 0xf7, 0xf8, 0xcb, 0xa4, 0x3e, 0x20, 0x7f, 0xb3, 0x9f,
	0xf8, 0x27, 0x00, 0x00, 0xff, 0xff, 0x75, 0x7d, 0x07, 0x31, 0x35, 0x12, 0x00, 0x00,
}

func (this *GetSuggestedBlockClientRuleReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSuggestedBlockClientRuleReq)
	if !ok {
		that2, ok := that.(GetSuggestedBlockClientRuleReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.IpPrefix != that1.IpPrefix {
		return false
	}
	if this.AsNumber != that1.AsNumber {
		return false
	}
	if this.AsDescription != that1.AsDescription {
		return false
	}
	if this.UserId != that1.UserId {
		return false
	}
	return true
}
func (this *GetSuggestedBlockClientRuleRsp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSuggestedBlockClientRuleRsp)
	if !ok {
		that2, ok := that.(GetSuggestedBlockClientRuleRsp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Rule.Equal(that1.Rule) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.FoundExistingRule.Equal(that1.FoundExistingRule) {
		return false
	}
	return true
}
func (this *GetSuggestedTrustClientRuleReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSuggestedTrustClientRuleReq)
	if !ok {
		that2, ok := that.(GetSuggestedTrustClientRuleReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.IpPrefix != that1.IpPrefix {
		return false
	}
	if this.AsNumber != that1.AsNumber {
		return false
	}
	if this.AsDescription != that1.AsDescription {
		return false
	}
	if len(this.SecEventTypes) != len(that1.SecEventTypes) {
		return false
	}
	for i := range this.SecEventTypes {
		if this.SecEventTypes[i] != that1.SecEventTypes[i] {
			return false
		}
	}
	if this.UserId != that1.UserId {
		return false
	}
	if this.SecEventName != that1.SecEventName {
		return false
	}
	if this.IpReputation != that1.IpReputation {
		return false
	}
	if this.ThreatMesh != that1.ThreatMesh {
		return false
	}
	return true
}
func (this *GetSuggestedTrustClientRuleRsp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSuggestedTrustClientRuleRsp)
	if !ok {
		that2, ok := that.(GetSuggestedTrustClientRuleRsp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Rule.Equal(that1.Rule) {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.FoundExistingRule.Equal(that1.FoundExistingRule) {
		return false
	}
	return true
}
func (this *GetSuggestedDDoSMitigtionRuleReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSuggestedDDoSMitigtionRuleReq)
	if !ok {
		that2, ok := that.(GetSuggestedDDoSMitigtionRuleReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.IpPrefixList.Equal(that1.IpPrefixList) {
		return false
	}
	if !this.AsnList.Equal(that1.AsnList) {
		return false
	}
	if len(this.CountryList) != len(that1.CountryList) {
		return false
	}
	for i := range this.CountryList {
		if this.CountryList[i] != that1.CountryList[i] {
			return false
		}
	}
	if !this.TlsFingerprintMatcher.Equal(that1.TlsFingerprintMatcher) {
		return false
	}
	if !this.Ja4TlsFingerprintMatcher.Equal(that1.Ja4TlsFingerprintMatcher) {
		return false
	}
	return true
}
func (this *GetSuggestedDDoSMitigtionRuleRsp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSuggestedDDoSMitigtionRuleRsp)
	if !ok {
		that2, ok := that.(GetSuggestedDDoSMitigtionRuleRsp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MitigationRule.Equal(that1.MitigationRule) {
		return false
	}
	if this.MitigationRuleName != that1.MitigationRuleName {
		return false
	}
	if !this.FoundExistingMitigationRule.Equal(that1.FoundExistingMitigationRule) {
		return false
	}
	return true
}
func (this *GetSuggestedBlockClientRuleReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&app_security.GetSuggestedBlockClientRuleReq{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "IpPrefix: "+fmt.Sprintf("%#v", this.IpPrefix)+",\n")
	s = append(s, "AsNumber: "+fmt.Sprintf("%#v", this.AsNumber)+",\n")
	s = append(s, "AsDescription: "+fmt.Sprintf("%#v", this.AsDescription)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSuggestedBlockClientRuleRsp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&app_security.GetSuggestedBlockClientRuleRsp{")
	if this.Rule != nil {
		s = append(s, "Rule: "+fmt.Sprintf("%#v", this.Rule)+",\n")
	}
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.FoundExistingRule != nil {
		s = append(s, "FoundExistingRule: "+fmt.Sprintf("%#v", this.FoundExistingRule)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSuggestedTrustClientRuleReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&app_security.GetSuggestedTrustClientRuleReq{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "IpPrefix: "+fmt.Sprintf("%#v", this.IpPrefix)+",\n")
	s = append(s, "AsNumber: "+fmt.Sprintf("%#v", this.AsNumber)+",\n")
	s = append(s, "AsDescription: "+fmt.Sprintf("%#v", this.AsDescription)+",\n")
	s = append(s, "SecEventTypes: "+fmt.Sprintf("%#v", this.SecEventTypes)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "SecEventName: "+fmt.Sprintf("%#v", this.SecEventName)+",\n")
	s = append(s, "IpReputation: "+fmt.Sprintf("%#v", this.IpReputation)+",\n")
	s = append(s, "ThreatMesh: "+fmt.Sprintf("%#v", this.ThreatMesh)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSuggestedTrustClientRuleRsp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&app_security.GetSuggestedTrustClientRuleRsp{")
	if this.Rule != nil {
		s = append(s, "Rule: "+fmt.Sprintf("%#v", this.Rule)+",\n")
	}
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.FoundExistingRule != nil {
		s = append(s, "FoundExistingRule: "+fmt.Sprintf("%#v", this.FoundExistingRule)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSuggestedDDoSMitigtionRuleReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&app_security.GetSuggestedDDoSMitigtionRuleReq{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.IpPrefixList != nil {
		s = append(s, "IpPrefixList: "+fmt.Sprintf("%#v", this.IpPrefixList)+",\n")
	}
	if this.AsnList != nil {
		s = append(s, "AsnList: "+fmt.Sprintf("%#v", this.AsnList)+",\n")
	}
	s = append(s, "CountryList: "+fmt.Sprintf("%#v", this.CountryList)+",\n")
	if this.TlsFingerprintMatcher != nil {
		s = append(s, "TlsFingerprintMatcher: "+fmt.Sprintf("%#v", this.TlsFingerprintMatcher)+",\n")
	}
	if this.Ja4TlsFingerprintMatcher != nil {
		s = append(s, "Ja4TlsFingerprintMatcher: "+fmt.Sprintf("%#v", this.Ja4TlsFingerprintMatcher)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSuggestedDDoSMitigtionRuleRsp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&app_security.GetSuggestedDDoSMitigtionRuleRsp{")
	if this.MitigationRule != nil {
		s = append(s, "MitigationRule: "+fmt.Sprintf("%#v", this.MitigationRule)+",\n")
	}
	s = append(s, "MitigationRuleName: "+fmt.Sprintf("%#v", this.MitigationRuleName)+",\n")
	if this.FoundExistingMitigationRule != nil {
		s = append(s, "FoundExistingMitigationRule: "+fmt.Sprintf("%#v", this.FoundExistingMitigationRule)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringPublicClientRuleSuggestionsApi(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AppSecurityClientRuleAPIClient is the client API for AppSecurityClientRuleAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AppSecurityClientRuleAPIClient interface {
	// Suggest block client rule
	//
	// x-displayName: "Suggest block client rule"
	// Suggest blocking SimpleClientSrcRule for a given IP/ASN
	GetSuggestedBlockClientRule(ctx context.Context, in *GetSuggestedBlockClientRuleReq, opts ...grpc.CallOption) (*GetSuggestedBlockClientRuleRsp, error)
	// Suggest block client rule
	//
	// x-displayName: "Suggest block client rule"
	// Suggest blocking SimpleClientSrcRule for a given IP/ASN
	GetSuggestedBlockClientRuleForCDN(ctx context.Context, in *GetSuggestedBlockClientRuleReq, opts ...grpc.CallOption) (*GetSuggestedBlockClientRuleRsp, error)
	// Suggest trust client rule
	//
	// x-displayName: "Suggest trust client rule"
	// Suggest SimpleClientSrcRule to trust a given IP/ASN
	GetSuggestedTrustClientRule(ctx context.Context, in *GetSuggestedTrustClientRuleReq, opts ...grpc.CallOption) (*GetSuggestedTrustClientRuleRsp, error)
	// Suggest trust client rule
	//
	// x-displayName: "Suggest trust client rule"
	// Suggest SimpleClientSrcRule to trust a given IP/ASN
	GetSuggestedTrustClientRuleForCDN(ctx context.Context, in *GetSuggestedTrustClientRuleReq, opts ...grpc.CallOption) (*GetSuggestedTrustClientRuleRsp, error)
	// Suggest DDoS Mitigation rule
	//
	// x-displayName: "Suggest DDoS Mitigation rule"
	// Suggest DDoSMitigatonRule to mitigate a given IP/ASN/Region/TLS
	GetSuggestedDDoSMitigationRule(ctx context.Context, in *GetSuggestedDDoSMitigtionRuleReq, opts ...grpc.CallOption) (*GetSuggestedDDoSMitigtionRuleRsp, error)
	// Suggest CDN DDoS Mitigation rule
	//
	// x-displayName: "Suggest CDN DDoS Mitigation rule"
	// Suggest DDoSMitigatonRule to mitigate a given IP/ASN/Region/TLS
	GetSuggestedDDoSMitigationRuleForCDN(ctx context.Context, in *GetSuggestedDDoSMitigtionRuleReq, opts ...grpc.CallOption) (*GetSuggestedDDoSMitigtionRuleRsp, error)
}

type appSecurityClientRuleAPIClient struct {
	cc *grpc.ClientConn
}

func NewAppSecurityClientRuleAPIClient(cc *grpc.ClientConn) AppSecurityClientRuleAPIClient {
	return &appSecurityClientRuleAPIClient{cc}
}

func (c *appSecurityClientRuleAPIClient) GetSuggestedBlockClientRule(ctx context.Context, in *GetSuggestedBlockClientRuleReq, opts ...grpc.CallOption) (*GetSuggestedBlockClientRuleRsp, error) {
	out := new(GetSuggestedBlockClientRuleRsp)
	err := c.cc.Invoke(ctx, "/ves.io.schema.app_security.AppSecurityClientRuleAPI/GetSuggestedBlockClientRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appSecurityClientRuleAPIClient) GetSuggestedBlockClientRuleForCDN(ctx context.Context, in *GetSuggestedBlockClientRuleReq, opts ...grpc.CallOption) (*GetSuggestedBlockClientRuleRsp, error) {
	out := new(GetSuggestedBlockClientRuleRsp)
	err := c.cc.Invoke(ctx, "/ves.io.schema.app_security.AppSecurityClientRuleAPI/GetSuggestedBlockClientRuleForCDN", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appSecurityClientRuleAPIClient) GetSuggestedTrustClientRule(ctx context.Context, in *GetSuggestedTrustClientRuleReq, opts ...grpc.CallOption) (*GetSuggestedTrustClientRuleRsp, error) {
	out := new(GetSuggestedTrustClientRuleRsp)
	err := c.cc.Invoke(ctx, "/ves.io.schema.app_security.AppSecurityClientRuleAPI/GetSuggestedTrustClientRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appSecurityClientRuleAPIClient) GetSuggestedTrustClientRuleForCDN(ctx context.Context, in *GetSuggestedTrustClientRuleReq, opts ...grpc.CallOption) (*GetSuggestedTrustClientRuleRsp, error) {
	out := new(GetSuggestedTrustClientRuleRsp)
	err := c.cc.Invoke(ctx, "/ves.io.schema.app_security.AppSecurityClientRuleAPI/GetSuggestedTrustClientRuleForCDN", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appSecurityClientRuleAPIClient) GetSuggestedDDoSMitigationRule(ctx context.Context, in *GetSuggestedDDoSMitigtionRuleReq, opts ...grpc.CallOption) (*GetSuggestedDDoSMitigtionRuleRsp, error) {
	out := new(GetSuggestedDDoSMitigtionRuleRsp)
	err := c.cc.Invoke(ctx, "/ves.io.schema.app_security.AppSecurityClientRuleAPI/GetSuggestedDDoSMitigationRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appSecurityClientRuleAPIClient) GetSuggestedDDoSMitigationRuleForCDN(ctx context.Context, in *GetSuggestedDDoSMitigtionRuleReq, opts ...grpc.CallOption) (*GetSuggestedDDoSMitigtionRuleRsp, error) {
	out := new(GetSuggestedDDoSMitigtionRuleRsp)
	err := c.cc.Invoke(ctx, "/ves.io.schema.app_security.AppSecurityClientRuleAPI/GetSuggestedDDoSMitigationRuleForCDN", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AppSecurityClientRuleAPIServer is the server API for AppSecurityClientRuleAPI service.
type AppSecurityClientRuleAPIServer interface {
	// Suggest block client rule
	//
	// x-displayName: "Suggest block client rule"
	// Suggest blocking SimpleClientSrcRule for a given IP/ASN
	GetSuggestedBlockClientRule(context.Context, *GetSuggestedBlockClientRuleReq) (*GetSuggestedBlockClientRuleRsp, error)
	// Suggest block client rule
	//
	// x-displayName: "Suggest block client rule"
	// Suggest blocking SimpleClientSrcRule for a given IP/ASN
	GetSuggestedBlockClientRuleForCDN(context.Context, *GetSuggestedBlockClientRuleReq) (*GetSuggestedBlockClientRuleRsp, error)
	// Suggest trust client rule
	//
	// x-displayName: "Suggest trust client rule"
	// Suggest SimpleClientSrcRule to trust a given IP/ASN
	GetSuggestedTrustClientRule(context.Context, *GetSuggestedTrustClientRuleReq) (*GetSuggestedTrustClientRuleRsp, error)
	// Suggest trust client rule
	//
	// x-displayName: "Suggest trust client rule"
	// Suggest SimpleClientSrcRule to trust a given IP/ASN
	GetSuggestedTrustClientRuleForCDN(context.Context, *GetSuggestedTrustClientRuleReq) (*GetSuggestedTrustClientRuleRsp, error)
	// Suggest DDoS Mitigation rule
	//
	// x-displayName: "Suggest DDoS Mitigation rule"
	// Suggest DDoSMitigatonRule to mitigate a given IP/ASN/Region/TLS
	GetSuggestedDDoSMitigationRule(context.Context, *GetSuggestedDDoSMitigtionRuleReq) (*GetSuggestedDDoSMitigtionRuleRsp, error)
	// Suggest CDN DDoS Mitigation rule
	//
	// x-displayName: "Suggest CDN DDoS Mitigation rule"
	// Suggest DDoSMitigatonRule to mitigate a given IP/ASN/Region/TLS
	GetSuggestedDDoSMitigationRuleForCDN(context.Context, *GetSuggestedDDoSMitigtionRuleReq) (*GetSuggestedDDoSMitigtionRuleRsp, error)
}

// UnimplementedAppSecurityClientRuleAPIServer can be embedded to have forward compatible implementations.
type UnimplementedAppSecurityClientRuleAPIServer struct {
}

func (*UnimplementedAppSecurityClientRuleAPIServer) GetSuggestedBlockClientRule(ctx context.Context, req *GetSuggestedBlockClientRuleReq) (*GetSuggestedBlockClientRuleRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSuggestedBlockClientRule not implemented")
}
func (*UnimplementedAppSecurityClientRuleAPIServer) GetSuggestedBlockClientRuleForCDN(ctx context.Context, req *GetSuggestedBlockClientRuleReq) (*GetSuggestedBlockClientRuleRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSuggestedBlockClientRuleForCDN not implemented")
}
func (*UnimplementedAppSecurityClientRuleAPIServer) GetSuggestedTrustClientRule(ctx context.Context, req *GetSuggestedTrustClientRuleReq) (*GetSuggestedTrustClientRuleRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSuggestedTrustClientRule not implemented")
}
func (*UnimplementedAppSecurityClientRuleAPIServer) GetSuggestedTrustClientRuleForCDN(ctx context.Context, req *GetSuggestedTrustClientRuleReq) (*GetSuggestedTrustClientRuleRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSuggestedTrustClientRuleForCDN not implemented")
}
func (*UnimplementedAppSecurityClientRuleAPIServer) GetSuggestedDDoSMitigationRule(ctx context.Context, req *GetSuggestedDDoSMitigtionRuleReq) (*GetSuggestedDDoSMitigtionRuleRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSuggestedDDoSMitigationRule not implemented")
}
func (*UnimplementedAppSecurityClientRuleAPIServer) GetSuggestedDDoSMitigationRuleForCDN(ctx context.Context, req *GetSuggestedDDoSMitigtionRuleReq) (*GetSuggestedDDoSMitigtionRuleRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSuggestedDDoSMitigationRuleForCDN not implemented")
}

func RegisterAppSecurityClientRuleAPIServer(s *grpc.Server, srv AppSecurityClientRuleAPIServer) {
	s.RegisterService(&_AppSecurityClientRuleAPI_serviceDesc, srv)
}

func _AppSecurityClientRuleAPI_GetSuggestedBlockClientRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSuggestedBlockClientRuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppSecurityClientRuleAPIServer).GetSuggestedBlockClientRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.app_security.AppSecurityClientRuleAPI/GetSuggestedBlockClientRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppSecurityClientRuleAPIServer).GetSuggestedBlockClientRule(ctx, req.(*GetSuggestedBlockClientRuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppSecurityClientRuleAPI_GetSuggestedBlockClientRuleForCDN_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSuggestedBlockClientRuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppSecurityClientRuleAPIServer).GetSuggestedBlockClientRuleForCDN(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.app_security.AppSecurityClientRuleAPI/GetSuggestedBlockClientRuleForCDN",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppSecurityClientRuleAPIServer).GetSuggestedBlockClientRuleForCDN(ctx, req.(*GetSuggestedBlockClientRuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppSecurityClientRuleAPI_GetSuggestedTrustClientRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSuggestedTrustClientRuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppSecurityClientRuleAPIServer).GetSuggestedTrustClientRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.app_security.AppSecurityClientRuleAPI/GetSuggestedTrustClientRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppSecurityClientRuleAPIServer).GetSuggestedTrustClientRule(ctx, req.(*GetSuggestedTrustClientRuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppSecurityClientRuleAPI_GetSuggestedTrustClientRuleForCDN_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSuggestedTrustClientRuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppSecurityClientRuleAPIServer).GetSuggestedTrustClientRuleForCDN(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.app_security.AppSecurityClientRuleAPI/GetSuggestedTrustClientRuleForCDN",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppSecurityClientRuleAPIServer).GetSuggestedTrustClientRuleForCDN(ctx, req.(*GetSuggestedTrustClientRuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppSecurityClientRuleAPI_GetSuggestedDDoSMitigationRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSuggestedDDoSMitigtionRuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppSecurityClientRuleAPIServer).GetSuggestedDDoSMitigationRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.app_security.AppSecurityClientRuleAPI/GetSuggestedDDoSMitigationRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppSecurityClientRuleAPIServer).GetSuggestedDDoSMitigationRule(ctx, req.(*GetSuggestedDDoSMitigtionRuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppSecurityClientRuleAPI_GetSuggestedDDoSMitigationRuleForCDN_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSuggestedDDoSMitigtionRuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppSecurityClientRuleAPIServer).GetSuggestedDDoSMitigationRuleForCDN(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.app_security.AppSecurityClientRuleAPI/GetSuggestedDDoSMitigationRuleForCDN",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppSecurityClientRuleAPIServer).GetSuggestedDDoSMitigationRuleForCDN(ctx, req.(*GetSuggestedDDoSMitigtionRuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _AppSecurityClientRuleAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ves.io.schema.app_security.AppSecurityClientRuleAPI",
	HandlerType: (*AppSecurityClientRuleAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSuggestedBlockClientRule",
			Handler:    _AppSecurityClientRuleAPI_GetSuggestedBlockClientRule_Handler,
		},
		{
			MethodName: "GetSuggestedBlockClientRuleForCDN",
			Handler:    _AppSecurityClientRuleAPI_GetSuggestedBlockClientRuleForCDN_Handler,
		},
		{
			MethodName: "GetSuggestedTrustClientRule",
			Handler:    _AppSecurityClientRuleAPI_GetSuggestedTrustClientRule_Handler,
		},
		{
			MethodName: "GetSuggestedTrustClientRuleForCDN",
			Handler:    _AppSecurityClientRuleAPI_GetSuggestedTrustClientRuleForCDN_Handler,
		},
		{
			MethodName: "GetSuggestedDDoSMitigationRule",
			Handler:    _AppSecurityClientRuleAPI_GetSuggestedDDoSMitigationRule_Handler,
		},
		{
			MethodName: "GetSuggestedDDoSMitigationRuleForCDN",
			Handler:    _AppSecurityClientRuleAPI_GetSuggestedDDoSMitigationRuleForCDN_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ves.io/schema/app_security/public_client_rule_suggestions_api.proto",
}

func (m *GetSuggestedBlockClientRuleReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSuggestedBlockClientRuleReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSuggestedBlockClientRuleReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UserId) > 0 {
		i -= len(m.UserId)
		copy(dAtA[i:], m.UserId)
		i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(len(m.UserId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AsDescription) > 0 {
		i -= len(m.AsDescription)
		copy(dAtA[i:], m.AsDescription)
		i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(len(m.AsDescription)))
		i--
		dAtA[i] = 0x32
	}
	if m.AsNumber != 0 {
		i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(m.AsNumber))
		i--
		dAtA[i] = 0x28
	}
	if len(m.IpPrefix) > 0 {
		i -= len(m.IpPrefix)
		copy(dAtA[i:], m.IpPrefix)
		i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(len(m.IpPrefix)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSuggestedBlockClientRuleRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSuggestedBlockClientRuleRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSuggestedBlockClientRuleRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FoundExistingRule != nil {
		{
			size, err := m.FoundExistingRule.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Rule != nil {
		{
			size, err := m.Rule.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSuggestedTrustClientRuleReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSuggestedTrustClientRuleReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSuggestedTrustClientRuleReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ThreatMesh {
		i--
		if m.ThreatMesh {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.IpReputation {
		i--
		if m.IpReputation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.SecEventName) > 0 {
		i -= len(m.SecEventName)
		copy(dAtA[i:], m.SecEventName)
		i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(len(m.SecEventName)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.UserId) > 0 {
		i -= len(m.UserId)
		copy(dAtA[i:], m.UserId)
		i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(len(m.UserId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SecEventTypes) > 0 {
		dAtA4 := make([]byte, len(m.SecEventTypes)*10)
		var j3 int
		for _, num := range m.SecEventTypes {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AsDescription) > 0 {
		i -= len(m.AsDescription)
		copy(dAtA[i:], m.AsDescription)
		i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(len(m.AsDescription)))
		i--
		dAtA[i] = 0x32
	}
	if m.AsNumber != 0 {
		i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(m.AsNumber))
		i--
		dAtA[i] = 0x28
	}
	if len(m.IpPrefix) > 0 {
		i -= len(m.IpPrefix)
		copy(dAtA[i:], m.IpPrefix)
		i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(len(m.IpPrefix)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSuggestedTrustClientRuleRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSuggestedTrustClientRuleRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSuggestedTrustClientRuleRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FoundExistingRule != nil {
		{
			size, err := m.FoundExistingRule.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Rule != nil {
		{
			size, err := m.Rule.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSuggestedDDoSMitigtionRuleReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSuggestedDDoSMitigtionRuleReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSuggestedDDoSMitigtionRuleReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ja4TlsFingerprintMatcher != nil {
		{
			size, err := m.Ja4TlsFingerprintMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.TlsFingerprintMatcher != nil {
		{
			size, err := m.TlsFingerprintMatcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.CountryList) > 0 {
		dAtA10 := make([]byte, len(m.CountryList)*10)
		var j9 int
		for _, num := range m.CountryList {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x2a
	}
	if m.AsnList != nil {
		{
			size, err := m.AsnList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.IpPrefixList != nil {
		{
			size, err := m.IpPrefixList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSuggestedDDoSMitigtionRuleRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSuggestedDDoSMitigtionRuleRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSuggestedDDoSMitigtionRuleRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FoundExistingMitigationRule != nil {
		{
			size, err := m.FoundExistingMitigationRule.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MitigationRuleName) > 0 {
		i -= len(m.MitigationRuleName)
		copy(dAtA[i:], m.MitigationRuleName)
		i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(len(m.MitigationRuleName)))
		i--
		dAtA[i] = 0x12
	}
	if m.MitigationRule != nil {
		{
			size, err := m.MitigationRule.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicClientRuleSuggestionsApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPublicClientRuleSuggestionsApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovPublicClientRuleSuggestionsApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GetSuggestedBlockClientRuleReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	l = len(m.IpPrefix)
	if l > 0 {
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	if m.AsNumber != 0 {
		n += 1 + sovPublicClientRuleSuggestionsApi(uint64(m.AsNumber))
	}
	l = len(m.AsDescription)
	if l > 0 {
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	return n
}

func (m *GetSuggestedBlockClientRuleRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rule != nil {
		l = m.Rule.Size()
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	if m.FoundExistingRule != nil {
		l = m.FoundExistingRule.Size()
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	return n
}

func (m *GetSuggestedTrustClientRuleReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	l = len(m.IpPrefix)
	if l > 0 {
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	if m.AsNumber != 0 {
		n += 1 + sovPublicClientRuleSuggestionsApi(uint64(m.AsNumber))
	}
	l = len(m.AsDescription)
	if l > 0 {
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	if len(m.SecEventTypes) > 0 {
		l = 0
		for _, e := range m.SecEventTypes {
			l += sovPublicClientRuleSuggestionsApi(uint64(e))
		}
		n += 1 + sovPublicClientRuleSuggestionsApi(uint64(l)) + l
	}
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	l = len(m.SecEventName)
	if l > 0 {
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	if m.IpReputation {
		n += 2
	}
	if m.ThreatMesh {
		n += 2
	}
	return n
}

func (m *GetSuggestedTrustClientRuleRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rule != nil {
		l = m.Rule.Size()
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	if m.FoundExistingRule != nil {
		l = m.FoundExistingRule.Size()
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	return n
}

func (m *GetSuggestedDDoSMitigtionRuleReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	if m.IpPrefixList != nil {
		l = m.IpPrefixList.Size()
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	if m.AsnList != nil {
		l = m.AsnList.Size()
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	if len(m.CountryList) > 0 {
		l = 0
		for _, e := range m.CountryList {
			l += sovPublicClientRuleSuggestionsApi(uint64(e))
		}
		n += 1 + sovPublicClientRuleSuggestionsApi(uint64(l)) + l
	}
	if m.TlsFingerprintMatcher != nil {
		l = m.TlsFingerprintMatcher.Size()
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	if m.Ja4TlsFingerprintMatcher != nil {
		l = m.Ja4TlsFingerprintMatcher.Size()
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	return n
}

func (m *GetSuggestedDDoSMitigtionRuleRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MitigationRule != nil {
		l = m.MitigationRule.Size()
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	l = len(m.MitigationRuleName)
	if l > 0 {
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	if m.FoundExistingMitigationRule != nil {
		l = m.FoundExistingMitigationRule.Size()
		n += 1 + l + sovPublicClientRuleSuggestionsApi(uint64(l))
	}
	return n
}

func sovPublicClientRuleSuggestionsApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPublicClientRuleSuggestionsApi(x uint64) (n int) {
	return sovPublicClientRuleSuggestionsApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *GetSuggestedBlockClientRuleReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSuggestedBlockClientRuleReq{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`IpPrefix:` + fmt.Sprintf("%v", this.IpPrefix) + `,`,
		`AsNumber:` + fmt.Sprintf("%v", this.AsNumber) + `,`,
		`AsDescription:` + fmt.Sprintf("%v", this.AsDescription) + `,`,
		`UserId:` + fmt.Sprintf("%v", this.UserId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSuggestedBlockClientRuleRsp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSuggestedBlockClientRuleRsp{`,
		`Rule:` + strings.Replace(fmt.Sprintf("%v", this.Rule), "SimpleClientSrcRule", "common_waf.SimpleClientSrcRule", 1) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`FoundExistingRule:` + strings.Replace(fmt.Sprintf("%v", this.FoundExistingRule), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSuggestedTrustClientRuleReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSuggestedTrustClientRuleReq{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`IpPrefix:` + fmt.Sprintf("%v", this.IpPrefix) + `,`,
		`AsNumber:` + fmt.Sprintf("%v", this.AsNumber) + `,`,
		`AsDescription:` + fmt.Sprintf("%v", this.AsDescription) + `,`,
		`SecEventTypes:` + fmt.Sprintf("%v", this.SecEventTypes) + `,`,
		`UserId:` + fmt.Sprintf("%v", this.UserId) + `,`,
		`SecEventName:` + fmt.Sprintf("%v", this.SecEventName) + `,`,
		`IpReputation:` + fmt.Sprintf("%v", this.IpReputation) + `,`,
		`ThreatMesh:` + fmt.Sprintf("%v", this.ThreatMesh) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSuggestedTrustClientRuleRsp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSuggestedTrustClientRuleRsp{`,
		`Rule:` + strings.Replace(fmt.Sprintf("%v", this.Rule), "SimpleClientSrcRule", "common_waf.SimpleClientSrcRule", 1) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`FoundExistingRule:` + strings.Replace(fmt.Sprintf("%v", this.FoundExistingRule), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSuggestedDDoSMitigtionRuleReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSuggestedDDoSMitigtionRuleReq{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`IpPrefixList:` + strings.Replace(fmt.Sprintf("%v", this.IpPrefixList), "PrefixMatchList", "policy.PrefixMatchList", 1) + `,`,
		`AsnList:` + strings.Replace(fmt.Sprintf("%v", this.AsnList), "AsnMatchList", "policy.AsnMatchList", 1) + `,`,
		`CountryList:` + fmt.Sprintf("%v", this.CountryList) + `,`,
		`TlsFingerprintMatcher:` + strings.Replace(fmt.Sprintf("%v", this.TlsFingerprintMatcher), "TlsFingerprintMatcherType", "policy.TlsFingerprintMatcherType", 1) + `,`,
		`Ja4TlsFingerprintMatcher:` + strings.Replace(fmt.Sprintf("%v", this.Ja4TlsFingerprintMatcher), "JA4TlsFingerprintMatcherType", "policy.JA4TlsFingerprintMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSuggestedDDoSMitigtionRuleRsp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSuggestedDDoSMitigtionRuleRsp{`,
		`MitigationRule:` + strings.Replace(fmt.Sprintf("%v", this.MitigationRule), "DDoSMitigationRule", "common_security.DDoSMitigationRule", 1) + `,`,
		`MitigationRuleName:` + fmt.Sprintf("%v", this.MitigationRuleName) + `,`,
		`FoundExistingMitigationRule:` + strings.Replace(fmt.Sprintf("%v", this.FoundExistingMitigationRule), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringPublicClientRuleSuggestionsApi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *GetSuggestedBlockClientRuleReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicClientRuleSuggestionsApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSuggestedBlockClientRuleReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSuggestedBlockClientRuleReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsNumber", wireType)
			}
			m.AsNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AsNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicClientRuleSuggestionsApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSuggestedBlockClientRuleRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicClientRuleSuggestionsApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSuggestedBlockClientRuleRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSuggestedBlockClientRuleRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rule == nil {
				m.Rule = &common_waf.SimpleClientSrcRule{}
			}
			if err := m.Rule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoundExistingRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FoundExistingRule == nil {
				m.FoundExistingRule = &schema.Empty{}
			}
			if err := m.FoundExistingRule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicClientRuleSuggestionsApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSuggestedTrustClientRuleReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicClientRuleSuggestionsApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSuggestedTrustClientRuleReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSuggestedTrustClientRuleReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsNumber", wireType)
			}
			m.AsNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AsNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v SecEventType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicClientRuleSuggestionsApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= SecEventType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SecEventTypes = append(m.SecEventTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicClientRuleSuggestionsApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPublicClientRuleSuggestionsApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPublicClientRuleSuggestionsApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.SecEventTypes) == 0 {
					m.SecEventTypes = make([]SecEventType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v SecEventType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicClientRuleSuggestionsApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= SecEventType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SecEventTypes = append(m.SecEventTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SecEventTypes", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecEventName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecEventName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpReputation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpReputation = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThreatMesh", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ThreatMesh = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPublicClientRuleSuggestionsApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSuggestedTrustClientRuleRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicClientRuleSuggestionsApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSuggestedTrustClientRuleRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSuggestedTrustClientRuleRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rule == nil {
				m.Rule = &common_waf.SimpleClientSrcRule{}
			}
			if err := m.Rule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoundExistingRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FoundExistingRule == nil {
				m.FoundExistingRule = &schema.Empty{}
			}
			if err := m.FoundExistingRule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicClientRuleSuggestionsApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSuggestedDDoSMitigtionRuleReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicClientRuleSuggestionsApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSuggestedDDoSMitigtionRuleReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSuggestedDDoSMitigtionRuleReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpPrefixList == nil {
				m.IpPrefixList = &policy.PrefixMatchList{}
			}
			if err := m.IpPrefixList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsnList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AsnList == nil {
				m.AsnList = &policy.AsnMatchList{}
			}
			if err := m.AsnList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v policy.CountryCode
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicClientRuleSuggestionsApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= policy.CountryCode(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CountryList = append(m.CountryList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicClientRuleSuggestionsApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPublicClientRuleSuggestionsApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPublicClientRuleSuggestionsApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.CountryList) == 0 {
					m.CountryList = make([]policy.CountryCode, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v policy.CountryCode
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicClientRuleSuggestionsApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= policy.CountryCode(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CountryList = append(m.CountryList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryList", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsFingerprintMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsFingerprintMatcher == nil {
				m.TlsFingerprintMatcher = &policy.TlsFingerprintMatcherType{}
			}
			if err := m.TlsFingerprintMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ja4TlsFingerprintMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ja4TlsFingerprintMatcher == nil {
				m.Ja4TlsFingerprintMatcher = &policy.JA4TlsFingerprintMatcherType{}
			}
			if err := m.Ja4TlsFingerprintMatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicClientRuleSuggestionsApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSuggestedDDoSMitigtionRuleRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicClientRuleSuggestionsApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSuggestedDDoSMitigtionRuleRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSuggestedDDoSMitigtionRuleRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MitigationRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MitigationRule == nil {
				m.MitigationRule = &common_security.DDoSMitigationRule{}
			}
			if err := m.MitigationRule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MitigationRuleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MitigationRuleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoundExistingMitigationRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FoundExistingMitigationRule == nil {
				m.FoundExistingMitigationRule = &schema.Empty{}
			}
			if err := m.FoundExistingMitigationRule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicClientRuleSuggestionsApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPublicClientRuleSuggestionsApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPublicClientRuleSuggestionsApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPublicClientRuleSuggestionsApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPublicClientRuleSuggestionsApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPublicClientRuleSuggestionsApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPublicClientRuleSuggestionsApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPublicClientRuleSuggestionsApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPublicClientRuleSuggestionsApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPublicClientRuleSuggestionsApi = fmt.Errorf("proto: unexpected end of group")
)
