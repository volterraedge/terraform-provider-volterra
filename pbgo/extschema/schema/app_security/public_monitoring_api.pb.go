// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/app_security/public_monitoring_api.proto

// Application Security Monitoring APIs
//
// x-displayName: "Application Security Monitoring APIs"
// APIs to get application security events and metrics on virtual-host basis.
// Security events may be generated for following reasons:
// 1. Service policy hits with action "deny"
// 2. Rate limiting
// 3. Javascript challenge failure

package app_security

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/googleapis/google/api"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	incidents "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/app_security/incidents"
	metrics "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/app_security/metrics"
	suspicious_user_log "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/app_security/suspicious_user_log"
	log "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/log"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/vesenv"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Search Label for VH list API
//
// x-displayName: "Search Label for VH List API"
// List of Virtual Hosts will be returned matching the following labels.
type SearchLabel int32

const (
	// x-displayName: "Request ID"
	REQUEST_ID SearchLabel = 0
	// x-displayName: "Source IP"
	SOURCE_IP SearchLabel = 1
)

var SearchLabel_name = map[int32]string{
	0: "REQUEST_ID",
	1: "SOURCE_IP",
}

var SearchLabel_value = map[string]int32{
	"REQUEST_ID": 0,
	"SOURCE_IP":  1,
}

func (SearchLabel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{0}
}

// Search Label Operator
//
// x-displayName: "Search Label Operator"
// Search Label Operator
type SearchLabelOperator int32

const (
	// x-displayName: "IN"
	// x-example: "field: ["foo", "bar"]"
	IN SearchLabelOperator = 0
	// x-displayName: "NOT_IN"
	NOT_IN SearchLabelOperator = 1
)

var SearchLabelOperator_name = map[int32]string{
	0: "IN",
	1: "NOT_IN",
}

var SearchLabelOperator_value = map[string]int32{
	"IN":     0,
	"NOT_IN": 1,
}

func (SearchLabelOperator) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{1}
}

// Security Events Request
//
// x-displayName: "Security Events Request"
// Request to fetch security events
type SecurityEventsRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// fetch security events for a given namespace
	// x-example: "bloggin-app-namespace-1"
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// query
	//
	// x-displayName: "Query"
	// x-example: "query={app_type="blogging_app"}"
	// query is used to specify the list of matchers
	// syntax for query := {[<matcher>]}
	// <matcher> := <field_name><operator>"<value>"
	// <field_name> := string
	//   One or more of these fields in the security event may be specified in the query.
	//     vh_name - name of the virtual host
	//     src_site - source site
	//     city - name of the city
	//     country - country code
	// <value> := string
	// <operator> := ["="|"!="|"=~"|"!~"]
	//   = : equal to
	//   != : not equal to
	//   =~ : regex match
	//   !~ : not regex match
	// When more than one matcher is specified in the query, then security events matching ALL the matchers will be returned in the response.
	// Example: query={country="United States", city="California"} will return all security events originating from California, United States.
	//
	// Optional: If not specified, all the security events matching the given tenant and namespace will be returned in the response.
	Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// start time
	//
	// x-displayName: "Start Time"
	// x-example: "1570007981"
	// fetch security events whose timestamp >= start_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the start_time will be evaluated to end_time-10m
	//           If end_time is not specified, then the start_time will be evaluated to <current time>-10m
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end time
	//
	// x-displayName: "End Time"
	// x-example: "1570007981"
	// fetch security events whose timestamp <= end_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the end_time will be evaluated to start_time+10m
	//           If start_time is not specified, then the end_time will be evaluated to <current time>
	EndTime string `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// sort order
	//
	// x-displayName: "Sort Order"
	// Optional: default is descending order
	Sort schema.SortOrder `protobuf:"varint,5,opt,name=sort,proto3,enum=ves.io.schema.SortOrder" json:"sort,omitempty"`
	// limit
	//
	// x-displayName: "Limit"
	// x-example: "100"
	// limits the number of security events returned in the response
	// Optional: If not specified, first or last 500 security events that matches the query (depending on the sort order) will be returned in the response.
	//           The maximum value for limit is 500.
	Limit int32 `protobuf:"varint,6,opt,name=limit,proto3" json:"limit,omitempty"`
	// scroll
	//
	// x-displayName: "Scroll"
	// x-example: "true"
	// Scroll is used to retrieve large number of security events (or all security events) that matches the query.
	// If scroll is set to true, the scroll_id in the response can be used in the scroll API to fetch the next
	// batch of security events until there are no more security events left to return. The number of messages in each batch is determined
	// by the limit field.
	// Note: Scroll is used for processing large amount of data and therefore is not intended for real time user request.
	// Optional: default is false
	Scroll bool `protobuf:"varint,7,opt,name=scroll,proto3" json:"scroll,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the security events response. If the number of security events that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.
	// Optional
	Aggs map[string]*AggregationRequest `protobuf:"bytes,8,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// sort by
	//
	// x-displayName: "Sort By"
	// Optional: default is sort by last_event_time
	SortBy string `protobuf:"bytes,11,opt,name=sort_by,json=sortBy,proto3" json:"sort_by,omitempty"`
}

func (m *SecurityEventsRequest) Reset()      { *m = SecurityEventsRequest{} }
func (*SecurityEventsRequest) ProtoMessage() {}
func (*SecurityEventsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{0}
}
func (m *SecurityEventsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityEventsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityEventsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityEventsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityEventsRequest.Merge(m, src)
}
func (m *SecurityEventsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SecurityEventsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityEventsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityEventsRequest proto.InternalMessageInfo

func (m *SecurityEventsRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *SecurityEventsRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *SecurityEventsRequest) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *SecurityEventsRequest) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *SecurityEventsRequest) GetSort() schema.SortOrder {
	if m != nil {
		return m.Sort
	}
	return schema.DESCENDING
}

func (m *SecurityEventsRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SecurityEventsRequest) GetScroll() bool {
	if m != nil {
		return m.Scroll
	}
	return false
}

func (m *SecurityEventsRequest) GetAggs() map[string]*AggregationRequest {
	if m != nil {
		return m.Aggs
	}
	return nil
}

func (m *SecurityEventsRequest) GetSortBy() string {
	if m != nil {
		return m.SortBy
	}
	return ""
}

// Security Events Scroll Request
//
// x-displayName: "Security Events Scroll Request"
// Scroll request is used to fetch large number of security events in multiple batches with each SecurityEventsResponse
// containing no more than 500 messages. To scroll through more than 500 or all WAF security events, one can use the
// SecurityEventScrollRequest. Use the scroll_id returned in the SecurityEventsResponse to fetch the next batch of security events and
// one can continue this process till the scroll_id returned is "" which indicates no more messages to scroll.
type SecurityEventsScrollRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "bloggin-app-namespace-1"
	// fetch the WAF security events scoped by namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// scroll id
	//
	// x-displayName: "Scroll ID"
	// x-example: "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ=="
	// Long Base-64 encoded string which can be used to retrieve next batch of security events.
	ScrollId string `protobuf:"bytes,2,opt,name=scroll_id,json=scrollId,proto3" json:"scroll_id,omitempty"`
}

func (m *SecurityEventsScrollRequest) Reset()      { *m = SecurityEventsScrollRequest{} }
func (*SecurityEventsScrollRequest) ProtoMessage() {}
func (*SecurityEventsScrollRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{1}
}
func (m *SecurityEventsScrollRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityEventsScrollRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityEventsScrollRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityEventsScrollRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityEventsScrollRequest.Merge(m, src)
}
func (m *SecurityEventsScrollRequest) XXX_Size() int {
	return m.Size()
}
func (m *SecurityEventsScrollRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityEventsScrollRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityEventsScrollRequest proto.InternalMessageInfo

func (m *SecurityEventsScrollRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *SecurityEventsScrollRequest) GetScrollId() string {
	if m != nil {
		return m.ScrollId
	}
	return ""
}

// Security Events Response
//
// x-displayName: "Security Events Response"
// Response message for SecurityEventsRequest/SecurityEventsScrollRequest
type SecurityEventsResponse struct {
	// events
	//
	// x-displayName: "Events"
	// x-example: "value"
	// list of security events that matched the query. Contains no more than 500 messages.
	Events []string `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
	// total hits
	//
	// x-displayName: "Total Hits"
	// x-example: "0"
	// total number of security events that matched the query.
	TotalHits uint64 `protobuf:"varint,2,opt,name=total_hits,json=totalHits,proto3" json:"total_hits,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the security events response. If the number of security events that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	Aggs map[string]*log.LogAggregationData `protobuf:"bytes,3,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// scroll id
	//
	// x-displayName: "Scroll id"
	// x-example: "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ=="
	// Long Base-64 encoded string which can be used to retrieve the next batch of security events using the scroll request.
	// Empty scroll_id indicates no more messages to scroll (EOF).
	// Note: scroll_id is valid only for 2 minutes. i.e., If one intend to retrieve next batch of the result, then the
	//       scroll request should be sent within 2 minutes upon receiving the SecurityEventsResponse.
	ScrollId string `protobuf:"bytes,4,opt,name=scroll_id,json=scrollId,proto3" json:"scroll_id,omitempty"`
}

func (m *SecurityEventsResponse) Reset()      { *m = SecurityEventsResponse{} }
func (*SecurityEventsResponse) ProtoMessage() {}
func (*SecurityEventsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{2}
}
func (m *SecurityEventsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityEventsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityEventsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityEventsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityEventsResponse.Merge(m, src)
}
func (m *SecurityEventsResponse) XXX_Size() int {
	return m.Size()
}
func (m *SecurityEventsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityEventsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityEventsResponse proto.InternalMessageInfo

func (m *SecurityEventsResponse) GetEvents() []string {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *SecurityEventsResponse) GetTotalHits() uint64 {
	if m != nil {
		return m.TotalHits
	}
	return 0
}

func (m *SecurityEventsResponse) GetAggs() map[string]*log.LogAggregationData {
	if m != nil {
		return m.Aggs
	}
	return nil
}

func (m *SecurityEventsResponse) GetScrollId() string {
	if m != nil {
		return m.ScrollId
	}
	return ""
}

// Security Events Aggregation Request
//
// x-displayName: "Security Events Aggregation Request"
// Request to get only aggregation data for security events
type SecurityEventsAggregationRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// fetch security events for a given namespace
	// x-example: "bloggin-app-namespace-1"
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// query
	//
	// x-displayName: "Query"
	// x-example: "query={app_type="blogging_app"}"
	// query is used to specify the list of matchers
	// syntax for query := {[<matcher>]}
	// <matcher> := <field_name><operator>"<value>"
	// <field_name> := string
	//   One or more of these fields in the security event may be specified in the query.
	//     vh_name - name of the virtual host
	//     src_site - source site
	//     city - name of the city
	//     country - country code
	// <value> := string
	// <operator> := ["="|"!="|"=~"|"!~"]
	//   = : equal to
	//   != : not equal to
	//   =~ : regex match
	//   !~ : not regex match
	// When more than one matcher is specified in the query, then security events matching ALL the matchers will be returned in the response.
	// Example: query={country="United States", city="California"} will return all security events originating from California, United States.
	//
	// Optional: If not specified, all the security events matching the given tenant and namespace will be returned in the response.
	Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// start time
	//
	// x-displayName: "Start Time"
	// x-example: "1570007981"
	// fetch security events whose timestamp >= start_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the start_time will be evaluated to end_time-10m
	//           If end_time is not specified, then the start_time will be evaluated to <current time>-10m
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end time
	//
	// x-displayName: "End Time"
	// x-example: "1570007981"
	// fetch security events whose timestamp <= end_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the end_time will be evaluated to start_time+10m
	//           If start_time is not specified, then the end_time will be evaluated to <current time>
	EndTime string `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the security events response. If the number of security events that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.
	// Optional
	Aggs map[string]*AggregationRequest `protobuf:"bytes,5,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SecurityEventsAggregationRequest) Reset()      { *m = SecurityEventsAggregationRequest{} }
func (*SecurityEventsAggregationRequest) ProtoMessage() {}
func (*SecurityEventsAggregationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{3}
}
func (m *SecurityEventsAggregationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityEventsAggregationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityEventsAggregationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityEventsAggregationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityEventsAggregationRequest.Merge(m, src)
}
func (m *SecurityEventsAggregationRequest) XXX_Size() int {
	return m.Size()
}
func (m *SecurityEventsAggregationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityEventsAggregationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityEventsAggregationRequest proto.InternalMessageInfo

func (m *SecurityEventsAggregationRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *SecurityEventsAggregationRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *SecurityEventsAggregationRequest) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *SecurityEventsAggregationRequest) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *SecurityEventsAggregationRequest) GetAggs() map[string]*AggregationRequest {
	if m != nil {
		return m.Aggs
	}
	return nil
}

// Security Events Aggregation Response
//
// x-displayName: "Security Events Aggregation Response"
// Response message for SecurityEventsAggregationRequest
type SecurityEventsAggregationResponse struct {
	// total hits
	//
	// x-displayName: "Total Hits"
	// x-example: "0"
	// total number of security events that matched the query.
	TotalHits uint64 `protobuf:"varint,1,opt,name=total_hits,json=totalHits,proto3" json:"total_hits,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the security events response. If the number of security events that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregation data is key'ed with the aggregation name specified in the request.
	Aggs map[string]*log.LogAggregationData `protobuf:"bytes,2,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SecurityEventsAggregationResponse) Reset()      { *m = SecurityEventsAggregationResponse{} }
func (*SecurityEventsAggregationResponse) ProtoMessage() {}
func (*SecurityEventsAggregationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{4}
}
func (m *SecurityEventsAggregationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityEventsAggregationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityEventsAggregationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityEventsAggregationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityEventsAggregationResponse.Merge(m, src)
}
func (m *SecurityEventsAggregationResponse) XXX_Size() int {
	return m.Size()
}
func (m *SecurityEventsAggregationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityEventsAggregationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityEventsAggregationResponse proto.InternalMessageInfo

func (m *SecurityEventsAggregationResponse) GetTotalHits() uint64 {
	if m != nil {
		return m.TotalHits
	}
	return 0
}

func (m *SecurityEventsAggregationResponse) GetAggs() map[string]*log.LogAggregationData {
	if m != nil {
		return m.Aggs
	}
	return nil
}

// Suspicious User Logs Request
//
// x-displayName: "Suspicious User Logs Request"
// Request to fetch suspicious user logs
type SuspiciousUserLogsRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// fetch suspicious user logs for a given namespace
	// x-example: "bloggin-app-namespace-1"
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// query
	//
	// x-displayName: "Query"
	// x-example: "query={vh_name="vh-1", site="ce-01"}"
	// query is used to specify the list of matchers
	// syntax for query := {[<matcher>]}
	// <matcher> := <field_name><operator>"<value>"
	// <field_name> := string
	//   One or more of these fields in the suspicious user logs may be specified in the query.
	//     vh_name - name of the virtual host
	//     user - user id
	//     site - source site
	//     city - name of the city
	//     country - country code
	// <value> := string
	// <operator> := ["="|"!="|"=~"|"!~"]
	//   = : equal to
	//   != : not equal to
	//   =~ : regex match
	//   !~ : not regex match
	// When more than one matcher is specified in the query, then suspicious user logs matching ALL the matchers will be returned in the response.
	//
	// Optional: If not specified, all the suspicious user logs matching the given tenant and namespace will be returned in the response.
	Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// start time
	//
	// x-displayName: "Start Time"
	// x-example: "1570007981"
	// fetch suspicious user logs whose timestamp >= start_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the start_time will be evaluated to end_time-10m
	//           If end_time is not specified, then the start_time will be evaluated to <current time>-10m
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end time
	//
	// x-displayName: "End Time"
	// x-example: "1570007981"
	// fetch suspicious user logs whose timestamp <= end_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the end_time will be evaluated to start_time+10m
	//           If start_time is not specified, then the end_time will be evaluated to <current time>
	EndTime string `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// sort order
	//
	// x-displayName: "Sort Order"
	// Optional: default is descending order
	Sort schema.SortOrder `protobuf:"varint,5,opt,name=sort,proto3,enum=ves.io.schema.SortOrder" json:"sort,omitempty"`
	// limit
	//
	// x-displayName: "Limit"
	// x-example: "100"
	// limits the number of logs returned in the response
	// Optional: If not specified, first or last 500 logs that matches the query (depending on the sort order) will be returned in the response.
	//           The maximum value for limit is 500.
	Limit int32 `protobuf:"varint,6,opt,name=limit,proto3" json:"limit,omitempty"`
	// scroll
	//
	// x-displayName: "Scroll"
	// x-example: "true"
	// Scroll is used to retrieve large number of logs (or all logs) that matches the query.
	// If scroll is set to true, the scroll_id in the response can be used in the scroll API to fetch the next
	// batch of logs until there are no logs left to return. The number of logs in each batch is determined
	// by the limit field.
	// Note: Scroll is used for processing large amount of data and therefore is not intended for real time user request.
	// Optional: default is false
	Scroll bool `protobuf:"varint,7,opt,name=scroll,proto3" json:"scroll,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the suspicious user logs response. If the number of logs that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.
	// Optional
	Aggs map[string]*suspicious_user_log.AggregationRequest `protobuf:"bytes,8,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// sort by
	//
	// x-displayName: "Sort By"
	// Optional: default is sort by last_event_time
	SortBy string `protobuf:"bytes,11,opt,name=sort_by,json=sortBy,proto3" json:"sort_by,omitempty"`
}

func (m *SuspiciousUserLogsRequest) Reset()      { *m = SuspiciousUserLogsRequest{} }
func (*SuspiciousUserLogsRequest) ProtoMessage() {}
func (*SuspiciousUserLogsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{5}
}
func (m *SuspiciousUserLogsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SuspiciousUserLogsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SuspiciousUserLogsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SuspiciousUserLogsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SuspiciousUserLogsRequest.Merge(m, src)
}
func (m *SuspiciousUserLogsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SuspiciousUserLogsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SuspiciousUserLogsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SuspiciousUserLogsRequest proto.InternalMessageInfo

func (m *SuspiciousUserLogsRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *SuspiciousUserLogsRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *SuspiciousUserLogsRequest) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *SuspiciousUserLogsRequest) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *SuspiciousUserLogsRequest) GetSort() schema.SortOrder {
	if m != nil {
		return m.Sort
	}
	return schema.DESCENDING
}

func (m *SuspiciousUserLogsRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SuspiciousUserLogsRequest) GetScroll() bool {
	if m != nil {
		return m.Scroll
	}
	return false
}

func (m *SuspiciousUserLogsRequest) GetAggs() map[string]*suspicious_user_log.AggregationRequest {
	if m != nil {
		return m.Aggs
	}
	return nil
}

func (m *SuspiciousUserLogsRequest) GetSortBy() string {
	if m != nil {
		return m.SortBy
	}
	return ""
}

// Suspicious User Logs Scroll Request
//
// x-displayName: "Suspicious User Logs Scroll Request"
// Scroll request is used to fetch large number of suspicious user logs in multiple batches with each SuspiciousUserLogsResponse
// containing no more than 500 messages. To scroll through more than 500 or all messages, one can use the
// SuspiciousUserLogsScrollRequest. Use the scroll_id returned in the SuspiciousUserLogsResponse to fetch the next batch of logs
// and one can continue this process till the scroll_id returned is "" which indicates no more logs to scroll.
type SuspiciousUserLogsScrollRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "bloggin-app-namespace-1"
	// fetch the next batch of suspicious user logs scoped by namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// scroll id
	//
	// x-displayName: "Scroll ID"
	// x-example: "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ=="
	// Long Base-64 encoded string which can be used to retrieve next batch of security events.
	ScrollId string `protobuf:"bytes,2,opt,name=scroll_id,json=scrollId,proto3" json:"scroll_id,omitempty"`
}

func (m *SuspiciousUserLogsScrollRequest) Reset()      { *m = SuspiciousUserLogsScrollRequest{} }
func (*SuspiciousUserLogsScrollRequest) ProtoMessage() {}
func (*SuspiciousUserLogsScrollRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{6}
}
func (m *SuspiciousUserLogsScrollRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SuspiciousUserLogsScrollRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SuspiciousUserLogsScrollRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SuspiciousUserLogsScrollRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SuspiciousUserLogsScrollRequest.Merge(m, src)
}
func (m *SuspiciousUserLogsScrollRequest) XXX_Size() int {
	return m.Size()
}
func (m *SuspiciousUserLogsScrollRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SuspiciousUserLogsScrollRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SuspiciousUserLogsScrollRequest proto.InternalMessageInfo

func (m *SuspiciousUserLogsScrollRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *SuspiciousUserLogsScrollRequest) GetScrollId() string {
	if m != nil {
		return m.ScrollId
	}
	return ""
}

// Suspicious User Logs Response
//
// x-displayName: "Suspicious User Logs Response"
// Response message for Suspicious User Logs Request
type SuspiciousUserLogsResponse struct {
	// events
	//
	// x-displayName: "Events"
	// x-example: "value"
	// list of log messages that matched the query. Contains no more than 500 messages.
	Logs []string `protobuf:"bytes,1,rep,name=logs,proto3" json:"logs,omitempty"`
	// total hits
	//
	// x-displayName: "Total Hits"
	// x-example: "100"
	// total number of logs that matched the query.
	TotalHits uint64 `protobuf:"varint,2,opt,name=total_hits,json=totalHits,proto3" json:"total_hits,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the security events response. If the number of security events that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	Aggs map[string]*log.LogAggregationData `protobuf:"bytes,3,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// scroll id
	//
	// x-displayName: "Scroll id"
	// x-example: "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ=="
	// Long Base-64 encoded string which can be used to retrieve the next batch of suspicous user logs using the scroll request.
	// Empty scroll_id indicates no more messages to scroll (EOF).
	// Note: scroll_id is valid only for 2 minutes. i.e., If one intend to retrieve next batch of the result, then the
	//       scroll request should be sent within 2 minutes upon receiving the SuspiciousUserLogsResponse.
	ScrollId string `protobuf:"bytes,4,opt,name=scroll_id,json=scrollId,proto3" json:"scroll_id,omitempty"`
}

func (m *SuspiciousUserLogsResponse) Reset()      { *m = SuspiciousUserLogsResponse{} }
func (*SuspiciousUserLogsResponse) ProtoMessage() {}
func (*SuspiciousUserLogsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{7}
}
func (m *SuspiciousUserLogsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SuspiciousUserLogsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SuspiciousUserLogsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SuspiciousUserLogsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SuspiciousUserLogsResponse.Merge(m, src)
}
func (m *SuspiciousUserLogsResponse) XXX_Size() int {
	return m.Size()
}
func (m *SuspiciousUserLogsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SuspiciousUserLogsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SuspiciousUserLogsResponse proto.InternalMessageInfo

func (m *SuspiciousUserLogsResponse) GetLogs() []string {
	if m != nil {
		return m.Logs
	}
	return nil
}

func (m *SuspiciousUserLogsResponse) GetTotalHits() uint64 {
	if m != nil {
		return m.TotalHits
	}
	return 0
}

func (m *SuspiciousUserLogsResponse) GetAggs() map[string]*log.LogAggregationData {
	if m != nil {
		return m.Aggs
	}
	return nil
}

func (m *SuspiciousUserLogsResponse) GetScrollId() string {
	if m != nil {
		return m.ScrollId
	}
	return ""
}

// Suspicious User Logs Aggregation Request
//
// x-displayName: "Suspicious User Logs Aggregation Request"
// Request to get only aggregation data for suspicious user logs
type SuspiciousUserLogsAggregationRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// fetch suspicious user logs for a given namespace
	// x-example: "bloggin-app-namespace-1"
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// query
	//
	// x-displayName: "Query"
	// x-example: "query={vh_name="vh-1", site="ce-01"}"
	// query is used to specify the list of matchers
	// syntax for query := {[<matcher>]}
	// <matcher> := <field_name><operator>"<value>"
	// <field_name> := string
	//   One or more of these fields in the suspicious user logs may be specified in the query.
	//     vh_name - name of the virtual host
	//     user - user id
	//     site - source site
	//     city - name of the city
	//     country - country code
	// <value> := string
	// <operator> := ["="|"!="|"=~"|"!~"]
	//   = : equal to
	//   != : not equal to
	//   =~ : regex match
	//   !~ : not regex match
	// When more than one matcher is specified in the query, then suspicious user logs matching ALL the matchers will be returned in the response.
	//
	// Optional: If not specified, all the suspicious user logs matching the given tenant and namespace will be returned in the response.
	Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// start time
	//
	// x-displayName: "Start Time"
	// x-example: "1570007981"
	// fetch suspicious user logs whose timestamp >= start_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the start_time will be evaluated to end_time-10m
	//           If end_time is not specified, then the start_time will be evaluated to <current time>-10m
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end time
	//
	// x-displayName: "End Time"
	// x-example: "1570007981"
	// fetch suspicious user logs whose timestamp <= end_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the end_time will be evaluated to start_time+10m
	//           If start_time is not specified, then the end_time will be evaluated to <current time>
	EndTime string `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the suspicious user logs response. If the number of logs that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.
	// Optional
	Aggs map[string]*suspicious_user_log.AggregationRequest `protobuf:"bytes,5,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SuspiciousUserLogsAggregationRequest) Reset()      { *m = SuspiciousUserLogsAggregationRequest{} }
func (*SuspiciousUserLogsAggregationRequest) ProtoMessage() {}
func (*SuspiciousUserLogsAggregationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{8}
}
func (m *SuspiciousUserLogsAggregationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SuspiciousUserLogsAggregationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SuspiciousUserLogsAggregationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SuspiciousUserLogsAggregationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SuspiciousUserLogsAggregationRequest.Merge(m, src)
}
func (m *SuspiciousUserLogsAggregationRequest) XXX_Size() int {
	return m.Size()
}
func (m *SuspiciousUserLogsAggregationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SuspiciousUserLogsAggregationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SuspiciousUserLogsAggregationRequest proto.InternalMessageInfo

func (m *SuspiciousUserLogsAggregationRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *SuspiciousUserLogsAggregationRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *SuspiciousUserLogsAggregationRequest) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *SuspiciousUserLogsAggregationRequest) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *SuspiciousUserLogsAggregationRequest) GetAggs() map[string]*suspicious_user_log.AggregationRequest {
	if m != nil {
		return m.Aggs
	}
	return nil
}

// Suspicious User Logs Aggregation Response
//
// x-displayName: "Suspicious User Logs Aggregation Response"
// Response message for SuspiciousUserLogsAggregationRequest
type SuspiciousUserLogsAggregationResponse struct {
	// total hits
	//
	// x-displayName: "Total Hits"
	// x-example: "1400"
	// total number of suspicious user logs that matched the query.
	TotalHits uint64 `protobuf:"varint,1,opt,name=total_hits,json=totalHits,proto3" json:"total_hits,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the suspicious user logs response. If the number of logs that matched the query
	// is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.
	// The aggregation data is key'ed with the aggregation name specified in the request.
	Aggs map[string]*log.LogAggregationData `protobuf:"bytes,2,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SuspiciousUserLogsAggregationResponse) Reset()      { *m = SuspiciousUserLogsAggregationResponse{} }
func (*SuspiciousUserLogsAggregationResponse) ProtoMessage() {}
func (*SuspiciousUserLogsAggregationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{9}
}
func (m *SuspiciousUserLogsAggregationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SuspiciousUserLogsAggregationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SuspiciousUserLogsAggregationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SuspiciousUserLogsAggregationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SuspiciousUserLogsAggregationResponse.Merge(m, src)
}
func (m *SuspiciousUserLogsAggregationResponse) XXX_Size() int {
	return m.Size()
}
func (m *SuspiciousUserLogsAggregationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SuspiciousUserLogsAggregationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SuspiciousUserLogsAggregationResponse proto.InternalMessageInfo

func (m *SuspiciousUserLogsAggregationResponse) GetTotalHits() uint64 {
	if m != nil {
		return m.TotalHits
	}
	return 0
}

func (m *SuspiciousUserLogsAggregationResponse) GetAggs() map[string]*log.LogAggregationData {
	if m != nil {
		return m.Aggs
	}
	return nil
}

// SecurityEventsCountRequest
//
// x-displayName: "Security Events Count Request"
// Request to get number of security events for a given namespace.
type SecurityEventsCountRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "bloggin-app-namespace-1"
	// namespace is used to scope the security events for the given namespace.
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Label Filter
	//
	// x-displayName: "Label Filter"
	// List of label filter expressions of the form "label" `Op` "value".
	// Response will only contain data that matches all the conditions specified in the `label_filter`.
	// One or more of the following labels can be specified in the label_filter.
	// `VIRTUAL_HOST`, `SRC_SITE`, `SRC_INSTANCE`, `SEC_EVENT_TYPE`.
	//
	// Optional: If not specified, then the metrics will be filtered only based on the `namespace` in the request.
	LabelFilter []*metrics.SecurityMetricLabelFilter `protobuf:"bytes,2,rep,name=label_filter,json=labelFilter,proto3" json:"label_filter,omitempty"`
	// Group by
	//
	// x-displayName: "Group By"
	// Aggregate data by one or more labels listed here.
	// `NAMESPACE`, `VIRTUAL_HOST`, `SRC_SITE`, `SRC_INSTANCE`, `SEC_EVENT_TYPE`.
	//
	// Optional: If not specified, then the security events are aggregated/grouped by `VIRTUAL_HOST`, `SEC_EVENT_TYPE`.
	GroupBy []metrics.SecurityMetricLabel `protobuf:"varint,3,rep,packed,name=group_by,json=groupBy,proto3,enum=ves.io.schema.app_security.metrics.SecurityMetricLabel" json:"group_by,omitempty"`
	// Start time
	//
	// x-displayName: "Start Time"
	// x-example: "1570007981"
	// start time of metric collection from which data will be considered.
	// Format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the start_time will be evaluated to end_time-10m
	//           If end_time is not specified, then the start_time will be evaluated to <current time>-10m
	StartTime string `protobuf:"bytes,4,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// End time
	//
	// x-displayName: "End Time"
	// x-example: "1570007981"
	// end time of metric collection from which data will be considered.
	// Format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the end_time will be evaluated to start_time+10m
	//           If start_time is not specified, then the end_time will be evaluated to <current time>
	EndTime string `protobuf:"bytes,5,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// Step
	//
	// x-displayName: "Step"
	// x-example: "15m"
	// step is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.
	// The timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn <= end_time.
	// Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days
	//
	// Optional: If not specified, then step size is evaluated to <end_time - start_time>
	Step string `protobuf:"bytes,6,opt,name=step,proto3" json:"step,omitempty"`
}

func (m *SecurityEventsCountRequest) Reset()      { *m = SecurityEventsCountRequest{} }
func (*SecurityEventsCountRequest) ProtoMessage() {}
func (*SecurityEventsCountRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{10}
}
func (m *SecurityEventsCountRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityEventsCountRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityEventsCountRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityEventsCountRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityEventsCountRequest.Merge(m, src)
}
func (m *SecurityEventsCountRequest) XXX_Size() int {
	return m.Size()
}
func (m *SecurityEventsCountRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityEventsCountRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityEventsCountRequest proto.InternalMessageInfo

func (m *SecurityEventsCountRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *SecurityEventsCountRequest) GetLabelFilter() []*metrics.SecurityMetricLabelFilter {
	if m != nil {
		return m.LabelFilter
	}
	return nil
}

func (m *SecurityEventsCountRequest) GetGroupBy() []metrics.SecurityMetricLabel {
	if m != nil {
		return m.GroupBy
	}
	return nil
}

func (m *SecurityEventsCountRequest) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *SecurityEventsCountRequest) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *SecurityEventsCountRequest) GetStep() string {
	if m != nil {
		return m.Step
	}
	return ""
}

// SecurityEventsCountResponse
//
// x-displayName: "Security Events Count Response"
// Number of security events for each unique combination of group_by labels in the SecurityEventsCountRequest.
type SecurityEventsCountResponse struct {
	// Security events counter data
	//
	// x-displayName: "Security events counter data"
	// List of security events counter data
	Data []*metrics.SecurityEventsCounter `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
	// step
	//
	// x-displayName: "Step"
	// x-example: "30m"
	// Actual step size used in the response. It could be higher than the requested step due to metric rollups and the query duration.
	// Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days
	Step string `protobuf:"bytes,2,opt,name=step,proto3" json:"step,omitempty"`
}

func (m *SecurityEventsCountResponse) Reset()      { *m = SecurityEventsCountResponse{} }
func (*SecurityEventsCountResponse) ProtoMessage() {}
func (*SecurityEventsCountResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{11}
}
func (m *SecurityEventsCountResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityEventsCountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityEventsCountResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityEventsCountResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityEventsCountResponse.Merge(m, src)
}
func (m *SecurityEventsCountResponse) XXX_Size() int {
	return m.Size()
}
func (m *SecurityEventsCountResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityEventsCountResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityEventsCountResponse proto.InternalMessageInfo

func (m *SecurityEventsCountResponse) GetData() []*metrics.SecurityEventsCounter {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *SecurityEventsCountResponse) GetStep() string {
	if m != nil {
		return m.Step
	}
	return ""
}

// Security Incidents Request
//
// x-displayName: "Security Incidents Request"
// Request to fetch security incidents
type SecurityIncidentsRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "bloggin-app-namespace-1"
	// Fetch security incidents for a given namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// query
	//
	// x-displayName: "Query"
	// x-example: "query={app_type="blogging_app"}"
	// Query is used to specify the list of matchers
	// syntax for query := {[<matcher>]}
	// <matcher> := <field_name><operator>"<value>"
	// <field_name> := string
	//   One or more of these fields in the security incident may be specified in the query.
	//     vh_name - name of the virtual host
	//     src_site - source site
	//     city - name of the city
	//     country - country code
	// <value> := string
	// <operator> := ["="|"!="|"=~"|"!~"]
	//   = : equal to
	//   != : not equal to
	//   =~ : regex match
	//   !~ : not regex match
	// When more than one matcher is specified in the query, then security incidents matching ALL the matchers will be returned in the response.
	// Example: query={country="United States", city="California"} will return all security events originating from California, United States.
	//
	// Optional: If not specified, all the security events matching the given tenant and namespace will be returned in the response.
	Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// start time
	//
	// x-displayName: "Start Time"
	// x-example: "1570007981"
	// Fetch security incidents whose timestamp >= start_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the start_time will be evaluated to end_time-10m
	//           If end_time is not specified, then the start_time will be evaluated to <current time>-10m
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end time
	//
	// x-displayName: "End Time"
	// x-example: "1570007981"
	// Fetch security incidents whose timestamp <= end_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the end_time will be evaluated to start_time+10m
	//           If start_time is not specified, then the end_time will be evaluated to <current time>
	EndTime string `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// sort order
	//
	// x-displayName: "Sort Order"
	// Optional: default is descending order
	Sort schema.SortOrder `protobuf:"varint,5,opt,name=sort,proto3,enum=ves.io.schema.SortOrder" json:"sort,omitempty"`
	// limit
	//
	// x-displayName: "Limit"
	// x-example: "100"
	// Limits the number of security incidents returned in the response
	// Optional: If not specified, first or last 500 security events that matches the query (depending on the sort order) will be returned in the response.
	//           The maximum value for limit is 500.
	Limit int32 `protobuf:"varint,6,opt,name=limit,proto3" json:"limit,omitempty"`
	// scroll
	//
	// x-displayName: "Scroll"
	// x-example: "true"
	// Scroll is used to retrieve large number of security incidents (or all security incidents) that matches the query.
	// If scroll is set to true, the scroll_id in the response can be used in the scroll API to fetch the next
	// batch of security events until there are no more security events left to return. The number of messages in each
	// batch is determined by the limit field.
	// Note: Scroll is used for processing large amount of data and therefore is not intended for real time user request.
	// Optional: default is false
	Scroll bool `protobuf:"varint,7,opt,name=scroll,proto3" json:"scroll,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the security incidents response. If the number of security incidents
	// that matched the query is large and cannot be returned in a single response message, user can get helpful
	// insights/summary using aggregations. The aggregations are key'ed by user-defined aggregation name. The response
	// will be key'ed with the same name.
	// Optional
	Aggs map[string]*incidents.AggregationRequest `protobuf:"bytes,9,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// sort by
	//
	// x-displayName: "Sort By"
	// Optional: default is sort by last_event_time
	SortBy string `protobuf:"bytes,10,opt,name=sort_by,json=sortBy,proto3" json:"sort_by,omitempty"`
}

func (m *SecurityIncidentsRequest) Reset()      { *m = SecurityIncidentsRequest{} }
func (*SecurityIncidentsRequest) ProtoMessage() {}
func (*SecurityIncidentsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{12}
}
func (m *SecurityIncidentsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityIncidentsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityIncidentsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityIncidentsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityIncidentsRequest.Merge(m, src)
}
func (m *SecurityIncidentsRequest) XXX_Size() int {
	return m.Size()
}
func (m *SecurityIncidentsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityIncidentsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityIncidentsRequest proto.InternalMessageInfo

func (m *SecurityIncidentsRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *SecurityIncidentsRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *SecurityIncidentsRequest) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *SecurityIncidentsRequest) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *SecurityIncidentsRequest) GetSort() schema.SortOrder {
	if m != nil {
		return m.Sort
	}
	return schema.DESCENDING
}

func (m *SecurityIncidentsRequest) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SecurityIncidentsRequest) GetScroll() bool {
	if m != nil {
		return m.Scroll
	}
	return false
}

func (m *SecurityIncidentsRequest) GetAggs() map[string]*incidents.AggregationRequest {
	if m != nil {
		return m.Aggs
	}
	return nil
}

func (m *SecurityIncidentsRequest) GetSortBy() string {
	if m != nil {
		return m.SortBy
	}
	return ""
}

// Security Incidents Scroll Request
//
// x-displayName: "Security Incidents Scroll Request"
// Scroll request is used to fetch large number of security incidents in multiple batches with each SecurityIncidentsResponse
// containing no more than 500 messages. To scroll through more than 500 or all security incidents, one can use the
// SecurityIncidentsScrollRequest. Use the scroll_id returned in the SecurityIncidentsResponse to fetch the next batch
// of security events and one can continue this process till the scroll_id returned is "" which indicates no more
// messages to scroll.
type SecurityIncidentsScrollRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "bloggin-app-namespace-1"
	// Fetch security incidents for a given namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// scroll id
	//
	// x-displayName: "Scroll ID"
	// x-example: "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ=="
	// Long Base-64 encoded string which can be used to retrieve next batch of security events.
	ScrollId string `protobuf:"bytes,2,opt,name=scroll_id,json=scrollId,proto3" json:"scroll_id,omitempty"`
}

func (m *SecurityIncidentsScrollRequest) Reset()      { *m = SecurityIncidentsScrollRequest{} }
func (*SecurityIncidentsScrollRequest) ProtoMessage() {}
func (*SecurityIncidentsScrollRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{13}
}
func (m *SecurityIncidentsScrollRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityIncidentsScrollRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityIncidentsScrollRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityIncidentsScrollRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityIncidentsScrollRequest.Merge(m, src)
}
func (m *SecurityIncidentsScrollRequest) XXX_Size() int {
	return m.Size()
}
func (m *SecurityIncidentsScrollRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityIncidentsScrollRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityIncidentsScrollRequest proto.InternalMessageInfo

func (m *SecurityIncidentsScrollRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *SecurityIncidentsScrollRequest) GetScrollId() string {
	if m != nil {
		return m.ScrollId
	}
	return ""
}

// Security Incidents Response
//
// x-displayName: "Security Incidents Response"
// Response message for SecurityIncidentsRequest/SecurityIncidentsScrollRequest
type SecurityIncidentsResponse struct {
	// incidents
	//
	// x-displayName: "Incidents"
	// x-example: "value"
	// list of security incidents that matched the query. Contains no more than 500 messages.
	Incidents []string `protobuf:"bytes,1,rep,name=incidents,proto3" json:"incidents,omitempty"`
	// total hits
	//
	// x-displayName: "Total Hits"
	// x-example: "0"
	// total number of security events that matched the query.
	TotalHits uint64 `protobuf:"varint,2,opt,name=total_hits,json=totalHits,proto3" json:"total_hits,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the security incidents response. If the number of security incidents
	// that matched the query is large and cannot be returned in a single response message, user can get helpful
	// insights/summary using aggregations.
	Aggs map[string]*log.LogAggregationData `protobuf:"bytes,3,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// scroll id
	//
	// x-displayName: "Scroll id"
	// x-example: "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ=="
	// Long Base-64 encoded string which can be used to retrieve the next batch of security incidents using the scroll
	// request.
	// Empty scroll_id indicates no more messages to scroll (EOF).
	// Note: scroll_id is valid only for 2 minutes. i.e., If one intend to retrieve next batch of the result, then the
	//       scroll request should be sent within 2 minutes upon receiving the SecurityIncidentsResponse.
	ScrollId string `protobuf:"bytes,4,opt,name=scroll_id,json=scrollId,proto3" json:"scroll_id,omitempty"`
}

func (m *SecurityIncidentsResponse) Reset()      { *m = SecurityIncidentsResponse{} }
func (*SecurityIncidentsResponse) ProtoMessage() {}
func (*SecurityIncidentsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{14}
}
func (m *SecurityIncidentsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityIncidentsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityIncidentsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityIncidentsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityIncidentsResponse.Merge(m, src)
}
func (m *SecurityIncidentsResponse) XXX_Size() int {
	return m.Size()
}
func (m *SecurityIncidentsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityIncidentsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityIncidentsResponse proto.InternalMessageInfo

func (m *SecurityIncidentsResponse) GetIncidents() []string {
	if m != nil {
		return m.Incidents
	}
	return nil
}

func (m *SecurityIncidentsResponse) GetTotalHits() uint64 {
	if m != nil {
		return m.TotalHits
	}
	return 0
}

func (m *SecurityIncidentsResponse) GetAggs() map[string]*log.LogAggregationData {
	if m != nil {
		return m.Aggs
	}
	return nil
}

func (m *SecurityIncidentsResponse) GetScrollId() string {
	if m != nil {
		return m.ScrollId
	}
	return ""
}

// Security Incidents Aggregation Request
//
// x-displayName: "Security Incidents Aggregation Request"
// Request to get only aggregation data for security incidents
type SecurityIncidentsAggregationRequest struct {
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "bloggin-app-namespace-1"
	// Fetch security incidents for a given namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// query
	//
	// x-displayName: "Query"
	// x-example: "query={app_type="blogging_app"}"
	// Query is used to specify the list of matchers
	// syntax for query := {[<matcher>]}
	// <matcher> := <field_name><operator>"<value>"
	// <field_name> := string
	//   One or more of these fields in the security event may be specified in the query.
	//     vh_name - name of the virtual host
	//     src_site - source site
	//     city - name of the city
	//     country - country code
	// <value> := string
	// <operator> := ["="|"!="|"=~"|"!~"]
	//   = : equal to
	//   != : not equal to
	//   =~ : regex match
	//   !~ : not regex match
	// When more than one matcher is specified in the query, then security incidents matching ALL the matchers will be
	// returned in the response.
	// Example: query={country="United States", city="California"} will return all security incidents originating from
	// California, United States.
	//
	// Optional: If not specified, all security incidents matching the given tenant and namespace will be returned in
	// the response.
	Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	// start time
	//
	// x-displayName: "Start Time"
	// x-example: "1570007981"
	// Fetch security incidents whose timestamp >= start_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the start_time will be evaluated to end_time-10m
	//           If end_time is not specified, then the start_time will be evaluated to <current time>-10m
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end time
	//
	// x-displayName: "End Time"
	// x-example: "1570007981"
	// Fetch security incidents whose timestamp <= end_time
	// format: unix_timestamp|rfc 3339
	//
	// Optional: If not specified, then the end_time will be evaluated to start_time+10m
	//           If start_time is not specified, then the end_time will be evaluated to <current time>
	EndTime string `protobuf:"bytes,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over security incidents response. If the number of security incidents
	// that matched the query is large and cannot be returned in a single response message, user can get helpful
	// insights/summary using aggregations. The aggregations are key'ed by user-defined aggregation name.
	// The response will be key'ed with the same name.
	// Optional
	Aggs map[string]*incidents.AggregationRequest `protobuf:"bytes,5,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SecurityIncidentsAggregationRequest) Reset()      { *m = SecurityIncidentsAggregationRequest{} }
func (*SecurityIncidentsAggregationRequest) ProtoMessage() {}
func (*SecurityIncidentsAggregationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{15}
}
func (m *SecurityIncidentsAggregationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityIncidentsAggregationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityIncidentsAggregationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityIncidentsAggregationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityIncidentsAggregationRequest.Merge(m, src)
}
func (m *SecurityIncidentsAggregationRequest) XXX_Size() int {
	return m.Size()
}
func (m *SecurityIncidentsAggregationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityIncidentsAggregationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityIncidentsAggregationRequest proto.InternalMessageInfo

func (m *SecurityIncidentsAggregationRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *SecurityIncidentsAggregationRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *SecurityIncidentsAggregationRequest) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *SecurityIncidentsAggregationRequest) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *SecurityIncidentsAggregationRequest) GetAggs() map[string]*incidents.AggregationRequest {
	if m != nil {
		return m.Aggs
	}
	return nil
}

// Security Incidents Aggregation Response
//
// x-displayName: "Security Incidents Aggregation Response"
// Response message for SecurityIncidentsAggregationRequest
type SecurityIncidentsAggregationResponse struct {
	// total hits
	//
	// x-displayName: "Total Hits"
	// x-example: "0"
	// Total number of security incidents that matched the query.
	TotalHits uint64 `protobuf:"varint,1,opt,name=total_hits,json=totalHits,proto3" json:"total_hits,omitempty"`
	// aggregations
	//
	// x-displayName: "Aggregations"
	// Aggregations provide summary/analytics data over the security incidents response. If the number of security incidents
	// that matched the query is large and cannot be returned in a single response message, user can get helpful
	// insights/summary using aggregations. The aggregation data is key'ed with the aggregation name specified in the request.
	Aggs map[string]*log.LogAggregationData `protobuf:"bytes,2,rep,name=aggs,proto3" json:"aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SecurityIncidentsAggregationResponse) Reset()      { *m = SecurityIncidentsAggregationResponse{} }
func (*SecurityIncidentsAggregationResponse) ProtoMessage() {}
func (*SecurityIncidentsAggregationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{16}
}
func (m *SecurityIncidentsAggregationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityIncidentsAggregationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityIncidentsAggregationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityIncidentsAggregationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityIncidentsAggregationResponse.Merge(m, src)
}
func (m *SecurityIncidentsAggregationResponse) XXX_Size() int {
	return m.Size()
}
func (m *SecurityIncidentsAggregationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityIncidentsAggregationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityIncidentsAggregationResponse proto.InternalMessageInfo

func (m *SecurityIncidentsAggregationResponse) GetTotalHits() uint64 {
	if m != nil {
		return m.TotalHits
	}
	return 0
}

func (m *SecurityIncidentsAggregationResponse) GetAggs() map[string]*log.LogAggregationData {
	if m != nil {
		return m.Aggs
	}
	return nil
}

// Search Filter
//
// x-displayName: "Search Filter"
// Metric label filter can be specified to query specific metrics based on label match
type SearchFilter struct {
	// Search Label
	//
	// x-displayName: "Search Label"
	// Label name which is used in the search filter.
	Label SearchLabel `protobuf:"varint,1,opt,name=label,proto3,enum=ves.io.schema.app_security.SearchLabel" json:"label,omitempty"`
	// Operator
	//
	// x-displayName: "Operator"
	// Operator to evaluate the label in this filter
	Op SearchLabelOperator `protobuf:"varint,2,opt,name=op,proto3,enum=ves.io.schema.app_security.SearchLabelOperator" json:"op,omitempty"`
	// Value
	//
	// x-displayName: "Value"
	// x-example: "["blogging-app-namespace-1", "namespace-2"]"
	// Value to be compared with
	Value []string `protobuf:"bytes,3,rep,name=value,proto3" json:"value,omitempty"`
}

func (m *SearchFilter) Reset()      { *m = SearchFilter{} }
func (*SearchFilter) ProtoMessage() {}
func (*SearchFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{17}
}
func (m *SearchFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchFilter.Merge(m, src)
}
func (m *SearchFilter) XXX_Size() int {
	return m.Size()
}
func (m *SearchFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchFilter.DiscardUnknown(m)
}

var xxx_messageInfo_SearchFilter proto.InternalMessageInfo

func (m *SearchFilter) GetLabel() SearchLabel {
	if m != nil {
		return m.Label
	}
	return REQUEST_ID
}

func (m *SearchFilter) GetOp() SearchLabelOperator {
	if m != nil {
		return m.Op
	}
	return IN
}

func (m *SearchFilter) GetValue() []string {
	if m != nil {
		return m.Value
	}
	return nil
}

// SearchLoadBalancersRequest
//
// x-displayName: "Search Load Balancers Request"
// Get a list of virtual hosts in all the namespaces matching filter provided in the request.
// The filter can be a) Request ID b) Source IP
type SearchLoadBalancersRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "shared"
	// Namespace of the App type for current request
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Label Filter
	//
	// x-displayName: "Label Filter"
	// List of label filter expressions of the form "label" `Op` "value".
	// Response will only contain data that matches all the conditions specified in the `label_filter`.
	// One or more of the following labels can be specified in the label_filter.
	// `REQUEST_ID`, `SOURCE_IP``.
	//
	LabelFilter []*SearchFilter `protobuf:"bytes,2,rep,name=label_filter,json=labelFilter,proto3" json:"label_filter,omitempty"`
}

func (m *SearchLoadBalancersRequest) Reset()      { *m = SearchLoadBalancersRequest{} }
func (*SearchLoadBalancersRequest) ProtoMessage() {}
func (*SearchLoadBalancersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{18}
}
func (m *SearchLoadBalancersRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchLoadBalancersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchLoadBalancersRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchLoadBalancersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchLoadBalancersRequest.Merge(m, src)
}
func (m *SearchLoadBalancersRequest) XXX_Size() int {
	return m.Size()
}
func (m *SearchLoadBalancersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchLoadBalancersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SearchLoadBalancersRequest proto.InternalMessageInfo

func (m *SearchLoadBalancersRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *SearchLoadBalancersRequest) GetLabelFilter() []*SearchFilter {
	if m != nil {
		return m.LabelFilter
	}
	return nil
}

// SearchLoadBalancersResponse
//
// x-displayName: "Search Load Balancers Response"
// List of virtual hosts in all the namespaces matching filter provided in the request.
type SearchLoadBalancersResponse struct {
	// Loadbalancers
	//
	// x-displayName: "HTTP Load Balancer List"
	// x-example: "[ves-io-frontend", "ns1" , "1", "0"]"
	// HTTP load balancer list for which the SearchFilter is applied.
	Loadbalancers []*LoadbalancerData `protobuf:"bytes,1,rep,name=loadbalancers,proto3" json:"loadbalancers,omitempty"`
}

func (m *SearchLoadBalancersResponse) Reset()      { *m = SearchLoadBalancersResponse{} }
func (*SearchLoadBalancersResponse) ProtoMessage() {}
func (*SearchLoadBalancersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{19}
}
func (m *SearchLoadBalancersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SearchLoadBalancersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SearchLoadBalancersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SearchLoadBalancersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SearchLoadBalancersResponse.Merge(m, src)
}
func (m *SearchLoadBalancersResponse) XXX_Size() int {
	return m.Size()
}
func (m *SearchLoadBalancersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SearchLoadBalancersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SearchLoadBalancersResponse proto.InternalMessageInfo

func (m *SearchLoadBalancersResponse) GetLoadbalancers() []*LoadbalancerData {
	if m != nil {
		return m.Loadbalancers
	}
	return nil
}

// LoadbalancerData
//
// x-displayName: "Load Balancer data"
// List of virtual hosts in all the namespaces matching filter provided in the request.
type LoadbalancerData struct {
	// Name
	//
	// x-displayName: "HTTP Load Balancer Name"
	// x-example: "ves-io-frontend"
	// HTTP load balancer name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace"
	// Namespace of the virtual host.
	// x-example: "bloggin-app-namespace-1"
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Security Events Data
	//
	// x-displayName: "Security Events Data"
	// x-example: "[5, 01-01-1970T00:00:00Z, 01-01-1970T00:00:00Z]"
	// Security Events Data
	SecurityEventsData *SecurityEventsData `protobuf:"bytes,3,opt,name=security_events_data,json=securityEventsData,proto3" json:"security_events_data,omitempty"`
	// Request Data
	//
	// x-displayName: "Request Data"
	// x-example: "[5, 01-01-1970T00:00:00Z, 01-01-1970T00:00:00Z]"
	// Request Data
	RequestData *RequestData `protobuf:"bytes,4,opt,name=request_data,json=requestData,proto3" json:"request_data,omitempty"`
}

func (m *LoadbalancerData) Reset()      { *m = LoadbalancerData{} }
func (*LoadbalancerData) ProtoMessage() {}
func (*LoadbalancerData) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{20}
}
func (m *LoadbalancerData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadbalancerData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadbalancerData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadbalancerData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadbalancerData.Merge(m, src)
}
func (m *LoadbalancerData) XXX_Size() int {
	return m.Size()
}
func (m *LoadbalancerData) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadbalancerData.DiscardUnknown(m)
}

var xxx_messageInfo_LoadbalancerData proto.InternalMessageInfo

func (m *LoadbalancerData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LoadbalancerData) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *LoadbalancerData) GetSecurityEventsData() *SecurityEventsData {
	if m != nil {
		return m.SecurityEventsData
	}
	return nil
}

func (m *LoadbalancerData) GetRequestData() *RequestData {
	if m != nil {
		return m.RequestData
	}
	return nil
}

// SecurityEventsData
//
// x-displayName: "Security Events Data"
// Security events data
type SecurityEventsData struct {
	// Count.
	//
	// x-displayName: "Count"
	// x-example: 15
	// the number of security events for virtual host in the given namespace
	Count uint64 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	// Minimum Time
	//
	// x-displayName: "Minimum time"
	// x-example: "01-01-1970T00:00:00Z"
	// Minimum time at which the secuirty event was found.
	MinTime *types.Timestamp `protobuf:"bytes,2,opt,name=min_time,json=minTime,proto3" json:"min_time,omitempty"`
	// Maximun Time
	//
	// x-displayName: "Maximum time"
	// x-example: "01-01-1970T00:00:00Z"
	// Maximum start time at which security event was found.
	MaxTime *types.Timestamp `protobuf:"bytes,3,opt,name=max_time,json=maxTime,proto3" json:"max_time,omitempty"`
}

func (m *SecurityEventsData) Reset()      { *m = SecurityEventsData{} }
func (*SecurityEventsData) ProtoMessage() {}
func (*SecurityEventsData) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{21}
}
func (m *SecurityEventsData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityEventsData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityEventsData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityEventsData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityEventsData.Merge(m, src)
}
func (m *SecurityEventsData) XXX_Size() int {
	return m.Size()
}
func (m *SecurityEventsData) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityEventsData.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityEventsData proto.InternalMessageInfo

func (m *SecurityEventsData) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *SecurityEventsData) GetMinTime() *types.Timestamp {
	if m != nil {
		return m.MinTime
	}
	return nil
}

func (m *SecurityEventsData) GetMaxTime() *types.Timestamp {
	if m != nil {
		return m.MaxTime
	}
	return nil
}

// RequestData
//
// x-displayName: "Request Data"
// Request Data
type RequestData struct {
	// Count.
	//
	// x-displayName: "Count"
	// x-example: 15
	// the number of requests matching the filter for virtual host in the given namespace
	Count uint64 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	// Minimum Time
	//
	// x-displayName: "Minimum time"
	// x-example: "01-01-1970T00:00:00Z"
	// Minimum time at which the request ID was found.
	MinTime *types.Timestamp `protobuf:"bytes,2,opt,name=min_time,json=minTime,proto3" json:"min_time,omitempty"`
	// Maximun Time
	//
	// x-displayName: "Maximum time"
	// x-example: "01-01-1970T00:00:00Z"
	// Maximum time at which request ID was found.
	MaxTime *types.Timestamp `protobuf:"bytes,3,opt,name=max_time,json=maxTime,proto3" json:"max_time,omitempty"`
}

func (m *RequestData) Reset()      { *m = RequestData{} }
func (*RequestData) ProtoMessage() {}
func (*RequestData) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9bb0a693f4ed96, []int{22}
}
func (m *RequestData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestData.Merge(m, src)
}
func (m *RequestData) XXX_Size() int {
	return m.Size()
}
func (m *RequestData) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestData.DiscardUnknown(m)
}

var xxx_messageInfo_RequestData proto.InternalMessageInfo

func (m *RequestData) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *RequestData) GetMinTime() *types.Timestamp {
	if m != nil {
		return m.MinTime
	}
	return nil
}

func (m *RequestData) GetMaxTime() *types.Timestamp {
	if m != nil {
		return m.MaxTime
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.app_security.SearchLabel", SearchLabel_name, SearchLabel_value)
	golang_proto.RegisterEnum("ves.io.schema.app_security.SearchLabel", SearchLabel_name, SearchLabel_value)
	proto.RegisterEnum("ves.io.schema.app_security.SearchLabelOperator", SearchLabelOperator_name, SearchLabelOperator_value)
	golang_proto.RegisterEnum("ves.io.schema.app_security.SearchLabelOperator", SearchLabelOperator_name, SearchLabelOperator_value)
	proto.RegisterType((*SecurityEventsRequest)(nil), "ves.io.schema.app_security.SecurityEventsRequest")
	golang_proto.RegisterType((*SecurityEventsRequest)(nil), "ves.io.schema.app_security.SecurityEventsRequest")
	proto.RegisterMapType((map[string]*AggregationRequest)(nil), "ves.io.schema.app_security.SecurityEventsRequest.AggsEntry")
	golang_proto.RegisterMapType((map[string]*AggregationRequest)(nil), "ves.io.schema.app_security.SecurityEventsRequest.AggsEntry")
	proto.RegisterType((*SecurityEventsScrollRequest)(nil), "ves.io.schema.app_security.SecurityEventsScrollRequest")
	golang_proto.RegisterType((*SecurityEventsScrollRequest)(nil), "ves.io.schema.app_security.SecurityEventsScrollRequest")
	proto.RegisterType((*SecurityEventsResponse)(nil), "ves.io.schema.app_security.SecurityEventsResponse")
	golang_proto.RegisterType((*SecurityEventsResponse)(nil), "ves.io.schema.app_security.SecurityEventsResponse")
	proto.RegisterMapType((map[string]*log.LogAggregationData)(nil), "ves.io.schema.app_security.SecurityEventsResponse.AggsEntry")
	golang_proto.RegisterMapType((map[string]*log.LogAggregationData)(nil), "ves.io.schema.app_security.SecurityEventsResponse.AggsEntry")
	proto.RegisterType((*SecurityEventsAggregationRequest)(nil), "ves.io.schema.app_security.SecurityEventsAggregationRequest")
	golang_proto.RegisterType((*SecurityEventsAggregationRequest)(nil), "ves.io.schema.app_security.SecurityEventsAggregationRequest")
	proto.RegisterMapType((map[string]*AggregationRequest)(nil), "ves.io.schema.app_security.SecurityEventsAggregationRequest.AggsEntry")
	golang_proto.RegisterMapType((map[string]*AggregationRequest)(nil), "ves.io.schema.app_security.SecurityEventsAggregationRequest.AggsEntry")
	proto.RegisterType((*SecurityEventsAggregationResponse)(nil), "ves.io.schema.app_security.SecurityEventsAggregationResponse")
	golang_proto.RegisterType((*SecurityEventsAggregationResponse)(nil), "ves.io.schema.app_security.SecurityEventsAggregationResponse")
	proto.RegisterMapType((map[string]*log.LogAggregationData)(nil), "ves.io.schema.app_security.SecurityEventsAggregationResponse.AggsEntry")
	golang_proto.RegisterMapType((map[string]*log.LogAggregationData)(nil), "ves.io.schema.app_security.SecurityEventsAggregationResponse.AggsEntry")
	proto.RegisterType((*SuspiciousUserLogsRequest)(nil), "ves.io.schema.app_security.SuspiciousUserLogsRequest")
	golang_proto.RegisterType((*SuspiciousUserLogsRequest)(nil), "ves.io.schema.app_security.SuspiciousUserLogsRequest")
	proto.RegisterMapType((map[string]*suspicious_user_log.AggregationRequest)(nil), "ves.io.schema.app_security.SuspiciousUserLogsRequest.AggsEntry")
	golang_proto.RegisterMapType((map[string]*suspicious_user_log.AggregationRequest)(nil), "ves.io.schema.app_security.SuspiciousUserLogsRequest.AggsEntry")
	proto.RegisterType((*SuspiciousUserLogsScrollRequest)(nil), "ves.io.schema.app_security.SuspiciousUserLogsScrollRequest")
	golang_proto.RegisterType((*SuspiciousUserLogsScrollRequest)(nil), "ves.io.schema.app_security.SuspiciousUserLogsScrollRequest")
	proto.RegisterType((*SuspiciousUserLogsResponse)(nil), "ves.io.schema.app_security.SuspiciousUserLogsResponse")
	golang_proto.RegisterType((*SuspiciousUserLogsResponse)(nil), "ves.io.schema.app_security.SuspiciousUserLogsResponse")
	proto.RegisterMapType((map[string]*log.LogAggregationData)(nil), "ves.io.schema.app_security.SuspiciousUserLogsResponse.AggsEntry")
	golang_proto.RegisterMapType((map[string]*log.LogAggregationData)(nil), "ves.io.schema.app_security.SuspiciousUserLogsResponse.AggsEntry")
	proto.RegisterType((*SuspiciousUserLogsAggregationRequest)(nil), "ves.io.schema.app_security.SuspiciousUserLogsAggregationRequest")
	golang_proto.RegisterType((*SuspiciousUserLogsAggregationRequest)(nil), "ves.io.schema.app_security.SuspiciousUserLogsAggregationRequest")
	proto.RegisterMapType((map[string]*suspicious_user_log.AggregationRequest)(nil), "ves.io.schema.app_security.SuspiciousUserLogsAggregationRequest.AggsEntry")
	golang_proto.RegisterMapType((map[string]*suspicious_user_log.AggregationRequest)(nil), "ves.io.schema.app_security.SuspiciousUserLogsAggregationRequest.AggsEntry")
	proto.RegisterType((*SuspiciousUserLogsAggregationResponse)(nil), "ves.io.schema.app_security.SuspiciousUserLogsAggregationResponse")
	golang_proto.RegisterType((*SuspiciousUserLogsAggregationResponse)(nil), "ves.io.schema.app_security.SuspiciousUserLogsAggregationResponse")
	proto.RegisterMapType((map[string]*log.LogAggregationData)(nil), "ves.io.schema.app_security.SuspiciousUserLogsAggregationResponse.AggsEntry")
	golang_proto.RegisterMapType((map[string]*log.LogAggregationData)(nil), "ves.io.schema.app_security.SuspiciousUserLogsAggregationResponse.AggsEntry")
	proto.RegisterType((*SecurityEventsCountRequest)(nil), "ves.io.schema.app_security.SecurityEventsCountRequest")
	golang_proto.RegisterType((*SecurityEventsCountRequest)(nil), "ves.io.schema.app_security.SecurityEventsCountRequest")
	proto.RegisterType((*SecurityEventsCountResponse)(nil), "ves.io.schema.app_security.SecurityEventsCountResponse")
	golang_proto.RegisterType((*SecurityEventsCountResponse)(nil), "ves.io.schema.app_security.SecurityEventsCountResponse")
	proto.RegisterType((*SecurityIncidentsRequest)(nil), "ves.io.schema.app_security.SecurityIncidentsRequest")
	golang_proto.RegisterType((*SecurityIncidentsRequest)(nil), "ves.io.schema.app_security.SecurityIncidentsRequest")
	proto.RegisterMapType((map[string]*incidents.AggregationRequest)(nil), "ves.io.schema.app_security.SecurityIncidentsRequest.AggsEntry")
	golang_proto.RegisterMapType((map[string]*incidents.AggregationRequest)(nil), "ves.io.schema.app_security.SecurityIncidentsRequest.AggsEntry")
	proto.RegisterType((*SecurityIncidentsScrollRequest)(nil), "ves.io.schema.app_security.SecurityIncidentsScrollRequest")
	golang_proto.RegisterType((*SecurityIncidentsScrollRequest)(nil), "ves.io.schema.app_security.SecurityIncidentsScrollRequest")
	proto.RegisterType((*SecurityIncidentsResponse)(nil), "ves.io.schema.app_security.SecurityIncidentsResponse")
	golang_proto.RegisterType((*SecurityIncidentsResponse)(nil), "ves.io.schema.app_security.SecurityIncidentsResponse")
	proto.RegisterMapType((map[string]*log.LogAggregationData)(nil), "ves.io.schema.app_security.SecurityIncidentsResponse.AggsEntry")
	golang_proto.RegisterMapType((map[string]*log.LogAggregationData)(nil), "ves.io.schema.app_security.SecurityIncidentsResponse.AggsEntry")
	proto.RegisterType((*SecurityIncidentsAggregationRequest)(nil), "ves.io.schema.app_security.SecurityIncidentsAggregationRequest")
	golang_proto.RegisterType((*SecurityIncidentsAggregationRequest)(nil), "ves.io.schema.app_security.SecurityIncidentsAggregationRequest")
	proto.RegisterMapType((map[string]*incidents.AggregationRequest)(nil), "ves.io.schema.app_security.SecurityIncidentsAggregationRequest.AggsEntry")
	golang_proto.RegisterMapType((map[string]*incidents.AggregationRequest)(nil), "ves.io.schema.app_security.SecurityIncidentsAggregationRequest.AggsEntry")
	proto.RegisterType((*SecurityIncidentsAggregationResponse)(nil), "ves.io.schema.app_security.SecurityIncidentsAggregationResponse")
	golang_proto.RegisterType((*SecurityIncidentsAggregationResponse)(nil), "ves.io.schema.app_security.SecurityIncidentsAggregationResponse")
	proto.RegisterMapType((map[string]*log.LogAggregationData)(nil), "ves.io.schema.app_security.SecurityIncidentsAggregationResponse.AggsEntry")
	golang_proto.RegisterMapType((map[string]*log.LogAggregationData)(nil), "ves.io.schema.app_security.SecurityIncidentsAggregationResponse.AggsEntry")
	proto.RegisterType((*SearchFilter)(nil), "ves.io.schema.app_security.SearchFilter")
	golang_proto.RegisterType((*SearchFilter)(nil), "ves.io.schema.app_security.SearchFilter")
	proto.RegisterType((*SearchLoadBalancersRequest)(nil), "ves.io.schema.app_security.SearchLoadBalancersRequest")
	golang_proto.RegisterType((*SearchLoadBalancersRequest)(nil), "ves.io.schema.app_security.SearchLoadBalancersRequest")
	proto.RegisterType((*SearchLoadBalancersResponse)(nil), "ves.io.schema.app_security.SearchLoadBalancersResponse")
	golang_proto.RegisterType((*SearchLoadBalancersResponse)(nil), "ves.io.schema.app_security.SearchLoadBalancersResponse")
	proto.RegisterType((*LoadbalancerData)(nil), "ves.io.schema.app_security.LoadbalancerData")
	golang_proto.RegisterType((*LoadbalancerData)(nil), "ves.io.schema.app_security.LoadbalancerData")
	proto.RegisterType((*SecurityEventsData)(nil), "ves.io.schema.app_security.SecurityEventsData")
	golang_proto.RegisterType((*SecurityEventsData)(nil), "ves.io.schema.app_security.SecurityEventsData")
	proto.RegisterType((*RequestData)(nil), "ves.io.schema.app_security.RequestData")
	golang_proto.RegisterType((*RequestData)(nil), "ves.io.schema.app_security.RequestData")
}

func init() {
	proto.RegisterFile("ves.io/schema/app_security/public_monitoring_api.proto", fileDescriptor_0a9bb0a693f4ed96)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/app_security/public_monitoring_api.proto", fileDescriptor_0a9bb0a693f4ed96)
}

var fileDescriptor_0a9bb0a693f4ed96 = []byte{
	// 2321 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x5a, 0x4d, 0x6c, 0x1b, 0xc7,
	0x15, 0xd6, 0x2c, 0x29, 0x59, 0x1c, 0x39, 0x86, 0xb0, 0x4d, 0x13, 0x9a, 0x96, 0x69, 0x66, 0x13,
	0xa7, 0xb2, 0xeb, 0x25, 0x53, 0x26, 0xf2, 0x8f, 0xfc, 0x23, 0x4b, 0xb6, 0xec, 0x4a, 0x95, 0x25,
	0x9b, 0x92, 0x51, 0xc3, 0xaa, 0xbd, 0x19, 0x92, 0xa3, 0xd5, 0x26, 0xcb, 0x9d, 0xf5, 0xee, 0x92,
	0x91, 0xe2, 0xb6, 0x68, 0x03, 0xa4, 0x41, 0x82, 0x14, 0xfd, 0x0d, 0x62, 0xa0, 0x45, 0x51, 0xe4,
	0xd2, 0xa2, 0xa7, 0x00, 0xbd, 0x14, 0xf5, 0xc5, 0x3d, 0xd9, 0x28, 0x8a, 0xc2, 0x6d, 0x2e, 0x39,
	0xd6, 0x74, 0x0f, 0xa9, 0x81, 0x02, 0x46, 0x80, 0x1e, 0x7a, 0x28, 0x1a, 0xec, 0xec, 0xf0, 0x67,
	0x48, 0x6a, 0xc5, 0x25, 0x19, 0x5b, 0x40, 0x6e, 0x3b, 0x3b, 0xf3, 0xde, 0xbe, 0xf7, 0xcd, 0x7b,
	0xdf, 0x9b, 0x7d, 0xbb, 0xf0, 0x60, 0x09, 0xdb, 0x49, 0x8d, 0xa4, 0xec, 0xdc, 0x2a, 0x2e, 0xa0,
	0x14, 0x32, 0x4d, 0xc5, 0xc6, 0xb9, 0xa2, 0xa5, 0x39, 0xeb, 0x29, 0xb3, 0x98, 0xd5, 0xb5, 0x9c,
	0x52, 0x20, 0x86, 0xe6, 0x10, 0x4b, 0x33, 0x54, 0x05, 0x99, 0x5a, 0xd2, 0xb4, 0x88, 0x43, 0xc4,
	0x98, 0x27, 0x97, 0xf4, 0xe4, 0x92, 0xf5, 0x72, 0x31, 0x59, 0xd5, 0x9c, 0xd5, 0x62, 0x36, 0x99,
	0x23, 0x85, 0x94, 0x4a, 0x54, 0x92, 0xa2, 0x22, 0xd9, 0xe2, 0x0a, 0x1d, 0xd1, 0x01, 0xbd, 0xf2,
	0x54, 0xc5, 0x46, 0x54, 0x42, 0x54, 0x1d, 0xa7, 0x90, 0xa9, 0xa5, 0x90, 0x61, 0x10, 0x07, 0x39,
	0x1a, 0x31, 0x6c, 0x36, 0xbb, 0x87, 0xcd, 0x56, 0x75, 0x38, 0x5a, 0x01, 0xdb, 0x0e, 0x2a, 0x98,
	0x6c, 0xc1, 0x0b, 0x3e, 0x1e, 0x68, 0x46, 0x4e, 0xcb, 0x63, 0xc3, 0xb1, 0x53, 0xce, 0xba, 0x89,
	0x2b, 0x2a, 0x93, 0x3e, 0x12, 0x05, 0xec, 0x58, 0x5a, 0x8e, 0x5f, 0x3f, 0xee, 0xb3, 0xde, 0x2e,
	0xda, 0xa6, 0x96, 0xd3, 0x48, 0xd1, 0x56, 0x8a, 0x36, 0xb6, 0x14, 0x9d, 0xa8, 0x9c, 0xec, 0xf3,
	0x3e, 0xb2, 0xf5, 0xeb, 0x76, 0xf3, 0xeb, 0x1a, 0xd5, 0xec, 0xe2, 0xa7, 0x89, 0x59, 0x0f, 0xd1,
	0x4e, 0x7e, 0xb2, 0x5e, 0x6e, 0x84, 0x9f, 0x2a, 0x21, 0x5d, 0xcb, 0x23, 0x07, 0xb3, 0x59, 0xa9,
	0x61, 0x16, 0xdb, 0xd8, 0x28, 0x35, 0x28, 0x4f, 0x34, 0xac, 0xd1, 0xf0, 0x6b, 0x0a, 0xb7, 0x42,
	0xfa, 0x4b, 0x08, 0x7e, 0x79, 0x91, 0xf9, 0x34, 0x5d, 0x72, 0xd1, 0xce, 0xe0, 0x6b, 0x45, 0x6c,
	0x3b, 0xe2, 0x08, 0x8c, 0x18, 0xa8, 0x80, 0x6d, 0x13, 0xe5, 0x70, 0x14, 0x24, 0xc0, 0x68, 0x24,
	0x53, 0xbb, 0x21, 0x3e, 0x09, 0xfb, 0xaf, 0x15, 0xb1, 0xb5, 0x1e, 0x15, 0xe8, 0x8c, 0x37, 0x10,
	0xf7, 0x41, 0x68, 0x3b, 0xc8, 0x72, 0x14, 0x77, 0x9f, 0xa3, 0x21, 0x77, 0x6a, 0x0a, 0xfe, 0xf1,
	0x5f, 0xb7, 0x42, 0xfd, 0x56, 0xe8, 0x46, 0x18, 0x64, 0x22, 0x74, 0x76, 0x49, 0x2b, 0x60, 0x71,
	0x2f, 0x1c, 0xc4, 0x46, 0xde, 0x5b, 0x18, 0x6e, 0x5a, 0xb8, 0x0d, 0x1b, 0x79, 0xba, 0xec, 0x00,
	0x0c, 0xdb, 0xc4, 0x72, 0xa2, 0xfd, 0x09, 0x30, 0xba, 0x23, 0x1d, 0x4d, 0xf2, 0x91, 0xbb, 0x48,
	0x2c, 0x67, 0xc1, 0xca, 0x63, 0x2b, 0x43, 0x57, 0xb9, 0x56, 0xe9, 0x5a, 0x41, 0x73, 0xa2, 0x03,
	0x09, 0x30, 0xda, 0x9f, 0xf1, 0x06, 0xe2, 0x53, 0x70, 0xc0, 0xce, 0x59, 0x44, 0xd7, 0xa3, 0xdb,
	0x12, 0x60, 0x74, 0x30, 0xc3, 0x46, 0xe2, 0x02, 0x0c, 0x23, 0x55, 0xb5, 0xa3, 0x83, 0x89, 0xd0,
	0xe8, 0x50, 0xfa, 0x68, 0x72, 0xe3, 0xac, 0x48, 0xb6, 0x84, 0x28, 0x39, 0xa9, 0xaa, 0xf6, 0xb4,
	0xe1, 0x58, 0xeb, 0x19, 0xaa, 0x48, 0x7c, 0x1a, 0x6e, 0x73, 0xcd, 0x50, 0xb2, 0xeb, 0xd1, 0x21,
	0x0a, 0xcb, 0x80, 0x3b, 0x9c, 0x5a, 0x8f, 0xa9, 0x30, 0x52, 0x5d, 0x2b, 0x0e, 0xc3, 0xd0, 0xab,
	0x78, 0x9d, 0x41, 0xea, 0x5e, 0x8a, 0xa7, 0x61, 0x7f, 0x09, 0xe9, 0x45, 0x4c, 0xc1, 0x1c, 0x4a,
	0x27, 0xfd, 0x2c, 0x99, 0x54, 0x55, 0x0b, 0xab, 0x34, 0xcb, 0x98, 0x19, 0x19, 0x4f, 0x78, 0x5c,
	0x38, 0x0c, 0xa4, 0x4b, 0x70, 0x17, 0x6f, 0xea, 0x22, 0x75, 0xb5, 0xbd, 0x3d, 0xdd, 0x05, 0x23,
	0x1e, 0x32, 0x8a, 0x96, 0x67, 0xfb, 0x3a, 0xe8, 0xdd, 0x98, 0xc9, 0x4b, 0xbf, 0x12, 0xe0, 0x53,
	0x8d, 0x28, 0xd8, 0x26, 0x31, 0x6c, 0xec, 0xe2, 0x8b, 0xe9, 0x9d, 0x28, 0x48, 0x84, 0x5c, 0xaf,
	0xbd, 0x91, 0xb8, 0x1b, 0x42, 0x87, 0x38, 0x48, 0x57, 0x56, 0x35, 0xc7, 0xa6, 0x0a, 0xc3, 0x99,
	0x08, 0xbd, 0xf3, 0x75, 0xcd, 0xb1, 0xc5, 0xf3, 0x0c, 0xfe, 0x10, 0x85, 0xff, 0x58, 0x10, 0xf8,
	0xbd, 0x07, 0x37, 0xe1, 0xcf, 0x39, 0x10, 0xe6, 0x1d, 0x88, 0x5d, 0xf5, 0xdf, 0x83, 0xa3, 0xfc,
	0x1e, 0xec, 0x6d, 0x30, 0x47, 0x27, 0x6a, 0x72, 0x8e, 0xa8, 0x75, 0xe8, 0x9f, 0x46, 0x0e, 0xaa,
	0x87, 0xfe, 0xdf, 0x02, 0x4c, 0xf0, 0x76, 0x36, 0x6f, 0xd5, 0x16, 0x49, 0xaa, 0xcb, 0x0c, 0xf9,
	0x7e, 0x8a, 0xfc, 0x99, 0xf6, 0x91, 0x6f, 0xf6, 0xa8, 0x71, 0x0f, 0x1e, 0x5d, 0xa8, 0xff, 0x1f,
	0xc0, 0x67, 0x7c, 0xac, 0x63, 0xb1, 0xc9, 0xc7, 0x20, 0x68, 0x8c, 0xc1, 0x65, 0x86, 0x84, 0x40,
	0x91, 0x38, 0xdb, 0x21, 0x12, 0xad, 0xc3, 0xf1, 0x73, 0x8f, 0xb8, 0x4f, 0x42, 0x70, 0xe7, 0x62,
	0xb5, 0x84, 0x5d, 0xb4, 0xb1, 0x35, 0x47, 0xd4, 0x2f, 0x10, 0x7f, 0x2f, 0x72, 0xfc, 0x3d, 0xe1,
	0xbb, 0x79, 0x1b, 0xc1, 0xd4, 0x3e, 0x87, 0x5f, 0xf7, 0xdf, 0xcd, 0x4b, 0xfc, 0x6e, 0x4e, 0xf9,
	0x59, 0xd3, 0xe2, 0xdc, 0xb1, 0x49, 0xb0, 0x7f, 0x0b, 0xee, 0x69, 0x76, 0xa1, 0x67, 0xdc, 0xfe,
	0x81, 0x00, 0x63, 0xad, 0x10, 0x62, 0x39, 0x24, 0xc2, 0xb0, 0x4e, 0xd4, 0x0a, 0xbb, 0xd3, 0xeb,
	0xcd, 0xb8, 0x7d, 0x89, 0xe3, 0xf6, 0x93, 0x41, 0xb7, 0x66, 0x2b, 0xf2, 0xfb, 0xdb, 0x21, 0xf8,
	0x5c, 0xb3, 0xad, 0x5b, 0x96, 0xe3, 0xaf, 0x72, 0x1c, 0x3f, 0x1b, 0x6c, 0x07, 0xda, 0xe0, 0xf9,
	0xc7, 0x9a, 0x0e, 0x6f, 0x09, 0x70, 0xef, 0x26, 0x56, 0xb7, 0xc7, 0xff, 0x0a, 0xc7, 0xff, 0xdf,
	0xe8, 0x02, 0xa5, 0xc7, 0x54, 0x03, 0xca, 0x6e, 0xea, 0x72, 0x95, 0xe9, 0x14, 0x29, 0x1a, 0x4e,
	0x7b, 0xb1, 0xf8, 0x32, 0xdc, 0xae, 0xa3, 0x2c, 0xd6, 0x95, 0x15, 0x4d, 0x77, 0xb0, 0xc5, 0x50,
	0x38, 0xee, 0x87, 0x02, 0x7b, 0xc5, 0xaa, 0x56, 0xc3, 0x73, 0x74, 0x3c, 0xe7, 0x6a, 0x39, 0x43,
	0x95, 0x64, 0x86, 0xf4, 0xda, 0x40, 0xcc, 0xc0, 0x41, 0xd5, 0x22, 0x45, 0xd3, 0xa5, 0x53, 0x97,
	0x0b, 0x76, 0xa4, 0x0f, 0x75, 0xa8, 0x3d, 0xb3, 0x8d, 0x2a, 0x9a, 0x6a, 0xcc, 0x95, 0x70, 0xbb,
	0xb9, 0xd2, 0xbf, 0x71, 0xae, 0xc4, 0x61, 0xd8, 0x76, 0xb0, 0x49, 0xab, 0x4e, 0x6d, 0xc9, 0xaf,
	0xc3, 0x20, 0x43, 0xef, 0x4b, 0xef, 0x82, 0xc6, 0x63, 0x35, 0x03, 0x99, 0x05, 0xd9, 0x39, 0x18,
	0xce, 0x23, 0x07, 0x51, 0x82, 0x1c, 0x4a, 0x1f, 0x09, 0xe2, 0x61, 0x9d, 0x3a, 0xb7, 0x0a, 0xba,
	0x6a, 0xaa, 0xe6, 0x08, 0x9c, 0x39, 0x0f, 0x85, 0x8a, 0x39, 0xe5, 0x10, 0x8c, 0x56, 0xe4, 0x67,
	0x2a, 0x2f, 0xc9, 0x5f, 0x9c, 0xb2, 0x9f, 0x61, 0x39, 0x1b, 0xa1, 0x68, 0x9f, 0x68, 0xe7, 0xcc,
	0xd6, 0x88, 0x92, 0x5f, 0xd5, 0x87, 0x5c, 0xd5, 0xbf, 0xe6, 0x9f, 0xbf, 0xf3, 0x7c, 0xfe, 0x1e,
	0xf6, 0x33, 0xa6, 0xda, 0xcf, 0xf0, 0x27, 0xb7, 0xd9, 0xf0, 0xe0, 0xe0, 0x70, 0x44, 0x5a, 0x86,
	0xf1, 0x26, 0xeb, 0x7b, 0x56, 0xf0, 0x7f, 0x27, 0xc0, 0x9d, 0x2d, 0xb0, 0x61, 0xe1, 0x3c, 0x02,
	0x23, 0x55, 0x5b, 0x59, 0xd1, 0xaf, 0xdd, 0xd8, 0xac, 0xf2, 0x2f, 0x72, 0x95, 0x7f, 0x22, 0xe0,
	0xee, 0x6c, 0xc5, 0xc2, 0xff, 0x3f, 0x01, 0x3e, 0xdb, 0x64, 0xea, 0x96, 0xad, 0xfb, 0x57, 0xb8,
	0xba, 0x3f, 0x13, 0x08, 0xff, 0x36, 0xca, 0xfe, 0xa3, 0xcf, 0x07, 0xe9, 0x4d, 0x01, 0x3e, 0xe7,
	0x6f, 0x6a, 0x7b, 0xb5, 0xfe, 0x2a, 0x57, 0xeb, 0x67, 0x3b, 0x47, 0xe6, 0x31, 0x95, 0xfa, 0x0f,
	0x01, 0xdc, 0xbe, 0x88, 0x91, 0x95, 0x5b, 0x65, 0xc5, 0xf5, 0x38, 0xec, 0xa7, 0xb5, 0x96, 0x3e,
	0x65, 0x47, 0xfa, 0x2b, 0xfe, 0x1e, 0xb9, 0x82, 0x5e, 0x25, 0xf5, 0xa4, 0xc4, 0x09, 0x28, 0x10,
	0xaf, 0xc8, 0xec, 0x48, 0xa7, 0xda, 0x94, 0x5d, 0x30, 0xb1, 0x85, 0x1c, 0x62, 0x65, 0x04, 0x62,
	0x8a, 0x89, 0x8a, 0x47, 0x6e, 0xae, 0x57, 0xc2, 0xf1, 0xa7, 0x40, 0x18, 0xee, 0x67, 0x66, 0x4b,
	0xbf, 0x00, 0xee, 0xe9, 0x84, 0x4a, 0x13, 0x94, 0x9f, 0x42, 0x3a, 0x32, 0x72, 0xd8, 0x6a, 0xb3,
	0x56, 0x7d, 0xb3, 0xe5, 0xe9, 0x64, 0x74, 0x73, 0x4b, 0x3d, 0x78, 0x38, 0x7b, 0xea, 0x0f, 0x25,
	0xe3, 0x03, 0x7f, 0xbe, 0x09, 0x84, 0x61, 0x20, 0x5d, 0x73, 0xab, 0x7a, 0x0b, 0xe3, 0x58, 0x38,
	0x65, 0xe0, 0x13, 0x3a, 0x41, 0xf9, 0x6c, 0x65, 0x82, 0x95, 0xf7, 0x03, 0x7e, 0x06, 0xcc, 0xd5,
	0x09, 0xd0, 0xfd, 0xe3, 0x55, 0x48, 0x9f, 0x02, 0x38, 0xdc, 0xb8, 0xc6, 0x7d, 0xbf, 0x72, 0xbd,
	0x66, 0x08, 0xd0, 0x6b, 0x1e, 0x1a, 0xa1, 0xf9, 0xe0, 0xf6, 0x64, 0xe5, 0x91, 0x8a, 0xd7, 0x6c,
	0x53, 0xe8, 0x01, 0x24, 0xb4, 0x79, 0x53, 0x85, 0x3f, 0x78, 0x50, 0x1b, 0x45, 0xbb, 0xe9, 0x9e,
	0x38, 0x0b, 0xb7, 0x5b, 0xde, 0x2e, 0x79, 0x9a, 0xc3, 0x54, 0xb3, 0x6f, 0x88, 0xb1, 0x5d, 0xa5,
	0x2a, 0x87, 0xac, 0xda, 0x40, 0xba, 0x01, 0xa0, 0xd8, 0xfc, 0x58, 0x97, 0x11, 0x73, 0xee, 0xb9,
	0x87, 0x65, 0xaa, 0x37, 0x10, 0xc7, 0xe0, 0x60, 0x41, 0x33, 0x3c, 0x9a, 0xf3, 0x32, 0x25, 0x96,
	0xf4, 0xbe, 0x22, 0x24, 0x2b, 0x5f, 0x11, 0x92, 0x4b, 0x95, 0xaf, 0x08, 0x99, 0x6d, 0x05, 0xcd,
	0xa0, 0xb4, 0xe7, 0x8a, 0xa1, 0xb5, 0x1a, 0x8d, 0x6e, 0x26, 0x86, 0xd6, 0xdc, 0x91, 0xf4, 0x13,
	0x00, 0x87, 0xea, 0xec, 0xde, 0x0a, 0x36, 0xed, 0x3f, 0x00, 0x87, 0xea, 0x32, 0x4e, 0xdc, 0x01,
	0x61, 0x66, 0xfa, 0xc2, 0xc5, 0xe9, 0xc5, 0x25, 0x65, 0xe6, 0xf4, 0x70, 0x9f, 0xf8, 0x04, 0x8c,
	0x2c, 0x2e, 0x5c, 0xcc, 0x9c, 0x9a, 0x56, 0x66, 0xce, 0x0f, 0x83, 0xfd, 0xfb, 0xe0, 0x97, 0x5a,
	0xe4, 0xa7, 0x38, 0x00, 0x85, 0x99, 0xf9, 0xe1, 0x3e, 0x11, 0xc2, 0x81, 0xf9, 0x85, 0x25, 0x65,
	0x66, 0x7e, 0x18, 0xa4, 0xdf, 0x7b, 0x1e, 0x46, 0x27, 0x4d, 0xb3, 0x7a, 0xb8, 0xae, 0x7e, 0x1a,
	0x9a, 0x3c, 0x3f, 0x23, 0xfe, 0x17, 0xb8, 0x8a, 0xea, 0x37, 0xe9, 0x02, 0xad, 0x50, 0x5f, 0x0b,
	0xdc, 0x16, 0x8f, 0xa5, 0x83, 0xb7, 0x72, 0xa5, 0xeb, 0x77, 0xfe, 0x20, 0x80, 0xf2, 0xed, 0xe8,
	0xc1, 0x95, 0xb1, 0xb5, 0x9c, 0xfc, 0x1a, 0x42, 0xa6, 0x6c, 0x3b, 0xc8, 0xc8, 0x23, 0x2b, 0x2f,
	0xb3, 0x6f, 0x58, 0x07, 0x12, 0x25, 0x6c, 0xcb, 0x1a, 0x91, 0x35, 0x63, 0xc5, 0x42, 0xb6, 0x63,
	0x15, 0x73, 0x4e, 0xd1, 0xc2, 0xb2, 0x85, 0x51, 0xfe, 0x8d, 0x8f, 0xfe, 0xf9, 0x33, 0xe1, 0x90,
	0x94, 0x66, 0x9f, 0xbd, 0x52, 0xd5, 0x54, 0xb1, 0x53, 0xd7, 0xab, 0xd7, 0xdf, 0xe1, 0xbf, 0xe0,
	0x78, 0x89, 0x33, 0x0e, 0xf6, 0x8b, 0xff, 0x01, 0x8d, 0xad, 0x5b, 0xea, 0xfb, 0xa4, 0xae, 0xcf,
	0x57, 0xf5, 0x3c, 0x2a, 0x20, 0x5e, 0x61, 0x40, 0x3c, 0xdb, 0x02, 0x08, 0xa4, 0xeb, 0xb2, 0x61,
	0xcb, 0x79, 0x64, 0xaf, 0x66, 0x09, 0xb2, 0x3c, 0xaf, 0x8f, 0x48, 0x2f, 0xb5, 0xf0, 0xda, 0x5e,
	0xb7, 0x1d, 0x5c, 0xe0, 0x1d, 0x46, 0xba, 0xae, 0x18, 0xb6, 0x52, 0xf3, 0xfb, 0xfd, 0x70, 0xed,
	0x18, 0x58, 0xff, 0xb9, 0xc0, 0xdb, 0xf9, 0x43, 0xed, 0x5b, 0xcf, 0x1d, 0x4c, 0x3b, 0x72, 0xfb,
	0xdd, 0x50, 0x77, 0x01, 0xf0, 0xe0, 0x76, 0xf4, 0x0e, 0x80, 0x7b, 0xa8, 0x30, 0x32, 0x4d, 0xb9,
	0xf2, 0x3c, 0xd9, 0xf3, 0x56, 0x66, 0xef, 0x0e, 0x17, 0x60, 0x48, 0xc5, 0x8e, 0x38, 0xdb, 0x02,
	0xb1, 0xd1, 0x65, 0x24, 0xbf, 0x7e, 0x65, 0x74, 0x59, 0x46, 0xf2, 0xeb, 0x2f, 0xc8, 0x47, 0xae,
	0xec, 0x5f, 0x66, 0x17, 0xfb, 0x26, 0xf6, 0xb5, 0x0a, 0x9c, 0x54, 0xed, 0x75, 0xc4, 0x24, 0x76,
	0x4f, 0x75, 0xd2, 0x7d, 0xbd, 0x2e, 0x1e, 0x09, 0x1e, 0xcd, 0x4c, 0xc1, 0xe5, 0x13, 0x52, 0xe7,
	0xc2, 0x6e, 0x64, 0xfc, 0x46, 0xa8, 0xbd, 0x7e, 0x34, 0x35, 0xbc, 0xbd, 0xf0, 0x38, 0xd6, 0xcd,
	0x67, 0x83, 0xd8, 0xf1, 0xae, 0x5a, 0xed, 0xd2, 0x5b, 0xa0, 0x07, 0x7c, 0x71, 0x4a, 0x3a, 0xd1,
	0x01, 0x48, 0xa8, 0x66, 0x8e, 0x8b, 0xd4, 0x07, 0x02, 0xfc, 0xaa, 0x3f, 0x52, 0x3c, 0x8d, 0x3c,
	0x56, 0xd8, 0x4a, 0x41, 0xc9, 0x65, 0x5a, 0x3a, 0xd9, 0x09, 0xb9, 0x34, 0x82, 0xf4, 0x73, 0x01,
	0x3e, 0xdd, 0xdc, 0x3f, 0xf3, 0xe2, 0x68, 0xac, 0xa3, 0xbe, 0x7d, 0xec, 0x60, 0x67, 0x3d, 0x65,
	0xe9, 0xed, 0x16, 0x91, 0x83, 0xf2, 0x25, 0xf7, 0x34, 0xd6, 0x7e, 0xe4, 0xb4, 0x86, 0x65, 0xc3,
	0xc8, 0x69, 0xd1, 0xe0, 0xa4, 0xfc, 0xfb, 0x20, 0x0c, 0x77, 0x6f, 0xd4, 0xd6, 0xf7, 0xc0, 0x39,
	0x1a, 0xcc, 0x4b, 0x9e, 0x87, 0x3b, 0x85, 0xe8, 0xa3, 0x50, 0x77, 0x10, 0x3d, 0xb8, 0x1d, 0xfd,
	0x14, 0x40, 0xb9, 0x99, 0x8b, 0x6b, 0x38, 0xc8, 0x2e, 0x0e, 0xb2, 0x8b, 0x43, 0x85, 0x99, 0x15,
	0x8f, 0x99, 0x2f, 0x75, 0xc5, 0xa2, 0xad, 0x80, 0xae, 0xf0, 0xf4, 0xcb, 0x8c, 0xa7, 0x3f, 0xb7,
	0x27, 0xd0, 0xc8, 0x78, 0x1f, 0x88, 0x67, 0xbb, 0x0d, 0x8d, 0x0a, 0x89, 0xcf, 0x49, 0xbd, 0x52,
	0xe5, 0x06, 0xdb, 0x9f, 0x04, 0x28, 0xf9, 0xf6, 0xb0, 0xbd, 0x88, 0x3b, 0xd9, 0xed, 0x97, 0x82,
	0xd8, 0x64, 0xd7, 0x5d, 0x74, 0xe9, 0xbd, 0x5e, 0x24, 0xe9, 0x05, 0x69, 0xae, 0x6b, 0xf8, 0x1a,
	0x78, 0xec, 0x07, 0x42, 0xe3, 0xdf, 0x32, 0x5e, 0x87, 0xda, 0x16, 0x0f, 0xb6, 0x4f, 0xcc, 0xf5,
	0x0d, 0xfa, 0xd8, 0xa1, 0xc0, 0x72, 0x0c, 0xa2, 0x6f, 0xf7, 0xa0, 0x00, 0x1e, 0x96, 0x5e, 0x0c,
	0x82, 0x10, 0xeb, 0x5d, 0xbb, 0x40, 0xbc, 0x59, 0xf7, 0x37, 0x48, 0xb5, 0x49, 0xe2, 0x05, 0xd0,
	0x4b, 0x9d, 0x34, 0x64, 0x63, 0x63, 0x1d, 0x35, 0x0a, 0xa5, 0xef, 0xf6, 0x00, 0x85, 0x71, 0x69,
	0x2c, 0x08, 0x0a, 0xd5, 0xb6, 0x95, 0x8b, 0xc3, 0x87, 0x61, 0x38, 0xb2, 0x41, 0x9b, 0xd6, 0x43,
	0x63, 0x3c, 0x90, 0x5f, 0x3c, 0x7f, 0x77, 0x88, 0xc9, 0x2f, 0xbb, 0x3f, 0x4a, 0xff, 0x0d, 0x40,
	0xa9, 0x99, 0xbe, 0xab, 0x9e, 0x57, 0x38, 0x7b, 0xc9, 0xe3, 0xec, 0x73, 0x5d, 0x31, 0x6a, 0xed,
	0x37, 0x3f, 0xa6, 0xf5, 0x22, 0x23, 0xea, 0xde, 0xaa, 0xa5, 0x5b, 0xfd, 0x7d, 0x20, 0x1e, 0xeb,
	0x68, 0xaf, 0x2b, 0x94, 0x3c, 0x29, 0x75, 0x25, 0xef, 0x86, 0xcc, 0xef, 0x85, 0xda, 0x7f, 0x2b,
	0xad, 0xfa, 0x8b, 0x5e, 0xdc, 0x4c, 0x74, 0xd9, 0xb8, 0x8d, 0x9d, 0xec, 0xb6, 0xbf, 0x29, 0xbd,
	0xd3, 0x8b, 0x33, 0xf6, 0x19, 0x69, 0xb2, 0x33, 0xc0, 0x1a, 0x98, 0xf7, 0x86, 0x50, 0xed, 0x73,
	0xd4, 0x37, 0xeb, 0x36, 0xe3, 0xdd, 0x8d, 0x5a, 0x8f, 0x9b, 0xf1, 0xee, 0x86, 0x5d, 0x41, 0xe9,
	0x47, 0x15, 0x54, 0x8e, 0x51, 0x54, 0xa8, 0x0c, 0x2e, 0x60, 0x7b, 0x35, 0x38, 0x36, 0x41, 0x4f,
	0x91, 0xd4, 0xaa, 0x14, 0xd7, 0x50, 0x74, 0xa1, 0xf9, 0x21, 0xfd, 0xf1, 0xac, 0xc9, 0x62, 0xfe,
	0xb5, 0xe3, 0x91, 0xe3, 0xb4, 0x16, 0xf4, 0x55, 0xe3, 0xac, 0x34, 0x15, 0xec, 0x55, 0x63, 0x03,
	0x3c, 0x62, 0xa9, 0x5b, 0x37, 0x41, 0xe8, 0xef, 0x37, 0xc1, 0x33, 0x3e, 0x96, 0x2f, 0x64, 0x5f,
	0xc1, 0x39, 0xe7, 0x8d, 0xbf, 0x46, 0x85, 0x28, 0x98, 0x7a, 0x07, 0xdc, 0xbd, 0x17, 0xef, 0xfb,
	0xf8, 0x5e, 0xbc, 0xef, 0xe1, 0xbd, 0x38, 0xf8, 0x5e, 0x39, 0x0e, 0x7e, 0x5b, 0x8e, 0x83, 0x3b,
	0xe5, 0x38, 0xb8, 0x5b, 0x8e, 0x83, 0x7f, 0x94, 0xe3, 0xe0, 0x93, 0x72, 0xbc, 0xef, 0x61, 0x39,
	0x0e, 0x7e, 0x7c, 0x3f, 0xde, 0x77, 0xeb, 0x7e, 0x1c, 0xdc, 0xbd, 0x1f, 0xef, 0xfb, 0xf8, 0x7e,
	0xbc, 0xef, 0xf2, 0x79, 0x95, 0x98, 0xaf, 0xaa, 0xc9, 0x12, 0xd1, 0x1d, 0x6c, 0x59, 0x28, 0x59,
	0xb4, 0x53, 0xf4, 0x62, 0x85, 0x58, 0x05, 0xd9, 0xb4, 0x48, 0x49, 0xcb, 0x63, 0x4b, 0xae, 0x4c,
	0xa7, 0xcc, 0xac, 0x4a, 0x52, 0x78, 0xcd, 0x61, 0xff, 0xe3, 0xb6, 0xf8, 0xaf, 0x38, 0x3b, 0x40,
	0x5b, 0x83, 0x2f, 0x7e, 0x16, 0x00, 0x00, 0xff, 0xff, 0xdd, 0x63, 0x16, 0xf8, 0xdc, 0x2d, 0x00,
	0x00,
}

func (x SearchLabel) String() string {
	s, ok := SearchLabel_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SearchLabelOperator) String() string {
	s, ok := SearchLabelOperator_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *SecurityEventsRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityEventsRequest)
	if !ok {
		that2, ok := that.(SecurityEventsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Query != that1.Query {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if this.Sort != that1.Sort {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if this.Scroll != that1.Scroll {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	if this.SortBy != that1.SortBy {
		return false
	}
	return true
}
func (this *SecurityEventsScrollRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityEventsScrollRequest)
	if !ok {
		that2, ok := that.(SecurityEventsScrollRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.ScrollId != that1.ScrollId {
		return false
	}
	return true
}
func (this *SecurityEventsResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityEventsResponse)
	if !ok {
		that2, ok := that.(SecurityEventsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Events) != len(that1.Events) {
		return false
	}
	for i := range this.Events {
		if this.Events[i] != that1.Events[i] {
			return false
		}
	}
	if this.TotalHits != that1.TotalHits {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	if this.ScrollId != that1.ScrollId {
		return false
	}
	return true
}
func (this *SecurityEventsAggregationRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityEventsAggregationRequest)
	if !ok {
		that2, ok := that.(SecurityEventsAggregationRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Query != that1.Query {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *SecurityEventsAggregationResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityEventsAggregationResponse)
	if !ok {
		that2, ok := that.(SecurityEventsAggregationResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TotalHits != that1.TotalHits {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *SuspiciousUserLogsRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SuspiciousUserLogsRequest)
	if !ok {
		that2, ok := that.(SuspiciousUserLogsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Query != that1.Query {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if this.Sort != that1.Sort {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if this.Scroll != that1.Scroll {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	if this.SortBy != that1.SortBy {
		return false
	}
	return true
}
func (this *SuspiciousUserLogsScrollRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SuspiciousUserLogsScrollRequest)
	if !ok {
		that2, ok := that.(SuspiciousUserLogsScrollRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.ScrollId != that1.ScrollId {
		return false
	}
	return true
}
func (this *SuspiciousUserLogsResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SuspiciousUserLogsResponse)
	if !ok {
		that2, ok := that.(SuspiciousUserLogsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Logs) != len(that1.Logs) {
		return false
	}
	for i := range this.Logs {
		if this.Logs[i] != that1.Logs[i] {
			return false
		}
	}
	if this.TotalHits != that1.TotalHits {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	if this.ScrollId != that1.ScrollId {
		return false
	}
	return true
}
func (this *SuspiciousUserLogsAggregationRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SuspiciousUserLogsAggregationRequest)
	if !ok {
		that2, ok := that.(SuspiciousUserLogsAggregationRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Query != that1.Query {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *SuspiciousUserLogsAggregationResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SuspiciousUserLogsAggregationResponse)
	if !ok {
		that2, ok := that.(SuspiciousUserLogsAggregationResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TotalHits != that1.TotalHits {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *SecurityEventsCountRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityEventsCountRequest)
	if !ok {
		that2, ok := that.(SecurityEventsCountRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if len(this.LabelFilter) != len(that1.LabelFilter) {
		return false
	}
	for i := range this.LabelFilter {
		if !this.LabelFilter[i].Equal(that1.LabelFilter[i]) {
			return false
		}
	}
	if len(this.GroupBy) != len(that1.GroupBy) {
		return false
	}
	for i := range this.GroupBy {
		if this.GroupBy[i] != that1.GroupBy[i] {
			return false
		}
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if this.Step != that1.Step {
		return false
	}
	return true
}
func (this *SecurityEventsCountResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityEventsCountResponse)
	if !ok {
		that2, ok := that.(SecurityEventsCountResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Data) != len(that1.Data) {
		return false
	}
	for i := range this.Data {
		if !this.Data[i].Equal(that1.Data[i]) {
			return false
		}
	}
	if this.Step != that1.Step {
		return false
	}
	return true
}
func (this *SecurityIncidentsRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityIncidentsRequest)
	if !ok {
		that2, ok := that.(SecurityIncidentsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Query != that1.Query {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if this.Sort != that1.Sort {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if this.Scroll != that1.Scroll {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	if this.SortBy != that1.SortBy {
		return false
	}
	return true
}
func (this *SecurityIncidentsScrollRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityIncidentsScrollRequest)
	if !ok {
		that2, ok := that.(SecurityIncidentsScrollRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.ScrollId != that1.ScrollId {
		return false
	}
	return true
}
func (this *SecurityIncidentsResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityIncidentsResponse)
	if !ok {
		that2, ok := that.(SecurityIncidentsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Incidents) != len(that1.Incidents) {
		return false
	}
	for i := range this.Incidents {
		if this.Incidents[i] != that1.Incidents[i] {
			return false
		}
	}
	if this.TotalHits != that1.TotalHits {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	if this.ScrollId != that1.ScrollId {
		return false
	}
	return true
}
func (this *SecurityIncidentsAggregationRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityIncidentsAggregationRequest)
	if !ok {
		that2, ok := that.(SecurityIncidentsAggregationRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Query != that1.Query {
		return false
	}
	if this.StartTime != that1.StartTime {
		return false
	}
	if this.EndTime != that1.EndTime {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *SecurityIncidentsAggregationResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityIncidentsAggregationResponse)
	if !ok {
		that2, ok := that.(SecurityIncidentsAggregationResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TotalHits != that1.TotalHits {
		return false
	}
	if len(this.Aggs) != len(that1.Aggs) {
		return false
	}
	for i := range this.Aggs {
		if !this.Aggs[i].Equal(that1.Aggs[i]) {
			return false
		}
	}
	return true
}
func (this *SearchFilter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SearchFilter)
	if !ok {
		that2, ok := that.(SearchFilter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Label != that1.Label {
		return false
	}
	if this.Op != that1.Op {
		return false
	}
	if len(this.Value) != len(that1.Value) {
		return false
	}
	for i := range this.Value {
		if this.Value[i] != that1.Value[i] {
			return false
		}
	}
	return true
}
func (this *SearchLoadBalancersRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SearchLoadBalancersRequest)
	if !ok {
		that2, ok := that.(SearchLoadBalancersRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if len(this.LabelFilter) != len(that1.LabelFilter) {
		return false
	}
	for i := range this.LabelFilter {
		if !this.LabelFilter[i].Equal(that1.LabelFilter[i]) {
			return false
		}
	}
	return true
}
func (this *SearchLoadBalancersResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SearchLoadBalancersResponse)
	if !ok {
		that2, ok := that.(SearchLoadBalancersResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Loadbalancers) != len(that1.Loadbalancers) {
		return false
	}
	for i := range this.Loadbalancers {
		if !this.Loadbalancers[i].Equal(that1.Loadbalancers[i]) {
			return false
		}
	}
	return true
}
func (this *LoadbalancerData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoadbalancerData)
	if !ok {
		that2, ok := that.(LoadbalancerData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if !this.SecurityEventsData.Equal(that1.SecurityEventsData) {
		return false
	}
	if !this.RequestData.Equal(that1.RequestData) {
		return false
	}
	return true
}
func (this *SecurityEventsData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityEventsData)
	if !ok {
		that2, ok := that.(SecurityEventsData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	if !this.MinTime.Equal(that1.MinTime) {
		return false
	}
	if !this.MaxTime.Equal(that1.MaxTime) {
		return false
	}
	return true
}
func (this *RequestData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestData)
	if !ok {
		that2, ok := that.(RequestData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Count != that1.Count {
		return false
	}
	if !this.MinTime.Equal(that1.MinTime) {
		return false
	}
	if !this.MaxTime.Equal(that1.MaxTime) {
		return false
	}
	return true
}
func (this *SecurityEventsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&app_security.SecurityEventsRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	s = append(s, "Sort: "+fmt.Sprintf("%#v", this.Sort)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	s = append(s, "Scroll: "+fmt.Sprintf("%#v", this.Scroll)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "SortBy: "+fmt.Sprintf("%#v", this.SortBy)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SecurityEventsScrollRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&app_security.SecurityEventsScrollRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "ScrollId: "+fmt.Sprintf("%#v", this.ScrollId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SecurityEventsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&app_security.SecurityEventsResponse{")
	s = append(s, "Events: "+fmt.Sprintf("%#v", this.Events)+",\n")
	s = append(s, "TotalHits: "+fmt.Sprintf("%#v", this.TotalHits)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*log.LogAggregationData{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "ScrollId: "+fmt.Sprintf("%#v", this.ScrollId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SecurityEventsAggregationRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&app_security.SecurityEventsAggregationRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SecurityEventsAggregationResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&app_security.SecurityEventsAggregationResponse{")
	s = append(s, "TotalHits: "+fmt.Sprintf("%#v", this.TotalHits)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*log.LogAggregationData{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SuspiciousUserLogsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&app_security.SuspiciousUserLogsRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	s = append(s, "Sort: "+fmt.Sprintf("%#v", this.Sort)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	s = append(s, "Scroll: "+fmt.Sprintf("%#v", this.Scroll)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*suspicious_user_log.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "SortBy: "+fmt.Sprintf("%#v", this.SortBy)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SuspiciousUserLogsScrollRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&app_security.SuspiciousUserLogsScrollRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "ScrollId: "+fmt.Sprintf("%#v", this.ScrollId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SuspiciousUserLogsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&app_security.SuspiciousUserLogsResponse{")
	s = append(s, "Logs: "+fmt.Sprintf("%#v", this.Logs)+",\n")
	s = append(s, "TotalHits: "+fmt.Sprintf("%#v", this.TotalHits)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*log.LogAggregationData{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "ScrollId: "+fmt.Sprintf("%#v", this.ScrollId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SuspiciousUserLogsAggregationRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&app_security.SuspiciousUserLogsAggregationRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*suspicious_user_log.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SuspiciousUserLogsAggregationResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&app_security.SuspiciousUserLogsAggregationResponse{")
	s = append(s, "TotalHits: "+fmt.Sprintf("%#v", this.TotalHits)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*log.LogAggregationData{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SecurityEventsCountRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&app_security.SecurityEventsCountRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	if this.LabelFilter != nil {
		s = append(s, "LabelFilter: "+fmt.Sprintf("%#v", this.LabelFilter)+",\n")
	}
	s = append(s, "GroupBy: "+fmt.Sprintf("%#v", this.GroupBy)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	s = append(s, "Step: "+fmt.Sprintf("%#v", this.Step)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SecurityEventsCountResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&app_security.SecurityEventsCountResponse{")
	if this.Data != nil {
		s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	}
	s = append(s, "Step: "+fmt.Sprintf("%#v", this.Step)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SecurityIncidentsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&app_security.SecurityIncidentsRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	s = append(s, "Sort: "+fmt.Sprintf("%#v", this.Sort)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	s = append(s, "Scroll: "+fmt.Sprintf("%#v", this.Scroll)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*incidents.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "SortBy: "+fmt.Sprintf("%#v", this.SortBy)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SecurityIncidentsScrollRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&app_security.SecurityIncidentsScrollRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "ScrollId: "+fmt.Sprintf("%#v", this.ScrollId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SecurityIncidentsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&app_security.SecurityIncidentsResponse{")
	s = append(s, "Incidents: "+fmt.Sprintf("%#v", this.Incidents)+",\n")
	s = append(s, "TotalHits: "+fmt.Sprintf("%#v", this.TotalHits)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*log.LogAggregationData{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "ScrollId: "+fmt.Sprintf("%#v", this.ScrollId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SecurityIncidentsAggregationRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&app_security.SecurityIncidentsAggregationRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	s = append(s, "StartTime: "+fmt.Sprintf("%#v", this.StartTime)+",\n")
	s = append(s, "EndTime: "+fmt.Sprintf("%#v", this.EndTime)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*incidents.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SecurityIncidentsAggregationResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&app_security.SecurityIncidentsAggregationResponse{")
	s = append(s, "TotalHits: "+fmt.Sprintf("%#v", this.TotalHits)+",\n")
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*log.LogAggregationData{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%#v: %#v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	if this.Aggs != nil {
		s = append(s, "Aggs: "+mapStringForAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SearchFilter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&app_security.SearchFilter{")
	s = append(s, "Label: "+fmt.Sprintf("%#v", this.Label)+",\n")
	s = append(s, "Op: "+fmt.Sprintf("%#v", this.Op)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SearchLoadBalancersRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&app_security.SearchLoadBalancersRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	if this.LabelFilter != nil {
		s = append(s, "LabelFilter: "+fmt.Sprintf("%#v", this.LabelFilter)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SearchLoadBalancersResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&app_security.SearchLoadBalancersResponse{")
	if this.Loadbalancers != nil {
		s = append(s, "Loadbalancers: "+fmt.Sprintf("%#v", this.Loadbalancers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LoadbalancerData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&app_security.LoadbalancerData{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	if this.SecurityEventsData != nil {
		s = append(s, "SecurityEventsData: "+fmt.Sprintf("%#v", this.SecurityEventsData)+",\n")
	}
	if this.RequestData != nil {
		s = append(s, "RequestData: "+fmt.Sprintf("%#v", this.RequestData)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SecurityEventsData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&app_security.SecurityEventsData{")
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	if this.MinTime != nil {
		s = append(s, "MinTime: "+fmt.Sprintf("%#v", this.MinTime)+",\n")
	}
	if this.MaxTime != nil {
		s = append(s, "MaxTime: "+fmt.Sprintf("%#v", this.MaxTime)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&app_security.RequestData{")
	s = append(s, "Count: "+fmt.Sprintf("%#v", this.Count)+",\n")
	if this.MinTime != nil {
		s = append(s, "MinTime: "+fmt.Sprintf("%#v", this.MinTime)+",\n")
	}
	if this.MaxTime != nil {
		s = append(s, "MaxTime: "+fmt.Sprintf("%#v", this.MaxTime)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringPublicMonitoringApi(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AppSecurityMonitoringAPIClient is the client API for AppSecurityMonitoringAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AppSecurityMonitoringAPIClient interface {
	// Security Events Query
	//
	// x-displayName: "Security Events Query"
	// Get security events for the given namespace.
	// For `system` namespace, all security events for the tenant matching the query specified
	// in the request will be returned in the response. User may query security events that matches various
	// fields such as `vh_name`, `sec_event_type`, `src_site`, `city`, `country`.
	SecurityEventsQuery(ctx context.Context, in *SecurityEventsRequest, opts ...grpc.CallOption) (*SecurityEventsResponse, error)
	// Security Events Query All Namespaces
	//
	// x-displayName: "Security Events Query All Namespaces"
	// Get security events for the given namespace.
	// For `system` namespace, all security events for the tenant matching the query specified
	// in the request will be returned in the response. User may query security events that matches various
	// fields such as `vh_name`, `sec_event_type`, `src_site`, `city`, `country`.
	// This API is specific to system namespace
	SecurityEventsQueryAllNamespaces(ctx context.Context, in *SecurityEventsRequest, opts ...grpc.CallOption) (*SecurityEventsResponse, error)
	// SecurityEventScrollQuery
	//
	// x-displayName: "Security Event Scroll Query"
	// Scroll request is used to fetch large number of security events in multiple batches with each SecurityEventResponse
	// containing no more than 500 messages. To scroll through more than 500 or all messages, one can use the
	// SecurityEventScrollRequest. Use the scroll_id returned in the SecurityEventResponse to fetch the next batch of security events
	// and one can continue this process till the scroll_id returned is "" which indicates no more events to scroll.
	SecurityEventsScrollQuery(ctx context.Context, in *SecurityEventsScrollRequest, opts ...grpc.CallOption) (*SecurityEventsResponse, error)
	// Security Events Aggregation Query
	//
	// x-displayName: "Security Events Aggregation Query"
	// Get summary/aggregation data for security events in the given namespace.
	// For `system` namespace, all security events for the tenant matching the query specified
	// in the request will be considered for aggregation. User may query security events that matches various
	// fields such as `vh_name`, `sec_event_type`, `src_site`, `city`, `country`.
	SecurityEventsAggregationQuery(ctx context.Context, in *SecurityEventsAggregationRequest, opts ...grpc.CallOption) (*SecurityEventsAggregationResponse, error)
	// Security Events Aggregation Query All Namespaces
	//
	// x-displayName: "Security Events Aggregation Query All Namespaces"
	// Get summary/aggregation data for security events in the given namespace.
	// For `system` namespace, all security events for the tenant matching the query specified
	// in the request will be considered for aggregation. User may query security events that matches various
	// fields such as `vh_name`, `sec_event_type`, `src_site`, `city`, `country`.
	SecurityEventsAggregationQueryAllNamespaces(ctx context.Context, in *SecurityEventsAggregationRequest, opts ...grpc.CallOption) (*SecurityEventsAggregationResponse, error)
	// Suspicious Users Logs Query
	//
	// x-displayName: "Suspicious User Logs Query"
	// Get suspicious user logs for the given namespace.
	// For `system` namespace, all suspicious users logs for the tenant matching the query specified
	// in the request will be returned in the response. User may query suspicious user logs that matches various
	// fields such as `vh_name`, `user`, `site`, `city`, `country`.
	SuspiciousUserLogsQuery(ctx context.Context, in *SuspiciousUserLogsRequest, opts ...grpc.CallOption) (*SuspiciousUserLogsResponse, error)
	// Suspicious User Logs Scroll Query
	//
	// x-displayName: "Suspicious User Logs Scroll Query"
	// Scroll request is used to fetch large number of suspicious user logs in multiple batches with each SuspiciousUserLogsResponse
	// containing no more than 500 messages. To scroll through more than 500 or all messages, one can use the
	// SuspiciousUserLogsScrollRequest. Use the scroll_id returned in the SuspiciousUserLogsResponse to fetch the next batch of logs
	// and one can continue this process till the scroll_id returned is "" which indicates no more logs to scroll.
	SuspiciousUserLogsScrollQuery(ctx context.Context, in *SuspiciousUserLogsScrollRequest, opts ...grpc.CallOption) (*SuspiciousUserLogsResponse, error)
	// Suspicious User Logs Aggregation Query
	//
	// x-displayName: "Suspicious User Logs Aggregation Query"
	// Get summary/aggregation data for suspicious user logs in the given namespace.
	// For `system` namespace, all suspicious user logs for the tenant matching the query specified
	// in the request will be considered for aggregation. User may query suspicious user logs that matches various
	// fields such as `vh_name`, `user`, `site`, `city`, `country`.
	SuspiciousUserLogsAggregationQuery(ctx context.Context, in *SuspiciousUserLogsAggregationRequest, opts ...grpc.CallOption) (*SuspiciousUserLogsAggregationResponse, error)
	// Security Events Metrics
	//
	// x-displayName: "Security Events Metrics"
	// Get the number of security events for a given namespace.
	// Security events can be aggregated across multiple dimensions like VIRTUAL_HOST, SITE, SEC_EVENT_TYPE, etc.,
	SecurityEventsMetrics(ctx context.Context, in *SecurityEventsCountRequest, opts ...grpc.CallOption) (*SecurityEventsCountResponse, error)
	// Security Incidents Query
	//
	// x-displayName: "Security Incidents Query"
	// Get security incidents for the given namespace.
	// For `system` namespace, all security incidents for the tenant matching the query specified
	// in the request will be returned in the response. User may query security incidents that matches various
	// fields such as `vh_name`, `intent`, `city`, `country`.
	SecurityIncidentsQuery(ctx context.Context, in *SecurityIncidentsRequest, opts ...grpc.CallOption) (*SecurityIncidentsResponse, error)
	// SecurityIncidentsScrollQuery
	//
	// x-displayName: "Security Incidents Scroll Query"
	// Scroll request is used to fetch large number of security incidents in multiple batches with each SecurityIncidentsResponse
	// containing no more than 500 messages. To scroll through more than 500 or all messages, one can use the
	// SecurityIncidentsScrollRequest. Use the scroll_id returned in the SecurityIncidentsResponse to fetch the next batch
	// of security incidents and one can continue this process till the scroll_id returned is "" which indicates no more
	// events to scroll.
	SecurityIncidentsScrollQuery(ctx context.Context, in *SecurityIncidentsScrollRequest, opts ...grpc.CallOption) (*SecurityIncidentsResponse, error)
	// Security Incidents Aggregation Query
	//
	// x-displayName: "Security Incidents Aggregation Query"
	// Get summary/aggregation data for security incidents in the given namespace.
	// For `system` namespace, all security incidents for the tenant matching the query specified in the request will be
	// considered for aggregation. User may query security events that matches various fields such as `vh_name`,
	// `intent`, `city`, `country`.
	SecurityIncidentsAggregationQuery(ctx context.Context, in *SecurityIncidentsAggregationRequest, opts ...grpc.CallOption) (*SecurityIncidentsAggregationResponse, error)
	// Search load balancers
	//
	// x-displayName: "Search load balancers"
	// Get list of virtual hosts matching label filter
	SearchLoadBalancers(ctx context.Context, in *SearchLoadBalancersRequest, opts ...grpc.CallOption) (*SearchLoadBalancersResponse, error)
	// Search load balancers All Namespaces
	//
	// x-displayName: "Search load balancers All Namespaces"
	// Get list of virtual hosts matching label filter
	SearchLoadBalancersAllNamespaces(ctx context.Context, in *SearchLoadBalancersRequest, opts ...grpc.CallOption) (*SearchLoadBalancersResponse, error)
}

type appSecurityMonitoringAPIClient struct {
	cc *grpc.ClientConn
}

func NewAppSecurityMonitoringAPIClient(cc *grpc.ClientConn) AppSecurityMonitoringAPIClient {
	return &appSecurityMonitoringAPIClient{cc}
}

func (c *appSecurityMonitoringAPIClient) SecurityEventsQuery(ctx context.Context, in *SecurityEventsRequest, opts ...grpc.CallOption) (*SecurityEventsResponse, error) {
	out := new(SecurityEventsResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SecurityEventsQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appSecurityMonitoringAPIClient) SecurityEventsQueryAllNamespaces(ctx context.Context, in *SecurityEventsRequest, opts ...grpc.CallOption) (*SecurityEventsResponse, error) {
	out := new(SecurityEventsResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SecurityEventsQueryAllNamespaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appSecurityMonitoringAPIClient) SecurityEventsScrollQuery(ctx context.Context, in *SecurityEventsScrollRequest, opts ...grpc.CallOption) (*SecurityEventsResponse, error) {
	out := new(SecurityEventsResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SecurityEventsScrollQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appSecurityMonitoringAPIClient) SecurityEventsAggregationQuery(ctx context.Context, in *SecurityEventsAggregationRequest, opts ...grpc.CallOption) (*SecurityEventsAggregationResponse, error) {
	out := new(SecurityEventsAggregationResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SecurityEventsAggregationQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appSecurityMonitoringAPIClient) SecurityEventsAggregationQueryAllNamespaces(ctx context.Context, in *SecurityEventsAggregationRequest, opts ...grpc.CallOption) (*SecurityEventsAggregationResponse, error) {
	out := new(SecurityEventsAggregationResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SecurityEventsAggregationQueryAllNamespaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appSecurityMonitoringAPIClient) SuspiciousUserLogsQuery(ctx context.Context, in *SuspiciousUserLogsRequest, opts ...grpc.CallOption) (*SuspiciousUserLogsResponse, error) {
	out := new(SuspiciousUserLogsResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SuspiciousUserLogsQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appSecurityMonitoringAPIClient) SuspiciousUserLogsScrollQuery(ctx context.Context, in *SuspiciousUserLogsScrollRequest, opts ...grpc.CallOption) (*SuspiciousUserLogsResponse, error) {
	out := new(SuspiciousUserLogsResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SuspiciousUserLogsScrollQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appSecurityMonitoringAPIClient) SuspiciousUserLogsAggregationQuery(ctx context.Context, in *SuspiciousUserLogsAggregationRequest, opts ...grpc.CallOption) (*SuspiciousUserLogsAggregationResponse, error) {
	out := new(SuspiciousUserLogsAggregationResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SuspiciousUserLogsAggregationQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appSecurityMonitoringAPIClient) SecurityEventsMetrics(ctx context.Context, in *SecurityEventsCountRequest, opts ...grpc.CallOption) (*SecurityEventsCountResponse, error) {
	out := new(SecurityEventsCountResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SecurityEventsMetrics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appSecurityMonitoringAPIClient) SecurityIncidentsQuery(ctx context.Context, in *SecurityIncidentsRequest, opts ...grpc.CallOption) (*SecurityIncidentsResponse, error) {
	out := new(SecurityIncidentsResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SecurityIncidentsQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appSecurityMonitoringAPIClient) SecurityIncidentsScrollQuery(ctx context.Context, in *SecurityIncidentsScrollRequest, opts ...grpc.CallOption) (*SecurityIncidentsResponse, error) {
	out := new(SecurityIncidentsResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SecurityIncidentsScrollQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appSecurityMonitoringAPIClient) SecurityIncidentsAggregationQuery(ctx context.Context, in *SecurityIncidentsAggregationRequest, opts ...grpc.CallOption) (*SecurityIncidentsAggregationResponse, error) {
	out := new(SecurityIncidentsAggregationResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SecurityIncidentsAggregationQuery", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appSecurityMonitoringAPIClient) SearchLoadBalancers(ctx context.Context, in *SearchLoadBalancersRequest, opts ...grpc.CallOption) (*SearchLoadBalancersResponse, error) {
	out := new(SearchLoadBalancersResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SearchLoadBalancers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appSecurityMonitoringAPIClient) SearchLoadBalancersAllNamespaces(ctx context.Context, in *SearchLoadBalancersRequest, opts ...grpc.CallOption) (*SearchLoadBalancersResponse, error) {
	out := new(SearchLoadBalancersResponse)
	err := c.cc.Invoke(ctx, "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SearchLoadBalancersAllNamespaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AppSecurityMonitoringAPIServer is the server API for AppSecurityMonitoringAPI service.
type AppSecurityMonitoringAPIServer interface {
	// Security Events Query
	//
	// x-displayName: "Security Events Query"
	// Get security events for the given namespace.
	// For `system` namespace, all security events for the tenant matching the query specified
	// in the request will be returned in the response. User may query security events that matches various
	// fields such as `vh_name`, `sec_event_type`, `src_site`, `city`, `country`.
	SecurityEventsQuery(context.Context, *SecurityEventsRequest) (*SecurityEventsResponse, error)
	// Security Events Query All Namespaces
	//
	// x-displayName: "Security Events Query All Namespaces"
	// Get security events for the given namespace.
	// For `system` namespace, all security events for the tenant matching the query specified
	// in the request will be returned in the response. User may query security events that matches various
	// fields such as `vh_name`, `sec_event_type`, `src_site`, `city`, `country`.
	// This API is specific to system namespace
	SecurityEventsQueryAllNamespaces(context.Context, *SecurityEventsRequest) (*SecurityEventsResponse, error)
	// SecurityEventScrollQuery
	//
	// x-displayName: "Security Event Scroll Query"
	// Scroll request is used to fetch large number of security events in multiple batches with each SecurityEventResponse
	// containing no more than 500 messages. To scroll through more than 500 or all messages, one can use the
	// SecurityEventScrollRequest. Use the scroll_id returned in the SecurityEventResponse to fetch the next batch of security events
	// and one can continue this process till the scroll_id returned is "" which indicates no more events to scroll.
	SecurityEventsScrollQuery(context.Context, *SecurityEventsScrollRequest) (*SecurityEventsResponse, error)
	// Security Events Aggregation Query
	//
	// x-displayName: "Security Events Aggregation Query"
	// Get summary/aggregation data for security events in the given namespace.
	// For `system` namespace, all security events for the tenant matching the query specified
	// in the request will be considered for aggregation. User may query security events that matches various
	// fields such as `vh_name`, `sec_event_type`, `src_site`, `city`, `country`.
	SecurityEventsAggregationQuery(context.Context, *SecurityEventsAggregationRequest) (*SecurityEventsAggregationResponse, error)
	// Security Events Aggregation Query All Namespaces
	//
	// x-displayName: "Security Events Aggregation Query All Namespaces"
	// Get summary/aggregation data for security events in the given namespace.
	// For `system` namespace, all security events for the tenant matching the query specified
	// in the request will be considered for aggregation. User may query security events that matches various
	// fields such as `vh_name`, `sec_event_type`, `src_site`, `city`, `country`.
	SecurityEventsAggregationQueryAllNamespaces(context.Context, *SecurityEventsAggregationRequest) (*SecurityEventsAggregationResponse, error)
	// Suspicious Users Logs Query
	//
	// x-displayName: "Suspicious User Logs Query"
	// Get suspicious user logs for the given namespace.
	// For `system` namespace, all suspicious users logs for the tenant matching the query specified
	// in the request will be returned in the response. User may query suspicious user logs that matches various
	// fields such as `vh_name`, `user`, `site`, `city`, `country`.
	SuspiciousUserLogsQuery(context.Context, *SuspiciousUserLogsRequest) (*SuspiciousUserLogsResponse, error)
	// Suspicious User Logs Scroll Query
	//
	// x-displayName: "Suspicious User Logs Scroll Query"
	// Scroll request is used to fetch large number of suspicious user logs in multiple batches with each SuspiciousUserLogsResponse
	// containing no more than 500 messages. To scroll through more than 500 or all messages, one can use the
	// SuspiciousUserLogsScrollRequest. Use the scroll_id returned in the SuspiciousUserLogsResponse to fetch the next batch of logs
	// and one can continue this process till the scroll_id returned is "" which indicates no more logs to scroll.
	SuspiciousUserLogsScrollQuery(context.Context, *SuspiciousUserLogsScrollRequest) (*SuspiciousUserLogsResponse, error)
	// Suspicious User Logs Aggregation Query
	//
	// x-displayName: "Suspicious User Logs Aggregation Query"
	// Get summary/aggregation data for suspicious user logs in the given namespace.
	// For `system` namespace, all suspicious user logs for the tenant matching the query specified
	// in the request will be considered for aggregation. User may query suspicious user logs that matches various
	// fields such as `vh_name`, `user`, `site`, `city`, `country`.
	SuspiciousUserLogsAggregationQuery(context.Context, *SuspiciousUserLogsAggregationRequest) (*SuspiciousUserLogsAggregationResponse, error)
	// Security Events Metrics
	//
	// x-displayName: "Security Events Metrics"
	// Get the number of security events for a given namespace.
	// Security events can be aggregated across multiple dimensions like VIRTUAL_HOST, SITE, SEC_EVENT_TYPE, etc.,
	SecurityEventsMetrics(context.Context, *SecurityEventsCountRequest) (*SecurityEventsCountResponse, error)
	// Security Incidents Query
	//
	// x-displayName: "Security Incidents Query"
	// Get security incidents for the given namespace.
	// For `system` namespace, all security incidents for the tenant matching the query specified
	// in the request will be returned in the response. User may query security incidents that matches various
	// fields such as `vh_name`, `intent`, `city`, `country`.
	SecurityIncidentsQuery(context.Context, *SecurityIncidentsRequest) (*SecurityIncidentsResponse, error)
	// SecurityIncidentsScrollQuery
	//
	// x-displayName: "Security Incidents Scroll Query"
	// Scroll request is used to fetch large number of security incidents in multiple batches with each SecurityIncidentsResponse
	// containing no more than 500 messages. To scroll through more than 500 or all messages, one can use the
	// SecurityIncidentsScrollRequest. Use the scroll_id returned in the SecurityIncidentsResponse to fetch the next batch
	// of security incidents and one can continue this process till the scroll_id returned is "" which indicates no more
	// events to scroll.
	SecurityIncidentsScrollQuery(context.Context, *SecurityIncidentsScrollRequest) (*SecurityIncidentsResponse, error)
	// Security Incidents Aggregation Query
	//
	// x-displayName: "Security Incidents Aggregation Query"
	// Get summary/aggregation data for security incidents in the given namespace.
	// For `system` namespace, all security incidents for the tenant matching the query specified in the request will be
	// considered for aggregation. User may query security events that matches various fields such as `vh_name`,
	// `intent`, `city`, `country`.
	SecurityIncidentsAggregationQuery(context.Context, *SecurityIncidentsAggregationRequest) (*SecurityIncidentsAggregationResponse, error)
	// Search load balancers
	//
	// x-displayName: "Search load balancers"
	// Get list of virtual hosts matching label filter
	SearchLoadBalancers(context.Context, *SearchLoadBalancersRequest) (*SearchLoadBalancersResponse, error)
	// Search load balancers All Namespaces
	//
	// x-displayName: "Search load balancers All Namespaces"
	// Get list of virtual hosts matching label filter
	SearchLoadBalancersAllNamespaces(context.Context, *SearchLoadBalancersRequest) (*SearchLoadBalancersResponse, error)
}

// UnimplementedAppSecurityMonitoringAPIServer can be embedded to have forward compatible implementations.
type UnimplementedAppSecurityMonitoringAPIServer struct {
}

func (*UnimplementedAppSecurityMonitoringAPIServer) SecurityEventsQuery(ctx context.Context, req *SecurityEventsRequest) (*SecurityEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecurityEventsQuery not implemented")
}
func (*UnimplementedAppSecurityMonitoringAPIServer) SecurityEventsQueryAllNamespaces(ctx context.Context, req *SecurityEventsRequest) (*SecurityEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecurityEventsQueryAllNamespaces not implemented")
}
func (*UnimplementedAppSecurityMonitoringAPIServer) SecurityEventsScrollQuery(ctx context.Context, req *SecurityEventsScrollRequest) (*SecurityEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecurityEventsScrollQuery not implemented")
}
func (*UnimplementedAppSecurityMonitoringAPIServer) SecurityEventsAggregationQuery(ctx context.Context, req *SecurityEventsAggregationRequest) (*SecurityEventsAggregationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecurityEventsAggregationQuery not implemented")
}
func (*UnimplementedAppSecurityMonitoringAPIServer) SecurityEventsAggregationQueryAllNamespaces(ctx context.Context, req *SecurityEventsAggregationRequest) (*SecurityEventsAggregationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecurityEventsAggregationQueryAllNamespaces not implemented")
}
func (*UnimplementedAppSecurityMonitoringAPIServer) SuspiciousUserLogsQuery(ctx context.Context, req *SuspiciousUserLogsRequest) (*SuspiciousUserLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SuspiciousUserLogsQuery not implemented")
}
func (*UnimplementedAppSecurityMonitoringAPIServer) SuspiciousUserLogsScrollQuery(ctx context.Context, req *SuspiciousUserLogsScrollRequest) (*SuspiciousUserLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SuspiciousUserLogsScrollQuery not implemented")
}
func (*UnimplementedAppSecurityMonitoringAPIServer) SuspiciousUserLogsAggregationQuery(ctx context.Context, req *SuspiciousUserLogsAggregationRequest) (*SuspiciousUserLogsAggregationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SuspiciousUserLogsAggregationQuery not implemented")
}
func (*UnimplementedAppSecurityMonitoringAPIServer) SecurityEventsMetrics(ctx context.Context, req *SecurityEventsCountRequest) (*SecurityEventsCountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecurityEventsMetrics not implemented")
}
func (*UnimplementedAppSecurityMonitoringAPIServer) SecurityIncidentsQuery(ctx context.Context, req *SecurityIncidentsRequest) (*SecurityIncidentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecurityIncidentsQuery not implemented")
}
func (*UnimplementedAppSecurityMonitoringAPIServer) SecurityIncidentsScrollQuery(ctx context.Context, req *SecurityIncidentsScrollRequest) (*SecurityIncidentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecurityIncidentsScrollQuery not implemented")
}
func (*UnimplementedAppSecurityMonitoringAPIServer) SecurityIncidentsAggregationQuery(ctx context.Context, req *SecurityIncidentsAggregationRequest) (*SecurityIncidentsAggregationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecurityIncidentsAggregationQuery not implemented")
}
func (*UnimplementedAppSecurityMonitoringAPIServer) SearchLoadBalancers(ctx context.Context, req *SearchLoadBalancersRequest) (*SearchLoadBalancersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchLoadBalancers not implemented")
}
func (*UnimplementedAppSecurityMonitoringAPIServer) SearchLoadBalancersAllNamespaces(ctx context.Context, req *SearchLoadBalancersRequest) (*SearchLoadBalancersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchLoadBalancersAllNamespaces not implemented")
}

func RegisterAppSecurityMonitoringAPIServer(s *grpc.Server, srv AppSecurityMonitoringAPIServer) {
	s.RegisterService(&_AppSecurityMonitoringAPI_serviceDesc, srv)
}

func _AppSecurityMonitoringAPI_SecurityEventsQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppSecurityMonitoringAPIServer).SecurityEventsQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SecurityEventsQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppSecurityMonitoringAPIServer).SecurityEventsQuery(ctx, req.(*SecurityEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppSecurityMonitoringAPI_SecurityEventsQueryAllNamespaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppSecurityMonitoringAPIServer).SecurityEventsQueryAllNamespaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SecurityEventsQueryAllNamespaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppSecurityMonitoringAPIServer).SecurityEventsQueryAllNamespaces(ctx, req.(*SecurityEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppSecurityMonitoringAPI_SecurityEventsScrollQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityEventsScrollRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppSecurityMonitoringAPIServer).SecurityEventsScrollQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SecurityEventsScrollQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppSecurityMonitoringAPIServer).SecurityEventsScrollQuery(ctx, req.(*SecurityEventsScrollRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppSecurityMonitoringAPI_SecurityEventsAggregationQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityEventsAggregationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppSecurityMonitoringAPIServer).SecurityEventsAggregationQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SecurityEventsAggregationQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppSecurityMonitoringAPIServer).SecurityEventsAggregationQuery(ctx, req.(*SecurityEventsAggregationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppSecurityMonitoringAPI_SecurityEventsAggregationQueryAllNamespaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityEventsAggregationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppSecurityMonitoringAPIServer).SecurityEventsAggregationQueryAllNamespaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SecurityEventsAggregationQueryAllNamespaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppSecurityMonitoringAPIServer).SecurityEventsAggregationQueryAllNamespaces(ctx, req.(*SecurityEventsAggregationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppSecurityMonitoringAPI_SuspiciousUserLogsQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuspiciousUserLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppSecurityMonitoringAPIServer).SuspiciousUserLogsQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SuspiciousUserLogsQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppSecurityMonitoringAPIServer).SuspiciousUserLogsQuery(ctx, req.(*SuspiciousUserLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppSecurityMonitoringAPI_SuspiciousUserLogsScrollQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuspiciousUserLogsScrollRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppSecurityMonitoringAPIServer).SuspiciousUserLogsScrollQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SuspiciousUserLogsScrollQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppSecurityMonitoringAPIServer).SuspiciousUserLogsScrollQuery(ctx, req.(*SuspiciousUserLogsScrollRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppSecurityMonitoringAPI_SuspiciousUserLogsAggregationQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuspiciousUserLogsAggregationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppSecurityMonitoringAPIServer).SuspiciousUserLogsAggregationQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SuspiciousUserLogsAggregationQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppSecurityMonitoringAPIServer).SuspiciousUserLogsAggregationQuery(ctx, req.(*SuspiciousUserLogsAggregationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppSecurityMonitoringAPI_SecurityEventsMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityEventsCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppSecurityMonitoringAPIServer).SecurityEventsMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SecurityEventsMetrics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppSecurityMonitoringAPIServer).SecurityEventsMetrics(ctx, req.(*SecurityEventsCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppSecurityMonitoringAPI_SecurityIncidentsQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityIncidentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppSecurityMonitoringAPIServer).SecurityIncidentsQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SecurityIncidentsQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppSecurityMonitoringAPIServer).SecurityIncidentsQuery(ctx, req.(*SecurityIncidentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppSecurityMonitoringAPI_SecurityIncidentsScrollQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityIncidentsScrollRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppSecurityMonitoringAPIServer).SecurityIncidentsScrollQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SecurityIncidentsScrollQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppSecurityMonitoringAPIServer).SecurityIncidentsScrollQuery(ctx, req.(*SecurityIncidentsScrollRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppSecurityMonitoringAPI_SecurityIncidentsAggregationQuery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecurityIncidentsAggregationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppSecurityMonitoringAPIServer).SecurityIncidentsAggregationQuery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SecurityIncidentsAggregationQuery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppSecurityMonitoringAPIServer).SecurityIncidentsAggregationQuery(ctx, req.(*SecurityIncidentsAggregationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppSecurityMonitoringAPI_SearchLoadBalancers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchLoadBalancersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppSecurityMonitoringAPIServer).SearchLoadBalancers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SearchLoadBalancers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppSecurityMonitoringAPIServer).SearchLoadBalancers(ctx, req.(*SearchLoadBalancersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppSecurityMonitoringAPI_SearchLoadBalancersAllNamespaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchLoadBalancersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppSecurityMonitoringAPIServer).SearchLoadBalancersAllNamespaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.app_security.AppSecurityMonitoringAPI/SearchLoadBalancersAllNamespaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppSecurityMonitoringAPIServer).SearchLoadBalancersAllNamespaces(ctx, req.(*SearchLoadBalancersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AppSecurityMonitoringAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ves.io.schema.app_security.AppSecurityMonitoringAPI",
	HandlerType: (*AppSecurityMonitoringAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SecurityEventsQuery",
			Handler:    _AppSecurityMonitoringAPI_SecurityEventsQuery_Handler,
		},
		{
			MethodName: "SecurityEventsQueryAllNamespaces",
			Handler:    _AppSecurityMonitoringAPI_SecurityEventsQueryAllNamespaces_Handler,
		},
		{
			MethodName: "SecurityEventsScrollQuery",
			Handler:    _AppSecurityMonitoringAPI_SecurityEventsScrollQuery_Handler,
		},
		{
			MethodName: "SecurityEventsAggregationQuery",
			Handler:    _AppSecurityMonitoringAPI_SecurityEventsAggregationQuery_Handler,
		},
		{
			MethodName: "SecurityEventsAggregationQueryAllNamespaces",
			Handler:    _AppSecurityMonitoringAPI_SecurityEventsAggregationQueryAllNamespaces_Handler,
		},
		{
			MethodName: "SuspiciousUserLogsQuery",
			Handler:    _AppSecurityMonitoringAPI_SuspiciousUserLogsQuery_Handler,
		},
		{
			MethodName: "SuspiciousUserLogsScrollQuery",
			Handler:    _AppSecurityMonitoringAPI_SuspiciousUserLogsScrollQuery_Handler,
		},
		{
			MethodName: "SuspiciousUserLogsAggregationQuery",
			Handler:    _AppSecurityMonitoringAPI_SuspiciousUserLogsAggregationQuery_Handler,
		},
		{
			MethodName: "SecurityEventsMetrics",
			Handler:    _AppSecurityMonitoringAPI_SecurityEventsMetrics_Handler,
		},
		{
			MethodName: "SecurityIncidentsQuery",
			Handler:    _AppSecurityMonitoringAPI_SecurityIncidentsQuery_Handler,
		},
		{
			MethodName: "SecurityIncidentsScrollQuery",
			Handler:    _AppSecurityMonitoringAPI_SecurityIncidentsScrollQuery_Handler,
		},
		{
			MethodName: "SecurityIncidentsAggregationQuery",
			Handler:    _AppSecurityMonitoringAPI_SecurityIncidentsAggregationQuery_Handler,
		},
		{
			MethodName: "SearchLoadBalancers",
			Handler:    _AppSecurityMonitoringAPI_SearchLoadBalancers_Handler,
		},
		{
			MethodName: "SearchLoadBalancersAllNamespaces",
			Handler:    _AppSecurityMonitoringAPI_SearchLoadBalancersAllNamespaces_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ves.io/schema/app_security/public_monitoring_api.proto",
}

func (m *SecurityEventsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityEventsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityEventsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SortBy) > 0 {
		i -= len(m.SortBy)
		copy(dAtA[i:], m.SortBy)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.SortBy)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Scroll {
		i--
		if m.Scroll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Limit != 0 {
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x30
	}
	if m.Sort != 0 {
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(m.Sort))
		i--
		dAtA[i] = 0x28
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityEventsScrollRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityEventsScrollRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityEventsScrollRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ScrollId) > 0 {
		i -= len(m.ScrollId)
		copy(dAtA[i:], m.ScrollId)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.ScrollId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityEventsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityEventsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityEventsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ScrollId) > 0 {
		i -= len(m.ScrollId)
		copy(dAtA[i:], m.ScrollId)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.ScrollId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.TotalHits != 0 {
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(m.TotalHits))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Events[iNdEx])
			copy(dAtA[i:], m.Events[iNdEx])
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Events[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SecurityEventsAggregationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityEventsAggregationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityEventsAggregationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityEventsAggregationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityEventsAggregationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityEventsAggregationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TotalHits != 0 {
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(m.TotalHits))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SuspiciousUserLogsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuspiciousUserLogsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SuspiciousUserLogsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SortBy) > 0 {
		i -= len(m.SortBy)
		copy(dAtA[i:], m.SortBy)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.SortBy)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Scroll {
		i--
		if m.Scroll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Limit != 0 {
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x30
	}
	if m.Sort != 0 {
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(m.Sort))
		i--
		dAtA[i] = 0x28
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SuspiciousUserLogsScrollRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuspiciousUserLogsScrollRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SuspiciousUserLogsScrollRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ScrollId) > 0 {
		i -= len(m.ScrollId)
		copy(dAtA[i:], m.ScrollId)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.ScrollId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SuspiciousUserLogsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuspiciousUserLogsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SuspiciousUserLogsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ScrollId) > 0 {
		i -= len(m.ScrollId)
		copy(dAtA[i:], m.ScrollId)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.ScrollId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.TotalHits != 0 {
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(m.TotalHits))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Logs) > 0 {
		for iNdEx := len(m.Logs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Logs[iNdEx])
			copy(dAtA[i:], m.Logs[iNdEx])
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Logs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SuspiciousUserLogsAggregationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuspiciousUserLogsAggregationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SuspiciousUserLogsAggregationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SuspiciousUserLogsAggregationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuspiciousUserLogsAggregationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SuspiciousUserLogsAggregationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TotalHits != 0 {
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(m.TotalHits))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SecurityEventsCountRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityEventsCountRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityEventsCountRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Step) > 0 {
		i -= len(m.Step)
		copy(dAtA[i:], m.Step)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Step)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.GroupBy) > 0 {
		dAtA10 := make([]byte, len(m.GroupBy)*10)
		var j9 int
		for _, num := range m.GroupBy {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.LabelFilter) > 0 {
		for iNdEx := len(m.LabelFilter) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LabelFilter[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityEventsCountResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityEventsCountResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityEventsCountResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Step) > 0 {
		i -= len(m.Step)
		copy(dAtA[i:], m.Step)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Step)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SecurityIncidentsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityIncidentsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityIncidentsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SortBy) > 0 {
		i -= len(m.SortBy)
		copy(dAtA[i:], m.SortBy)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.SortBy)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Scroll {
		i--
		if m.Scroll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Limit != 0 {
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x30
	}
	if m.Sort != 0 {
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(m.Sort))
		i--
		dAtA[i] = 0x28
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityIncidentsScrollRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityIncidentsScrollRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityIncidentsScrollRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ScrollId) > 0 {
		i -= len(m.ScrollId)
		copy(dAtA[i:], m.ScrollId)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.ScrollId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityIncidentsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityIncidentsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityIncidentsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ScrollId) > 0 {
		i -= len(m.ScrollId)
		copy(dAtA[i:], m.ScrollId)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.ScrollId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.TotalHits != 0 {
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(m.TotalHits))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Incidents) > 0 {
		for iNdEx := len(m.Incidents) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Incidents[iNdEx])
			copy(dAtA[i:], m.Incidents[iNdEx])
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Incidents[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SecurityIncidentsAggregationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityIncidentsAggregationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityIncidentsAggregationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityIncidentsAggregationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityIncidentsAggregationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityIncidentsAggregationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Aggs) > 0 {
		for k := range m.Aggs {
			v := m.Aggs[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TotalHits != 0 {
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(m.TotalHits))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SearchFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for iNdEx := len(m.Value) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Value[iNdEx])
			copy(dAtA[i:], m.Value[iNdEx])
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Value[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Op != 0 {
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x10
	}
	if m.Label != 0 {
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(m.Label))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SearchLoadBalancersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchLoadBalancersRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchLoadBalancersRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LabelFilter) > 0 {
		for iNdEx := len(m.LabelFilter) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LabelFilter[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SearchLoadBalancersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchLoadBalancersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SearchLoadBalancersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Loadbalancers) > 0 {
		for iNdEx := len(m.Loadbalancers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Loadbalancers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LoadbalancerData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadbalancerData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoadbalancerData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequestData != nil {
		{
			size, err := m.RequestData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.SecurityEventsData != nil {
		{
			size, err := m.SecurityEventsData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecurityEventsData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityEventsData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecurityEventsData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxTime != nil {
		{
			size, err := m.MaxTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MinTime != nil {
		{
			size, err := m.MinTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Count != 0 {
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RequestData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxTime != nil {
		{
			size, err := m.MaxTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MinTime != nil {
		{
			size, err := m.MinTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Count != 0 {
		i = encodeVarintPublicMonitoringApi(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintPublicMonitoringApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovPublicMonitoringApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SecurityEventsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	if m.Sort != 0 {
		n += 1 + sovPublicMonitoringApi(uint64(m.Sort))
	}
	if m.Limit != 0 {
		n += 1 + sovPublicMonitoringApi(uint64(m.Limit))
	}
	if m.Scroll {
		n += 2
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicMonitoringApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicMonitoringApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicMonitoringApi(uint64(mapEntrySize))
		}
	}
	l = len(m.SortBy)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	return n
}

func (m *SecurityEventsScrollRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	l = len(m.ScrollId)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	return n
}

func (m *SecurityEventsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, s := range m.Events {
			l = len(s)
			n += 1 + l + sovPublicMonitoringApi(uint64(l))
		}
	}
	if m.TotalHits != 0 {
		n += 1 + sovPublicMonitoringApi(uint64(m.TotalHits))
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicMonitoringApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicMonitoringApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicMonitoringApi(uint64(mapEntrySize))
		}
	}
	l = len(m.ScrollId)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	return n
}

func (m *SecurityEventsAggregationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicMonitoringApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicMonitoringApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicMonitoringApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SecurityEventsAggregationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalHits != 0 {
		n += 1 + sovPublicMonitoringApi(uint64(m.TotalHits))
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicMonitoringApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicMonitoringApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicMonitoringApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SuspiciousUserLogsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	if m.Sort != 0 {
		n += 1 + sovPublicMonitoringApi(uint64(m.Sort))
	}
	if m.Limit != 0 {
		n += 1 + sovPublicMonitoringApi(uint64(m.Limit))
	}
	if m.Scroll {
		n += 2
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicMonitoringApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicMonitoringApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicMonitoringApi(uint64(mapEntrySize))
		}
	}
	l = len(m.SortBy)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	return n
}

func (m *SuspiciousUserLogsScrollRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	l = len(m.ScrollId)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	return n
}

func (m *SuspiciousUserLogsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Logs) > 0 {
		for _, s := range m.Logs {
			l = len(s)
			n += 1 + l + sovPublicMonitoringApi(uint64(l))
		}
	}
	if m.TotalHits != 0 {
		n += 1 + sovPublicMonitoringApi(uint64(m.TotalHits))
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicMonitoringApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicMonitoringApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicMonitoringApi(uint64(mapEntrySize))
		}
	}
	l = len(m.ScrollId)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	return n
}

func (m *SuspiciousUserLogsAggregationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicMonitoringApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicMonitoringApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicMonitoringApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SuspiciousUserLogsAggregationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalHits != 0 {
		n += 1 + sovPublicMonitoringApi(uint64(m.TotalHits))
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicMonitoringApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicMonitoringApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicMonitoringApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SecurityEventsCountRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	if len(m.LabelFilter) > 0 {
		for _, e := range m.LabelFilter {
			l = e.Size()
			n += 1 + l + sovPublicMonitoringApi(uint64(l))
		}
	}
	if len(m.GroupBy) > 0 {
		l = 0
		for _, e := range m.GroupBy {
			l += sovPublicMonitoringApi(uint64(e))
		}
		n += 1 + sovPublicMonitoringApi(uint64(l)) + l
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	l = len(m.Step)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	return n
}

func (m *SecurityEventsCountResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovPublicMonitoringApi(uint64(l))
		}
	}
	l = len(m.Step)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	return n
}

func (m *SecurityIncidentsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	if m.Sort != 0 {
		n += 1 + sovPublicMonitoringApi(uint64(m.Sort))
	}
	if m.Limit != 0 {
		n += 1 + sovPublicMonitoringApi(uint64(m.Limit))
	}
	if m.Scroll {
		n += 2
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicMonitoringApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicMonitoringApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicMonitoringApi(uint64(mapEntrySize))
		}
	}
	l = len(m.SortBy)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	return n
}

func (m *SecurityIncidentsScrollRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	l = len(m.ScrollId)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	return n
}

func (m *SecurityIncidentsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Incidents) > 0 {
		for _, s := range m.Incidents {
			l = len(s)
			n += 1 + l + sovPublicMonitoringApi(uint64(l))
		}
	}
	if m.TotalHits != 0 {
		n += 1 + sovPublicMonitoringApi(uint64(m.TotalHits))
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicMonitoringApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicMonitoringApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicMonitoringApi(uint64(mapEntrySize))
		}
	}
	l = len(m.ScrollId)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	return n
}

func (m *SecurityIncidentsAggregationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicMonitoringApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicMonitoringApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicMonitoringApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SecurityIncidentsAggregationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalHits != 0 {
		n += 1 + sovPublicMonitoringApi(uint64(m.TotalHits))
	}
	if len(m.Aggs) > 0 {
		for k, v := range m.Aggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPublicMonitoringApi(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPublicMonitoringApi(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPublicMonitoringApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SearchFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Label != 0 {
		n += 1 + sovPublicMonitoringApi(uint64(m.Label))
	}
	if m.Op != 0 {
		n += 1 + sovPublicMonitoringApi(uint64(m.Op))
	}
	if len(m.Value) > 0 {
		for _, s := range m.Value {
			l = len(s)
			n += 1 + l + sovPublicMonitoringApi(uint64(l))
		}
	}
	return n
}

func (m *SearchLoadBalancersRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	if len(m.LabelFilter) > 0 {
		for _, e := range m.LabelFilter {
			l = e.Size()
			n += 1 + l + sovPublicMonitoringApi(uint64(l))
		}
	}
	return n
}

func (m *SearchLoadBalancersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Loadbalancers) > 0 {
		for _, e := range m.Loadbalancers {
			l = e.Size()
			n += 1 + l + sovPublicMonitoringApi(uint64(l))
		}
	}
	return n
}

func (m *LoadbalancerData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	if m.SecurityEventsData != nil {
		l = m.SecurityEventsData.Size()
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	if m.RequestData != nil {
		l = m.RequestData.Size()
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	return n
}

func (m *SecurityEventsData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovPublicMonitoringApi(uint64(m.Count))
	}
	if m.MinTime != nil {
		l = m.MinTime.Size()
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	if m.MaxTime != nil {
		l = m.MaxTime.Size()
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	return n
}

func (m *RequestData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovPublicMonitoringApi(uint64(m.Count))
	}
	if m.MinTime != nil {
		l = m.MinTime.Size()
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	if m.MaxTime != nil {
		l = m.MaxTime.Size()
		n += 1 + l + sovPublicMonitoringApi(uint64(l))
	}
	return n
}

func sovPublicMonitoringApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPublicMonitoringApi(x uint64) (n int) {
	return sovPublicMonitoringApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *SecurityEventsRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&SecurityEventsRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`Sort:` + fmt.Sprintf("%v", this.Sort) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`Scroll:` + fmt.Sprintf("%v", this.Scroll) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`SortBy:` + fmt.Sprintf("%v", this.SortBy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityEventsScrollRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SecurityEventsScrollRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`ScrollId:` + fmt.Sprintf("%v", this.ScrollId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityEventsResponse) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*log.LogAggregationData{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&SecurityEventsResponse{`,
		`Events:` + fmt.Sprintf("%v", this.Events) + `,`,
		`TotalHits:` + fmt.Sprintf("%v", this.TotalHits) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`ScrollId:` + fmt.Sprintf("%v", this.ScrollId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityEventsAggregationRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&SecurityEventsAggregationRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityEventsAggregationResponse) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*log.LogAggregationData{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&SecurityEventsAggregationResponse{`,
		`TotalHits:` + fmt.Sprintf("%v", this.TotalHits) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *SuspiciousUserLogsRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*suspicious_user_log.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&SuspiciousUserLogsRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`Sort:` + fmt.Sprintf("%v", this.Sort) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`Scroll:` + fmt.Sprintf("%v", this.Scroll) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`SortBy:` + fmt.Sprintf("%v", this.SortBy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SuspiciousUserLogsScrollRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SuspiciousUserLogsScrollRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`ScrollId:` + fmt.Sprintf("%v", this.ScrollId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SuspiciousUserLogsResponse) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*log.LogAggregationData{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&SuspiciousUserLogsResponse{`,
		`Logs:` + fmt.Sprintf("%v", this.Logs) + `,`,
		`TotalHits:` + fmt.Sprintf("%v", this.TotalHits) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`ScrollId:` + fmt.Sprintf("%v", this.ScrollId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SuspiciousUserLogsAggregationRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*suspicious_user_log.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&SuspiciousUserLogsAggregationRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *SuspiciousUserLogsAggregationResponse) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*log.LogAggregationData{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&SuspiciousUserLogsAggregationResponse{`,
		`TotalHits:` + fmt.Sprintf("%v", this.TotalHits) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityEventsCountRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLabelFilter := "[]*SecurityMetricLabelFilter{"
	for _, f := range this.LabelFilter {
		repeatedStringForLabelFilter += strings.Replace(fmt.Sprintf("%v", f), "SecurityMetricLabelFilter", "metrics.SecurityMetricLabelFilter", 1) + ","
	}
	repeatedStringForLabelFilter += "}"
	s := strings.Join([]string{`&SecurityEventsCountRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`LabelFilter:` + repeatedStringForLabelFilter + `,`,
		`GroupBy:` + fmt.Sprintf("%v", this.GroupBy) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`Step:` + fmt.Sprintf("%v", this.Step) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityEventsCountResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForData := "[]*SecurityEventsCounter{"
	for _, f := range this.Data {
		repeatedStringForData += strings.Replace(fmt.Sprintf("%v", f), "SecurityEventsCounter", "metrics.SecurityEventsCounter", 1) + ","
	}
	repeatedStringForData += "}"
	s := strings.Join([]string{`&SecurityEventsCountResponse{`,
		`Data:` + repeatedStringForData + `,`,
		`Step:` + fmt.Sprintf("%v", this.Step) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityIncidentsRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*incidents.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&SecurityIncidentsRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`Sort:` + fmt.Sprintf("%v", this.Sort) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`Scroll:` + fmt.Sprintf("%v", this.Scroll) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`SortBy:` + fmt.Sprintf("%v", this.SortBy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityIncidentsScrollRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SecurityIncidentsScrollRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`ScrollId:` + fmt.Sprintf("%v", this.ScrollId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityIncidentsResponse) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*log.LogAggregationData{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&SecurityIncidentsResponse{`,
		`Incidents:` + fmt.Sprintf("%v", this.Incidents) + `,`,
		`TotalHits:` + fmt.Sprintf("%v", this.TotalHits) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`ScrollId:` + fmt.Sprintf("%v", this.ScrollId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityIncidentsAggregationRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*incidents.AggregationRequest{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&SecurityIncidentsAggregationRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`StartTime:` + fmt.Sprintf("%v", this.StartTime) + `,`,
		`EndTime:` + fmt.Sprintf("%v", this.EndTime) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityIncidentsAggregationResponse) String() string {
	if this == nil {
		return "nil"
	}
	keysForAggs := make([]string, 0, len(this.Aggs))
	for k, _ := range this.Aggs {
		keysForAggs = append(keysForAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAggs)
	mapStringForAggs := "map[string]*log.LogAggregationData{"
	for _, k := range keysForAggs {
		mapStringForAggs += fmt.Sprintf("%v: %v,", k, this.Aggs[k])
	}
	mapStringForAggs += "}"
	s := strings.Join([]string{`&SecurityIncidentsAggregationResponse{`,
		`TotalHits:` + fmt.Sprintf("%v", this.TotalHits) + `,`,
		`Aggs:` + mapStringForAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *SearchFilter) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SearchFilter{`,
		`Label:` + fmt.Sprintf("%v", this.Label) + `,`,
		`Op:` + fmt.Sprintf("%v", this.Op) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SearchLoadBalancersRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLabelFilter := "[]*SearchFilter{"
	for _, f := range this.LabelFilter {
		repeatedStringForLabelFilter += strings.Replace(f.String(), "SearchFilter", "SearchFilter", 1) + ","
	}
	repeatedStringForLabelFilter += "}"
	s := strings.Join([]string{`&SearchLoadBalancersRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`LabelFilter:` + repeatedStringForLabelFilter + `,`,
		`}`,
	}, "")
	return s
}
func (this *SearchLoadBalancersResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLoadbalancers := "[]*LoadbalancerData{"
	for _, f := range this.Loadbalancers {
		repeatedStringForLoadbalancers += strings.Replace(f.String(), "LoadbalancerData", "LoadbalancerData", 1) + ","
	}
	repeatedStringForLoadbalancers += "}"
	s := strings.Join([]string{`&SearchLoadBalancersResponse{`,
		`Loadbalancers:` + repeatedStringForLoadbalancers + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoadbalancerData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoadbalancerData{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`SecurityEventsData:` + strings.Replace(this.SecurityEventsData.String(), "SecurityEventsData", "SecurityEventsData", 1) + `,`,
		`RequestData:` + strings.Replace(this.RequestData.String(), "RequestData", "RequestData", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityEventsData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SecurityEventsData{`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`MinTime:` + strings.Replace(fmt.Sprintf("%v", this.MinTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`MaxTime:` + strings.Replace(fmt.Sprintf("%v", this.MaxTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestData{`,
		`Count:` + fmt.Sprintf("%v", this.Count) + `,`,
		`MinTime:` + strings.Replace(fmt.Sprintf("%v", this.MinTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`MaxTime:` + strings.Replace(fmt.Sprintf("%v", this.MaxTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringPublicMonitoringApi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *SecurityEventsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicMonitoringApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityEventsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityEventsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= schema.SortOrder(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scroll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Scroll = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*AggregationRequest)
			}
			var mapkey string
			var mapvalue *AggregationRequest
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicMonitoringApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AggregationRequest{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SortBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityEventsScrollRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicMonitoringApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityEventsScrollRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityEventsScrollRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScrollId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScrollId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityEventsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicMonitoringApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityEventsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityEventsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHits", wireType)
			}
			m.TotalHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*log.LogAggregationData)
			}
			var mapkey string
			var mapvalue *log.LogAggregationData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicMonitoringApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &log.LogAggregationData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScrollId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScrollId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityEventsAggregationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicMonitoringApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityEventsAggregationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityEventsAggregationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*AggregationRequest)
			}
			var mapkey string
			var mapvalue *AggregationRequest
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicMonitoringApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AggregationRequest{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityEventsAggregationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicMonitoringApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityEventsAggregationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityEventsAggregationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHits", wireType)
			}
			m.TotalHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*log.LogAggregationData)
			}
			var mapkey string
			var mapvalue *log.LogAggregationData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicMonitoringApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &log.LogAggregationData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SuspiciousUserLogsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicMonitoringApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SuspiciousUserLogsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SuspiciousUserLogsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= schema.SortOrder(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scroll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Scroll = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*suspicious_user_log.AggregationRequest)
			}
			var mapkey string
			var mapvalue *suspicious_user_log.AggregationRequest
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicMonitoringApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &suspicious_user_log.AggregationRequest{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SortBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SuspiciousUserLogsScrollRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicMonitoringApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SuspiciousUserLogsScrollRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SuspiciousUserLogsScrollRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScrollId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScrollId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SuspiciousUserLogsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicMonitoringApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SuspiciousUserLogsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SuspiciousUserLogsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logs = append(m.Logs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHits", wireType)
			}
			m.TotalHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*log.LogAggregationData)
			}
			var mapkey string
			var mapvalue *log.LogAggregationData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicMonitoringApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &log.LogAggregationData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScrollId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScrollId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SuspiciousUserLogsAggregationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicMonitoringApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SuspiciousUserLogsAggregationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SuspiciousUserLogsAggregationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*suspicious_user_log.AggregationRequest)
			}
			var mapkey string
			var mapvalue *suspicious_user_log.AggregationRequest
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicMonitoringApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &suspicious_user_log.AggregationRequest{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SuspiciousUserLogsAggregationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicMonitoringApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SuspiciousUserLogsAggregationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SuspiciousUserLogsAggregationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHits", wireType)
			}
			m.TotalHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*log.LogAggregationData)
			}
			var mapkey string
			var mapvalue *log.LogAggregationData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicMonitoringApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &log.LogAggregationData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityEventsCountRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicMonitoringApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityEventsCountRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityEventsCountRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabelFilter = append(m.LabelFilter, &metrics.SecurityMetricLabelFilter{})
			if err := m.LabelFilter[len(m.LabelFilter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v metrics.SecurityMetricLabel
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicMonitoringApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= metrics.SecurityMetricLabel(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GroupBy = append(m.GroupBy, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicMonitoringApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPublicMonitoringApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPublicMonitoringApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.GroupBy) == 0 {
					m.GroupBy = make([]metrics.SecurityMetricLabel, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v metrics.SecurityMetricLabel
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= metrics.SecurityMetricLabel(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GroupBy = append(m.GroupBy, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Step = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityEventsCountResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicMonitoringApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityEventsCountResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityEventsCountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &metrics.SecurityEventsCounter{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Step = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityIncidentsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicMonitoringApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityIncidentsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityIncidentsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= schema.SortOrder(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scroll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Scroll = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*incidents.AggregationRequest)
			}
			var mapkey string
			var mapvalue *incidents.AggregationRequest
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicMonitoringApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &incidents.AggregationRequest{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SortBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityIncidentsScrollRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicMonitoringApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityIncidentsScrollRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityIncidentsScrollRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScrollId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScrollId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityIncidentsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicMonitoringApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityIncidentsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityIncidentsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Incidents", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Incidents = append(m.Incidents, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHits", wireType)
			}
			m.TotalHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*log.LogAggregationData)
			}
			var mapkey string
			var mapvalue *log.LogAggregationData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicMonitoringApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &log.LogAggregationData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScrollId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScrollId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityIncidentsAggregationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicMonitoringApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityIncidentsAggregationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityIncidentsAggregationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*incidents.AggregationRequest)
			}
			var mapkey string
			var mapvalue *incidents.AggregationRequest
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicMonitoringApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &incidents.AggregationRequest{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityIncidentsAggregationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicMonitoringApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityIncidentsAggregationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityIncidentsAggregationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalHits", wireType)
			}
			m.TotalHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalHits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggs == nil {
				m.Aggs = make(map[string]*log.LogAggregationData)
			}
			var mapkey string
			var mapvalue *log.LogAggregationData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPublicMonitoringApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPublicMonitoringApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &log.LogAggregationData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPublicMonitoringApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Aggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicMonitoringApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			m.Label = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Label |= SearchLabel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= SearchLabelOperator(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchLoadBalancersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicMonitoringApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchLoadBalancersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchLoadBalancersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabelFilter = append(m.LabelFilter, &SearchFilter{})
			if err := m.LabelFilter[len(m.LabelFilter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchLoadBalancersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicMonitoringApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchLoadBalancersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchLoadBalancersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loadbalancers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Loadbalancers = append(m.Loadbalancers, &LoadbalancerData{})
			if err := m.Loadbalancers[len(m.Loadbalancers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadbalancerData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicMonitoringApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadbalancerData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadbalancerData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecurityEventsData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecurityEventsData == nil {
				m.SecurityEventsData = &SecurityEventsData{}
			}
			if err := m.SecurityEventsData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RequestData == nil {
				m.RequestData = &RequestData{}
			}
			if err := m.RequestData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityEventsData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicMonitoringApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityEventsData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityEventsData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinTime == nil {
				m.MinTime = &types.Timestamp{}
			}
			if err := m.MinTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxTime == nil {
				m.MaxTime = &types.Timestamp{}
			}
			if err := m.MaxTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPublicMonitoringApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinTime == nil {
				m.MinTime = &types.Timestamp{}
			}
			if err := m.MinTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxTime == nil {
				m.MaxTime = &types.Timestamp{}
			}
			if err := m.MaxTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPublicMonitoringApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPublicMonitoringApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPublicMonitoringApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPublicMonitoringApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPublicMonitoringApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPublicMonitoringApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPublicMonitoringApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPublicMonitoringApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPublicMonitoringApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPublicMonitoringApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPublicMonitoringApi = fmt.Errorf("proto: unexpected end of group")
)
