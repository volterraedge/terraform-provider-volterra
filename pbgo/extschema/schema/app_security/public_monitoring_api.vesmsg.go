// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package app_security

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema_app_security_incidents "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/app_security/incidents"
	ves_io_schema_app_security_suspicious_user_log "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/app_security/suspicious_user_log"
	ves_io_schema_log "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/log"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *LoadbalancerData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LoadbalancerData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LoadbalancerData) DeepCopy() *LoadbalancerData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LoadbalancerData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LoadbalancerData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LoadbalancerData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LoadbalancerDataValidator().Validate(ctx, m, opts...)
}

type ValidateLoadbalancerData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLoadbalancerData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LoadbalancerData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LoadbalancerData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["request_data"]; exists {

		vOpts := append(opts, db.WithValidateField("request_data"))
		if err := fv(ctx, m.GetRequestData(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["security_events_data"]; exists {

		vOpts := append(opts, db.WithValidateField("security_events_data"))
		if err := fv(ctx, m.GetSecurityEventsData(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLoadbalancerDataValidator = func() *ValidateLoadbalancerData {
	v := &ValidateLoadbalancerData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func LoadbalancerDataValidator() db.Validator {
	return DefaultLoadbalancerDataValidator
}

// augmented methods on protoc/std generated struct

func (m *RequestData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RequestData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RequestData) DeepCopy() *RequestData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RequestData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RequestData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RequestData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RequestDataValidator().Validate(ctx, m, opts...)
}

type ValidateRequestData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRequestData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RequestData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RequestData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["count"]; exists {

		vOpts := append(opts, db.WithValidateField("count"))
		if err := fv(ctx, m.GetCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_time"]; exists {

		vOpts := append(opts, db.WithValidateField("max_time"))
		if err := fv(ctx, m.GetMaxTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["min_time"]; exists {

		vOpts := append(opts, db.WithValidateField("min_time"))
		if err := fv(ctx, m.GetMinTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRequestDataValidator = func() *ValidateRequestData {
	v := &ValidateRequestData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func RequestDataValidator() db.Validator {
	return DefaultRequestDataValidator
}

// augmented methods on protoc/std generated struct

func (m *SearchFilter) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SearchFilter) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SearchFilter) DeepCopy() *SearchFilter {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SearchFilter{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SearchFilter) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SearchFilter) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SearchFilterValidator().Validate(ctx, m, opts...)
}

type ValidateSearchFilter struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSearchFilter) ValueValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for value")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for value")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated value")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items value")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSearchFilter) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SearchFilter)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SearchFilter got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["label"]; exists {

		vOpts := append(opts, db.WithValidateField("label"))
		if err := fv(ctx, m.GetLabel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["op"]; exists {

		vOpts := append(opts, db.WithValidateField("op"))
		if err := fv(ctx, m.GetOp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {
		vOpts := append(opts, db.WithValidateField("value"))
		if err := fv(ctx, m.GetValue(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSearchFilterValidator = func() *ValidateSearchFilter {
	v := &ValidateSearchFilter{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhValue := v.ValueValidationRuleHandler
	rulesValue := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "5",
	}
	vFn, err = vrhValue(rulesValue)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SearchFilter.value: %s", err)
		panic(errMsg)
	}
	v.FldValidators["value"] = vFn

	return v
}()

func SearchFilterValidator() db.Validator {
	return DefaultSearchFilterValidator
}

// augmented methods on protoc/std generated struct

func (m *SearchLoadBalancersRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SearchLoadBalancersRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SearchLoadBalancersRequest) DeepCopy() *SearchLoadBalancersRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SearchLoadBalancersRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SearchLoadBalancersRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SearchLoadBalancersRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SearchLoadBalancersRequestValidator().Validate(ctx, m, opts...)
}

type ValidateSearchLoadBalancersRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSearchLoadBalancersRequest) LabelFilterValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for label_filter")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*SearchFilter, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := SearchFilterValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for label_filter")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*SearchFilter)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*SearchFilter, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated label_filter")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items label_filter")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateSearchLoadBalancersRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SearchLoadBalancersRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SearchLoadBalancersRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["label_filter"]; exists {
		vOpts := append(opts, db.WithValidateField("label_filter"))
		if err := fv(ctx, m.GetLabelFilter(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSearchLoadBalancersRequestValidator = func() *ValidateSearchLoadBalancersRequest {
	v := &ValidateSearchLoadBalancersRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhLabelFilter := v.LabelFilterValidationRuleHandler
	rulesLabelFilter := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "5",
	}
	vFn, err = vrhLabelFilter(rulesLabelFilter)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SearchLoadBalancersRequest.label_filter: %s", err)
		panic(errMsg)
	}
	v.FldValidators["label_filter"] = vFn

	return v
}()

func SearchLoadBalancersRequestValidator() db.Validator {
	return DefaultSearchLoadBalancersRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *SearchLoadBalancersResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SearchLoadBalancersResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SearchLoadBalancersResponse) DeepCopy() *SearchLoadBalancersResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SearchLoadBalancersResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SearchLoadBalancersResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SearchLoadBalancersResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SearchLoadBalancersResponseValidator().Validate(ctx, m, opts...)
}

type ValidateSearchLoadBalancersResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSearchLoadBalancersResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SearchLoadBalancersResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SearchLoadBalancersResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["loadbalancers"]; exists {

		vOpts := append(opts, db.WithValidateField("loadbalancers"))
		for idx, item := range m.GetLoadbalancers() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSearchLoadBalancersResponseValidator = func() *ValidateSearchLoadBalancersResponse {
	v := &ValidateSearchLoadBalancersResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SearchLoadBalancersResponseValidator() db.Validator {
	return DefaultSearchLoadBalancersResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *SecurityEventsAggregationRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecurityEventsAggregationRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SecurityEventsAggregationRequest) DeepCopy() *SecurityEventsAggregationRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecurityEventsAggregationRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecurityEventsAggregationRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecurityEventsAggregationRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecurityEventsAggregationRequestValidator().Validate(ctx, m, opts...)
}

type ValidateSecurityEventsAggregationRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecurityEventsAggregationRequest) StartTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_time")
	}

	return validatorFn, nil
}

func (v *ValidateSecurityEventsAggregationRequest) EndTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_time")
	}

	return validatorFn, nil
}

func (v *ValidateSecurityEventsAggregationRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecurityEventsAggregationRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecurityEventsAggregationRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query"]; exists {

		vOpts := append(opts, db.WithValidateField("query"))
		if err := fv(ctx, m.GetQuery(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecurityEventsAggregationRequestValidator = func() *ValidateSecurityEventsAggregationRequest {
	v := &ValidateSecurityEventsAggregationRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStartTime := v.StartTimeValidationRuleHandler
	rulesStartTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhStartTime(rulesStartTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityEventsAggregationRequest.start_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_time"] = vFn

	vrhEndTime := v.EndTimeValidationRuleHandler
	rulesEndTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhEndTime(rulesEndTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityEventsAggregationRequest.end_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_time"] = vFn

	v.FldValidators["aggs"] = AggregationRequestValidator().Validate

	return v
}()

func SecurityEventsAggregationRequestValidator() db.Validator {
	return DefaultSecurityEventsAggregationRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *SecurityEventsAggregationResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecurityEventsAggregationResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SecurityEventsAggregationResponse) DeepCopy() *SecurityEventsAggregationResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecurityEventsAggregationResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecurityEventsAggregationResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecurityEventsAggregationResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecurityEventsAggregationResponseValidator().Validate(ctx, m, opts...)
}

type ValidateSecurityEventsAggregationResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecurityEventsAggregationResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecurityEventsAggregationResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecurityEventsAggregationResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["total_hits"]; exists {

		vOpts := append(opts, db.WithValidateField("total_hits"))
		if err := fv(ctx, m.GetTotalHits(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecurityEventsAggregationResponseValidator = func() *ValidateSecurityEventsAggregationResponse {
	v := &ValidateSecurityEventsAggregationResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["aggs"] = ves_io_schema_log.LogAggregationDataValidator().Validate

	return v
}()

func SecurityEventsAggregationResponseValidator() db.Validator {
	return DefaultSecurityEventsAggregationResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *SecurityEventsCountRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecurityEventsCountRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SecurityEventsCountRequest) DeepCopy() *SecurityEventsCountRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecurityEventsCountRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecurityEventsCountRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecurityEventsCountRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecurityEventsCountRequestValidator().Validate(ctx, m, opts...)
}

type ValidateSecurityEventsCountRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecurityEventsCountRequest) StartTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_time")
	}

	return validatorFn, nil
}

func (v *ValidateSecurityEventsCountRequest) EndTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_time")
	}

	return validatorFn, nil
}

func (v *ValidateSecurityEventsCountRequest) StepValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for step")
	}

	return validatorFn, nil
}

func (v *ValidateSecurityEventsCountRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecurityEventsCountRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecurityEventsCountRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["group_by"]; exists {

		vOpts := append(opts, db.WithValidateField("group_by"))
		for idx, item := range m.GetGroupBy() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["label_filter"]; exists {

		vOpts := append(opts, db.WithValidateField("label_filter"))
		for idx, item := range m.GetLabelFilter() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["step"]; exists {

		vOpts := append(opts, db.WithValidateField("step"))
		if err := fv(ctx, m.GetStep(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecurityEventsCountRequestValidator = func() *ValidateSecurityEventsCountRequest {
	v := &ValidateSecurityEventsCountRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStartTime := v.StartTimeValidationRuleHandler
	rulesStartTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhStartTime(rulesStartTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityEventsCountRequest.start_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_time"] = vFn

	vrhEndTime := v.EndTimeValidationRuleHandler
	rulesEndTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhEndTime(rulesEndTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityEventsCountRequest.end_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_time"] = vFn

	vrhStep := v.StepValidationRuleHandler
	rulesStep := map[string]string{
		"ves.io.schema.rules.string.query_step": "true",
	}
	vFn, err = vrhStep(rulesStep)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityEventsCountRequest.step: %s", err)
		panic(errMsg)
	}
	v.FldValidators["step"] = vFn

	return v
}()

func SecurityEventsCountRequestValidator() db.Validator {
	return DefaultSecurityEventsCountRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *SecurityEventsCountResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecurityEventsCountResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SecurityEventsCountResponse) DeepCopy() *SecurityEventsCountResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecurityEventsCountResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecurityEventsCountResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecurityEventsCountResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecurityEventsCountResponseValidator().Validate(ctx, m, opts...)
}

type ValidateSecurityEventsCountResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecurityEventsCountResponse) StepValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for step")
	}

	return validatorFn, nil
}

func (v *ValidateSecurityEventsCountResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecurityEventsCountResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecurityEventsCountResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["data"]; exists {

		vOpts := append(opts, db.WithValidateField("data"))
		for idx, item := range m.GetData() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["step"]; exists {

		vOpts := append(opts, db.WithValidateField("step"))
		if err := fv(ctx, m.GetStep(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecurityEventsCountResponseValidator = func() *ValidateSecurityEventsCountResponse {
	v := &ValidateSecurityEventsCountResponse{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStep := v.StepValidationRuleHandler
	rulesStep := map[string]string{
		"ves.io.schema.rules.string.time_interval": "true",
	}
	vFn, err = vrhStep(rulesStep)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityEventsCountResponse.step: %s", err)
		panic(errMsg)
	}
	v.FldValidators["step"] = vFn

	return v
}()

func SecurityEventsCountResponseValidator() db.Validator {
	return DefaultSecurityEventsCountResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *SecurityEventsData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecurityEventsData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SecurityEventsData) DeepCopy() *SecurityEventsData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecurityEventsData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecurityEventsData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecurityEventsData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecurityEventsDataValidator().Validate(ctx, m, opts...)
}

type ValidateSecurityEventsData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecurityEventsData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecurityEventsData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecurityEventsData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["count"]; exists {

		vOpts := append(opts, db.WithValidateField("count"))
		if err := fv(ctx, m.GetCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["max_time"]; exists {

		vOpts := append(opts, db.WithValidateField("max_time"))
		if err := fv(ctx, m.GetMaxTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["min_time"]; exists {

		vOpts := append(opts, db.WithValidateField("min_time"))
		if err := fv(ctx, m.GetMinTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecurityEventsDataValidator = func() *ValidateSecurityEventsData {
	v := &ValidateSecurityEventsData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SecurityEventsDataValidator() db.Validator {
	return DefaultSecurityEventsDataValidator
}

// augmented methods on protoc/std generated struct

func (m *SecurityEventsRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecurityEventsRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SecurityEventsRequest) DeepCopy() *SecurityEventsRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecurityEventsRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecurityEventsRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecurityEventsRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecurityEventsRequestValidator().Validate(ctx, m, opts...)
}

type ValidateSecurityEventsRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecurityEventsRequest) StartTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_time")
	}

	return validatorFn, nil
}

func (v *ValidateSecurityEventsRequest) EndTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_time")
	}

	return validatorFn, nil
}

func (v *ValidateSecurityEventsRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecurityEventsRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecurityEventsRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["limit"]; exists {

		vOpts := append(opts, db.WithValidateField("limit"))
		if err := fv(ctx, m.GetLimit(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query"]; exists {

		vOpts := append(opts, db.WithValidateField("query"))
		if err := fv(ctx, m.GetQuery(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["scroll"]; exists {

		vOpts := append(opts, db.WithValidateField("scroll"))
		if err := fv(ctx, m.GetScroll(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sort"]; exists {

		vOpts := append(opts, db.WithValidateField("sort"))
		if err := fv(ctx, m.GetSort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sort_by"]; exists {

		vOpts := append(opts, db.WithValidateField("sort_by"))
		if err := fv(ctx, m.GetSortBy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecurityEventsRequestValidator = func() *ValidateSecurityEventsRequest {
	v := &ValidateSecurityEventsRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStartTime := v.StartTimeValidationRuleHandler
	rulesStartTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhStartTime(rulesStartTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityEventsRequest.start_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_time"] = vFn

	vrhEndTime := v.EndTimeValidationRuleHandler
	rulesEndTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhEndTime(rulesEndTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityEventsRequest.end_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_time"] = vFn

	v.FldValidators["aggs"] = AggregationRequestValidator().Validate

	return v
}()

func SecurityEventsRequestValidator() db.Validator {
	return DefaultSecurityEventsRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *SecurityEventsResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecurityEventsResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SecurityEventsResponse) DeepCopy() *SecurityEventsResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecurityEventsResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecurityEventsResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecurityEventsResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecurityEventsResponseValidator().Validate(ctx, m, opts...)
}

type ValidateSecurityEventsResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecurityEventsResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecurityEventsResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecurityEventsResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["events"]; exists {

		vOpts := append(opts, db.WithValidateField("events"))
		for idx, item := range m.GetEvents() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["scroll_id"]; exists {

		vOpts := append(opts, db.WithValidateField("scroll_id"))
		if err := fv(ctx, m.GetScrollId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["total_hits"]; exists {

		vOpts := append(opts, db.WithValidateField("total_hits"))
		if err := fv(ctx, m.GetTotalHits(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecurityEventsResponseValidator = func() *ValidateSecurityEventsResponse {
	v := &ValidateSecurityEventsResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["aggs"] = ves_io_schema_log.LogAggregationDataValidator().Validate

	return v
}()

func SecurityEventsResponseValidator() db.Validator {
	return DefaultSecurityEventsResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *SecurityEventsScrollRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecurityEventsScrollRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SecurityEventsScrollRequest) DeepCopy() *SecurityEventsScrollRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecurityEventsScrollRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecurityEventsScrollRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecurityEventsScrollRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecurityEventsScrollRequestValidator().Validate(ctx, m, opts...)
}

type ValidateSecurityEventsScrollRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecurityEventsScrollRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecurityEventsScrollRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecurityEventsScrollRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["scroll_id"]; exists {

		vOpts := append(opts, db.WithValidateField("scroll_id"))
		if err := fv(ctx, m.GetScrollId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecurityEventsScrollRequestValidator = func() *ValidateSecurityEventsScrollRequest {
	v := &ValidateSecurityEventsScrollRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SecurityEventsScrollRequestValidator() db.Validator {
	return DefaultSecurityEventsScrollRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *SecurityIncidentsAggregationRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecurityIncidentsAggregationRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SecurityIncidentsAggregationRequest) DeepCopy() *SecurityIncidentsAggregationRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecurityIncidentsAggregationRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecurityIncidentsAggregationRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecurityIncidentsAggregationRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecurityIncidentsAggregationRequestValidator().Validate(ctx, m, opts...)
}

type ValidateSecurityIncidentsAggregationRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecurityIncidentsAggregationRequest) StartTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_time")
	}

	return validatorFn, nil
}

func (v *ValidateSecurityIncidentsAggregationRequest) EndTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_time")
	}

	return validatorFn, nil
}

func (v *ValidateSecurityIncidentsAggregationRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecurityIncidentsAggregationRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecurityIncidentsAggregationRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query"]; exists {

		vOpts := append(opts, db.WithValidateField("query"))
		if err := fv(ctx, m.GetQuery(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecurityIncidentsAggregationRequestValidator = func() *ValidateSecurityIncidentsAggregationRequest {
	v := &ValidateSecurityIncidentsAggregationRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStartTime := v.StartTimeValidationRuleHandler
	rulesStartTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhStartTime(rulesStartTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityIncidentsAggregationRequest.start_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_time"] = vFn

	vrhEndTime := v.EndTimeValidationRuleHandler
	rulesEndTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhEndTime(rulesEndTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityIncidentsAggregationRequest.end_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_time"] = vFn

	v.FldValidators["aggs"] = ves_io_schema_app_security_incidents.AggregationRequestValidator().Validate

	return v
}()

func SecurityIncidentsAggregationRequestValidator() db.Validator {
	return DefaultSecurityIncidentsAggregationRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *SecurityIncidentsAggregationResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecurityIncidentsAggregationResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SecurityIncidentsAggregationResponse) DeepCopy() *SecurityIncidentsAggregationResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecurityIncidentsAggregationResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecurityIncidentsAggregationResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecurityIncidentsAggregationResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecurityIncidentsAggregationResponseValidator().Validate(ctx, m, opts...)
}

type ValidateSecurityIncidentsAggregationResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecurityIncidentsAggregationResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecurityIncidentsAggregationResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecurityIncidentsAggregationResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["total_hits"]; exists {

		vOpts := append(opts, db.WithValidateField("total_hits"))
		if err := fv(ctx, m.GetTotalHits(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecurityIncidentsAggregationResponseValidator = func() *ValidateSecurityIncidentsAggregationResponse {
	v := &ValidateSecurityIncidentsAggregationResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["aggs"] = ves_io_schema_log.LogAggregationDataValidator().Validate

	return v
}()

func SecurityIncidentsAggregationResponseValidator() db.Validator {
	return DefaultSecurityIncidentsAggregationResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *SecurityIncidentsRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecurityIncidentsRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SecurityIncidentsRequest) DeepCopy() *SecurityIncidentsRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecurityIncidentsRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecurityIncidentsRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecurityIncidentsRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecurityIncidentsRequestValidator().Validate(ctx, m, opts...)
}

type ValidateSecurityIncidentsRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecurityIncidentsRequest) StartTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_time")
	}

	return validatorFn, nil
}

func (v *ValidateSecurityIncidentsRequest) EndTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_time")
	}

	return validatorFn, nil
}

func (v *ValidateSecurityIncidentsRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecurityIncidentsRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecurityIncidentsRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["limit"]; exists {

		vOpts := append(opts, db.WithValidateField("limit"))
		if err := fv(ctx, m.GetLimit(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query"]; exists {

		vOpts := append(opts, db.WithValidateField("query"))
		if err := fv(ctx, m.GetQuery(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["scroll"]; exists {

		vOpts := append(opts, db.WithValidateField("scroll"))
		if err := fv(ctx, m.GetScroll(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sort"]; exists {

		vOpts := append(opts, db.WithValidateField("sort"))
		if err := fv(ctx, m.GetSort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sort_by"]; exists {

		vOpts := append(opts, db.WithValidateField("sort_by"))
		if err := fv(ctx, m.GetSortBy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecurityIncidentsRequestValidator = func() *ValidateSecurityIncidentsRequest {
	v := &ValidateSecurityIncidentsRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStartTime := v.StartTimeValidationRuleHandler
	rulesStartTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhStartTime(rulesStartTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityIncidentsRequest.start_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_time"] = vFn

	vrhEndTime := v.EndTimeValidationRuleHandler
	rulesEndTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhEndTime(rulesEndTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SecurityIncidentsRequest.end_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_time"] = vFn

	v.FldValidators["aggs"] = ves_io_schema_app_security_incidents.AggregationRequestValidator().Validate

	return v
}()

func SecurityIncidentsRequestValidator() db.Validator {
	return DefaultSecurityIncidentsRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *SecurityIncidentsResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecurityIncidentsResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SecurityIncidentsResponse) DeepCopy() *SecurityIncidentsResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecurityIncidentsResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecurityIncidentsResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecurityIncidentsResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecurityIncidentsResponseValidator().Validate(ctx, m, opts...)
}

type ValidateSecurityIncidentsResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecurityIncidentsResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecurityIncidentsResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecurityIncidentsResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["incidents"]; exists {

		vOpts := append(opts, db.WithValidateField("incidents"))
		for idx, item := range m.GetIncidents() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["scroll_id"]; exists {

		vOpts := append(opts, db.WithValidateField("scroll_id"))
		if err := fv(ctx, m.GetScrollId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["total_hits"]; exists {

		vOpts := append(opts, db.WithValidateField("total_hits"))
		if err := fv(ctx, m.GetTotalHits(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecurityIncidentsResponseValidator = func() *ValidateSecurityIncidentsResponse {
	v := &ValidateSecurityIncidentsResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["aggs"] = ves_io_schema_log.LogAggregationDataValidator().Validate

	return v
}()

func SecurityIncidentsResponseValidator() db.Validator {
	return DefaultSecurityIncidentsResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *SecurityIncidentsScrollRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecurityIncidentsScrollRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SecurityIncidentsScrollRequest) DeepCopy() *SecurityIncidentsScrollRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecurityIncidentsScrollRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecurityIncidentsScrollRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecurityIncidentsScrollRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecurityIncidentsScrollRequestValidator().Validate(ctx, m, opts...)
}

type ValidateSecurityIncidentsScrollRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecurityIncidentsScrollRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecurityIncidentsScrollRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecurityIncidentsScrollRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["scroll_id"]; exists {

		vOpts := append(opts, db.WithValidateField("scroll_id"))
		if err := fv(ctx, m.GetScrollId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecurityIncidentsScrollRequestValidator = func() *ValidateSecurityIncidentsScrollRequest {
	v := &ValidateSecurityIncidentsScrollRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SecurityIncidentsScrollRequestValidator() db.Validator {
	return DefaultSecurityIncidentsScrollRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *SuspiciousUserLogsAggregationRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SuspiciousUserLogsAggregationRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SuspiciousUserLogsAggregationRequest) DeepCopy() *SuspiciousUserLogsAggregationRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SuspiciousUserLogsAggregationRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SuspiciousUserLogsAggregationRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SuspiciousUserLogsAggregationRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SuspiciousUserLogsAggregationRequestValidator().Validate(ctx, m, opts...)
}

type ValidateSuspiciousUserLogsAggregationRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSuspiciousUserLogsAggregationRequest) StartTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_time")
	}

	return validatorFn, nil
}

func (v *ValidateSuspiciousUserLogsAggregationRequest) EndTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_time")
	}

	return validatorFn, nil
}

func (v *ValidateSuspiciousUserLogsAggregationRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SuspiciousUserLogsAggregationRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SuspiciousUserLogsAggregationRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query"]; exists {

		vOpts := append(opts, db.WithValidateField("query"))
		if err := fv(ctx, m.GetQuery(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSuspiciousUserLogsAggregationRequestValidator = func() *ValidateSuspiciousUserLogsAggregationRequest {
	v := &ValidateSuspiciousUserLogsAggregationRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStartTime := v.StartTimeValidationRuleHandler
	rulesStartTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhStartTime(rulesStartTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SuspiciousUserLogsAggregationRequest.start_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_time"] = vFn

	vrhEndTime := v.EndTimeValidationRuleHandler
	rulesEndTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhEndTime(rulesEndTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SuspiciousUserLogsAggregationRequest.end_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_time"] = vFn

	v.FldValidators["aggs"] = ves_io_schema_app_security_suspicious_user_log.AggregationRequestValidator().Validate

	return v
}()

func SuspiciousUserLogsAggregationRequestValidator() db.Validator {
	return DefaultSuspiciousUserLogsAggregationRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *SuspiciousUserLogsAggregationResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SuspiciousUserLogsAggregationResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SuspiciousUserLogsAggregationResponse) DeepCopy() *SuspiciousUserLogsAggregationResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SuspiciousUserLogsAggregationResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SuspiciousUserLogsAggregationResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SuspiciousUserLogsAggregationResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SuspiciousUserLogsAggregationResponseValidator().Validate(ctx, m, opts...)
}

type ValidateSuspiciousUserLogsAggregationResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSuspiciousUserLogsAggregationResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SuspiciousUserLogsAggregationResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SuspiciousUserLogsAggregationResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["total_hits"]; exists {

		vOpts := append(opts, db.WithValidateField("total_hits"))
		if err := fv(ctx, m.GetTotalHits(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSuspiciousUserLogsAggregationResponseValidator = func() *ValidateSuspiciousUserLogsAggregationResponse {
	v := &ValidateSuspiciousUserLogsAggregationResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["aggs"] = ves_io_schema_log.LogAggregationDataValidator().Validate

	return v
}()

func SuspiciousUserLogsAggregationResponseValidator() db.Validator {
	return DefaultSuspiciousUserLogsAggregationResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *SuspiciousUserLogsRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SuspiciousUserLogsRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SuspiciousUserLogsRequest) DeepCopy() *SuspiciousUserLogsRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SuspiciousUserLogsRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SuspiciousUserLogsRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SuspiciousUserLogsRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SuspiciousUserLogsRequestValidator().Validate(ctx, m, opts...)
}

type ValidateSuspiciousUserLogsRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSuspiciousUserLogsRequest) StartTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_time")
	}

	return validatorFn, nil
}

func (v *ValidateSuspiciousUserLogsRequest) EndTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_time")
	}

	return validatorFn, nil
}

func (v *ValidateSuspiciousUserLogsRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SuspiciousUserLogsRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SuspiciousUserLogsRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["limit"]; exists {

		vOpts := append(opts, db.WithValidateField("limit"))
		if err := fv(ctx, m.GetLimit(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query"]; exists {

		vOpts := append(opts, db.WithValidateField("query"))
		if err := fv(ctx, m.GetQuery(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["scroll"]; exists {

		vOpts := append(opts, db.WithValidateField("scroll"))
		if err := fv(ctx, m.GetScroll(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sort"]; exists {

		vOpts := append(opts, db.WithValidateField("sort"))
		if err := fv(ctx, m.GetSort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sort_by"]; exists {

		vOpts := append(opts, db.WithValidateField("sort_by"))
		if err := fv(ctx, m.GetSortBy(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSuspiciousUserLogsRequestValidator = func() *ValidateSuspiciousUserLogsRequest {
	v := &ValidateSuspiciousUserLogsRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStartTime := v.StartTimeValidationRuleHandler
	rulesStartTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhStartTime(rulesStartTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SuspiciousUserLogsRequest.start_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_time"] = vFn

	vrhEndTime := v.EndTimeValidationRuleHandler
	rulesEndTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhEndTime(rulesEndTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SuspiciousUserLogsRequest.end_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_time"] = vFn

	v.FldValidators["aggs"] = ves_io_schema_app_security_suspicious_user_log.AggregationRequestValidator().Validate

	return v
}()

func SuspiciousUserLogsRequestValidator() db.Validator {
	return DefaultSuspiciousUserLogsRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *SuspiciousUserLogsResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SuspiciousUserLogsResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SuspiciousUserLogsResponse) DeepCopy() *SuspiciousUserLogsResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SuspiciousUserLogsResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SuspiciousUserLogsResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SuspiciousUserLogsResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SuspiciousUserLogsResponseValidator().Validate(ctx, m, opts...)
}

type ValidateSuspiciousUserLogsResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSuspiciousUserLogsResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SuspiciousUserLogsResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SuspiciousUserLogsResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["aggs"]; exists {

		vOpts := append(opts, db.WithValidateField("aggs"))
		for key, value := range m.GetAggs() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["logs"]; exists {

		vOpts := append(opts, db.WithValidateField("logs"))
		for idx, item := range m.GetLogs() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["scroll_id"]; exists {

		vOpts := append(opts, db.WithValidateField("scroll_id"))
		if err := fv(ctx, m.GetScrollId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["total_hits"]; exists {

		vOpts := append(opts, db.WithValidateField("total_hits"))
		if err := fv(ctx, m.GetTotalHits(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSuspiciousUserLogsResponseValidator = func() *ValidateSuspiciousUserLogsResponse {
	v := &ValidateSuspiciousUserLogsResponse{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["aggs"] = ves_io_schema_log.LogAggregationDataValidator().Validate

	return v
}()

func SuspiciousUserLogsResponseValidator() db.Validator {
	return DefaultSuspiciousUserLogsResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *SuspiciousUserLogsScrollRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SuspiciousUserLogsScrollRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SuspiciousUserLogsScrollRequest) DeepCopy() *SuspiciousUserLogsScrollRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SuspiciousUserLogsScrollRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SuspiciousUserLogsScrollRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SuspiciousUserLogsScrollRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SuspiciousUserLogsScrollRequestValidator().Validate(ctx, m, opts...)
}

type ValidateSuspiciousUserLogsScrollRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSuspiciousUserLogsScrollRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SuspiciousUserLogsScrollRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SuspiciousUserLogsScrollRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["scroll_id"]; exists {

		vOpts := append(opts, db.WithValidateField("scroll_id"))
		if err := fv(ctx, m.GetScrollId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSuspiciousUserLogsScrollRequestValidator = func() *ValidateSuspiciousUserLogsScrollRequest {
	v := &ValidateSuspiciousUserLogsScrollRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SuspiciousUserLogsScrollRequestValidator() db.Validator {
	return DefaultSuspiciousUserLogsScrollRequestValidator
}
