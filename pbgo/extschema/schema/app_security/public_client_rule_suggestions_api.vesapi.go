// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package app_security

import (
	"bytes"
	"context"
	"fmt"
	io "io"
	"net/http"
	"strings"

	"github.com/gogo/protobuf/proto"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"google.golang.org/grpc"

	"gopkg.volterra.us/stdlib/client"
	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/errors"
	"gopkg.volterra.us/stdlib/server"
	"gopkg.volterra.us/stdlib/svcfw"
)

var (
	_ = fmt.Sprintf("dummy for fmt import use")
)

// Create AppSecurityClientRuleAPI GRPC Client satisfying server.CustomClient
type AppSecurityClientRuleAPIGrpcClient struct {
	conn       *grpc.ClientConn
	grpcClient AppSecurityClientRuleAPIClient
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error)
}

func (c *AppSecurityClientRuleAPIGrpcClient) doRPCGetSuggestedBlockClientRule(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetSuggestedBlockClientRuleReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.GetSuggestedBlockClientRuleReq", yamlReq)
	}
	rsp, err := c.grpcClient.GetSuggestedBlockClientRule(ctx, req, opts...)
	return rsp, err
}

func (c *AppSecurityClientRuleAPIGrpcClient) doRPCGetSuggestedBlockClientRuleForCDN(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetSuggestedBlockClientRuleReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.GetSuggestedBlockClientRuleReq", yamlReq)
	}
	rsp, err := c.grpcClient.GetSuggestedBlockClientRuleForCDN(ctx, req, opts...)
	return rsp, err
}

func (c *AppSecurityClientRuleAPIGrpcClient) doRPCGetSuggestedDDoSMitigationRule(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetSuggestedDDoSMitigtionRuleReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.GetSuggestedDDoSMitigtionRuleReq", yamlReq)
	}
	rsp, err := c.grpcClient.GetSuggestedDDoSMitigationRule(ctx, req, opts...)
	return rsp, err
}

func (c *AppSecurityClientRuleAPIGrpcClient) doRPCGetSuggestedDDoSMitigationRuleForCDN(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetSuggestedDDoSMitigtionRuleReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.GetSuggestedDDoSMitigtionRuleReq", yamlReq)
	}
	rsp, err := c.grpcClient.GetSuggestedDDoSMitigationRuleForCDN(ctx, req, opts...)
	return rsp, err
}

func (c *AppSecurityClientRuleAPIGrpcClient) doRPCGetSuggestedTrustClientRule(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetSuggestedTrustClientRuleReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.GetSuggestedTrustClientRuleReq", yamlReq)
	}
	rsp, err := c.grpcClient.GetSuggestedTrustClientRule(ctx, req, opts...)
	return rsp, err
}

func (c *AppSecurityClientRuleAPIGrpcClient) doRPCGetSuggestedTrustClientRuleForCDN(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetSuggestedTrustClientRuleReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.GetSuggestedTrustClientRuleReq", yamlReq)
	}
	rsp, err := c.grpcClient.GetSuggestedTrustClientRuleForCDN(ctx, req, opts...)
	return rsp, err
}

func (c *AppSecurityClientRuleAPIGrpcClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	if cco.YAMLReq == "" {
		return nil, fmt.Errorf("Error, empty request body")
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := rpcFn(ctx, cco.YAMLReq, cco.GrpcCallOpts...)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using GRPC")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func NewAppSecurityClientRuleAPIGrpcClient(cc *grpc.ClientConn) server.CustomClient {
	ccl := &AppSecurityClientRuleAPIGrpcClient{
		conn:       cc,
		grpcClient: NewAppSecurityClientRuleAPIClient(cc),
	}
	rpcFns := make(map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error))
	rpcFns["GetSuggestedBlockClientRule"] = ccl.doRPCGetSuggestedBlockClientRule

	rpcFns["GetSuggestedBlockClientRuleForCDN"] = ccl.doRPCGetSuggestedBlockClientRuleForCDN

	rpcFns["GetSuggestedDDoSMitigationRule"] = ccl.doRPCGetSuggestedDDoSMitigationRule

	rpcFns["GetSuggestedDDoSMitigationRuleForCDN"] = ccl.doRPCGetSuggestedDDoSMitigationRuleForCDN

	rpcFns["GetSuggestedTrustClientRule"] = ccl.doRPCGetSuggestedTrustClientRule

	rpcFns["GetSuggestedTrustClientRuleForCDN"] = ccl.doRPCGetSuggestedTrustClientRuleForCDN

	ccl.rpcFns = rpcFns

	return ccl
}

// Create AppSecurityClientRuleAPI REST Client satisfying server.CustomClient
type AppSecurityClientRuleAPIRestClient struct {
	baseURL string
	client  http.Client
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error)
}

func (c *AppSecurityClientRuleAPIRestClient) doRPCGetSuggestedBlockClientRule(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetSuggestedBlockClientRuleReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.GetSuggestedBlockClientRuleReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("as_description", fmt.Sprintf("%v", req.AsDescription))
		q.Add("as_number", fmt.Sprintf("%v", req.AsNumber))
		q.Add("ip_prefix", fmt.Sprintf("%v", req.IpPrefix))
		q.Add("name", fmt.Sprintf("%v", req.Name))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("user_id", fmt.Sprintf("%v", req.UserId))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetSuggestedBlockClientRuleRsp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.app_security.GetSuggestedBlockClientRuleRsp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *AppSecurityClientRuleAPIRestClient) doRPCGetSuggestedBlockClientRuleForCDN(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetSuggestedBlockClientRuleReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.GetSuggestedBlockClientRuleReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("as_description", fmt.Sprintf("%v", req.AsDescription))
		q.Add("as_number", fmt.Sprintf("%v", req.AsNumber))
		q.Add("ip_prefix", fmt.Sprintf("%v", req.IpPrefix))
		q.Add("name", fmt.Sprintf("%v", req.Name))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("user_id", fmt.Sprintf("%v", req.UserId))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetSuggestedBlockClientRuleRsp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.app_security.GetSuggestedBlockClientRuleRsp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *AppSecurityClientRuleAPIRestClient) doRPCGetSuggestedDDoSMitigationRule(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetSuggestedDDoSMitigtionRuleReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.GetSuggestedDDoSMitigtionRuleReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("asn_list", fmt.Sprintf("%v", req.AsnList))
		for _, item := range req.CountryList {
			q.Add("country_list", fmt.Sprintf("%v", item))
		}
		q.Add("ip_prefix_list", fmt.Sprintf("%v", req.IpPrefixList))
		q.Add("ja4_tls_fingerprint_matcher", fmt.Sprintf("%v", req.Ja4TlsFingerprintMatcher))
		q.Add("name", fmt.Sprintf("%v", req.Name))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("tls_fingerprint_matcher", fmt.Sprintf("%v", req.TlsFingerprintMatcher))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetSuggestedDDoSMitigtionRuleRsp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.app_security.GetSuggestedDDoSMitigtionRuleRsp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *AppSecurityClientRuleAPIRestClient) doRPCGetSuggestedDDoSMitigationRuleForCDN(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetSuggestedDDoSMitigtionRuleReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.GetSuggestedDDoSMitigtionRuleReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("asn_list", fmt.Sprintf("%v", req.AsnList))
		for _, item := range req.CountryList {
			q.Add("country_list", fmt.Sprintf("%v", item))
		}
		q.Add("ip_prefix_list", fmt.Sprintf("%v", req.IpPrefixList))
		q.Add("ja4_tls_fingerprint_matcher", fmt.Sprintf("%v", req.Ja4TlsFingerprintMatcher))
		q.Add("name", fmt.Sprintf("%v", req.Name))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("tls_fingerprint_matcher", fmt.Sprintf("%v", req.TlsFingerprintMatcher))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetSuggestedDDoSMitigtionRuleRsp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.app_security.GetSuggestedDDoSMitigtionRuleRsp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *AppSecurityClientRuleAPIRestClient) doRPCGetSuggestedTrustClientRule(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetSuggestedTrustClientRuleReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.GetSuggestedTrustClientRuleReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("as_description", fmt.Sprintf("%v", req.AsDescription))
		q.Add("as_number", fmt.Sprintf("%v", req.AsNumber))
		q.Add("ip_prefix", fmt.Sprintf("%v", req.IpPrefix))
		q.Add("ip_reputation", fmt.Sprintf("%v", req.IpReputation))
		q.Add("name", fmt.Sprintf("%v", req.Name))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("sec_event_name", fmt.Sprintf("%v", req.SecEventName))
		for _, item := range req.SecEventTypes {
			q.Add("sec_event_types", fmt.Sprintf("%v", item))
		}
		q.Add("threat_mesh", fmt.Sprintf("%v", req.ThreatMesh))
		q.Add("user_id", fmt.Sprintf("%v", req.UserId))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetSuggestedTrustClientRuleRsp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.app_security.GetSuggestedTrustClientRuleRsp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *AppSecurityClientRuleAPIRestClient) doRPCGetSuggestedTrustClientRuleForCDN(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetSuggestedTrustClientRuleReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.GetSuggestedTrustClientRuleReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("as_description", fmt.Sprintf("%v", req.AsDescription))
		q.Add("as_number", fmt.Sprintf("%v", req.AsNumber))
		q.Add("ip_prefix", fmt.Sprintf("%v", req.IpPrefix))
		q.Add("ip_reputation", fmt.Sprintf("%v", req.IpReputation))
		q.Add("name", fmt.Sprintf("%v", req.Name))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("sec_event_name", fmt.Sprintf("%v", req.SecEventName))
		for _, item := range req.SecEventTypes {
			q.Add("sec_event_types", fmt.Sprintf("%v", item))
		}
		q.Add("threat_mesh", fmt.Sprintf("%v", req.ThreatMesh))
		q.Add("user_id", fmt.Sprintf("%v", req.UserId))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetSuggestedTrustClientRuleRsp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.app_security.GetSuggestedTrustClientRuleRsp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *AppSecurityClientRuleAPIRestClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	rsp, err := rpcFn(ctx, cco)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using Rest")
	}
	return rsp, nil
}

func NewAppSecurityClientRuleAPIRestClient(baseURL string, hc http.Client) server.CustomClient {
	ccl := &AppSecurityClientRuleAPIRestClient{
		baseURL: baseURL,
		client:  hc,
	}

	rpcFns := make(map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error))
	rpcFns["GetSuggestedBlockClientRule"] = ccl.doRPCGetSuggestedBlockClientRule

	rpcFns["GetSuggestedBlockClientRuleForCDN"] = ccl.doRPCGetSuggestedBlockClientRuleForCDN

	rpcFns["GetSuggestedDDoSMitigationRule"] = ccl.doRPCGetSuggestedDDoSMitigationRule

	rpcFns["GetSuggestedDDoSMitigationRuleForCDN"] = ccl.doRPCGetSuggestedDDoSMitigationRuleForCDN

	rpcFns["GetSuggestedTrustClientRule"] = ccl.doRPCGetSuggestedTrustClientRule

	rpcFns["GetSuggestedTrustClientRuleForCDN"] = ccl.doRPCGetSuggestedTrustClientRuleForCDN

	ccl.rpcFns = rpcFns

	return ccl
}

// Create appSecurityClientRuleAPIInprocClient

// INPROC Client (satisfying AppSecurityClientRuleAPIClient interface)
type appSecurityClientRuleAPIInprocClient struct {
	AppSecurityClientRuleAPIServer
}

func (c *appSecurityClientRuleAPIInprocClient) GetSuggestedBlockClientRule(ctx context.Context, in *GetSuggestedBlockClientRuleReq, opts ...grpc.CallOption) (*GetSuggestedBlockClientRuleRsp, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.app_security.AppSecurityClientRuleAPI.GetSuggestedBlockClientRule")
	return c.AppSecurityClientRuleAPIServer.GetSuggestedBlockClientRule(ctx, in)
}
func (c *appSecurityClientRuleAPIInprocClient) GetSuggestedBlockClientRuleForCDN(ctx context.Context, in *GetSuggestedBlockClientRuleReq, opts ...grpc.CallOption) (*GetSuggestedBlockClientRuleRsp, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.app_security.AppSecurityClientRuleAPI.GetSuggestedBlockClientRuleForCDN")
	return c.AppSecurityClientRuleAPIServer.GetSuggestedBlockClientRuleForCDN(ctx, in)
}
func (c *appSecurityClientRuleAPIInprocClient) GetSuggestedDDoSMitigationRule(ctx context.Context, in *GetSuggestedDDoSMitigtionRuleReq, opts ...grpc.CallOption) (*GetSuggestedDDoSMitigtionRuleRsp, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.app_security.AppSecurityClientRuleAPI.GetSuggestedDDoSMitigationRule")
	return c.AppSecurityClientRuleAPIServer.GetSuggestedDDoSMitigationRule(ctx, in)
}
func (c *appSecurityClientRuleAPIInprocClient) GetSuggestedDDoSMitigationRuleForCDN(ctx context.Context, in *GetSuggestedDDoSMitigtionRuleReq, opts ...grpc.CallOption) (*GetSuggestedDDoSMitigtionRuleRsp, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.app_security.AppSecurityClientRuleAPI.GetSuggestedDDoSMitigationRuleForCDN")
	return c.AppSecurityClientRuleAPIServer.GetSuggestedDDoSMitigationRuleForCDN(ctx, in)
}
func (c *appSecurityClientRuleAPIInprocClient) GetSuggestedTrustClientRule(ctx context.Context, in *GetSuggestedTrustClientRuleReq, opts ...grpc.CallOption) (*GetSuggestedTrustClientRuleRsp, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.app_security.AppSecurityClientRuleAPI.GetSuggestedTrustClientRule")
	return c.AppSecurityClientRuleAPIServer.GetSuggestedTrustClientRule(ctx, in)
}
func (c *appSecurityClientRuleAPIInprocClient) GetSuggestedTrustClientRuleForCDN(ctx context.Context, in *GetSuggestedTrustClientRuleReq, opts ...grpc.CallOption) (*GetSuggestedTrustClientRuleRsp, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.app_security.AppSecurityClientRuleAPI.GetSuggestedTrustClientRuleForCDN")
	return c.AppSecurityClientRuleAPIServer.GetSuggestedTrustClientRuleForCDN(ctx, in)
}

func NewAppSecurityClientRuleAPIInprocClient(svc svcfw.Service) AppSecurityClientRuleAPIClient {
	return &appSecurityClientRuleAPIInprocClient{AppSecurityClientRuleAPIServer: NewAppSecurityClientRuleAPIServer(svc)}
}

// RegisterGwAppSecurityClientRuleAPIHandler registers with grpc-gw with an inproc-client backing so that
// rest to grpc happens without a grpc.Dial (thus avoiding additional certs for mTLS)
func RegisterGwAppSecurityClientRuleAPIHandler(ctx context.Context, mux *runtime.ServeMux, svc interface{}) error {
	s, ok := svc.(svcfw.Service)
	if !ok {
		return fmt.Errorf("svc is not svcfw.Service")
	}
	return RegisterAppSecurityClientRuleAPIHandlerClient(ctx, mux, NewAppSecurityClientRuleAPIInprocClient(s))
}

// Create appSecurityClientRuleAPISrv

// SERVER (satisfying AppSecurityClientRuleAPIServer interface)
type appSecurityClientRuleAPISrv struct {
	svc svcfw.Service
}

func (s *appSecurityClientRuleAPISrv) GetSuggestedBlockClientRule(ctx context.Context, in *GetSuggestedBlockClientRuleReq) (*GetSuggestedBlockClientRuleRsp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.app_security.AppSecurityClientRuleAPI")
	cah, ok := ah.(AppSecurityClientRuleAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *AppSecurityClientRuleAPIServer", ah)
	}

	var (
		rsp *GetSuggestedBlockClientRuleRsp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.app_security.GetSuggestedBlockClientRuleReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'AppSecurityClientRuleAPI.GetSuggestedBlockClientRule' operation on 'app_security'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.app_security.AppSecurityClientRuleAPI.GetSuggestedBlockClientRule"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetSuggestedBlockClientRule(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.app_security.GetSuggestedBlockClientRuleRsp", rsp)...)

	return rsp, nil
}
func (s *appSecurityClientRuleAPISrv) GetSuggestedBlockClientRuleForCDN(ctx context.Context, in *GetSuggestedBlockClientRuleReq) (*GetSuggestedBlockClientRuleRsp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.app_security.AppSecurityClientRuleAPI")
	cah, ok := ah.(AppSecurityClientRuleAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *AppSecurityClientRuleAPIServer", ah)
	}

	var (
		rsp *GetSuggestedBlockClientRuleRsp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.app_security.GetSuggestedBlockClientRuleReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'AppSecurityClientRuleAPI.GetSuggestedBlockClientRuleForCDN' operation on 'app_security'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.app_security.AppSecurityClientRuleAPI.GetSuggestedBlockClientRuleForCDN"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetSuggestedBlockClientRuleForCDN(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.app_security.GetSuggestedBlockClientRuleRsp", rsp)...)

	return rsp, nil
}
func (s *appSecurityClientRuleAPISrv) GetSuggestedDDoSMitigationRule(ctx context.Context, in *GetSuggestedDDoSMitigtionRuleReq) (*GetSuggestedDDoSMitigtionRuleRsp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.app_security.AppSecurityClientRuleAPI")
	cah, ok := ah.(AppSecurityClientRuleAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *AppSecurityClientRuleAPIServer", ah)
	}

	var (
		rsp *GetSuggestedDDoSMitigtionRuleRsp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.app_security.GetSuggestedDDoSMitigtionRuleReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'AppSecurityClientRuleAPI.GetSuggestedDDoSMitigationRule' operation on 'app_security'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.app_security.AppSecurityClientRuleAPI.GetSuggestedDDoSMitigationRule"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetSuggestedDDoSMitigationRule(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.app_security.GetSuggestedDDoSMitigtionRuleRsp", rsp)...)

	return rsp, nil
}
func (s *appSecurityClientRuleAPISrv) GetSuggestedDDoSMitigationRuleForCDN(ctx context.Context, in *GetSuggestedDDoSMitigtionRuleReq) (*GetSuggestedDDoSMitigtionRuleRsp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.app_security.AppSecurityClientRuleAPI")
	cah, ok := ah.(AppSecurityClientRuleAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *AppSecurityClientRuleAPIServer", ah)
	}

	var (
		rsp *GetSuggestedDDoSMitigtionRuleRsp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.app_security.GetSuggestedDDoSMitigtionRuleReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'AppSecurityClientRuleAPI.GetSuggestedDDoSMitigationRuleForCDN' operation on 'app_security'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.app_security.AppSecurityClientRuleAPI.GetSuggestedDDoSMitigationRuleForCDN"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetSuggestedDDoSMitigationRuleForCDN(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.app_security.GetSuggestedDDoSMitigtionRuleRsp", rsp)...)

	return rsp, nil
}
func (s *appSecurityClientRuleAPISrv) GetSuggestedTrustClientRule(ctx context.Context, in *GetSuggestedTrustClientRuleReq) (*GetSuggestedTrustClientRuleRsp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.app_security.AppSecurityClientRuleAPI")
	cah, ok := ah.(AppSecurityClientRuleAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *AppSecurityClientRuleAPIServer", ah)
	}

	var (
		rsp *GetSuggestedTrustClientRuleRsp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.app_security.GetSuggestedTrustClientRuleReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'AppSecurityClientRuleAPI.GetSuggestedTrustClientRule' operation on 'app_security'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.app_security.AppSecurityClientRuleAPI.GetSuggestedTrustClientRule"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetSuggestedTrustClientRule(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.app_security.GetSuggestedTrustClientRuleRsp", rsp)...)

	return rsp, nil
}
func (s *appSecurityClientRuleAPISrv) GetSuggestedTrustClientRuleForCDN(ctx context.Context, in *GetSuggestedTrustClientRuleReq) (*GetSuggestedTrustClientRuleRsp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.app_security.AppSecurityClientRuleAPI")
	cah, ok := ah.(AppSecurityClientRuleAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *AppSecurityClientRuleAPIServer", ah)
	}

	var (
		rsp *GetSuggestedTrustClientRuleRsp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.app_security.GetSuggestedTrustClientRuleReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'AppSecurityClientRuleAPI.GetSuggestedTrustClientRuleForCDN' operation on 'app_security'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.app_security.AppSecurityClientRuleAPI.GetSuggestedTrustClientRuleForCDN"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetSuggestedTrustClientRuleForCDN(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.app_security.GetSuggestedTrustClientRuleRsp", rsp)...)

	return rsp, nil
}

func NewAppSecurityClientRuleAPIServer(svc svcfw.Service) AppSecurityClientRuleAPIServer {
	return &appSecurityClientRuleAPISrv{svc: svc}
}

var AppSecurityClientRuleAPISwaggerJSON string = `{
    "swagger": "2.0",
    "info": {
        "title": "Application Security Monitoring APIs",
        "description": "APIs to get application security events and metrics on virtual-host basis.\nSecurity events may be generated for following reasons:\n1. Service policy hits with action \"deny\"\n2. Rate limiting\n3. Javascript challenge failure",
        "version": "version not set"
    },
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "tags": [],
    "paths": {
        "/public/namespaces/{namespace}/cdn_loadbalancers/{name}/block_client/suggestion": {
            "post": {
                "summary": "Suggest block client rule",
                "description": "Suggest blocking SimpleClientSrcRule for a given IP/ASN",
                "operationId": "ves.io.schema.app_security.AppSecurityClientRuleAPI.GetSuggestedBlockClientRuleForCDN",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securityGetSuggestedBlockClientRuleRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"shared\"\nNamespace of the App type for current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "name",
                        "description": "Name\n\nx-example: \"ves-io-frontend\"\nHTTP load balancer for which this WAF exclusion will be applied",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "HTTP Load Balancer Name"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/app_securityGetSuggestedBlockClientRuleReq"
                        }
                    }
                ],
                "tags": [
                    "AppSecurityClientRuleAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-app_security-appsecurityclientruleapi-getsuggestedblockclientruleforcdn"
                },
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityClientRuleAPI.GetSuggestedBlockClientRuleForCDN"
            },
            "x-displayname": "Application Security Client Rule APIs",
            "x-ves-proto-service": "ves.io.schema.app_security.AppSecurityClientRuleAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/cdn_loadbalancers/{name}/ddos_mitigation/suggestion": {
            "post": {
                "summary": "Suggest CDN DDoS Mitigation rule",
                "description": "Suggest DDoSMitigatonRule to mitigate a given IP/ASN/Region/TLS",
                "operationId": "ves.io.schema.app_security.AppSecurityClientRuleAPI.GetSuggestedDDoSMitigationRuleForCDN",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securityGetSuggestedDDoSMitigtionRuleRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"shared\"\nNamespace of the App type for current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "name",
                        "description": "Name\n\nx-example: \"ves-io-frontend\"\nload balancer for which this WAF exclusion will be applied",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Load Balancer Name"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/app_securityGetSuggestedDDoSMitigtionRuleReq"
                        }
                    }
                ],
                "tags": [
                    "AppSecurityClientRuleAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-app_security-appsecurityclientruleapi-getsuggestedddosmitigationruleforcdn"
                },
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityClientRuleAPI.GetSuggestedDDoSMitigationRuleForCDN"
            },
            "x-displayname": "Application Security Client Rule APIs",
            "x-ves-proto-service": "ves.io.schema.app_security.AppSecurityClientRuleAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/cdn_loadbalancers/{name}/trust_client/suggestion": {
            "post": {
                "summary": "Suggest trust client rule",
                "description": "Suggest SimpleClientSrcRule to trust a given IP/ASN",
                "operationId": "ves.io.schema.app_security.AppSecurityClientRuleAPI.GetSuggestedTrustClientRuleForCDN",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securityGetSuggestedTrustClientRuleRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"shared\"\nNamespace of the App type for current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "name",
                        "description": "Name\n\nx-example: \"ves-io-frontend\"\nHTTP load balancer for which this client blocking rule will be applied",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "HTTP Load Balancer Name"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/app_securityGetSuggestedTrustClientRuleReq"
                        }
                    }
                ],
                "tags": [
                    "AppSecurityClientRuleAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-app_security-appsecurityclientruleapi-getsuggestedtrustclientruleforcdn"
                },
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityClientRuleAPI.GetSuggestedTrustClientRuleForCDN"
            },
            "x-displayname": "Application Security Client Rule APIs",
            "x-ves-proto-service": "ves.io.schema.app_security.AppSecurityClientRuleAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/http_loadbalancers/{name}/block_client/suggestion": {
            "post": {
                "summary": "Suggest block client rule",
                "description": "Suggest blocking SimpleClientSrcRule for a given IP/ASN",
                "operationId": "ves.io.schema.app_security.AppSecurityClientRuleAPI.GetSuggestedBlockClientRule",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securityGetSuggestedBlockClientRuleRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"shared\"\nNamespace of the App type for current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "name",
                        "description": "Name\n\nx-example: \"ves-io-frontend\"\nHTTP load balancer for which this WAF exclusion will be applied",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "HTTP Load Balancer Name"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/app_securityGetSuggestedBlockClientRuleReq"
                        }
                    }
                ],
                "tags": [
                    "AppSecurityClientRuleAPI"
                ],
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityClientRuleAPI.GetSuggestedBlockClientRule"
            },
            "x-displayname": "Application Security Client Rule APIs",
            "x-ves-proto-service": "ves.io.schema.app_security.AppSecurityClientRuleAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/http_loadbalancers/{name}/ddos_mitigation/suggestion": {
            "post": {
                "summary": "Suggest DDoS Mitigation rule",
                "description": "Suggest DDoSMitigatonRule to mitigate a given IP/ASN/Region/TLS",
                "operationId": "ves.io.schema.app_security.AppSecurityClientRuleAPI.GetSuggestedDDoSMitigationRule",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securityGetSuggestedDDoSMitigtionRuleRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"shared\"\nNamespace of the App type for current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "name",
                        "description": "Name\n\nx-example: \"ves-io-frontend\"\nload balancer for which this WAF exclusion will be applied",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Load Balancer Name"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/app_securityGetSuggestedDDoSMitigtionRuleReq"
                        }
                    }
                ],
                "tags": [
                    "AppSecurityClientRuleAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-app_security-appsecurityclientruleapi-getsuggestedddosmitigationrule"
                },
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityClientRuleAPI.GetSuggestedDDoSMitigationRule"
            },
            "x-displayname": "Application Security Client Rule APIs",
            "x-ves-proto-service": "ves.io.schema.app_security.AppSecurityClientRuleAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/http_loadbalancers/{name}/trust_client/suggestion": {
            "post": {
                "summary": "Suggest trust client rule",
                "description": "Suggest SimpleClientSrcRule to trust a given IP/ASN",
                "operationId": "ves.io.schema.app_security.AppSecurityClientRuleAPI.GetSuggestedTrustClientRule",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securityGetSuggestedTrustClientRuleRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"shared\"\nNamespace of the App type for current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "name",
                        "description": "Name\n\nx-example: \"ves-io-frontend\"\nHTTP load balancer for which this client blocking rule will be applied",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "HTTP Load Balancer Name"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/app_securityGetSuggestedTrustClientRuleReq"
                        }
                    }
                ],
                "tags": [
                    "AppSecurityClientRuleAPI"
                ],
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityClientRuleAPI.GetSuggestedTrustClientRule"
            },
            "x-displayname": "Application Security Client Rule APIs",
            "x-ves-proto-service": "ves.io.schema.app_security.AppSecurityClientRuleAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        }
    },
    "definitions": {
        "app_securityGetSuggestedBlockClientRuleReq": {
            "type": "object",
            "description": "Get suggested blocking SimpleClientSrcRule for a given IP/ASN",
            "title": "GetSuggestedBlockClientRuleReq",
            "x-displayname": "Get Suggested Block Client Rule Request",
            "x-ves-proto-message": "ves.io.schema.app_security.GetSuggestedBlockClientRuleReq",
            "properties": {
                "as_description": {
                    "type": "string",
                    "description": " AS description\n\nExample: - \"as-description\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "Description",
                    "maxLength": 256,
                    "x-displayname": "AS Description",
                    "x-ves-example": "as-description",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                },
                "as_number": {
                    "type": "integer",
                    "description": " RFC 6793 defined 4-byte AS number\n\nExample: - \"4683\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.uint32.gte: 0\n  ves.io.schema.rules.uint32.lte: 401308\n",
                    "title": "as number",
                    "format": "int64",
                    "x-displayname": "AS Number",
                    "x-ves-example": "4683",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.uint32.gte": "0",
                        "ves.io.schema.rules.uint32.lte": "401308"
                    }
                },
                "ip_prefix": {
                    "type": "string",
                    "description": " IP prefix string.\n\nExample: - \"192.168.20.0/24\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.ip_prefix: true\n",
                    "title": "ip prefix",
                    "x-displayname": "IP Prefix",
                    "x-ves-example": "192.168.20.0/24",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.ip_prefix": "true"
                    }
                },
                "name": {
                    "type": "string",
                    "description": " HTTP load balancer for which this WAF exclusion will be applied\n\nExample: - \"ves-io-frontend\"-",
                    "title": "Name",
                    "x-displayname": "HTTP Load Balancer Name",
                    "x-ves-example": "ves-io-frontend"
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace of the App type for current request\n\nExample: - \"shared\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "shared"
                },
                "user_id": {
                    "type": "string",
                    "description": " User id of blocked client.\n\nExample: - \"abc\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "user id",
                    "maxLength": 256,
                    "x-displayname": "User Id",
                    "x-ves-example": "abc",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                }
            }
        },
        "app_securityGetSuggestedBlockClientRuleRsp": {
            "type": "object",
            "description": "Get suggested blocking SimpleClientSrcRule for a given IP/ASN",
            "title": "GetSuggestedBlockClientRuleRsp",
            "x-displayname": "Get Suggested Block Client Rule Response",
            "x-ves-proto-message": "ves.io.schema.app_security.GetSuggestedBlockClientRuleRsp",
            "properties": {
                "found_existing_rule": {
                    "description": " Specifies if an existing rule to block this client already exists with same match conditions",
                    "title": "FoundExistingRule",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Found existing rule"
                },
                "name": {
                    "type": "string",
                    "description": " HTTP load balancer for which this WAF exclusion will be applied\n\nExample: - \"ves-io-frontend\"-",
                    "title": "Name",
                    "x-displayname": "HTTP Load Balancer Name",
                    "x-ves-example": "ves-io-frontend"
                },
                "rule": {
                    "description": " Simple client source rule specifies the IP/ASN to be blocked",
                    "title": "SimpleClientSrcRule",
                    "$ref": "#/definitions/common_wafSimpleClientSrcRule",
                    "x-displayname": "Simple Client Source Rule"
                }
            }
        },
        "app_securityGetSuggestedDDoSMitigtionRuleReq": {
            "type": "object",
            "description": "Get suggested blocking DDoSMitigtionRule for a given IP/ASN/Country/TLS",
            "title": "GetSuggestedDDoSMitigtionRuleReq",
            "x-displayname": "Get Suggested DDoS Mitigtion Rule Request",
            "x-ves-proto-message": "ves.io.schema.app_security.GetSuggestedDDoSMitigtionRuleReq",
            "properties": {
                "asn_list": {
                    "description": " Addresses that belong to the ASNs in the given list\n The ASN is obtained by performing a lookup for the source IPv4 Address in a GeoIP DB.",
                    "title": "asn_list",
                    "$ref": "#/definitions/policyAsnMatchList",
                    "x-displayname": "ASN List"
                },
                "country_list": {
                    "type": "array",
                    "description": " Sources that are located in one of the countries in the given list\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "country_list",
                    "maxItems": 64,
                    "items": {
                        "$ref": "#/definitions/policyCountryCode"
                    },
                    "x-displayname": "Country List",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "ip_prefix_list": {
                    "description": " Addresses that are covered by the given list of IPv4 prefixes",
                    "title": "prefix_list",
                    "$ref": "#/definitions/policyPrefixMatchList",
                    "x-displayname": "IPv4 Prefix List"
                },
                "ja4_tls_fingerprint_matcher": {
                    "description": " TLS JA4 fingerprints to be matched.\n The predicate evaluates to true if source JA4 TLS fingerprint matches any of the exact values of JA4 TLS fingerprints.",
                    "title": "TLS JA4 fingerprint matcher",
                    "$ref": "#/definitions/policyJA4TlsFingerprintMatcherType",
                    "x-displayname": "JA4 TLS Fingerprint Matcher"
                },
                "name": {
                    "type": "string",
                    "description": " load balancer for which this WAF exclusion will be applied\n\nExample: - \"ves-io-frontend\"-",
                    "title": "Name",
                    "x-displayname": "Load Balancer Name",
                    "x-ves-example": "ves-io-frontend"
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace of the App type for current request\n\nExample: - \"shared\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "shared"
                },
                "tls_fingerprint_matcher": {
                    "description": " TLS JA3 fingerprints to be matched.\n The predicate evaluates to true if the TLS fingerprint matches any of the exact values or classes of known TLS fingerprints.",
                    "title": "TLS JA3 fingerprint matcher",
                    "$ref": "#/definitions/policyTlsFingerprintMatcherType",
                    "x-displayname": "JA3 TLS Fingerprint Matcher"
                }
            }
        },
        "app_securityGetSuggestedDDoSMitigtionRuleRsp": {
            "type": "object",
            "description": "Get suggested DDoS Mitigtion Rule for a given IP/ASN/Country/TLS",
            "title": "GetSuggestedDDoSMitigtionRuleRsp",
            "x-displayname": "Get Suggested DDoS Mitigtion Rule Response",
            "x-ves-proto-message": "ves.io.schema.app_security.GetSuggestedDDoSMitigtionRuleRsp",
            "properties": {
                "found_existing_mitigation_rule": {
                    "description": " Specifies if an existing rule to block this client already exists with same match conditions",
                    "title": "FoundExistingRule",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Found existing rule"
                },
                "mitigation_rule": {
                    "description": " Service policy rule specifies the IP/ASN/Region/TLS to be blocked",
                    "title": "mitigation_rule",
                    "$ref": "#/definitions/common_securityDDoSMitigationRule",
                    "x-displayname": "DDoS Mitigation Rule"
                },
                "mitigation_rule_name": {
                    "type": "string",
                    "description": " HTTP load balancer for which this DDoS Mitigation Rule will be applied\n\nExample: - \"ves-io-ddos-mitigation-rule\"-",
                    "title": "Name",
                    "x-displayname": "DDoS Mitigation Rule Name",
                    "x-ves-example": "ves-io-ddos-mitigation-rule"
                }
            }
        },
        "app_securityGetSuggestedTrustClientRuleReq": {
            "type": "object",
            "description": "Get suggested blocking SimpleClientSrcRule for a given IP/ASN",
            "title": "GetSuggestedTrustClientRuleReq",
            "x-displayname": "Get Suggested Trust Client Rule Request",
            "x-ves-proto-message": "ves.io.schema.app_security.GetSuggestedTrustClientRuleReq",
            "properties": {
                "as_description": {
                    "type": "string",
                    "description": " AS description\n\nExample: - \"as-description\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "Description",
                    "maxLength": 256,
                    "x-displayname": "AS Description",
                    "x-ves-example": "as-description",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                },
                "as_number": {
                    "type": "integer",
                    "description": " RFC 6793 defined 4-byte AS number\n\nExample: - \"4683\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.uint32.gte: 0\n  ves.io.schema.rules.uint32.lte: 401308\n",
                    "title": "as number",
                    "format": "int64",
                    "x-displayname": "AS Number",
                    "x-ves-example": "4683",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.uint32.gte": "0",
                        "ves.io.schema.rules.uint32.lte": "401308"
                    }
                },
                "ip_prefix": {
                    "type": "string",
                    "description": " IP prefix string.\n\nExample: - \"192.168.20.0/24\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.ip_prefix: true\n",
                    "title": "ip prefix",
                    "x-displayname": "IP Prefix",
                    "x-ves-example": "192.168.20.0/24",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.ip_prefix": "true"
                    }
                },
                "ip_reputation": {
                    "type": "boolean",
                    "description": " Indicates whether the security event is ip reputation\n\nExample: - \"true\"-",
                    "title": "IP Reputation Security Event",
                    "format": "boolean",
                    "x-displayname": "IP Reputation Security Event",
                    "x-ves-example": "true"
                },
                "name": {
                    "type": "string",
                    "description": " HTTP load balancer for which this client blocking rule will be applied\n\nExample: - \"ves-io-frontend\"-",
                    "title": "Name",
                    "x-displayname": "HTTP Load Balancer Name",
                    "x-ves-example": "ves-io-frontend"
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace of the App type for current request\n\nExample: - \"shared\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "shared"
                },
                "sec_event_name": {
                    "type": "string",
                    "description": " The name of Security Event\n\nExample: - \"Malicious User Mitigation\"-",
                    "title": "Security Event Name",
                    "x-displayname": "Security Event Name",
                    "x-ves-example": "Malicious User Mitigation"
                },
                "sec_event_types": {
                    "type": "array",
                    "description": " List of Security Event types that should stop being generated for this client\n\nExample: - \"[WAF_SEC_EVENT]\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 4\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Security Event Types",
                    "maxItems": 4,
                    "items": {
                        "$ref": "#/definitions/app_securitySecEventType"
                    },
                    "x-displayname": "Security Event Types",
                    "x-ves-example": "[WAF_SEC_EVENT]",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "4",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "threat_mesh": {
                    "type": "boolean",
                    "description": " Indicates whether the security event is threat mesh\n\nExample: - \"true\"-",
                    "title": "Threat Mesh Security Event",
                    "format": "boolean",
                    "x-displayname": "Threat Mesh Security Event",
                    "x-ves-example": "true"
                },
                "user_id": {
                    "type": "string",
                    "description": " User id of trusted client.\n\nExample: - \"abc\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "user id",
                    "maxLength": 256,
                    "x-displayname": "User Id",
                    "x-ves-example": "abc",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                }
            }
        },
        "app_securityGetSuggestedTrustClientRuleRsp": {
            "type": "object",
            "description": "Get suggested SimpleClientSrcRule to trust a given IP/ASN",
            "title": "GetSuggestedTrustClientRuleRsp",
            "x-displayname": "Get Suggested Trust Client Rule Response",
            "x-ves-proto-message": "ves.io.schema.app_security.GetSuggestedTrustClientRuleRsp",
            "properties": {
                "found_existing_rule": {
                    "description": " Specifies if an existing rule to trust this client already exists with same match conditions",
                    "title": "FoundExistingRule",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Found existing rule"
                },
                "name": {
                    "type": "string",
                    "description": " HTTP load balancer for which this client rule will be applied\n\nExample: - \"ves-io-frontend\"-",
                    "title": "Name",
                    "x-displayname": "HTTP Load Balancer Name",
                    "x-ves-example": "ves-io-frontend"
                },
                "rule": {
                    "description": " Simple client source rule specifies the IP/ASN to be trusted",
                    "title": "SimpleClientSrcRule",
                    "$ref": "#/definitions/common_wafSimpleClientSrcRule",
                    "x-displayname": "Simple Client Source Rule"
                }
            }
        },
        "app_securitySecEventType": {
            "type": "string",
            "description": "Security event can be one of the following types.\n",
            "title": "Security Event Type",
            "enum": [
                "WAF_SEC_EVENT",
                "L7_POLICY_SEC_EVENT",
                "JS_CHALLENGE_SEC_EVENT",
                "CAPTCHA_CHALLENGE_SEC_EVENT",
                "MALICIOUS_USER_SEC_EVENT",
                "SVC_POLICY_SEC_EVENT",
                "BOT_DEFENSE_SEC_EVENT",
                "API_SEC_EVENT",
                "DDOS_SEC_EVENT",
                "DOS_SEC_EVENT"
            ],
            "default": "WAF_SEC_EVENT",
            "x-displayname": "Security Event Type",
            "x-ves-proto-enum": "ves.io.schema.app_security.SecEventType"
        },
        "common_securityDDoSClientSource": {
            "type": "object",
            "description": "DDoS Mitigation sources to be blocked",
            "title": "DDoSClientSource",
            "x-displayname": "DDoS Client Source Choice",
            "x-ves-displayorder": "1,3,5,6",
            "x-ves-proto-message": "ves.io.schema.views.common_security.DDoSClientSource",
            "properties": {
                "asn_list": {
                    "description": " Addresses that belong to the ASNs in the given list\n The ASN is obtained by performing a lookup for the source IPv4 Address in a GeoIP DB.",
                    "title": "asn_list",
                    "$ref": "#/definitions/policyAsnMatchList",
                    "x-displayname": "ASN List"
                },
                "country_list": {
                    "type": "array",
                    "description": " Sources that are located in one of the countries in the given list\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.enum.defined_only: true\n  ves.io.schema.rules.repeated.items.enum.not_in: [0]\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "country_list",
                    "maxItems": 64,
                    "items": {
                        "$ref": "#/definitions/policyCountryCode"
                    },
                    "x-displayname": "Country List",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.enum.defined_only": "true",
                        "ves.io.schema.rules.repeated.items.enum.not_in": "[0]",
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "ja4_tls_fingerprint_matcher": {
                    "description": " TLS JA4 fingerprints to be matched.\n The predicate evaluates to true if source JA4 TLS fingerprint matches any of the exact values of JA4 TLS fingerprints.",
                    "title": "TLS JA4 fingerprint matcher",
                    "$ref": "#/definitions/policyJA4TlsFingerprintMatcherType",
                    "x-displayname": "JA4 TLS Fingerprint Matcher"
                },
                "tls_fingerprint_matcher": {
                    "description": " TLS JA3 fingerprints to be matched.\n The predicate evaluates to true if the TLS fingerprint matches any of the exact values or classes of known TLS fingerprints.",
                    "title": "TLS JA3 fingerprint matcher",
                    "$ref": "#/definitions/policyTlsFingerprintMatcherType",
                    "x-displayname": "TLS Fingerprint Matcher"
                }
            }
        },
        "common_securityDDoSMitigationRule": {
            "type": "object",
            "description": "DDoS Mitigation Rule specifies the sources to be blocked",
            "title": "DDoSMitigationRule",
            "x-displayname": "DDoS Mitigation Rule",
            "x-ves-displayorder": "1,2,7,10",
            "x-ves-oneof-field-mitigation_action": "[\"block\"]",
            "x-ves-oneof-field-mitigation_choice": "[\"ddos_client_source\",\"ip_prefix_list\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_security.DDoSMitigationRule",
            "properties": {
                "block": {
                    "description": "Exclusive with []\n Block user for a duration determined by the expiration time",
                    "title": "Block User",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Block User"
                },
                "ddos_client_source": {
                    "description": "Exclusive with [ip_prefix_list]\n Combination of Region, ASN and TLS Fingerprints\n\nValidation Rules:\n  ves.io.schema.rules.message.required_one_nonzero_field: true\n",
                    "title": "ddos_client_source",
                    "$ref": "#/definitions/common_securityDDoSClientSource",
                    "x-displayname": "DDoS Client Source",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required_one_nonzero_field": "true"
                    }
                },
                "expiration_timestamp": {
                    "type": "string",
                    "description": " The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in\n the configuration but is not applied anymore.\n\nExample: - \"2019-12-31:44:34.171543432Z\"-\n\nValidation Rules:\n  ves.io.schema.rules.timestamp.within.seconds: 31536000\n",
                    "title": "expiration timestamp",
                    "format": "date-time",
                    "x-displayname": "Expiration Timestamp",
                    "x-ves-example": "2019-12-31:44:34.171543432Z",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.timestamp.within.seconds": "31536000"
                    }
                },
                "ip_prefix_list": {
                    "description": "Exclusive with [ddos_client_source]\n IP prefix string.",
                    "title": "ip source",
                    "$ref": "#/definitions/policyPrefixMatchList",
                    "x-displayname": "IP Source"
                },
                "metadata": {
                    "description": " Common attributes for the rule including name and description.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType",
                    "x-displayname": "Metadata",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "common_wafClientSrcRuleAction": {
            "type": "string",
            "description": "Action that should be taken when client identifier matches the rule\n",
            "title": "action",
            "enum": [
                "SKIP_PROCESSING_WAF",
                "SKIP_PROCESSING_BOT",
                "SKIP_PROCESSING_MUM",
                "SKIP_PROCESSING_IP_REPUTATION",
                "SKIP_PROCESSING_API_PROTECTION",
                "SKIP_PROCESSING_OAS_VALIDATION",
                "SKIP_PROCESSING_DDOS_PROTECTION",
                "SKIP_PROCESSING_THREAT_MESH",
                "SKIP_PROCESSING_MALWARE_PROTECTION"
            ],
            "default": "SKIP_PROCESSING_WAF",
            "x-displayname": "Action",
            "x-ves-proto-enum": "ves.io.schema.views.common_waf.ClientSrcRuleAction"
        },
        "common_wafHttpHeaderMatcherList": {
            "type": "object",
            "description": "Request header name and value pairs",
            "title": "HTTP Header",
            "x-displayname": "HTTP Header",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.HttpHeaderMatcherList",
            "properties": {
                "headers": {
                    "type": "array",
                    "description": " List of HTTP header name and value pairs\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 16\n",
                    "title": "headers",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/ioschemaHeaderMatcherType"
                    },
                    "x-displayname": "HTTP Headers",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "16"
                    }
                }
            }
        },
        "common_wafSimpleClientSrcRule": {
            "type": "object",
            "description": "Simple client source rule specifies the sources to be blocked or trusted (skip WAF)",
            "title": "SimpleClientSrcRule",
            "x-displayname": "Client Rule",
            "x-ves-oneof-field-action_choice": "[\"bot_skip_processing\",\"skip_processing\",\"waf_skip_processing\"]",
            "x-ves-oneof-field-client_source_choice": "[\"as_number\",\"http_header\",\"ip_prefix\",\"ipv6_prefix\",\"user_identifier\"]",
            "x-ves-proto-message": "ves.io.schema.views.common_waf.SimpleClientSrcRule",
            "properties": {
                "actions": {
                    "type": "array",
                    "description": " Actions that should be taken when client identifier matches the rule\n\nValidation Rules:\n  ves.io.schema.rules.enum.defined_only: true\n  ves.io.schema.rules.repeated.max_items: 10\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "actions",
                    "maxItems": 10,
                    "items": {
                        "$ref": "#/definitions/common_wafClientSrcRuleAction"
                    },
                    "x-displayname": "Actions",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.enum.defined_only": "true",
                        "ves.io.schema.rules.repeated.max_items": "10",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "as_number": {
                    "type": "integer",
                    "description": "Exclusive with [http_header ip_prefix ipv6_prefix user_identifier]\n RFC 6793 defined 4-byte AS number\n\nExample: - \"4683\"-\n\nValidation Rules:\n  ves.io.schema.rules.uint32.gte: 1\n  ves.io.schema.rules.uint32.lte: 401308\n",
                    "title": "as number",
                    "format": "int64",
                    "x-displayname": "AS Number",
                    "x-ves-example": "4683",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.uint32.gte": "1",
                        "ves.io.schema.rules.uint32.lte": "401308"
                    }
                },
                "bot_skip_processing": {
                    "description": "Exclusive with [skip_processing waf_skip_processing]\n Skip Bot Defense processing for clients matching this rule.",
                    "title": "Skip Bot Processing",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Skip Bot Defense Processing"
                },
                "expiration_timestamp": {
                    "type": "string",
                    "description": " The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in\n the configuration but is not applied anymore.\n\nExample: - \"2019-12-31:44:34.171543432Z\"-\n\nValidation Rules:\n  ves.io.schema.rules.timestamp.within.seconds: 31536000\n",
                    "title": "expiration timestamp",
                    "format": "date-time",
                    "x-displayname": "Expiration Timestamp",
                    "x-ves-example": "2019-12-31:44:34.171543432Z",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.timestamp.within.seconds": "31536000"
                    }
                },
                "http_header": {
                    "description": "Exclusive with [as_number ip_prefix ipv6_prefix user_identifier]\n Request header name and value pairs",
                    "title": "HTTP Header",
                    "$ref": "#/definitions/common_wafHttpHeaderMatcherList",
                    "x-displayname": "HTTP Headers"
                },
                "ip_prefix": {
                    "type": "string",
                    "description": "Exclusive with [as_number http_header ipv6_prefix user_identifier]\n IPv4 prefix string.\n\nExample: - \"192.168.20.0/24\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.ipv4_prefix: true\n",
                    "title": "ip prefix",
                    "x-displayname": "IPv4 Prefix",
                    "x-ves-example": "192.168.20.0/24",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.ipv4_prefix": "true"
                    }
                },
                "ipv6_prefix": {
                    "type": "string",
                    "description": "Exclusive with [as_number http_header ip_prefix user_identifier]\n IPv6 prefix string.\n\nExample: - \"2001::1/64\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.ipv6_prefix: true\n",
                    "title": "ipv6 prefix",
                    "x-displayname": "IPv6 Prefix",
                    "x-ves-example": "2001::1/64",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.ipv6_prefix": "true"
                    }
                },
                "metadata": {
                    "description": " Common attributes for the rule including name and description.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType",
                    "x-displayname": "Metadata",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "skip_processing": {
                    "description": "Exclusive with [bot_skip_processing waf_skip_processing]\n Skip both WAF and Bot Defense processing for clients matching this rule.",
                    "title": "Skip Both",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Skip Both"
                },
                "user_identifier": {
                    "type": "string",
                    "description": "Exclusive with [as_number http_header ip_prefix ipv6_prefix]\n Identify user based on user identifier. User identifier value needs to be copied from security event.\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "user identifier",
                    "maxLength": 256,
                    "x-displayname": "User Identifier",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                },
                "waf_skip_processing": {
                    "description": "Exclusive with [bot_skip_processing skip_processing]\n Skip WAF processing for clients matching this rule.",
                    "title": "Skip WAF Processing",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Skip WAF Processing"
                }
            }
        },
        "ioschemaHeaderMatcherType": {
            "type": "object",
            "description": "Header match is done using the name of the header and its value.\nThe value match is done using one of the following\n    regex match on value\n    exact match of value\n    presence of header\n\nHeader Match can also be inverse of above, which be used to check\n    missing header or\n    non-matching value",
            "title": "HeaderMatcherType",
            "x-displayname": "Header to Match",
            "x-ves-oneof-field-value_match": "[\"exact\",\"presence\",\"regex\"]",
            "x-ves-proto-message": "ves.io.schema.HeaderMatcherType",
            "properties": {
                "exact": {
                    "type": "string",
                    "description": "Exclusive with [presence regex]\n Header value to match exactly\n\nExample: - \"application/json\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 256\n  ves.io.schema.rules.string.not_empty: true\n",
                    "title": "exact",
                    "maxLength": 256,
                    "x-displayname": "Exact",
                    "x-ves-example": "application/json",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "256",
                        "ves.io.schema.rules.string.not_empty": "true"
                    }
                },
                "invert_match": {
                    "type": "boolean",
                    "description": " Invert the result of the match to detect missing header or non-matching value",
                    "title": "invert_match",
                    "format": "boolean",
                    "x-displayname": "NOT of match"
                },
                "name": {
                    "type": "string",
                    "description": " Name of the header\n\nExample: - \"Content-Type\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.http_header_field: true\n  ves.io.schema.rules.string.max_bytes: 256\n  ves.io.schema.rules.string.min_bytes: 1\n",
                    "title": "name",
                    "minLength": 1,
                    "maxLength": 256,
                    "x-displayname": "Name",
                    "x-ves-example": "Content-Type",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.http_header_field": "true",
                        "ves.io.schema.rules.string.max_bytes": "256",
                        "ves.io.schema.rules.string.min_bytes": "1"
                    }
                },
                "presence": {
                    "type": "boolean",
                    "description": "Exclusive with [exact regex]\n If true, check for presence of header",
                    "title": "presence",
                    "format": "boolean",
                    "x-displayname": "Presence"
                },
                "regex": {
                    "type": "string",
                    "description": "Exclusive with [exact presence]\n Regex match of the header value in re2 format\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 256\n  ves.io.schema.rules.string.not_empty: true\n  ves.io.schema.rules.string.regex: true\n",
                    "title": "regex",
                    "maxLength": 256,
                    "x-displayname": "Regex",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "256",
                        "ves.io.schema.rules.string.not_empty": "true",
                        "ves.io.schema.rules.string.regex": "true"
                    }
                }
            }
        },
        "policyAsnMatchList": {
            "type": "object",
            "description": "An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
            "title": "Asn Match List",
            "x-displayname": "ASN Match List",
            "x-ves-proto-message": "ves.io.schema.policy.AsnMatchList",
            "properties": {
                "as_numbers": {
                    "type": "array",
                    "description": " An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.\n\nExample: - \"[713, 7932, 847325, 4683, 15269, 1000001]\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.min_items: 1\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "as numbers",
                    "minItems": 1,
                    "maxItems": 16,
                    "items": {
                        "type": "integer",
                        "format": "int64"
                    },
                    "x-displayname": "AS Numbers",
                    "x-ves-example": "[713, 7932, 847325, 4683, 15269, 1000001]",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.min_items": "1",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyCountryCode": {
            "type": "string",
            "description": "ISO 3166 Aplpha-2 country codes\n",
            "title": "CountryCode",
            "enum": [
                "COUNTRY_NONE",
                "COUNTRY_AD",
                "COUNTRY_AE",
                "COUNTRY_AF",
                "COUNTRY_AG",
                "COUNTRY_AI",
                "COUNTRY_AL",
                "COUNTRY_AM",
                "COUNTRY_AN",
                "COUNTRY_AO",
                "COUNTRY_AQ",
                "COUNTRY_AR",
                "COUNTRY_AS",
                "COUNTRY_AT",
                "COUNTRY_AU",
                "COUNTRY_AW",
                "COUNTRY_AX",
                "COUNTRY_AZ",
                "COUNTRY_BA",
                "COUNTRY_BB",
                "COUNTRY_BD",
                "COUNTRY_BE",
                "COUNTRY_BF",
                "COUNTRY_BG",
                "COUNTRY_BH",
                "COUNTRY_BI",
                "COUNTRY_BJ",
                "COUNTRY_BL",
                "COUNTRY_BM",
                "COUNTRY_BN",
                "COUNTRY_BO",
                "COUNTRY_BQ",
                "COUNTRY_BR",
                "COUNTRY_BS",
                "COUNTRY_BT",
                "COUNTRY_BV",
                "COUNTRY_BW",
                "COUNTRY_BY",
                "COUNTRY_BZ",
                "COUNTRY_CA",
                "COUNTRY_CC",
                "COUNTRY_CD",
                "COUNTRY_CF",
                "COUNTRY_CG",
                "COUNTRY_CH",
                "COUNTRY_CI",
                "COUNTRY_CK",
                "COUNTRY_CL",
                "COUNTRY_CM",
                "COUNTRY_CN",
                "COUNTRY_CO",
                "COUNTRY_CR",
                "COUNTRY_CS",
                "COUNTRY_CU",
                "COUNTRY_CV",
                "COUNTRY_CW",
                "COUNTRY_CX",
                "COUNTRY_CY",
                "COUNTRY_CZ",
                "COUNTRY_DE",
                "COUNTRY_DJ",
                "COUNTRY_DK",
                "COUNTRY_DM",
                "COUNTRY_DO",
                "COUNTRY_DZ",
                "COUNTRY_EC",
                "COUNTRY_EE",
                "COUNTRY_EG",
                "COUNTRY_EH",
                "COUNTRY_ER",
                "COUNTRY_ES",
                "COUNTRY_ET",
                "COUNTRY_FI",
                "COUNTRY_FJ",
                "COUNTRY_FK",
                "COUNTRY_FM",
                "COUNTRY_FO",
                "COUNTRY_FR",
                "COUNTRY_GA",
                "COUNTRY_GB",
                "COUNTRY_GD",
                "COUNTRY_GE",
                "COUNTRY_GF",
                "COUNTRY_GG",
                "COUNTRY_GH",
                "COUNTRY_GI",
                "COUNTRY_GL",
                "COUNTRY_GM",
                "COUNTRY_GN",
                "COUNTRY_GP",
                "COUNTRY_GQ",
                "COUNTRY_GR",
                "COUNTRY_GS",
                "COUNTRY_GT",
                "COUNTRY_GU",
                "COUNTRY_GW",
                "COUNTRY_GY",
                "COUNTRY_HK",
                "COUNTRY_HM",
                "COUNTRY_HN",
                "COUNTRY_HR",
                "COUNTRY_HT",
                "COUNTRY_HU",
                "COUNTRY_ID",
                "COUNTRY_IE",
                "COUNTRY_IL",
                "COUNTRY_IM",
                "COUNTRY_IN",
                "COUNTRY_IO",
                "COUNTRY_IQ",
                "COUNTRY_IR",
                "COUNTRY_IS",
                "COUNTRY_IT",
                "COUNTRY_JE",
                "COUNTRY_JM",
                "COUNTRY_JO",
                "COUNTRY_JP",
                "COUNTRY_KE",
                "COUNTRY_KG",
                "COUNTRY_KH",
                "COUNTRY_KI",
                "COUNTRY_KM",
                "COUNTRY_KN",
                "COUNTRY_KP",
                "COUNTRY_KR",
                "COUNTRY_KW",
                "COUNTRY_KY",
                "COUNTRY_KZ",
                "COUNTRY_LA",
                "COUNTRY_LB",
                "COUNTRY_LC",
                "COUNTRY_LI",
                "COUNTRY_LK",
                "COUNTRY_LR",
                "COUNTRY_LS",
                "COUNTRY_LT",
                "COUNTRY_LU",
                "COUNTRY_LV",
                "COUNTRY_LY",
                "COUNTRY_MA",
                "COUNTRY_MC",
                "COUNTRY_MD",
                "COUNTRY_ME",
                "COUNTRY_MF",
                "COUNTRY_MG",
                "COUNTRY_MH",
                "COUNTRY_MK",
                "COUNTRY_ML",
                "COUNTRY_MM",
                "COUNTRY_MN",
                "COUNTRY_MO",
                "COUNTRY_MP",
                "COUNTRY_MQ",
                "COUNTRY_MR",
                "COUNTRY_MS",
                "COUNTRY_MT",
                "COUNTRY_MU",
                "COUNTRY_MV",
                "COUNTRY_MW",
                "COUNTRY_MX",
                "COUNTRY_MY",
                "COUNTRY_MZ",
                "COUNTRY_NA",
                "COUNTRY_NC",
                "COUNTRY_NE",
                "COUNTRY_NF",
                "COUNTRY_NG",
                "COUNTRY_NI",
                "COUNTRY_NL",
                "COUNTRY_NO",
                "COUNTRY_NP",
                "COUNTRY_NR",
                "COUNTRY_NU",
                "COUNTRY_NZ",
                "COUNTRY_OM",
                "COUNTRY_PA",
                "COUNTRY_PE",
                "COUNTRY_PF",
                "COUNTRY_PG",
                "COUNTRY_PH",
                "COUNTRY_PK",
                "COUNTRY_PL",
                "COUNTRY_PM",
                "COUNTRY_PN",
                "COUNTRY_PR",
                "COUNTRY_PS",
                "COUNTRY_PT",
                "COUNTRY_PW",
                "COUNTRY_PY",
                "COUNTRY_QA",
                "COUNTRY_RE",
                "COUNTRY_RO",
                "COUNTRY_RS",
                "COUNTRY_RU",
                "COUNTRY_RW",
                "COUNTRY_SA",
                "COUNTRY_SB",
                "COUNTRY_SC",
                "COUNTRY_SD",
                "COUNTRY_SE",
                "COUNTRY_SG",
                "COUNTRY_SH",
                "COUNTRY_SI",
                "COUNTRY_SJ",
                "COUNTRY_SK",
                "COUNTRY_SL",
                "COUNTRY_SM",
                "COUNTRY_SN",
                "COUNTRY_SO",
                "COUNTRY_SR",
                "COUNTRY_SS",
                "COUNTRY_ST",
                "COUNTRY_SV",
                "COUNTRY_SX",
                "COUNTRY_SY",
                "COUNTRY_SZ",
                "COUNTRY_TC",
                "COUNTRY_TD",
                "COUNTRY_TF",
                "COUNTRY_TG",
                "COUNTRY_TH",
                "COUNTRY_TJ",
                "COUNTRY_TK",
                "COUNTRY_TL",
                "COUNTRY_TM",
                "COUNTRY_TN",
                "COUNTRY_TO",
                "COUNTRY_TR",
                "COUNTRY_TT",
                "COUNTRY_TV",
                "COUNTRY_TW",
                "COUNTRY_TZ",
                "COUNTRY_UA",
                "COUNTRY_UG",
                "COUNTRY_UM",
                "COUNTRY_US",
                "COUNTRY_UY",
                "COUNTRY_UZ",
                "COUNTRY_VA",
                "COUNTRY_VC",
                "COUNTRY_VE",
                "COUNTRY_VG",
                "COUNTRY_VI",
                "COUNTRY_VN",
                "COUNTRY_VU",
                "COUNTRY_WF",
                "COUNTRY_WS",
                "COUNTRY_XK",
                "COUNTRY_XT",
                "COUNTRY_YE",
                "COUNTRY_YT",
                "COUNTRY_ZA",
                "COUNTRY_ZM",
                "COUNTRY_ZW"
            ],
            "default": "COUNTRY_NONE",
            "x-displayname": "Country Code",
            "x-ves-proto-enum": "ves.io.schema.policy.CountryCode"
        },
        "policyJA4TlsFingerprintMatcherType": {
            "type": "object",
            "description": "An extended version of JA3 that includes additional fields for more comprehensive fingerprinting of\nSSL/TLS clients and potentially has a different structure and length.",
            "title": "JA4TlsFingerprintMatcherType",
            "x-displayname": "JA4 TLS Fingerprint Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.JA4TlsFingerprintMatcherType",
            "properties": {
                "exact_values": {
                    "type": "array",
                    "description": " A list of exact JA4 TLS fingerprint to match the input JA4 TLS fingerprint against\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.len: 36\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "exact values",
                    "maxItems": 16,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Exact Values",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.len": "36",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyKnownTlsFingerprintClass": {
            "type": "string",
            "description": "Specifies known TLS fingerprint classes\n\n - TLS_FINGERPRINT_NONE: TLS_FINGERPRINT_NONE\n\nNo TLS fingerprint\n - ANY_MALICIOUS_FINGERPRINT: ANY_MALICIOUS_FINGERPRINT\n\nTLS fingerprints known to be associated with malicious clients\n - ADWARE: ADWARE\n\nTLS fingerprints known to be associated with adware\n - ADWIND: ADWIND\n\nTLS fingerprints known to be associated with adwind\n - DRIDEX: DRIDEX\n\nTLS fingerprints known to be associated with dridex\n - GOOTKIT: GOOTKIT\n\nTLS fingerprints known to be associated with gootkit\n - GOZI: GOZI\n\nTLS fingerprints known to be associated with gozi\n - JBIFROST: JBIFROST\n\nTLS fingerprints known to be associated with jbifrost\n - QUAKBOT: QUAKBOT\n\nTLS fingerprints known to be associated with quakbot\n - RANSOMWARE: RANSOMWARE\n\nTLS fingerprints known to be associated with ransomware\n - TROLDESH: TROLDESH\n\nTLS fingerprints known to be associated with troldesh\n - TOFSEE: TOFSEE\n\nTLS fingerprints known to be associated with tofsee\n - TORRENTLOCKER: TORRENTLOCKER\n\nTLS fingerprints known to be associated with torrentlocker\n - TRICKBOT: TRICKBOT\n\nTLS fingerprints known to be associated with trickbot",
            "title": "TLS known fingerprint class",
            "enum": [
                "TLS_FINGERPRINT_NONE",
                "ANY_MALICIOUS_FINGERPRINT",
                "ADWARE",
                "ADWIND",
                "DRIDEX",
                "GOOTKIT",
                "GOZI",
                "JBIFROST",
                "QUAKBOT",
                "RANSOMWARE",
                "TROLDESH",
                "TOFSEE",
                "TORRENTLOCKER",
                "TRICKBOT"
            ],
            "default": "TLS_FINGERPRINT_NONE",
            "x-displayname": "TLS known fingerprint class",
            "x-ves-proto-enum": "ves.io.schema.policy.KnownTlsFingerprintClass"
        },
        "policyPrefixMatchList": {
            "type": "object",
            "description": "List of IP Prefix strings to match against.",
            "title": "IP Prefix Match List",
            "x-displayname": "IP Prefix Match List",
            "x-ves-proto-message": "ves.io.schema.policy.PrefixMatchList",
            "properties": {
                "invert_match": {
                    "type": "boolean",
                    "description": " Invert the match result.",
                    "title": "invert_matcher",
                    "format": "boolean",
                    "x-displayname": "Invert Match Result"
                },
                "ip_prefixes": {
                    "type": "array",
                    "description": " List of IPv4 prefix strings.\n\nExample: - \"192.168.20.0/24\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.ipv4_prefix: true\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.max_items: 128\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "ip prefixes",
                    "maxItems": 128,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "IPv4 Prefix List",
                    "x-ves-example": "192.168.20.0/24",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.ipv4_prefix": "true",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.max_items": "128",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "ipv6_prefixes": {
                    "type": "array",
                    "description": " List of IPv6 prefix strings.\n\nExample: - \"fd48:fa09:d9d4::/48\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.ipv6_prefix: true\n  ves.io.schema.rules.repeated.items.string.not_empty: true\n  ves.io.schema.rules.repeated.max_items: 128\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "ipv6 prefixes",
                    "maxItems": 128,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "IPv6 Prefix List",
                    "x-ves-example": "fd48:fa09:d9d4::/48",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.ipv6_prefix": "true",
                        "ves.io.schema.rules.repeated.items.string.not_empty": "true",
                        "ves.io.schema.rules.repeated.max_items": "128",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyTlsFingerprintMatcherType": {
            "type": "object",
            "description": "A TLS fingerprint matcher specifies multiple criteria for matching a TLS fingerprint. The set of supported positve match criteria includes a list of known\nclasses of TLS fingerprints and a list of exact values. The match is considered successful if either of these positive criteria are satisfied and the input\nfingerprint is not one of the excluded values.",
            "title": "TlsFingerprintMatcherType",
            "x-displayname": "TLS Fingerprint Matcher",
            "x-ves-proto-message": "ves.io.schema.policy.TlsFingerprintMatcherType",
            "properties": {
                "classes": {
                    "type": "array",
                    "description": " A list of known classes of TLS fingerprints to match the input TLS JA3 fingerprint against.\n\nExample: - \"['ADWARE', 'TRICKBOT']-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "classes",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/policyKnownTlsFingerprintClass"
                    },
                    "x-displayname": "TLS fingerprint classes",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "exact_values": {
                    "type": "array",
                    "description": " A list of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against.\n\nExample: - \"['ed6dfd54b01ebe31b7a65b88abfa7297', '16efcf0e00504ddfedde13bfea997952', 'de364c46b0dfc283b5e38c79ceae3f8f']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.len: 32\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "exact values",
                    "maxItems": 16,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Exact Values",
                    "x-ves-example": "['ed6dfd54b01ebe31b7a65b88abfa7297', '16efcf0e00504ddfedde13bfea997952', 'de364c46b0dfc283b5e38c79ceae3f8f']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.len": "32",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "excluded_values": {
                    "type": "array",
                    "description": " A list of TLS JA3 fingerprints to be excluded when matching the input TLS JA3 fingerprint. This can be used to skip known false positives when using one\n or more known TLS fingerprint classes in the enclosing matcher.\n\nExample: - \"['fb00055a1196aeea8d1bc609885ba953', 'b386946a5a44d1ddcc843bc75336dfce']\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.string.len: 32\n  ves.io.schema.rules.repeated.max_items: 32\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "excluded values",
                    "maxItems": 32,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Excluded Values",
                    "x-ves-example": "['fb00055a1196aeea8d1bc609885ba953', 'b386946a5a44d1ddcc843bc75336dfce']",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.string.len": "32",
                        "ves.io.schema.rules.repeated.max_items": "32",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "schemaEmpty": {
            "type": "object",
            "description": "This can be used for messages where no values are needed",
            "title": "Empty",
            "x-displayname": "Empty",
            "x-ves-proto-message": "ves.io.schema.Empty"
        },
        "schemaMessageMetaType": {
            "type": "object",
            "description": "MessageMetaType is metadata (common attributes) of a message that only certain messages\nhave. This information is propagated to the metadata of a child object that gets created\nfrom the containing message during view processing.\nThe information in this type can be specified by user during create and replace APIs.",
            "title": "MessageMetaType",
            "x-displayname": "Message Metadata",
            "x-ves-proto-message": "ves.io.schema.MessageMetaType",
            "properties": {
                "description": {
                    "type": "string",
                    "description": " Human readable description.\n\nExample: - \"Virtual Host for acmecorp website\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "description",
                    "maxLength": 256,
                    "x-displayname": "Description",
                    "x-ves-example": "Virtual Host for acmecorp website",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                },
                "name": {
                    "type": "string",
                    "description": " This is the name of the message.\n The value of name has to follow DNS-1035 format.\n\nExample: - \"acmecorp-web\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.min_len: 1\n  ves.io.schema.rules.string.ves_object_name: true\n",
                    "title": "name",
                    "minLength": 1,
                    "x-displayname": "Name",
                    "x-ves-example": "acmecorp-web",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.min_len": "1",
                        "ves.io.schema.rules.string.ves_object_name": "true"
                    }
                }
            }
        }
    },
    "x-displayname": "Application Security Monitoring APIs",
    "x-ves-proto-file": "ves.io/schema/app_security/public_client_rule_suggestions_api.proto"
}`
