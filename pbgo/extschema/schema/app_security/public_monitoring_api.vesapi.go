// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package app_security

import (
	"bytes"
	"context"
	"fmt"
	io "io"
	"net/http"
	"strings"

	"github.com/gogo/protobuf/proto"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"google.golang.org/grpc"

	"gopkg.volterra.us/stdlib/client"
	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/errors"
	"gopkg.volterra.us/stdlib/server"
	"gopkg.volterra.us/stdlib/svcfw"
)

var (
	_ = fmt.Sprintf("dummy for fmt import use")
)

// Create AppSecurityMonitoringAPI GRPC Client satisfying server.CustomClient
type AppSecurityMonitoringAPIGrpcClient struct {
	conn       *grpc.ClientConn
	grpcClient AppSecurityMonitoringAPIClient
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error)
}

func (c *AppSecurityMonitoringAPIGrpcClient) doRPCSearchLoadBalancers(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SearchLoadBalancersRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SearchLoadBalancersRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SearchLoadBalancers(ctx, req, opts...)
	return rsp, err
}

func (c *AppSecurityMonitoringAPIGrpcClient) doRPCSearchLoadBalancersAllNamespaces(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SearchLoadBalancersRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SearchLoadBalancersRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SearchLoadBalancersAllNamespaces(ctx, req, opts...)
	return rsp, err
}

func (c *AppSecurityMonitoringAPIGrpcClient) doRPCSecurityEventsAggregationQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SecurityEventsAggregationRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SecurityEventsAggregationRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SecurityEventsAggregationQuery(ctx, req, opts...)
	return rsp, err
}

func (c *AppSecurityMonitoringAPIGrpcClient) doRPCSecurityEventsAggregationQueryAllNamespaces(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SecurityEventsAggregationRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SecurityEventsAggregationRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SecurityEventsAggregationQueryAllNamespaces(ctx, req, opts...)
	return rsp, err
}

func (c *AppSecurityMonitoringAPIGrpcClient) doRPCSecurityEventsMetrics(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SecurityEventsCountRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SecurityEventsCountRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SecurityEventsMetrics(ctx, req, opts...)
	return rsp, err
}

func (c *AppSecurityMonitoringAPIGrpcClient) doRPCSecurityEventsQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SecurityEventsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SecurityEventsRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SecurityEventsQuery(ctx, req, opts...)
	return rsp, err
}

func (c *AppSecurityMonitoringAPIGrpcClient) doRPCSecurityEventsQueryAllNamespaces(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SecurityEventsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SecurityEventsRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SecurityEventsQueryAllNamespaces(ctx, req, opts...)
	return rsp, err
}

func (c *AppSecurityMonitoringAPIGrpcClient) doRPCSecurityEventsScrollQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SecurityEventsScrollRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SecurityEventsScrollRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SecurityEventsScrollQuery(ctx, req, opts...)
	return rsp, err
}

func (c *AppSecurityMonitoringAPIGrpcClient) doRPCSecurityIncidentsAggregationQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SecurityIncidentsAggregationRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SecurityIncidentsAggregationRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SecurityIncidentsAggregationQuery(ctx, req, opts...)
	return rsp, err
}

func (c *AppSecurityMonitoringAPIGrpcClient) doRPCSecurityIncidentsQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SecurityIncidentsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SecurityIncidentsRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SecurityIncidentsQuery(ctx, req, opts...)
	return rsp, err
}

func (c *AppSecurityMonitoringAPIGrpcClient) doRPCSecurityIncidentsScrollQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SecurityIncidentsScrollRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SecurityIncidentsScrollRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SecurityIncidentsScrollQuery(ctx, req, opts...)
	return rsp, err
}

func (c *AppSecurityMonitoringAPIGrpcClient) doRPCSuspiciousUserLogsAggregationQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SuspiciousUserLogsAggregationRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SuspiciousUserLogsAggregationRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SuspiciousUserLogsAggregationQuery(ctx, req, opts...)
	return rsp, err
}

func (c *AppSecurityMonitoringAPIGrpcClient) doRPCSuspiciousUserLogsQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SuspiciousUserLogsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SuspiciousUserLogsRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SuspiciousUserLogsQuery(ctx, req, opts...)
	return rsp, err
}

func (c *AppSecurityMonitoringAPIGrpcClient) doRPCSuspiciousUserLogsScrollQuery(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &SuspiciousUserLogsScrollRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SuspiciousUserLogsScrollRequest", yamlReq)
	}
	rsp, err := c.grpcClient.SuspiciousUserLogsScrollQuery(ctx, req, opts...)
	return rsp, err
}

func (c *AppSecurityMonitoringAPIGrpcClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	if cco.YAMLReq == "" {
		return nil, fmt.Errorf("Error, empty request body")
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := rpcFn(ctx, cco.YAMLReq, cco.GrpcCallOpts...)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using GRPC")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func NewAppSecurityMonitoringAPIGrpcClient(cc *grpc.ClientConn) server.CustomClient {
	ccl := &AppSecurityMonitoringAPIGrpcClient{
		conn:       cc,
		grpcClient: NewAppSecurityMonitoringAPIClient(cc),
	}
	rpcFns := make(map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error))
	rpcFns["SearchLoadBalancers"] = ccl.doRPCSearchLoadBalancers

	rpcFns["SearchLoadBalancersAllNamespaces"] = ccl.doRPCSearchLoadBalancersAllNamespaces

	rpcFns["SecurityEventsAggregationQuery"] = ccl.doRPCSecurityEventsAggregationQuery

	rpcFns["SecurityEventsAggregationQueryAllNamespaces"] = ccl.doRPCSecurityEventsAggregationQueryAllNamespaces

	rpcFns["SecurityEventsMetrics"] = ccl.doRPCSecurityEventsMetrics

	rpcFns["SecurityEventsQuery"] = ccl.doRPCSecurityEventsQuery

	rpcFns["SecurityEventsQueryAllNamespaces"] = ccl.doRPCSecurityEventsQueryAllNamespaces

	rpcFns["SecurityEventsScrollQuery"] = ccl.doRPCSecurityEventsScrollQuery

	rpcFns["SecurityIncidentsAggregationQuery"] = ccl.doRPCSecurityIncidentsAggregationQuery

	rpcFns["SecurityIncidentsQuery"] = ccl.doRPCSecurityIncidentsQuery

	rpcFns["SecurityIncidentsScrollQuery"] = ccl.doRPCSecurityIncidentsScrollQuery

	rpcFns["SuspiciousUserLogsAggregationQuery"] = ccl.doRPCSuspiciousUserLogsAggregationQuery

	rpcFns["SuspiciousUserLogsQuery"] = ccl.doRPCSuspiciousUserLogsQuery

	rpcFns["SuspiciousUserLogsScrollQuery"] = ccl.doRPCSuspiciousUserLogsScrollQuery

	ccl.rpcFns = rpcFns

	return ccl
}

// Create AppSecurityMonitoringAPI REST Client satisfying server.CustomClient
type AppSecurityMonitoringAPIRestClient struct {
	baseURL string
	client  http.Client
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error)
}

func (c *AppSecurityMonitoringAPIRestClient) doRPCSearchLoadBalancers(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SearchLoadBalancersRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SearchLoadBalancersRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		for _, item := range req.LabelFilter {
			q.Add("label_filter", fmt.Sprintf("%v", item))
		}
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SearchLoadBalancersResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.app_security.SearchLoadBalancersResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *AppSecurityMonitoringAPIRestClient) doRPCSearchLoadBalancersAllNamespaces(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SearchLoadBalancersRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SearchLoadBalancersRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		for _, item := range req.LabelFilter {
			q.Add("label_filter", fmt.Sprintf("%v", item))
		}
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SearchLoadBalancersResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.app_security.SearchLoadBalancersResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *AppSecurityMonitoringAPIRestClient) doRPCSecurityEventsAggregationQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SecurityEventsAggregationRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SecurityEventsAggregationRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("aggs", fmt.Sprintf("%v", req.Aggs))
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("query", fmt.Sprintf("%v", req.Query))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SecurityEventsAggregationResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.app_security.SecurityEventsAggregationResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *AppSecurityMonitoringAPIRestClient) doRPCSecurityEventsAggregationQueryAllNamespaces(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SecurityEventsAggregationRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SecurityEventsAggregationRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("aggs", fmt.Sprintf("%v", req.Aggs))
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("query", fmt.Sprintf("%v", req.Query))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SecurityEventsAggregationResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.app_security.SecurityEventsAggregationResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *AppSecurityMonitoringAPIRestClient) doRPCSecurityEventsMetrics(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SecurityEventsCountRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SecurityEventsCountRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		for _, item := range req.GroupBy {
			q.Add("group_by", fmt.Sprintf("%v", item))
		}
		for _, item := range req.LabelFilter {
			q.Add("label_filter", fmt.Sprintf("%v", item))
		}
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))
		q.Add("step", fmt.Sprintf("%v", req.Step))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SecurityEventsCountResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.app_security.SecurityEventsCountResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *AppSecurityMonitoringAPIRestClient) doRPCSecurityEventsQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SecurityEventsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SecurityEventsRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("aggs", fmt.Sprintf("%v", req.Aggs))
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("limit", fmt.Sprintf("%v", req.Limit))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("query", fmt.Sprintf("%v", req.Query))
		q.Add("scroll", fmt.Sprintf("%v", req.Scroll))
		q.Add("sort", fmt.Sprintf("%v", req.Sort))
		q.Add("sort_by", fmt.Sprintf("%v", req.SortBy))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SecurityEventsResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.app_security.SecurityEventsResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *AppSecurityMonitoringAPIRestClient) doRPCSecurityEventsQueryAllNamespaces(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SecurityEventsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SecurityEventsRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("aggs", fmt.Sprintf("%v", req.Aggs))
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("limit", fmt.Sprintf("%v", req.Limit))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("query", fmt.Sprintf("%v", req.Query))
		q.Add("scroll", fmt.Sprintf("%v", req.Scroll))
		q.Add("sort", fmt.Sprintf("%v", req.Sort))
		q.Add("sort_by", fmt.Sprintf("%v", req.SortBy))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SecurityEventsResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.app_security.SecurityEventsResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *AppSecurityMonitoringAPIRestClient) doRPCSecurityEventsScrollQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SecurityEventsScrollRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SecurityEventsScrollRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("scroll_id", fmt.Sprintf("%v", req.ScrollId))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SecurityEventsResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.app_security.SecurityEventsResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *AppSecurityMonitoringAPIRestClient) doRPCSecurityIncidentsAggregationQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SecurityIncidentsAggregationRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SecurityIncidentsAggregationRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("aggs", fmt.Sprintf("%v", req.Aggs))
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("query", fmt.Sprintf("%v", req.Query))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SecurityIncidentsAggregationResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.app_security.SecurityIncidentsAggregationResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *AppSecurityMonitoringAPIRestClient) doRPCSecurityIncidentsQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SecurityIncidentsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SecurityIncidentsRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("aggs", fmt.Sprintf("%v", req.Aggs))
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("limit", fmt.Sprintf("%v", req.Limit))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("query", fmt.Sprintf("%v", req.Query))
		q.Add("scroll", fmt.Sprintf("%v", req.Scroll))
		q.Add("sort", fmt.Sprintf("%v", req.Sort))
		q.Add("sort_by", fmt.Sprintf("%v", req.SortBy))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SecurityIncidentsResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.app_security.SecurityIncidentsResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *AppSecurityMonitoringAPIRestClient) doRPCSecurityIncidentsScrollQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SecurityIncidentsScrollRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SecurityIncidentsScrollRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("scroll_id", fmt.Sprintf("%v", req.ScrollId))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SecurityIncidentsResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.app_security.SecurityIncidentsResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *AppSecurityMonitoringAPIRestClient) doRPCSuspiciousUserLogsAggregationQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SuspiciousUserLogsAggregationRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SuspiciousUserLogsAggregationRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("aggs", fmt.Sprintf("%v", req.Aggs))
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("query", fmt.Sprintf("%v", req.Query))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SuspiciousUserLogsAggregationResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.app_security.SuspiciousUserLogsAggregationResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *AppSecurityMonitoringAPIRestClient) doRPCSuspiciousUserLogsQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SuspiciousUserLogsRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SuspiciousUserLogsRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("aggs", fmt.Sprintf("%v", req.Aggs))
		q.Add("end_time", fmt.Sprintf("%v", req.EndTime))
		q.Add("limit", fmt.Sprintf("%v", req.Limit))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("query", fmt.Sprintf("%v", req.Query))
		q.Add("scroll", fmt.Sprintf("%v", req.Scroll))
		q.Add("sort", fmt.Sprintf("%v", req.Sort))
		q.Add("sort_by", fmt.Sprintf("%v", req.SortBy))
		q.Add("start_time", fmt.Sprintf("%v", req.StartTime))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SuspiciousUserLogsResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.app_security.SuspiciousUserLogsResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *AppSecurityMonitoringAPIRestClient) doRPCSuspiciousUserLogsScrollQuery(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &SuspiciousUserLogsScrollRequest{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.SuspiciousUserLogsScrollRequest: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("scroll_id", fmt.Sprintf("%v", req.ScrollId))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &SuspiciousUserLogsResponse{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.app_security.SuspiciousUserLogsResponse", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *AppSecurityMonitoringAPIRestClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	rsp, err := rpcFn(ctx, cco)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using Rest")
	}
	return rsp, nil
}

func NewAppSecurityMonitoringAPIRestClient(baseURL string, hc http.Client) server.CustomClient {
	ccl := &AppSecurityMonitoringAPIRestClient{
		baseURL: baseURL,
		client:  hc,
	}

	rpcFns := make(map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error))
	rpcFns["SearchLoadBalancers"] = ccl.doRPCSearchLoadBalancers

	rpcFns["SearchLoadBalancersAllNamespaces"] = ccl.doRPCSearchLoadBalancersAllNamespaces

	rpcFns["SecurityEventsAggregationQuery"] = ccl.doRPCSecurityEventsAggregationQuery

	rpcFns["SecurityEventsAggregationQueryAllNamespaces"] = ccl.doRPCSecurityEventsAggregationQueryAllNamespaces

	rpcFns["SecurityEventsMetrics"] = ccl.doRPCSecurityEventsMetrics

	rpcFns["SecurityEventsQuery"] = ccl.doRPCSecurityEventsQuery

	rpcFns["SecurityEventsQueryAllNamespaces"] = ccl.doRPCSecurityEventsQueryAllNamespaces

	rpcFns["SecurityEventsScrollQuery"] = ccl.doRPCSecurityEventsScrollQuery

	rpcFns["SecurityIncidentsAggregationQuery"] = ccl.doRPCSecurityIncidentsAggregationQuery

	rpcFns["SecurityIncidentsQuery"] = ccl.doRPCSecurityIncidentsQuery

	rpcFns["SecurityIncidentsScrollQuery"] = ccl.doRPCSecurityIncidentsScrollQuery

	rpcFns["SuspiciousUserLogsAggregationQuery"] = ccl.doRPCSuspiciousUserLogsAggregationQuery

	rpcFns["SuspiciousUserLogsQuery"] = ccl.doRPCSuspiciousUserLogsQuery

	rpcFns["SuspiciousUserLogsScrollQuery"] = ccl.doRPCSuspiciousUserLogsScrollQuery

	ccl.rpcFns = rpcFns

	return ccl
}

// Create appSecurityMonitoringAPIInprocClient

// INPROC Client (satisfying AppSecurityMonitoringAPIClient interface)
type appSecurityMonitoringAPIInprocClient struct {
	AppSecurityMonitoringAPIServer
}

func (c *appSecurityMonitoringAPIInprocClient) SearchLoadBalancers(ctx context.Context, in *SearchLoadBalancersRequest, opts ...grpc.CallOption) (*SearchLoadBalancersResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.app_security.AppSecurityMonitoringAPI.SearchLoadBalancers")
	return c.AppSecurityMonitoringAPIServer.SearchLoadBalancers(ctx, in)
}
func (c *appSecurityMonitoringAPIInprocClient) SearchLoadBalancersAllNamespaces(ctx context.Context, in *SearchLoadBalancersRequest, opts ...grpc.CallOption) (*SearchLoadBalancersResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.app_security.AppSecurityMonitoringAPI.SearchLoadBalancersAllNamespaces")
	return c.AppSecurityMonitoringAPIServer.SearchLoadBalancersAllNamespaces(ctx, in)
}
func (c *appSecurityMonitoringAPIInprocClient) SecurityEventsAggregationQuery(ctx context.Context, in *SecurityEventsAggregationRequest, opts ...grpc.CallOption) (*SecurityEventsAggregationResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsAggregationQuery")
	return c.AppSecurityMonitoringAPIServer.SecurityEventsAggregationQuery(ctx, in)
}
func (c *appSecurityMonitoringAPIInprocClient) SecurityEventsAggregationQueryAllNamespaces(ctx context.Context, in *SecurityEventsAggregationRequest, opts ...grpc.CallOption) (*SecurityEventsAggregationResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsAggregationQueryAllNamespaces")
	return c.AppSecurityMonitoringAPIServer.SecurityEventsAggregationQueryAllNamespaces(ctx, in)
}
func (c *appSecurityMonitoringAPIInprocClient) SecurityEventsMetrics(ctx context.Context, in *SecurityEventsCountRequest, opts ...grpc.CallOption) (*SecurityEventsCountResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsMetrics")
	return c.AppSecurityMonitoringAPIServer.SecurityEventsMetrics(ctx, in)
}
func (c *appSecurityMonitoringAPIInprocClient) SecurityEventsQuery(ctx context.Context, in *SecurityEventsRequest, opts ...grpc.CallOption) (*SecurityEventsResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsQuery")
	return c.AppSecurityMonitoringAPIServer.SecurityEventsQuery(ctx, in)
}
func (c *appSecurityMonitoringAPIInprocClient) SecurityEventsQueryAllNamespaces(ctx context.Context, in *SecurityEventsRequest, opts ...grpc.CallOption) (*SecurityEventsResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsQueryAllNamespaces")
	return c.AppSecurityMonitoringAPIServer.SecurityEventsQueryAllNamespaces(ctx, in)
}
func (c *appSecurityMonitoringAPIInprocClient) SecurityEventsScrollQuery(ctx context.Context, in *SecurityEventsScrollRequest, opts ...grpc.CallOption) (*SecurityEventsResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsScrollQuery")
	return c.AppSecurityMonitoringAPIServer.SecurityEventsScrollQuery(ctx, in)
}
func (c *appSecurityMonitoringAPIInprocClient) SecurityIncidentsAggregationQuery(ctx context.Context, in *SecurityIncidentsAggregationRequest, opts ...grpc.CallOption) (*SecurityIncidentsAggregationResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityIncidentsAggregationQuery")
	return c.AppSecurityMonitoringAPIServer.SecurityIncidentsAggregationQuery(ctx, in)
}
func (c *appSecurityMonitoringAPIInprocClient) SecurityIncidentsQuery(ctx context.Context, in *SecurityIncidentsRequest, opts ...grpc.CallOption) (*SecurityIncidentsResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityIncidentsQuery")
	return c.AppSecurityMonitoringAPIServer.SecurityIncidentsQuery(ctx, in)
}
func (c *appSecurityMonitoringAPIInprocClient) SecurityIncidentsScrollQuery(ctx context.Context, in *SecurityIncidentsScrollRequest, opts ...grpc.CallOption) (*SecurityIncidentsResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityIncidentsScrollQuery")
	return c.AppSecurityMonitoringAPIServer.SecurityIncidentsScrollQuery(ctx, in)
}
func (c *appSecurityMonitoringAPIInprocClient) SuspiciousUserLogsAggregationQuery(ctx context.Context, in *SuspiciousUserLogsAggregationRequest, opts ...grpc.CallOption) (*SuspiciousUserLogsAggregationResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.app_security.AppSecurityMonitoringAPI.SuspiciousUserLogsAggregationQuery")
	return c.AppSecurityMonitoringAPIServer.SuspiciousUserLogsAggregationQuery(ctx, in)
}
func (c *appSecurityMonitoringAPIInprocClient) SuspiciousUserLogsQuery(ctx context.Context, in *SuspiciousUserLogsRequest, opts ...grpc.CallOption) (*SuspiciousUserLogsResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.app_security.AppSecurityMonitoringAPI.SuspiciousUserLogsQuery")
	return c.AppSecurityMonitoringAPIServer.SuspiciousUserLogsQuery(ctx, in)
}
func (c *appSecurityMonitoringAPIInprocClient) SuspiciousUserLogsScrollQuery(ctx context.Context, in *SuspiciousUserLogsScrollRequest, opts ...grpc.CallOption) (*SuspiciousUserLogsResponse, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.app_security.AppSecurityMonitoringAPI.SuspiciousUserLogsScrollQuery")
	return c.AppSecurityMonitoringAPIServer.SuspiciousUserLogsScrollQuery(ctx, in)
}

func NewAppSecurityMonitoringAPIInprocClient(svc svcfw.Service) AppSecurityMonitoringAPIClient {
	return &appSecurityMonitoringAPIInprocClient{AppSecurityMonitoringAPIServer: NewAppSecurityMonitoringAPIServer(svc)}
}

// RegisterGwAppSecurityMonitoringAPIHandler registers with grpc-gw with an inproc-client backing so that
// rest to grpc happens without a grpc.Dial (thus avoiding additional certs for mTLS)
func RegisterGwAppSecurityMonitoringAPIHandler(ctx context.Context, mux *runtime.ServeMux, svc interface{}) error {
	s, ok := svc.(svcfw.Service)
	if !ok {
		return fmt.Errorf("svc is not svcfw.Service")
	}
	return RegisterAppSecurityMonitoringAPIHandlerClient(ctx, mux, NewAppSecurityMonitoringAPIInprocClient(s))
}

// Create appSecurityMonitoringAPISrv

// SERVER (satisfying AppSecurityMonitoringAPIServer interface)
type appSecurityMonitoringAPISrv struct {
	svc svcfw.Service
}

func (s *appSecurityMonitoringAPISrv) SearchLoadBalancers(ctx context.Context, in *SearchLoadBalancersRequest) (*SearchLoadBalancersResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.app_security.AppSecurityMonitoringAPI")
	cah, ok := ah.(AppSecurityMonitoringAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *AppSecurityMonitoringAPIServer", ah)
	}

	var (
		rsp *SearchLoadBalancersResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.app_security.SearchLoadBalancersRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'AppSecurityMonitoringAPI.SearchLoadBalancers' operation on 'app_security'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.app_security.AppSecurityMonitoringAPI.SearchLoadBalancers"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SearchLoadBalancers(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.app_security.SearchLoadBalancersResponse", rsp)...)

	return rsp, nil
}
func (s *appSecurityMonitoringAPISrv) SearchLoadBalancersAllNamespaces(ctx context.Context, in *SearchLoadBalancersRequest) (*SearchLoadBalancersResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.app_security.AppSecurityMonitoringAPI")
	cah, ok := ah.(AppSecurityMonitoringAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *AppSecurityMonitoringAPIServer", ah)
	}

	var (
		rsp *SearchLoadBalancersResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.app_security.SearchLoadBalancersRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'AppSecurityMonitoringAPI.SearchLoadBalancersAllNamespaces' operation on 'app_security'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.app_security.AppSecurityMonitoringAPI.SearchLoadBalancersAllNamespaces"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SearchLoadBalancersAllNamespaces(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.app_security.SearchLoadBalancersResponse", rsp)...)

	return rsp, nil
}
func (s *appSecurityMonitoringAPISrv) SecurityEventsAggregationQuery(ctx context.Context, in *SecurityEventsAggregationRequest) (*SecurityEventsAggregationResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.app_security.AppSecurityMonitoringAPI")
	cah, ok := ah.(AppSecurityMonitoringAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *AppSecurityMonitoringAPIServer", ah)
	}

	var (
		rsp *SecurityEventsAggregationResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.app_security.SecurityEventsAggregationRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'AppSecurityMonitoringAPI.SecurityEventsAggregationQuery' operation on 'app_security'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsAggregationQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SecurityEventsAggregationQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.app_security.SecurityEventsAggregationResponse", rsp)...)

	return rsp, nil
}
func (s *appSecurityMonitoringAPISrv) SecurityEventsAggregationQueryAllNamespaces(ctx context.Context, in *SecurityEventsAggregationRequest) (*SecurityEventsAggregationResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.app_security.AppSecurityMonitoringAPI")
	cah, ok := ah.(AppSecurityMonitoringAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *AppSecurityMonitoringAPIServer", ah)
	}

	var (
		rsp *SecurityEventsAggregationResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.app_security.SecurityEventsAggregationRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'AppSecurityMonitoringAPI.SecurityEventsAggregationQueryAllNamespaces' operation on 'app_security'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsAggregationQueryAllNamespaces"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SecurityEventsAggregationQueryAllNamespaces(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.app_security.SecurityEventsAggregationResponse", rsp)...)

	return rsp, nil
}
func (s *appSecurityMonitoringAPISrv) SecurityEventsMetrics(ctx context.Context, in *SecurityEventsCountRequest) (*SecurityEventsCountResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.app_security.AppSecurityMonitoringAPI")
	cah, ok := ah.(AppSecurityMonitoringAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *AppSecurityMonitoringAPIServer", ah)
	}

	var (
		rsp *SecurityEventsCountResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.app_security.SecurityEventsCountRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'AppSecurityMonitoringAPI.SecurityEventsMetrics' operation on 'app_security'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsMetrics"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SecurityEventsMetrics(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.app_security.SecurityEventsCountResponse", rsp)...)

	return rsp, nil
}
func (s *appSecurityMonitoringAPISrv) SecurityEventsQuery(ctx context.Context, in *SecurityEventsRequest) (*SecurityEventsResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.app_security.AppSecurityMonitoringAPI")
	cah, ok := ah.(AppSecurityMonitoringAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *AppSecurityMonitoringAPIServer", ah)
	}

	var (
		rsp *SecurityEventsResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.app_security.SecurityEventsRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'AppSecurityMonitoringAPI.SecurityEventsQuery' operation on 'app_security'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SecurityEventsQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.app_security.SecurityEventsResponse", rsp)...)

	return rsp, nil
}
func (s *appSecurityMonitoringAPISrv) SecurityEventsQueryAllNamespaces(ctx context.Context, in *SecurityEventsRequest) (*SecurityEventsResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.app_security.AppSecurityMonitoringAPI")
	cah, ok := ah.(AppSecurityMonitoringAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *AppSecurityMonitoringAPIServer", ah)
	}

	var (
		rsp *SecurityEventsResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.app_security.SecurityEventsRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'AppSecurityMonitoringAPI.SecurityEventsQueryAllNamespaces' operation on 'app_security'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsQueryAllNamespaces"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SecurityEventsQueryAllNamespaces(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.app_security.SecurityEventsResponse", rsp)...)

	return rsp, nil
}
func (s *appSecurityMonitoringAPISrv) SecurityEventsScrollQuery(ctx context.Context, in *SecurityEventsScrollRequest) (*SecurityEventsResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.app_security.AppSecurityMonitoringAPI")
	cah, ok := ah.(AppSecurityMonitoringAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *AppSecurityMonitoringAPIServer", ah)
	}

	var (
		rsp *SecurityEventsResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.app_security.SecurityEventsScrollRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'AppSecurityMonitoringAPI.SecurityEventsScrollQuery' operation on 'app_security'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsScrollQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SecurityEventsScrollQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.app_security.SecurityEventsResponse", rsp)...)

	return rsp, nil
}
func (s *appSecurityMonitoringAPISrv) SecurityIncidentsAggregationQuery(ctx context.Context, in *SecurityIncidentsAggregationRequest) (*SecurityIncidentsAggregationResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.app_security.AppSecurityMonitoringAPI")
	cah, ok := ah.(AppSecurityMonitoringAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *AppSecurityMonitoringAPIServer", ah)
	}

	var (
		rsp *SecurityIncidentsAggregationResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.app_security.SecurityIncidentsAggregationRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'AppSecurityMonitoringAPI.SecurityIncidentsAggregationQuery' operation on 'app_security'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityIncidentsAggregationQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SecurityIncidentsAggregationQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.app_security.SecurityIncidentsAggregationResponse", rsp)...)

	return rsp, nil
}
func (s *appSecurityMonitoringAPISrv) SecurityIncidentsQuery(ctx context.Context, in *SecurityIncidentsRequest) (*SecurityIncidentsResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.app_security.AppSecurityMonitoringAPI")
	cah, ok := ah.(AppSecurityMonitoringAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *AppSecurityMonitoringAPIServer", ah)
	}

	var (
		rsp *SecurityIncidentsResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.app_security.SecurityIncidentsRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'AppSecurityMonitoringAPI.SecurityIncidentsQuery' operation on 'app_security'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityIncidentsQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SecurityIncidentsQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.app_security.SecurityIncidentsResponse", rsp)...)

	return rsp, nil
}
func (s *appSecurityMonitoringAPISrv) SecurityIncidentsScrollQuery(ctx context.Context, in *SecurityIncidentsScrollRequest) (*SecurityIncidentsResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.app_security.AppSecurityMonitoringAPI")
	cah, ok := ah.(AppSecurityMonitoringAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *AppSecurityMonitoringAPIServer", ah)
	}

	var (
		rsp *SecurityIncidentsResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.app_security.SecurityIncidentsScrollRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'AppSecurityMonitoringAPI.SecurityIncidentsScrollQuery' operation on 'app_security'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityIncidentsScrollQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SecurityIncidentsScrollQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.app_security.SecurityIncidentsResponse", rsp)...)

	return rsp, nil
}
func (s *appSecurityMonitoringAPISrv) SuspiciousUserLogsAggregationQuery(ctx context.Context, in *SuspiciousUserLogsAggregationRequest) (*SuspiciousUserLogsAggregationResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.app_security.AppSecurityMonitoringAPI")
	cah, ok := ah.(AppSecurityMonitoringAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *AppSecurityMonitoringAPIServer", ah)
	}

	var (
		rsp *SuspiciousUserLogsAggregationResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.app_security.SuspiciousUserLogsAggregationRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'AppSecurityMonitoringAPI.SuspiciousUserLogsAggregationQuery' operation on 'app_security'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.app_security.AppSecurityMonitoringAPI.SuspiciousUserLogsAggregationQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SuspiciousUserLogsAggregationQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.app_security.SuspiciousUserLogsAggregationResponse", rsp)...)

	return rsp, nil
}
func (s *appSecurityMonitoringAPISrv) SuspiciousUserLogsQuery(ctx context.Context, in *SuspiciousUserLogsRequest) (*SuspiciousUserLogsResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.app_security.AppSecurityMonitoringAPI")
	cah, ok := ah.(AppSecurityMonitoringAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *AppSecurityMonitoringAPIServer", ah)
	}

	var (
		rsp *SuspiciousUserLogsResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.app_security.SuspiciousUserLogsRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'AppSecurityMonitoringAPI.SuspiciousUserLogsQuery' operation on 'app_security'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.app_security.AppSecurityMonitoringAPI.SuspiciousUserLogsQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SuspiciousUserLogsQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.app_security.SuspiciousUserLogsResponse", rsp)...)

	return rsp, nil
}
func (s *appSecurityMonitoringAPISrv) SuspiciousUserLogsScrollQuery(ctx context.Context, in *SuspiciousUserLogsScrollRequest) (*SuspiciousUserLogsResponse, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.app_security.AppSecurityMonitoringAPI")
	cah, ok := ah.(AppSecurityMonitoringAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *AppSecurityMonitoringAPIServer", ah)
	}

	var (
		rsp *SuspiciousUserLogsResponse
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.app_security.SuspiciousUserLogsScrollRequest", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'AppSecurityMonitoringAPI.SuspiciousUserLogsScrollQuery' operation on 'app_security'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.app_security.AppSecurityMonitoringAPI.SuspiciousUserLogsScrollQuery"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.SuspiciousUserLogsScrollQuery(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.app_security.SuspiciousUserLogsResponse", rsp)...)

	return rsp, nil
}

func NewAppSecurityMonitoringAPIServer(svc svcfw.Service) AppSecurityMonitoringAPIServer {
	return &appSecurityMonitoringAPISrv{svc: svc}
}

var AppSecurityMonitoringAPISwaggerJSON string = `{
    "swagger": "2.0",
    "info": {
        "title": "Application Security Monitoring APIs",
        "description": "APIs to get application security events and metrics on virtual-host basis.\nSecurity events may be generated for following reasons:\n1. Service policy hits with action \"deny\"\n2. Rate limiting\n3. Javascript challenge failure",
        "version": "version not set"
    },
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "tags": [],
    "paths": {
        "/public/namespaces/system/app_security/all_ns_events": {
            "post": {
                "summary": "Security Events Query All Namespaces",
                "description": "Get security events for the given namespace.\nFor -system- namespace, all security events for the tenant matching the query specified\nin the request will be returned in the response. User may query security events that matches various\nfields such as -vh_name-, -sec_event_type-, -src_site-, -city-, -country-.\nThis API is specific to system namespace",
                "operationId": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsQueryAllNamespaces",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securitySecurityEventsResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/app_securitySecurityEventsRequest"
                        }
                    }
                ],
                "tags": [
                    "AppSecurityMonitoringAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-app_security-appsecuritymonitoringapi-securityeventsqueryallnamespaces"
                },
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsQueryAllNamespaces"
            },
            "x-displayname": "Application Security Monitoring APIs",
            "x-ves-proto-service": "ves.io.schema.app_security.AppSecurityMonitoringAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/app_security/all_ns_events/aggregation": {
            "post": {
                "summary": "Security Events Aggregation Query All Namespaces",
                "description": "Get summary/aggregation data for security events in the given namespace.\nFor -system- namespace, all security events for the tenant matching the query specified\nin the request will be considered for aggregation. User may query security events that matches various\nfields such as -vh_name-, -sec_event_type-, -src_site-, -city-, -country-.",
                "operationId": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsAggregationQueryAllNamespaces",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securitySecurityEventsAggregationResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/app_securitySecurityEventsAggregationRequest"
                        }
                    }
                ],
                "tags": [
                    "AppSecurityMonitoringAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-app_security-appsecuritymonitoringapi-securityeventsaggregationqueryallnamespaces"
                },
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsAggregationQueryAllNamespaces"
            },
            "x-displayname": "Application Security Monitoring APIs",
            "x-ves-proto-service": "ves.io.schema.app_security.AppSecurityMonitoringAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/app_security/all_ns_search/loadbalancers": {
            "post": {
                "summary": "Search load balancers All Namespaces",
                "description": "Get list of virtual hosts matching label filter",
                "operationId": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SearchLoadBalancersAllNamespaces",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securitySearchLoadBalancersResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/app_securitySearchLoadBalancersRequest"
                        }
                    }
                ],
                "tags": [
                    "AppSecurityMonitoringAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-app_security-appsecuritymonitoringapi-searchloadbalancersallnamespaces"
                },
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SearchLoadBalancersAllNamespaces"
            },
            "x-displayname": "Application Security Monitoring APIs",
            "x-ves-proto-service": "ves.io.schema.app_security.AppSecurityMonitoringAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/app_security/events": {
            "post": {
                "summary": "Security Events Query",
                "description": "Get security events for the given namespace.\nFor -system- namespace, all security events for the tenant matching the query specified\nin the request will be returned in the response. User may query security events that matches various\nfields such as -vh_name-, -sec_event_type-, -src_site-, -city-, -country-.",
                "operationId": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securitySecurityEventsResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nfetch security events for a given namespace\nx-example: \"bloggin-app-namespace-1\"",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/app_securitySecurityEventsRequest"
                        }
                    }
                ],
                "tags": [
                    "AppSecurityMonitoringAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-app_security-appsecuritymonitoringapi-securityeventsquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsQuery"
            },
            "x-displayname": "Application Security Monitoring APIs",
            "x-ves-proto-service": "ves.io.schema.app_security.AppSecurityMonitoringAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/app_security/events/aggregation": {
            "post": {
                "summary": "Security Events Aggregation Query",
                "description": "Get summary/aggregation data for security events in the given namespace.\nFor -system- namespace, all security events for the tenant matching the query specified\nin the request will be considered for aggregation. User may query security events that matches various\nfields such as -vh_name-, -sec_event_type-, -src_site-, -city-, -country-.",
                "operationId": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsAggregationQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securitySecurityEventsAggregationResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nfetch security events for a given namespace\nx-example: \"bloggin-app-namespace-1\"",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/app_securitySecurityEventsAggregationRequest"
                        }
                    }
                ],
                "tags": [
                    "AppSecurityMonitoringAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-app_security-appsecuritymonitoringapi-securityeventsaggregationquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsAggregationQuery"
            },
            "x-displayname": "Application Security Monitoring APIs",
            "x-ves-proto-service": "ves.io.schema.app_security.AppSecurityMonitoringAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/app_security/events/scroll": {
            "get": {
                "summary": "Security Event Scroll Query",
                "description": "Scroll request is used to fetch large number of security events in multiple batches with each SecurityEventResponse\ncontaining no more than 500 messages. To scroll through more than 500 or all messages, one can use the\nSecurityEventScrollRequest. Use the scroll_id returned in the SecurityEventResponse to fetch the next batch of security events\nand one can continue this process till the scroll_id returned is \"\" which indicates no more events to scroll.",
                "operationId": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsScrollQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securitySecurityEventsResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"bloggin-app-namespace-1\"\nfetch the WAF security events scoped by namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "scroll_id",
                        "description": "x-example: \"DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==\"\nLong Base-64 encoded string which can be used to retrieve next batch of security events.",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "x-displayname": "Scroll ID"
                    }
                ],
                "tags": [
                    "AppSecurityMonitoringAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-app_security-appsecuritymonitoringapi-securityeventsscrollquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsScrollQuery"
            },
            "post": {
                "summary": "Security Event Scroll Query",
                "description": "Scroll request is used to fetch large number of security events in multiple batches with each SecurityEventResponse\ncontaining no more than 500 messages. To scroll through more than 500 or all messages, one can use the\nSecurityEventScrollRequest. Use the scroll_id returned in the SecurityEventResponse to fetch the next batch of security events\nand one can continue this process till the scroll_id returned is \"\" which indicates no more events to scroll.",
                "operationId": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsScrollQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securitySecurityEventsResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"bloggin-app-namespace-1\"\nfetch the WAF security events scoped by namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/app_securitySecurityEventsScrollRequest"
                        }
                    }
                ],
                "tags": [
                    "AppSecurityMonitoringAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-app_security-appsecuritymonitoringapi-securityeventsscrollquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsScrollQuery"
            },
            "x-displayname": "Application Security Monitoring APIs",
            "x-ves-proto-service": "ves.io.schema.app_security.AppSecurityMonitoringAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/app_security/incidents": {
            "post": {
                "summary": "Security Incidents Query",
                "description": "Get security incidents for the given namespace.\nFor -system- namespace, all security incidents for the tenant matching the query specified\nin the request will be returned in the response. User may query security incidents that matches various\nfields such as -vh_name-, -intent-, -city-, -country-.",
                "operationId": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityIncidentsQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securitySecurityIncidentsResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"bloggin-app-namespace-1\"\nFetch security incidents for a given namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/app_securitySecurityIncidentsRequest"
                        }
                    }
                ],
                "tags": [
                    "AppSecurityMonitoringAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-app_security-appsecuritymonitoringapi-securityincidentsquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityIncidentsQuery"
            },
            "x-displayname": "Application Security Monitoring APIs",
            "x-ves-proto-service": "ves.io.schema.app_security.AppSecurityMonitoringAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/app_security/incidents/aggregation": {
            "post": {
                "summary": "Security Incidents Aggregation Query",
                "description": "Get summary/aggregation data for security incidents in the given namespace.\nFor -system- namespace, all security incidents for the tenant matching the query specified in the request will be\nconsidered for aggregation. User may query security events that matches various fields such as -vh_name-,\n-intent-, -city-, -country-.",
                "operationId": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityIncidentsAggregationQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securitySecurityIncidentsAggregationResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"bloggin-app-namespace-1\"\nFetch security incidents for a given namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/app_securitySecurityIncidentsAggregationRequest"
                        }
                    }
                ],
                "tags": [
                    "AppSecurityMonitoringAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-app_security-appsecuritymonitoringapi-securityincidentsaggregationquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityIncidentsAggregationQuery"
            },
            "x-displayname": "Application Security Monitoring APIs",
            "x-ves-proto-service": "ves.io.schema.app_security.AppSecurityMonitoringAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/app_security/incidents/scroll": {
            "get": {
                "summary": "Security Incidents Scroll Query",
                "description": "Scroll request is used to fetch large number of security incidents in multiple batches with each SecurityIncidentsResponse\ncontaining no more than 500 messages. To scroll through more than 500 or all messages, one can use the\nSecurityIncidentsScrollRequest. Use the scroll_id returned in the SecurityIncidentsResponse to fetch the next batch\nof security incidents and one can continue this process till the scroll_id returned is \"\" which indicates no more\nevents to scroll.",
                "operationId": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityIncidentsScrollQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securitySecurityIncidentsResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"bloggin-app-namespace-1\"\nFetch security incidents for a given namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "scroll_id",
                        "description": "x-example: \"DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==\"\nLong Base-64 encoded string which can be used to retrieve next batch of security events.",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "x-displayname": "Scroll ID"
                    }
                ],
                "tags": [
                    "AppSecurityMonitoringAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-app_security-appsecuritymonitoringapi-securityincidentsscrollquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityIncidentsScrollQuery"
            },
            "post": {
                "summary": "Security Incidents Scroll Query",
                "description": "Scroll request is used to fetch large number of security incidents in multiple batches with each SecurityIncidentsResponse\ncontaining no more than 500 messages. To scroll through more than 500 or all messages, one can use the\nSecurityIncidentsScrollRequest. Use the scroll_id returned in the SecurityIncidentsResponse to fetch the next batch\nof security incidents and one can continue this process till the scroll_id returned is \"\" which indicates no more\nevents to scroll.",
                "operationId": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityIncidentsScrollQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securitySecurityIncidentsResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"bloggin-app-namespace-1\"\nFetch security incidents for a given namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/app_securitySecurityIncidentsScrollRequest"
                        }
                    }
                ],
                "tags": [
                    "AppSecurityMonitoringAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-app_security-appsecuritymonitoringapi-securityincidentsscrollquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityIncidentsScrollQuery"
            },
            "x-displayname": "Application Security Monitoring APIs",
            "x-ves-proto-service": "ves.io.schema.app_security.AppSecurityMonitoringAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/app_security/metrics": {
            "post": {
                "summary": "Security Events Metrics",
                "description": "Get the number of security events for a given namespace.\nSecurity events can be aggregated across multiple dimensions like VIRTUAL_HOST, SITE, SEC_EVENT_TYPE, etc.,",
                "operationId": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsMetrics",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securitySecurityEventsCountResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"bloggin-app-namespace-1\"\nnamespace is used to scope the security events for the given namespace.",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/app_securitySecurityEventsCountRequest"
                        }
                    }
                ],
                "tags": [
                    "AppSecurityMonitoringAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-app_security-appsecuritymonitoringapi-securityeventsmetrics"
                },
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SecurityEventsMetrics"
            },
            "x-displayname": "Application Security Monitoring APIs",
            "x-ves-proto-service": "ves.io.schema.app_security.AppSecurityMonitoringAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/app_security/search/loadbalancers": {
            "post": {
                "summary": "Search load balancers",
                "description": "Get list of virtual hosts matching label filter",
                "operationId": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SearchLoadBalancers",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securitySearchLoadBalancersResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"shared\"\nNamespace of the App type for current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/app_securitySearchLoadBalancersRequest"
                        }
                    }
                ],
                "tags": [
                    "AppSecurityMonitoringAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-app_security-appsecuritymonitoringapi-searchloadbalancers"
                },
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SearchLoadBalancers"
            },
            "x-displayname": "Application Security Monitoring APIs",
            "x-ves-proto-service": "ves.io.schema.app_security.AppSecurityMonitoringAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/app_security/suspicious_user_logs": {
            "post": {
                "summary": "Suspicious User Logs Query",
                "description": "Get suspicious user logs for the given namespace.\nFor -system- namespace, all suspicious users logs for the tenant matching the query specified\nin the request will be returned in the response. User may query suspicious user logs that matches various\nfields such as -vh_name-, -user-, -site-, -city-, -country-.",
                "operationId": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SuspiciousUserLogsQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securitySuspiciousUserLogsResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nfetch suspicious user logs for a given namespace\nx-example: \"bloggin-app-namespace-1\"",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/app_securitySuspiciousUserLogsRequest"
                        }
                    }
                ],
                "tags": [
                    "AppSecurityMonitoringAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-app_security-appsecuritymonitoringapi-suspicioususerlogsquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SuspiciousUserLogsQuery"
            },
            "x-displayname": "Application Security Monitoring APIs",
            "x-ves-proto-service": "ves.io.schema.app_security.AppSecurityMonitoringAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/app_security/suspicious_user_logs/aggregation": {
            "post": {
                "summary": "Suspicious User Logs Aggregation Query",
                "description": "Get summary/aggregation data for suspicious user logs in the given namespace.\nFor -system- namespace, all suspicious user logs for the tenant matching the query specified\nin the request will be considered for aggregation. User may query suspicious user logs that matches various\nfields such as -vh_name-, -user-, -site-, -city-, -country-.",
                "operationId": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SuspiciousUserLogsAggregationQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securitySuspiciousUserLogsAggregationResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nfetch suspicious user logs for a given namespace\nx-example: \"bloggin-app-namespace-1\"",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/app_securitySuspiciousUserLogsAggregationRequest"
                        }
                    }
                ],
                "tags": [
                    "AppSecurityMonitoringAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-app_security-appsecuritymonitoringapi-suspicioususerlogsaggregationquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SuspiciousUserLogsAggregationQuery"
            },
            "x-displayname": "Application Security Monitoring APIs",
            "x-ves-proto-service": "ves.io.schema.app_security.AppSecurityMonitoringAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/app_security/suspicious_user_logs/scroll": {
            "get": {
                "summary": "Suspicious User Logs Scroll Query",
                "description": "Scroll request is used to fetch large number of suspicious user logs in multiple batches with each SuspiciousUserLogsResponse\ncontaining no more than 500 messages. To scroll through more than 500 or all messages, one can use the\nSuspiciousUserLogsScrollRequest. Use the scroll_id returned in the SuspiciousUserLogsResponse to fetch the next batch of logs \nand one can continue this process till the scroll_id returned is \"\" which indicates no more logs to scroll.",
                "operationId": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SuspiciousUserLogsScrollQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securitySuspiciousUserLogsResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"bloggin-app-namespace-1\"\nfetch the next batch of suspicious user logs scoped by namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "scroll_id",
                        "description": "x-example: \"DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==\"\nLong Base-64 encoded string which can be used to retrieve next batch of security events.",
                        "in": "query",
                        "required": false,
                        "type": "string",
                        "x-displayname": "Scroll ID"
                    }
                ],
                "tags": [
                    "AppSecurityMonitoringAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-app_security-appsecuritymonitoringapi-suspicioususerlogsscrollquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SuspiciousUserLogsScrollQuery"
            },
            "post": {
                "summary": "Suspicious User Logs Scroll Query",
                "description": "Scroll request is used to fetch large number of suspicious user logs in multiple batches with each SuspiciousUserLogsResponse\ncontaining no more than 500 messages. To scroll through more than 500 or all messages, one can use the\nSuspiciousUserLogsScrollRequest. Use the scroll_id returned in the SuspiciousUserLogsResponse to fetch the next batch of logs \nand one can continue this process till the scroll_id returned is \"\" which indicates no more logs to scroll.",
                "operationId": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SuspiciousUserLogsScrollQuery",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securitySuspiciousUserLogsResponse"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "namespace\n\nx-example: \"bloggin-app-namespace-1\"\nfetch the next batch of suspicious user logs scoped by namespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/app_securitySuspiciousUserLogsScrollRequest"
                        }
                    }
                ],
                "tags": [
                    "AppSecurityMonitoringAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-app_security-appsecuritymonitoringapi-suspicioususerlogsscrollquery"
                },
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityMonitoringAPI.SuspiciousUserLogsScrollQuery"
            },
            "x-displayname": "Application Security Monitoring APIs",
            "x-ves-proto-service": "ves.io.schema.app_security.AppSecurityMonitoringAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        }
    },
    "definitions": {
        "app_securityLoadbalancerData": {
            "type": "object",
            "description": "List of virtual hosts in all the namespaces matching filter provided in the request.",
            "title": "LoadbalancerData",
            "x-displayname": "Load Balancer data",
            "x-ves-proto-message": "ves.io.schema.app_security.LoadbalancerData",
            "properties": {
                "name": {
                    "type": "string",
                    "description": " HTTP load balancer name.\n\nExample: - \"ves-io-frontend\"-",
                    "title": "Name",
                    "x-displayname": "HTTP Load Balancer Name",
                    "x-ves-example": "ves-io-frontend"
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace of the virtual host.\n\nExample: - \"bloggin-app-namespace-1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "bloggin-app-namespace-1"
                },
                "request_data": {
                    "description": " Request Data\n\nExample: - \"[5, 01-01-1970T00:00:00Z, 01-01-1970T00:00:00Z]\"-",
                    "title": "Request Data",
                    "$ref": "#/definitions/app_securityRequestData",
                    "x-displayname": "Request Data",
                    "x-ves-example": "[5, 01-01-1970T00:00:00Z, 01-01-1970T00:00:00Z]"
                },
                "security_events_data": {
                    "description": " Security Events Data\n\nExample: - \"[5, 01-01-1970T00:00:00Z, 01-01-1970T00:00:00Z]\"-",
                    "title": "Security Events Data",
                    "$ref": "#/definitions/app_securitySecurityEventsData",
                    "x-displayname": "Security Events Data",
                    "x-ves-example": "[5, 01-01-1970T00:00:00Z, 01-01-1970T00:00:00Z]"
                }
            }
        },
        "app_securityRequestData": {
            "type": "object",
            "description": "Request Data",
            "title": "RequestData",
            "x-displayname": "Request Data",
            "x-ves-proto-message": "ves.io.schema.app_security.RequestData",
            "properties": {
                "count": {
                    "type": "string",
                    "description": " the number of requests matching the filter for virtual host in the given namespace\n\nExample: - 15-",
                    "format": "uint64",
                    "x-displayname": "Count"
                },
                "max_time": {
                    "type": "string",
                    "description": " Maximum time at which request ID was found.\n\nExample: - \"01-01-1970T00:00:00Z\"-",
                    "title": "Maximun Time",
                    "format": "date-time",
                    "x-displayname": "Maximum time",
                    "x-ves-example": "01-01-1970T00:00:00Z"
                },
                "min_time": {
                    "type": "string",
                    "description": " Minimum time at which the request ID was found.\n\nExample: - \"01-01-1970T00:00:00Z\"-",
                    "title": "Minimum Time",
                    "format": "date-time",
                    "x-displayname": "Minimum time",
                    "x-ves-example": "01-01-1970T00:00:00Z"
                }
            }
        },
        "app_securitySearchFilter": {
            "type": "object",
            "description": "Metric label filter can be specified to query specific metrics based on label match",
            "title": "Search Filter",
            "x-displayname": "Search Filter",
            "x-ves-proto-message": "ves.io.schema.app_security.SearchFilter",
            "properties": {
                "label": {
                    "description": " Label name which is used in the search filter.",
                    "title": "Search Label",
                    "$ref": "#/definitions/app_securitySearchLabel",
                    "x-displayname": "Search Label"
                },
                "op": {
                    "description": " Operator to evaluate the label in this filter",
                    "title": "Operator",
                    "$ref": "#/definitions/app_securitySearchLabelOperator",
                    "x-displayname": "Operator"
                },
                "value": {
                    "type": "array",
                    "description": " Value to be compared with\n\nExample: - \"[\"blogging-app-namespace-1\", \"namespace-2\"]\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 5\n",
                    "title": "Value",
                    "maxItems": 5,
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Value",
                    "x-ves-example": "[\"blogging-app-namespace-1\", \"namespace-2\"]",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "5"
                    }
                }
            }
        },
        "app_securitySearchLabel": {
            "type": "string",
            "description": "List of Virtual Hosts will be returned matching the following labels.\n",
            "title": "Search Label for VH list API",
            "enum": [
                "REQUEST_ID",
                "SOURCE_IP"
            ],
            "default": "REQUEST_ID",
            "x-displayname": "Search Label for VH List API",
            "x-ves-proto-enum": "ves.io.schema.app_security.SearchLabel"
        },
        "app_securitySearchLabelOperator": {
            "type": "string",
            "description": "Search Label Operator\n\nx-example: \"field: [\"foo\", \"bar\"]\"",
            "title": "Search Label Operator",
            "enum": [
                "IN",
                "NOT_IN"
            ],
            "default": "IN",
            "x-displayname": "Search Label Operator",
            "x-ves-proto-enum": "ves.io.schema.app_security.SearchLabelOperator"
        },
        "app_securitySearchLoadBalancersRequest": {
            "type": "object",
            "description": "Get a list of virtual hosts in all the namespaces matching filter provided in the request. \nThe filter can be a) Request ID b) Source IP",
            "title": "SearchLoadBalancersRequest",
            "x-displayname": "Search Load Balancers Request",
            "x-ves-proto-message": "ves.io.schema.app_security.SearchLoadBalancersRequest",
            "properties": {
                "label_filter": {
                    "type": "array",
                    "description": " List of label filter expressions of the form \"label\" -Op- \"value\".\n Response will only contain data that matches all the conditions specified in the -label_filter-.\n One or more of the following labels can be specified in the label_filter.\n -REQUEST_ID-, -SOURCE_IP--.\n\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 5\n",
                    "title": "Label Filter",
                    "maxItems": 5,
                    "items": {
                        "$ref": "#/definitions/app_securitySearchFilter"
                    },
                    "x-displayname": "Label Filter",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "5"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace of the App type for current request\n\nExample: - \"shared\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "shared"
                }
            }
        },
        "app_securitySearchLoadBalancersResponse": {
            "type": "object",
            "description": "List of virtual hosts in all the namespaces matching filter provided in the request.",
            "title": "SearchLoadBalancersResponse",
            "x-displayname": "Search Load Balancers Response",
            "x-ves-proto-message": "ves.io.schema.app_security.SearchLoadBalancersResponse",
            "properties": {
                "loadbalancers": {
                    "type": "array",
                    "description": " HTTP load balancer list for which the SearchFilter is applied.\n\nExample: - \"[ves-io-frontend\", \"ns1\" , \"1\", \"0\"]\"-",
                    "title": "Loadbalancers",
                    "items": {
                        "$ref": "#/definitions/app_securityLoadbalancerData"
                    },
                    "x-displayname": "HTTP Load Balancer List",
                    "x-ves-example": "[ves-io-frontend\", \"ns1\" , \"1\", \"0\"]"
                }
            }
        },
        "app_securitySecurityEventsAggregationRequest": {
            "type": "object",
            "description": "Request to get only aggregation data for security events",
            "title": "Security Events Aggregation Request",
            "x-displayname": "Security Events Aggregation Request",
            "x-ves-proto-message": "ves.io.schema.app_security.SecurityEventsAggregationRequest",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the security events response. If the number of security events that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.\n Optional",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "end_time": {
                    "type": "string",
                    "description": " fetch security events whose timestamp \u003c= end_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "end time",
                    "x-displayname": "End Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " fetch security events for a given namespace\n\nExample: - \"bloggin-app-namespace-1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "bloggin-app-namespace-1"
                },
                "query": {
                    "type": "string",
                    "description": " query is used to specify the list of matchers\n syntax for query := {[\u003cmatcher\u003e]}\n \u003cmatcher\u003e := \u003cfield_name\u003e\u003coperator\u003e\"\u003cvalue\u003e\"\n \u003cfield_name\u003e := string\n   One or more of these fields in the security event may be specified in the query.\n     vh_name - name of the virtual host\n     src_site - source site\n     city - name of the city\n     country - country code\n \u003cvalue\u003e := string\n \u003coperator\u003e := [\"=\"|\"!=\"|\"=~\"|\"!~\"]\n   = : equal to\n   != : not equal to\n   =~ : regex match\n   !~ : not regex match\n When more than one matcher is specified in the query, then security events matching ALL the matchers will be returned in the response.\n Example: query={country=\"United States\", city=\"California\"} will return all security events originating from California, United States.\n\n Optional: If not specified, all the security events matching the given tenant and namespace will be returned in the response.\n\nExample: - \"query={app_type=\"blogging_app\"}\"-",
                    "title": "query",
                    "x-displayname": "Query",
                    "x-ves-example": "query={app_type=\"blogging_app\"}"
                },
                "start_time": {
                    "type": "string",
                    "description": " fetch security events whose timestamp \u003e= start_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                }
            }
        },
        "app_securitySecurityEventsAggregationResponse": {
            "type": "object",
            "description": "Response message for SecurityEventsAggregationRequest",
            "title": "Security Events Aggregation Response",
            "x-displayname": "Security Events Aggregation Response",
            "x-ves-proto-message": "ves.io.schema.app_security.SecurityEventsAggregationResponse",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the security events response. If the number of security events that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregation data is key'ed with the aggregation name specified in the request.",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "total_hits": {
                    "type": "string",
                    "description": " total number of security events that matched the query.\n\nExample: - \"0\"-",
                    "title": "total hits",
                    "format": "uint64",
                    "x-displayname": "Total Hits",
                    "x-ves-example": "0"
                }
            }
        },
        "app_securitySecurityEventsCountRequest": {
            "type": "object",
            "description": "Request to get number of security events for a given namespace.",
            "title": "SecurityEventsCountRequest",
            "x-displayname": "Security Events Count Request",
            "x-ves-proto-message": "ves.io.schema.app_security.SecurityEventsCountRequest",
            "properties": {
                "end_time": {
                    "type": "string",
                    "description": " end time of metric collection from which data will be considered.\n Format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "End time",
                    "x-displayname": "End Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "group_by": {
                    "type": "array",
                    "description": " Aggregate data by one or more labels listed here.\n -NAMESPACE-, -VIRTUAL_HOST-, -SRC_SITE-, -SRC_INSTANCE-, -SEC_EVENT_TYPE-.\n\n Optional: If not specified, then the security events are aggregated/grouped by -VIRTUAL_HOST-, -SEC_EVENT_TYPE-.",
                    "title": "Group by",
                    "items": {
                        "$ref": "#/definitions/metricsSecurityMetricLabel"
                    },
                    "x-displayname": "Group By"
                },
                "label_filter": {
                    "type": "array",
                    "description": " List of label filter expressions of the form \"label\" -Op- \"value\".\n Response will only contain data that matches all the conditions specified in the -label_filter-.\n One or more of the following labels can be specified in the label_filter.\n -VIRTUAL_HOST-, -SRC_SITE-, -SRC_INSTANCE-, -SEC_EVENT_TYPE-.\n\n Optional: If not specified, then the metrics will be filtered only based on the -namespace- in the request.",
                    "title": "Label Filter",
                    "items": {
                        "$ref": "#/definitions/metricsSecurityMetricLabelFilter"
                    },
                    "x-displayname": "Label Filter"
                },
                "namespace": {
                    "type": "string",
                    "description": " namespace is used to scope the security events for the given namespace.\n\nExample: - \"bloggin-app-namespace-1\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "bloggin-app-namespace-1"
                },
                "start_time": {
                    "type": "string",
                    "description": " start time of metric collection from which data will be considered.\n Format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "Start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "step": {
                    "type": "string",
                    "description": " step is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.\n The timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn \u003c= end_time.\n Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days\n\n Optional: If not specified, then step size is evaluated to \u003cend_time - start_time\u003e\n\nExample: - \"15m\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_step: true\n",
                    "title": "Step",
                    "x-displayname": "Step",
                    "x-ves-example": "15m",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_step": "true"
                    }
                }
            }
        },
        "app_securitySecurityEventsCountResponse": {
            "type": "object",
            "description": "Number of security events for each unique combination of group_by labels in the SecurityEventsCountRequest.",
            "title": "SecurityEventsCountResponse",
            "x-displayname": "Security Events Count Response",
            "x-ves-proto-message": "ves.io.schema.app_security.SecurityEventsCountResponse",
            "properties": {
                "data": {
                    "type": "array",
                    "description": " List of security events counter data",
                    "title": "Security events counter data",
                    "items": {
                        "$ref": "#/definitions/metricsSecurityEventsCounter"
                    },
                    "x-displayname": "Security events counter data"
                },
                "step": {
                    "type": "string",
                    "description": " Actual step size used in the response. It could be higher than the requested step due to metric rollups and the query duration.\n Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days\n\nExample: - \"30m\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.time_interval: true\n",
                    "title": "step",
                    "x-displayname": "Step",
                    "x-ves-example": "30m",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.time_interval": "true"
                    }
                }
            }
        },
        "app_securitySecurityEventsData": {
            "type": "object",
            "description": "Security events data",
            "title": "SecurityEventsData",
            "x-displayname": "Security Events Data",
            "x-ves-proto-message": "ves.io.schema.app_security.SecurityEventsData",
            "properties": {
                "count": {
                    "type": "string",
                    "description": " the number of security events for virtual host in the given namespace \n\nExample: - 15-",
                    "format": "uint64",
                    "x-displayname": "Count"
                },
                "max_time": {
                    "type": "string",
                    "description": " Maximum start time at which security event was found.\n\nExample: - \"01-01-1970T00:00:00Z\"-",
                    "title": "Maximun Time",
                    "format": "date-time",
                    "x-displayname": "Maximum time",
                    "x-ves-example": "01-01-1970T00:00:00Z"
                },
                "min_time": {
                    "type": "string",
                    "description": " Minimum time at which the secuirty event was found.\n\nExample: - \"01-01-1970T00:00:00Z\"-",
                    "title": "Minimum Time",
                    "format": "date-time",
                    "x-displayname": "Minimum time",
                    "x-ves-example": "01-01-1970T00:00:00Z"
                }
            }
        },
        "app_securitySecurityEventsRequest": {
            "type": "object",
            "description": "Request to fetch security events",
            "title": "Security Events Request",
            "x-displayname": "Security Events Request",
            "x-ves-proto-message": "ves.io.schema.app_security.SecurityEventsRequest",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the security events response. If the number of security events that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.\n Optional",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "end_time": {
                    "type": "string",
                    "description": " fetch security events whose timestamp \u003c= end_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "end time",
                    "x-displayname": "End Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "limit": {
                    "type": "integer",
                    "description": " limits the number of security events returned in the response\n Optional: If not specified, first or last 500 security events that matches the query (depending on the sort order) will be returned in the response.\n           The maximum value for limit is 500.\n\nExample: - \"100\"-",
                    "title": "limit",
                    "format": "int32",
                    "x-displayname": "Limit",
                    "x-ves-example": "100"
                },
                "namespace": {
                    "type": "string",
                    "description": " fetch security events for a given namespace\n\nExample: - \"bloggin-app-namespace-1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "bloggin-app-namespace-1"
                },
                "query": {
                    "type": "string",
                    "description": " query is used to specify the list of matchers\n syntax for query := {[\u003cmatcher\u003e]}\n \u003cmatcher\u003e := \u003cfield_name\u003e\u003coperator\u003e\"\u003cvalue\u003e\"\n \u003cfield_name\u003e := string\n   One or more of these fields in the security event may be specified in the query.\n     vh_name - name of the virtual host\n     src_site - source site\n     city - name of the city\n     country - country code\n \u003cvalue\u003e := string\n \u003coperator\u003e := [\"=\"|\"!=\"|\"=~\"|\"!~\"]\n   = : equal to\n   != : not equal to\n   =~ : regex match\n   !~ : not regex match\n When more than one matcher is specified in the query, then security events matching ALL the matchers will be returned in the response.\n Example: query={country=\"United States\", city=\"California\"} will return all security events originating from California, United States.\n\n Optional: If not specified, all the security events matching the given tenant and namespace will be returned in the response.\n\nExample: - \"query={app_type=\"blogging_app\"}\"-",
                    "title": "query",
                    "x-displayname": "Query",
                    "x-ves-example": "query={app_type=\"blogging_app\"}"
                },
                "scroll": {
                    "type": "boolean",
                    "description": " Scroll is used to retrieve large number of security events (or all security events) that matches the query.\n If scroll is set to true, the scroll_id in the response can be used in the scroll API to fetch the next\n batch of security events until there are no more security events left to return. The number of messages in each batch is determined\n by the limit field.\n Note: Scroll is used for processing large amount of data and therefore is not intended for real time user request.\n Optional: default is false\n\nExample: - \"true\"-",
                    "title": "scroll",
                    "format": "boolean",
                    "x-displayname": "Scroll",
                    "x-ves-example": "true"
                },
                "sort": {
                    "description": " Optional: default is descending order",
                    "title": "sort order",
                    "$ref": "#/definitions/schemaSortOrder",
                    "x-displayname": "Sort Order"
                },
                "sort_by": {
                    "type": "string",
                    "description": " Optional: default is sort by last_event_time",
                    "title": "sort by",
                    "x-displayname": "Sort By"
                },
                "start_time": {
                    "type": "string",
                    "description": " fetch security events whose timestamp \u003e= start_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                }
            }
        },
        "app_securitySecurityEventsResponse": {
            "type": "object",
            "description": "Response message for SecurityEventsRequest/SecurityEventsScrollRequest",
            "title": "Security Events Response",
            "x-displayname": "Security Events Response",
            "x-ves-proto-message": "ves.io.schema.app_security.SecurityEventsResponse",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the security events response. If the number of security events that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "events": {
                    "type": "array",
                    "description": " list of security events that matched the query. Contains no more than 500 messages.\n\nExample: - \"value\"-",
                    "title": "events",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Events",
                    "x-ves-example": "value"
                },
                "scroll_id": {
                    "type": "string",
                    "description": " Long Base-64 encoded string which can be used to retrieve the next batch of security events using the scroll request.\n Empty scroll_id indicates no more messages to scroll (EOF).\n Note: scroll_id is valid only for 2 minutes. i.e., If one intend to retrieve next batch of the result, then the\n       scroll request should be sent within 2 minutes upon receiving the SecurityEventsResponse.\n\nExample: - \"DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==\"-",
                    "title": "scroll id",
                    "x-displayname": "Scroll id",
                    "x-ves-example": "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ=="
                },
                "total_hits": {
                    "type": "string",
                    "description": " total number of security events that matched the query.\n\nExample: - \"0\"-",
                    "title": "total hits",
                    "format": "uint64",
                    "x-displayname": "Total Hits",
                    "x-ves-example": "0"
                }
            }
        },
        "app_securitySecurityEventsScrollRequest": {
            "type": "object",
            "description": "Scroll request is used to fetch large number of security events in multiple batches with each SecurityEventsResponse\ncontaining no more than 500 messages. To scroll through more than 500 or all WAF security events, one can use the\nSecurityEventScrollRequest. Use the scroll_id returned in the SecurityEventsResponse to fetch the next batch of security events and\none can continue this process till the scroll_id returned is \"\" which indicates no more messages to scroll.",
            "title": "Security Events Scroll Request",
            "x-displayname": "Security Events Scroll Request",
            "x-ves-proto-message": "ves.io.schema.app_security.SecurityEventsScrollRequest",
            "properties": {
                "namespace": {
                    "type": "string",
                    "description": " fetch the WAF security events scoped by namespace\n\nExample: - \"bloggin-app-namespace-1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "bloggin-app-namespace-1"
                },
                "scroll_id": {
                    "type": "string",
                    "description": " Long Base-64 encoded string which can be used to retrieve next batch of security events.\n\nExample: - \"DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==\"-",
                    "title": "scroll id",
                    "x-displayname": "Scroll ID",
                    "x-ves-example": "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ=="
                }
            }
        },
        "app_securitySecurityIncidentsAggregationRequest": {
            "type": "object",
            "description": "Request to get only aggregation data for security incidents",
            "title": "Security Incidents Aggregation Request",
            "x-displayname": "Security Incidents Aggregation Request",
            "x-ves-proto-message": "ves.io.schema.app_security.SecurityIncidentsAggregationRequest",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over security incidents response. If the number of security incidents\n that matched the query is large and cannot be returned in a single response message, user can get helpful\n insights/summary using aggregations. The aggregations are key'ed by user-defined aggregation name.\n The response will be key'ed with the same name.\n Optional",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "end_time": {
                    "type": "string",
                    "description": " Fetch security incidents whose timestamp \u003c= end_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "end time",
                    "x-displayname": "End Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " Fetch security incidents for a given namespace\n\nExample: - \"bloggin-app-namespace-1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "bloggin-app-namespace-1"
                },
                "query": {
                    "type": "string",
                    "description": " Query is used to specify the list of matchers\n syntax for query := {[\u003cmatcher\u003e]}\n \u003cmatcher\u003e := \u003cfield_name\u003e\u003coperator\u003e\"\u003cvalue\u003e\"\n \u003cfield_name\u003e := string\n   One or more of these fields in the security event may be specified in the query.\n     vh_name - name of the virtual host\n     src_site - source site\n     city - name of the city\n     country - country code\n \u003cvalue\u003e := string\n \u003coperator\u003e := [\"=\"|\"!=\"|\"=~\"|\"!~\"]\n   = : equal to\n   != : not equal to\n   =~ : regex match\n   !~ : not regex match\n When more than one matcher is specified in the query, then security incidents matching ALL the matchers will be\n returned in the response.\n Example: query={country=\"United States\", city=\"California\"} will return all security incidents originating from\n California, United States.\n\n Optional: If not specified, all security incidents matching the given tenant and namespace will be returned in\n the response.\n\nExample: - \"query={app_type=\"blogging_app\"}\"-",
                    "title": "query",
                    "x-displayname": "Query",
                    "x-ves-example": "query={app_type=\"blogging_app\"}"
                },
                "start_time": {
                    "type": "string",
                    "description": " Fetch security incidents whose timestamp \u003e= start_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                }
            }
        },
        "app_securitySecurityIncidentsAggregationResponse": {
            "type": "object",
            "description": "Response message for SecurityIncidentsAggregationRequest",
            "title": "Security Incidents Aggregation Response",
            "x-displayname": "Security Incidents Aggregation Response",
            "x-ves-proto-message": "ves.io.schema.app_security.SecurityIncidentsAggregationResponse",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the security incidents response. If the number of security incidents\n that matched the query is large and cannot be returned in a single response message, user can get helpful\n insights/summary using aggregations. The aggregation data is key'ed with the aggregation name specified in the request.",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "total_hits": {
                    "type": "string",
                    "description": " Total number of security incidents that matched the query.\n\nExample: - \"0\"-",
                    "title": "total hits",
                    "format": "uint64",
                    "x-displayname": "Total Hits",
                    "x-ves-example": "0"
                }
            }
        },
        "app_securitySecurityIncidentsRequest": {
            "type": "object",
            "description": "Request to fetch security incidents",
            "title": "Security Incidents Request",
            "x-displayname": "Security Incidents Request",
            "x-ves-proto-message": "ves.io.schema.app_security.SecurityIncidentsRequest",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the security incidents response. If the number of security incidents\n that matched the query is large and cannot be returned in a single response message, user can get helpful\n insights/summary using aggregations. The aggregations are key'ed by user-defined aggregation name. The response\n will be key'ed with the same name.\n Optional",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "end_time": {
                    "type": "string",
                    "description": " Fetch security incidents whose timestamp \u003c= end_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "end time",
                    "x-displayname": "End Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "limit": {
                    "type": "integer",
                    "description": " Limits the number of security incidents returned in the response\n Optional: If not specified, first or last 500 security events that matches the query (depending on the sort order) will be returned in the response.\n           The maximum value for limit is 500.\n\nExample: - \"100\"-",
                    "title": "limit",
                    "format": "int32",
                    "x-displayname": "Limit",
                    "x-ves-example": "100"
                },
                "namespace": {
                    "type": "string",
                    "description": " Fetch security incidents for a given namespace\n\nExample: - \"bloggin-app-namespace-1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "bloggin-app-namespace-1"
                },
                "query": {
                    "type": "string",
                    "description": " Query is used to specify the list of matchers\n syntax for query := {[\u003cmatcher\u003e]}\n \u003cmatcher\u003e := \u003cfield_name\u003e\u003coperator\u003e\"\u003cvalue\u003e\"\n \u003cfield_name\u003e := string\n   One or more of these fields in the security incident may be specified in the query.\n     vh_name - name of the virtual host\n     src_site - source site\n     city - name of the city\n     country - country code\n \u003cvalue\u003e := string\n \u003coperator\u003e := [\"=\"|\"!=\"|\"=~\"|\"!~\"]\n   = : equal to\n   != : not equal to\n   =~ : regex match\n   !~ : not regex match\n When more than one matcher is specified in the query, then security incidents matching ALL the matchers will be returned in the response.\n Example: query={country=\"United States\", city=\"California\"} will return all security events originating from California, United States.\n\n Optional: If not specified, all the security events matching the given tenant and namespace will be returned in the response.\n\nExample: - \"query={app_type=\"blogging_app\"}\"-",
                    "title": "query",
                    "x-displayname": "Query",
                    "x-ves-example": "query={app_type=\"blogging_app\"}"
                },
                "scroll": {
                    "type": "boolean",
                    "description": " Scroll is used to retrieve large number of security incidents (or all security incidents) that matches the query.\n If scroll is set to true, the scroll_id in the response can be used in the scroll API to fetch the next\n batch of security events until there are no more security events left to return. The number of messages in each\n batch is determined by the limit field.\n Note: Scroll is used for processing large amount of data and therefore is not intended for real time user request.\n Optional: default is false\n\nExample: - \"true\"-",
                    "title": "scroll",
                    "format": "boolean",
                    "x-displayname": "Scroll",
                    "x-ves-example": "true"
                },
                "sort": {
                    "description": " Optional: default is descending order",
                    "title": "sort order",
                    "$ref": "#/definitions/schemaSortOrder",
                    "x-displayname": "Sort Order"
                },
                "sort_by": {
                    "type": "string",
                    "description": " Optional: default is sort by last_event_time",
                    "title": "sort by",
                    "x-displayname": "Sort By"
                },
                "start_time": {
                    "type": "string",
                    "description": " Fetch security incidents whose timestamp \u003e= start_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                }
            }
        },
        "app_securitySecurityIncidentsResponse": {
            "type": "object",
            "description": "Response message for SecurityIncidentsRequest/SecurityIncidentsScrollRequest",
            "title": "Security Incidents Response",
            "x-displayname": "Security Incidents Response",
            "x-ves-proto-message": "ves.io.schema.app_security.SecurityIncidentsResponse",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the security incidents response. If the number of security incidents\n that matched the query is large and cannot be returned in a single response message, user can get helpful\n insights/summary using aggregations.",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "incidents": {
                    "type": "array",
                    "description": " list of security incidents that matched the query. Contains no more than 500 messages.\n\nExample: - \"value\"-",
                    "title": "incidents",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Incidents",
                    "x-ves-example": "value"
                },
                "scroll_id": {
                    "type": "string",
                    "description": " Long Base-64 encoded string which can be used to retrieve the next batch of security incidents using the scroll\n request.\n Empty scroll_id indicates no more messages to scroll (EOF).\n Note: scroll_id is valid only for 2 minutes. i.e., If one intend to retrieve next batch of the result, then the\n       scroll request should be sent within 2 minutes upon receiving the SecurityIncidentsResponse.\n\nExample: - \"DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==\"-",
                    "title": "scroll id",
                    "x-displayname": "Scroll id",
                    "x-ves-example": "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ=="
                },
                "total_hits": {
                    "type": "string",
                    "description": " total number of security events that matched the query.\n\nExample: - \"0\"-",
                    "title": "total hits",
                    "format": "uint64",
                    "x-displayname": "Total Hits",
                    "x-ves-example": "0"
                }
            }
        },
        "app_securitySecurityIncidentsScrollRequest": {
            "type": "object",
            "description": "Scroll request is used to fetch large number of security incidents in multiple batches with each SecurityIncidentsResponse\ncontaining no more than 500 messages. To scroll through more than 500 or all security incidents, one can use the\nSecurityIncidentsScrollRequest. Use the scroll_id returned in the SecurityIncidentsResponse to fetch the next batch\nof security events and one can continue this process till the scroll_id returned is \"\" which indicates no more\nmessages to scroll.",
            "title": "Security Incidents Scroll Request",
            "x-displayname": "Security Incidents Scroll Request",
            "x-ves-proto-message": "ves.io.schema.app_security.SecurityIncidentsScrollRequest",
            "properties": {
                "namespace": {
                    "type": "string",
                    "description": " Fetch security incidents for a given namespace\n\nExample: - \"bloggin-app-namespace-1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "bloggin-app-namespace-1"
                },
                "scroll_id": {
                    "type": "string",
                    "description": " Long Base-64 encoded string which can be used to retrieve next batch of security events.\n\nExample: - \"DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==\"-",
                    "title": "scroll id",
                    "x-displayname": "Scroll ID",
                    "x-ves-example": "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ=="
                }
            }
        },
        "app_securitySuspiciousUserLogsAggregationRequest": {
            "type": "object",
            "description": "Request to get only aggregation data for suspicious user logs",
            "title": "Suspicious User Logs Aggregation Request",
            "x-displayname": "Suspicious User Logs Aggregation Request",
            "x-ves-proto-message": "ves.io.schema.app_security.SuspiciousUserLogsAggregationRequest",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the suspicious user logs response. If the number of logs that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.\n Optional",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "end_time": {
                    "type": "string",
                    "description": " fetch suspicious user logs whose timestamp \u003c= end_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "end time",
                    "x-displayname": "End Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " fetch suspicious user logs for a given namespace\n\nExample: - \"bloggin-app-namespace-1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "bloggin-app-namespace-1"
                },
                "query": {
                    "type": "string",
                    "description": " query is used to specify the list of matchers\n syntax for query := {[\u003cmatcher\u003e]}\n \u003cmatcher\u003e := \u003cfield_name\u003e\u003coperator\u003e\"\u003cvalue\u003e\"\n \u003cfield_name\u003e := string\n   One or more of these fields in the suspicious user logs may be specified in the query.\n     vh_name - name of the virtual host\n     user - user id\n     site - source site\n     city - name of the city\n     country - country code\n \u003cvalue\u003e := string\n \u003coperator\u003e := [\"=\"|\"!=\"|\"=~\"|\"!~\"]\n   = : equal to\n   != : not equal to\n   =~ : regex match\n   !~ : not regex match\n When more than one matcher is specified in the query, then suspicious user logs matching ALL the matchers will be returned in the response.\n\n Optional: If not specified, all the suspicious user logs matching the given tenant and namespace will be returned in the response.\n\nExample: - \"query={vh_name=\"vh-1\", site=\"ce-01\"}\"-",
                    "title": "query",
                    "x-displayname": "Query",
                    "x-ves-example": "query={vh_name=\"vh-1\", site=\"ce-01\"}"
                },
                "start_time": {
                    "type": "string",
                    "description": " fetch suspicious user logs whose timestamp \u003e= start_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                }
            }
        },
        "app_securitySuspiciousUserLogsAggregationResponse": {
            "type": "object",
            "description": "Response message for SuspiciousUserLogsAggregationRequest",
            "title": "Suspicious User Logs Aggregation Response",
            "x-displayname": "Suspicious User Logs Aggregation Response",
            "x-ves-proto-message": "ves.io.schema.app_security.SuspiciousUserLogsAggregationResponse",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the suspicious user logs response. If the number of logs that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregation data is key'ed with the aggregation name specified in the request.",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "total_hits": {
                    "type": "string",
                    "description": " total number of suspicious user logs that matched the query.\n\nExample: - \"1400\"-",
                    "title": "total hits",
                    "format": "uint64",
                    "x-displayname": "Total Hits",
                    "x-ves-example": "1400"
                }
            }
        },
        "app_securitySuspiciousUserLogsRequest": {
            "type": "object",
            "description": "Request to fetch suspicious user logs",
            "title": "Suspicious User Logs Request",
            "x-displayname": "Suspicious User Logs Request",
            "x-ves-proto-message": "ves.io.schema.app_security.SuspiciousUserLogsRequest",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the suspicious user logs response. If the number of logs that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.\n The aggregations are key'ed by user-defined aggregation name. The response will be key'ed with the same name.\n Optional",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "end_time": {
                    "type": "string",
                    "description": " fetch suspicious user logs whose timestamp \u003c= end_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the end_time will be evaluated to start_time+10m\n           If start_time is not specified, then the end_time will be evaluated to \u003ccurrent time\u003e\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "end time",
                    "x-displayname": "End Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                },
                "limit": {
                    "type": "integer",
                    "description": " limits the number of logs returned in the response\n Optional: If not specified, first or last 500 logs that matches the query (depending on the sort order) will be returned in the response.\n           The maximum value for limit is 500.\n\nExample: - \"100\"-",
                    "title": "limit",
                    "format": "int32",
                    "x-displayname": "Limit",
                    "x-ves-example": "100"
                },
                "namespace": {
                    "type": "string",
                    "description": " fetch suspicious user logs for a given namespace\n\nExample: - \"bloggin-app-namespace-1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "bloggin-app-namespace-1"
                },
                "query": {
                    "type": "string",
                    "description": " query is used to specify the list of matchers\n syntax for query := {[\u003cmatcher\u003e]}\n \u003cmatcher\u003e := \u003cfield_name\u003e\u003coperator\u003e\"\u003cvalue\u003e\"\n \u003cfield_name\u003e := string\n   One or more of these fields in the suspicious user logs may be specified in the query.\n     vh_name - name of the virtual host\n     user - user id\n     site - source site\n     city - name of the city\n     country - country code\n \u003cvalue\u003e := string\n \u003coperator\u003e := [\"=\"|\"!=\"|\"=~\"|\"!~\"]\n   = : equal to\n   != : not equal to\n   =~ : regex match\n   !~ : not regex match\n When more than one matcher is specified in the query, then suspicious user logs matching ALL the matchers will be returned in the response.\n\n Optional: If not specified, all the suspicious user logs matching the given tenant and namespace will be returned in the response.\n\nExample: - \"query={vh_name=\"vh-1\", site=\"ce-01\"}\"-",
                    "title": "query",
                    "x-displayname": "Query",
                    "x-ves-example": "query={vh_name=\"vh-1\", site=\"ce-01\"}"
                },
                "scroll": {
                    "type": "boolean",
                    "description": " Scroll is used to retrieve large number of logs (or all logs) that matches the query.\n If scroll is set to true, the scroll_id in the response can be used in the scroll API to fetch the next\n batch of logs until there are no logs left to return. The number of logs in each batch is determined\n by the limit field.\n Note: Scroll is used for processing large amount of data and therefore is not intended for real time user request.\n Optional: default is false\n\nExample: - \"true\"-",
                    "title": "scroll",
                    "format": "boolean",
                    "x-displayname": "Scroll",
                    "x-ves-example": "true"
                },
                "sort": {
                    "description": " Optional: default is descending order",
                    "title": "sort order",
                    "$ref": "#/definitions/schemaSortOrder",
                    "x-displayname": "Sort Order"
                },
                "sort_by": {
                    "type": "string",
                    "description": " Optional: default is sort by last_event_time",
                    "title": "sort by",
                    "x-displayname": "Sort By"
                },
                "start_time": {
                    "type": "string",
                    "description": " fetch suspicious user logs whose timestamp \u003e= start_time\n format: unix_timestamp|rfc 3339\n\n Optional: If not specified, then the start_time will be evaluated to end_time-10m\n           If end_time is not specified, then the start_time will be evaluated to \u003ccurrent time\u003e-10m\n\nExample: - \"1570007981\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.query_time: true\n",
                    "title": "start time",
                    "x-displayname": "Start Time",
                    "x-ves-example": "1570007981",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.query_time": "true"
                    }
                }
            }
        },
        "app_securitySuspiciousUserLogsResponse": {
            "type": "object",
            "description": "Response message for Suspicious User Logs Request",
            "title": "Suspicious User Logs Response",
            "x-displayname": "Suspicious User Logs Response",
            "x-ves-proto-message": "ves.io.schema.app_security.SuspiciousUserLogsResponse",
            "properties": {
                "aggs": {
                    "type": "object",
                    "description": " Aggregations provide summary/analytics data over the security events response. If the number of security events that matched the query\n is large and cannot be returned in a single response message, user can get helpful insights/summary using aggregations.",
                    "title": "aggregations",
                    "x-displayname": "Aggregations"
                },
                "logs": {
                    "type": "array",
                    "description": " list of log messages that matched the query. Contains no more than 500 messages.\n\nExample: - \"value\"-",
                    "title": "events",
                    "items": {
                        "type": "string"
                    },
                    "x-displayname": "Events",
                    "x-ves-example": "value"
                },
                "scroll_id": {
                    "type": "string",
                    "description": " Long Base-64 encoded string which can be used to retrieve the next batch of suspicous user logs using the scroll request.\n Empty scroll_id indicates no more messages to scroll (EOF).\n Note: scroll_id is valid only for 2 minutes. i.e., If one intend to retrieve next batch of the result, then the\n       scroll request should be sent within 2 minutes upon receiving the SuspiciousUserLogsResponse.\n\nExample: - \"DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==\"-",
                    "title": "scroll id",
                    "x-displayname": "Scroll id",
                    "x-ves-example": "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ=="
                },
                "total_hits": {
                    "type": "string",
                    "description": " total number of logs that matched the query.\n\nExample: - \"100\"-",
                    "title": "total hits",
                    "format": "uint64",
                    "x-displayname": "Total Hits",
                    "x-ves-example": "100"
                }
            }
        },
        "app_securitySuspiciousUserLogsScrollRequest": {
            "type": "object",
            "description": "Scroll request is used to fetch large number of suspicious user logs in multiple batches with each SuspiciousUserLogsResponse\ncontaining no more than 500 messages. To scroll through more than 500 or all messages, one can use the\nSuspiciousUserLogsScrollRequest. Use the scroll_id returned in the SuspiciousUserLogsResponse to fetch the next batch of logs \nand one can continue this process till the scroll_id returned is \"\" which indicates no more logs to scroll.",
            "title": "Suspicious User Logs Scroll Request",
            "x-displayname": "Suspicious User Logs Scroll Request",
            "x-ves-proto-message": "ves.io.schema.app_security.SuspiciousUserLogsScrollRequest",
            "properties": {
                "namespace": {
                    "type": "string",
                    "description": " fetch the next batch of suspicious user logs scoped by namespace\n\nExample: - \"bloggin-app-namespace-1\"-",
                    "title": "namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "bloggin-app-namespace-1"
                },
                "scroll_id": {
                    "type": "string",
                    "description": " Long Base-64 encoded string which can be used to retrieve next batch of security events.\n\nExample: - \"DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==\"-",
                    "title": "scroll id",
                    "x-displayname": "Scroll ID",
                    "x-ves-example": "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ=="
                }
            }
        },
        "app_securityincidentsAggregationRequest": {
            "type": "object",
            "description": "x-displayName: \"Aggregation Request\"\nAggregation request to provide analytics data over the log response",
            "title": "Aggregation Request",
            "properties": {
                "cardinality_aggregation": {
                    "description": "x-displayName: \"Cardinality Aggregation\"\nGet approximate count of distinct values for a field in the incident",
                    "title": "Cardinality Aggregation",
                    "$ref": "#/definitions/app_securityincidentsCardinalityAggregation"
                },
                "date_aggregation": {
                    "description": "x-displayName: \"Date Aggregation\"\nAggregate based on timestamp in the incident",
                    "title": "Date Aggregation",
                    "$ref": "#/definitions/app_securityincidentsDateAggregation"
                },
                "field_aggregation": {
                    "description": "x-displayName: \"Field Aggregation\"\nAggregate based on one of the key fields in the incident",
                    "title": "Field Aggregation",
                    "$ref": "#/definitions/app_securityincidentsFieldAggregation"
                },
                "metrics_aggregation": {
                    "description": "x-displayName: \"Metrics Aggregation\"\nComputes metrics based on values for the field in the incident",
                    "title": "Metrics Aggregation",
                    "$ref": "#/definitions/app_securityincidentsMetricsAggregation"
                },
                "multi_field_aggregation": {
                    "description": "x-displayName: \"Multi-Field Aggregation\"\nAggregate based on multiple key fields in the incident",
                    "title": "Multi-Field Aggregation",
                    "$ref": "#/definitions/app_securityincidentsMultiFieldAggregation"
                }
            }
        },
        "app_securityincidentsCardinalityAggregation": {
            "type": "object",
            "description": "x-displayName: \"Cardinality Aggregation\"\nGet approximate count of distinct values for the field in the incident.",
            "title": "Cardinality Aggregation",
            "properties": {
                "field": {
                    "description": "x-displayName: \"Field\"\nx-required\n\nField name for which count of distinct values should be computed.",
                    "title": "field",
                    "$ref": "#/definitions/app_securityincidentsKeyField"
                }
            }
        },
        "app_securityincidentsDateAggregation": {
            "type": "object",
            "description": "x-displayName: \"Date Aggregation\"\nAggregate incidents based on timestamp in the log",
            "title": "Date Aggregation",
            "properties": {
                "step": {
                    "type": "string",
                    "description": "x-displayName: \"Step\"\nx-required\nx-example: \"5m\"\n\nstep is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.\nThe timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn \u003c= end_time.\nFormat: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days",
                    "title": "step"
                },
                "sub_aggs": {
                    "type": "object",
                    "description": "x-displayName: \"Sub Aggregation\"\nThis option provides sub-aggregation for each date bucket",
                    "title": "sub aggregation"
                }
            }
        },
        "app_securityincidentsDateSubAggregation": {
            "type": "object",
            "description": "x-displayName: \"Date SubAggregation\"\nAggregate security events based on one of the sub aggregation types",
            "title": "Date SubAggregation",
            "properties": {
                "field_aggregation": {
                    "description": "x-displayName: \"Field Aggregation\"\nAggregate based on one of the key fields in the security event",
                    "title": "Field Aggregation",
                    "$ref": "#/definitions/app_securityincidentsFieldAggregation"
                },
                "multi_field_aggregation": {
                    "description": "x-displayName: \"Multi Field Aggregation\"\nAggregate based on one of the mutiple key fields in the security event",
                    "title": "Multi Field Aggregation",
                    "$ref": "#/definitions/app_securityincidentsMultiFieldAggregation"
                }
            }
        },
        "app_securityincidentsFieldAggregation": {
            "type": "object",
            "description": "x-displayName: \"Field Aggregation\"\nAggregate incidents based on the key fields in the security event.",
            "title": "Field Aggregation",
            "properties": {
                "field": {
                    "description": "x-displayName: \"Field\"\nx-required\n\nField name by which the security events should be aggregated.",
                    "title": "field",
                    "$ref": "#/definitions/app_securityincidentsKeyField"
                },
                "metrics_aggregation": {
                    "description": "x-displayName: \"Metrics Aggregation\"\nComputes metrics based on values for the field in the incident",
                    "title": "Metrics Aggregation",
                    "$ref": "#/definitions/app_securityincidentsMetricsAggregation"
                },
                "sub_aggs": {
                    "type": "object",
                    "description": "x-displayName: \"Sub Aggregation\"\nThis option provides sub-aggregation for each field aggregation bucket.",
                    "title": "sub aggregation"
                },
                "topk": {
                    "type": "integer",
                    "description": "x-displayName: \"TopK\"\nx-example: \"10\"\n\nNumber of top field values to be returned in the response.",
                    "title": "topk",
                    "format": "int64"
                }
            }
        },
        "app_securityincidentsFieldSubAggregation": {
            "type": "object",
            "description": "x-displayName: \"Field SubAggregation\"\nAggregate security events in each field bucket based on one of the sub aggregation types",
            "title": "Field SubAggregation",
            "properties": {
                "cardinality_aggregation": {
                    "description": "x-displayName: \"Cardinality Aggregation\"\nGet approximate count of distinct values for a field",
                    "title": "Cardinality Aggregation",
                    "$ref": "#/definitions/app_securityincidentsCardinalityAggregation"
                }
            }
        },
        "app_securityincidentsKeyField": {
            "type": "string",
            "description": "x-displayName: \"Key Field\"\nSecurity events can be aggregated based on these fields.\n\n - CITY: x-displayName: \"City\"\n - COUNTRY: x-displayName: \"Country\"\n - ASN: x-displayName: \"ASN\"\n - INCIDENT_TYPE: x-displayName: \"Incident Type\"\n - INTENT: x-displayName: \"Intent\"\n - VH_NAME: x-displayName: \"Virtual Host Name\"\n - USER_ID: x-displayName: \"User ID\"\n - SRC_IP: x-displayName: \"Source IP\"\n - TLS_FINGERPRINT: x-displayName: \"JA3 TLS Fingerprint\"\n - LAST_STATUS: x-displayName: \"Last Status\"\n - INCIDENT_ID: x-displayName: \"Incident ID\"",
            "title": "Key Field",
            "enum": [
                "CITY",
                "COUNTRY",
                "ASN",
                "INCIDENT_TYPE",
                "INTENT",
                "VH_NAME",
                "USER_ID",
                "SRC_IP",
                "TLS_FINGERPRINT",
                "LAST_STATUS",
                "INCIDENT_ID"
            ],
            "default": "CITY"
        },
        "app_securityincidentsMetricField": {
            "type": "string",
            "description": "x-displayName: \"Metric Field\"\nMetrics can be computed based on these fields.\n\n - EVENTS: x-displayName: \"Events\"",
            "title": "Metric Field",
            "enum": [
                "EVENTS"
            ],
            "default": "EVENTS"
        },
        "app_securityincidentsMetricsAggregation": {
            "type": "object",
            "description": "x-displayName: \"Metrics Aggregation\"\nComputes metrics based on values for the field in the incident.",
            "title": "Metrics Aggregation",
            "properties": {
                "percentile": {
                    "description": "x-displayName: \"Percentile Aggregation\"\nCalculates percentile over numeric values for a field",
                    "title": "Percentile Aggregation",
                    "$ref": "#/definitions/app_securityincidentsPercentileAggregation"
                }
            }
        },
        "app_securityincidentsMultiFieldAggregation": {
            "type": "object",
            "description": "x-displayName: \"Multi-Field Aggregation\"\nAggregate incidents based on the multiple fields in the incident.",
            "title": "Multi-Field Aggregation",
            "properties": {
                "field": {
                    "description": "x-displayName: \"Field\"\nx-required\n\nMulti-key field by which the security events should be aggregated.",
                    "title": "field",
                    "$ref": "#/definitions/app_securityincidentsMultiKeyField"
                },
                "metrics_aggregation": {
                    "description": "x-displayName: \"Metrics Aggregation\"\nComputes metrics based on values for the field in the incident",
                    "title": "Metrics Aggregation",
                    "$ref": "#/definitions/app_securityincidentsMetricsAggregation"
                },
                "sub_aggs": {
                    "type": "object",
                    "description": "x-displayName: \"Sub Aggregation\"\nThis option provides sub-aggregation for each field aggregation bucket.",
                    "title": "sub aggregation"
                },
                "topk": {
                    "type": "integer",
                    "description": "x-displayName: \"TopK\"\nx-example: \"10\"\n\nNumber of top field values to be returned in the response.",
                    "title": "topk",
                    "format": "int64"
                }
            }
        },
        "app_securityincidentsMultiFieldSubAggregation": {
            "type": "object",
            "description": "x-displayName: \"Multi Field SubAggregation\"\nAggregate security events in each MultiTerms bucket based on one of the sub aggregation types",
            "title": "Multi Field SubAggregation",
            "properties": {
                "cardinality_aggregation": {
                    "description": "x-displayName: \"Cardinality Aggregation\"\nGet approximate count of distinct values for a field",
                    "title": "Cardinality Aggregation",
                    "$ref": "#/definitions/app_securityincidentsCardinalityAggregation"
                }
            }
        },
        "app_securityincidentsMultiKeyField": {
            "type": "string",
            "description": "x-displayName: \"Multi-Key Field\"\nSecurity events can be aggregated based on these multiple key fields\n\n - SRC_IP_TLS_FINGERPRINT: x-displayName: \"Source IP, JA3 TLS Fingerprint\"\nAggregated by (KeyField.SRC_IP, KeyField.TLS_FINGERPRINT)",
            "title": "Multi-Key Field",
            "enum": [
                "SRC_IP_TLS_FINGERPRINT"
            ],
            "default": "SRC_IP_TLS_FINGERPRINT"
        },
        "app_securityincidentsPercentileAggregation": {
            "type": "object",
            "description": "x-displayName: \"Percentile Aggregation\"\nCalculates percentile over numeric values for a field.",
            "title": "Percentile Aggregation",
            "properties": {
                "field": {
                    "description": "x-displayName: \"Field\"\nx-required\n\nField name for which percentile of values should be computed.",
                    "title": "field",
                    "$ref": "#/definitions/app_securityincidentsMetricField"
                },
                "percent": {
                    "type": "number",
                    "description": "x-displayName: \"Percent\"\nx-example: \"[99.0]\"\nx-required\n\nPercentile for which value is calculated.",
                    "title": "percent",
                    "format": "double"
                }
            }
        },
        "app_securitysuspicious_user_logAggregationRequest": {
            "type": "object",
            "description": "x-displayName: \"Aggregation Request\"\nAggregation request to provide analytics data over the log response",
            "title": "Aggregation Request",
            "properties": {
                "avg_aggregation": {
                    "description": "x-displayName: \"Avg Aggregation\"\nGet the average value of the numeric values for field in the suspicious user log",
                    "title": "Average Aggregation",
                    "$ref": "#/definitions/suspicious_user_logAvgAggregation"
                },
                "cardinality_aggregation": {
                    "description": "x-displayName: \"Cardinality Aggregation\"\nGet approximate count of distinct values for a field in the suspicious user log",
                    "title": "Cardinality Aggregation",
                    "$ref": "#/definitions/app_securitysuspicious_user_logCardinalityAggregation"
                },
                "date_aggregation": {
                    "description": "x-displayName: \"Date Aggregation\"\nAggregate based on timestamp in the log",
                    "title": "Date Aggregation",
                    "$ref": "#/definitions/app_securitysuspicious_user_logDateAggregation"
                },
                "field_aggregation": {
                    "description": "x-displayName: \"Field Aggregation\"\nAggregate based on one of the key fields in the suspicious user log",
                    "title": "Field Aggregation",
                    "$ref": "#/definitions/app_securitysuspicious_user_logFieldAggregation"
                },
                "max_aggregation": {
                    "description": "x-displayName: \"Max Aggregation\"\nGet the maximum value among the numeric values for a field in the suspicious user log",
                    "title": "Max Aggregation",
                    "$ref": "#/definitions/suspicious_user_logMaxAggregation"
                },
                "metrics_aggregation": {
                    "description": "x-displayName: \"Metrics Aggregation\"\nComputes metrics based on values for the field in the suspicious user log",
                    "title": "Metrics Aggregation",
                    "$ref": "#/definitions/app_securitysuspicious_user_logMetricsAggregation"
                },
                "min_aggregation": {
                    "description": "x-displayName: \"Min Aggregation\"\nGet the minimum value among the numeric values for a field in the suspicious user log",
                    "title": "Min Aggregation",
                    "$ref": "#/definitions/suspicious_user_logMinAggregation"
                }
            }
        },
        "app_securitysuspicious_user_logCardinalityAggregation": {
            "type": "object",
            "description": "x-displayName: \"Cardinality Aggregation\"\nGet approximate count of distinct values for the field in the suspicious user log.",
            "title": "Cardinality Aggregation",
            "properties": {
                "field": {
                    "description": "x-displayName: \"Field\"\nx-required\n\nField name for which count of distinct values should be computed.",
                    "title": "field",
                    "$ref": "#/definitions/app_securitysuspicious_user_logKeyField"
                }
            }
        },
        "app_securitysuspicious_user_logDateAggregation": {
            "type": "object",
            "description": "x-displayName: \"Date Aggregation\"\nAggregate suspicious user logs based on timestamp in the log",
            "title": "Date Aggregation",
            "properties": {
                "step": {
                    "type": "string",
                    "description": "x-displayName: \"Step\"\nx-required\nx-example: \"5m\"\n\nstep is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.\nThe timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn \u003c= end_time.\nFormat: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days",
                    "title": "step"
                }
            }
        },
        "app_securitysuspicious_user_logFieldAggregation": {
            "type": "object",
            "description": "x-displayName: \"Field Aggregation\"\nAggregate incidents based on the key fields in the suspicious user log.",
            "title": "Field Aggregation",
            "properties": {
                "field": {
                    "description": "x-displayName: \"Field\"\nx-required\n\nField name by which the suspicious user logs should be aggregated.",
                    "title": "field",
                    "$ref": "#/definitions/app_securitysuspicious_user_logKeyField"
                },
                "metrics_aggregation": {
                    "description": "x-displayName: \"Metrics Aggregation\"\nComputes metrics based on values for the field in the suspicious user log",
                    "title": "Metrics Aggregation",
                    "$ref": "#/definitions/app_securitysuspicious_user_logMetricsAggregation"
                },
                "sub_aggs": {
                    "type": "object",
                    "description": "x-displayName: \"Sub Aggregation\"\nThis option provides sub-aggregation for each field aggregation bucket.",
                    "title": "sub aggregation"
                },
                "topk": {
                    "type": "integer",
                    "description": "x-displayName: \"TopK\"\nx-example: \"10\"\n\nNumber of top field values to be returned in the response.",
                    "title": "topk",
                    "format": "int64"
                }
            }
        },
        "app_securitysuspicious_user_logFieldSubAggregation": {
            "type": "object",
            "description": "x-displayName: \"Field SubAggregation\"\nAggregate security events in each field bucket based on one of the sub aggregation types",
            "title": "Field SubAggregation",
            "properties": {
                "cardinality_aggregation": {
                    "description": "x-displayName: \"Cardinality Aggregation\"\nGet approximate count of distinct values for a field",
                    "title": "Cardinality Aggregation",
                    "$ref": "#/definitions/app_securitysuspicious_user_logCardinalityAggregation"
                }
            }
        },
        "app_securitysuspicious_user_logKeyField": {
            "type": "string",
            "description": "x-displayName: \"Key Field\"\nSecurity events can be aggregated based on these fields.\n\n - CITY: x-displayName: \"City\"\n - COUNTRY: x-displayName: \"Country\"\n - ASN: x-displayName: \"ASN\"\n - USER: x-displayName: \"User\"\n - THREAT_LEVEL: x-displayName: \"Threat Level\"\n - VH_NAME: x-displayName: \"Virtual Host Name\"\n - SRC_IP: x-displayName: \"Source IP\"\n - SUSPICION_LOG_TYPE: x-displayName: \"Suspicion Log Type\"",
            "title": "Key Field",
            "enum": [
                "CITY",
                "COUNTRY",
                "ASN",
                "USER",
                "THREAT_LEVEL",
                "VH_NAME",
                "SRC_IP",
                "SUSPICION_LOG_TYPE"
            ],
            "default": "CITY"
        },
        "app_securitysuspicious_user_logMetricsAggregation": {
            "type": "object",
            "description": "x-displayName: \"Metrics Aggregation\"\nComputes metrics based on values for the field in the suspicious user log.",
            "title": "Metrics Aggregation",
            "properties": {
                "percentile": {
                    "description": "x-displayName: \"Percentile Aggregation\"\nCalculates percentile over numeric values for a field",
                    "title": "Percentile Aggregation",
                    "$ref": "#/definitions/app_securitysuspicious_user_logPercentileAggregation"
                }
            }
        },
        "app_securitysuspicious_user_logPercentileAggregation": {
            "type": "object",
            "description": "x-displayName: \"Percentile Aggregation\"\nCalculates percentile over numeric values for a field.",
            "title": "Percentile Aggregation",
            "properties": {
                "field": {
                    "description": "x-displayName: \"Field\"\nx-required\n\nField name for which percentile of values should be computed.",
                    "title": "field",
                    "$ref": "#/definitions/suspicious_user_logNumKeyField"
                },
                "percent": {
                    "type": "number",
                    "description": "x-displayName: \"Percent\"\nx-example: \"[99.0]\"\nx-required\n\nPercentile for which value is calculated.",
                    "title": "percent",
                    "format": "double"
                }
            }
        },
        "logAvgAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Avg Aggregation Data\"\nAverage Aggregation data",
            "title": "AvgAggregationData",
            "properties": {
                "value": {
                    "type": "number",
                    "description": "x-displayName: \"Value\"\nx-example: 985.0\n\nvalue corresponding to the average value of field",
                    "title": "value",
                    "format": "double"
                }
            }
        },
        "logCardinalityAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Cardinality Aggregation Data\"\nApproximate count of distinct values of the log field specified in the request.",
            "title": "CardinalityAggregationData",
            "properties": {
                "count": {
                    "type": "string",
                    "description": "x-displayName: \"Count\"\nx-example: 100\nCount of distinct values of a log field",
                    "title": "count",
                    "format": "uint64"
                },
                "trend_value": {
                    "description": "x-displayName: \"Trend Value\"\ntrend value for the cardinality aggregation field.",
                    "title": "Trend value",
                    "$ref": "#/definitions/schemaTrendValue"
                }
            }
        },
        "logDateAggregationBucket": {
            "type": "object",
            "description": "x-displayName: \"Date Aggregation Bucket\"\nDate histogram bucket containing the timestamp and the number of logs in that bucket.",
            "title": "DateAggregationBucket",
            "properties": {
                "count": {
                    "type": "string",
                    "description": "x-displayName: \"Count\"\nx-example: 45\n\nnumber of logs in this bucket",
                    "title": "count",
                    "format": "uint64"
                },
                "sub_aggs": {
                    "type": "object",
                    "description": "x-displayName: \"Sub Aggregation\"\nSub aggregation data for the date bucket",
                    "title": "sub aggregation"
                },
                "time": {
                    "type": "string",
                    "description": "x-displayName: \"Time\"\nx-example: 1578710280000\n\nunix timestamp",
                    "title": "time",
                    "format": "uint64"
                },
                "trend_value": {
                    "description": "x-displayName: \"Trend Value\"\ntrend value for the key present in the date aggregation bucket",
                    "title": "Trend value",
                    "$ref": "#/definitions/schemaTrendValue"
                }
            }
        },
        "logDateAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Date Aggregation Data\"\nDate aggregation data",
            "title": "DateAggregationData",
            "properties": {
                "buckets": {
                    "type": "array",
                    "description": "x-displayName: \"Buckets\"\nLists of buckets containing timestamp and the corresponding log count",
                    "title": "buckets",
                    "items": {
                        "$ref": "#/definitions/logDateAggregationBucket"
                    }
                },
                "step": {
                    "type": "string",
                    "description": "x-displayName: \"Step\"\nx-example: \"30m\"\nActual step size in the response. It could be higher than the requested step depending on the query duration and/or the log rollups.\nFormat: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days",
                    "title": "step"
                }
            }
        },
        "logDateSubAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Date SubAggregation\"\n\nDate subaggregation data",
            "title": "DateSubAggregationData",
            "properties": {
                "field_aggregation": {
                    "description": "Field aggregation data",
                    "title": "field aggregation\nx-displayName: \"Field Aggregation\"",
                    "$ref": "#/definitions/logFieldAggregationData"
                },
                "multi_field_aggregation": {
                    "description": "Field aggregation data",
                    "title": "mulifield aggregation\nx-displayName: \"Multi Field Aggregation\"",
                    "$ref": "#/definitions/logMultiFieldAggregationData"
                }
            }
        },
        "logFieldAggregationBucket": {
            "type": "object",
            "description": "x-displayName: \"Field Aggregation Bucket\"\nField aggregation bucket containing field value and the number of logs.",
            "title": "FieldAggregationBucket",
            "properties": {
                "count": {
                    "type": "string",
                    "description": "x-displayName: \"Count\"\nx-example: 45\n\nnumber of logs in this bucket",
                    "title": "count",
                    "format": "uint64"
                },
                "key": {
                    "type": "string",
                    "description": "x-displayName: \"Key\"\nx-example: \"US\"",
                    "title": "key"
                },
                "order_by": {
                    "description": "x-displayName: \"Order by\"\nOrder by data for the metrics field aggregation bucket",
                    "title": "Order by",
                    "$ref": "#/definitions/logOrderByData"
                },
                "sub_aggs": {
                    "type": "object",
                    "description": "x-displayName: \"Sub Aggregation\"\nSub aggregation data for the field aggregation bucket",
                    "title": "sub aggregation"
                },
                "trend_value": {
                    "description": "x-displayName: \"Trend Value\"\ntrend value for the keys present in the field aggregation bucket",
                    "title": "Trend value",
                    "$ref": "#/definitions/schemaTrendValue"
                }
            }
        },
        "logFieldAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Field Aggregation Data\"\nField Aggregation data",
            "title": "FieldAggregationData",
            "properties": {
                "buckets": {
                    "type": "array",
                    "description": "x-displayName: \"Buckets\"\nLists of buckets containing field value and the corresponding log count",
                    "title": "buckets",
                    "items": {
                        "$ref": "#/definitions/logFieldAggregationBucket"
                    }
                }
            }
        },
        "logFieldSubAggregationBucket": {
            "type": "object",
            "description": "x-displayName: \"Field Sub Aggregation Bucket\"\nField sub aggregation bucket containing field values and the number of logs.",
            "title": "FieldSubAggregationBucket",
            "properties": {
                "count": {
                    "type": "string",
                    "description": "x-displayName: \"Count\"\nx-example: 45\n\nnumber of logs in this bucket",
                    "title": "count",
                    "format": "uint64"
                },
                "key": {
                    "type": "string",
                    "description": "x-displayName: \"Key\"\nKey contain the name/value pair that identifies the unique key fields\nx-example: \"HIT, MISS, REVALIDATED\"",
                    "title": "keys"
                },
                "order_by": {
                    "description": "x-displayName: \"Order by\"\nOrder by data for the metrics field aggregation bucket",
                    "title": "Order by",
                    "$ref": "#/definitions/logOrderByData"
                }
            }
        },
        "logFieldSubAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Field SubAggregation\"\nField subaggregation data",
            "title": "FieldSubAggregationData",
            "properties": {
                "avg_aggregation": {
                    "description": "x-displayName: \"Avg Aggregation\"\nAvg Aggregation Data",
                    "title": "Average Aggregation",
                    "$ref": "#/definitions/logAvgAggregationData"
                },
                "buckets": {
                    "type": "array",
                    "description": "x-displayName: \"Buckets\"\nLists of buckets containing field values and the corresponding log count",
                    "title": "buckets",
                    "items": {
                        "$ref": "#/definitions/logFieldSubAggregationBucket"
                    }
                },
                "cardinality_aggregation": {
                    "description": "cardinality aggregation data",
                    "title": "cardinality aggregation\nx-displayName: \"Cardinality Aggregation\"",
                    "$ref": "#/definitions/logCardinalityAggregationData"
                },
                "filter_aggregation": {
                    "description": "x-displayName: \"Filter Aggregation\"\nFilter Aggregation Data",
                    "title": "Filter Aggregation",
                    "$ref": "#/definitions/logFilterAggregationData"
                },
                "max_aggregation": {
                    "description": "x-displayName: \"Max Aggregation\"\nMax Aggregation Data",
                    "title": "Max Aggregation",
                    "$ref": "#/definitions/logMaxAggregationData"
                },
                "min_aggregation": {
                    "description": "x-displayName: \"Min Aggregation\"\nMin Aggregation Data",
                    "title": "Min Aggregation",
                    "$ref": "#/definitions/logMinAggregationData"
                },
                "multi_filter_aggregation": {
                    "description": "x-displayName: \"Multi Filter Aggregation\"\nMulti Filter Aggregation Data",
                    "title": "Multi Filter Aggregation",
                    "$ref": "#/definitions/logMultiFilterAggregationData"
                }
            }
        },
        "logFieldSubFieldAggregationBucket": {
            "type": "object",
            "description": "x-displayName: \"Field Sub Field Aggregation Bucket\"\nField sub aggregation bucket containing field values and the number of logs.",
            "title": "FieldSubFieldAggregationBucket",
            "properties": {
                "count": {
                    "type": "string",
                    "description": "x-displayName: \"Count\"\nx-example: 45\n\nnumber of logs in this bucket",
                    "title": "count",
                    "format": "uint64"
                },
                "key": {
                    "type": "string",
                    "description": "x-displayName: \"Key\"\nKey contain the name/value pair that identifies the unique key fields\nx-example: \"HIT, MISS, REVALIDATED\"",
                    "title": "keys"
                }
            }
        },
        "logFieldSubFieldAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Field Sub Field Aggregation Data\"\nField Aggregation data as Field Sub-aggregation",
            "title": "FieldSubFieldAggregationData",
            "properties": {
                "buckets": {
                    "type": "array",
                    "description": "x-displayName: \"Buckets\"\nLists of buckets containing field value and the corresponding log count",
                    "title": "buckets",
                    "items": {
                        "$ref": "#/definitions/logFieldSubFieldAggregationBucket"
                    }
                }
            }
        },
        "logFilterAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Filter Aggregation Data\"\nFilter Aggregation Data",
            "title": "FilterAggregationData",
            "properties": {
                "count": {
                    "type": "string",
                    "description": "x-displayName: \"Count\"\nx-example: 45\n\nnumber of logs in this bucket",
                    "title": "count",
                    "format": "uint64"
                },
                "sub_aggs": {
                    "type": "object",
                    "description": "x-displayName: \"Sub Aggregation\"\nSub aggregation data for the filter aggregation",
                    "title": "sub aggregation"
                }
            }
        },
        "logFilterSubAggregationData": {
            "type": "object",
            "description": "x-displayName: \"FilterSubAggregation\"\nFilter subaggregation data",
            "title": "FilterSubAggregationData",
            "properties": {
                "buckets": {
                    "type": "array",
                    "description": "x-displayName: \"Buckets\"\nLists of buckets containing field value and the corresponding log count",
                    "title": "buckets",
                    "items": {
                        "$ref": "#/definitions/logFilterSubFieldAggregationBucket"
                    }
                }
            }
        },
        "logFilterSubFieldAggregationBucket": {
            "type": "object",
            "description": "x-displayName: \"Filter Sub Field Aggregation Bucket\"\nField sub aggregation bucket containing field values and the number of logs.",
            "title": "FilterSubFieldAggregationBucket",
            "properties": {
                "count": {
                    "type": "string",
                    "description": "x-displayName: \"Count\"\nx-example: 45\n\nnumber of logs in this bucket",
                    "title": "count",
                    "format": "uint64"
                },
                "key": {
                    "type": "string",
                    "description": "x-displayName: \"Key\"\nKey contain the name/value pair that identifies the unique key fields\nx-example: \"HIT, MISS, REVALIDATED\"",
                    "title": "keys"
                },
                "sub_aggs": {
                    "type": "object",
                    "description": "x-displayName: \"Sub Aggregation\"\nSub aggregation data for the filter aggregation",
                    "title": "sub aggregation"
                }
            }
        },
        "logLogAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Log Aggregation\"\nLog aggregation response data",
            "title": "LogAggregationData",
            "properties": {
                "avg_aggregation": {
                    "description": "x-displayName: \"Avg Aggregation\"\nAvg Aggregation Data",
                    "title": "Average Aggregation",
                    "$ref": "#/definitions/logAvgAggregationData"
                },
                "cardinality_aggregation": {
                    "description": "Cardinality aggregation data",
                    "title": "cardinality aggregation\nx-displayName: \"Cardinality Aggregation\"",
                    "$ref": "#/definitions/logCardinalityAggregationData"
                },
                "date_aggregation": {
                    "description": "Date aggregation data",
                    "title": "date aggregation\nx-displayName: \"Date Aggregation\"",
                    "$ref": "#/definitions/logDateAggregationData"
                },
                "field_aggregation": {
                    "description": "Field aggregation data",
                    "title": "field aggregation\nx-displayName: \"Field Aggregation\"",
                    "$ref": "#/definitions/logFieldAggregationData"
                },
                "filter_aggregation": {
                    "description": "x-displayName: \"Filter Aggregation\"\nFilter Aggregation Data",
                    "title": "Filter Aggregation",
                    "$ref": "#/definitions/logFilterAggregationData"
                },
                "max_aggregation": {
                    "description": "x-displayName: \"Max Aggregation\"\nMax Aggregation Data",
                    "title": "Max Aggregation",
                    "$ref": "#/definitions/logMaxAggregationData"
                },
                "metrics_aggregation": {
                    "description": "x-displayName: \"Metrics Aggregation\"\nMetrics aggregation data",
                    "title": "metrics Aggregation",
                    "$ref": "#/definitions/logMetricsAggregationData"
                },
                "min_aggregation": {
                    "description": "x-displayName: \"Min Aggregation\"\nMin Aggregation Data",
                    "title": "Min Aggregation",
                    "$ref": "#/definitions/logMinAggregationData"
                },
                "multi_field_aggregation": {
                    "description": "Multi-Field aggregation data",
                    "title": "multi-field aggregation\nx-displayName: \"Multi-Field Aggregation\"",
                    "$ref": "#/definitions/logMultiFieldAggregationData"
                },
                "multi_filter_aggregation": {
                    "description": "x-displayName: \"Multi Filter Aggregation\"\nMulti Filter Aggregation Data",
                    "title": "Multi Filter Aggregation",
                    "$ref": "#/definitions/logMultiFilterAggregationData"
                }
            }
        },
        "logMaxAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Max Aggregation Data\"\nMax Aggregation data",
            "title": "MaxAggregationData",
            "properties": {
                "value": {
                    "type": "number",
                    "description": "x-displayName: \"Value\"\nx-example: 985.0\n\nvalue corresponding to the maximum value of field",
                    "title": "value",
                    "format": "double"
                }
            }
        },
        "logMetricsAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Metrics Aggregation\"\nMetrics aggregation data",
            "title": "MetricsAggregationData",
            "properties": {
                "percentile": {
                    "description": "percentile aggregation data",
                    "title": "percentile aggregation\nx-displayName: \"Percentile Aggregation\"",
                    "$ref": "#/definitions/logPercentileAggregationData"
                }
            }
        },
        "logMinAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Min Aggregation Data\"\nMin Aggregation data",
            "title": "MinAggregationData",
            "properties": {
                "value": {
                    "type": "number",
                    "description": "x-displayName: \"Value\"\nx-example: 985.0\n\nvalue corresponding to the minimum value of field",
                    "title": "value",
                    "format": "double"
                }
            }
        },
        "logMultiFieldAggregationBucket": {
            "type": "object",
            "description": "x-displayName: \"Multi-Field Aggregation Bucket\"\nMulti-Field aggregation bucket containing field values and the number of logs.",
            "title": "MultiFieldAggregationBucket",
            "properties": {
                "count": {
                    "type": "string",
                    "description": "x-displayName: \"Count\"\nx-example: 45\n\nnumber of logs in this bucket",
                    "title": "count",
                    "format": "uint64"
                },
                "keys": {
                    "type": "object",
                    "description": "x-displayName: \"Keys\"\nKeys contain the name/value pair that identifies the unique combination of multiple key fields\nx-example: \"{\"SRC_IP\": \"10.10.10.1\", \"COUNTRY\": \"US\"}\"",
                    "title": "keys"
                },
                "order_by": {
                    "description": "x-displayName: \"Order by\"\nOrder by data for the metrics field aggregation bucket",
                    "title": "Order by",
                    "$ref": "#/definitions/logOrderByData"
                },
                "sub_aggs": {
                    "type": "object",
                    "description": "x-displayName: \"Sub Aggregation\"\nSub aggregation data for the multi field aggregation bucket",
                    "title": "sub aggregation"
                }
            }
        },
        "logMultiFieldAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Multi-Field Aggregation Data\"\nMulti-Field Aggregation data",
            "title": "MultiFieldAggregationData",
            "properties": {
                "buckets": {
                    "type": "array",
                    "description": "x-displayName: \"Buckets\"\nLists of buckets containing field values and the corresponding log count",
                    "title": "buckets",
                    "items": {
                        "$ref": "#/definitions/logMultiFieldAggregationBucket"
                    }
                }
            }
        },
        "logMultiFieldSubAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Multi Field SubAggregation\"\nField subaggregation data",
            "title": "MultiFieldSubAggregationData",
            "properties": {
                "avg_aggregation": {
                    "description": "x-displayName: \"Avg Aggregation\"\nAvg Aggregation Data",
                    "title": "Average Aggregation",
                    "$ref": "#/definitions/logAvgAggregationData"
                },
                "cardinality_aggregation": {
                    "description": "cardinality aggregation data",
                    "title": "cardinality aggregation\nx-displayName: \"Cardinality Aggregation\"",
                    "$ref": "#/definitions/logCardinalityAggregationData"
                },
                "max_aggregation": {
                    "description": "x-displayName: \"Max Aggregation\"\nMax Aggregation Data",
                    "title": "Max Aggregation",
                    "$ref": "#/definitions/logMaxAggregationData"
                },
                "min_aggregation": {
                    "description": "x-displayName: \"Min Aggregation\"\nMin Aggregation Data",
                    "title": "Min Aggregation",
                    "$ref": "#/definitions/logMinAggregationData"
                },
                "top_hits_aggregation": {
                    "description": "Top Hits Aggregation Data",
                    "title": "Top Hits Aggregation\nx-displayName: \"Top Hits Aggregation\"",
                    "$ref": "#/definitions/logTopHitsAggregationData"
                }
            }
        },
        "logMultiFilterAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Multi Filter Aggregation Data\"\nMulti Filter Aggregation data",
            "title": "MultiFilterAggregationData",
            "properties": {
                "count": {
                    "type": "string",
                    "description": "x-displayName: \"Count\"\nx-example: 45\n\nnumber of logs in this bucket",
                    "title": "count",
                    "format": "uint64"
                }
            }
        },
        "logOrderByData": {
            "type": "object",
            "description": "x-displayName: \"Order by Data\"\nOrder by data",
            "title": "OrderByData",
            "properties": {
                "metrics_aggregation": {
                    "description": "x-displayName: \"Metrics Aggregation\"\nMetrics aggregation data",
                    "title": "metrics Aggregation",
                    "$ref": "#/definitions/logMetricsAggregationData"
                }
            }
        },
        "logPercentileAggregationData": {
            "type": "object",
            "description": "x-displayName: \"Percentile Aggregation Data\"\nPercentile Aggregation data",
            "title": "PercentileAggregationData",
            "properties": {
                "key": {
                    "type": "number",
                    "description": "x-displayName: \"Key\"\nx-example: 99.0",
                    "title": "key",
                    "format": "double"
                },
                "value": {
                    "type": "number",
                    "description": "x-displayName: \"Value\"\nx-example: 985.0\n\nvalue corresponding to the key percent",
                    "title": "value",
                    "format": "double"
                }
            }
        },
        "logTopHitsAggregationData": {
            "type": "object",
            "description": "x-displayName: \"TopHits Aggregation Data\"\nTop Hits Aggregation Data.",
            "title": "TopHitsAggregationData",
            "properties": {
                "count": {
                    "type": "string",
                    "description": "x-displayName: \"Count\"\nx-example: 100\nCount of top hit values",
                    "title": "count",
                    "format": "uint64"
                },
                "documents": {
                    "type": "array",
                    "description": "x-displayName: \"Documents\"\ndocument values",
                    "title": "documents",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "metricsSecurityEventsCounter": {
            "type": "object",
            "description": "SecurityEventsCounter contains the timeseries data of security events counter.",
            "title": "Security Events Counter",
            "x-displayname": "Security Events Counter",
            "x-ves-proto-message": "ves.io.schema.app_security.metrics.SecurityEventsCounter",
            "properties": {
                "id": {
                    "description": " Security Event ID is the associated info for security events count",
                    "title": "Security Events ID",
                    "$ref": "#/definitions/metricsSecurityEventsId",
                    "x-displayname": "Security Events ID"
                },
                "metric": {
                    "type": "array",
                    "description": " List of metric values",
                    "title": "Metric Values",
                    "items": {
                        "$ref": "#/definitions/metricsSecurityMetricValue"
                    },
                    "x-displayname": "Metric Values"
                }
            }
        },
        "metricsSecurityEventsId": {
            "type": "object",
            "description": "SecurityEventsId uniquely identifies an entry in the response for security events metrics query.\nsecurity events counter is aggregated based on the MetricLabel specified in the group_by field in the request.\nTherefore, only the fields that corresponds to the MetricLabel in the group_by will have non-empty\nvalue in the response.",
            "title": "SecurityEventsId",
            "x-displayname": "Security Events ID",
            "x-ves-proto-message": "ves.io.schema.app_security.metrics.SecurityEventsId",
            "properties": {
                "namespace": {
                    "type": "string",
                    "description": " Namespace for which the security event was generated\n\nExample: - \"blogging-app-namespace-1\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "blogging-app-namespace-1"
                },
                "sec_event_type": {
                    "type": "string",
                    "description": "\n\nExample: - \"WAF\"-",
                    "title": "Security Event Type",
                    "x-displayname": "Security Event Type",
                    "x-ves-example": "WAF"
                },
                "src_instance": {
                    "type": "string",
                    "description": "\n\nExample: - \"IN\"-",
                    "title": "Source Instance",
                    "x-displayname": "Source Instance",
                    "x-ves-example": "IN"
                },
                "src_site": {
                    "type": "string",
                    "description": "\n\nExample: - \"greatblogs-ce\"-",
                    "title": "Source Site",
                    "x-displayname": "Source Site",
                    "x-ves-example": "greatblogs-ce"
                },
                "vh_name": {
                    "type": "string",
                    "description": "\n\nExample: - \"greatblogs-vhost\"-",
                    "title": "Virtual Host",
                    "x-displayname": "Virtual Host",
                    "x-ves-example": "greatblogs-vhost"
                }
            }
        },
        "metricsSecurityMetricLabel": {
            "type": "string",
            "description": "Labels in the security events metrics.\n\nSecurity events metric can be sliced and diced based\non one or more labels listed below.\n",
            "enum": [
                "NAMESPACE",
                "VH_NAME",
                "SEC_EVENT_TYPE",
                "SRC_SITE",
                "SRC_INSTANCE"
            ],
            "default": "NAMESPACE",
            "x-displayname": "Security Events Metric Labels",
            "x-ves-proto-enum": "ves.io.schema.app_security.metrics.SecurityMetricLabel"
        },
        "metricsSecurityMetricLabelFilter": {
            "type": "object",
            "description": "Label based filtering for Security Events metrics.\n\nSecurity Events metrics are tagged with labels mentioned in MetricLabel.\nMetric label filter can be specified to query specific metrics based on label match",
            "x-displayname": "Security Events Metric Label Filter",
            "x-ves-proto-message": "ves.io.schema.app_security.metrics.SecurityMetricLabelFilter",
            "properties": {
                "label": {
                    "description": " Label name which is one out of the labels defined in MetricLabel enum.",
                    "title": "Label",
                    "$ref": "#/definitions/metricsSecurityMetricLabel",
                    "x-displayname": "Label"
                },
                "op": {
                    "description": " Operator to evaluate the label in this filter",
                    "title": "Operator",
                    "$ref": "#/definitions/metricsSecurityMetricLabelOp",
                    "x-displayname": "Operator"
                },
                "value": {
                    "type": "string",
                    "description": " Value to be compared with\n\nExample: - \"blogging-app-namespace-1\"-",
                    "title": "Value",
                    "x-displayname": "Value",
                    "x-ves-example": "blogging-app-namespace-1"
                }
            }
        },
        "metricsSecurityMetricLabelOp": {
            "type": "string",
            "description": "The operator to use when querying Security Events metrics with labels.\n",
            "title": "Security Events Metric Label Operator",
            "enum": [
                "EQ",
                "NEQ"
            ],
            "default": "EQ",
            "x-displayname": "Security Events Metric Label Operator",
            "x-ves-proto-enum": "ves.io.schema.app_security.metrics.SecurityMetricLabelOp"
        },
        "metricsSecurityMetricValue": {
            "type": "object",
            "description": "Value returned for a Security Events Metrics query",
            "title": "Metric Value",
            "x-displayname": "Metric Value",
            "x-ves-proto-message": "ves.io.schema.app_security.metrics.SecurityMetricValue",
            "properties": {
                "timestamp": {
                    "type": "number",
                    "description": " timestamp\n\nExample: - \"1570007981\"-",
                    "title": "Timestamp",
                    "format": "double",
                    "x-displayname": "Timestamp",
                    "x-ves-example": "1570007981"
                },
                "value": {
                    "type": "string",
                    "description": " value\n\nExample: - \"15\"-",
                    "title": "Value",
                    "x-displayname": "Value",
                    "x-ves-example": "15"
                }
            }
        },
        "schemaSortOrder": {
            "type": "string",
            "description": "Sort algorithm\n\nSort in descending order\nSort in ascending order",
            "title": "SortOrder",
            "enum": [
                "DESCENDING",
                "ASCENDING"
            ],
            "default": "DESCENDING",
            "x-displayname": "Sort Order",
            "x-ves-proto-enum": "ves.io.schema.SortOrder"
        },
        "schemaTrendSentiment": {
            "type": "string",
            "description": "x-displayName: \"Trend Sentiment\"\ntrend sentiment\n\n - TREND_SENTIMENT_NONE: x-displayName: \"None\"\n - TREND_SENTIMENT_POSITIVE: x-displayName: \"Positive\"\nIndicates trend sentiment is positive\n - TREND_SENTIMENT_NEGATIVE: x-displayName: \"Negative\"\nIndicates trend sentiment is negative.",
            "title": "Trend Sentiment",
            "enum": [
                "TREND_SENTIMENT_NONE",
                "TREND_SENTIMENT_POSITIVE",
                "TREND_SENTIMENT_NEGATIVE"
            ],
            "default": "TREND_SENTIMENT_NONE"
        },
        "schemaTrendValue": {
            "type": "object",
            "description": "x-displayName: \"Trend Value\"\nTrend value contains trend value, trend sentiment and trend calculation description and window size.",
            "title": "Trend Value",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "x-displayName: \"Description\"\nx-example: \"Trend was calculated by comparing the avg of window size intervals of end-start Time and last window time interval\"\ndescription of the method used to calculate trend.",
                    "title": "Description"
                },
                "previous_value": {
                    "type": "string",
                    "description": "x-displayName: \"Previous Value\"\nx-example: \"200.00\"",
                    "title": "Previous Value"
                },
                "sentiment": {
                    "description": "x-displayName: \"Sentiment\"\nx-example: \"Positive\"",
                    "title": "Sentiment",
                    "$ref": "#/definitions/schemaTrendSentiment"
                },
                "value": {
                    "type": "string",
                    "description": "x-displayName: \"Value\"\nx-example: \"-15\"",
                    "title": "Value"
                }
            }
        },
        "schemaapp_securityAggregationRequest": {
            "type": "object",
            "description": "x-displayName: \"Aggregation Request\"\nAggregation request to provide analytics data over the security events",
            "title": "Aggregation Request",
            "properties": {
                "cardinality_aggregation": {
                    "description": "x-displayName: \"Cardinality Aggregation\"\nGet approximate count of distinct values for a field in the security event",
                    "title": "Cardinality Aggregation",
                    "$ref": "#/definitions/schemaapp_securityCardinalityAggregation"
                },
                "date_aggregation": {
                    "description": "x-displayName: \"Date Aggregation\"\nAggregate based on timestamp in the security event",
                    "title": "Date Aggregation",
                    "$ref": "#/definitions/schemaapp_securityDateAggregation"
                },
                "field_aggregation": {
                    "description": "x-displayName: \"Field Aggregation\"\nAggregate based on one of the key fields in the security event",
                    "title": "Field Aggregation",
                    "$ref": "#/definitions/schemaapp_securityFieldAggregation"
                },
                "is_trend_request": {
                    "type": "boolean",
                    "description": "Trend value computation requested for the field present in aggregation.\n\nx-displayName: \"Trend calculation requested by the user\"\nx-example: \"true\"\nTrend value computation requested by the user\nOptional: default is false",
                    "format": "boolean"
                },
                "metrics_aggregation": {
                    "description": "x-displayName: \"Metrics Aggregation\"\nComputes metrics based on values for the field in the security event",
                    "title": "Metrics Aggregation",
                    "$ref": "#/definitions/schemaapp_securityMetricsAggregation"
                },
                "multi_field_aggregation": {
                    "description": "x-displayName: \"Multi-Field Aggregation\"\nAggregate based on multiple key fields in the security event",
                    "title": "Multi-Field Aggregation",
                    "$ref": "#/definitions/schemaapp_securityMultiFieldAggregation"
                }
            }
        },
        "schemaapp_securityCardinalityAggregation": {
            "type": "object",
            "description": "x-displayName: \"Cardinality Aggregation\"\nGet approximate count of distinct values for the field in the security event.",
            "title": "Cardinality Aggregation",
            "properties": {
                "field": {
                    "description": "x-displayName: \"Field\"\nx-required\n\nField name for which count of distinct values should be computed.",
                    "title": "field",
                    "$ref": "#/definitions/schemaapp_securityKeyField"
                }
            }
        },
        "schemaapp_securityDateAggregation": {
            "type": "object",
            "description": "x-displayName: \"Date Aggregation\"\nAggregate security events based on timestamp in the security event",
            "title": "Date Aggregation",
            "properties": {
                "step": {
                    "type": "string",
                    "description": "x-displayName: \"Step\"\nx-required\nx-example: \"5m\"\n\nstep is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.\nThe timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn \u003c= end_time.\nFormat: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days",
                    "title": "step"
                },
                "sub_aggs": {
                    "type": "object",
                    "description": "x-displayName: \"Sub Aggregation\"\nThis option provides sub-aggregation for each date bucket",
                    "title": "sub aggregation"
                }
            }
        },
        "schemaapp_securityDateSubAggregation": {
            "type": "object",
            "description": "x-displayName: \"Date SubAggregation\"\nAggregate security events based on one of the sub aggregation types",
            "title": "Date SubAggregation",
            "properties": {
                "field_aggregation": {
                    "description": "x-displayName: \"Field Aggregation\"\nAggregate based on one of the key fields in the security event",
                    "title": "Field Aggregation",
                    "$ref": "#/definitions/schemaapp_securityFieldAggregation"
                },
                "multi_field_aggregation": {
                    "description": "x-displayName: \"Multi Field Aggregation\"\nAggregate based on one of the mutiple key fields in the security event",
                    "title": "Multi Field Aggregation",
                    "$ref": "#/definitions/schemaapp_securityMultiFieldAggregation"
                }
            }
        },
        "schemaapp_securityFieldAggregation": {
            "type": "object",
            "description": "x-displayName: \"Field Aggregation\"\nAggregate security events based on the key fields in the security event.",
            "title": "Field Aggregation",
            "properties": {
                "field": {
                    "description": "x-displayName: \"Field\"\nx-required\n\nField name by which the security events should be aggregated.",
                    "title": "field",
                    "$ref": "#/definitions/schemaapp_securityKeyField"
                },
                "metrics_aggregation": {
                    "description": "x-displayName: \"Metrics Aggregation\"\nComputes metrics based on values for the field in the security event",
                    "title": "Metrics Aggregation",
                    "$ref": "#/definitions/schemaapp_securityMetricsAggregation"
                },
                "sub_aggs": {
                    "type": "object",
                    "description": "x-displayName: \"Sub Aggregation\"\nThis option provides sub-aggregation for each field aggregation bucket.",
                    "title": "sub aggregation"
                },
                "topk": {
                    "type": "integer",
                    "description": "x-displayName: \"TopK\"\nx-example: \"10\"\n\nNumber of top field values to be returned in the response.",
                    "title": "topk",
                    "format": "int64"
                }
            }
        },
        "schemaapp_securityFieldSubAggregation": {
            "type": "object",
            "description": "x-displayName: \"Field SubAggregation\"\nAggregate security events in each field bucket based on one of the sub aggregation types",
            "title": "Field SubAggregation",
            "properties": {
                "cardinality_aggregation": {
                    "description": "x-displayName: \"Cardinality Aggregation\"\nGet approximate count of distinct values for a field",
                    "title": "Cardinality Aggregation",
                    "$ref": "#/definitions/schemaapp_securityCardinalityAggregation"
                }
            }
        },
        "schemaapp_securityKeyField": {
            "type": "string",
            "description": "x-displayName: \"Key Field\"\nSecurity events can be aggregated based on these fields.\n\n - CITY: x-displayName: \"City\"\n - COUNTRY: x-displayName: \"Country\"\n - SEC_EVENT_TYPE: x-displayName: \"Security Event Type\"\n - SRC_SITE: x-displayName: \"Source Site\"\n - VH_NAME: x-displayName: \"Virtual Host Name\"\n - VH_TYPE: x-displayName: \"Virtual Host Type\"\n - USER: x-displayName: \"User\"\n - SUSPICIOUS_USER_COUNTRY: x-displayName: \"Suspicious User Country\"\nThis field is applicable only for DDoS security events, where a ddos event\nmay be detected based on requests originating from one or more countries.\n - SUSPICIOUS_USER_REGION: x-displayName: \"Suspicious User Region\"\nThis field is applicable only for DDoS security events, where a ddos event\nmay be detected based on requests originating from one or more regions.\n - SUSPICIOUS_USER_ASN: x-displayName: \"Suspicious User ASN\"\nThis field is applicable only for DDoS security events, where a ddos event\nmay be detected based on requests originating from one or more ASNs.\n - SUSPICIOUS_USER_SRC_IP: x-displayName: \"Suspicious User Source IP\"\nThis field is applicable only for DDoS security events, where a ddos event\nmay be detected based on requests originating from one or more source IP address.\n - SUSPICIOUS_USER_SRC_SITE: x-displayName: \"Suspicious User Source Site\"\nThis field is applicable only for DDoS security events, where a ddos event\nmay be detected based on requests originating from one or more sites.\n - SUSPICIOUS_USER_TLS_FINGERPRINT: x-displayName: \"Suspicious User JA3 TLS Fingerprint\"\nThis field is applicable only for DDoS security events, where a ddos event\nmay be detected based on requests originating with one or more JA3 TLS fingerprints.\n - VIOLATION: x-displayName: \"Violation\"\nMapped to violations.name\n - ATTACK_TYPE: x-displayName: \"Attack Type\"\nMapped to attack_types.name\n - SIGNATURE: x-displayName: \"Signature\"\nMapped to signatures.id_name\n - THREAT_CAMPAIGN: x-displayName: \"Threat Campaign\"\nMapped to threat_campaigns.id_name\n - URI: x-displayName: \"URI\"\nMapped to req_path\n - BOT_CLASSIFICATION: x-displayName: \"BOT Classification\"\nMapped to bot_info.classification\n - AUTOMATION_TYPE: x-displayName: \"BOT Defense Automation type\"\nMapped to bot_defense.automation_type\n - DOMAIN: x-displayName: \"DOMAIN\"\n - BOT_TYPE: x-displayName: \"BOT_TYPE\"\nMapped to bot_info.type\n - BOT_NAME: x-displayName: \"BOT_NAME\"\nMapped to bot_info.name\n - SRC_IP: x-displayName: \"SRC_IP\"\n - TLS_FINGERPRINT: x-displayName: \"JA3 TLS Fingerprint\"\n - ASN: x-displayName: \"ASN\"\n - API_EP: x-displayName: \"API_EP\"\nMapped to api_endpoint\n - BROWSER_TYPE: x-displayName: \"BROWSER_TYPE\"\n - DEVICE_TYPE: x-displayName: \"DEVICE_TYPE\"\n - METHOD: x-displayName: \"METHOD\"\n - RESP_CODE: x-displayName: \"RESP_CODE\"\nMapped to rsp_code\n - RESP_CODE_DETAILS: x-displayName: \"RESP_CODE_DETAILS\"\nMapped to rsp_code_details\n - SEC_EVENT_NAME: x-displayName: \"SEC_EVENT_NAME\"\n - WAF_MODE: x-displayName: \"WAF_MODE\"\n - SIGNATURE_NAME: x-displayName: \"SIGNATURE_NAME\"\nMapped to signatures.name\n - SIGNATURE_ID: x-displayName: \"SIGNATURE_ID\"\nMapped to signatures.id\n - SIGNATURE_STATE: x-displayName: \"SIGNATURE_STATE\"\nMapped to signatures.state\n - SIGNATURE_ACCURACY: x-displayName: \"SIGNATURE_ACCURACY\"\nMapped to signatures.accuracy\n - VIOLATION_STATE: x-displayName: \"VIOLATION_STATE\"\nMapped to violations.state\n - THREAT_CAMPAIGN_NAME: x-displayName: \"THREAT_CAMPAIGN_NAME\"\nMapped to threat_campaigns.name\n - THREAT_CAMPAIGN_ID: x-displayName: \"THREAT_CAMPAIGN_ID\"\nMapped to threat_campaigns.id\n - THREAT_CAMPAIGN_STATE: x-displayName: \"THREAT_CAMPAIGN_STATE\"\nMapped to threat_campaigns.state\n - VIOLATION_RATING: x-displayName: \"VIOLATION_RATING\"\n - SERVICE_POLICY: x-displayName: \"Service Policy\"\nMapped to policy_hits.policy_hits.policy\n - TLS_CIPHER_SUITE: x-displayName: \"TLS Cipher Suite\"\n - TLS_VERSION: x-displayName: \"TLS version\"\n - BOT_DEFENSE_INSIGHT: x-displayName: \"Bot Defense Insight\"\nMapped to bot_defense.insight\n - BOT_DEFENSE_RECOMMENDATION: x-displayName: \"Bot Defense Recommendation\"\nMapped to bot_defense.recommendation\n - BOT_ANOMALY: x-displayName: \"Bot Anomaly\"\nMapped to bot_info.anomaly\n - SERVICE_POLICY_RESULT: x-displayName: \"Service Policy Result\"\nMapped to policy_hits.policy_hits.result\n - SIGNATURE_CONTEXT: x-displayName: \"Signature Context\"\nMapped to signatures.context\n - ACTION: x-displayName: \"Action\"\n - NAMESPACE: x-displayName: \"Namespace\"\n - REQ_RISK: x-displayName: \"Request Risk\"\n - REQ_RISK_REASON: x-displayName: \"Request Risk Reason\"\n - JA4_TLS_FINGERPRINT: x-displayName: \"JA4 TLS Fingerprint\"\n - SUSPICIOUS_USER_JA4_TLS_FINGERPRINT: x-displayName: \"Suspicious User JA4 TLS Fingerprint\"\nThis field is applicable only for DDoS security events, where a ddos event\nmay be detected based on requests originating with one or more JA4 TLS fingerprints.\n - MALWARE_NAME: x-displayName: \"Malware Name\"\nMapped to malware_info.name\n - MALWARE_TYPE: x-displayName: \"Malware Type\"\nMapped to malware_info.type\n - MALWARE_SCAN_RESULT: x-displayName: \"Malware Scan Result\"\nMapped to malware_info.scan_result\n - MALWARE_RECOMMENDED_ACTION: x-displayName: \"Malware Recommended Action\"\nMapped to malware_info.recommended_action",
            "title": "Key Field",
            "enum": [
                "CITY",
                "COUNTRY",
                "SEC_EVENT_TYPE",
                "SRC_SITE",
                "VH_NAME",
                "VH_TYPE",
                "USER",
                "SUSPICIOUS_USER_COUNTRY",
                "SUSPICIOUS_USER_REGION",
                "SUSPICIOUS_USER_ASN",
                "SUSPICIOUS_USER_SRC_IP",
                "SUSPICIOUS_USER_SRC_SITE",
                "SUSPICIOUS_USER_TLS_FINGERPRINT",
                "VIOLATION",
                "ATTACK_TYPE",
                "SIGNATURE",
                "THREAT_CAMPAIGN",
                "URI",
                "BOT_CLASSIFICATION",
                "AUTOMATION_TYPE",
                "DOMAIN",
                "BOT_TYPE",
                "BOT_NAME",
                "SRC_IP",
                "TLS_FINGERPRINT",
                "ASN",
                "API_EP",
                "BROWSER_TYPE",
                "DEVICE_TYPE",
                "METHOD",
                "RESP_CODE",
                "RESP_CODE_DETAILS",
                "SEC_EVENT_NAME",
                "WAF_MODE",
                "SIGNATURE_NAME",
                "SIGNATURE_ID",
                "SIGNATURE_STATE",
                "SIGNATURE_ACCURACY",
                "VIOLATION_STATE",
                "THREAT_CAMPAIGN_NAME",
                "THREAT_CAMPAIGN_ID",
                "THREAT_CAMPAIGN_STATE",
                "VIOLATION_RATING",
                "SERVICE_POLICY",
                "TLS_CIPHER_SUITE",
                "TLS_VERSION",
                "BOT_DEFENSE_INSIGHT",
                "BOT_DEFENSE_RECOMMENDATION",
                "BOT_ANOMALY",
                "SERVICE_POLICY_RESULT",
                "SIGNATURE_CONTEXT",
                "ACTION",
                "NAMESPACE",
                "REQ_RISK",
                "REQ_RISK_REASON",
                "JA4_TLS_FINGERPRINT",
                "SUSPICIOUS_USER_JA4_TLS_FINGERPRINT",
                "MALWARE_NAME",
                "MALWARE_TYPE",
                "MALWARE_SCAN_RESULT",
                "MALWARE_RECOMMENDED_ACTION"
            ],
            "default": "CITY"
        },
        "schemaapp_securityMetricField": {
            "type": "string",
            "description": "x-displayName: \"Metric Field\"\nMetrics can be computed based on these fields.\n\n - SUSPICION_SCORE: x-displayName: \"Suspicion Score\"",
            "title": "Metric Field",
            "enum": [
                "SUSPICION_SCORE"
            ],
            "default": "SUSPICION_SCORE"
        },
        "schemaapp_securityMetricsAggregation": {
            "type": "object",
            "description": "x-displayName: \"Metrics Aggregation\"\nComputes metrics based on values for the field in the security event.",
            "title": "Metrics Aggregation",
            "properties": {
                "percentile": {
                    "description": "x-displayName: \"Percentile Aggregation\"\nCalculates percentile over numeric values for a field",
                    "title": "Percentile Aggregation",
                    "$ref": "#/definitions/schemaapp_securityPercentileAggregation"
                }
            }
        },
        "schemaapp_securityMultiFieldAggregation": {
            "type": "object",
            "description": "x-displayName: \"Multi-Field Aggregation\"\nAggregate security events based on the multiple fields in the security event.",
            "title": "Multi-Field Aggregation",
            "properties": {
                "field": {
                    "description": "x-displayName: \"Field\"\nx-required\n\nMulti-key field by which the security events should be aggregated.",
                    "title": "field",
                    "$ref": "#/definitions/schemaapp_securityMultiKeyField"
                },
                "metrics_aggregation": {
                    "description": "x-displayName: \"Metrics Aggregation\"\nComputes metrics based on values for the field in the security event",
                    "title": "Metrics Aggregation",
                    "$ref": "#/definitions/schemaapp_securityMetricsAggregation"
                },
                "sub_aggs": {
                    "type": "object",
                    "description": "x-displayName: \"Sub Aggregation\"\nThis option provides sub-aggregation for each field aggregation bucket.",
                    "title": "sub aggregation"
                },
                "topk": {
                    "type": "integer",
                    "description": "x-displayName: \"TopK\"\nx-example: \"10\"\n\nNumber of top field values to be returned in the response.",
                    "title": "topk",
                    "format": "int64"
                }
            }
        },
        "schemaapp_securityMultiFieldSubAggregation": {
            "type": "object",
            "description": "x-displayName: \"Multi Field SubAggregation\"\nAggregate security events in each MultiTerms bucket based on one of the sub aggregation types",
            "title": "Multi Field SubAggregation",
            "properties": {
                "cardinality_aggregation": {
                    "description": "x-displayName: \"Cardinality Aggregation\"\nGet approximate count of distinct values for a field",
                    "title": "Cardinality Aggregation",
                    "$ref": "#/definitions/schemaapp_securityCardinalityAggregation"
                }
            }
        },
        "schemaapp_securityMultiKeyField": {
            "type": "string",
            "description": "x-displayName: \"Multi-Key Field\"\nSecurity events can be aggregated based on these multiple key fields\n\n - ASN_COUNTRY: x-displayName: \"ASN, Country\"\nAggregated by (KeyField.ASN, KeyField.COUNTRY)\n - DOMAIN_METHOD_API_EP: x-displayName: \"Domain, Method, API Endpoint\"\nAggregated by (KeyField.DOMAIN, KeyField.Method, KeyField.APIEP)\n - SRC_IP_COUNTRY: x-displayName: \"Source IP, Country\"\nAggregated by (KeyField.SRC_IP, KeyField.COUNTRY)\n - TLS_FINGERPRINT_COUNTRY: x-displayName: \"TLS Fingerprint, Country\"\nAggregated by (KeyField.TLS_FINGERPRINT, KeyField.COUNTRY)\n - SEC_EVENT_TYPE_ACTION: x-displayName: \"SEC_EVENT_TYPE, ACTION\"\nAggregated by (KeyField.SEC_EVENT_TYPE, KeyField.ACTION)\n - DOMAIN_METHOD_REQ_PATH: x-displayName: \"Domain, Method, Request Path\"\nAggregated by (KeyField.DOMAIN, KeyField.Method, KeyField.REQ_PATH)\n - VH_NAME_SRC_IP_THREAT_CAMPAIGN: x-displayName: \"Virtual Host, Source IP, Threat Campaign\"\nAggregated by (KeyField.VH_NAME, KeyField.SRC_IP, KeyField.THREAT_CAMPAIGN_NAME, KeyField.THREAT_CAMPAIGN_ID)\n - VH_NAME_USER_THREAT_CAMPAIGN: x-displayName: \"Virtual Host, User, Threat Campaign\"\nAggregated by (KeyField.VH_NAME, KeyField.USER, KeyField.THREAT_CAMPAIGN_NAME, KeyField.THREAT_CAMPAIGN_ID)\n - VH_NAME_COUNTRY_THREAT_CAMPAIGN: x-displayName: \"Virtual Host, Country, Threat Campaign\"\nAggregated by (KeyField.VH_NAME, KeyField.COUNTRY, KeyField.THREAT_CAMPAIGN_NAME, KeyField.THREAT_CAMPAIGN_ID)\n - ACTION_THREAT_CAMPAIGN: x-displayName: \"Action, Threat Campaign\"\nAggregated by (KeyField.ACTION, KeyField.THREAT_CAMPAIGN_NAME, KeyField.THREAT_CAMPAIGN_ID)\n - USER_SRC_IP_COUNTRY_CITY_REGION_ASN: x-displayName: \"User, Source IP, Country, City, Region, ASN\"\nAggregated by (KeyField.USER, KeyField.SRC_IP, KeyField.COUNTRY, KeyField.CITY, KeyField.REGION, KeyField.ASN)\n - VH_NAME_NAMESPACE: x-displayName: \"VH Name, Namespace\"\nAggregated by (KeyField.VH_NAME, KeyField.NAMESPACE)\n - API_ENDPOINT_METHOD: x-displayName: \"api_endpoint, method\"\nAggregated by (KeyField.API_ENDPOINT, KeyField.METHOD)\n - JA4_TLS_FINGERPRINT_COUNTRY: x-displayName: \"JA4 TLS Fingerprint, Country\"\nAggregated by (KeyField.JA4_TLS_FINGERPRINT, KeyField.COUNTRY)",
            "title": "Multi-Key Field",
            "enum": [
                "ASN_COUNTRY",
                "DOMAIN_METHOD_API_EP",
                "SRC_IP_COUNTRY",
                "TLS_FINGERPRINT_COUNTRY",
                "SEC_EVENT_TYPE_ACTION",
                "DOMAIN_METHOD_REQ_PATH",
                "VH_NAME_SRC_IP_THREAT_CAMPAIGN",
                "VH_NAME_USER_THREAT_CAMPAIGN",
                "VH_NAME_COUNTRY_THREAT_CAMPAIGN",
                "ACTION_THREAT_CAMPAIGN",
                "USER_SRC_IP_COUNTRY_CITY_REGION_ASN",
                "VH_NAME_NAMESPACE",
                "API_ENDPOINT_METHOD",
                "JA4_TLS_FINGERPRINT_COUNTRY"
            ],
            "default": "ASN_COUNTRY"
        },
        "schemaapp_securityPercentileAggregation": {
            "type": "object",
            "description": "x-displayName: \"Percentile Aggregation\"\nCalculates percentile over numeric values for a field.",
            "title": "Percentile Aggregation",
            "properties": {
                "field": {
                    "description": "x-displayName: \"Field\"\nx-required\n\nField name for which percentile of values should be computed.",
                    "title": "field",
                    "$ref": "#/definitions/schemaapp_securityMetricField"
                },
                "percent": {
                    "type": "number",
                    "description": "x-displayName: \"Percent\"\nx-example: \"[99.0]\"\nx-required\n\nPercentile for which value is calculated.",
                    "title": "percent",
                    "format": "double"
                }
            }
        },
        "suspicious_user_logAvgAggregation": {
            "type": "object",
            "description": "x-displayName: \"Avg aggregation\"\nGet the average value of the numeric values extracted from the field in the suspicious user log.",
            "title": "Average aggregation",
            "properties": {
                "field": {
                    "description": "x-displayName: \"Field\"\nx-required\n\nField name for which average value should be computed.",
                    "title": "field",
                    "$ref": "#/definitions/suspicious_user_logNumKeyField"
                }
            }
        },
        "suspicious_user_logMaxAggregation": {
            "type": "object",
            "description": "x-displayName: \"Max aggregation\"\nGet the maximum value among the numeric values extracted from the field in the suspicious user log.",
            "title": "Max aggregation",
            "properties": {
                "field": {
                    "description": "x-displayName: \"Field\"\nx-required\n\nField name for which maximum value should be computed.",
                    "title": "field",
                    "$ref": "#/definitions/suspicious_user_logNumKeyField"
                }
            }
        },
        "suspicious_user_logMinAggregation": {
            "type": "object",
            "description": "x-displayName: \"Min aggregation\"\nGet the minimum value among the numeric values extracted from the field in the suspicious user log.",
            "title": "Min aggregation",
            "properties": {
                "field": {
                    "description": "x-displayName: \"Field\"\nx-required\n\nField name for which minimum value should be computed.",
                    "title": "field",
                    "$ref": "#/definitions/suspicious_user_logNumKeyField"
                }
            }
        },
        "suspicious_user_logNumKeyField": {
            "type": "string",
            "description": "x-displayName: \"Num-Key Field\"\nsuspicious user log can be aggregated based on these numeric fields.\n\n - SUSPICION_SCORE: x-displayName: \"SUSPICION SCORE\"\n - BEHAVIOR_ANOMALY_SCORE: x-displayName: \"BEHAVIOR ANOMALY SCORE\"\n - BOT_DEFENSE_SEC_EVENT_COUNT: x-displayName: \"BOT DEFENSE SEC EVENT COUNT\"\n - BOT_DEFENSE_SUSPICION_SCORE: x-displayName: \"BOT DEFENSE SUSPICION SCORE\"\n - ERR_COUNT: x-displayName: \"ERR COUNT\"\n - FAILED_LOGIN_COUNT: x-displayName: \"FAILED LOGIN COUNT\"\n - FAILED_LOGIN_SUSPICION_SCORE: x-displayName: \"FAILED LOGIN SUSPICION SCORE\"\n - FORBIDDEN_ACCESS_COUNT: x-displayName: \"FORBIDDEN ACCESS COUNT\"\n - FORBIDDEN_ACCESS_SUSPICION_SCORE: x-displayName: \"FORBIDDEN ACCESS SUSPICION SCORE\"\n - IP_REPUTATION_SUSPICION_SCORE: x-displayName: \"IP REPUTATION SUSPICION SCORE\"\n - PAGE_NOT_FOUND_COUNT: x-displayName: \"PAGE NOT FOUND COUNT\"\n - RATE_LIMIT_SUSPICION_SCORE: x-displayName: \"RATE LIMIT SUSPICION SCORE\"\n - RATE_LIMITING_COUNT: x-displayName: \"RATE LIMITING COUNT\"\n - WAF_SEC_EVENT_COUNT: x-displayName: \"WAF SEC EVENT COUNT\"\n - WAF_SUSPICION_SCORE: x-displayName: \"WAF SUSPICION SCORE\"",
            "title": "Numeric-Key Field",
            "enum": [
                "SUSPICION_SCORE",
                "BEHAVIOR_ANOMALY_SCORE",
                "BOT_DEFENSE_SEC_EVENT_COUNT",
                "BOT_DEFENSE_SUSPICION_SCORE",
                "ERR_COUNT",
                "FAILED_LOGIN_COUNT",
                "FAILED_LOGIN_SUSPICION_SCORE",
                "FORBIDDEN_ACCESS_COUNT",
                "FORBIDDEN_ACCESS_SUSPICION_SCORE",
                "IP_REPUTATION_SUSPICION_SCORE",
                "PAGE_NOT_FOUND_COUNT",
                "RATE_LIMIT_SUSPICION_SCORE",
                "RATE_LIMITING_COUNT",
                "WAF_SEC_EVENT_COUNT",
                "WAF_SUSPICION_SCORE"
            ],
            "default": "SUSPICION_SCORE"
        }
    },
    "x-displayname": "Application Security Monitoring APIs",
    "x-ves-proto-file": "ves.io/schema/app_security/public_monitoring_api.proto"
}`
