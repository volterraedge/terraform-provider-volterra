// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/app_security/types.proto

package app_security

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Security Event Type
//
// x-displayName: "Security Event Type"
// Security event can be one of the following types.
type SecEventType int32

const (
	// x-displayName: "WAF Security Event"
	WAF_SEC_EVENT SecEventType = 0
	// x-displayName: "L7 Policy Security Event"
	L7_POLICY_SEC_EVENT SecEventType = 1
	// x-displayName: "Javascript Challenge Security Event"
	JS_CHALLENGE_SEC_EVENT SecEventType = 2
	// x-displayName: "Captcha Challenge Security Event"
	CAPTCHA_CHALLENGE_SEC_EVENT SecEventType = 3
	// x-displayName: "Malicious User Security Event"
	MALICIOUS_USER_SEC_EVENT SecEventType = 4
	// x-displayName: "Service Policy Security Event"
	SVC_POLICY_SEC_EVENT SecEventType = 5
	// x-displayName: "BOT DEFENSE Security Event"
	BOT_DEFENSE_SEC_EVENT SecEventType = 6
	// x-displayName: "API SECURITY Security Event"
	API_SEC_EVENT SecEventType = 7
	// x-displayName: "DDoS Security Event"
	DDOS_SEC_EVENT SecEventType = 8
	// x-displayName: "DoS Security Event"
	DOS_SEC_EVENT SecEventType = 9
)

var SecEventType_name = map[int32]string{
	0: "WAF_SEC_EVENT",
	1: "L7_POLICY_SEC_EVENT",
	2: "JS_CHALLENGE_SEC_EVENT",
	3: "CAPTCHA_CHALLENGE_SEC_EVENT",
	4: "MALICIOUS_USER_SEC_EVENT",
	5: "SVC_POLICY_SEC_EVENT",
	6: "BOT_DEFENSE_SEC_EVENT",
	7: "API_SEC_EVENT",
	8: "DDOS_SEC_EVENT",
	9: "DOS_SEC_EVENT",
}

var SecEventType_value = map[string]int32{
	"WAF_SEC_EVENT":               0,
	"L7_POLICY_SEC_EVENT":         1,
	"JS_CHALLENGE_SEC_EVENT":      2,
	"CAPTCHA_CHALLENGE_SEC_EVENT": 3,
	"MALICIOUS_USER_SEC_EVENT":    4,
	"SVC_POLICY_SEC_EVENT":        5,
	"BOT_DEFENSE_SEC_EVENT":       6,
	"API_SEC_EVENT":               7,
	"DDOS_SEC_EVENT":              8,
	"DOS_SEC_EVENT":               9,
}

func (SecEventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e85477373611cb39, []int{0}
}

// Metric Field
//
// x-displayName: "Metric Field"
// Metrics can be computed based on these fields.
type MetricField int32

const (
	// x-displayName: "Suspicion Score"
	SUSPICION_SCORE MetricField = 0
)

var MetricField_name = map[int32]string{
	0: "SUSPICION_SCORE",
}

var MetricField_value = map[string]int32{
	"SUSPICION_SCORE": 0,
}

func (MetricField) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e85477373611cb39, []int{1}
}

// Key Field
//
// x-displayName: "Key Field"
// Security events can be aggregated based on these fields.
type KeyField int32

const (
	// x-displayName: "City"
	CITY KeyField = 0
	// x-displayName: "Country"
	COUNTRY KeyField = 1
	// x-displayName: "Security Event Type"
	SEC_EVENT_TYPE KeyField = 2
	// x-displayName: "Source Site"
	SRC_SITE KeyField = 3
	// x-displayName: "Virtual Host Name"
	VH_NAME KeyField = 4
	// x-displayName: "Virtual Host Type"
	VH_TYPE KeyField = 5
	// x-displayName: "User"
	USER KeyField = 6
	// x-displayName: "Suspicious User Country"
	// This field is applicable only for DDoS security events, where a ddos event
	// may be detected based on requests originating from one or more countries.
	SUSPICIOUS_USER_COUNTRY KeyField = 7
	// x-displayName: "Suspicious User Region"
	// This field is applicable only for DDoS security events, where a ddos event
	// may be detected based on requests originating from one or more regions.
	SUSPICIOUS_USER_REGION KeyField = 8
	// x-displayName: "Suspicious User ASN"
	// This field is applicable only for DDoS security events, where a ddos event
	// may be detected based on requests originating from one or more ASNs.
	SUSPICIOUS_USER_ASN KeyField = 9
	// x-displayName: "Suspicious User Source IP"
	// This field is applicable only for DDoS security events, where a ddos event
	// may be detected based on requests originating from one or more source IP address.
	SUSPICIOUS_USER_SRC_IP KeyField = 10
	// x-displayName: "Suspicious User Source Site"
	// This field is applicable only for DDoS security events, where a ddos event
	// may be detected based on requests originating from one or more sites.
	SUSPICIOUS_USER_SRC_SITE KeyField = 11
	// x-displayName: "Suspicious User JA3 TLS Fingerprint"
	// This field is applicable only for DDoS security events, where a ddos event
	// may be detected based on requests originating with one or more JA3 TLS fingerprints.
	SUSPICIOUS_USER_TLS_FINGERPRINT KeyField = 12
	// x-displayName: "Violation"
	// Mapped to violations.name
	VIOLATION KeyField = 13
	// x-displayName: "Attack Type"
	// Mapped to attack_types.name
	ATTACK_TYPE KeyField = 14
	// x-displayName: "Signature"
	// Mapped to signatures.id_name
	SIGNATURE KeyField = 15
	// x-displayName: "Threat Campaign"
	// Mapped to threat_campaigns.id_name
	THREAT_CAMPAIGN KeyField = 16
	// x-displayName: "URI"
	// Mapped to req_path
	URI KeyField = 17
	// x-displayName: "BOT Classification"
	// Mapped to bot_info.classification
	BOT_CLASSIFICATION KeyField = 18
	// x-displayName: "BOT Defense Automation type"
	// Mapped to bot_defense.automation_type
	AUTOMATION_TYPE KeyField = 19
	// x-displayName: "DOMAIN"
	DOMAIN KeyField = 20
	// x-displayName: "BOT_TYPE"
	// Mapped to bot_info.type
	BOT_TYPE KeyField = 21
	// x-displayName: "BOT_NAME"
	// Mapped to bot_info.name
	BOT_NAME KeyField = 22
	// x-displayName: "SRC_IP"
	SRC_IP KeyField = 23
	// x-displayName: "JA3 TLS Fingerprint"
	TLS_FINGERPRINT KeyField = 24
	// x-displayName: "ASN"
	ASN KeyField = 25
	// x-displayName: "API_EP"
	// Mapped to api_endpoint
	API_EP KeyField = 26
	// x-displayName: "BROWSER_TYPE"
	BROWSER_TYPE KeyField = 27
	// x-displayName: "DEVICE_TYPE"
	DEVICE_TYPE KeyField = 28
	// x-displayName: "METHOD"
	METHOD KeyField = 29
	// x-displayName: "RESP_CODE"
	// Mapped to rsp_code
	RESP_CODE KeyField = 30
	// x-displayName: "RESP_CODE_DETAILS"
	// Mapped to rsp_code_details
	RESP_CODE_DETAILS KeyField = 58
	// x-displayName: "SEC_EVENT_NAME"
	SEC_EVENT_NAME KeyField = 31
	// x-displayName: "WAF_MODE"
	WAF_MODE KeyField = 32
	// x-displayName: "SIGNATURE_NAME"
	// Mapped to signatures.name
	SIGNATURE_NAME KeyField = 33
	// x-displayName: "SIGNATURE_ID"
	// Mapped to signatures.id
	SIGNATURE_ID KeyField = 34
	// x-displayName: "SIGNATURE_STATE"
	// Mapped to signatures.state
	SIGNATURE_STATE KeyField = 35
	// x-displayName: "SIGNATURE_ACCURACY"
	// Mapped to signatures.accuracy
	SIGNATURE_ACCURACY KeyField = 36
	// x-displayName: "VIOLATION_STATE"
	// Mapped to violations.state
	VIOLATION_STATE KeyField = 37
	// x-displayName: "THREAT_CAMPAIGN_NAME"
	// Mapped to threat_campaigns.name
	THREAT_CAMPAIGN_NAME KeyField = 38
	// x-displayName: "THREAT_CAMPAIGN_ID"
	// Mapped to threat_campaigns.id
	THREAT_CAMPAIGN_ID KeyField = 39
	// x-displayName: "THREAT_CAMPAIGN_STATE"
	// Mapped to threat_campaigns.state
	THREAT_CAMPAIGN_STATE KeyField = 40
	// x-displayName: "VIOLATION_RATING"
	VIOLATION_RATING KeyField = 41
	// x-displayName: "Service Policy"
	//Mapped to policy_hits.policy_hits.policy
	SERVICE_POLICY KeyField = 46
	// x-displayName: "TLS Cipher Suite"
	TLS_CIPHER_SUITE KeyField = 47
	// x-displayName: "TLS version"
	TLS_VERSION KeyField = 48
	// x-displayName: "Bot Defense Insight"
	// Mapped to bot_defense.insight
	BOT_DEFENSE_INSIGHT KeyField = 49
	// x-displayName: "Bot Defense Recommendation"
	// Mapped to bot_defense.recommendation
	BOT_DEFENSE_RECOMMENDATION KeyField = 50
	// x-displayName: "Bot Anomaly"
	// Mapped to bot_info.anomaly
	BOT_ANOMALY KeyField = 51
	// x-displayName: "Service Policy Result"
	// Mapped to policy_hits.policy_hits.result
	SERVICE_POLICY_RESULT KeyField = 54
	// x-displayName: "Signature Context"
	// Mapped to signatures.context
	SIGNATURE_CONTEXT KeyField = 55
	// x-displayName: "Action"
	ACTION KeyField = 56
	// x-displayName: "Namespace"
	NAMESPACE KeyField = 59
	// x-displayName: "Request Risk"
	REQ_RISK KeyField = 60
	// x-displayName: "Request Risk Reason"
	REQ_RISK_REASON KeyField = 61
	// x-displayName: "JA4 TLS Fingerprint"
	JA4_TLS_FINGERPRINT KeyField = 62
	// x-displayName: "Suspicious User JA4 TLS Fingerprint"
	// This field is applicable only for DDoS security events, where a ddos event
	// may be detected based on requests originating with one or more JA4 TLS fingerprints.
	SUSPICIOUS_USER_JA4_TLS_FINGERPRINT KeyField = 63
	// x-displayName: "Malware Name"
	// Mapped to malware_info.name
	MALWARE_NAME KeyField = 64
	// x-displayName: "Malware Type"
	// Mapped to malware_info.type
	MALWARE_TYPE KeyField = 65
	// x-displayName: "Malware Scan Result"
	// Mapped to malware_info.scan_result
	MALWARE_SCAN_RESULT KeyField = 66
	// x-displayName: "Malware Recommended Action"
	// Mapped to malware_info.recommended_action
	MALWARE_RECOMMENDED_ACTION KeyField = 67
)

var KeyField_name = map[int32]string{
	0:  "CITY",
	1:  "COUNTRY",
	2:  "SEC_EVENT_TYPE",
	3:  "SRC_SITE",
	4:  "VH_NAME",
	5:  "VH_TYPE",
	6:  "USER",
	7:  "SUSPICIOUS_USER_COUNTRY",
	8:  "SUSPICIOUS_USER_REGION",
	9:  "SUSPICIOUS_USER_ASN",
	10: "SUSPICIOUS_USER_SRC_IP",
	11: "SUSPICIOUS_USER_SRC_SITE",
	12: "SUSPICIOUS_USER_TLS_FINGERPRINT",
	13: "VIOLATION",
	14: "ATTACK_TYPE",
	15: "SIGNATURE",
	16: "THREAT_CAMPAIGN",
	17: "URI",
	18: "BOT_CLASSIFICATION",
	19: "AUTOMATION_TYPE",
	20: "DOMAIN",
	21: "BOT_TYPE",
	22: "BOT_NAME",
	23: "SRC_IP",
	24: "TLS_FINGERPRINT",
	25: "ASN",
	26: "API_EP",
	27: "BROWSER_TYPE",
	28: "DEVICE_TYPE",
	29: "METHOD",
	30: "RESP_CODE",
	58: "RESP_CODE_DETAILS",
	31: "SEC_EVENT_NAME",
	32: "WAF_MODE",
	33: "SIGNATURE_NAME",
	34: "SIGNATURE_ID",
	35: "SIGNATURE_STATE",
	36: "SIGNATURE_ACCURACY",
	37: "VIOLATION_STATE",
	38: "THREAT_CAMPAIGN_NAME",
	39: "THREAT_CAMPAIGN_ID",
	40: "THREAT_CAMPAIGN_STATE",
	41: "VIOLATION_RATING",
	46: "SERVICE_POLICY",
	47: "TLS_CIPHER_SUITE",
	48: "TLS_VERSION",
	49: "BOT_DEFENSE_INSIGHT",
	50: "BOT_DEFENSE_RECOMMENDATION",
	51: "BOT_ANOMALY",
	54: "SERVICE_POLICY_RESULT",
	55: "SIGNATURE_CONTEXT",
	56: "ACTION",
	59: "NAMESPACE",
	60: "REQ_RISK",
	61: "REQ_RISK_REASON",
	62: "JA4_TLS_FINGERPRINT",
	63: "SUSPICIOUS_USER_JA4_TLS_FINGERPRINT",
	64: "MALWARE_NAME",
	65: "MALWARE_TYPE",
	66: "MALWARE_SCAN_RESULT",
	67: "MALWARE_RECOMMENDED_ACTION",
}

var KeyField_value = map[string]int32{
	"CITY":                                0,
	"COUNTRY":                             1,
	"SEC_EVENT_TYPE":                      2,
	"SRC_SITE":                            3,
	"VH_NAME":                             4,
	"VH_TYPE":                             5,
	"USER":                                6,
	"SUSPICIOUS_USER_COUNTRY":             7,
	"SUSPICIOUS_USER_REGION":              8,
	"SUSPICIOUS_USER_ASN":                 9,
	"SUSPICIOUS_USER_SRC_IP":              10,
	"SUSPICIOUS_USER_SRC_SITE":            11,
	"SUSPICIOUS_USER_TLS_FINGERPRINT":     12,
	"VIOLATION":                           13,
	"ATTACK_TYPE":                         14,
	"SIGNATURE":                           15,
	"THREAT_CAMPAIGN":                     16,
	"URI":                                 17,
	"BOT_CLASSIFICATION":                  18,
	"AUTOMATION_TYPE":                     19,
	"DOMAIN":                              20,
	"BOT_TYPE":                            21,
	"BOT_NAME":                            22,
	"SRC_IP":                              23,
	"TLS_FINGERPRINT":                     24,
	"ASN":                                 25,
	"API_EP":                              26,
	"BROWSER_TYPE":                        27,
	"DEVICE_TYPE":                         28,
	"METHOD":                              29,
	"RESP_CODE":                           30,
	"RESP_CODE_DETAILS":                   58,
	"SEC_EVENT_NAME":                      31,
	"WAF_MODE":                            32,
	"SIGNATURE_NAME":                      33,
	"SIGNATURE_ID":                        34,
	"SIGNATURE_STATE":                     35,
	"SIGNATURE_ACCURACY":                  36,
	"VIOLATION_STATE":                     37,
	"THREAT_CAMPAIGN_NAME":                38,
	"THREAT_CAMPAIGN_ID":                  39,
	"THREAT_CAMPAIGN_STATE":               40,
	"VIOLATION_RATING":                    41,
	"SERVICE_POLICY":                      46,
	"TLS_CIPHER_SUITE":                    47,
	"TLS_VERSION":                         48,
	"BOT_DEFENSE_INSIGHT":                 49,
	"BOT_DEFENSE_RECOMMENDATION":          50,
	"BOT_ANOMALY":                         51,
	"SERVICE_POLICY_RESULT":               54,
	"SIGNATURE_CONTEXT":                   55,
	"ACTION":                              56,
	"NAMESPACE":                           59,
	"REQ_RISK":                            60,
	"REQ_RISK_REASON":                     61,
	"JA4_TLS_FINGERPRINT":                 62,
	"SUSPICIOUS_USER_JA4_TLS_FINGERPRINT": 63,
	"MALWARE_NAME":                        64,
	"MALWARE_TYPE":                        65,
	"MALWARE_SCAN_RESULT":                 66,
	"MALWARE_RECOMMENDED_ACTION":          67,
}

func (KeyField) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e85477373611cb39, []int{2}
}

// Multi-Key Field
//
// x-displayName: "Multi-Key Field"
// Security events can be aggregated based on these multiple key fields
type MultiKeyField int32

const (
	// x-displayName: "ASN, Country"
	// Aggregated by (KeyField.ASN, KeyField.COUNTRY)
	ASN_COUNTRY MultiKeyField = 0
	// x-displayName: "Domain, Method, API Endpoint"
	// Aggregated by (KeyField.DOMAIN, KeyField.Method, KeyField.APIEP)
	DOMAIN_METHOD_API_EP MultiKeyField = 1
	// x-displayName: "Source IP, Country"
	// Aggregated by (KeyField.SRC_IP, KeyField.COUNTRY)
	SRC_IP_COUNTRY MultiKeyField = 2
	// x-displayName: "TLS Fingerprint, Country"
	// Aggregated by (KeyField.TLS_FINGERPRINT, KeyField.COUNTRY)
	TLS_FINGERPRINT_COUNTRY MultiKeyField = 3
	// x-displayName: "SEC_EVENT_TYPE, ACTION"
	// Aggregated by (KeyField.SEC_EVENT_TYPE, KeyField.ACTION)
	SEC_EVENT_TYPE_ACTION MultiKeyField = 4
	// x-displayName: "Domain, Method, Request Path"
	// Aggregated by (KeyField.DOMAIN, KeyField.Method, KeyField.REQ_PATH)
	DOMAIN_METHOD_REQ_PATH MultiKeyField = 5
	// x-displayName: "Virtual Host, Source IP, Threat Campaign"
	// Aggregated by (KeyField.VH_NAME, KeyField.SRC_IP, KeyField.THREAT_CAMPAIGN_NAME, KeyField.THREAT_CAMPAIGN_ID)
	VH_NAME_SRC_IP_THREAT_CAMPAIGN MultiKeyField = 10
	// x-displayName: "Virtual Host, User, Threat Campaign"
	// Aggregated by (KeyField.VH_NAME, KeyField.USER, KeyField.THREAT_CAMPAIGN_NAME, KeyField.THREAT_CAMPAIGN_ID)
	VH_NAME_USER_THREAT_CAMPAIGN MultiKeyField = 11
	// x-displayName: "Virtual Host, Country, Threat Campaign"
	// Aggregated by (KeyField.VH_NAME, KeyField.COUNTRY, KeyField.THREAT_CAMPAIGN_NAME, KeyField.THREAT_CAMPAIGN_ID)
	VH_NAME_COUNTRY_THREAT_CAMPAIGN MultiKeyField = 12
	// x-displayName: "Action, Threat Campaign"
	// Aggregated by (KeyField.ACTION, KeyField.THREAT_CAMPAIGN_NAME, KeyField.THREAT_CAMPAIGN_ID)
	ACTION_THREAT_CAMPAIGN MultiKeyField = 13
	// x-displayName: "User, Source IP, Country, City, Region, ASN"
	// Aggregated by (KeyField.USER, KeyField.SRC_IP, KeyField.COUNTRY, KeyField.CITY, KeyField.REGION, KeyField.ASN)
	USER_SRC_IP_COUNTRY_CITY_REGION_ASN MultiKeyField = 14
	// x-displayName: "VH Name, Namespace"
	// Aggregated by (KeyField.VH_NAME, KeyField.NAMESPACE)
	VH_NAME_NAMESPACE MultiKeyField = 15
	// x-displayName: "api_endpoint, method"
	// Aggregated by (KeyField.API_ENDPOINT, KeyField.METHOD)
	API_ENDPOINT_METHOD MultiKeyField = 16
	// x-displayName: "JA4 TLS Fingerprint, Country"
	// Aggregated by (KeyField.JA4_TLS_FINGERPRINT, KeyField.COUNTRY)
	JA4_TLS_FINGERPRINT_COUNTRY MultiKeyField = 17
)

var MultiKeyField_name = map[int32]string{
	0:  "ASN_COUNTRY",
	1:  "DOMAIN_METHOD_API_EP",
	2:  "SRC_IP_COUNTRY",
	3:  "TLS_FINGERPRINT_COUNTRY",
	4:  "SEC_EVENT_TYPE_ACTION",
	5:  "DOMAIN_METHOD_REQ_PATH",
	10: "VH_NAME_SRC_IP_THREAT_CAMPAIGN",
	11: "VH_NAME_USER_THREAT_CAMPAIGN",
	12: "VH_NAME_COUNTRY_THREAT_CAMPAIGN",
	13: "ACTION_THREAT_CAMPAIGN",
	14: "USER_SRC_IP_COUNTRY_CITY_REGION_ASN",
	15: "VH_NAME_NAMESPACE",
	16: "API_ENDPOINT_METHOD",
	17: "JA4_TLS_FINGERPRINT_COUNTRY",
}

var MultiKeyField_value = map[string]int32{
	"ASN_COUNTRY":                         0,
	"DOMAIN_METHOD_API_EP":                1,
	"SRC_IP_COUNTRY":                      2,
	"TLS_FINGERPRINT_COUNTRY":             3,
	"SEC_EVENT_TYPE_ACTION":               4,
	"DOMAIN_METHOD_REQ_PATH":              5,
	"VH_NAME_SRC_IP_THREAT_CAMPAIGN":      10,
	"VH_NAME_USER_THREAT_CAMPAIGN":        11,
	"VH_NAME_COUNTRY_THREAT_CAMPAIGN":     12,
	"ACTION_THREAT_CAMPAIGN":              13,
	"USER_SRC_IP_COUNTRY_CITY_REGION_ASN": 14,
	"VH_NAME_NAMESPACE":                   15,
	"API_ENDPOINT_METHOD":                 16,
	"JA4_TLS_FINGERPRINT_COUNTRY":         17,
}

func (MultiKeyField) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e85477373611cb39, []int{3}
}

// Threat Level
//
// x-displayName: "Threat Level"
// Threat levels of malicious users based on suspicion score
// For all the threat levels, the range is inclusive of min_value, excluding max_value
// i.e, greater than or equal to min_val, less than max_val (min_value <= value < max_value)
type ThreatLevel int32

const (
	// x-displayName: "Threat Level Unknown"
	THREAT_LEVEL_UNKNOWN ThreatLevel = 0
	// x-displayName: "Threat Level Low"
	THREAT_LEVEL_LOW ThreatLevel = 1
	// x-displayName: "Threat Level Medium"
	THREAT_LEVEL_MEDIUM ThreatLevel = 2
	// x-displayName: "Threat Level High"
	THREAT_LEVEL_HIGH ThreatLevel = 3
)

var ThreatLevel_name = map[int32]string{
	0: "THREAT_LEVEL_UNKNOWN",
	1: "THREAT_LEVEL_LOW",
	2: "THREAT_LEVEL_MEDIUM",
	3: "THREAT_LEVEL_HIGH",
}

var ThreatLevel_value = map[string]int32{
	"THREAT_LEVEL_UNKNOWN": 0,
	"THREAT_LEVEL_LOW":     1,
	"THREAT_LEVEL_MEDIUM":  2,
	"THREAT_LEVEL_HIGH":    3,
}

func (ThreatLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e85477373611cb39, []int{4}
}

// Date SubAggregation
//
// x-displayName: "Date SubAggregation"
// Aggregate security events based on one of the sub aggregation types
type DateSubAggregation struct {
	// aggregation type
	//
	// x-displayName: "Aggregation Type"
	// Specify one of the aggregation types
	//
	// Types that are valid to be assigned to AggregationType:
	//	*DateSubAggregation_FieldAggregation
	//	*DateSubAggregation_MultiFieldAggregation
	AggregationType isDateSubAggregation_AggregationType `protobuf_oneof:"aggregation_type"`
}

func (m *DateSubAggregation) Reset()      { *m = DateSubAggregation{} }
func (*DateSubAggregation) ProtoMessage() {}
func (*DateSubAggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_e85477373611cb39, []int{0}
}
func (m *DateSubAggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DateSubAggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DateSubAggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DateSubAggregation.Merge(m, src)
}
func (m *DateSubAggregation) XXX_Size() int {
	return m.Size()
}
func (m *DateSubAggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_DateSubAggregation.DiscardUnknown(m)
}

var xxx_messageInfo_DateSubAggregation proto.InternalMessageInfo

type isDateSubAggregation_AggregationType interface {
	isDateSubAggregation_AggregationType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DateSubAggregation_FieldAggregation struct {
	FieldAggregation *FieldAggregation `protobuf:"bytes,1,opt,name=field_aggregation,json=fieldAggregation,proto3,oneof" json:"field_aggregation,omitempty"`
}
type DateSubAggregation_MultiFieldAggregation struct {
	MultiFieldAggregation *MultiFieldAggregation `protobuf:"bytes,3,opt,name=multi_field_aggregation,json=multiFieldAggregation,proto3,oneof" json:"multi_field_aggregation,omitempty"`
}

func (*DateSubAggregation_FieldAggregation) isDateSubAggregation_AggregationType()      {}
func (*DateSubAggregation_MultiFieldAggregation) isDateSubAggregation_AggregationType() {}

func (m *DateSubAggregation) GetAggregationType() isDateSubAggregation_AggregationType {
	if m != nil {
		return m.AggregationType
	}
	return nil
}

func (m *DateSubAggregation) GetFieldAggregation() *FieldAggregation {
	if x, ok := m.GetAggregationType().(*DateSubAggregation_FieldAggregation); ok {
		return x.FieldAggregation
	}
	return nil
}

func (m *DateSubAggregation) GetMultiFieldAggregation() *MultiFieldAggregation {
	if x, ok := m.GetAggregationType().(*DateSubAggregation_MultiFieldAggregation); ok {
		return x.MultiFieldAggregation
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DateSubAggregation) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DateSubAggregation_FieldAggregation)(nil),
		(*DateSubAggregation_MultiFieldAggregation)(nil),
	}
}

// Date Aggregation
//
// x-displayName: "Date Aggregation"
// Aggregate security events based on timestamp in the security event
type DateAggregation struct {
	// step
	//
	// x-displayName: "Step"
	// x-required
	// x-example: "5m"
	//
	// step is the resolution width, which determines the number of the data points [x-axis (time)] to be returned in the response.
	// The timestamps in the response will be t1=start_time, t2=t1+step, ... tn=tn-1+step, where tn <= end_time.
	// Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days
	Step string `protobuf:"bytes,1,opt,name=step,proto3" json:"step,omitempty"`
	// sub aggregation
	//
	// x-displayName: "Sub Aggregation"
	// This option provides sub-aggregation for each date bucket
	SubAggs map[string]*DateSubAggregation `protobuf:"bytes,2,rep,name=sub_aggs,json=subAggs,proto3" json:"sub_aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *DateAggregation) Reset()      { *m = DateAggregation{} }
func (*DateAggregation) ProtoMessage() {}
func (*DateAggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_e85477373611cb39, []int{1}
}
func (m *DateAggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DateAggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DateAggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DateAggregation.Merge(m, src)
}
func (m *DateAggregation) XXX_Size() int {
	return m.Size()
}
func (m *DateAggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_DateAggregation.DiscardUnknown(m)
}

var xxx_messageInfo_DateAggregation proto.InternalMessageInfo

func (m *DateAggregation) GetStep() string {
	if m != nil {
		return m.Step
	}
	return ""
}

func (m *DateAggregation) GetSubAggs() map[string]*DateSubAggregation {
	if m != nil {
		return m.SubAggs
	}
	return nil
}

// Field SubAggregation
//
// x-displayName: "Field SubAggregation"
// Aggregate security events in each field bucket based on one of the sub aggregation types
type FieldSubAggregation struct {
	// aggregation type
	//
	// x-displayName: "Aggregation Type"
	// Specify one of the aggregation types
	//
	// Types that are valid to be assigned to AggregationType:
	//	*FieldSubAggregation_CardinalityAggregation
	AggregationType isFieldSubAggregation_AggregationType `protobuf_oneof:"aggregation_type"`
}

func (m *FieldSubAggregation) Reset()      { *m = FieldSubAggregation{} }
func (*FieldSubAggregation) ProtoMessage() {}
func (*FieldSubAggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_e85477373611cb39, []int{2}
}
func (m *FieldSubAggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FieldSubAggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FieldSubAggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FieldSubAggregation.Merge(m, src)
}
func (m *FieldSubAggregation) XXX_Size() int {
	return m.Size()
}
func (m *FieldSubAggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_FieldSubAggregation.DiscardUnknown(m)
}

var xxx_messageInfo_FieldSubAggregation proto.InternalMessageInfo

type isFieldSubAggregation_AggregationType interface {
	isFieldSubAggregation_AggregationType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type FieldSubAggregation_CardinalityAggregation struct {
	CardinalityAggregation *CardinalityAggregation `protobuf:"bytes,2,opt,name=cardinality_aggregation,json=cardinalityAggregation,proto3,oneof" json:"cardinality_aggregation,omitempty"`
}

func (*FieldSubAggregation_CardinalityAggregation) isFieldSubAggregation_AggregationType() {}

func (m *FieldSubAggregation) GetAggregationType() isFieldSubAggregation_AggregationType {
	if m != nil {
		return m.AggregationType
	}
	return nil
}

func (m *FieldSubAggregation) GetCardinalityAggregation() *CardinalityAggregation {
	if x, ok := m.GetAggregationType().(*FieldSubAggregation_CardinalityAggregation); ok {
		return x.CardinalityAggregation
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*FieldSubAggregation) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*FieldSubAggregation_CardinalityAggregation)(nil),
	}
}

// Multi Field SubAggregation
//
// x-displayName: "Multi Field SubAggregation"
// Aggregate security events in each MultiTerms bucket based on one of the sub aggregation types
type MultiFieldSubAggregation struct {
	// aggregation type
	//
	// x-required
	// x-displayName: "Aggregation Type"
	// Specify one of the aggregation types
	//
	// Types that are valid to be assigned to AggregationType:
	//	*MultiFieldSubAggregation_CardinalityAggregation
	AggregationType isMultiFieldSubAggregation_AggregationType `protobuf_oneof:"aggregation_type"`
}

func (m *MultiFieldSubAggregation) Reset()      { *m = MultiFieldSubAggregation{} }
func (*MultiFieldSubAggregation) ProtoMessage() {}
func (*MultiFieldSubAggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_e85477373611cb39, []int{3}
}
func (m *MultiFieldSubAggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiFieldSubAggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MultiFieldSubAggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiFieldSubAggregation.Merge(m, src)
}
func (m *MultiFieldSubAggregation) XXX_Size() int {
	return m.Size()
}
func (m *MultiFieldSubAggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiFieldSubAggregation.DiscardUnknown(m)
}

var xxx_messageInfo_MultiFieldSubAggregation proto.InternalMessageInfo

type isMultiFieldSubAggregation_AggregationType interface {
	isMultiFieldSubAggregation_AggregationType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type MultiFieldSubAggregation_CardinalityAggregation struct {
	CardinalityAggregation *CardinalityAggregation `protobuf:"bytes,2,opt,name=cardinality_aggregation,json=cardinalityAggregation,proto3,oneof" json:"cardinality_aggregation,omitempty"`
}

func (*MultiFieldSubAggregation_CardinalityAggregation) isMultiFieldSubAggregation_AggregationType() {
}

func (m *MultiFieldSubAggregation) GetAggregationType() isMultiFieldSubAggregation_AggregationType {
	if m != nil {
		return m.AggregationType
	}
	return nil
}

func (m *MultiFieldSubAggregation) GetCardinalityAggregation() *CardinalityAggregation {
	if x, ok := m.GetAggregationType().(*MultiFieldSubAggregation_CardinalityAggregation); ok {
		return x.CardinalityAggregation
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MultiFieldSubAggregation) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MultiFieldSubAggregation_CardinalityAggregation)(nil),
	}
}

// Field Aggregation
//
// x-displayName: "Field Aggregation"
// Aggregate security events based on the key fields in the security event.
type FieldAggregation struct {
	// field
	//
	// x-displayName: "Field"
	// x-required
	//
	// Field name by which the security events should be aggregated.
	Field KeyField `protobuf:"varint,1,opt,name=field,proto3,enum=ves.io.schema.app_security.KeyField" json:"field,omitempty"`
	// topk
	//
	// x-displayName: "TopK"
	// x-example: "10"
	//
	// Number of top field values to be returned in the response.
	Topk uint32 `protobuf:"varint,2,opt,name=topk,proto3" json:"topk,omitempty"`
	// sub aggregation
	//
	// x-displayName: "Sub Aggregation"
	// This option provides sub-aggregation for each field aggregation bucket.
	SubAggs map[string]*FieldSubAggregation `protobuf:"bytes,3,rep,name=sub_aggs,json=subAggs,proto3" json:"sub_aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// order by
	//
	// x-displayName: "Order by"
	// Specify one of the order by. If order_by is not specified, topk is calculated based on the log count.
	//
	// Types that are valid to be assigned to OrderBy:
	//	*FieldAggregation_MetricsAggregation
	OrderBy isFieldAggregation_OrderBy `protobuf_oneof:"order_by"`
}

func (m *FieldAggregation) Reset()      { *m = FieldAggregation{} }
func (*FieldAggregation) ProtoMessage() {}
func (*FieldAggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_e85477373611cb39, []int{4}
}
func (m *FieldAggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FieldAggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FieldAggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FieldAggregation.Merge(m, src)
}
func (m *FieldAggregation) XXX_Size() int {
	return m.Size()
}
func (m *FieldAggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_FieldAggregation.DiscardUnknown(m)
}

var xxx_messageInfo_FieldAggregation proto.InternalMessageInfo

type isFieldAggregation_OrderBy interface {
	isFieldAggregation_OrderBy()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type FieldAggregation_MetricsAggregation struct {
	MetricsAggregation *MetricsAggregation `protobuf:"bytes,6,opt,name=metrics_aggregation,json=metricsAggregation,proto3,oneof" json:"metrics_aggregation,omitempty"`
}

func (*FieldAggregation_MetricsAggregation) isFieldAggregation_OrderBy() {}

func (m *FieldAggregation) GetOrderBy() isFieldAggregation_OrderBy {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *FieldAggregation) GetField() KeyField {
	if m != nil {
		return m.Field
	}
	return CITY
}

func (m *FieldAggregation) GetTopk() uint32 {
	if m != nil {
		return m.Topk
	}
	return 0
}

func (m *FieldAggregation) GetSubAggs() map[string]*FieldSubAggregation {
	if m != nil {
		return m.SubAggs
	}
	return nil
}

func (m *FieldAggregation) GetMetricsAggregation() *MetricsAggregation {
	if x, ok := m.GetOrderBy().(*FieldAggregation_MetricsAggregation); ok {
		return x.MetricsAggregation
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*FieldAggregation) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*FieldAggregation_MetricsAggregation)(nil),
	}
}

// Multi-Field Aggregation
//
// x-displayName: "Multi-Field Aggregation"
// Aggregate security events based on the multiple fields in the security event.
type MultiFieldAggregation struct {
	// field
	//
	// x-displayName: "Field"
	// x-required
	//
	// Multi-key field by which the security events should be aggregated.
	Field MultiKeyField `protobuf:"varint,1,opt,name=field,proto3,enum=ves.io.schema.app_security.MultiKeyField" json:"field,omitempty"`
	// topk
	//
	// x-displayName: "TopK"
	// x-example: "10"
	//
	// Number of top field values to be returned in the response.
	Topk uint32 `protobuf:"varint,2,opt,name=topk,proto3" json:"topk,omitempty"`
	// order by
	//
	// x-displayName: "Order by"
	// Specify one of the order by. If order_by is not specified, topk is calculated based on the log count.
	//
	// Types that are valid to be assigned to OrderBy:
	//	*MultiFieldAggregation_MetricsAggregation
	OrderBy isMultiFieldAggregation_OrderBy `protobuf_oneof:"order_by"`
	// sub aggregation
	//
	// x-displayName: "Sub Aggregation"
	// This option provides sub-aggregation for each field aggregation bucket.
	SubAggs map[string]*MultiFieldSubAggregation `protobuf:"bytes,7,rep,name=sub_aggs,json=subAggs,proto3" json:"sub_aggs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *MultiFieldAggregation) Reset()      { *m = MultiFieldAggregation{} }
func (*MultiFieldAggregation) ProtoMessage() {}
func (*MultiFieldAggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_e85477373611cb39, []int{5}
}
func (m *MultiFieldAggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiFieldAggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MultiFieldAggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiFieldAggregation.Merge(m, src)
}
func (m *MultiFieldAggregation) XXX_Size() int {
	return m.Size()
}
func (m *MultiFieldAggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiFieldAggregation.DiscardUnknown(m)
}

var xxx_messageInfo_MultiFieldAggregation proto.InternalMessageInfo

type isMultiFieldAggregation_OrderBy interface {
	isMultiFieldAggregation_OrderBy()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type MultiFieldAggregation_MetricsAggregation struct {
	MetricsAggregation *MetricsAggregation `protobuf:"bytes,6,opt,name=metrics_aggregation,json=metricsAggregation,proto3,oneof" json:"metrics_aggregation,omitempty"`
}

func (*MultiFieldAggregation_MetricsAggregation) isMultiFieldAggregation_OrderBy() {}

func (m *MultiFieldAggregation) GetOrderBy() isMultiFieldAggregation_OrderBy {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *MultiFieldAggregation) GetField() MultiKeyField {
	if m != nil {
		return m.Field
	}
	return ASN_COUNTRY
}

func (m *MultiFieldAggregation) GetTopk() uint32 {
	if m != nil {
		return m.Topk
	}
	return 0
}

func (m *MultiFieldAggregation) GetMetricsAggregation() *MetricsAggregation {
	if x, ok := m.GetOrderBy().(*MultiFieldAggregation_MetricsAggregation); ok {
		return x.MetricsAggregation
	}
	return nil
}

func (m *MultiFieldAggregation) GetSubAggs() map[string]*MultiFieldSubAggregation {
	if m != nil {
		return m.SubAggs
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MultiFieldAggregation) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MultiFieldAggregation_MetricsAggregation)(nil),
	}
}

// Cardinality Aggregation
//
// x-displayName: "Cardinality Aggregation"
// Get approximate count of distinct values for the field in the security event.
type CardinalityAggregation struct {
	// field
	//
	// x-displayName: "Field"
	// x-required
	//
	// Field name for which count of distinct values should be computed.
	Field KeyField `protobuf:"varint,1,opt,name=field,proto3,enum=ves.io.schema.app_security.KeyField" json:"field,omitempty"`
}

func (m *CardinalityAggregation) Reset()      { *m = CardinalityAggregation{} }
func (*CardinalityAggregation) ProtoMessage() {}
func (*CardinalityAggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_e85477373611cb39, []int{6}
}
func (m *CardinalityAggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CardinalityAggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CardinalityAggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CardinalityAggregation.Merge(m, src)
}
func (m *CardinalityAggregation) XXX_Size() int {
	return m.Size()
}
func (m *CardinalityAggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_CardinalityAggregation.DiscardUnknown(m)
}

var xxx_messageInfo_CardinalityAggregation proto.InternalMessageInfo

func (m *CardinalityAggregation) GetField() KeyField {
	if m != nil {
		return m.Field
	}
	return CITY
}

// Percentile Aggregation
//
// x-displayName: "Percentile Aggregation"
// Calculates percentile over numeric values for a field.
type PercentileAggregation struct {
	// field
	//
	// x-displayName: "Field"
	// x-required
	//
	// Field name for which percentile of values should be computed.
	Field MetricField `protobuf:"varint,1,opt,name=field,proto3,enum=ves.io.schema.app_security.MetricField" json:"field,omitempty"`
	// percent
	//
	// x-displayName: "Percent"
	// x-example: "[99.0]"
	// x-required
	//
	// Percentile for which value is calculated.
	Percent float64 `protobuf:"fixed64,3,opt,name=percent,proto3" json:"percent,omitempty"`
}

func (m *PercentileAggregation) Reset()      { *m = PercentileAggregation{} }
func (*PercentileAggregation) ProtoMessage() {}
func (*PercentileAggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_e85477373611cb39, []int{7}
}
func (m *PercentileAggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PercentileAggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PercentileAggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PercentileAggregation.Merge(m, src)
}
func (m *PercentileAggregation) XXX_Size() int {
	return m.Size()
}
func (m *PercentileAggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_PercentileAggregation.DiscardUnknown(m)
}

var xxx_messageInfo_PercentileAggregation proto.InternalMessageInfo

func (m *PercentileAggregation) GetField() MetricField {
	if m != nil {
		return m.Field
	}
	return SUSPICION_SCORE
}

func (m *PercentileAggregation) GetPercent() float64 {
	if m != nil {
		return m.Percent
	}
	return 0
}

// Metrics Aggregation
//
// x-displayName: "Metrics Aggregation"
// Computes metrics based on values for the field in the security event.
type MetricsAggregation struct {
	// aggregation type
	//
	// x-displayName: "Aggregation Type"
	// Specify one of the aggregation types
	//
	// Types that are valid to be assigned to AggregationType:
	//	*MetricsAggregation_Percentile
	AggregationType isMetricsAggregation_AggregationType `protobuf_oneof:"aggregation_type"`
}

func (m *MetricsAggregation) Reset()      { *m = MetricsAggregation{} }
func (*MetricsAggregation) ProtoMessage() {}
func (*MetricsAggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_e85477373611cb39, []int{8}
}
func (m *MetricsAggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricsAggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MetricsAggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricsAggregation.Merge(m, src)
}
func (m *MetricsAggregation) XXX_Size() int {
	return m.Size()
}
func (m *MetricsAggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricsAggregation.DiscardUnknown(m)
}

var xxx_messageInfo_MetricsAggregation proto.InternalMessageInfo

type isMetricsAggregation_AggregationType interface {
	isMetricsAggregation_AggregationType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type MetricsAggregation_Percentile struct {
	Percentile *PercentileAggregation `protobuf:"bytes,2,opt,name=percentile,proto3,oneof" json:"percentile,omitempty"`
}

func (*MetricsAggregation_Percentile) isMetricsAggregation_AggregationType() {}

func (m *MetricsAggregation) GetAggregationType() isMetricsAggregation_AggregationType {
	if m != nil {
		return m.AggregationType
	}
	return nil
}

func (m *MetricsAggregation) GetPercentile() *PercentileAggregation {
	if x, ok := m.GetAggregationType().(*MetricsAggregation_Percentile); ok {
		return x.Percentile
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MetricsAggregation) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MetricsAggregation_Percentile)(nil),
	}
}

// Aggregation Request
//
// x-displayName: "Aggregation Request"
// Aggregation request to provide analytics data over the security events
type AggregationRequest struct {
	// aggregation type
	//
	// x-displayName: "Aggregation Type"
	// Specify one of the aggregation types
	//
	// Types that are valid to be assigned to AggregationType:
	//	*AggregationRequest_DateAggregation
	//	*AggregationRequest_FieldAggregation
	//	*AggregationRequest_MultiFieldAggregation
	//	*AggregationRequest_CardinalityAggregation
	//	*AggregationRequest_MetricsAggregation
	AggregationType isAggregationRequest_AggregationType `protobuf_oneof:"aggregation_type"`
	// Trend value computation requested for the field present in aggregation.
	//
	// x-displayName: "Trend calculation requested by the user"
	// x-example: "true"
	// Trend value computation requested by the user
	// Optional: default is false
	IsTrendRequest bool `protobuf:"varint,7,opt,name=is_trend_request,json=isTrendRequest,proto3" json:"is_trend_request,omitempty"`
}

func (m *AggregationRequest) Reset()      { *m = AggregationRequest{} }
func (*AggregationRequest) ProtoMessage() {}
func (*AggregationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e85477373611cb39, []int{9}
}
func (m *AggregationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggregationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AggregationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggregationRequest.Merge(m, src)
}
func (m *AggregationRequest) XXX_Size() int {
	return m.Size()
}
func (m *AggregationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AggregationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AggregationRequest proto.InternalMessageInfo

type isAggregationRequest_AggregationType interface {
	isAggregationRequest_AggregationType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type AggregationRequest_DateAggregation struct {
	DateAggregation *DateAggregation `protobuf:"bytes,1,opt,name=date_aggregation,json=dateAggregation,proto3,oneof" json:"date_aggregation,omitempty"`
}
type AggregationRequest_FieldAggregation struct {
	FieldAggregation *FieldAggregation `protobuf:"bytes,2,opt,name=field_aggregation,json=fieldAggregation,proto3,oneof" json:"field_aggregation,omitempty"`
}
type AggregationRequest_MultiFieldAggregation struct {
	MultiFieldAggregation *MultiFieldAggregation `protobuf:"bytes,5,opt,name=multi_field_aggregation,json=multiFieldAggregation,proto3,oneof" json:"multi_field_aggregation,omitempty"`
}
type AggregationRequest_CardinalityAggregation struct {
	CardinalityAggregation *CardinalityAggregation `protobuf:"bytes,4,opt,name=cardinality_aggregation,json=cardinalityAggregation,proto3,oneof" json:"cardinality_aggregation,omitempty"`
}
type AggregationRequest_MetricsAggregation struct {
	MetricsAggregation *MetricsAggregation `protobuf:"bytes,6,opt,name=metrics_aggregation,json=metricsAggregation,proto3,oneof" json:"metrics_aggregation,omitempty"`
}

func (*AggregationRequest_DateAggregation) isAggregationRequest_AggregationType()        {}
func (*AggregationRequest_FieldAggregation) isAggregationRequest_AggregationType()       {}
func (*AggregationRequest_MultiFieldAggregation) isAggregationRequest_AggregationType()  {}
func (*AggregationRequest_CardinalityAggregation) isAggregationRequest_AggregationType() {}
func (*AggregationRequest_MetricsAggregation) isAggregationRequest_AggregationType()     {}

func (m *AggregationRequest) GetAggregationType() isAggregationRequest_AggregationType {
	if m != nil {
		return m.AggregationType
	}
	return nil
}

func (m *AggregationRequest) GetDateAggregation() *DateAggregation {
	if x, ok := m.GetAggregationType().(*AggregationRequest_DateAggregation); ok {
		return x.DateAggregation
	}
	return nil
}

func (m *AggregationRequest) GetFieldAggregation() *FieldAggregation {
	if x, ok := m.GetAggregationType().(*AggregationRequest_FieldAggregation); ok {
		return x.FieldAggregation
	}
	return nil
}

func (m *AggregationRequest) GetMultiFieldAggregation() *MultiFieldAggregation {
	if x, ok := m.GetAggregationType().(*AggregationRequest_MultiFieldAggregation); ok {
		return x.MultiFieldAggregation
	}
	return nil
}

func (m *AggregationRequest) GetCardinalityAggregation() *CardinalityAggregation {
	if x, ok := m.GetAggregationType().(*AggregationRequest_CardinalityAggregation); ok {
		return x.CardinalityAggregation
	}
	return nil
}

func (m *AggregationRequest) GetMetricsAggregation() *MetricsAggregation {
	if x, ok := m.GetAggregationType().(*AggregationRequest_MetricsAggregation); ok {
		return x.MetricsAggregation
	}
	return nil
}

func (m *AggregationRequest) GetIsTrendRequest() bool {
	if m != nil {
		return m.IsTrendRequest
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AggregationRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AggregationRequest_DateAggregation)(nil),
		(*AggregationRequest_FieldAggregation)(nil),
		(*AggregationRequest_MultiFieldAggregation)(nil),
		(*AggregationRequest_CardinalityAggregation)(nil),
		(*AggregationRequest_MetricsAggregation)(nil),
	}
}

func init() {
	proto.RegisterEnum("ves.io.schema.app_security.SecEventType", SecEventType_name, SecEventType_value)
	proto.RegisterEnum("ves.io.schema.app_security.MetricField", MetricField_name, MetricField_value)
	proto.RegisterEnum("ves.io.schema.app_security.KeyField", KeyField_name, KeyField_value)
	proto.RegisterEnum("ves.io.schema.app_security.MultiKeyField", MultiKeyField_name, MultiKeyField_value)
	proto.RegisterEnum("ves.io.schema.app_security.ThreatLevel", ThreatLevel_name, ThreatLevel_value)
	proto.RegisterType((*DateSubAggregation)(nil), "ves.io.schema.app_security.DateSubAggregation")
	proto.RegisterType((*DateAggregation)(nil), "ves.io.schema.app_security.DateAggregation")
	proto.RegisterMapType((map[string]*DateSubAggregation)(nil), "ves.io.schema.app_security.DateAggregation.SubAggsEntry")
	proto.RegisterType((*FieldSubAggregation)(nil), "ves.io.schema.app_security.FieldSubAggregation")
	proto.RegisterType((*MultiFieldSubAggregation)(nil), "ves.io.schema.app_security.MultiFieldSubAggregation")
	proto.RegisterType((*FieldAggregation)(nil), "ves.io.schema.app_security.FieldAggregation")
	proto.RegisterMapType((map[string]*FieldSubAggregation)(nil), "ves.io.schema.app_security.FieldAggregation.SubAggsEntry")
	proto.RegisterType((*MultiFieldAggregation)(nil), "ves.io.schema.app_security.MultiFieldAggregation")
	proto.RegisterMapType((map[string]*MultiFieldSubAggregation)(nil), "ves.io.schema.app_security.MultiFieldAggregation.SubAggsEntry")
	proto.RegisterType((*CardinalityAggregation)(nil), "ves.io.schema.app_security.CardinalityAggregation")
	proto.RegisterType((*PercentileAggregation)(nil), "ves.io.schema.app_security.PercentileAggregation")
	proto.RegisterType((*MetricsAggregation)(nil), "ves.io.schema.app_security.MetricsAggregation")
	proto.RegisterType((*AggregationRequest)(nil), "ves.io.schema.app_security.AggregationRequest")
}

func init() {
	proto.RegisterFile("ves.io/schema/app_security/types.proto", fileDescriptor_e85477373611cb39)
}

var fileDescriptor_e85477373611cb39 = []byte{
	// 1977 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0xbf, 0x73, 0xdb, 0xd6,
	0x1d, 0x27, 0x48, 0x48, 0x84, 0x9e, 0x7e, 0x3d, 0x3d, 0x59, 0x12, 0x4d, 0x29, 0xb4, 0x0a, 0xa7,
	0xb1, 0x22, 0x5b, 0x64, 0xa2, 0xa4, 0x89, 0xed, 0x36, 0x89, 0x20, 0xf0, 0x49, 0x84, 0x4c, 0x02,
	0x2c, 0x00, 0x4a, 0x51, 0x3b, 0xe0, 0x28, 0x09, 0xa6, 0x59, 0x49, 0x24, 0x0b, 0x82, 0x72, 0x35,
	0xf8, 0x2e, 0x43, 0x87, 0x5e, 0xa6, 0x2e, 0x5d, 0x3c, 0x75, 0xec, 0x98, 0xa5, 0x4b, 0xb5, 0x78,
	0xe8, 0xd0, 0xeb, 0xa4, 0xd1, 0xd7, 0xeb, 0x10, 0xcb, 0x1d, 0xda, 0x2d, 0xd7, 0xbf, 0xa0, 0xf7,
	0x7d, 0x00, 0x28, 0x80, 0xa2, 0x25, 0xbb, 0x4d, 0x7a, 0x17, 0x4e, 0x7c, 0xdf, 0xdf, 0xdf, 0xcf,
	0xf7, 0xc7, 0x7b, 0x07, 0xf4, 0xce, 0x91, 0xdd, 0xce, 0xd6, 0x9b, 0xb9, 0xf6, 0xee, 0x23, 0xfb,
	0xb0, 0x9a, 0xab, 0xb6, 0x5a, 0x56, 0xdb, 0xde, 0xed, 0x38, 0x75, 0xf7, 0x38, 0xe7, 0x1e, 0xb7,
	0xec, 0x76, 0xb6, 0xe5, 0x34, 0xdd, 0x26, 0x49, 0x7b, 0x72, 0x59, 0x4f, 0x2e, 0x1b, 0x96, 0x4b,
	0x2f, 0xd5, 0xea, 0xee, 0xa3, 0xce, 0x4e, 0x76, 0xb7, 0x79, 0x98, 0xab, 0x35, 0x6b, 0xcd, 0x1c,
	0x53, 0xd9, 0xe9, 0x3c, 0x64, 0x27, 0x76, 0x60, 0xff, 0x3c, 0x53, 0xe9, 0xd9, 0xa8, 0xcb, 0x66,
	0xcb, 0xad, 0x37, 0x1b, 0xbe, 0x9f, 0xf4, 0x5c, 0x94, 0x79, 0x54, 0x3d, 0xa8, 0xef, 0x55, 0x5d,
	0xdb, 0xe7, 0xce, 0xf7, 0x70, 0xeb, 0xf6, 0x63, 0x2b, 0xa2, 0x2f, 0x7e, 0x19, 0x47, 0x24, 0x5f,
	0x75, 0x6d, 0xa3, 0xb3, 0x23, 0xd5, 0x6a, 0x8e, 0x5d, 0xab, 0x02, 0x97, 0xfc, 0x1c, 0x4d, 0x3c,
	0xac, 0xdb, 0x07, 0x7b, 0x56, 0xf5, 0x9c, 0x98, 0xe2, 0xe6, 0xb9, 0x85, 0xe1, 0xe5, 0x3b, 0xd9,
	0x57, 0xa7, 0x96, 0x5d, 0x03, 0xa5, 0x90, 0xa1, 0x42, 0x4c, 0xc7, 0x0f, 0x7b, 0x68, 0x64, 0x1f,
	0xcd, 0x1c, 0x76, 0x0e, 0xdc, 0xba, 0x75, 0xd1, 0x45, 0x82, 0xb9, 0x78, 0xff, 0x32, 0x17, 0x25,
	0x50, 0xed, 0xe3, 0x67, 0xea, 0xb0, 0x1f, 0xe3, 0xfe, 0xe0, 0x5f, 0x4f, 0xb8, 0x38, 0xe6, 0x56,
	0xe7, 0x10, 0x0e, 0x39, 0xb2, 0xa0, 0x56, 0x44, 0x78, 0x76, 0xc2, 0x71, 0xa7, 0x27, 0x5c, 0x7c,
	0x83, 0x17, 0xe2, 0x38, 0x21, 0xfe, 0x9b, 0x43, 0xe3, 0x00, 0x46, 0x38, 0xd8, 0x0c, 0xe2, 0xdb,
	0xae, 0xdd, 0x62, 0xc9, 0x0f, 0xad, 0xa2, 0x3f, 0xfd, 0xeb, 0x59, 0x62, 0xc0, 0x49, 0xfc, 0x9e,
	0xe7, 0x74, 0x46, 0x27, 0x06, 0x12, 0xda, 0x9d, 0x1d, 0x48, 0xa2, 0x9d, 0x8a, 0xcf, 0x27, 0x16,
	0x86, 0x97, 0xef, 0x5e, 0x16, 0x7d, 0x8f, 0xf9, 0xac, 0x87, 0x7b, 0x9b, 0x36, 0x5c, 0xe7, 0x58,
	0x4f, 0xb6, 0xbd, 0x53, 0xfa, 0x17, 0x68, 0x24, 0xcc, 0x20, 0x18, 0x25, 0xf6, 0xed, 0x63, 0x2f,
	0x06, 0x1d, 0xfe, 0x92, 0x3c, 0x1a, 0x38, 0xaa, 0x1e, 0x74, 0xec, 0x54, 0x9c, 0x21, 0x96, 0xbd,
	0xca, 0x67, 0xb4, 0xbe, 0xba, 0xa7, 0x7c, 0x3f, 0x7e, 0x97, 0x13, 0xbf, 0xe2, 0xd0, 0x24, 0x43,
	0xad, 0xa7, 0x05, 0x0e, 0xd1, 0xcc, 0x6e, 0xd5, 0xd9, 0xab, 0x37, 0xaa, 0x07, 0x75, 0xf7, 0x38,
	0x52, 0x25, 0xcf, 0xe7, 0xf2, 0x65, 0x3e, 0xe5, 0x73, 0xd5, 0x68, 0x99, 0xa6, 0x77, 0xfb, 0x72,
	0xae, 0xac, 0x53, 0xfc, 0xf4, 0x84, 0xe3, 0x36, 0x78, 0x81, 0xc3, 0x71, 0xf1, 0x8f, 0x1c, 0x4a,
	0x9d, 0xb7, 0xc1, 0xf7, 0x27, 0xee, 0xaf, 0x12, 0x08, 0xf7, 0x36, 0x28, 0xb9, 0x8f, 0x06, 0xd8,
	0x1c, 0xb0, 0xea, 0x8e, 0x2d, 0xbf, 0x7d, 0x59, 0x74, 0x0f, 0xec, 0x63, 0xa6, 0xaf, 0x7b, 0x2a,
	0x44, 0x44, 0xbc, 0xdb, 0x6c, 0xed, 0xb3, 0xc4, 0x46, 0x57, 0xc7, 0xfe, 0x76, 0xc2, 0x71, 0x3f,
	0x82, 0x0e, 0xe5, 0x17, 0xe3, 0xa9, 0x3d, 0x9d, 0xf1, 0x88, 0x19, 0x6a, 0xd0, 0x04, 0x6b, 0xd0,
	0x7b, 0x6f, 0x32, 0xc1, 0xfd, 0x3b, 0x94, 0x54, 0xd1, 0xe4, 0xa1, 0xed, 0x3a, 0xf5, 0xdd, 0x76,
	0x04, 0xe1, 0xc1, 0xab, 0xbb, 0xb1, 0xe4, 0xa9, 0x45, 0xd1, 0x25, 0x87, 0x17, 0xa8, 0xe9, 0xfd,
	0x2b, 0x87, 0x80, 0x46, 0x87, 0x20, 0x77, 0x65, 0x5e, 0xaf, 0x9c, 0x82, 0x55, 0x8c, 0x84, 0xa6,
	0xb3, 0x67, 0x3b, 0xd6, 0xce, 0x31, 0xe1, 0x4f, 0x4f, 0x38, 0x7e, 0x83, 0x17, 0x78, 0x3c, 0x20,
	0xfe, 0x39, 0x81, 0xa6, 0xfa, 0x6e, 0x1c, 0xf2, 0x59, 0xb4, 0x6e, 0xef, 0x5e, 0xb9, 0xb3, 0xfe,
	0x9b, 0xe2, 0x7d, 0xf7, 0x30, 0x93, 0xed, 0x50, 0x7f, 0x24, 0x59, 0x7f, 0x7c, 0xfa, 0xc6, 0xeb,
	0xf7, 0x15, 0x6b, 0xac, 0x75, 0x65, 0x05, 0x37, 0xa2, 0x15, 0xfc, 0xf0, 0xf5, 0x3c, 0xbf, 0x7e,
	0x19, 0x13, 0x1b, 0xbc, 0x90, 0xc0, 0xbc, 0x68, 0xa2, 0xe9, 0xfe, 0x93, 0xfd, 0xbf, 0x8c, 0x9f,
	0xf8, 0x1b, 0x0e, 0x4d, 0x95, 0x6d, 0x67, 0xd7, 0x6e, 0xb8, 0xf5, 0x83, 0xc8, 0xad, 0xf1, 0x49,
	0xd4, 0xea, 0xad, 0xab, 0x2b, 0x15, 0x69, 0x8d, 0x45, 0x94, 0x6c, 0x79, 0x76, 0xd9, 0x8d, 0xc8,
	0xad, 0x62, 0x68, 0x8c, 0x61, 0x32, 0x74, 0x3d, 0xc6, 0x7e, 0xdb, 0x2b, 0x7a, 0x20, 0xe0, 0x5f,
	0x5d, 0xbf, 0xe3, 0x10, 0xb9, 0x58, 0x72, 0x62, 0x20, 0xd4, 0xea, 0x06, 0xe8, 0x83, 0x7c, 0xe9,
	0xed, 0xda, 0x37, 0x9d, 0x42, 0x4c, 0x0f, 0x99, 0x79, 0xa3, 0x95, 0xf7, 0x35, 0x8f, 0x48, 0xb8,
	0x56, 0xf6, 0x2f, 0x3b, 0x76, 0xdb, 0x25, 0x9f, 0x23, 0x0c, 0xcf, 0x94, 0x3e, 0xcf, 0x8b, 0xdb,
	0x6f, 0x70, 0x7b, 0x16, 0x62, 0xfa, 0xf8, 0x5e, 0xcf, 0x7d, 0xdd, 0xf7, 0xe5, 0x12, 0xff, 0xee,
	0x5f, 0x2e, 0x03, 0xdf, 0xf6, 0xcb, 0xe5, 0xb2, 0x8b, 0x8c, 0xff, 0xf6, 0x2f, 0xb2, 0xff, 0xc7,
	0xaa, 0x59, 0x40, 0xb8, 0xde, 0xb6, 0x5c, 0xc7, 0x6e, 0xec, 0x59, 0x8e, 0xd7, 0x09, 0xa9, 0xe4,
	0x3c, 0xb7, 0x20, 0xe8, 0x63, 0xf5, 0xb6, 0x09, 0x64, 0xbf, 0x3f, 0x5e, 0xeb, 0xd5, 0xe6, 0xcf,
	0xf6, 0xe2, 0xaf, 0xe3, 0x68, 0xc4, 0xb0, 0x77, 0xe9, 0x91, 0xdd, 0x70, 0x4d, 0x10, 0x98, 0x40,
	0xa3, 0x5b, 0xd2, 0x9a, 0x65, 0x50, 0xd9, 0xa2, 0x9b, 0x54, 0x35, 0x71, 0x8c, 0xcc, 0xa0, 0xc9,
	0xe2, 0xc7, 0x56, 0x59, 0x2b, 0x2a, 0xf2, 0x76, 0x88, 0xc1, 0x91, 0x34, 0x9a, 0xde, 0x30, 0x2c,
	0xb9, 0x20, 0x15, 0x8b, 0x54, 0x5d, 0xa7, 0x21, 0x5e, 0x9c, 0xdc, 0x40, 0xb3, 0xb2, 0x54, 0x36,
	0xe5, 0x82, 0xd4, 0x57, 0x20, 0x41, 0xe6, 0x50, 0xaa, 0x24, 0x15, 0x15, 0x59, 0xd1, 0x2a, 0x86,
	0x55, 0x31, 0xa8, 0x1e, 0xe2, 0xf2, 0x24, 0x85, 0xae, 0x19, 0x9b, 0xf2, 0x45, 0xa7, 0x03, 0xe4,
	0x3a, 0x9a, 0x5a, 0xd5, 0x4c, 0x2b, 0x4f, 0xd7, 0xa8, 0x6a, 0x84, 0x4d, 0x0e, 0x42, 0xec, 0x52,
	0x59, 0x09, 0x91, 0x92, 0x84, 0xa0, 0xb1, 0x7c, 0x5e, 0x33, 0x42, 0x34, 0x01, 0xc4, 0xa2, 0xa4,
	0xa1, 0x45, 0x11, 0x0d, 0x87, 0x36, 0x09, 0x99, 0x44, 0xe3, 0x46, 0xc5, 0x28, 0x43, 0x70, 0xaa,
	0x65, 0xc8, 0x9a, 0x4e, 0x71, 0x6c, 0xf1, 0x1f, 0x43, 0x48, 0x08, 0x96, 0x18, 0x11, 0x10, 0x2f,
	0x2b, 0xe6, 0x36, 0x8e, 0x91, 0x61, 0x94, 0x94, 0xb5, 0x8a, 0x6a, 0xea, 0xdb, 0x98, 0x03, 0x77,
	0x5d, 0xb3, 0x96, 0xb9, 0x5d, 0xa6, 0x38, 0x4e, 0x46, 0x90, 0x60, 0xe8, 0xb2, 0x65, 0x28, 0x26,
	0xc5, 0x09, 0x10, 0xdf, 0x2c, 0x58, 0xaa, 0x54, 0xa2, 0x98, 0xf7, 0x0f, 0x4c, 0x6e, 0x00, 0x4c,
	0x02, 0x0c, 0x78, 0x90, 0xcc, 0xa2, 0x99, 0xc0, 0x7d, 0x80, 0x4d, 0xe0, 0x22, 0x09, 0xa0, 0xf7,
	0x32, 0x75, 0xba, 0xae, 0x68, 0x2a, 0x16, 0xa0, 0x52, 0xbd, 0x3c, 0xc9, 0x50, 0xf1, 0x50, 0x3f,
	0x25, 0x88, 0x49, 0x29, 0x63, 0x04, 0x85, 0xe8, 0xc7, 0x63, 0xf1, 0x0e, 0x93, 0x9b, 0xe8, 0x46,
	0x2f, 0xd7, 0x2c, 0x1a, 0xd6, 0x9a, 0xa2, 0xae, 0x53, 0xbd, 0xac, 0x2b, 0xaa, 0x89, 0x47, 0xc8,
	0x28, 0x1a, 0xda, 0x54, 0xb4, 0xa2, 0x64, 0x42, 0x18, 0xa3, 0x64, 0x1c, 0x0d, 0x4b, 0xa6, 0x29,
	0xc9, 0x0f, 0xbc, 0xd4, 0xc6, 0x80, 0x6f, 0x28, 0xeb, 0xaa, 0x64, 0x56, 0x74, 0x8a, 0xc7, 0x01,
	0x5e, 0xb3, 0xa0, 0x53, 0xc9, 0xb4, 0x64, 0xa9, 0x54, 0x96, 0x94, 0x75, 0x15, 0x63, 0x92, 0x44,
	0x89, 0x8a, 0xae, 0xe0, 0x09, 0x32, 0x8d, 0x08, 0x14, 0x58, 0x2e, 0x4a, 0x86, 0xa1, 0xac, 0x29,
	0xb2, 0x67, 0x95, 0x80, 0x96, 0x54, 0x31, 0xb5, 0x12, 0x3b, 0x7b, 0x96, 0x27, 0x09, 0x42, 0x83,
	0x79, 0xad, 0x24, 0x29, 0x2a, 0xbe, 0x06, 0x40, 0x83, 0x22, 0xe3, 0x4c, 0x05, 0x27, 0x86, 0xf4,
	0x34, 0xc8, 0xf9, 0x09, 0xcf, 0x30, 0xf7, 0x3d, 0x29, 0xa4, 0xc0, 0x3d, 0x40, 0x75, 0x1d, 0x24,
	0xa1, 0x89, 0x68, 0x19, 0xa7, 0x09, 0x46, 0x23, 0xab, 0xba, 0xb6, 0xc5, 0x92, 0x06, 0xab, 0xb3,
	0x90, 0x5a, 0x9e, 0x6e, 0x2a, 0x32, 0xf5, 0x08, 0x73, 0x20, 0x5e, 0xa2, 0x66, 0x41, 0xcb, 0xe3,
	0xb7, 0x20, 0x4d, 0x9d, 0x1a, 0x65, 0x4b, 0xd6, 0xf2, 0x14, 0x67, 0xc8, 0x14, 0x9a, 0xe8, 0x1e,
	0xad, 0x3c, 0x35, 0x25, 0xa5, 0x68, 0xe0, 0xfb, 0xd1, 0x1e, 0x61, 0xe1, 0xdd, 0x80, 0x60, 0x61,
	0xea, 0x4a, 0xa0, 0x38, 0xcf, 0x24, 0x02, 0xb8, 0x3c, 0x89, 0x1f, 0x40, 0x28, 0xe7, 0x34, 0x25,
	0x8f, 0x45, 0xd6, 0xa4, 0x5d, 0x8a, 0x61, 0x4a, 0x26, 0xc5, 0x37, 0x01, 0xbc, 0x73, 0xa2, 0x24,
	0xcb, 0x15, 0x5d, 0x92, 0xb7, 0xf1, 0xdb, 0x20, 0xdc, 0xad, 0x90, 0x2f, 0xfc, 0x43, 0x18, 0xb2,
	0x9e, 0x3a, 0x78, 0xde, 0xde, 0x01, 0x33, 0xbd, 0x1c, 0x25, 0x8f, 0x6f, 0xc1, 0xf0, 0xf5, 0xd2,
	0x3d, 0x63, 0x0b, 0xe4, 0x1a, 0xc2, 0xe7, 0x1e, 0x74, 0xc9, 0x54, 0xd4, 0x75, 0xfc, 0xae, 0x97,
	0xac, 0xce, 0x00, 0xf3, 0x66, 0x19, 0x67, 0x41, 0x12, 0xf0, 0x97, 0x95, 0x72, 0x01, 0x7a, 0xad,
	0x02, 0x8d, 0x96, 0x03, 0x64, 0x81, 0xba, 0x49, 0x75, 0x03, 0xea, 0xfd, 0x1e, 0x34, 0x73, 0x78,
	0xd0, 0x15, 0xd5, 0x50, 0xd6, 0x0b, 0x26, 0x7e, 0x9f, 0x64, 0x50, 0x3a, 0xcc, 0xd0, 0xa9, 0xac,
	0x95, 0x4a, 0x54, 0xcd, 0x7b, 0x8d, 0xb2, 0x0c, 0x96, 0x80, 0x2f, 0xa9, 0x5a, 0x49, 0x2a, 0x6e,
	0xe3, 0x0f, 0x20, 0xea, 0x68, 0x10, 0x96, 0x4e, 0x8d, 0x4a, 0xd1, 0xc4, 0x1f, 0x41, 0x8d, 0xce,
	0xf1, 0x92, 0x35, 0xd5, 0xa4, 0x9f, 0x9b, 0xf8, 0x63, 0xd6, 0x04, 0x32, 0x33, 0x77, 0x17, 0xaa,
	0x0a, 0xa8, 0x18, 0x65, 0x49, 0xa6, 0xf8, 0xc7, 0x50, 0x2a, 0x9d, 0xfe, 0xd4, 0xd2, 0x15, 0xe3,
	0x01, 0xfe, 0x09, 0xe0, 0x1a, 0x9c, 0x2c, 0x9d, 0x4a, 0x86, 0xa6, 0xe2, 0x4f, 0x20, 0xf2, 0x0d,
	0xe9, 0xc3, 0x0b, 0x73, 0xf2, 0x29, 0xb9, 0x85, 0x6e, 0xf6, 0x0e, 0x53, 0x3f, 0xc1, 0xcf, 0xa0,
	0xda, 0x25, 0xa9, 0xb8, 0x25, 0x05, 0xf5, 0x5f, 0x09, 0x53, 0x58, 0xe7, 0x49, 0xe0, 0x25, 0xa0,
	0x18, 0xb2, 0xa4, 0x06, 0x39, 0xad, 0x02, 0x3e, 0x01, 0xa3, 0x8b, 0x0d, 0xcd, 0x5b, 0x7e, 0x42,
	0xb2, 0xc8, 0x0b, 0x8b, 0x78, 0x51, 0xe4, 0x85, 0xdb, 0xf8, 0xb6, 0xc8, 0x0b, 0x77, 0xf0, 0x1d,
	0x91, 0x17, 0x96, 0xf0, 0x92, 0xc8, 0x0b, 0xf7, 0xf0, 0xbd, 0xc5, 0x93, 0x04, 0x1a, 0x8d, 0x3c,
	0xb9, 0xd9, 0x38, 0x1b, 0x6a, 0x77, 0x05, 0xc5, 0xa0, 0x6f, 0xbc, 0xa1, 0xb3, 0xbc, 0xd6, 0xb7,
	0xfc, 0x81, 0xf1, 0xf6, 0x1f, 0x1b, 0xb3, 0xae, 0x74, 0x1c, 0xb6, 0x59, 0x4f, 0x82, 0x5d, 0x66,
	0xc2, 0x2b, 0x4d, 0x78, 0x61, 0x06, 0x61, 0xf2, 0xb0, 0xb3, 0xa2, 0x5e, 0x00, 0xe8, 0xb2, 0x64,
	0x16, 0xf0, 0x00, 0x11, 0x51, 0xc6, 0xdf, 0xa2, 0xfe, 0x1e, 0xb3, 0x7a, 0x17, 0x0a, 0x22, 0xf3,
	0x68, 0x2e, 0x90, 0xf1, 0xd6, 0x56, 0x8f, 0x04, 0xdb, 0x6d, 0x81, 0x84, 0x1f, 0xd1, 0x05, 0xa1,
	0x11, 0x08, 0xc3, 0x0b, 0xe9, 0x02, 0x6f, 0x14, 0xea, 0x19, 0xda, 0xa5, 0x5d, 0x23, 0x70, 0x33,
	0xf8, 0x4b, 0x99, 0xed, 0xdf, 0x31, 0x68, 0xb3, 0xc0, 0xd3, 0x79, 0x2f, 0x8d, 0x43, 0x09, 0x19,
	0x74, 0x6a, 0xbe, 0xac, 0x01, 0x2e, 0xfe, 0x26, 0xc1, 0x70, 0x7b, 0xf6, 0x69, 0x8c, 0x2e, 0x6e,
	0x13, 0x22, 0x2f, 0x0c, 0xe2, 0x41, 0x91, 0x17, 0x92, 0x38, 0x29, 0xf2, 0x82, 0x80, 0x05, 0x91,
	0x17, 0x86, 0xf0, 0xd0, 0xe2, 0xdf, 0x39, 0x34, 0x6c, 0x3e, 0x72, 0xec, 0xaa, 0x5b, 0xb4, 0x8f,
	0xec, 0x03, 0x92, 0xeb, 0x8e, 0x78, 0x91, 0x6e, 0xd2, 0xa2, 0x55, 0x51, 0x1f, 0xa8, 0xda, 0x96,
	0x8a, 0x63, 0xe9, 0xa9, 0xa7, 0x4f, 0xc8, 0x10, 0x7b, 0x10, 0x7f, 0xa1, 0xae, 0xa4, 0x93, 0x95,
	0xc6, 0x7e, 0xa3, 0xf9, 0xb8, 0x41, 0xde, 0x43, 0x38, 0xa2, 0x50, 0xd4, 0xb6, 0x30, 0x97, 0x4e,
	0x3f, 0x7d, 0x32, 0xe3, 0x09, 0x3f, 0xd3, 0x57, 0x26, 0xba, 0x5a, 0x89, 0x62, 0xf3, 0x31, 0xf9,
	0x08, 0x4d, 0x46, 0x34, 0x4a, 0x34, 0xaf, 0x54, 0x4a, 0x38, 0x9e, 0x7e, 0xeb, 0xe9, 0x93, 0xb4,
	0xaf, 0x54, 0xf1, 0x95, 0x9e, 0xe9, 0x2b, 0xe9, 0xc1, 0x92, 0xbd, 0x57, 0xef, 0x1c, 0x92, 0x65,
	0x34, 0x11, 0xd1, 0x2b, 0x28, 0xeb, 0x05, 0x9c, 0x48, 0xcf, 0x3e, 0x7d, 0x92, 0xf2, 0xb4, 0x56,
	0xb6, 0x03, 0xad, 0xca, 0x4a, 0x9a, 0x2f, 0xd4, 0x6b, 0x8f, 0x56, 0xbf, 0xe4, 0x4e, 0x5f, 0x64,
	0x62, 0xcf, 0x5f, 0x64, 0x62, 0xdf, 0xbc, 0xc8, 0x70, 0x5f, 0x9c, 0x65, 0xb8, 0x3f, 0x9c, 0x65,
	0xb8, 0xbf, 0x9c, 0x65, 0xb8, 0xd3, 0xb3, 0x0c, 0xf7, 0xfc, 0x2c, 0xc3, 0x7d, 0x7d, 0x96, 0xe1,
	0xfe, 0x79, 0x96, 0x89, 0x7d, 0x73, 0x96, 0xe1, 0x7e, 0xfb, 0x32, 0x13, 0x3b, 0x7d, 0x99, 0x89,
	0x3d, 0x7f, 0x99, 0x89, 0xfd, 0xac, 0x5c, 0x6b, 0xb6, 0xf6, 0x6b, 0xd9, 0xa3, 0xe6, 0x81, 0x6b,
	0x3b, 0x4e, 0x35, 0xdb, 0x69, 0xe7, 0xd8, 0x9f, 0x87, 0x4d, 0xe7, 0x70, 0xa9, 0xe5, 0x34, 0x8f,
	0xea, 0x7b, 0xb6, 0xb3, 0x14, 0xb0, 0x73, 0xad, 0x9d, 0x5a, 0x33, 0x67, 0xff, 0xca, 0xf5, 0xbf,
	0xfe, 0xf5, 0xf9, 0x64, 0xb9, 0x33, 0xc8, 0xbe, 0x02, 0x7e, 0xf0, 0x9f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0xde, 0xbe, 0x5b, 0x5e, 0xd7, 0x14, 0x00, 0x00,
}

func (x SecEventType) String() string {
	s, ok := SecEventType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MetricField) String() string {
	s, ok := MetricField_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x KeyField) String() string {
	s, ok := KeyField_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MultiKeyField) String() string {
	s, ok := MultiKeyField_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ThreatLevel) String() string {
	s, ok := ThreatLevel_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *DateSubAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DateSubAggregation)
	if !ok {
		that2, ok := that.(DateSubAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AggregationType == nil {
		if this.AggregationType != nil {
			return false
		}
	} else if this.AggregationType == nil {
		return false
	} else if !this.AggregationType.Equal(that1.AggregationType) {
		return false
	}
	return true
}
func (this *DateSubAggregation_FieldAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DateSubAggregation_FieldAggregation)
	if !ok {
		that2, ok := that.(DateSubAggregation_FieldAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FieldAggregation.Equal(that1.FieldAggregation) {
		return false
	}
	return true
}
func (this *DateSubAggregation_MultiFieldAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DateSubAggregation_MultiFieldAggregation)
	if !ok {
		that2, ok := that.(DateSubAggregation_MultiFieldAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MultiFieldAggregation.Equal(that1.MultiFieldAggregation) {
		return false
	}
	return true
}
func (this *DateAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DateAggregation)
	if !ok {
		that2, ok := that.(DateAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Step != that1.Step {
		return false
	}
	if len(this.SubAggs) != len(that1.SubAggs) {
		return false
	}
	for i := range this.SubAggs {
		if !this.SubAggs[i].Equal(that1.SubAggs[i]) {
			return false
		}
	}
	return true
}
func (this *FieldSubAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FieldSubAggregation)
	if !ok {
		that2, ok := that.(FieldSubAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AggregationType == nil {
		if this.AggregationType != nil {
			return false
		}
	} else if this.AggregationType == nil {
		return false
	} else if !this.AggregationType.Equal(that1.AggregationType) {
		return false
	}
	return true
}
func (this *FieldSubAggregation_CardinalityAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FieldSubAggregation_CardinalityAggregation)
	if !ok {
		that2, ok := that.(FieldSubAggregation_CardinalityAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CardinalityAggregation.Equal(that1.CardinalityAggregation) {
		return false
	}
	return true
}
func (this *MultiFieldSubAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MultiFieldSubAggregation)
	if !ok {
		that2, ok := that.(MultiFieldSubAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AggregationType == nil {
		if this.AggregationType != nil {
			return false
		}
	} else if this.AggregationType == nil {
		return false
	} else if !this.AggregationType.Equal(that1.AggregationType) {
		return false
	}
	return true
}
func (this *MultiFieldSubAggregation_CardinalityAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MultiFieldSubAggregation_CardinalityAggregation)
	if !ok {
		that2, ok := that.(MultiFieldSubAggregation_CardinalityAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CardinalityAggregation.Equal(that1.CardinalityAggregation) {
		return false
	}
	return true
}
func (this *FieldAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FieldAggregation)
	if !ok {
		that2, ok := that.(FieldAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Field != that1.Field {
		return false
	}
	if this.Topk != that1.Topk {
		return false
	}
	if len(this.SubAggs) != len(that1.SubAggs) {
		return false
	}
	for i := range this.SubAggs {
		if !this.SubAggs[i].Equal(that1.SubAggs[i]) {
			return false
		}
	}
	if that1.OrderBy == nil {
		if this.OrderBy != nil {
			return false
		}
	} else if this.OrderBy == nil {
		return false
	} else if !this.OrderBy.Equal(that1.OrderBy) {
		return false
	}
	return true
}
func (this *FieldAggregation_MetricsAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FieldAggregation_MetricsAggregation)
	if !ok {
		that2, ok := that.(FieldAggregation_MetricsAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MetricsAggregation.Equal(that1.MetricsAggregation) {
		return false
	}
	return true
}
func (this *MultiFieldAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MultiFieldAggregation)
	if !ok {
		that2, ok := that.(MultiFieldAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Field != that1.Field {
		return false
	}
	if this.Topk != that1.Topk {
		return false
	}
	if that1.OrderBy == nil {
		if this.OrderBy != nil {
			return false
		}
	} else if this.OrderBy == nil {
		return false
	} else if !this.OrderBy.Equal(that1.OrderBy) {
		return false
	}
	if len(this.SubAggs) != len(that1.SubAggs) {
		return false
	}
	for i := range this.SubAggs {
		if !this.SubAggs[i].Equal(that1.SubAggs[i]) {
			return false
		}
	}
	return true
}
func (this *MultiFieldAggregation_MetricsAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MultiFieldAggregation_MetricsAggregation)
	if !ok {
		that2, ok := that.(MultiFieldAggregation_MetricsAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MetricsAggregation.Equal(that1.MetricsAggregation) {
		return false
	}
	return true
}
func (this *CardinalityAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CardinalityAggregation)
	if !ok {
		that2, ok := that.(CardinalityAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Field != that1.Field {
		return false
	}
	return true
}
func (this *PercentileAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PercentileAggregation)
	if !ok {
		that2, ok := that.(PercentileAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Field != that1.Field {
		return false
	}
	if this.Percent != that1.Percent {
		return false
	}
	return true
}
func (this *MetricsAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetricsAggregation)
	if !ok {
		that2, ok := that.(MetricsAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AggregationType == nil {
		if this.AggregationType != nil {
			return false
		}
	} else if this.AggregationType == nil {
		return false
	} else if !this.AggregationType.Equal(that1.AggregationType) {
		return false
	}
	return true
}
func (this *MetricsAggregation_Percentile) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetricsAggregation_Percentile)
	if !ok {
		that2, ok := that.(MetricsAggregation_Percentile)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Percentile.Equal(that1.Percentile) {
		return false
	}
	return true
}
func (this *AggregationRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AggregationRequest)
	if !ok {
		that2, ok := that.(AggregationRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AggregationType == nil {
		if this.AggregationType != nil {
			return false
		}
	} else if this.AggregationType == nil {
		return false
	} else if !this.AggregationType.Equal(that1.AggregationType) {
		return false
	}
	if this.IsTrendRequest != that1.IsTrendRequest {
		return false
	}
	return true
}
func (this *AggregationRequest_DateAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AggregationRequest_DateAggregation)
	if !ok {
		that2, ok := that.(AggregationRequest_DateAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DateAggregation.Equal(that1.DateAggregation) {
		return false
	}
	return true
}
func (this *AggregationRequest_FieldAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AggregationRequest_FieldAggregation)
	if !ok {
		that2, ok := that.(AggregationRequest_FieldAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FieldAggregation.Equal(that1.FieldAggregation) {
		return false
	}
	return true
}
func (this *AggregationRequest_MultiFieldAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AggregationRequest_MultiFieldAggregation)
	if !ok {
		that2, ok := that.(AggregationRequest_MultiFieldAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MultiFieldAggregation.Equal(that1.MultiFieldAggregation) {
		return false
	}
	return true
}
func (this *AggregationRequest_CardinalityAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AggregationRequest_CardinalityAggregation)
	if !ok {
		that2, ok := that.(AggregationRequest_CardinalityAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CardinalityAggregation.Equal(that1.CardinalityAggregation) {
		return false
	}
	return true
}
func (this *AggregationRequest_MetricsAggregation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AggregationRequest_MetricsAggregation)
	if !ok {
		that2, ok := that.(AggregationRequest_MetricsAggregation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MetricsAggregation.Equal(that1.MetricsAggregation) {
		return false
	}
	return true
}
func (this *DateSubAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&app_security.DateSubAggregation{")
	if this.AggregationType != nil {
		s = append(s, "AggregationType: "+fmt.Sprintf("%#v", this.AggregationType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DateSubAggregation_FieldAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&app_security.DateSubAggregation_FieldAggregation{` +
		`FieldAggregation:` + fmt.Sprintf("%#v", this.FieldAggregation) + `}`}, ", ")
	return s
}
func (this *DateSubAggregation_MultiFieldAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&app_security.DateSubAggregation_MultiFieldAggregation{` +
		`MultiFieldAggregation:` + fmt.Sprintf("%#v", this.MultiFieldAggregation) + `}`}, ", ")
	return s
}
func (this *DateAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&app_security.DateAggregation{")
	s = append(s, "Step: "+fmt.Sprintf("%#v", this.Step)+",\n")
	keysForSubAggs := make([]string, 0, len(this.SubAggs))
	for k, _ := range this.SubAggs {
		keysForSubAggs = append(keysForSubAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSubAggs)
	mapStringForSubAggs := "map[string]*DateSubAggregation{"
	for _, k := range keysForSubAggs {
		mapStringForSubAggs += fmt.Sprintf("%#v: %#v,", k, this.SubAggs[k])
	}
	mapStringForSubAggs += "}"
	if this.SubAggs != nil {
		s = append(s, "SubAggs: "+mapStringForSubAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FieldSubAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&app_security.FieldSubAggregation{")
	if this.AggregationType != nil {
		s = append(s, "AggregationType: "+fmt.Sprintf("%#v", this.AggregationType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FieldSubAggregation_CardinalityAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&app_security.FieldSubAggregation_CardinalityAggregation{` +
		`CardinalityAggregation:` + fmt.Sprintf("%#v", this.CardinalityAggregation) + `}`}, ", ")
	return s
}
func (this *MultiFieldSubAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&app_security.MultiFieldSubAggregation{")
	if this.AggregationType != nil {
		s = append(s, "AggregationType: "+fmt.Sprintf("%#v", this.AggregationType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MultiFieldSubAggregation_CardinalityAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&app_security.MultiFieldSubAggregation_CardinalityAggregation{` +
		`CardinalityAggregation:` + fmt.Sprintf("%#v", this.CardinalityAggregation) + `}`}, ", ")
	return s
}
func (this *FieldAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&app_security.FieldAggregation{")
	s = append(s, "Field: "+fmt.Sprintf("%#v", this.Field)+",\n")
	s = append(s, "Topk: "+fmt.Sprintf("%#v", this.Topk)+",\n")
	keysForSubAggs := make([]string, 0, len(this.SubAggs))
	for k, _ := range this.SubAggs {
		keysForSubAggs = append(keysForSubAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSubAggs)
	mapStringForSubAggs := "map[string]*FieldSubAggregation{"
	for _, k := range keysForSubAggs {
		mapStringForSubAggs += fmt.Sprintf("%#v: %#v,", k, this.SubAggs[k])
	}
	mapStringForSubAggs += "}"
	if this.SubAggs != nil {
		s = append(s, "SubAggs: "+mapStringForSubAggs+",\n")
	}
	if this.OrderBy != nil {
		s = append(s, "OrderBy: "+fmt.Sprintf("%#v", this.OrderBy)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FieldAggregation_MetricsAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&app_security.FieldAggregation_MetricsAggregation{` +
		`MetricsAggregation:` + fmt.Sprintf("%#v", this.MetricsAggregation) + `}`}, ", ")
	return s
}
func (this *MultiFieldAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&app_security.MultiFieldAggregation{")
	s = append(s, "Field: "+fmt.Sprintf("%#v", this.Field)+",\n")
	s = append(s, "Topk: "+fmt.Sprintf("%#v", this.Topk)+",\n")
	if this.OrderBy != nil {
		s = append(s, "OrderBy: "+fmt.Sprintf("%#v", this.OrderBy)+",\n")
	}
	keysForSubAggs := make([]string, 0, len(this.SubAggs))
	for k, _ := range this.SubAggs {
		keysForSubAggs = append(keysForSubAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSubAggs)
	mapStringForSubAggs := "map[string]*MultiFieldSubAggregation{"
	for _, k := range keysForSubAggs {
		mapStringForSubAggs += fmt.Sprintf("%#v: %#v,", k, this.SubAggs[k])
	}
	mapStringForSubAggs += "}"
	if this.SubAggs != nil {
		s = append(s, "SubAggs: "+mapStringForSubAggs+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MultiFieldAggregation_MetricsAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&app_security.MultiFieldAggregation_MetricsAggregation{` +
		`MetricsAggregation:` + fmt.Sprintf("%#v", this.MetricsAggregation) + `}`}, ", ")
	return s
}
func (this *CardinalityAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&app_security.CardinalityAggregation{")
	s = append(s, "Field: "+fmt.Sprintf("%#v", this.Field)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PercentileAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&app_security.PercentileAggregation{")
	s = append(s, "Field: "+fmt.Sprintf("%#v", this.Field)+",\n")
	s = append(s, "Percent: "+fmt.Sprintf("%#v", this.Percent)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MetricsAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&app_security.MetricsAggregation{")
	if this.AggregationType != nil {
		s = append(s, "AggregationType: "+fmt.Sprintf("%#v", this.AggregationType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MetricsAggregation_Percentile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&app_security.MetricsAggregation_Percentile{` +
		`Percentile:` + fmt.Sprintf("%#v", this.Percentile) + `}`}, ", ")
	return s
}
func (this *AggregationRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&app_security.AggregationRequest{")
	if this.AggregationType != nil {
		s = append(s, "AggregationType: "+fmt.Sprintf("%#v", this.AggregationType)+",\n")
	}
	s = append(s, "IsTrendRequest: "+fmt.Sprintf("%#v", this.IsTrendRequest)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AggregationRequest_DateAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&app_security.AggregationRequest_DateAggregation{` +
		`DateAggregation:` + fmt.Sprintf("%#v", this.DateAggregation) + `}`}, ", ")
	return s
}
func (this *AggregationRequest_FieldAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&app_security.AggregationRequest_FieldAggregation{` +
		`FieldAggregation:` + fmt.Sprintf("%#v", this.FieldAggregation) + `}`}, ", ")
	return s
}
func (this *AggregationRequest_MultiFieldAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&app_security.AggregationRequest_MultiFieldAggregation{` +
		`MultiFieldAggregation:` + fmt.Sprintf("%#v", this.MultiFieldAggregation) + `}`}, ", ")
	return s
}
func (this *AggregationRequest_CardinalityAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&app_security.AggregationRequest_CardinalityAggregation{` +
		`CardinalityAggregation:` + fmt.Sprintf("%#v", this.CardinalityAggregation) + `}`}, ", ")
	return s
}
func (this *AggregationRequest_MetricsAggregation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&app_security.AggregationRequest_MetricsAggregation{` +
		`MetricsAggregation:` + fmt.Sprintf("%#v", this.MetricsAggregation) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *DateSubAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DateSubAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DateSubAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AggregationType != nil {
		{
			size := m.AggregationType.Size()
			i -= size
			if _, err := m.AggregationType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DateSubAggregation_FieldAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DateSubAggregation_FieldAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FieldAggregation != nil {
		{
			size, err := m.FieldAggregation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *DateSubAggregation_MultiFieldAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DateSubAggregation_MultiFieldAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MultiFieldAggregation != nil {
		{
			size, err := m.MultiFieldAggregation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *DateAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DateAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DateAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubAggs) > 0 {
		keysForSubAggs := make([]string, 0, len(m.SubAggs))
		for k := range m.SubAggs {
			keysForSubAggs = append(keysForSubAggs, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForSubAggs)
		for iNdEx := len(keysForSubAggs) - 1; iNdEx >= 0; iNdEx-- {
			v := m.SubAggs[string(keysForSubAggs[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTypes(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForSubAggs[iNdEx])
			copy(dAtA[i:], keysForSubAggs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForSubAggs[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Step) > 0 {
		i -= len(m.Step)
		copy(dAtA[i:], m.Step)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Step)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FieldSubAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldSubAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FieldSubAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AggregationType != nil {
		{
			size := m.AggregationType.Size()
			i -= size
			if _, err := m.AggregationType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *FieldSubAggregation_CardinalityAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FieldSubAggregation_CardinalityAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CardinalityAggregation != nil {
		{
			size, err := m.CardinalityAggregation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MultiFieldSubAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiFieldSubAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiFieldSubAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AggregationType != nil {
		{
			size := m.AggregationType.Size()
			i -= size
			if _, err := m.AggregationType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MultiFieldSubAggregation_CardinalityAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiFieldSubAggregation_CardinalityAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CardinalityAggregation != nil {
		{
			size, err := m.CardinalityAggregation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *FieldAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FieldAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OrderBy != nil {
		{
			size := m.OrderBy.Size()
			i -= size
			if _, err := m.OrderBy.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.SubAggs) > 0 {
		keysForSubAggs := make([]string, 0, len(m.SubAggs))
		for k := range m.SubAggs {
			keysForSubAggs = append(keysForSubAggs, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForSubAggs)
		for iNdEx := len(keysForSubAggs) - 1; iNdEx >= 0; iNdEx-- {
			v := m.SubAggs[string(keysForSubAggs[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTypes(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForSubAggs[iNdEx])
			copy(dAtA[i:], keysForSubAggs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForSubAggs[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Topk != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Topk))
		i--
		dAtA[i] = 0x10
	}
	if m.Field != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Field))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FieldAggregation_MetricsAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FieldAggregation_MetricsAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MetricsAggregation != nil {
		{
			size, err := m.MetricsAggregation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *MultiFieldAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiFieldAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiFieldAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubAggs) > 0 {
		keysForSubAggs := make([]string, 0, len(m.SubAggs))
		for k := range m.SubAggs {
			keysForSubAggs = append(keysForSubAggs, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForSubAggs)
		for iNdEx := len(keysForSubAggs) - 1; iNdEx >= 0; iNdEx-- {
			v := m.SubAggs[string(keysForSubAggs[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTypes(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForSubAggs[iNdEx])
			copy(dAtA[i:], keysForSubAggs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForSubAggs[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.OrderBy != nil {
		{
			size := m.OrderBy.Size()
			i -= size
			if _, err := m.OrderBy.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Topk != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Topk))
		i--
		dAtA[i] = 0x10
	}
	if m.Field != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Field))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MultiFieldAggregation_MetricsAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiFieldAggregation_MetricsAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MetricsAggregation != nil {
		{
			size, err := m.MetricsAggregation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *CardinalityAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardinalityAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CardinalityAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Field != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Field))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PercentileAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PercentileAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PercentileAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Percent != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Percent))))
		i--
		dAtA[i] = 0x19
	}
	if m.Field != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Field))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MetricsAggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricsAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricsAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AggregationType != nil {
		{
			size := m.AggregationType.Size()
			i -= size
			if _, err := m.AggregationType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MetricsAggregation_Percentile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricsAggregation_Percentile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Percentile != nil {
		{
			size, err := m.Percentile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AggregationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggregationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsTrendRequest {
		i--
		if m.IsTrendRequest {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.AggregationType != nil {
		{
			size := m.AggregationType.Size()
			i -= size
			if _, err := m.AggregationType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AggregationRequest_DateAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggregationRequest_DateAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DateAggregation != nil {
		{
			size, err := m.DateAggregation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *AggregationRequest_FieldAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggregationRequest_FieldAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FieldAggregation != nil {
		{
			size, err := m.FieldAggregation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *AggregationRequest_CardinalityAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggregationRequest_CardinalityAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CardinalityAggregation != nil {
		{
			size, err := m.CardinalityAggregation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AggregationRequest_MultiFieldAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggregationRequest_MultiFieldAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MultiFieldAggregation != nil {
		{
			size, err := m.MultiFieldAggregation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *AggregationRequest_MetricsAggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggregationRequest_MetricsAggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MetricsAggregation != nil {
		{
			size, err := m.MetricsAggregation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DateSubAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AggregationType != nil {
		n += m.AggregationType.Size()
	}
	return n
}

func (m *DateSubAggregation_FieldAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FieldAggregation != nil {
		l = m.FieldAggregation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DateSubAggregation_MultiFieldAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MultiFieldAggregation != nil {
		l = m.MultiFieldAggregation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DateAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Step)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.SubAggs) > 0 {
		for k, v := range m.SubAggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FieldSubAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AggregationType != nil {
		n += m.AggregationType.Size()
	}
	return n
}

func (m *FieldSubAggregation_CardinalityAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CardinalityAggregation != nil {
		l = m.CardinalityAggregation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *MultiFieldSubAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AggregationType != nil {
		n += m.AggregationType.Size()
	}
	return n
}

func (m *MultiFieldSubAggregation_CardinalityAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CardinalityAggregation != nil {
		l = m.CardinalityAggregation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FieldAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Field != 0 {
		n += 1 + sovTypes(uint64(m.Field))
	}
	if m.Topk != 0 {
		n += 1 + sovTypes(uint64(m.Topk))
	}
	if len(m.SubAggs) > 0 {
		for k, v := range m.SubAggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.OrderBy != nil {
		n += m.OrderBy.Size()
	}
	return n
}

func (m *FieldAggregation_MetricsAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MetricsAggregation != nil {
		l = m.MetricsAggregation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *MultiFieldAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Field != 0 {
		n += 1 + sovTypes(uint64(m.Field))
	}
	if m.Topk != 0 {
		n += 1 + sovTypes(uint64(m.Topk))
	}
	if m.OrderBy != nil {
		n += m.OrderBy.Size()
	}
	if len(m.SubAggs) > 0 {
		for k, v := range m.SubAggs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MultiFieldAggregation_MetricsAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MetricsAggregation != nil {
		l = m.MetricsAggregation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CardinalityAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Field != 0 {
		n += 1 + sovTypes(uint64(m.Field))
	}
	return n
}

func (m *PercentileAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Field != 0 {
		n += 1 + sovTypes(uint64(m.Field))
	}
	if m.Percent != 0 {
		n += 9
	}
	return n
}

func (m *MetricsAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AggregationType != nil {
		n += m.AggregationType.Size()
	}
	return n
}

func (m *MetricsAggregation_Percentile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Percentile != nil {
		l = m.Percentile.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AggregationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AggregationType != nil {
		n += m.AggregationType.Size()
	}
	if m.IsTrendRequest {
		n += 2
	}
	return n
}

func (m *AggregationRequest_DateAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DateAggregation != nil {
		l = m.DateAggregation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AggregationRequest_FieldAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FieldAggregation != nil {
		l = m.FieldAggregation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AggregationRequest_CardinalityAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CardinalityAggregation != nil {
		l = m.CardinalityAggregation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AggregationRequest_MultiFieldAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MultiFieldAggregation != nil {
		l = m.MultiFieldAggregation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AggregationRequest_MetricsAggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MetricsAggregation != nil {
		l = m.MetricsAggregation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *DateSubAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DateSubAggregation{`,
		`AggregationType:` + fmt.Sprintf("%v", this.AggregationType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DateSubAggregation_FieldAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DateSubAggregation_FieldAggregation{`,
		`FieldAggregation:` + strings.Replace(fmt.Sprintf("%v", this.FieldAggregation), "FieldAggregation", "FieldAggregation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DateSubAggregation_MultiFieldAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DateSubAggregation_MultiFieldAggregation{`,
		`MultiFieldAggregation:` + strings.Replace(fmt.Sprintf("%v", this.MultiFieldAggregation), "MultiFieldAggregation", "MultiFieldAggregation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DateAggregation) String() string {
	if this == nil {
		return "nil"
	}
	keysForSubAggs := make([]string, 0, len(this.SubAggs))
	for k, _ := range this.SubAggs {
		keysForSubAggs = append(keysForSubAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSubAggs)
	mapStringForSubAggs := "map[string]*DateSubAggregation{"
	for _, k := range keysForSubAggs {
		mapStringForSubAggs += fmt.Sprintf("%v: %v,", k, this.SubAggs[k])
	}
	mapStringForSubAggs += "}"
	s := strings.Join([]string{`&DateAggregation{`,
		`Step:` + fmt.Sprintf("%v", this.Step) + `,`,
		`SubAggs:` + mapStringForSubAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *FieldSubAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FieldSubAggregation{`,
		`AggregationType:` + fmt.Sprintf("%v", this.AggregationType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FieldSubAggregation_CardinalityAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FieldSubAggregation_CardinalityAggregation{`,
		`CardinalityAggregation:` + strings.Replace(fmt.Sprintf("%v", this.CardinalityAggregation), "CardinalityAggregation", "CardinalityAggregation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MultiFieldSubAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MultiFieldSubAggregation{`,
		`AggregationType:` + fmt.Sprintf("%v", this.AggregationType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MultiFieldSubAggregation_CardinalityAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MultiFieldSubAggregation_CardinalityAggregation{`,
		`CardinalityAggregation:` + strings.Replace(fmt.Sprintf("%v", this.CardinalityAggregation), "CardinalityAggregation", "CardinalityAggregation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FieldAggregation) String() string {
	if this == nil {
		return "nil"
	}
	keysForSubAggs := make([]string, 0, len(this.SubAggs))
	for k, _ := range this.SubAggs {
		keysForSubAggs = append(keysForSubAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSubAggs)
	mapStringForSubAggs := "map[string]*FieldSubAggregation{"
	for _, k := range keysForSubAggs {
		mapStringForSubAggs += fmt.Sprintf("%v: %v,", k, this.SubAggs[k])
	}
	mapStringForSubAggs += "}"
	s := strings.Join([]string{`&FieldAggregation{`,
		`Field:` + fmt.Sprintf("%v", this.Field) + `,`,
		`Topk:` + fmt.Sprintf("%v", this.Topk) + `,`,
		`SubAggs:` + mapStringForSubAggs + `,`,
		`OrderBy:` + fmt.Sprintf("%v", this.OrderBy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FieldAggregation_MetricsAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FieldAggregation_MetricsAggregation{`,
		`MetricsAggregation:` + strings.Replace(fmt.Sprintf("%v", this.MetricsAggregation), "MetricsAggregation", "MetricsAggregation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MultiFieldAggregation) String() string {
	if this == nil {
		return "nil"
	}
	keysForSubAggs := make([]string, 0, len(this.SubAggs))
	for k, _ := range this.SubAggs {
		keysForSubAggs = append(keysForSubAggs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForSubAggs)
	mapStringForSubAggs := "map[string]*MultiFieldSubAggregation{"
	for _, k := range keysForSubAggs {
		mapStringForSubAggs += fmt.Sprintf("%v: %v,", k, this.SubAggs[k])
	}
	mapStringForSubAggs += "}"
	s := strings.Join([]string{`&MultiFieldAggregation{`,
		`Field:` + fmt.Sprintf("%v", this.Field) + `,`,
		`Topk:` + fmt.Sprintf("%v", this.Topk) + `,`,
		`OrderBy:` + fmt.Sprintf("%v", this.OrderBy) + `,`,
		`SubAggs:` + mapStringForSubAggs + `,`,
		`}`,
	}, "")
	return s
}
func (this *MultiFieldAggregation_MetricsAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MultiFieldAggregation_MetricsAggregation{`,
		`MetricsAggregation:` + strings.Replace(fmt.Sprintf("%v", this.MetricsAggregation), "MetricsAggregation", "MetricsAggregation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CardinalityAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CardinalityAggregation{`,
		`Field:` + fmt.Sprintf("%v", this.Field) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PercentileAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PercentileAggregation{`,
		`Field:` + fmt.Sprintf("%v", this.Field) + `,`,
		`Percent:` + fmt.Sprintf("%v", this.Percent) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricsAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MetricsAggregation{`,
		`AggregationType:` + fmt.Sprintf("%v", this.AggregationType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricsAggregation_Percentile) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MetricsAggregation_Percentile{`,
		`Percentile:` + strings.Replace(fmt.Sprintf("%v", this.Percentile), "PercentileAggregation", "PercentileAggregation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AggregationRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AggregationRequest{`,
		`AggregationType:` + fmt.Sprintf("%v", this.AggregationType) + `,`,
		`IsTrendRequest:` + fmt.Sprintf("%v", this.IsTrendRequest) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AggregationRequest_DateAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AggregationRequest_DateAggregation{`,
		`DateAggregation:` + strings.Replace(fmt.Sprintf("%v", this.DateAggregation), "DateAggregation", "DateAggregation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AggregationRequest_FieldAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AggregationRequest_FieldAggregation{`,
		`FieldAggregation:` + strings.Replace(fmt.Sprintf("%v", this.FieldAggregation), "FieldAggregation", "FieldAggregation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AggregationRequest_CardinalityAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AggregationRequest_CardinalityAggregation{`,
		`CardinalityAggregation:` + strings.Replace(fmt.Sprintf("%v", this.CardinalityAggregation), "CardinalityAggregation", "CardinalityAggregation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AggregationRequest_MultiFieldAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AggregationRequest_MultiFieldAggregation{`,
		`MultiFieldAggregation:` + strings.Replace(fmt.Sprintf("%v", this.MultiFieldAggregation), "MultiFieldAggregation", "MultiFieldAggregation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AggregationRequest_MetricsAggregation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AggregationRequest_MetricsAggregation{`,
		`MetricsAggregation:` + strings.Replace(fmt.Sprintf("%v", this.MetricsAggregation), "MetricsAggregation", "MetricsAggregation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *DateSubAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DateSubAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DateSubAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldAggregation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FieldAggregation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AggregationType = &DateSubAggregation_FieldAggregation{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiFieldAggregation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MultiFieldAggregation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AggregationType = &DateSubAggregation_MultiFieldAggregation{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DateAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DateAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DateAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Step = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubAggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubAggs == nil {
				m.SubAggs = make(map[string]*DateSubAggregation)
			}
			var mapkey string
			var mapvalue *DateSubAggregation
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &DateSubAggregation{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SubAggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldSubAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldSubAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldSubAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardinalityAggregation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CardinalityAggregation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AggregationType = &FieldSubAggregation_CardinalityAggregation{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiFieldSubAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiFieldSubAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiFieldSubAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardinalityAggregation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CardinalityAggregation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AggregationType = &MultiFieldSubAggregation_CardinalityAggregation{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			m.Field = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Field |= KeyField(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topk", wireType)
			}
			m.Topk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Topk |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubAggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubAggs == nil {
				m.SubAggs = make(map[string]*FieldSubAggregation)
			}
			var mapkey string
			var mapvalue *FieldSubAggregation
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FieldSubAggregation{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SubAggs[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricsAggregation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MetricsAggregation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OrderBy = &FieldAggregation_MetricsAggregation{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiFieldAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiFieldAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiFieldAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			m.Field = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Field |= MultiKeyField(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topk", wireType)
			}
			m.Topk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Topk |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricsAggregation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MetricsAggregation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OrderBy = &MultiFieldAggregation_MetricsAggregation{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubAggs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubAggs == nil {
				m.SubAggs = make(map[string]*MultiFieldSubAggregation)
			}
			var mapkey string
			var mapvalue *MultiFieldSubAggregation
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &MultiFieldSubAggregation{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SubAggs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardinalityAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardinalityAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardinalityAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			m.Field = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Field |= KeyField(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PercentileAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PercentileAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PercentileAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			m.Field = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Field |= MetricField(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Percent = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricsAggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricsAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricsAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percentile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PercentileAggregation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AggregationType = &MetricsAggregation_Percentile{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AggregationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AggregationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateAggregation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DateAggregation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AggregationType = &AggregationRequest_DateAggregation{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldAggregation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FieldAggregation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AggregationType = &AggregationRequest_FieldAggregation{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardinalityAggregation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CardinalityAggregation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AggregationType = &AggregationRequest_CardinalityAggregation{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiFieldAggregation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MultiFieldAggregation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AggregationType = &AggregationRequest_MultiFieldAggregation{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricsAggregation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MetricsAggregation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AggregationType = &AggregationRequest_MetricsAggregation{v}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTrendRequest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTrendRequest = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
