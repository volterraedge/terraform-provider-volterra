// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package app_security

import (
	"bytes"
	"context"
	"fmt"
	io "io"
	"net/http"
	"strings"

	"github.com/gogo/protobuf/proto"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"google.golang.org/grpc"

	"gopkg.volterra.us/stdlib/client"
	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/errors"
	"gopkg.volterra.us/stdlib/server"
	"gopkg.volterra.us/stdlib/svcfw"
)

var (
	_ = fmt.Sprintf("dummy for fmt import use")
)

// Create AppSecurityWafExclusionAPI GRPC Client satisfying server.CustomClient
type AppSecurityWafExclusionAPIGrpcClient struct {
	conn       *grpc.ClientConn
	grpcClient AppSecurityWafExclusionAPIClient
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error)
}

func (c *AppSecurityWafExclusionAPIGrpcClient) doRPCGetSuggestedWAFExclusionRule(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetSuggestedWAFExclusionRuleReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.GetSuggestedWAFExclusionRuleReq", yamlReq)
	}
	rsp, err := c.grpcClient.GetSuggestedWAFExclusionRule(ctx, req, opts...)
	return rsp, err
}

func (c *AppSecurityWafExclusionAPIGrpcClient) doRPCGetSuggestedWAFExclusionRuleForCDN(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &GetSuggestedWAFExclusionRuleReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.GetSuggestedWAFExclusionRuleReq", yamlReq)
	}
	rsp, err := c.grpcClient.GetSuggestedWAFExclusionRuleForCDN(ctx, req, opts...)
	return rsp, err
}

func (c *AppSecurityWafExclusionAPIGrpcClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	if cco.YAMLReq == "" {
		return nil, fmt.Errorf("Error, empty request body")
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := rpcFn(ctx, cco.YAMLReq, cco.GrpcCallOpts...)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using GRPC")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func NewAppSecurityWafExclusionAPIGrpcClient(cc *grpc.ClientConn) server.CustomClient {
	ccl := &AppSecurityWafExclusionAPIGrpcClient{
		conn:       cc,
		grpcClient: NewAppSecurityWafExclusionAPIClient(cc),
	}
	rpcFns := make(map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error))
	rpcFns["GetSuggestedWAFExclusionRule"] = ccl.doRPCGetSuggestedWAFExclusionRule

	rpcFns["GetSuggestedWAFExclusionRuleForCDN"] = ccl.doRPCGetSuggestedWAFExclusionRuleForCDN

	ccl.rpcFns = rpcFns

	return ccl
}

// Create AppSecurityWafExclusionAPI REST Client satisfying server.CustomClient
type AppSecurityWafExclusionAPIRestClient struct {
	baseURL string
	client  http.Client
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error)
}

func (c *AppSecurityWafExclusionAPIRestClient) doRPCGetSuggestedWAFExclusionRule(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetSuggestedWAFExclusionRuleReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.GetSuggestedWAFExclusionRuleReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("api_endpoint", fmt.Sprintf("%v", req.ApiEndpoint))
		q.Add("domain", fmt.Sprintf("%v", req.Domain))
		for _, item := range req.ExcludeBotNames {
			q.Add("exclude_bot_names", fmt.Sprintf("%v", item))
		}
		for _, item := range req.ExcludeSignatureContexts {
			q.Add("exclude_signature_contexts", fmt.Sprintf("%v", item))
		}
		for _, item := range req.ExcludeViolationContexts {
			q.Add("exclude_violation_contexts", fmt.Sprintf("%v", item))
		}
		q.Add("name", fmt.Sprintf("%v", req.Name))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("req_path", fmt.Sprintf("%v", req.ReqPath))
		q.Add("route_uuid", fmt.Sprintf("%v", req.RouteUuid))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetSuggestedWAFExclusionRuleRsp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.app_security.GetSuggestedWAFExclusionRuleRsp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *AppSecurityWafExclusionAPIRestClient) doRPCGetSuggestedWAFExclusionRuleForCDN(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &GetSuggestedWAFExclusionRuleReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.app_security.GetSuggestedWAFExclusionRuleReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("api_endpoint", fmt.Sprintf("%v", req.ApiEndpoint))
		q.Add("domain", fmt.Sprintf("%v", req.Domain))
		for _, item := range req.ExcludeBotNames {
			q.Add("exclude_bot_names", fmt.Sprintf("%v", item))
		}
		for _, item := range req.ExcludeSignatureContexts {
			q.Add("exclude_signature_contexts", fmt.Sprintf("%v", item))
		}
		for _, item := range req.ExcludeViolationContexts {
			q.Add("exclude_violation_contexts", fmt.Sprintf("%v", item))
		}
		q.Add("name", fmt.Sprintf("%v", req.Name))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("req_path", fmt.Sprintf("%v", req.ReqPath))
		q.Add("route_uuid", fmt.Sprintf("%v", req.RouteUuid))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &GetSuggestedWAFExclusionRuleRsp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.app_security.GetSuggestedWAFExclusionRuleRsp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *AppSecurityWafExclusionAPIRestClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	rsp, err := rpcFn(ctx, cco)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using Rest")
	}
	return rsp, nil
}

func NewAppSecurityWafExclusionAPIRestClient(baseURL string, hc http.Client) server.CustomClient {
	ccl := &AppSecurityWafExclusionAPIRestClient{
		baseURL: baseURL,
		client:  hc,
	}

	rpcFns := make(map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error))
	rpcFns["GetSuggestedWAFExclusionRule"] = ccl.doRPCGetSuggestedWAFExclusionRule

	rpcFns["GetSuggestedWAFExclusionRuleForCDN"] = ccl.doRPCGetSuggestedWAFExclusionRuleForCDN

	ccl.rpcFns = rpcFns

	return ccl
}

// Create appSecurityWafExclusionAPIInprocClient

// INPROC Client (satisfying AppSecurityWafExclusionAPIClient interface)
type appSecurityWafExclusionAPIInprocClient struct {
	AppSecurityWafExclusionAPIServer
}

func (c *appSecurityWafExclusionAPIInprocClient) GetSuggestedWAFExclusionRule(ctx context.Context, in *GetSuggestedWAFExclusionRuleReq, opts ...grpc.CallOption) (*GetSuggestedWAFExclusionRuleRsp, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.app_security.AppSecurityWafExclusionAPI.GetSuggestedWAFExclusionRule")
	return c.AppSecurityWafExclusionAPIServer.GetSuggestedWAFExclusionRule(ctx, in)
}
func (c *appSecurityWafExclusionAPIInprocClient) GetSuggestedWAFExclusionRuleForCDN(ctx context.Context, in *GetSuggestedWAFExclusionRuleReq, opts ...grpc.CallOption) (*GetSuggestedWAFExclusionRuleRsp, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.app_security.AppSecurityWafExclusionAPI.GetSuggestedWAFExclusionRuleForCDN")
	return c.AppSecurityWafExclusionAPIServer.GetSuggestedWAFExclusionRuleForCDN(ctx, in)
}

func NewAppSecurityWafExclusionAPIInprocClient(svc svcfw.Service) AppSecurityWafExclusionAPIClient {
	return &appSecurityWafExclusionAPIInprocClient{AppSecurityWafExclusionAPIServer: NewAppSecurityWafExclusionAPIServer(svc)}
}

// RegisterGwAppSecurityWafExclusionAPIHandler registers with grpc-gw with an inproc-client backing so that
// rest to grpc happens without a grpc.Dial (thus avoiding additional certs for mTLS)
func RegisterGwAppSecurityWafExclusionAPIHandler(ctx context.Context, mux *runtime.ServeMux, svc interface{}) error {
	s, ok := svc.(svcfw.Service)
	if !ok {
		return fmt.Errorf("svc is not svcfw.Service")
	}
	return RegisterAppSecurityWafExclusionAPIHandlerClient(ctx, mux, NewAppSecurityWafExclusionAPIInprocClient(s))
}

// Create appSecurityWafExclusionAPISrv

// SERVER (satisfying AppSecurityWafExclusionAPIServer interface)
type appSecurityWafExclusionAPISrv struct {
	svc svcfw.Service
}

func (s *appSecurityWafExclusionAPISrv) GetSuggestedWAFExclusionRule(ctx context.Context, in *GetSuggestedWAFExclusionRuleReq) (*GetSuggestedWAFExclusionRuleRsp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.app_security.AppSecurityWafExclusionAPI")
	cah, ok := ah.(AppSecurityWafExclusionAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *AppSecurityWafExclusionAPIServer", ah)
	}

	var (
		rsp *GetSuggestedWAFExclusionRuleRsp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.app_security.GetSuggestedWAFExclusionRuleReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'AppSecurityWafExclusionAPI.GetSuggestedWAFExclusionRule' operation on 'app_security'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.app_security.AppSecurityWafExclusionAPI.GetSuggestedWAFExclusionRule"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetSuggestedWAFExclusionRule(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.app_security.GetSuggestedWAFExclusionRuleRsp", rsp)...)

	return rsp, nil
}
func (s *appSecurityWafExclusionAPISrv) GetSuggestedWAFExclusionRuleForCDN(ctx context.Context, in *GetSuggestedWAFExclusionRuleReq) (*GetSuggestedWAFExclusionRuleRsp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.app_security.AppSecurityWafExclusionAPI")
	cah, ok := ah.(AppSecurityWafExclusionAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *AppSecurityWafExclusionAPIServer", ah)
	}

	var (
		rsp *GetSuggestedWAFExclusionRuleRsp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.app_security.GetSuggestedWAFExclusionRuleReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'AppSecurityWafExclusionAPI.GetSuggestedWAFExclusionRuleForCDN' operation on 'app_security'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.app_security.AppSecurityWafExclusionAPI.GetSuggestedWAFExclusionRuleForCDN"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetSuggestedWAFExclusionRuleForCDN(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.app_security.GetSuggestedWAFExclusionRuleRsp", rsp)...)

	return rsp, nil
}

func NewAppSecurityWafExclusionAPIServer(svc svcfw.Service) AppSecurityWafExclusionAPIServer {
	return &appSecurityWafExclusionAPISrv{svc: svc}
}

var AppSecurityWafExclusionAPISwaggerJSON string = `{
    "swagger": "2.0",
    "info": {
        "title": "Application Security Monitoring APIs",
        "description": "APIs to get application security events and metrics on virtual-host basis.\nSecurity events may be generated for following reasons:\n1. Service policy hits with action \"deny\"\n2. Rate limiting\n3. Javascript challenge failure",
        "version": "version not set"
    },
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "tags": [],
    "paths": {
        "/public/namespaces/{namespace}/cdn_loadbalancers/{name}/waf_exclusion/suggestion": {
            "post": {
                "summary": "Suggest WAF Exclusion Rule",
                "description": "Suggest service policy rule to set up WAF exclusion for a given WAF security event",
                "operationId": "ves.io.schema.app_security.AppSecurityWafExclusionAPI.GetSuggestedWAFExclusionRuleForCDN",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securityGetSuggestedWAFExclusionRuleRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"shared\"\nNamespace of the App type for current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "name",
                        "description": "Name\n\nx-example: \"ves-io-frontend\"\nHTTP load balancer for which this WAF exclusion will be applied",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "HTTP Load Balancer Name"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/app_securityGetSuggestedWAFExclusionRuleReq"
                        }
                    }
                ],
                "tags": [
                    "AppSecurityWafExclusionAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-app_security-appsecuritywafexclusionapi-getsuggestedwafexclusionruleforcdn"
                },
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityWafExclusionAPI.GetSuggestedWAFExclusionRuleForCDN"
            },
            "x-displayname": "Application Security WAF Exclusion APIs",
            "x-ves-proto-service": "ves.io.schema.app_security.AppSecurityWafExclusionAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/http_loadbalancers/{name}/waf_exclusion/suggestion": {
            "post": {
                "summary": "Suggest WAF Exclusion Rule",
                "description": "Suggest service policy rule to set up WAF exclusion for a given WAF security event",
                "operationId": "ves.io.schema.app_security.AppSecurityWafExclusionAPI.GetSuggestedWAFExclusionRule",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/app_securityGetSuggestedWAFExclusionRuleRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"shared\"\nNamespace of the App type for current request",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "name",
                        "description": "Name\n\nx-example: \"ves-io-frontend\"\nHTTP load balancer for which this WAF exclusion will be applied",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "HTTP Load Balancer Name"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/app_securityGetSuggestedWAFExclusionRuleReq"
                        }
                    }
                ],
                "tags": [
                    "AppSecurityWafExclusionAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-app_security-appsecuritywafexclusionapi-getsuggestedwafexclusionrule"
                },
                "x-ves-proto-rpc": "ves.io.schema.app_security.AppSecurityWafExclusionAPI.GetSuggestedWAFExclusionRule"
            },
            "x-displayname": "Application Security WAF Exclusion APIs",
            "x-ves-proto-service": "ves.io.schema.app_security.AppSecurityWafExclusionAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        }
    },
    "definitions": {
        "app_firewallAppFirewallViolationType": {
            "type": "string",
            "description": "List of all supported Violation Types\n\nVIOL_NONE\nVIOL_FILETYPE\nVIOL_METHOD\nVIOL_MANDATORY_HEADER\nVIOL_HTTP_RESPONSE_STATUS\nVIOL_REQUEST_MAX_LENGTH\nVIOL_FILE_UPLOAD\nVIOL_FILE_UPLOAD_IN_BODY\nVIOL_XML_MALFORMED\nVIOL_JSON_MALFORMED\nVIOL_ASM_COOKIE_MODIFIED\nVIOL_HTTP_PROTOCOL_MULTIPLE_HOST_HEADERS\nVIOL_HTTP_PROTOCOL_BAD_HOST_HEADER_VALUE\nVIOL_HTTP_PROTOCOL_UNPARSABLE_REQUEST_CONTENT\nVIOL_HTTP_PROTOCOL_NULL_IN_REQUEST\nVIOL_HTTP_PROTOCOL_BAD_HTTP_VERSION\nVIOL_HTTP_PROTOCOL_CRLF_CHARACTERS_BEFORE_REQUEST_START\nVIOL_HTTP_PROTOCOL_NO_HOST_HEADER_IN_HTTP_1_1_REQUEST\nVIOL_HTTP_PROTOCOL_BAD_MULTIPART_PARAMETERS_PARSING\nVIOL_HTTP_PROTOCOL_SEVERAL_CONTENT_LENGTH_HEADERS\nVIOL_HTTP_PROTOCOL_CONTENT_LENGTH_SHOULD_BE_A_POSITIVE_NUMBER\nVIOL_EVASION_DIRECTORY_TRAVERSALS\nVIOL_MALFORMED_REQUEST\nVIOL_EVASION_MULTIPLE_DECODING\nVIOL_DATA_GUARD\nVIOL_EVASION_APACHE_WHITESPACE\nVIOL_COOKIE_MODIFIED\nVIOL_EVASION_IIS_UNICODE_CODEPOINTS\nVIOL_EVASION_IIS_BACKSLASHES\nVIOL_EVASION_PERCENT_U_DECODING\nVIOL_EVASION_BARE_BYTE_DECODING\nVIOL_EVASION_BAD_UNESCAPE\nVIOL_HTTP_PROTOCOL_BAD_MULTIPART_FORMDATA_REQUEST_PARSING\nVIOL_HTTP_PROTOCOL_BODY_IN_GET_OR_HEAD_REQUEST\nVIOL_HTTP_PROTOCOL_HIGH_ASCII_CHARACTERS_IN_HEADERS\nVIOL_ENCODING\nVIOL_COOKIE_MALFORMED\nVIOL_GRAPHQL_FORMAT\nVIOL_GRAPHQL_MALFORMED\nVIOL_GRAPHQL_INTROSPECTION_QUERY",
            "title": "App Firewall Violation Type",
            "enum": [
                "VIOL_NONE",
                "VIOL_FILETYPE",
                "VIOL_METHOD",
                "VIOL_MANDATORY_HEADER",
                "VIOL_HTTP_RESPONSE_STATUS",
                "VIOL_REQUEST_MAX_LENGTH",
                "VIOL_FILE_UPLOAD",
                "VIOL_FILE_UPLOAD_IN_BODY",
                "VIOL_XML_MALFORMED",
                "VIOL_JSON_MALFORMED",
                "VIOL_ASM_COOKIE_MODIFIED",
                "VIOL_HTTP_PROTOCOL_MULTIPLE_HOST_HEADERS",
                "VIOL_HTTP_PROTOCOL_BAD_HOST_HEADER_VALUE",
                "VIOL_HTTP_PROTOCOL_UNPARSABLE_REQUEST_CONTENT",
                "VIOL_HTTP_PROTOCOL_NULL_IN_REQUEST",
                "VIOL_HTTP_PROTOCOL_BAD_HTTP_VERSION",
                "VIOL_HTTP_PROTOCOL_CRLF_CHARACTERS_BEFORE_REQUEST_START",
                "VIOL_HTTP_PROTOCOL_NO_HOST_HEADER_IN_HTTP_1_1_REQUEST",
                "VIOL_HTTP_PROTOCOL_BAD_MULTIPART_PARAMETERS_PARSING",
                "VIOL_HTTP_PROTOCOL_SEVERAL_CONTENT_LENGTH_HEADERS",
                "VIOL_HTTP_PROTOCOL_CONTENT_LENGTH_SHOULD_BE_A_POSITIVE_NUMBER",
                "VIOL_EVASION_DIRECTORY_TRAVERSALS",
                "VIOL_MALFORMED_REQUEST",
                "VIOL_EVASION_MULTIPLE_DECODING",
                "VIOL_DATA_GUARD",
                "VIOL_EVASION_APACHE_WHITESPACE",
                "VIOL_COOKIE_MODIFIED",
                "VIOL_EVASION_IIS_UNICODE_CODEPOINTS",
                "VIOL_EVASION_IIS_BACKSLASHES",
                "VIOL_EVASION_PERCENT_U_DECODING",
                "VIOL_EVASION_BARE_BYTE_DECODING",
                "VIOL_EVASION_BAD_UNESCAPE",
                "VIOL_HTTP_PROTOCOL_BAD_MULTIPART_FORMDATA_REQUEST_PARSING",
                "VIOL_HTTP_PROTOCOL_BODY_IN_GET_OR_HEAD_REQUEST",
                "VIOL_HTTP_PROTOCOL_HIGH_ASCII_CHARACTERS_IN_HEADERS",
                "VIOL_ENCODING",
                "VIOL_COOKIE_MALFORMED",
                "VIOL_GRAPHQL_FORMAT",
                "VIOL_GRAPHQL_MALFORMED",
                "VIOL_GRAPHQL_INTROSPECTION_QUERY"
            ],
            "default": "VIOL_NONE",
            "x-displayname": "App Firewall Violation Type",
            "x-ves-proto-enum": "ves.io.schema.app_firewall.AppFirewallViolationType"
        },
        "app_firewallAttackType": {
            "type": "string",
            "description": "List of all Attack Types\n\nATTACK_TYPE_NONE\nATTACK_TYPE_NON_BROWSER_CLIENT\nATTACK_TYPE_OTHER_APPLICATION_ATTACKS\nATTACK_TYPE_TROJAN_BACKDOOR_SPYWARE\nATTACK_TYPE_DETECTION_EVASION\nATTACK_TYPE_VULNERABILITY_SCAN\nATTACK_TYPE_ABUSE_OF_FUNCTIONALITY\nATTACK_TYPE_AUTHENTICATION_AUTHORIZATION_ATTACKS\nATTACK_TYPE_BUFFER_OVERFLOW\nATTACK_TYPE_PREDICTABLE_RESOURCE_LOCATION\nATTACK_TYPE_INFORMATION_LEAKAGE\nATTACK_TYPE_DIRECTORY_INDEXING\nATTACK_TYPE_PATH_TRAVERSAL\nATTACK_TYPE_XPATH_INJECTION\nATTACK_TYPE_LDAP_INJECTION\nATTACK_TYPE_SERVER_SIDE_CODE_INJECTION\nATTACK_TYPE_COMMAND_EXECUTION\nATTACK_TYPE_SQL_INJECTION\nATTACK_TYPE_CROSS_SITE_SCRIPTING\nATTACK_TYPE_DENIAL_OF_SERVICE\nATTACK_TYPE_HTTP_PARSER_ATTACK\nATTACK_TYPE_SESSION_HIJACKING\nATTACK_TYPE_HTTP_RESPONSE_SPLITTING\nATTACK_TYPE_FORCEFUL_BROWSING\nATTACK_TYPE_REMOTE_FILE_INCLUDE\nATTACK_TYPE_MALICIOUS_FILE_UPLOAD\nATTACK_TYPE_GRAPHQL_PARSER_ATTACK",
            "title": "AttackType",
            "enum": [
                "ATTACK_TYPE_NONE",
                "ATTACK_TYPE_NON_BROWSER_CLIENT",
                "ATTACK_TYPE_OTHER_APPLICATION_ATTACKS",
                "ATTACK_TYPE_TROJAN_BACKDOOR_SPYWARE",
                "ATTACK_TYPE_DETECTION_EVASION",
                "ATTACK_TYPE_VULNERABILITY_SCAN",
                "ATTACK_TYPE_ABUSE_OF_FUNCTIONALITY",
                "ATTACK_TYPE_AUTHENTICATION_AUTHORIZATION_ATTACKS",
                "ATTACK_TYPE_BUFFER_OVERFLOW",
                "ATTACK_TYPE_PREDICTABLE_RESOURCE_LOCATION",
                "ATTACK_TYPE_INFORMATION_LEAKAGE",
                "ATTACK_TYPE_DIRECTORY_INDEXING",
                "ATTACK_TYPE_PATH_TRAVERSAL",
                "ATTACK_TYPE_XPATH_INJECTION",
                "ATTACK_TYPE_LDAP_INJECTION",
                "ATTACK_TYPE_SERVER_SIDE_CODE_INJECTION",
                "ATTACK_TYPE_COMMAND_EXECUTION",
                "ATTACK_TYPE_SQL_INJECTION",
                "ATTACK_TYPE_CROSS_SITE_SCRIPTING",
                "ATTACK_TYPE_DENIAL_OF_SERVICE",
                "ATTACK_TYPE_HTTP_PARSER_ATTACK",
                "ATTACK_TYPE_SESSION_HIJACKING",
                "ATTACK_TYPE_HTTP_RESPONSE_SPLITTING",
                "ATTACK_TYPE_FORCEFUL_BROWSING",
                "ATTACK_TYPE_REMOTE_FILE_INCLUDE",
                "ATTACK_TYPE_MALICIOUS_FILE_UPLOAD",
                "ATTACK_TYPE_GRAPHQL_PARSER_ATTACK"
            ],
            "default": "ATTACK_TYPE_NONE",
            "x-displayname": "Attack Types",
            "x-ves-proto-enum": "ves.io.schema.app_firewall.AttackType"
        },
        "app_securityApiEndpoint": {
            "type": "object",
            "description": "API Endpoint indentified by collapsed_url and method",
            "title": "API Endpoint",
            "x-displayname": "API Endpoint",
            "x-ves-proto-message": "ves.io.schema.app_security.ApiEndpoint",
            "properties": {
                "collapsed_url": {
                    "type": "string",
                    "description": " Collapsed URL is the path with identified DYN components\n\nExample: - \"/abcd/DYN/xyz\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "Collapsed URL",
                    "maxLength": 256,
                    "x-displayname": "Collapsed URL",
                    "x-ves-example": "/abcd/DYN/xyz",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                },
                "method": {
                    "type": "string",
                    "description": " HTTP method\n\nExample: - GET-",
                    "title": "method",
                    "x-displayname": "Method"
                }
            }
        },
        "app_securityGetSuggestedWAFExclusionRuleReq": {
            "type": "object",
            "description": "Get suggested service policy rule to set up WAF rule exclusion for a given WAF security event",
            "title": "GetSuggestedWAFExclusionRuleReq",
            "x-displayname": "Get Suggested WAF Exclusion Request",
            "x-ves-proto-message": "ves.io.schema.app_security.GetSuggestedWAFExclusionRuleReq",
            "properties": {
                "api_endpoint": {
                    "description": " API Endpoint indentified by collapsed_url and method",
                    "title": "API Endpoint",
                    "$ref": "#/definitions/app_securityApiEndpoint",
                    "x-displayname": "API Endpoint"
                },
                "domain": {
                    "type": "string",
                    "description": " domain\n\nExample: - \"juiceshop.com\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.hostname: true\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "Domain",
                    "maxLength": 256,
                    "x-displayname": "Domain",
                    "x-ves-example": "juiceshop.com",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.hostname": "true",
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                },
                "exclude_bot_names": {
                    "type": "array",
                    "description": " Bot name contexts to be excluded for this request\n\nExample: - \"Hydra, Nikto\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Exclude Bot Name Contexts",
                    "maxItems": 64,
                    "items": {
                        "$ref": "#/definitions/policyBotNameContext"
                    },
                    "x-displayname": "Exclude Bot Name Contexts",
                    "x-ves-example": "Hydra, Nikto",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "exclude_signature_contexts": {
                    "type": "array",
                    "description": " App Firewall signature contexts to be excluded for this request\n\nExample: - \"[[10000001, 30000000]]\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 1024\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Exclude Signature Contexts",
                    "maxItems": 1024,
                    "items": {
                        "$ref": "#/definitions/policyAppFirewallSignatureContext"
                    },
                    "x-displayname": "Exclude App Firewall Signature Contexts",
                    "x-ves-example": "[[10000001, 30000000]]",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "1024",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "exclude_violation_contexts": {
                    "type": "array",
                    "description": " App Firewall violation contexts to be excluded for this request\n\nExample: - \"[[VIOL_MANDATORY_HEADER, VIOL_REQUEST_MAX_LENGTH]]\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Exclude Violation Contexts",
                    "maxItems": 64,
                    "items": {
                        "$ref": "#/definitions/policyAppFirewallViolationContext"
                    },
                    "x-displayname": "Exclude App Firewall Violation Contexts",
                    "x-ves-example": "[[VIOL_MANDATORY_HEADER, VIOL_REQUEST_MAX_LENGTH]]",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "name": {
                    "type": "string",
                    "description": " HTTP load balancer for which this WAF exclusion will be applied\n\nExample: - \"ves-io-frontend\"-",
                    "title": "Name",
                    "x-displayname": "HTTP Load Balancer Name",
                    "x-ves-example": "ves-io-frontend"
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace of the App type for current request\n\nExample: - \"shared\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "shared"
                },
                "req_path": {
                    "type": "string",
                    "description": " Request URL path\n\nExample: - \"/abcd/2452422c/xyz\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "Request Path",
                    "maxLength": 256,
                    "x-displayname": "Request Path",
                    "x-ves-example": "/abcd/2452422c/xyz",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                },
                "route_uuid": {
                    "type": "string",
                    "description": " Unique identifier for the request route\n\nExample: - \"fc407065-7aa7-48a6-a3e7-c28108b29bcd\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.pattern: ^$|^[a-fA-F0-9]{8}-([a-fA-F0-9]{4}-){3}[a-fA-F0-9]{12}$\n",
                    "title": "Route UUID",
                    "x-displayname": "Route UUID",
                    "x-ves-example": "fc407065-7aa7-48a6-a3e7-c28108b29bcd",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.pattern": "^$|^[a-fA-F0-9]{8}-([a-fA-F0-9]{4}-){3}[a-fA-F0-9]{12}$"
                    }
                }
            }
        },
        "app_securityGetSuggestedWAFExclusionRuleRsp": {
            "type": "object",
            "description": "Get suggested service policy rule to set up WAF rule exclusion for a given WAF security event",
            "title": "GetSuggestedWAFExclusionRuleRsp",
            "x-displayname": "Get Suggested WAF Exclusion Response",
            "x-ves-proto-message": "ves.io.schema.app_security.GetSuggestedWAFExclusionRuleRsp",
            "properties": {
                "found_existing_rule": {
                    "description": " Specifies if an existing WAF exclusion rule already exists with same match conditions",
                    "title": "FoundExistingRule",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Found existing rule"
                },
                "name": {
                    "type": "string",
                    "description": " HTTP load balancer for which this WAF exclusion will be applied\n\nExample: - \"ves-io-frontend\"-",
                    "title": "Name",
                    "x-displayname": "HTTP Load Balancer Name",
                    "x-ves-example": "ves-io-frontend"
                },
                "waf_exclusion_policy": {
                    "description": " The WAF Exclusion policy where this WAF exclusion rule should be included",
                    "title": "WAF Exclusion Policy",
                    "$ref": "#/definitions/schemaviewsObjectRefType",
                    "x-displayname": "WAF Exclusion Policy"
                },
                "waf_exclusion_rule": {
                    "description": " Specifies a simple set of match conditions to be matched to skip WAF detections",
                    "title": "SimpleWafExclusionRule",
                    "$ref": "#/definitions/policySimpleWafExclusionRule",
                    "x-displayname": "Simple WAF Exclusion Rule"
                }
            }
        },
        "policyAppFirewallAttackTypeContext": {
            "type": "object",
            "description": "App Firewall Attack Type context changes to be applied for this request",
            "title": "App Firewall Attack Type Context",
            "x-displayname": "App Firewall Attack Type Context",
            "x-ves-proto-message": "ves.io.schema.policy.AppFirewallAttackTypeContext",
            "properties": {
                "context": {
                    "description": "\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Context",
                    "$ref": "#/definitions/policyDetectionContext",
                    "x-displayname": "Context",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "context_name": {
                    "type": "string",
                    "description": " Relevant only for contexts: Header, Cookie and Parameter.\n Name of the Context that the WAF Exclusion Rules will check.\n Wildcard matching can be used by prefixing or suffixing the context name\n with an wildcard asterisk (*).\n\nExample: - \"exampleuser-agent for Header\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 128\n",
                    "title": "Context Name",
                    "maxLength": 128,
                    "x-displayname": "Context Name",
                    "x-ves-example": "example: user-agent for Header",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "128"
                    }
                },
                "exclude_attack_type": {
                    "description": "\nExample: - \"ATTACK_TYPE_SQL_INJECTION\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "AttackType",
                    "$ref": "#/definitions/app_firewallAttackType",
                    "x-displayname": "Attack Type",
                    "x-ves-example": "ATTACK_TYPE_SQL_INJECTION",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "policyAppFirewallDetectionControl": {
            "type": "object",
            "description": "Define the list of Signature IDs, Violations, Attack Types and Bot Names that should be excluded from triggering on the defined match criteria.",
            "title": "App Firewall Detection Control",
            "x-displayname": "App Firewall Detection Control",
            "x-ves-proto-message": "ves.io.schema.policy.AppFirewallDetectionControl",
            "properties": {
                "exclude_attack_type_contexts": {
                    "type": "array",
                    "description": " Attack Types to be excluded for the defined match criteria\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Exclude Attack Types Contexts",
                    "maxItems": 64,
                    "items": {
                        "$ref": "#/definitions/policyAppFirewallAttackTypeContext"
                    },
                    "x-displayname": "Attack Types",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "exclude_bot_name_contexts": {
                    "type": "array",
                    "description": " Bot Names to be excluded for the defined match criteria\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Exclude Bot Names Contexts",
                    "maxItems": 64,
                    "items": {
                        "$ref": "#/definitions/policyBotNameContext"
                    },
                    "x-displayname": "Bot Names",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "exclude_signature_contexts": {
                    "type": "array",
                    "description": " Signature IDs to be excluded for the defined match criteria\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 1024\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Exclude Signature Contexts",
                    "maxItems": 1024,
                    "items": {
                        "$ref": "#/definitions/policyAppFirewallSignatureContext"
                    },
                    "x-displayname": "Signature IDs",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "1024",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "exclude_violation_contexts": {
                    "type": "array",
                    "description": " Violations to be excluded for the defined match criteria\n\nValidation Rules:\n  ves.io.schema.rules.repeated.max_items: 64\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Exclude Violation Contexts",
                    "maxItems": 64,
                    "items": {
                        "$ref": "#/definitions/policyAppFirewallViolationContext"
                    },
                    "x-displayname": "Violations",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.max_items": "64",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                }
            }
        },
        "policyAppFirewallSignatureContext": {
            "type": "object",
            "description": "App Firewall signature context changes to be applied for this request",
            "title": "App Firewall Signature Context",
            "x-displayname": "App Firewall Signature Context",
            "x-ves-proto-message": "ves.io.schema.policy.AppFirewallSignatureContext",
            "properties": {
                "context": {
                    "description": "\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Context",
                    "$ref": "#/definitions/policyDetectionContext",
                    "x-displayname": "Context",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "context_name": {
                    "type": "string",
                    "description": " Relevant only for contexts: Header, Cookie and Parameter.\n Name of the Context that the WAF Exclusion Rules will check.\n Wildcard matching can be used by prefixing or suffixing the context name\n with an wildcard asterisk (*).\n\nExample: - \"exampleuser-agent for Header\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 128\n",
                    "title": "Context Name",
                    "maxLength": 128,
                    "x-displayname": "Context Name",
                    "x-ves-example": "example: user-agent for Header",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "128"
                    }
                },
                "signature_id": {
                    "type": "integer",
                    "description": " The allowed values for signature id are 0 and in the range of 200000001-299999999.\n 0 implies that all signatures will be excluded for the specified context.\n\nExample: - \"10000001\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.uint32.gte: 0\n  ves.io.schema.rules.uint32.lte: 299999999\n",
                    "title": "SignatureID",
                    "format": "int64",
                    "x-displayname": "SignatureID",
                    "x-ves-example": "10000001",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.uint32.gte": "0",
                        "ves.io.schema.rules.uint32.lte": "299999999"
                    }
                }
            }
        },
        "policyAppFirewallViolationContext": {
            "type": "object",
            "description": "App Firewall violation context changes to be applied for this request",
            "title": "App Firewall Violation Context",
            "x-displayname": "App Firewall Violation Context",
            "x-ves-proto-message": "ves.io.schema.policy.AppFirewallViolationContext",
            "properties": {
                "context": {
                    "description": "\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Context",
                    "$ref": "#/definitions/policyDetectionContext",
                    "x-displayname": "Context",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "context_name": {
                    "type": "string",
                    "description": " Relevant only for contexts: Header, Cookie and Parameter.\n Name of the Context that the WAF Exclusion Rules will check.\n Wildcard matching can be used by prefixing or suffixing the context name\n with an wildcard asterisk (*).\n\nExample: - \"exampleuser-agent for Header\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 128\n",
                    "title": "Context Name",
                    "maxLength": 128,
                    "x-displayname": "Context Name",
                    "x-ves-example": "example: user-agent for Header",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "128"
                    }
                },
                "exclude_violation": {
                    "description": "\nExample: - \"VIOL_MANDATORY_HEADER\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "ViolationType",
                    "$ref": "#/definitions/app_firewallAppFirewallViolationType",
                    "x-displayname": "Violation Type",
                    "x-ves-example": "VIOL_MANDATORY_HEADER",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "policyBotNameContext": {
            "type": "object",
            "description": "Specifies bot to be excluded by its name.",
            "title": "Bot Name Context",
            "x-displayname": "Bot Name",
            "x-ves-proto-message": "ves.io.schema.policy.BotNameContext",
            "properties": {
                "bot_name": {
                    "type": "string",
                    "description": "\nExample: - \"Hydra\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "BotName",
                    "x-displayname": "Bot Name",
                    "x-ves-example": "Hydra",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                }
            }
        },
        "policyDetectionContext": {
            "type": "string",
            "description": "The available contexts for Exclusion rules.\n\n - CONTEXT_ANY: CONTEXT_ANY\n\nDetection will be excluded for all contexts.\n - CONTEXT_BODY: CONTEXT_BODY\n\nDetection will be excluded for the request body.\n - CONTEXT_REQUEST: CONTEXT_REQUEST\n\nDetection will be excluded for the request.\n - CONTEXT_RESPONSE: CONTEXT_RESPONSE\n\n - CONTEXT_PARAMETER: CONTEXT_PARAMETER\n\nDetection will be excluded for the parameters. The parameter name is required in the Context name field. If the field is left empty, the detection will be excluded for all parameters.\n - CONTEXT_HEADER: CONTEXT_HEADER\n\nDetection will be excluded for the headers. The header name is required in the Context name field. If the field is left empty, the detection will be excluded for all headers.\n - CONTEXT_COOKIE: CONTEXT_COOKIE\n\nDetection will be excluded for the cookies. The cookie name is required in the Context name field. If the field is left empty, the detection will be excluded for all cookies.\n - CONTEXT_URL: CONTEXT_URL\n\nDetection will be excluded for the request URL.\n - CONTEXT_URI: CONTEXT_URI\n",
            "title": "Detection Context",
            "enum": [
                "CONTEXT_ANY",
                "CONTEXT_BODY",
                "CONTEXT_REQUEST",
                "CONTEXT_RESPONSE",
                "CONTEXT_PARAMETER",
                "CONTEXT_HEADER",
                "CONTEXT_COOKIE",
                "CONTEXT_URL",
                "CONTEXT_URI"
            ],
            "default": "CONTEXT_ANY",
            "x-displayname": "WAF Exclusion Context Options",
            "x-ves-proto-enum": "ves.io.schema.policy.DetectionContext"
        },
        "policySimpleWafExclusionRule": {
            "type": "object",
            "description": "Simple WAF exclusion rule specifies a simple set of match conditions to be matched to skip a list of WAF detections",
            "title": "SimpleWafExclusionRule",
            "x-displayname": "WAF Exclusion Rule",
            "x-ves-displayorder": "10,3,16,7,14,9",
            "x-ves-oneof-field-domain_choice": "[\"any_domain\",\"exact_value\",\"suffix_value\"]",
            "x-ves-oneof-field-path_choice": "[\"any_path\",\"path_prefix\",\"path_regex\"]",
            "x-ves-oneof-field-waf_advanced_configuration": "[\"app_firewall_detection_control\",\"waf_skip_processing\"]",
            "x-ves-proto-message": "ves.io.schema.policy.SimpleWafExclusionRule",
            "properties": {
                "any_domain": {
                    "description": "Exclusive with [exact_value suffix_value]\n Apply this WAF exclusion rule for any domain",
                    "title": "Any domain",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Any Domain"
                },
                "any_path": {
                    "description": "Exclusive with [path_prefix path_regex]\n Match all paths",
                    "title": "Any path",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Any Path"
                },
                "app_firewall_detection_control": {
                    "description": "Exclusive with [waf_skip_processing]\n Define the list of Signature IDs, Violations, Attack Types and Bot Names that should be excluded from triggering on the defined match criteria.\n\nValidation Rules:\n  ves.io.schema.rules.message.required_one_nonzero_field: true\n",
                    "title": "App Firewall Detection control",
                    "$ref": "#/definitions/policyAppFirewallDetectionControl",
                    "x-displayname": "App Firewall Detection Control",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required_one_nonzero_field": "true"
                    }
                },
                "exact_value": {
                    "type": "string",
                    "description": "Exclusive with [any_domain suffix_value]\n Exact domain name\n\nExample: - \"abc.zyz.com\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.hostname: true\n  ves.io.schema.rules.string.max_len: 256\n  ves.io.schema.rules.string.min_len: 1\n",
                    "title": "exact value",
                    "minLength": 1,
                    "maxLength": 256,
                    "x-displayname": "Exact Value",
                    "x-ves-example": "abc.zyz.com",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.hostname": "true",
                        "ves.io.schema.rules.string.max_len": "256",
                        "ves.io.schema.rules.string.min_len": "1"
                    }
                },
                "expiration_timestamp": {
                    "type": "string",
                    "description": " The expiration_timestamp is the RFC 3339 format timestamp at which the containing rule is considered to be logically expired. The rule continues to exist in\n the configuration but is not applied anymore.\n\nExample: - \"2019-12-31:44:34.171543432Z\"-",
                    "title": "expiration timestamp",
                    "format": "date-time",
                    "x-displayname": "Expiration Timestamp",
                    "x-ves-example": "2019-12-31:44:34.171543432Z"
                },
                "metadata": {
                    "description": " Common attributes for the rule including name and description.\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "metadata",
                    "$ref": "#/definitions/schemaMessageMetaType",
                    "x-displayname": "Metadata",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "methods": {
                    "type": "array",
                    "description": " methods to be matched\n\nExample: - \"GET\"-\n\nValidation Rules:\n  ves.io.schema.rules.repeated.items.enum.defined_only: true\n  ves.io.schema.rules.repeated.max_items: 16\n  ves.io.schema.rules.repeated.unique: true\n",
                    "title": "Methods",
                    "maxItems": 16,
                    "items": {
                        "$ref": "#/definitions/schemaHttpMethod"
                    },
                    "x-displayname": "Methods",
                    "x-ves-example": "GET",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.repeated.items.enum.defined_only": "true",
                        "ves.io.schema.rules.repeated.max_items": "16",
                        "ves.io.schema.rules.repeated.unique": "true"
                    }
                },
                "path_prefix": {
                    "type": "string",
                    "description": "Exclusive with [any_path path_regex]\n Path prefix to match (e.g. the value / will match on all paths)\n\nExample: - \"/register/\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.http_path: true\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "prefix",
                    "maxLength": 256,
                    "x-displayname": "Prefix",
                    "x-ves-example": "/register/",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.http_path": "true",
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                },
                "path_regex": {
                    "type": "string",
                    "description": "Exclusive with [any_path path_prefix]\n Define the regex for the path. For example, the regex ^/.*$ will match on all paths\n\nExample: - \"/blog_id/.*\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 256\n  ves.io.schema.rules.string.regex: true\n",
                    "title": "Path Regex",
                    "maxLength": 256,
                    "x-displayname": "Path Regex",
                    "x-ves-example": "/blog_id/.*",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "256",
                        "ves.io.schema.rules.string.regex": "true"
                    }
                },
                "suffix_value": {
                    "type": "string",
                    "description": "Exclusive with [any_domain exact_value]\n Suffix of domain name e.g \"xyz.com\" will match \"*.xyz.com\" and \"xyz.com\"\n\nExample: - \"xyz.com\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.hostname: true\n  ves.io.schema.rules.string.max_len: 256\n  ves.io.schema.rules.string.min_len: 1\n",
                    "title": "suffix value",
                    "minLength": 1,
                    "maxLength": 256,
                    "x-displayname": "Suffix Value",
                    "x-ves-example": "xyz.com",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.hostname": "true",
                        "ves.io.schema.rules.string.max_len": "256",
                        "ves.io.schema.rules.string.min_len": "1"
                    }
                },
                "waf_skip_processing": {
                    "description": "Exclusive with [app_firewall_detection_control]\n Skip all App Firewall processing for this request",
                    "title": "Skip App Firewall Processing",
                    "$ref": "#/definitions/schemaEmpty",
                    "x-displayname": "Skip App Firewall Processing"
                }
            }
        },
        "schemaEmpty": {
            "type": "object",
            "description": "This can be used for messages where no values are needed",
            "title": "Empty",
            "x-displayname": "Empty",
            "x-ves-proto-message": "ves.io.schema.Empty"
        },
        "schemaHttpMethod": {
            "type": "string",
            "description": "Specifies the HTTP method used to access a resource.\n\nAny HTTP Method",
            "title": "HttpMethod",
            "enum": [
                "ANY",
                "GET",
                "HEAD",
                "POST",
                "PUT",
                "DELETE",
                "CONNECT",
                "OPTIONS",
                "TRACE",
                "PATCH",
                "COPY"
            ],
            "default": "ANY",
            "x-displayname": "HTTP Method",
            "x-ves-proto-enum": "ves.io.schema.HttpMethod"
        },
        "schemaMessageMetaType": {
            "type": "object",
            "description": "MessageMetaType is metadata (common attributes) of a message that only certain messages\nhave. This information is propagated to the metadata of a child object that gets created\nfrom the containing message during view processing.\nThe information in this type can be specified by user during create and replace APIs.",
            "title": "MessageMetaType",
            "x-displayname": "Message Metadata",
            "x-ves-proto-message": "ves.io.schema.MessageMetaType",
            "properties": {
                "description": {
                    "type": "string",
                    "description": " Human readable description.\n\nExample: - \"Virtual Host for acmecorp website\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_len: 256\n",
                    "title": "description",
                    "maxLength": 256,
                    "x-displayname": "Description",
                    "x-ves-example": "Virtual Host for acmecorp website",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_len": "256"
                    }
                },
                "name": {
                    "type": "string",
                    "description": " This is the name of the message.\n The value of name has to follow DNS-1035 format.\n\nExample: - \"acmecorp-web\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.min_len: 1\n  ves.io.schema.rules.string.ves_object_name: true\n",
                    "title": "name",
                    "minLength": 1,
                    "x-displayname": "Name",
                    "x-ves-example": "acmecorp-web",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.min_len": "1",
                        "ves.io.schema.rules.string.ves_object_name": "true"
                    }
                }
            }
        },
        "schemaviewsObjectRefType": {
            "type": "object",
            "description": "This type establishes a direct reference from one object(the referrer) to another(the referred).\nSuch a reference is in form of tenant/namespace/name",
            "title": "ObjectRefType",
            "x-displayname": "Object reference",
            "x-ves-proto-message": "ves.io.schema.views.ObjectRefType",
            "properties": {
                "name": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then name will hold the referred object's(e.g. route's) name.\n\nExample: - \"contacts-route\"-\n\nRequired: YES\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n  ves.io.schema.rules.string.max_bytes: 128\n  ves.io.schema.rules.string.min_bytes: 1\n",
                    "title": "name",
                    "minLength": 1,
                    "maxLength": 128,
                    "x-displayname": "Name",
                    "x-ves-example": "contacts-route",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true",
                        "ves.io.schema.rules.string.max_bytes": "128",
                        "ves.io.schema.rules.string.min_bytes": "1"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then namespace will hold the referred object's(e.g. route's) namespace.\n\nExample: - \"ns1\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 64\n",
                    "title": "namespace",
                    "maxLength": 64,
                    "x-displayname": "Namespace",
                    "x-ves-example": "ns1",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "64"
                    }
                },
                "tenant": {
                    "type": "string",
                    "description": " When a configuration object(e.g. virtual_host) refers to another(e.g route)\n then tenant will hold the referred object's(e.g. route's) tenant.\n\nExample: - \"acmecorp\"-\n\nValidation Rules:\n  ves.io.schema.rules.string.max_bytes: 64\n",
                    "title": "tenant",
                    "maxLength": 64,
                    "x-displayname": "Tenant",
                    "x-ves-example": "acmecorp",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.string.max_bytes": "64"
                    }
                }
            }
        }
    },
    "x-displayname": "Application Security Monitoring APIs",
    "x-ves-proto-file": "ves.io/schema/app_security/public_waf_exclusion_api.proto"
}`
