// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/types.proto

package schema

import (
	bytes "bytes"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// HttpMethod
//
// x-displayName: "HTTP Method"
// Specifies the HTTP method used to access a resource.
type HttpMethod int32

const (
	// x-displayName: "ANY"
	// Any HTTP Method
	ANY HttpMethod = 0
	// x-displayName: "GET"
	GET HttpMethod = 1
	// x-displayName: "HEAD"
	HEAD HttpMethod = 2
	// x-displayName: "POST"
	POST HttpMethod = 3
	// x-displayName: "PUT"
	PUT HttpMethod = 4
	// x-displayName: "DELETE"
	DELETE HttpMethod = 5
	// x-displayName: "CONNECT"
	CONNECT HttpMethod = 6
	// x-displayName: "OPTIONS"
	OPTIONS HttpMethod = 7
	// x-displayName: "TRACE"
	TRACE HttpMethod = 8
	// x-displayName: "PATCH"
	PATCH HttpMethod = 9
)

var HttpMethod_name = map[int32]string{
	0: "ANY",
	1: "GET",
	2: "HEAD",
	3: "POST",
	4: "PUT",
	5: "DELETE",
	6: "CONNECT",
	7: "OPTIONS",
	8: "TRACE",
	9: "PATCH",
}

var HttpMethod_value = map[string]int32{
	"ANY":     0,
	"GET":     1,
	"HEAD":    2,
	"POST":    3,
	"PUT":     4,
	"DELETE":  5,
	"CONNECT": 6,
	"OPTIONS": 7,
	"TRACE":   8,
	"PATCH":   9,
}

func (HttpMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{0}
}

// BotHttpMethod
//
// x-displayName: "HTTP Method"
// Specifies the HTTP method used to access a resource.
type BotHttpMethod int32

const (
	// x-displayName: "ANY"
	// Any HTTP Method
	METHOD_ANY BotHttpMethod = 0
	// x-displayName: "GET(XHR/Fetch)"
	// GET method for XMLHttpRequest or Fetch
	METHOD_GET BotHttpMethod = 1
	// x-displayName: "POST"
	// POST method
	METHOD_POST BotHttpMethod = 3
	// x-displayName: "PUT"
	// PUT method
	METHOD_PUT BotHttpMethod = 4
	// x-displayName: "PATCH"
	// PATCH method
	METHOD_PATCH BotHttpMethod = 5
	// x-displayName: "DELETE"
	// DELETE method
	METHOD_DELETE BotHttpMethod = 6
	// x-displayName: "GET(Document)"
	// GET method for HTML document
	METHOD_GET_DOCUMENT BotHttpMethod = 10
)

var BotHttpMethod_name = map[int32]string{
	0:  "METHOD_ANY",
	1:  "METHOD_GET",
	3:  "METHOD_POST",
	4:  "METHOD_PUT",
	5:  "METHOD_PATCH",
	6:  "METHOD_DELETE",
	10: "METHOD_GET_DOCUMENT",
}

var BotHttpMethod_value = map[string]int32{
	"METHOD_ANY":          0,
	"METHOD_GET":          1,
	"METHOD_POST":         3,
	"METHOD_PUT":          4,
	"METHOD_PATCH":        5,
	"METHOD_DELETE":       6,
	"METHOD_GET_DOCUMENT": 10,
}

func (BotHttpMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{1}
}

// OpenApiValidationProperties
//
// x-displayName: "OpenAPI Validation Properties"
// List of required properties to validate against the OpenAPI spec
type OpenApiValidationProperties int32

const (
	// x-displayName: "Query Parameters"
	// Validate that all query parameters are according to the OpenAPI specification
	PROPERTY_QUERY_PARAMETERS OpenApiValidationProperties = 0
	// x-displayName: "Path Parameters"
	// Validate that all path parameters are according to the OpenAPI specification
	PROPERTY_PATH_PARAMETERS OpenApiValidationProperties = 1
	// x-displayName: "Content-type"
	// Validate that the content type of the request is according to the OpenAPI specification
	PROPERTY_CONTENT_TYPE OpenApiValidationProperties = 2
	// x-displayName: "Cookie Parameters"
	// Validate that all cookies are according to the OpenAPI specification
	PROPERTY_COOKIE_PARAMETERS OpenApiValidationProperties = 3
	// x-displayName: "HTTP Headers"
	// Validate that all HTTP headers are according to the OpenAPI specification
	PROPERTY_HTTP_HEADERS OpenApiValidationProperties = 4
	// x-displayName: "HTTP Body"
	// Validate that the body is according to the OpenAPI specification
	PROPERTY_HTTP_BODY OpenApiValidationProperties = 5
	// x-displayName: "Security Schema"
	// Validate that the security schema is according to the OpenAPI specification
	PROPERTY_SECURITY_SCHEMA OpenApiValidationProperties = 6
	// x-displayName: "Response Code"
	// Validate that the response code is according to the OpenAPI specification
	PROPERTY_RESPONSE_CODE OpenApiValidationProperties = 7
)

var OpenApiValidationProperties_name = map[int32]string{
	0: "PROPERTY_QUERY_PARAMETERS",
	1: "PROPERTY_PATH_PARAMETERS",
	2: "PROPERTY_CONTENT_TYPE",
	3: "PROPERTY_COOKIE_PARAMETERS",
	4: "PROPERTY_HTTP_HEADERS",
	5: "PROPERTY_HTTP_BODY",
	6: "PROPERTY_SECURITY_SCHEMA",
	7: "PROPERTY_RESPONSE_CODE",
}

var OpenApiValidationProperties_value = map[string]int32{
	"PROPERTY_QUERY_PARAMETERS":  0,
	"PROPERTY_PATH_PARAMETERS":   1,
	"PROPERTY_CONTENT_TYPE":      2,
	"PROPERTY_COOKIE_PARAMETERS": 3,
	"PROPERTY_HTTP_HEADERS":      4,
	"PROPERTY_HTTP_BODY":         5,
	"PROPERTY_SECURITY_SCHEMA":   6,
	"PROPERTY_RESPONSE_CODE":     7,
}

func (OpenApiValidationProperties) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{2}
}

// HttpStatusCode
//
// x-displayName: "HTTP Status Code"
// HTTP response status codes
type HttpStatusCode int32

const (
	// x-displayName: "0 Empty Status Code"
	// EmptyStatusCode response codes means it is not specified
	EmptyStatusCode HttpStatusCode = 0
	// x-displayName: "100 Continue"
	// Continue status code
	Continue HttpStatusCode = 100
	// x-displayName: "200 OK"
	// OK status code
	OK HttpStatusCode = 200
	// x-displayName: "201 Created"
	// Created status code
	Created HttpStatusCode = 201
	// x-displayName: "202 Accepted"
	// Accepted status code
	Accepted HttpStatusCode = 202
	// x-displayName: "203 Non Authoritative Information"
	// Non Authoritative Information status code
	NonAuthoritativeInformation HttpStatusCode = 203
	// x-displayName: "204 No Content"
	// No Content status code
	NoContent HttpStatusCode = 204
	// x-displayName: "205 Reset Content"
	// Reset Content status code
	ResetContent HttpStatusCode = 205
	// x-displayName: "206 Partial Content"
	// Partial Content status code
	PartialContent HttpStatusCode = 206
	// x-displayName: "207 Multi Status"
	// Multi Status status code
	MultiStatus HttpStatusCode = 207
	// x-displayName: "208 Already Reported"
	// Already Reported status code
	AlreadyReported HttpStatusCode = 208
	// x-displayName: "226 Im Used"
	// Im Used status code
	IMUsed HttpStatusCode = 226
	// x-displayName: "300 Multiple Choices"
	// Multiple Choices status code
	MultipleChoices HttpStatusCode = 300
	// x-displayName: "301 Moved Permanently"
	// Moved Permanently status code
	MovedPermanently HttpStatusCode = 301
	// x-displayName: "302 Found"
	// Found status code
	Found HttpStatusCode = 302
	// x-displayName: "303 See Other"
	// See Other status code
	SeeOther HttpStatusCode = 303
	// x-displayName: "304 Not Modified"
	// Not Modified status code
	NotModified HttpStatusCode = 304
	// x-displayName: "305 Use Proxy"
	// Use Proxy status code
	UseProxy HttpStatusCode = 305
	// x-displayName: "307 Temporary Redirect"
	// Temporary Redirect status code
	TemporaryRedirect HttpStatusCode = 307
	// x-displayName: "308 Permanent Redirect"
	// Permanent Redirect status code
	PermanentRedirect HttpStatusCode = 308
	// x-displayName: "400 Bad Request"
	// Bad Request status code
	BadRequest HttpStatusCode = 400
	// x-displayName: "401 Unauthorized"
	// Unauthorized status code
	Unauthorized HttpStatusCode = 401
	// x-displayName: "402 Payment Required"
	// Payment Required status code
	PaymentRequired HttpStatusCode = 402
	// x-displayName: "403 Forbidden"
	// Forbidden status code
	Forbidden HttpStatusCode = 403
	// x-displayName: "404 Not Found"
	// Not Found status code
	NotFound HttpStatusCode = 404
	// x-displayName: "405 Method Not Allowed"
	// Method Not Allowed status code
	MethodNotAllowed HttpStatusCode = 405
	// x-displayName: "406 Not Acceptable"
	// Not Acceptable status code
	NotAcceptable HttpStatusCode = 406
	// x-displayName: "407 Proxy Authentication Required"
	// Proxy Authentication Required status code
	ProxyAuthenticationRequired HttpStatusCode = 407
	// x-displayName: "408 Request Timeout"
	// Request Timeout status code
	RequestTimeout HttpStatusCode = 408
	// x-displayName: "409 Conflict"
	// Conflict status code
	Conflict HttpStatusCode = 409
	// x-displayName: "410 Gone"
	// Gone status code
	Gone HttpStatusCode = 410
	// x-displayName: "411 Length Required"
	// Length Required status code
	LengthRequired HttpStatusCode = 411
	// x-displayName: "412 Precondition Failed"
	// Precondition Failed status code
	PreconditionFailed HttpStatusCode = 412
	// x-displayName: "413 Payload Too Large"
	// Payload Too Large status code
	PayloadTooLarge HttpStatusCode = 413
	// x-displayName: "414 Uri Too Long"
	// Uri Too Long status code
	URITooLong HttpStatusCode = 414
	// x-displayName: "415 Unsupported Media Type"
	// Unsupported Media Type status code
	UnsupportedMediaType HttpStatusCode = 415
	// x-displayName: "416 Range Not Satisfiable"
	// Range Not Satisfiable status code
	RangeNotSatisfiable HttpStatusCode = 416
	// x-displayName: "417 Expectation Failed"
	// Expectation Failed status code
	ExpectationFailed HttpStatusCode = 417
	// x-displayName: "421 Misdirected Request"
	// Misdirected Request status code
	MisdirectedRequest HttpStatusCode = 421
	// x-displayName: "422 Unprocessable Entity"
	// Unprocessable Entity status code
	UnprocessableEntity HttpStatusCode = 422
	// x-displayName: "423 Locked"
	// Locked status code
	Locked HttpStatusCode = 423
	// x-displayName: "424 Failed Dependency"
	// Failed Dependency status code
	FailedDependency HttpStatusCode = 424
	// x-displayName: "426 Upgrade Required"
	// Upgrade Required status code
	UpgradeRequired HttpStatusCode = 426
	// x-displayName: "428 Precondition Required"
	// Precondition Required status code
	PreconditionRequired HttpStatusCode = 428
	// x-displayName: "429 Too Many Requests"
	// Too Many Requests status code
	TooManyRequests HttpStatusCode = 429
	// x-displayName: "431 Request Header Fields Too Large"
	// Request Header Fields Too Large status code
	RequestHeaderFieldsTooLarge HttpStatusCode = 431
	// x-displayName: "500 Internal Server Error"
	// Internal Server Error status code
	InternalServerError HttpStatusCode = 500
	// x-displayName: "501 Not Implemented"
	// Not Implemented status code
	NotImplemented HttpStatusCode = 501
	// x-displayName: "502 Bad Gateway"
	// Bad Gateway status code
	BadGateway HttpStatusCode = 502
	// x-displayName: "503 Service Unavailable"
	// Service Unavailable status code
	ServiceUnavailable HttpStatusCode = 503
	// x-displayName: "504 Gateway Timeout"
	// Gateway Timeout status code
	GatewayTimeout HttpStatusCode = 504
	// x-displayName: "505 Http Version Not Supported"
	// Http Version Not Supported status code
	HTTPVersionNotSupported HttpStatusCode = 505
	// x-displayName: "506 Variant Also Negotiates"
	// Variant Also Negotiates status code
	VariantAlsoNegotiates HttpStatusCode = 506
	// x-displayName: "507 Insufficient Storage"
	// Insufficient Storage status code
	InsufficientStorage HttpStatusCode = 507
	// x-displayName: "508 Loop Detected"
	// Loop Detected status code
	LoopDetected HttpStatusCode = 508
	// x-displayName: "510 Not Extended"
	// Not Extended status code
	NotExtended HttpStatusCode = 510
	// x-displayName: "511 Network Authentication Required"
	// Network Authentication Required status code
	NetworkAuthenticationRequired HttpStatusCode = 511
)

var HttpStatusCode_name = map[int32]string{
	0:   "EmptyStatusCode",
	100: "Continue",
	200: "OK",
	201: "Created",
	202: "Accepted",
	203: "NonAuthoritativeInformation",
	204: "NoContent",
	205: "ResetContent",
	206: "PartialContent",
	207: "MultiStatus",
	208: "AlreadyReported",
	226: "IMUsed",
	300: "MultipleChoices",
	301: "MovedPermanently",
	302: "Found",
	303: "SeeOther",
	304: "NotModified",
	305: "UseProxy",
	307: "TemporaryRedirect",
	308: "PermanentRedirect",
	400: "BadRequest",
	401: "Unauthorized",
	402: "PaymentRequired",
	403: "Forbidden",
	404: "NotFound",
	405: "MethodNotAllowed",
	406: "NotAcceptable",
	407: "ProxyAuthenticationRequired",
	408: "RequestTimeout",
	409: "Conflict",
	410: "Gone",
	411: "LengthRequired",
	412: "PreconditionFailed",
	413: "PayloadTooLarge",
	414: "URITooLong",
	415: "UnsupportedMediaType",
	416: "RangeNotSatisfiable",
	417: "ExpectationFailed",
	421: "MisdirectedRequest",
	422: "UnprocessableEntity",
	423: "Locked",
	424: "FailedDependency",
	426: "UpgradeRequired",
	428: "PreconditionRequired",
	429: "TooManyRequests",
	431: "RequestHeaderFieldsTooLarge",
	500: "InternalServerError",
	501: "NotImplemented",
	502: "BadGateway",
	503: "ServiceUnavailable",
	504: "GatewayTimeout",
	505: "HTTPVersionNotSupported",
	506: "VariantAlsoNegotiates",
	507: "InsufficientStorage",
	508: "LoopDetected",
	510: "NotExtended",
	511: "NetworkAuthenticationRequired",
}

var HttpStatusCode_value = map[string]int32{
	"EmptyStatusCode":               0,
	"Continue":                      100,
	"OK":                            200,
	"Created":                       201,
	"Accepted":                      202,
	"NonAuthoritativeInformation":   203,
	"NoContent":                     204,
	"ResetContent":                  205,
	"PartialContent":                206,
	"MultiStatus":                   207,
	"AlreadyReported":               208,
	"IMUsed":                        226,
	"MultipleChoices":               300,
	"MovedPermanently":              301,
	"Found":                         302,
	"SeeOther":                      303,
	"NotModified":                   304,
	"UseProxy":                      305,
	"TemporaryRedirect":             307,
	"PermanentRedirect":             308,
	"BadRequest":                    400,
	"Unauthorized":                  401,
	"PaymentRequired":               402,
	"Forbidden":                     403,
	"NotFound":                      404,
	"MethodNotAllowed":              405,
	"NotAcceptable":                 406,
	"ProxyAuthenticationRequired":   407,
	"RequestTimeout":                408,
	"Conflict":                      409,
	"Gone":                          410,
	"LengthRequired":                411,
	"PreconditionFailed":            412,
	"PayloadTooLarge":               413,
	"URITooLong":                    414,
	"UnsupportedMediaType":          415,
	"RangeNotSatisfiable":           416,
	"ExpectationFailed":             417,
	"MisdirectedRequest":            421,
	"UnprocessableEntity":           422,
	"Locked":                        423,
	"FailedDependency":              424,
	"UpgradeRequired":               426,
	"PreconditionRequired":          428,
	"TooManyRequests":               429,
	"RequestHeaderFieldsTooLarge":   431,
	"InternalServerError":           500,
	"NotImplemented":                501,
	"BadGateway":                    502,
	"ServiceUnavailable":            503,
	"GatewayTimeout":                504,
	"HTTPVersionNotSupported":       505,
	"VariantAlsoNegotiates":         506,
	"InsufficientStorage":           507,
	"LoopDetected":                  508,
	"NotExtended":                   510,
	"NetworkAuthenticationRequired": 511,
}

func (HttpStatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{3}
}

// HttpResponseCodeClass
//
// x-displayName: "HTTP Response Code Class"
// Represents different http response classes(e.g 1XX, 2XX etc).
type HttpResponseCodeClass int32

const (
	// x-displayName: "Unknown Response Class"
	// Response code is unknown.
	HTTP_RESPONSE_CODE_CLASS_UNKNOWN HttpResponseCodeClass = 0
	// x-displayName: "1XX Response Class"
	// Response code belongs to 1XX class.
	HTTP_RESPONSE_CODE_CLASS_1XX HttpResponseCodeClass = 1
	// x-displayName: "2XX Response Class"
	// Response code belongs to 2XX class.
	HTTP_RESPONSE_CODE_CLASS_2XX HttpResponseCodeClass = 2
	// x-displayName: "3XX Response Class"
	// Response code belongs to 3XX class.
	HTTP_RESPONSE_CODE_CLASS_3XX HttpResponseCodeClass = 3
	// x-displayName: "4XX Response Class"
	// Response code belongs to 4XX class.
	HTTP_RESPONSE_CODE_CLASS_4XX HttpResponseCodeClass = 4
	// x-displayName: "5XX Response Class"
	// Response code belongs to 5XX class.
	HTTP_RESPONSE_CODE_CLASS_5XX HttpResponseCodeClass = 5
)

var HttpResponseCodeClass_name = map[int32]string{
	0: "HTTP_RESPONSE_CODE_CLASS_UNKNOWN",
	1: "HTTP_RESPONSE_CODE_CLASS_1XX",
	2: "HTTP_RESPONSE_CODE_CLASS_2XX",
	3: "HTTP_RESPONSE_CODE_CLASS_3XX",
	4: "HTTP_RESPONSE_CODE_CLASS_4XX",
	5: "HTTP_RESPONSE_CODE_CLASS_5XX",
}

var HttpResponseCodeClass_value = map[string]int32{
	"HTTP_RESPONSE_CODE_CLASS_UNKNOWN": 0,
	"HTTP_RESPONSE_CODE_CLASS_1XX":     1,
	"HTTP_RESPONSE_CODE_CLASS_2XX":     2,
	"HTTP_RESPONSE_CODE_CLASS_3XX":     3,
	"HTTP_RESPONSE_CODE_CLASS_4XX":     4,
	"HTTP_RESPONSE_CODE_CLASS_5XX":     5,
}

func (HttpResponseCodeClass) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{4}
}

// HTTPSections
//
// x-displayName: "HTTP Sections"
// Request & Response Sections.
type HttpSections int32

const (
	// None
	//
	// ALL_SECTIONS
	// x-displayName: "None"
	HTTP_SECTION_NONE HttpSections = 0
	// QUERY_PARAMS
	//
	// x-displayName: "Request Query Params"
	HTTP_SECTION_QUERY_PARAMS HttpSections = 1
	// REQ_HEADERS
	//
	// x-displayName: "Request Headers"
	HTTP_SECTION_REQ_HEADERS HttpSections = 2
	// RSP_HEADERS
	//
	// x-displayName: "Response Headers"
	HTTP_SECTION_RSP_HEADERS HttpSections = 3
	// REQ_BODY
	//
	// x-displayName: "Request Body"
	HTTP_SECTION_REQ_BODY HttpSections = 5
	// RSP_BODY
	//
	// x-displayName: "Response Body"
	HTTP_SECTION_RSP_BODY HttpSections = 6
)

var HttpSections_name = map[int32]string{
	0: "HTTP_SECTION_NONE",
	1: "HTTP_SECTION_QUERY_PARAMS",
	2: "HTTP_SECTION_REQ_HEADERS",
	3: "HTTP_SECTION_RSP_HEADERS",
	5: "HTTP_SECTION_REQ_BODY",
	6: "HTTP_SECTION_RSP_BODY",
}

var HttpSections_value = map[string]int32{
	"HTTP_SECTION_NONE":         0,
	"HTTP_SECTION_QUERY_PARAMS": 1,
	"HTTP_SECTION_REQ_HEADERS":  2,
	"HTTP_SECTION_RSP_HEADERS":  3,
	"HTTP_SECTION_REQ_BODY":     5,
	"HTTP_SECTION_RSP_BODY":     6,
}

func (HttpSections) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{5}
}

// StatusPublishType
//
// x-displayName: "Status Publish Type"
// StatusPublishType is all possible publish operations on a StatusObject
type StatusPublishType int32

const (
	// Do Not Publish
	//
	// x-displayName: "Do Not Publish"
	// Do not propagate this status to user. This could be because status is only informational
	STATUS_DO_NOT_PUBLISH StatusPublishType = 0
	// Publish
	//
	// x-displayName: "Publish"
	// Propagate this status up to user as it might be actionable
	STATUS_PUBLISH StatusPublishType = 1
)

var StatusPublishType_name = map[int32]string{
	0: "STATUS_DO_NOT_PUBLISH",
	1: "STATUS_PUBLISH",
}

var StatusPublishType_value = map[string]int32{
	"STATUS_DO_NOT_PUBLISH": 0,
	"STATUS_PUBLISH":        1,
}

func (StatusPublishType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{6}
}

// SecretEncodingType
//
// x-displayName: "Secret Encoding"
// SecretEncodingType defines the encoding type of the secret before handled by the Secret Management Service.
type SecretEncodingType int32

const (
	// x-displayName: "None"
	// No Encoding
	EncodingNone SecretEncodingType = 0
	// Base64
	//
	// x-displayName: "Base64"
	// Base64 encoding
	EncodingBase64 SecretEncodingType = 1
)

var SecretEncodingType_name = map[int32]string{
	0: "EncodingNone",
	1: "EncodingBase64",
}

var SecretEncodingType_value = map[string]int32{
	"EncodingNone":   0,
	"EncodingBase64": 1,
}

func (SecretEncodingType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{7}
}

// URLSchemeType
//
// x-displayName: "URL Scheme"
// SchemeType is used to indicate URL scheme
type URLSchemeType int32

const (
	// x-displayName: "HTTP"
	// http:// scheme
	HTTP URLSchemeType = 0
	// x-displayName: "HTTPS"
	// https:// scheme
	HTTPS URLSchemeType = 1
)

var URLSchemeType_name = map[int32]string{
	0: "HTTP",
	1: "HTTPS",
}

var URLSchemeType_value = map[string]int32{
	"HTTP":  0,
	"HTTPS": 1,
}

func (URLSchemeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{8}
}

// TlsProtocol
//
// x-displayName: "TLS Protocol"
// TlsProtocol is enumeration of supported TLS versions
type TlsProtocol int32

const (
	// x-displayName: "Automatic"
	// F5 Distributed Cloud will choose the optimal TLS version.
	TLS_AUTO TlsProtocol = 0
	// x-displayName: "TLSv1.0"
	TLSv1_0 TlsProtocol = 1
	// x-displayName: "TLSv1.1"
	TLSv1_1 TlsProtocol = 2
	// x-displayName: "TLSv1.2"
	TLSv1_2 TlsProtocol = 3
	// x-displayName: "TLSv1.3"
	TLSv1_3 TlsProtocol = 4
)

var TlsProtocol_name = map[int32]string{
	0: "TLS_AUTO",
	1: "TLSv1_0",
	2: "TLSv1_1",
	3: "TLSv1_2",
	4: "TLSv1_3",
}

var TlsProtocol_value = map[string]int32{
	"TLS_AUTO": 0,
	"TLSv1_0":  1,
	"TLSv1_1":  2,
	"TLSv1_2":  3,
	"TLSv1_3":  4,
}

func (TlsProtocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{9}
}

// XfccElement
//
// x-displayName: "XFCC Elements"
// X-Forwarded-Client-Cert custom cookie elements
type XfccElement int32

const (
	// x-displayName: "None"
	XFCC_NONE XfccElement = 0
	// x-displayName: "Cert"
	// The entire client certificate in URL encoded PEM format.
	XFCC_CERT XfccElement = 1
	// x-displayName: "Chain"
	// The entire client certificate chain (including the leaf certificate) in URL encoded PEM format.
	XFCC_CHAIN XfccElement = 2
	// x-displayName: "Subject"
	// The Subject field of the current client certificate. The value is always double-quoted.
	XFCC_SUBJECT XfccElement = 3
	// x-displayName: "URI"
	// The URI type Subject Alternative Name field of the current client certificate.
	// A client certificate may contain multiple URI type Subject Alternative Names,
	// each will be a separate key-value pair.
	XFCC_URI XfccElement = 4
	// x-displayName: "DNS"
	// The DNS type Subject Alternative Name field of the current client certificate.
	// A client certificate may contain multiple DNS type Subject Alternative Names,
	// each will be a separate key-value pair.
	XFCC_DNS XfccElement = 5
)

var XfccElement_name = map[int32]string{
	0: "XFCC_NONE",
	1: "XFCC_CERT",
	2: "XFCC_CHAIN",
	3: "XFCC_SUBJECT",
	4: "XFCC_URI",
	5: "XFCC_DNS",
}

var XfccElement_value = map[string]int32{
	"XFCC_NONE":    0,
	"XFCC_CERT":    1,
	"XFCC_CHAIN":   2,
	"XFCC_SUBJECT": 3,
	"XFCC_URI":     4,
	"XFCC_DNS":     5,
}

func (XfccElement) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{10}
}

// HashAlgoritm
//
// x-displayName: "Hash Algorithm"
// Specifies the Hash Algorithm to be used
type HashAlgorithm int32

const (
	// x-displayName: "INVALID"
	// Invalid hash algorithm
	INVALID_HASH_ALGORITHM HashAlgorithm = 0
	// x-displayName: "SHA256"
	// sha256 hash algorithm
	SHA256 HashAlgorithm = 1
	// x-displayName: "SHA1"
	// sha1 hash algorithm
	SHA1 HashAlgorithm = 2
)

var HashAlgorithm_name = map[int32]string{
	0: "INVALID_HASH_ALGORITHM",
	1: "SHA256",
	2: "SHA1",
}

var HashAlgorithm_value = map[string]int32{
	"INVALID_HASH_ALGORITHM": 0,
	"SHA256":                 1,
	"SHA1":                   2,
}

func (HashAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{11}
}

// RoutingPriority
//
// x-displayName: "Routing Priority"
// Priority routing for each request.
// Different connection pools are used based on the priority selected for the request.
// Also, circuit-breaker configuration at destination cluster is chosen based on selected priority.
type RoutingPriority int32

const (
	// x-displayName: "Default"
	// Default routing mechanism
	DEFAULT RoutingPriority = 0
	// x-displayName: "High-Priority"
	// High-Priority routing mechanism
	HIGH RoutingPriority = 1
)

var RoutingPriority_name = map[int32]string{
	0: "DEFAULT",
	1: "HIGH",
}

var RoutingPriority_value = map[string]int32{
	"DEFAULT": 0,
	"HIGH":    1,
}

func (RoutingPriority) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{12}
}

// DenominatorType
//
// x-displayName: "Denominator"
// Denominator used in fraction where sampling percentages are needed. example sampled requests
type DenominatorType int32

const (
	// x-displayName: "100"
	// Use hundred as denominator
	HUNDRED DenominatorType = 0
	// x-displayName: "10000"
	// Use ten thousand as denominator
	TEN_THOUSAND DenominatorType = 1
	// x-displayName: "1000000"
	// Use million as denominator
	MILLION DenominatorType = 2
)

var DenominatorType_name = map[int32]string{
	0: "HUNDRED",
	1: "TEN_THOUSAND",
	2: "MILLION",
}

var DenominatorType_value = map[string]int32{
	"HUNDRED":      0,
	"TEN_THOUSAND": 1,
	"MILLION":      2,
}

func (DenominatorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{13}
}

// DiscoveryType
//
// x-displayName: "Discovery Type"
// Specifies whether the discovery is from Kubernetes or Consul cluster
type DiscoveryType int32

const (
	// x-displayName: "INVALID"
	// Invalid Discovery mechanism
	INVALID_DISCOVERY DiscoveryType = 0
	// x-displayName: "Kubernetes"
	// Discover from Kubernetes cluster
	K8S DiscoveryType = 1
	// x-displayName: "HashiCorp Consul"
	// Discover from Consul service
	CONSUL DiscoveryType = 2
)

var DiscoveryType_name = map[int32]string{
	0: "INVALID_DISCOVERY",
	1: "K8S",
	2: "CONSUL",
}

var DiscoveryType_value = map[string]int32{
	"INVALID_DISCOVERY": 0,
	"K8S":               1,
	"CONSUL":            2,
}

func (DiscoveryType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{14}
}

// VipVrrpType
//
// x-displayName: "VRRP Virtual-IP"
// VRRP advertisement mode for VIP
type VipVrrpType int32

const (
	// x-displayName: "INVALID"
	// Invalid VRRP mode
	VIP_VRRP_INVALID VipVrrpType = 0
	// x-displayName: "Enable VRRP for VIP(s)"
	// VRRP advertisement enabled for virtual-ip
	VIP_VRRP_ENABLE VipVrrpType = 1
	// x-displayName: "Disable VRRP for VIP(s)"
	// VRRP advertisement disabled for virtual-ip
	VIP_VRRP_DISABLE VipVrrpType = 2
)

var VipVrrpType_name = map[int32]string{
	0: "VIP_VRRP_INVALID",
	1: "VIP_VRRP_ENABLE",
	2: "VIP_VRRP_DISABLE",
}

var VipVrrpType_value = map[string]int32{
	"VIP_VRRP_INVALID": 0,
	"VIP_VRRP_ENABLE":  1,
	"VIP_VRRP_DISABLE": 2,
}

func (VipVrrpType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{15}
}

// Site to site tunnel type
//
// x-displayName: "Tunnel type"
// Tunnel encapsulation to be used between sites
type SiteToSiteTunnelType int32

const (
	// x-displayName: "IPSEC or SSL"
	// Site to site tunnel can operate in both ipsec and ssl
	// ipsec takes precedence over ssl
	SITE_TO_SITE_TUNNEL_IPSEC_OR_SSL SiteToSiteTunnelType = 0
	// x-displayName: "IPSEC"
	// Site to site tunnel is of type ipsec
	SITE_TO_SITE_TUNNEL_IPSEC SiteToSiteTunnelType = 1
	// x-displayName: "SSL"
	// Site to site tunnel is of type ssl
	SITE_TO_SITE_TUNNEL_SSL SiteToSiteTunnelType = 2
)

var SiteToSiteTunnelType_name = map[int32]string{
	0: "SITE_TO_SITE_TUNNEL_IPSEC_OR_SSL",
	1: "SITE_TO_SITE_TUNNEL_IPSEC",
	2: "SITE_TO_SITE_TUNNEL_SSL",
}

var SiteToSiteTunnelType_value = map[string]int32{
	"SITE_TO_SITE_TUNNEL_IPSEC_OR_SSL": 0,
	"SITE_TO_SITE_TUNNEL_IPSEC":        1,
	"SITE_TO_SITE_TUNNEL_SSL":          2,
}

func (SiteToSiteTunnelType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{16}
}

// SortOrder
//
// x-displayName: "Sort Order"
// Sort algorithm
type SortOrder int32

const (
	// x-displayName: "Descending Order"
	// Sort in descending order
	DESCENDING SortOrder = 0
	// x-displayName: "Ascending Order"
	// Sort in ascending order
	ASCENDING SortOrder = 1
)

var SortOrder_name = map[int32]string{
	0: "DESCENDING",
	1: "ASCENDING",
}

var SortOrder_value = map[string]int32{
	"DESCENDING": 0,
	"ASCENDING":  1,
}

func (SortOrder) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{17}
}

// TunnelEncapsulationType
//
// x-displayName: "Tunnel Encapsulation Type"
// Type of tunnel encapsulation
type TunnelEncapsulationType int32

const (
	// x-displayName: "IPSEC PKI"
	// IPSEC using public key infrastructure
	IPSEC_PKI TunnelEncapsulationType = 0
	// x-displayName: "IPSEC PSK"
	// IPSEC using pre shared key
	IPSEC_PSK TunnelEncapsulationType = 1
	// x-displayName: "SSL"
	// SSL encapsulation
	SSL TunnelEncapsulationType = 2
	// x-displayName: "GRE"
	// GRE encapsulation
	GRE TunnelEncapsulationType = 3
)

var TunnelEncapsulationType_name = map[int32]string{
	0: "IPSEC_PKI",
	1: "IPSEC_PSK",
	2: "SSL",
	3: "GRE",
}

var TunnelEncapsulationType_value = map[string]int32{
	"IPSEC_PKI": 0,
	"IPSEC_PSK": 1,
	"SSL":       2,
	"GRE":       3,
}

func (TunnelEncapsulationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{18}
}

// TenantType
//
// x-displayName: "Tenant type"
// TenantType is the type of the customer
type TenantType int32

const (
	// x-displayName: "Unknown"
	// UNKNOWN indicates the field not being set
	UNKNOWN TenantType = 0
	// x-displayName: "Freemium"
	// FREEMIUM are customer that don't have their domain
	FREEMIUM TenantType = 1
	// x-displayName: "Enterprise"
	// ENTERPRiISE customer have their domain
	ENTERPRISE TenantType = 2
)

var TenantType_name = map[int32]string{
	0: "UNKNOWN",
	1: "FREEMIUM",
	2: "ENTERPRISE",
}

var TenantType_value = map[string]int32{
	"UNKNOWN":    0,
	"FREEMIUM":   1,
	"ENTERPRISE": 2,
}

func (TenantType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{19}
}

// TaxExemptionType
//
// x-displayName: "Tax Exemption"
// TaxExemptionType holds possible tax exemption option.
type TaxExemptionType int32

const (
	// x-displayName: "Unknown"
	// UNKNOWN indicates the field not being set
	TAX_UNKNOWN TaxExemptionType = 0
	// x-displayName: "Regular"
	// TAX_REGULAR indicates customers that are required to pay taxes
	TAX_REGULAR TaxExemptionType = 1
	// x-displayName: "Unverified"
	// TAX_EXEMPT indicates customers exempt from paying taxes - their status needs to be verified once signup is completed.
	TAX_EXEMPT_UNVERIFIED TaxExemptionType = 2
	// x-displayName: "Verified"
	// TAX_EXEMPT indicates customers exempt from paying taxes - their status has been verified and the customer is not being taxed by us.
	TAX_EXEMPT_VERIFIED TaxExemptionType = 3
	// x-displayName: "Verification Failed"
	// TAX_EXEMPT_VERIFICATION_FAILED indicates customers that the tax exempt verification process failed - they can contact F5XC to get more details
	TAX_EXEMPT_VERIFICATION_FAILED TaxExemptionType = 4
	// x-displayName: "Verification Pending"
	// TAX_EXEMPT_VERIFICATION_PENDING indicates customers that the tax exempt verification process is ongoing
	TAX_EXEMPT_VERIFICATION_PENDING TaxExemptionType = 5
)

var TaxExemptionType_name = map[int32]string{
	0: "TAX_UNKNOWN",
	1: "TAX_REGULAR",
	2: "TAX_EXEMPT_UNVERIFIED",
	3: "TAX_EXEMPT_VERIFIED",
	4: "TAX_EXEMPT_VERIFICATION_FAILED",
	5: "TAX_EXEMPT_VERIFICATION_PENDING",
}

var TaxExemptionType_value = map[string]int32{
	"TAX_UNKNOWN":                     0,
	"TAX_REGULAR":                     1,
	"TAX_EXEMPT_UNVERIFIED":           2,
	"TAX_EXEMPT_VERIFIED":             3,
	"TAX_EXEMPT_VERIFICATION_FAILED":  4,
	"TAX_EXEMPT_VERIFICATION_PENDING": 5,
}

func (TaxExemptionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{20}
}

// PlanType
//
// x-displayName: "Plan Type"
// PlanType is the type of billing plan for the customer
type PlanType int32

const (
	// x-displayName: "Free"
	FREE PlanType = 0
	// x-displayName: "Individual"
	INDIVIDUAL PlanType = 1
	// x-displayName: "Team"
	TEAM PlanType = 2
	// x-displayName: "Organization"
	ORGANIZATION PlanType = 3
	// x-displayName: "Unspecified"
	PLAN_TYPE_UNSPECIFIED PlanType = 4
)

var PlanType_name = map[int32]string{
	0: "FREE",
	1: "INDIVIDUAL",
	2: "TEAM",
	3: "ORGANIZATION",
	4: "PLAN_TYPE_UNSPECIFIED",
}

var PlanType_value = map[string]int32{
	"FREE":                  0,
	"INDIVIDUAL":            1,
	"TEAM":                  2,
	"ORGANIZATION":          3,
	"PLAN_TYPE_UNSPECIFIED": 4,
}

func (PlanType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{21}
}

// Metric Label Operator
//
// x-displayName: "Metric Label Operator"
// The operator to use when filtering metrics based on label values.
type MetricLabelOp int32

const (
	// x-displayName: "Equal To"
	EQ MetricLabelOp = 0
	// x-displayName: "Not Equal To"
	NEQ MetricLabelOp = 1
)

var MetricLabelOp_name = map[int32]string{
	0: "EQ",
	1: "NEQ",
}

var MetricLabelOp_value = map[string]int32{
	"EQ":  0,
	"NEQ": 1,
}

func (MetricLabelOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{22}
}

// Trend Sentiment
//
// x-displayName: "Trend Sentiment"
// trend sentiment
type TrendSentiment int32

const (
	// x-displayName: "None"
	TREND_SENTIMENT_NONE TrendSentiment = 0
	// x-displayName: "Positive"
	// Indicates trend sentiment is positive
	TREND_SENTIMENT_POSITIVE TrendSentiment = 1
	// x-displayName: "Negative"
	// Indicates trend sentiment is negative.
	TREND_SENTIMENT_NEGATIVE TrendSentiment = 2
)

var TrendSentiment_name = map[int32]string{
	0: "TREND_SENTIMENT_NONE",
	1: "TREND_SENTIMENT_POSITIVE",
	2: "TREND_SENTIMENT_NEGATIVE",
}

var TrendSentiment_value = map[string]int32{
	"TREND_SENTIMENT_NONE":     0,
	"TREND_SENTIMENT_POSITIVE": 1,
	"TREND_SENTIMENT_NEGATIVE": 2,
}

func (TrendSentiment) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{23}
}

// Route Attribute
//
// x-displayName: "Route Attribute"
// Defines attributes associated with route
type RouteAttrType int32

const (
	// x-displayName: "None"
	// Ignore attribute
	ROUTE_ATTR_NO_OP RouteAttrType = 0
	// x-displayName: "Advertise"
	// Advertise route in all supported routing protocols
	ROUTE_ATTR_ADVERTISE RouteAttrType = 1
	// x-displayName: "Install Host OS"
	// Add route into host OS - route in host OS will point to interface corresponding to the
	// virtual network. Host OS must have an interface in the virtual network.
	ROUTE_ATTR_INSTALL_HOST RouteAttrType = 2
	// x-displayName: "Install Forwarding"
	// Use the route for forwarding decision - adds route into data plane
	// modules with configured next-hop
	ROUTE_ATTR_INSTALL_FORWARDING RouteAttrType = 3
	// x-displayName: "Merge Route"
	// Merge Route if they already exist
	ROUTE_ATTR_MERGE_ONLY RouteAttrType = 4
)

var RouteAttrType_name = map[int32]string{
	0: "ROUTE_ATTR_NO_OP",
	1: "ROUTE_ATTR_ADVERTISE",
	2: "ROUTE_ATTR_INSTALL_HOST",
	3: "ROUTE_ATTR_INSTALL_FORWARDING",
	4: "ROUTE_ATTR_MERGE_ONLY",
}

var RouteAttrType_value = map[string]int32{
	"ROUTE_ATTR_NO_OP":              0,
	"ROUTE_ATTR_ADVERTISE":          1,
	"ROUTE_ATTR_INSTALL_HOST":       2,
	"ROUTE_ATTR_INSTALL_FORWARDING": 3,
	"ROUTE_ATTR_MERGE_ONLY":         4,
}

func (RouteAttrType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{24}
}

// Nexthop Types
//
// x-displayName: "Nexthop Types"
// Defines types of next-hop
type NextHopTypes int32

const (
	// x-displayName: "Default Gateway"
	// Use default gateway on the local interface as gateway for route.
	// Assumes there is only one local interface on the virtual network.
	NEXT_HOP_DEFAULT_GATEWAY NextHopTypes = 0
	// x-displayName: "User Configured"
	// Use the specified address as nexthop
	NEXT_HOP_USE_CONFIGURED NextHopTypes = 1
	// x-displayName: "Network Interface"
	// Use the network interface as nexthop
	NEXT_HOP_NETWORK_INTERFACE NextHopTypes = 2
	// x-displayName: "Discard"
	// Discard nexthop, used when attr type is Advertise
	NEXT_HOP_DISCARD NextHopTypes = 3
	// x-displayName: "SNAT to Public"
	// Used in VoltADN private virtual network.
	NEXT_HOP_SNAT_TO_PUBLIC NextHopTypes = 4
)

var NextHopTypes_name = map[int32]string{
	0: "NEXT_HOP_DEFAULT_GATEWAY",
	1: "NEXT_HOP_USE_CONFIGURED",
	2: "NEXT_HOP_NETWORK_INTERFACE",
	3: "NEXT_HOP_DISCARD",
	4: "NEXT_HOP_SNAT_TO_PUBLIC",
}

var NextHopTypes_value = map[string]int32{
	"NEXT_HOP_DEFAULT_GATEWAY":   0,
	"NEXT_HOP_USE_CONFIGURED":    1,
	"NEXT_HOP_NETWORK_INTERFACE": 2,
	"NEXT_HOP_DISCARD":           3,
	"NEXT_HOP_SNAT_TO_PUBLIC":    4,
}

func (NextHopTypes) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{25}
}

// AddonServiceState
//
// x-displayName: "Addon Service State"
// State of a service
type AddonServiceState int32

const (
	// x-displayName: "None"
	// default state
	AS_NONE AddonServiceState = 0
	// x-displayName: "Pending Subscription"
	// initiated subscription request and is pending to activate (requested).
	AS_PENDING AddonServiceState = 1
	// x-displayName: "Subscribed"
	// successfully subscribed
	AS_SUBSCRIBED AddonServiceState = 2
	// x-displayName: "Error"
	// service subscription request ended up in error state.
	AS_ERROR AddonServiceState = 3
)

var AddonServiceState_name = map[int32]string{
	0: "AS_NONE",
	1: "AS_PENDING",
	2: "AS_SUBSCRIBED",
	3: "AS_ERROR",
}

var AddonServiceState_value = map[string]int32{
	"AS_NONE":       0,
	"AS_PENDING":    1,
	"AS_SUBSCRIBED": 2,
	"AS_ERROR":      3,
}

func (AddonServiceState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{26}
}

// AddonServiceCheckSubscribe
//
// x-displayName: "Addon Service Subscription Check"
// subscription is allowed or not
type AddonServiceCheckSubscribe int32

const (
	// x-displayName: "None"
	// Default check value. Check response details for more info.
	AS_SUB_NONE AddonServiceCheckSubscribe = 0
	// x-displayName: "Allowed"
	// Subscription Allowed
	AS_SUB_ALLOWED AddonServiceCheckSubscribe = 1
	// x-displayName: "Denied"
	// Subscription denied
	AS_SUB_DENIED AddonServiceCheckSubscribe = 2
	// x-displayName: "Dependency Denied"
	// Required dependent addon service missing
	AS_SUB_DEP_DENIED AddonServiceCheckSubscribe = 3
	// x-displayName: "Subscription Exist"
	// Already subscribed to addon service and a subscription exist.
	AS_SUB_EXIST AddonServiceCheckSubscribe = 4
)

var AddonServiceCheckSubscribe_name = map[int32]string{
	0: "AS_SUB_NONE",
	1: "AS_SUB_ALLOWED",
	2: "AS_SUB_DENIED",
	3: "AS_SUB_DEP_DENIED",
	4: "AS_SUB_EXIST",
}

var AddonServiceCheckSubscribe_value = map[string]int32{
	"AS_SUB_NONE":       0,
	"AS_SUB_ALLOWED":    1,
	"AS_SUB_DENIED":     2,
	"AS_SUB_DEP_DENIED": 3,
	"AS_SUB_EXIST":      4,
}

func (AddonServiceCheckSubscribe) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{27}
}

// AddonServiceCheckSubscribe
//
// x-displayName: "Addon Service Subscription Check"
// subscription is allowed or not
type AddonServiceSubscribeAction int32

const (
	// x-displayName: "Subscribe"
	// Subscribe to addon service.
	// This will set service state as AS_SUBSCRIBED
	AS_SUBSCRIBE AddonServiceSubscribeAction = 0
	// x-displayName: "Unsubscribe"
	// Remove addon service subscription.
	// if successful, the state goes back to AS_NONE
	AS_UNSUBSCRIBE AddonServiceSubscribeAction = 1
	// x-displayName: "Subscription Pending"
	// Service responsible for addon service is processing the subscribe request.
	AS_SUBSCRIBE_PENDING AddonServiceSubscribeAction = 2
	// x-displayName: "Cancel Pending Subscription"
	// Service responsible for addon service can use this action to cancel pending request.
	// if successful, the state goes back to AS_NONE
	AS_CANCEL_SUBSCRIBE_PENDING AddonServiceSubscribeAction = 3
)

var AddonServiceSubscribeAction_name = map[int32]string{
	0: "AS_SUBSCRIBE",
	1: "AS_UNSUBSCRIBE",
	2: "AS_SUBSCRIBE_PENDING",
	3: "AS_CANCEL_SUBSCRIBE_PENDING",
}

var AddonServiceSubscribeAction_value = map[string]int32{
	"AS_SUBSCRIBE":                0,
	"AS_UNSUBSCRIBE":              1,
	"AS_SUBSCRIBE_PENDING":        2,
	"AS_CANCEL_SUBSCRIBE_PENDING": 3,
}

func (AddonServiceSubscribeAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{28}
}

// AddonServiceAccess
//
// x-displayName: "Addon Service Access"
// State of access into service
type AddonServiceAccess int32

const (
	// x-displayName: "None"
	// default state
	// This can mean that addon service is not subscribed or is in pending subscription.
	AS_AC_NONE AddonServiceAccess = 0
	// x-displayName: "Allow"
	// access is allowed
	AS_AC_ALLOWED AddonServiceAccess = 1
	// x-displayName: "PBAC Deny"
	// Plan based access control denied. This means current plan doesnt allow this addon service.
	// When the user clicks on such addon, he will be shown billing plan upgrade page
	AS_AC_PBAC_DENY AddonServiceAccess = 2
	// x-displayName: "PBAC Deny - Upgrade plan"
	// Plan based access control denied. This means current plan doesnt allow this addon service.
	// When the user clicks on such addon, he will be shown billing plan upgrade page
	AS_AC_PBAC_DENY_UPGRADE_PLAN AddonServiceAccess = 3
	// x-displayName: "PBAC Deny - Request service"
	// Plan based access control denied. This means current plan doesnt allow this addon service.
	// When the user clicks on such addon, he will be shown request service button which creates a support ticket requesting enablement of the addon.
	// Since the addon is not part of the plan, the customer would be advised accordingly by the support team depending on his current plan
	AS_AC_PBAC_DENY_REQUEST_SERVICE AddonServiceAccess = 4
)

var AddonServiceAccess_name = map[int32]string{
	0: "AS_AC_NONE",
	1: "AS_AC_ALLOWED",
	2: "AS_AC_PBAC_DENY",
	3: "AS_AC_PBAC_DENY_UPGRADE_PLAN",
	4: "AS_AC_PBAC_DENY_REQUEST_SERVICE",
}

var AddonServiceAccess_value = map[string]int32{
	"AS_AC_NONE":                      0,
	"AS_AC_ALLOWED":                   1,
	"AS_AC_PBAC_DENY":                 2,
	"AS_AC_PBAC_DENY_UPGRADE_PLAN":    3,
	"AS_AC_PBAC_DENY_REQUEST_SERVICE": 4,
}

func (AddonServiceAccess) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{29}
}

// TileAccessState
//
// x-displayName: "Tile Access State"
// State of access to Primary navigation tile.
type TileAccessState int32

const (
	// x-displayName: "None"
	// default state
	TILE_AC_NONE TileAccessState = 0
	// x-displayName: "Allowed"
	// access is allowed
	TILE_AC_ALLOWED TileAccessState = 1
	// x-displayName: "Upgrade Plan"
	// Require plan upgrade.
	TILE_AC_UPGRADE_PLAN TileAccessState = 2
	// x-displayName: "Not Subscribed"
	// Required Addon Service is not subscribed.
	TILE_AC_NOT_SUBSCRIBED TileAccessState = 3
)

var TileAccessState_name = map[int32]string{
	0: "TILE_AC_NONE",
	1: "TILE_AC_ALLOWED",
	2: "TILE_AC_UPGRADE_PLAN",
	3: "TILE_AC_NOT_SUBSCRIBED",
}

var TileAccessState_value = map[string]int32{
	"TILE_AC_NONE":           0,
	"TILE_AC_ALLOWED":        1,
	"TILE_AC_UPGRADE_PLAN":   2,
	"TILE_AC_NOT_SUBSCRIBED": 3,
}

func (TileAccessState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{30}
}

// Sync Mode
//
// x-displayName: "Sync Mode"
// Sync mode is to specify where the user details are being synced from.
type SyncMode int32

const (
	// Self
	// x-displayName: "Self"
	// System managed user.
	SELF SyncMode = 0
	// SCIM
	// x-displayName: "SCIM"
	// SCIM synced user. Full user life cycle is managed by the SCIM provider.
	SCIM SyncMode = 10
)

var SyncMode_name = map[int32]string{
	0:  "SELF",
	10: "SCIM",
}

var SyncMode_value = map[string]int32{
	"SELF": 0,
	"SCIM": 10,
}

func (SyncMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{31}
}

// JavaScript Mode
//
// x-displayName: "Web Client JavaScript Mode"
// Web Client JavaScript Mode.
type JavaScriptMode int32

const (
	// x-displayName: "Async JS with no Caching"
	// Bot Defense JavaScript for telemetry collection is requested asynchronously, and it is non-cacheable
	ASYNC_JS_NO_CACHING JavaScriptMode = 0
	// x-displayName: "Async JS with Caching"
	// Bot Defense JavaScript for telemetry collection is requested asynchronously, and it is cacheable
	ASYNC_JS_CACHING JavaScriptMode = 1
	// x-displayName: "Sync JS with no Caching"
	// Bot Defense JavaScript for telemetry collection is requested synchronously, and it is non-cacheable
	SYNC_JS_NO_CACHING JavaScriptMode = 2
	// x-displayName: "Sync JS with Caching"
	// Bot Defense JavaScript for telemetry collection is requested synchronously, and it is cacheable
	SYNC_JS_CACHING JavaScriptMode = 3
)

var JavaScriptMode_name = map[int32]string{
	0: "ASYNC_JS_NO_CACHING",
	1: "ASYNC_JS_CACHING",
	2: "SYNC_JS_NO_CACHING",
	3: "SYNC_JS_CACHING",
}

var JavaScriptMode_value = map[string]int32{
	"ASYNC_JS_NO_CACHING": 0,
	"ASYNC_JS_CACHING":    1,
	"SYNC_JS_NO_CACHING":  2,
	"SYNC_JS_CACHING":     3,
}

func (JavaScriptMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{32}
}

// FeatureTag
//
// x-displayName: "Feature Tag"
// FeatureTag is for identifying the tag of feature of an offering (new, preview)
type FeatureTag int32

const (
	// x-displayName: "Unknown"
	// Unknown (undefined) feature tag
	NONE FeatureTag = 0
	// x-displayName: "New"
	// New feature tag
	NEW FeatureTag = 1
	// x-displayName: "Preview"
	// Preview feature tag
	PREVIEW FeatureTag = 2
	// x-displayName: "Private Preview"
	// Private preview feature tag
	PRIVATE_PREVIEW FeatureTag = 3
)

var FeatureTag_name = map[int32]string{
	0: "NONE",
	1: "NEW",
	2: "PREVIEW",
	3: "PRIVATE_PREVIEW",
}

var FeatureTag_value = map[string]int32{
	"NONE":            0,
	"NEW":             1,
	"PREVIEW":         2,
	"PRIVATE_PREVIEW": 3,
}

func (FeatureTag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{33}
}

// AddonServiceTierType
//
// x-displayName: "Addon Service Tier"
// AddonServiceTierType is for identifying the tier of an addon service
type AddonServiceTierType int32

const (
	// none
	//
	// x-displayName: "none"
	// when tier is not applicable for a addon service
	NO_TIER AddonServiceTierType = 0
	// basic
	//
	// x-displayName: "basic"
	// basic
	BASIC AddonServiceTierType = 1
	// standard
	//
	// x-displayName: "standard"
	// standard
	STANDARD AddonServiceTierType = 2
	// advanced
	//
	// x-displayName: "advanced"
	// advanced
	ADVANCED AddonServiceTierType = 3
	// premium
	//
	// x-displayName: "premium"
	// premium
	PREMIUM AddonServiceTierType = 4
)

var AddonServiceTierType_name = map[int32]string{
	0: "NO_TIER",
	1: "BASIC",
	2: "STANDARD",
	3: "ADVANCED",
	4: "PREMIUM",
}

var AddonServiceTierType_value = map[string]int32{
	"NO_TIER":  0,
	"BASIC":    1,
	"STANDARD": 2,
	"ADVANCED": 3,
	"PREMIUM":  4,
}

func (AddonServiceTierType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{34}
}

// CloudLink State
//
// x-displayName: "CloudLink State"
// State of the CloudLink connections
type CloudLinkState int32

const (
	// Up
	//
	// x-displayName: "Up"
	// CloudLink and their corresponding Direct Connect connections are up and healthy
	UP CloudLinkState = 0
	// Down
	//
	// x-displayName: "Down"
	// CloudLink and their corresponding Direct Connect connections are down
	DOWN CloudLinkState = 1
	// Degraded
	//
	// x-displayName: "Degraded"
	// Some of Direct Connect connections with the CloudLink are down
	DEGRADED CloudLinkState = 2
)

var CloudLinkState_name = map[int32]string{
	0: "UP",
	1: "DOWN",
	2: "DEGRADED",
}

var CloudLinkState_value = map[string]int32{
	"UP":       0,
	"DOWN":     1,
	"DEGRADED": 2,
}

func (CloudLinkState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{35}
}

// SignupOrigin
//
// x-displayName: "Signup Origin"
// x-required
// SignupOrigin indicates, from which platform signup is originated, example f5xc, aws..etc
type SignupOrigin int32

const (
	// ORIGIN_UNKNOWN
	//
	// x-displayName: "Unknown"
	// Indicates, the origin of the signup is unknown
	ORIGIN_UNKNOWN SignupOrigin = 0
	// ORIGIN_F5XC
	//
	// x-displayName: "F5XC"
	// ORIGIN_F5XC as an origin indicates, signup is initiated from console or by internal scaling/testing/support teams using private API
	ORIGIN_F5XC SignupOrigin = 1
	// ORIGIN_AWS
	//
	// x-displayName: "AWS"
	// ORIGIN_AWS as an origin indicates, signup is initiated from AWS marketplace & it comes to eywaprime via tsahik
	ORIGIN_AWS SignupOrigin = 2
)

var SignupOrigin_name = map[int32]string{
	0: "ORIGIN_UNKNOWN",
	1: "ORIGIN_F5XC",
	2: "ORIGIN_AWS",
}

var SignupOrigin_value = map[string]int32{
	"ORIGIN_UNKNOWN": 0,
	"ORIGIN_F5XC":    1,
	"ORIGIN_AWS":     2,
}

func (SignupOrigin) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{36}
}

// Empty
//
// x-displayName: "Empty"
// This can be used for messages where no values are needed
type Empty struct {
}

func (m *Empty) Reset()      { *m = Empty{} }
func (*Empty) ProtoMessage() {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{0}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

// ObjectRefType
//
// x-displayName: "Object reference"
// This type establishes a 'direct reference' from one object(the referrer) to another(the referred).
// Such a reference is in form of tenant/namespace/name for public API and Uid for private API
// This type of reference is called direct because the relation is explicit and concrete (as opposed
// to selector reference which builds a group based on labels of selectee objects)
type ObjectRefType struct {
	// kind
	//
	// x-displayName: "Kind"
	// x-example: "virtual_site"
	// When a configuration object(e.g. virtual_host) refers to another(e.g route)
	// then kind will hold the referred object's kind (e.g. "route")
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// uid
	//
	// x-displayName: "UID"
	// x-example: "d15f1fad-4d37-48c0-8706-df1824d76d31"
	// When a configuration object(e.g. virtual_host) refers to another(e.g route)
	// then uid will hold the referred object's(e.g. route's) uid.
	Uid string `protobuf:"bytes,2,opt,name=uid,proto3" json:"uid,omitempty"`
	// tenant
	//
	// x-displayName: "Tenant"
	// x-example: "acmecorp"
	// When a configuration object(e.g. virtual_host) refers to another(e.g route)
	// then tenant will hold the referred object's(e.g. route's) tenant.
	Tenant string `protobuf:"bytes,3,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "ns1"
	// When a configuration object(e.g. virtual_host) refers to another(e.g route)
	// then namespace will hold the referred object's(e.g. route's) namespace.
	Namespace string `protobuf:"bytes,4,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// name
	//
	// x-displayName: "Name"
	// x-example: "contactus-route"
	// When a configuration object(e.g. virtual_host) refers to another(e.g route)
	// then name will hold the referred object's(e.g. route's) name.
	Name string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ObjectRefType) Reset()      { *m = ObjectRefType{} }
func (*ObjectRefType) ProtoMessage() {}
func (*ObjectRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{1}
}
func (m *ObjectRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ObjectRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectRefType.Merge(m, src)
}
func (m *ObjectRefType) XXX_Size() int {
	return m.Size()
}
func (m *ObjectRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectRefType.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectRefType proto.InternalMessageInfo

func (m *ObjectRefType) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *ObjectRefType) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *ObjectRefType) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *ObjectRefType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ObjectRefType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// LabelSelectorType
//
// x-displayName: "Label Selector"
// This type can be used to establish a 'selector reference' from one object(called selector) to
// a set of other objects(called selectees) based on the value of expresssions.
// A label selector is a label query over a set of resources. An empty label selector matches all objects.
// A null label selector matches no objects. Label selector is immutable.
// expressions is a list of strings of label selection expression.
// Each string has "," separated values which are "AND" and all strings are logically "OR".
// BNF for expression string
// <selector-syntax>         ::= <requirement> | <requirement> "," <selector-syntax>
// <requirement>             ::= [!] KEY [ <set-based-restriction> | <exact-match-restriction> ]
// <set-based-restriction>   ::= "" | <inclusion-exclusion> <value-set>
// <inclusion-exclusion>     ::= <inclusion> | <exclusion>
// <exclusion>               ::= "notin"
// <inclusion>               ::= "in"
// <value-set>               ::= "(" <values> ")"
// <values>                  ::= VALUE | VALUE "," <values>
// <exact-match-restriction> ::= ["="|"=="|"!="] VALUE
type LabelSelectorType struct {
	// expressions
	//
	// x-displayName: "Selector Expression"
	// x-required
	// x-example: "region in (us-west1, us-west2),tier in (staging)"
	// expressions contains the kubernetes style label expression for selections.
	Expressions []string `protobuf:"bytes,1,rep,name=expressions,proto3" json:"expressions,omitempty"`
}

func (m *LabelSelectorType) Reset()      { *m = LabelSelectorType{} }
func (*LabelSelectorType) ProtoMessage() {}
func (*LabelSelectorType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{2}
}
func (m *LabelSelectorType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabelSelectorType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LabelSelectorType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabelSelectorType.Merge(m, src)
}
func (m *LabelSelectorType) XXX_Size() int {
	return m.Size()
}
func (m *LabelSelectorType) XXX_DiscardUnknown() {
	xxx_messageInfo_LabelSelectorType.DiscardUnknown(m)
}

var xxx_messageInfo_LabelSelectorType proto.InternalMessageInfo

func (m *LabelSelectorType) GetExpressions() []string {
	if m != nil {
		return m.Expressions
	}
	return nil
}

// LabelMatcherType
//
// x-displayName: "Label Matcher"
// A label matcher specifies a list of label keys whose values need to match for
// source/client and destination/server. Note that the actual label values are not
// specified and do not matter. This allows an ability to scope grouping by the
// label key name.
type LabelMatcherType struct {
	// keys
	//
	// x-displayName: "Keys"
	// x-example: "['environment', 'location', 'deployment']"
	// The list of label key names that have to match
	Keys []string `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
}

func (m *LabelMatcherType) Reset()      { *m = LabelMatcherType{} }
func (*LabelMatcherType) ProtoMessage() {}
func (*LabelMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{3}
}
func (m *LabelMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabelMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LabelMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabelMatcherType.Merge(m, src)
}
func (m *LabelMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *LabelMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_LabelMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_LabelMatcherType proto.InternalMessageInfo

func (m *LabelMatcherType) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

// ConditionType
//
// x-displayName: "Status Condition"
// Conditions are used in the object status to describe the current state of the
// object, e.g. Ready, Succeeded, etc.
type ConditionType struct {
	// type
	//
	// x-displayName: "Type"
	// x-example: "Operational"
	// Type of the condition
	// "Validation" represents validation user given configuration object
	// "Operational" represents operational status of a given configuration object
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// status
	//
	// x-displayName: "Status"
	// x-example: "Failed"
	// Status of the condition
	// "Success" Validtion has succeded. Requested operation was successful.
	// "Failed"  Validation has failed.
	// "Incomplete" Validation of configuration has failed due to missing configuration.
	// "Installed" Validation has passed and configuration has been installed in data path or K8s
	// "Down" Configuration is operationally down. e.g. down interface
	// "Disabled" Configuration is administratively disabled i.e. ObjectMetaType.Disable = true.
	// "NotApplicable" Configuration is not applicable e.g. tenant service_policy_set(s) in system namespace are not applicable on REs
	Status string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	// reason
	//
	// x-displayName: "Reason"
	// x-example: "value"
	// x-reason: "Insufficient memory in data plane"
	// A human readable string explaining the reason for reaching this condition
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	// last_update_time
	//
	// x-displayName: "Last Updated"
	// Last time the condition was updated
	LastUpdateTime *types.Timestamp `protobuf:"bytes,5,opt,name=last_update_time,json=lastUpdateTime,proto3" json:"last_update_time,omitempty"`
	// hostname
	//
	// x-displayName: "Hostname"
	// Hostname of the instance of the site that sent the status
	Hostname string `protobuf:"bytes,6,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// service name
	//
	// x-displayName: "Service Name"
	// Name of the service that sent the status
	ServiceName string `protobuf:"bytes,7,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
}

func (m *ConditionType) Reset()      { *m = ConditionType{} }
func (*ConditionType) ProtoMessage() {}
func (*ConditionType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{4}
}
func (m *ConditionType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConditionType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConditionType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConditionType.Merge(m, src)
}
func (m *ConditionType) XXX_Size() int {
	return m.Size()
}
func (m *ConditionType) XXX_DiscardUnknown() {
	xxx_messageInfo_ConditionType.DiscardUnknown(m)
}

var xxx_messageInfo_ConditionType proto.InternalMessageInfo

func (m *ConditionType) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ConditionType) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ConditionType) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *ConditionType) GetLastUpdateTime() *types.Timestamp {
	if m != nil {
		return m.LastUpdateTime
	}
	return nil
}

func (m *ConditionType) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *ConditionType) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

// StatusType
//
// x-displayName: "Status"
// Status is a return value for calls that don't return other objects.
type StatusType struct {
	// status
	//
	// x-displayName: "Status"
	// x-example: "value"
	// Status of the operation.
	// One of: "Success" or "Failure".
	Status string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// reason
	//
	// x-displayName: "Reason"
	// x-example: "value"
	// A human-readable description of why this operation is in the
	// "Failure" status. If this value is empty there
	// is no information available.
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	// code
	//
	// x-displayName: "Code"
	// x-example: "0"
	// Suggested HTTP return code for this status, 0 if not set.
	Code int32 `protobuf:"varint,4,opt,name=code,proto3" json:"code,omitempty"`
}

func (m *StatusType) Reset()      { *m = StatusType{} }
func (*StatusType) ProtoMessage() {}
func (*StatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{5}
}
func (m *StatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusType.Merge(m, src)
}
func (m *StatusType) XXX_Size() int {
	return m.Size()
}
func (m *StatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusType.DiscardUnknown(m)
}

var xxx_messageInfo_StatusType proto.InternalMessageInfo

func (m *StatusType) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *StatusType) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *StatusType) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

// InitializerType
//
// x-displayName: "Initializer"
// Initializer is information about an initializer that has not yet completed.
type InitializerType struct {
	// name
	//
	// x-displayName: "Name"
	// name of the service that is responsible for initializing this object.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *InitializerType) Reset()      { *m = InitializerType{} }
func (*InitializerType) ProtoMessage() {}
func (*InitializerType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{6}
}
func (m *InitializerType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InitializerType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InitializerType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitializerType.Merge(m, src)
}
func (m *InitializerType) XXX_Size() int {
	return m.Size()
}
func (m *InitializerType) XXX_DiscardUnknown() {
	xxx_messageInfo_InitializerType.DiscardUnknown(m)
}

var xxx_messageInfo_InitializerType proto.InternalMessageInfo

func (m *InitializerType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// InitializersType
//
// x-displayName: "Initializers"
// Initializers tracks the progress of initialization of a configuration object
type InitializersType struct {
	// pending
	//
	// x-displayName: "Pending"
	// Pending is a list of initializers that must execute in order before this object is initialized.
	// When the last pending initializer is removed, and no failing result is set, the initializers
	// struct will be set to nil and the object is considered as initialized and visible to all
	// clients.
	Pending []*InitializerType `protobuf:"bytes,1,rep,name=pending,proto3" json:"pending,omitempty"`
	// result
	//
	// x-displayName: "Result"
	// If result is set with the Failure field, the object will be persisted to storage and then deleted,
	// ensuring that other clients can observe the deletion.
	Result *StatusType `protobuf:"bytes,2,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *InitializersType) Reset()      { *m = InitializersType{} }
func (*InitializersType) ProtoMessage() {}
func (*InitializersType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{7}
}
func (m *InitializersType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InitializersType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InitializersType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitializersType.Merge(m, src)
}
func (m *InitializersType) XXX_Size() int {
	return m.Size()
}
func (m *InitializersType) XXX_DiscardUnknown() {
	xxx_messageInfo_InitializersType.DiscardUnknown(m)
}

var xxx_messageInfo_InitializersType proto.InternalMessageInfo

func (m *InitializersType) GetPending() []*InitializerType {
	if m != nil {
		return m.Pending
	}
	return nil
}

func (m *InitializersType) GetResult() *StatusType {
	if m != nil {
		return m.Result
	}
	return nil
}

// StatusMetaType
//
// x-displayName: "Metadata"
// StatusMetaType is metadata that all status must have.
type StatusMetaType struct {
	// uid
	//
	// x-displayName: "UID"
	// x-example: "d15f1fad-4d37-48c0-8706-df1824d76d31"
	// uid is the unique in time and space value for a StatusObject.
	Uid string `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// creator_class
	//
	// x-displayName: "Creator Class"
	// x-example: "ver.re1.int.ves.io"
	// Class of creator which created this StatusObject. This will be service's DNS FQDN.
	// This will be set by the system based on client certificate information.
	CreatorClass string `protobuf:"bytes,2,opt,name=creator_class,json=creatorClass,proto3" json:"creator_class,omitempty"`
	// creator_id
	//
	// x-displayName: "Creator ID"
	// x-example: "ver-instance-1"
	// ID of creator which created this StatusObject. This will be a concrete identifier for service (e.g.
	// identifying the environment also). This will be set by the system based on client certificate
	// information
	CreatorId string `protobuf:"bytes,3,opt,name=creator_id,json=creatorId,proto3" json:"creator_id,omitempty"`
	// status_id
	//
	// x-displayName: "Status ID"
	// status_id is a field used by the generator to distinguish (if necessary) between two status
	// objects for the same config object from the same site and same service and potentially same
	// daemon(creator-id)
	StatusId string `protobuf:"bytes,4,opt,name=status_id,json=statusId,proto3" json:"status_id,omitempty"`
	// creation_timestamp
	//
	// x-displayName: "Creation Timestamp"
	// creation_timestamp is when the status object was created. It is used to find/tie-break
	// for latest status object from same origin
	CreationTimestamp *types.Timestamp `protobuf:"bytes,5,opt,name=creation_timestamp,json=creationTimestamp,proto3" json:"creation_timestamp,omitempty"`
	// publish
	//
	// x-displayName: "Publish"
	// Decides wether this status object will be propagated to user.
	Publish StatusPublishType `protobuf:"varint,6,opt,name=publish,proto3,enum=ves.io.schema.StatusPublishType" json:"publish,omitempty"`
	// vtrp_id
	//
	// x-displayName: "VTRP ID"
	// Origin of this status exchanged by VTRP.
	VtrpId string `protobuf:"bytes,7,opt,name=vtrp_id,json=vtrpId,proto3" json:"vtrp_id,omitempty"`
	// vtrp_stale
	//
	// x-displayName: "VTRP Stale"
	// Indicate whether mars deems this object to be stale via graceful restart timer information
	VtrpStale bool `protobuf:"varint,8,opt,name=vtrp_stale,json=vtrpStale,proto3" json:"vtrp_stale,omitempty"`
}

func (m *StatusMetaType) Reset()      { *m = StatusMetaType{} }
func (*StatusMetaType) ProtoMessage() {}
func (*StatusMetaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{8}
}
func (m *StatusMetaType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusMetaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StatusMetaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusMetaType.Merge(m, src)
}
func (m *StatusMetaType) XXX_Size() int {
	return m.Size()
}
func (m *StatusMetaType) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusMetaType.DiscardUnknown(m)
}

var xxx_messageInfo_StatusMetaType proto.InternalMessageInfo

func (m *StatusMetaType) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *StatusMetaType) GetCreatorClass() string {
	if m != nil {
		return m.CreatorClass
	}
	return ""
}

func (m *StatusMetaType) GetCreatorId() string {
	if m != nil {
		return m.CreatorId
	}
	return ""
}

func (m *StatusMetaType) GetStatusId() string {
	if m != nil {
		return m.StatusId
	}
	return ""
}

func (m *StatusMetaType) GetCreationTimestamp() *types.Timestamp {
	if m != nil {
		return m.CreationTimestamp
	}
	return nil
}

func (m *StatusMetaType) GetPublish() StatusPublishType {
	if m != nil {
		return m.Publish
	}
	return STATUS_DO_NOT_PUBLISH
}

func (m *StatusMetaType) GetVtrpId() string {
	if m != nil {
		return m.VtrpId
	}
	return ""
}

func (m *StatusMetaType) GetVtrpStale() bool {
	if m != nil {
		return m.VtrpStale
	}
	return false
}

// ObjectMetaType
//
// x-displayName: "Metadata"
// ObjectMetaType is metadata(common attributes) of an object that all configuration objects will have.
// The information in this type can be specified by user during create and replace APIs.
type ObjectMetaType struct {
	// name
	//
	// x-displayName: "Name"
	// x-example: "acmecorp-web"
	// x-required
	// This is the name of configuration object. It has to be unique within the namespace.
	// It can only be specified during create API and cannot be changed during replace API.
	// The value of name has to follow DNS-1035 format.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "staging"
	// This defines the workspace within which each the configuration object is to be created.
	// Must be a DNS_LABEL format. For a namespace object itself, namespace value will be ""
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// uid
	//
	// x-displayName: "UID"
	// x-example: "d15f1fad-4d37-48c0-8706-df1824d76d31"
	// uid is the unique in time and space value for this object. Object create will fail if
	// provided by the client and the value exists in the system. Typically generated by the
	// server on successful creation of an object and is not allowed to change once populated.
	// Shadowed by SystemObjectMeta's uid field.
	Uid string `protobuf:"bytes,3,opt,name=uid,proto3" json:"uid,omitempty"`
	// labels
	//
	// x-displayName: "Labels"
	// x-example: "value"
	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects as chosen by the user. Values specified here will be used
	// by selector expression
	Labels map[string]string `protobuf:"bytes,4,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// annotations
	//
	// x-displayName: "Annotations"
	// x-example: "value"
	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	Annotations map[string]string `protobuf:"bytes,5,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// description
	//
	// x-displayName: "Description"
	// x-example: "Virtual Host for acmecorp website"
	// Human readable description for the object
	Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	// disable
	//
	// x-displayName: "Disable"
	// x-example: "true"
	// A value of true will administratively disable the object
	Disable bool `protobuf:"varint,7,opt,name=disable,proto3" json:"disable,omitempty"`
}

func (m *ObjectMetaType) Reset()      { *m = ObjectMetaType{} }
func (*ObjectMetaType) ProtoMessage() {}
func (*ObjectMetaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{9}
}
func (m *ObjectMetaType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectMetaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ObjectMetaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectMetaType.Merge(m, src)
}
func (m *ObjectMetaType) XXX_Size() int {
	return m.Size()
}
func (m *ObjectMetaType) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectMetaType.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectMetaType proto.InternalMessageInfo

func (m *ObjectMetaType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ObjectMetaType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ObjectMetaType) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *ObjectMetaType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ObjectMetaType) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ObjectMetaType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ObjectMetaType) GetDisable() bool {
	if m != nil {
		return m.Disable
	}
	return false
}

// ListMetaType
//
// x-displayName: "List Metadata"
// ListMetaType is metadata that all lists must have.
type ListMetaType struct {
	// resource_version
	//
	// x-displayName: "Resource Version"
	// x-example: "181255"
	// An opaque value that represents the revision of the store at the time the list API is
	// performed. It can be used in subsequent watch API to receive all changes after the list
	// API, or in a replace API to make the replace conditional on the object still being at
	// that revision
	ResourceVersion string `protobuf:"bytes,1,opt,name=resource_version,json=resourceVersion,proto3" json:"resource_version,omitempty"`
	// next_page
	//
	// x-displayName; "Next Page"
	// An opaque value that represents the next page that is supposed to be passed to the
	// next call to the list API when paging is enabled. If next_page is empty, then there
	// are no more pages to visit
	NextPage string `protobuf:"bytes,2,opt,name=next_page,json=nextPage,proto3" json:"next_page,omitempty"`
}

func (m *ListMetaType) Reset()      { *m = ListMetaType{} }
func (*ListMetaType) ProtoMessage() {}
func (*ListMetaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{10}
}
func (m *ListMetaType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListMetaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ListMetaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListMetaType.Merge(m, src)
}
func (m *ListMetaType) XXX_Size() int {
	return m.Size()
}
func (m *ListMetaType) XXX_DiscardUnknown() {
	xxx_messageInfo_ListMetaType.DiscardUnknown(m)
}

var xxx_messageInfo_ListMetaType proto.InternalMessageInfo

func (m *ListMetaType) GetResourceVersion() string {
	if m != nil {
		return m.ResourceVersion
	}
	return ""
}

func (m *ListMetaType) GetNextPage() string {
	if m != nil {
		return m.NextPage
	}
	return ""
}

// ObjectGetMetaType
//
// x-displayName: "Get Metadata"
// ObjectGetMetaType is metadata that can be specified in Get/Create response of an object.
type ObjectGetMetaType struct {
	// name
	//
	// x-displayName: "Name"
	// x-example: "acmecorp-web"
	// x-required
	// The configuration object will be created with name. It has to be unique within the namespace.
	// The value of name has to follow DNS-1035 format.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "staging"
	// This defines the workspace within which each the configuration object is to be created.
	// Must be a DNS_LABEL format. For a namespace object itself, namespace value will be ""
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// labels
	//
	// x-displayName: "Labels"
	// x-example: "value"
	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects as chosen by the user. Values specified here will be used
	// by selector expression
	Labels map[string]string `protobuf:"bytes,4,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// annotations
	//
	// x-displayName: "Annotation"
	// x-example: "value"
	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	Annotations map[string]string `protobuf:"bytes,5,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// description
	//
	// x-displayName: "Description"
	// x-example: "Virtual Host for acmecorp website"
	// Human readable description for the object
	Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	// disable
	//
	// x-displayName: "Disable"
	// x-example: "true"
	// A value of true will administratively disable the object
	Disable bool `protobuf:"varint,7,opt,name=disable,proto3" json:"disable,omitempty"`
}

func (m *ObjectGetMetaType) Reset()      { *m = ObjectGetMetaType{} }
func (*ObjectGetMetaType) ProtoMessage() {}
func (*ObjectGetMetaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{11}
}
func (m *ObjectGetMetaType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectGetMetaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ObjectGetMetaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectGetMetaType.Merge(m, src)
}
func (m *ObjectGetMetaType) XXX_Size() int {
	return m.Size()
}
func (m *ObjectGetMetaType) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectGetMetaType.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectGetMetaType proto.InternalMessageInfo

func (m *ObjectGetMetaType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ObjectGetMetaType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ObjectGetMetaType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ObjectGetMetaType) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ObjectGetMetaType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ObjectGetMetaType) GetDisable() bool {
	if m != nil {
		return m.Disable
	}
	return false
}

// ObjectCreateMetaType
//
// x-displayName: "Create Metadata"
// ObjectCreateMetaType is metadata that can be specified in Create request of an object.
type ObjectCreateMetaType struct {
	// name
	//
	// x-displayName: "Name"
	// x-example: "acmecorp-web"
	// x-required
	// The configuration object will be created with name. It has to be unique within the namespace.
	// The value of name has to follow DNS-1035 format.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "staging"
	// This defines the workspace within which each the configuration object is to be created.
	// Must be a DNS_LABEL format. For a namespace object itself, namespace value will be ""
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// labels
	//
	// x-displayName: "Labels"
	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects as chosen by the user. Values specified here will be used
	// by selector expression
	Labels map[string]string `protobuf:"bytes,4,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// annotations
	//
	// x-displayName: "Annotation"
	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	Annotations map[string]string `protobuf:"bytes,5,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// description
	//
	// x-displayName: "Description"
	// x-example: "Virtual Host for acmecorp website"
	// Human readable description for the object
	Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	// disable
	//
	// x-displayName: "Disable"
	// A value of true will administratively disable the object
	Disable bool `protobuf:"varint,7,opt,name=disable,proto3" json:"disable,omitempty"`
}

func (m *ObjectCreateMetaType) Reset()      { *m = ObjectCreateMetaType{} }
func (*ObjectCreateMetaType) ProtoMessage() {}
func (*ObjectCreateMetaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{12}
}
func (m *ObjectCreateMetaType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectCreateMetaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ObjectCreateMetaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectCreateMetaType.Merge(m, src)
}
func (m *ObjectCreateMetaType) XXX_Size() int {
	return m.Size()
}
func (m *ObjectCreateMetaType) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectCreateMetaType.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectCreateMetaType proto.InternalMessageInfo

func (m *ObjectCreateMetaType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ObjectCreateMetaType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ObjectCreateMetaType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ObjectCreateMetaType) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ObjectCreateMetaType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ObjectCreateMetaType) GetDisable() bool {
	if m != nil {
		return m.Disable
	}
	return false
}

// ObjectReplaceMetaType
//
// x-displayName: "Replace Metadata"
// ObjectReplaceMetaType is metadata that can be specified in Replace request of an object.
type ObjectReplaceMetaType struct {
	// name
	//
	// x-displayName: "Name"
	// x-example: "acmecorp-web"
	// The configuration object to be replaced will be looked up by name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "staging"
	// This defines the workspace within which each the configuration object is to be created.
	// Must be a DNS_LABEL format. For a namespace object itself, namespace value will be ""
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// labels
	//
	// x-displayName: "Labels"
	// x-example: "value"
	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects as chosen by the user. Values specified here will be used
	// by selector expression
	Labels map[string]string `protobuf:"bytes,3,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// annotations
	//
	// x-displayName: "Annotations"
	// x-example: "value"
	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	Annotations map[string]string `protobuf:"bytes,4,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// description
	//
	// x-displayName: "Description"
	// x-example: "Virtual Host for acmecorp website"
	// Human readable description for the object
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	// disable
	//
	// x-displayName: "Disable"
	// A value of true will administratively disable the object
	Disable bool `protobuf:"varint,6,opt,name=disable,proto3" json:"disable,omitempty"`
}

func (m *ObjectReplaceMetaType) Reset()      { *m = ObjectReplaceMetaType{} }
func (*ObjectReplaceMetaType) ProtoMessage() {}
func (*ObjectReplaceMetaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{13}
}
func (m *ObjectReplaceMetaType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectReplaceMetaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ObjectReplaceMetaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectReplaceMetaType.Merge(m, src)
}
func (m *ObjectReplaceMetaType) XXX_Size() int {
	return m.Size()
}
func (m *ObjectReplaceMetaType) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectReplaceMetaType.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectReplaceMetaType proto.InternalMessageInfo

func (m *ObjectReplaceMetaType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ObjectReplaceMetaType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ObjectReplaceMetaType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ObjectReplaceMetaType) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ObjectReplaceMetaType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ObjectReplaceMetaType) GetDisable() bool {
	if m != nil {
		return m.Disable
	}
	return false
}

// MessageMetaType
//
// x-displayName: "Message Metadata"
// MessageMetaType is metadata (common attributes) of a message that only certain messages
// have. This information is propagated to the metadata of a child object that gets created
// from the containing message during view processing.
// The information in this type can be specified by user during create and replace APIs.
type MessageMetaType struct {
	// name
	//
	// x-displayName: "Name"
	// x-example: "acmecorp-web"
	// x-required
	// This is the name of the message.
	// The value of name has to follow DNS-1035 format.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// description
	//
	// x-displayName: "Description"
	// x-example: "Virtual Host for acmecorp website"
	// Human readable description.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// disable
	//
	// x-displayName: "Disable"
	// x-example: "true"
	// A value of true will administratively disable the object that corresponds to the containing message.
	Disable bool `protobuf:"varint,3,opt,name=disable,proto3" json:"disable,omitempty"`
}

func (m *MessageMetaType) Reset()      { *m = MessageMetaType{} }
func (*MessageMetaType) ProtoMessage() {}
func (*MessageMetaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{14}
}
func (m *MessageMetaType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageMetaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MessageMetaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageMetaType.Merge(m, src)
}
func (m *MessageMetaType) XXX_Size() int {
	return m.Size()
}
func (m *MessageMetaType) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageMetaType.DiscardUnknown(m)
}

var xxx_messageInfo_MessageMetaType proto.InternalMessageInfo

func (m *MessageMetaType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MessageMetaType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MessageMetaType) GetDisable() bool {
	if m != nil {
		return m.Disable
	}
	return false
}

// ViewRefType
//
// x-displayName: "View Reference"
// ViewRefType represents a reference to a view
type ViewRefType struct {
	// kind
	//
	// x-displayName: "Kind"
	// x-example: "http_proxy"
	// Kind of the view object
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// uid
	//
	// x-displayName: "UID"
	// x-example: "f3744323-1adf-4aaa-a5dc-0707c1d1bd82"
	// UID of the view object
	Uid string `protobuf:"bytes,2,opt,name=uid,proto3" json:"uid,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "ns1"
	// When a configuration object(e.g. virtual_host) refers to another(e.g route)
	// then namespace will hold the referred object's(e.g. route's) namespace.
	Namespace string `protobuf:"bytes,4,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// name
	//
	// x-displayName: "Name"
	// x-example: "contactus-route"
	// When a configuration object(e.g. virtual_host) refers to another(e.g route)
	// then name will hold the referred object's(e.g. route's) name.
	Name string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ViewRefType) Reset()      { *m = ViewRefType{} }
func (*ViewRefType) ProtoMessage() {}
func (*ViewRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{15}
}
func (m *ViewRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ViewRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewRefType.Merge(m, src)
}
func (m *ViewRefType) XXX_Size() int {
	return m.Size()
}
func (m *ViewRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewRefType.DiscardUnknown(m)
}

var xxx_messageInfo_ViewRefType proto.InternalMessageInfo

func (m *ViewRefType) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *ViewRefType) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *ViewRefType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ViewRefType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// KubeRefType
//
// x-displayName: "Kubernetes Reference"
// KubeRefType represents a reference to a Kubernetes (K8s) object
type KubeRefType struct {
	// kind
	//
	// x-displayName: "Kind"
	// x-example: "Deployment"
	// Kind of the kubernetes object
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "ns1"
	// Namespace of the kubernetes object
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// name
	//
	// x-displayName: "Name"
	// x-example: "adservice"
	// Name of the kubernetes object
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *KubeRefType) Reset()      { *m = KubeRefType{} }
func (*KubeRefType) ProtoMessage() {}
func (*KubeRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{16}
}
func (m *KubeRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubeRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *KubeRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubeRefType.Merge(m, src)
}
func (m *KubeRefType) XXX_Size() int {
	return m.Size()
}
func (m *KubeRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_KubeRefType.DiscardUnknown(m)
}

var xxx_messageInfo_KubeRefType proto.InternalMessageInfo

func (m *KubeRefType) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *KubeRefType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *KubeRefType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// SystemObjectMetaType
//
// x-displayName: "System Metadata"
// SystemObjectMetaType is metadata generated or populated by the system for all persisted objects and
// cannot be updated directly by users.
type SystemObjectMetaType struct {
	// uid
	//
	// x-displayName: "UID"
	// x-example: "d15f1fad-4d37-48c0-8706-df1824d76d31"
	// uid is the unique in time and space value for this object. It is generated by
	// the server on successful creation of an object and is not allowed to change on Replace
	// API. The value of is taken from uid field of ObjectMetaType, if provided.
	Uid string `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// creation_timestamp
	//
	// x-displayName: "Creation Timestamp"
	// CreationTimestamp is a timestamp representing the server time when this object was
	// created. It is not guaranteed to be set in happens-before order across separate operations.
	// Clients may not set this value. It is represented in RFC3339 form and is in UTC.
	CreationTimestamp *types.Timestamp `protobuf:"bytes,3,opt,name=creation_timestamp,json=creationTimestamp,proto3" json:"creation_timestamp,omitempty"`
	// deletion_timestamp
	//
	// x-displayName: "Deletion Timestamp"
	// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
	// field is set by the server when a graceful deletion is requested by the user, and is not
	// directly settable by a client. The resource is expected to be deleted (no longer visible
	// from resource lists, and not reachable by name) after the time in this field, once the
	// finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
	// Once the deletionTimestamp is set, this value may not be unset or be set further into the
	// future, although it may be shortened or the resource may be deleted prior to this time.
	// For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
	// by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
	// the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
	// remove the pod from the API. In the presence of network partitions, this object may still
	// exist after this timestamp, until an administrator or automated process can determine the
	// resource is fully terminated.
	// If not set, graceful deletion of the object has not been requested.
	//
	// Populated by the system when a graceful deletion is requested.
	// Read-only.
	DeletionTimestamp *types.Timestamp `protobuf:"bytes,4,opt,name=deletion_timestamp,json=deletionTimestamp,proto3" json:"deletion_timestamp,omitempty"`
	// modification_timestamp
	//
	// x-displayName: "Modification Timestamp"
	// ModificationTimestamp is a timestamp representing the server time when this object was
	// last modified.
	ModificationTimestamp *types.Timestamp `protobuf:"bytes,5,opt,name=modification_timestamp,json=modificationTimestamp,proto3" json:"modification_timestamp,omitempty"`
	// initializers
	//
	// x-displayName: "Initializers"
	// An initializer is a controller which enforces some system invariant at object creation time.
	// This field is a list of initializers that have not yet acted on this object. If nil or empty,
	// this object has been completely initialized. Otherwise, the object is considered uninitialized
	// and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to
	// observe uninitialized objects.
	//
	// When an object is created, the system will populate this list with the current set of initializers.
	// Only privileged users may set or modify this list. Once it is empty, it may not be modified further
	// by any user.
	Initializers *InitializersType `protobuf:"bytes,6,opt,name=initializers,proto3" json:"initializers,omitempty"`
	// finalizers
	//
	// x-displayName: "Finalizers"
	// x-example: "value"
	// Must be empty before the object is deleted from the registry. Each entry
	// is an identifier for the responsible component that will remove the entry
	// from the list. If the deletionTimestamp of the object is non-nil, entries
	// in this list can only be removed.
	Finalizers []string `protobuf:"bytes,7,rep,name=finalizers,proto3" json:"finalizers,omitempty"`
	// tenant
	//
	// x-displayName: "Tenant"
	// x-example: "acmecorp"
	// Tenant to which this configuration object belongs to. The value for this is found from
	// presented credentials.
	Tenant string `protobuf:"bytes,8,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// creator_class
	//
	// x-displayName: "Creator Class"
	// x-example: "value"
	// A value identifying the class of the user or service which created this configuration object.
	CreatorClass string `protobuf:"bytes,9,opt,name=creator_class,json=creatorClass,proto3" json:"creator_class,omitempty"`
	// creator_id
	//
	// x-displayName: "Creator ID"
	// x-example: "value"
	// A value identifying the exact user or service that created this configuration object
	CreatorId string `protobuf:"bytes,10,opt,name=creator_id,json=creatorId,proto3" json:"creator_id,omitempty"`
	// creator_cookie
	//
	// x-displayName: "Creator Cookie"
	// x-example: "value"
	// This can used by the creator of the object for later audit for e.g. by storing the
	// version identifying information of the object so at future it can be determined if
	// version present at remote end is current or stale.
	CreatorCookie string `protobuf:"bytes,14,opt,name=creator_cookie,json=creatorCookie,proto3" json:"creator_cookie,omitempty"`
	// trace_info
	//
	// x-displayName: "Trace Info"
	// x-example: "value"
	// trace_info holds information(<trace-id>:<span-id>:<parent-span-id>) of the request doing
	// the object modification. This can be used on the watch side to create subsequent spans.
	// This information can be used to co-relate activities across services (modulo state compression)
	// for a synchronous API.
	TraceInfo string `protobuf:"bytes,11,opt,name=trace_info,json=traceInfo,proto3" json:"trace_info,omitempty"`
	// object_index
	//
	// x-displayName: "Object Index"
	// x-example: "0"
	// Unique index for the object. Some objects need a unique integer index to be allocated
	// for each object type. This field will be populated for all objects that need it and will
	// be zero otherwise.
	ObjectIndex uint32 `protobuf:"varint,12,opt,name=object_index,json=objectIndex,proto3" json:"object_index,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace Reference"
	// The namespace this object belongs to. This is populated by the service based on the
	// metadata.namespace field when an object is created.
	Namespace []*ObjectRefType `protobuf:"bytes,13,rep,name=namespace,proto3" json:"namespace,omitempty"`
	// owner_view
	//
	// x-displayName: "Owner View"
	// Reference to the view object that owns this object.
	// If there is no view owner, this field will be nil.
	// If not nil, this object can only be edited/deleted through the view
	OwnerView *ViewRefType `protobuf:"bytes,15,opt,name=owner_view,json=ownerView,proto3" json:"owner_view,omitempty"`
	// sre_disable
	//
	// x-displayName: "SRE Disable"
	// x-example: "true"
	// This should be set to true If VES/SRE operator wants to suppress an object from being
	// presented to business-logic of a daemon(e.g. due to bad-form/issue-causing Object).
	// This is meant only to be used in temporary situations for operational continuity till
	// a fix is rolled out in business-logic.
	SreDisable bool `protobuf:"varint,16,opt,name=sre_disable,json=sreDisable,proto3" json:"sre_disable,omitempty"`
	// vtrp_id
	//
	// x-displayName: "VTRP ID"
	// Indicate origin of this object.
	VtrpId string `protobuf:"bytes,17,opt,name=vtrp_id,json=vtrpId,proto3" json:"vtrp_id,omitempty"`
	// vtrp_stale
	//
	// x-displayName: "VTRP Stale"
	// Indicate whether mars deems this object to be stale via graceful restart timer information
	VtrpStale bool `protobuf:"varint,18,opt,name=vtrp_stale,json=vtrpStale,proto3" json:"vtrp_stale,omitempty"`
	// labels
	//
	// x-displayName: "Labels"
	// x-example: "'ves.io/soft-deleted': 'true'"
	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects as chosen by the operator or software. Values here can be interpreted
	// by software(backend or frontend) to enable certain behavior e.g. things marked as soft-deleted(restorable).
	Labels map[string]string `protobuf:"bytes,19,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SystemObjectMetaType) Reset()      { *m = SystemObjectMetaType{} }
func (*SystemObjectMetaType) ProtoMessage() {}
func (*SystemObjectMetaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{17}
}
func (m *SystemObjectMetaType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SystemObjectMetaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SystemObjectMetaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SystemObjectMetaType.Merge(m, src)
}
func (m *SystemObjectMetaType) XXX_Size() int {
	return m.Size()
}
func (m *SystemObjectMetaType) XXX_DiscardUnknown() {
	xxx_messageInfo_SystemObjectMetaType.DiscardUnknown(m)
}

var xxx_messageInfo_SystemObjectMetaType proto.InternalMessageInfo

func (m *SystemObjectMetaType) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *SystemObjectMetaType) GetCreationTimestamp() *types.Timestamp {
	if m != nil {
		return m.CreationTimestamp
	}
	return nil
}

func (m *SystemObjectMetaType) GetDeletionTimestamp() *types.Timestamp {
	if m != nil {
		return m.DeletionTimestamp
	}
	return nil
}

func (m *SystemObjectMetaType) GetModificationTimestamp() *types.Timestamp {
	if m != nil {
		return m.ModificationTimestamp
	}
	return nil
}

func (m *SystemObjectMetaType) GetInitializers() *InitializersType {
	if m != nil {
		return m.Initializers
	}
	return nil
}

func (m *SystemObjectMetaType) GetFinalizers() []string {
	if m != nil {
		return m.Finalizers
	}
	return nil
}

func (m *SystemObjectMetaType) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *SystemObjectMetaType) GetCreatorClass() string {
	if m != nil {
		return m.CreatorClass
	}
	return ""
}

func (m *SystemObjectMetaType) GetCreatorId() string {
	if m != nil {
		return m.CreatorId
	}
	return ""
}

func (m *SystemObjectMetaType) GetCreatorCookie() string {
	if m != nil {
		return m.CreatorCookie
	}
	return ""
}

func (m *SystemObjectMetaType) GetTraceInfo() string {
	if m != nil {
		return m.TraceInfo
	}
	return ""
}

func (m *SystemObjectMetaType) GetObjectIndex() uint32 {
	if m != nil {
		return m.ObjectIndex
	}
	return 0
}

func (m *SystemObjectMetaType) GetNamespace() []*ObjectRefType {
	if m != nil {
		return m.Namespace
	}
	return nil
}

func (m *SystemObjectMetaType) GetOwnerView() *ViewRefType {
	if m != nil {
		return m.OwnerView
	}
	return nil
}

func (m *SystemObjectMetaType) GetSreDisable() bool {
	if m != nil {
		return m.SreDisable
	}
	return false
}

func (m *SystemObjectMetaType) GetVtrpId() string {
	if m != nil {
		return m.VtrpId
	}
	return ""
}

func (m *SystemObjectMetaType) GetVtrpStale() bool {
	if m != nil {
		return m.VtrpStale
	}
	return false
}

func (m *SystemObjectMetaType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// SystemObjectGetMetaType
//
// x-displayName: "System Metadata"
// SystemObjectGetMetaType is metadata generated or populated by the system for all persisted objects and
// cannot be updated directly by users.
type SystemObjectGetMetaType struct {
	// uid
	//
	// x-displayName: "UID"
	// x-example: "d15f1fad-4d37-48c0-8706-df1824d76d31"
	// uid is the unique in time and space value for this object. It is generated by
	// the server on successful creation of an object and is not allowed to change on Replace
	// API. The value of is taken from uid field of ObjectMetaType, if provided.
	Uid string `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// creation_timestamp
	//
	// x-displayName: "Creation Timestamp"
	// CreationTimestamp is a timestamp representing the server time when this object was
	// created. It is not guaranteed to be set in happens-before order across separate operations.
	// Clients may not set this value. It is represented in RFC3339 form and is in UTC.
	CreationTimestamp *types.Timestamp `protobuf:"bytes,3,opt,name=creation_timestamp,json=creationTimestamp,proto3" json:"creation_timestamp,omitempty"`
	// deletion_timestamp
	//
	// x-displayName: "Deletion Timestamp"
	// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
	// field is set by the server when a graceful deletion is requested by the user, and is not
	// directly settable by a client. The resource is expected to be deleted (no longer visible
	// from resource lists, and not reachable by name) after the time in this field, once the
	// finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
	// Once the deletionTimestamp is set, this value may not be unset or be set further into the
	// future, although it may be shortened or the resource may be deleted prior to this time.
	// For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
	// by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
	// the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
	// remove the pod from the API. In the presence of network partitions, this object may still
	// exist after this timestamp, until an administrator or automated process can determine the
	// resource is fully terminated.
	// If not set, graceful deletion of the object has not been requested.
	//
	// Populated by the system when a graceful deletion is requested.
	// Read-only.
	DeletionTimestamp *types.Timestamp `protobuf:"bytes,4,opt,name=deletion_timestamp,json=deletionTimestamp,proto3" json:"deletion_timestamp,omitempty"`
	// modification_timestamp
	//
	// x-displayName: "Modification Timestamp"
	// ModificationTimestamp is a timestamp representing the server time when this object was
	// last modified.
	ModificationTimestamp *types.Timestamp `protobuf:"bytes,5,opt,name=modification_timestamp,json=modificationTimestamp,proto3" json:"modification_timestamp,omitempty"`
	// initializers
	//
	// x-displayName: "Initializers"
	// An initializer is a controller which enforces some system invariant at object creation time.
	// This field is a list of initializers that have not yet acted on this object. If nil or empty,
	// this object has been completely initialized. Otherwise, the object is considered uninitialized
	// and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to
	// observe uninitialized objects.
	//
	// When an object is created, the system will populate this list with the current set of initializers.
	// Only privileged users may set or modify this list. Once it is empty, it may not be modified further
	// by any user.
	Initializers *InitializersType `protobuf:"bytes,6,opt,name=initializers,proto3" json:"initializers,omitempty"`
	// finalizers
	//
	// x-displayName: "Finalizers"
	// x-example: "value"
	// Must be empty before the object is deleted from the registry. Each entry
	// is an identifier for the responsible component that will remove the entry
	// from the list. If the deletionTimestamp of the object is non-nil, entries
	// in this list can only be removed.
	Finalizers []string `protobuf:"bytes,7,rep,name=finalizers,proto3" json:"finalizers,omitempty"`
	// tenant
	//
	// x-displayName: "Tenant"
	// x-example: "acmecorp"
	// Tenant to which this configuration object belongs to. The value for this is found from
	// presented credentials.
	Tenant string `protobuf:"bytes,8,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// creator_class
	//
	// x-displayName: "Creator Class"
	// x-example: "prism"
	// A value identifying the class of the user or service which created this configuration object.
	CreatorClass string `protobuf:"bytes,9,opt,name=creator_class,json=creatorClass,proto3" json:"creator_class,omitempty"`
	// creator_id
	//
	// x-displayName: "Creator ID"
	// x-example: "admin@acmecorp.com"
	// A value identifying the exact user or service that created this configuration object
	CreatorId string `protobuf:"bytes,10,opt,name=creator_id,json=creatorId,proto3" json:"creator_id,omitempty"`
	// object_index
	//
	// x-displayName: "Object Index"
	// x-example: "0"
	// Unique index for the object. Some objects need a unique integer index to be allocated
	// for each object type. This field will be populated for all objects that need it and will
	// be zero otherwise.
	ObjectIndex uint32 `protobuf:"varint,12,opt,name=object_index,json=objectIndex,proto3" json:"object_index,omitempty"`
	// owner_view
	//
	// x-displayName: "Owner View"
	// Reference to the view object that owns this object.
	// If there is no view owner, this field will be nil.
	// If not nil, this object can only be edited/deleted through the view
	OwnerView *ViewRefType `protobuf:"bytes,15,opt,name=owner_view,json=ownerView,proto3" json:"owner_view,omitempty"`
	// labels
	//
	// x-displayName: "Labels"
	// x-example: "'ves.io/soft-deleted': 'true'"
	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects as chosen by the operator or software. Values here can be interpreted
	// by software(backend or frontend) to enable certain behavior e.g. things marked as soft-deleted(restorable).
	Labels map[string]string `protobuf:"bytes,19,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SystemObjectGetMetaType) Reset()      { *m = SystemObjectGetMetaType{} }
func (*SystemObjectGetMetaType) ProtoMessage() {}
func (*SystemObjectGetMetaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{18}
}
func (m *SystemObjectGetMetaType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SystemObjectGetMetaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SystemObjectGetMetaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SystemObjectGetMetaType.Merge(m, src)
}
func (m *SystemObjectGetMetaType) XXX_Size() int {
	return m.Size()
}
func (m *SystemObjectGetMetaType) XXX_DiscardUnknown() {
	xxx_messageInfo_SystemObjectGetMetaType.DiscardUnknown(m)
}

var xxx_messageInfo_SystemObjectGetMetaType proto.InternalMessageInfo

func (m *SystemObjectGetMetaType) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *SystemObjectGetMetaType) GetCreationTimestamp() *types.Timestamp {
	if m != nil {
		return m.CreationTimestamp
	}
	return nil
}

func (m *SystemObjectGetMetaType) GetDeletionTimestamp() *types.Timestamp {
	if m != nil {
		return m.DeletionTimestamp
	}
	return nil
}

func (m *SystemObjectGetMetaType) GetModificationTimestamp() *types.Timestamp {
	if m != nil {
		return m.ModificationTimestamp
	}
	return nil
}

func (m *SystemObjectGetMetaType) GetInitializers() *InitializersType {
	if m != nil {
		return m.Initializers
	}
	return nil
}

func (m *SystemObjectGetMetaType) GetFinalizers() []string {
	if m != nil {
		return m.Finalizers
	}
	return nil
}

func (m *SystemObjectGetMetaType) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *SystemObjectGetMetaType) GetCreatorClass() string {
	if m != nil {
		return m.CreatorClass
	}
	return ""
}

func (m *SystemObjectGetMetaType) GetCreatorId() string {
	if m != nil {
		return m.CreatorId
	}
	return ""
}

func (m *SystemObjectGetMetaType) GetObjectIndex() uint32 {
	if m != nil {
		return m.ObjectIndex
	}
	return 0
}

func (m *SystemObjectGetMetaType) GetOwnerView() *ViewRefType {
	if m != nil {
		return m.OwnerView
	}
	return nil
}

func (m *SystemObjectGetMetaType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// AuthnTypeBasicAuth
//
// x-displayName: "BasicAuth Authentication Parameters"
// AuthnTypeBasicAuth is used for using basic_auth mode of HTTP authentication
type AuthnTypeBasicAuth struct {
	// username
	//
	// x-displayName: "Username"
	// x-example: "value"
	// The username to encode in Basic Auth scheme
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	// password
	//
	// x-displayName: "Password"
	// x-example: "value"
	// F5XC Secret. The password to encode in Basic Auth scheme
	Password *SecretType `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
}

func (m *AuthnTypeBasicAuth) Reset()      { *m = AuthnTypeBasicAuth{} }
func (*AuthnTypeBasicAuth) ProtoMessage() {}
func (*AuthnTypeBasicAuth) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{19}
}
func (m *AuthnTypeBasicAuth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthnTypeBasicAuth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AuthnTypeBasicAuth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthnTypeBasicAuth.Merge(m, src)
}
func (m *AuthnTypeBasicAuth) XXX_Size() int {
	return m.Size()
}
func (m *AuthnTypeBasicAuth) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthnTypeBasicAuth.DiscardUnknown(m)
}

var xxx_messageInfo_AuthnTypeBasicAuth proto.InternalMessageInfo

func (m *AuthnTypeBasicAuth) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *AuthnTypeBasicAuth) GetPassword() *SecretType {
	if m != nil {
		return m.Password
	}
	return nil
}

// AuthnTypeHeaders
//
// x-displayName: "Authentication Headers"
// AuthnTypeHeaders is used for setting headers for authentication
type AuthnTypeHeaders struct {
	// headers
	//
	// x-displayName: "Headers"
	// The set of authentication headers to pass in HTTP request
	Headers map[string]*SecretType `protobuf:"bytes,1,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *AuthnTypeHeaders) Reset()      { *m = AuthnTypeHeaders{} }
func (*AuthnTypeHeaders) ProtoMessage() {}
func (*AuthnTypeHeaders) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{20}
}
func (m *AuthnTypeHeaders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthnTypeHeaders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AuthnTypeHeaders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthnTypeHeaders.Merge(m, src)
}
func (m *AuthnTypeHeaders) XXX_Size() int {
	return m.Size()
}
func (m *AuthnTypeHeaders) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthnTypeHeaders.DiscardUnknown(m)
}

var xxx_messageInfo_AuthnTypeHeaders proto.InternalMessageInfo

func (m *AuthnTypeHeaders) GetHeaders() map[string]*SecretType {
	if m != nil {
		return m.Headers
	}
	return nil
}

// AuthnTypeQueryParams
//
// x-displayName: "Authentication QueryParams"
// AuthnTypeQueryParams is used for setting query_params for authentication
type AuthnTypeQueryParams struct {
	// query_params
	//
	// x-displayName: "Query Parameters"
	// The set of authentication parameters to be passed as query parameters
	QueryParams map[string]*SecretType `protobuf:"bytes,1,rep,name=query_params,json=queryParams,proto3" json:"query_params,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *AuthnTypeQueryParams) Reset()      { *m = AuthnTypeQueryParams{} }
func (*AuthnTypeQueryParams) ProtoMessage() {}
func (*AuthnTypeQueryParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{21}
}
func (m *AuthnTypeQueryParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthnTypeQueryParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AuthnTypeQueryParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthnTypeQueryParams.Merge(m, src)
}
func (m *AuthnTypeQueryParams) XXX_Size() int {
	return m.Size()
}
func (m *AuthnTypeQueryParams) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthnTypeQueryParams.DiscardUnknown(m)
}

var xxx_messageInfo_AuthnTypeQueryParams proto.InternalMessageInfo

func (m *AuthnTypeQueryParams) GetQueryParams() map[string]*SecretType {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

// BlindfoldSecretInfoType
//
// x-displayName: "Blindfold Secret"
// BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management
type BlindfoldSecretInfoType struct {
	// Decryption Provider
	//
	// x-displayName: "Decryption Provider"
	// x-example: "value"
	// Name of the Secret Management Access object that contains information about the backend Secret Management service.
	DecryptionProvider string `protobuf:"bytes,1,opt,name=decryption_provider,json=decryptionProvider,proto3" json:"decryption_provider,omitempty"`
	// Store Provider
	//
	// x-displayName: "Store Provider"
	// x-example: "value"
	// Name of the Secret Management Access object that contains information about the store to get encrypted bytes
	// This field needs to be provided only if the url scheme is not string:///
	StoreProvider string `protobuf:"bytes,2,opt,name=store_provider,json=storeProvider,proto3" json:"store_provider,omitempty"`
	// Location
	//
	// x-displayName: "Location"
	// x-required
	// x-example: "string:///U2VjcmV0SW5mb3JtYXRpb24="
	// Location is the uri_ref. It could be in url format for string:///
	// Or it could be a path if the store provider is an http/https location
	Location string `protobuf:"bytes,3,opt,name=location,proto3" json:"location,omitempty"`
}

func (m *BlindfoldSecretInfoType) Reset()      { *m = BlindfoldSecretInfoType{} }
func (*BlindfoldSecretInfoType) ProtoMessage() {}
func (*BlindfoldSecretInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{22}
}
func (m *BlindfoldSecretInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlindfoldSecretInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BlindfoldSecretInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlindfoldSecretInfoType.Merge(m, src)
}
func (m *BlindfoldSecretInfoType) XXX_Size() int {
	return m.Size()
}
func (m *BlindfoldSecretInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_BlindfoldSecretInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_BlindfoldSecretInfoType proto.InternalMessageInfo

func (m *BlindfoldSecretInfoType) GetDecryptionProvider() string {
	if m != nil {
		return m.DecryptionProvider
	}
	return ""
}

func (m *BlindfoldSecretInfoType) GetStoreProvider() string {
	if m != nil {
		return m.StoreProvider
	}
	return ""
}

func (m *BlindfoldSecretInfoType) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

// VaultSecretInfoType
//
// x-displayName: "Vault Secret"
// VaultSecretInfoType specifies information about the Secret managed by Hashicorp Vault.
type VaultSecretInfoType struct {
	// Provider
	//
	// x-displayName: "Provider"
	// x-required
	// x-example: "vault-vh-provider"
	// Name of the Secret Management Access object that contains information about the backend Vault.
	Provider string `protobuf:"bytes,1,opt,name=provider,proto3" json:"provider,omitempty"`
	// Location
	//
	// x-displayName: "Location"
	// x-required
	// x-example: "v1/data/vhost_key"
	// Path to secret in Vault.
	Location string `protobuf:"bytes,2,opt,name=location,proto3" json:"location,omitempty"`
	// Key
	//
	// x-displayName: "Key"
	// x-example: "key_pem"
	// Key of the individual secret. Vault Secrets are stored as key-value pair.
	// If user is only interested in one value from the map, this field should be set to the corresponding key.
	// If not provided entire secret will be returned.
	Key string `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	// Version
	//
	// x-displayName: "Version"
	// x-example: "1"
	// Version of the secret to be fetched. As vault secrets are versioned, user can specify this field to fetch specific version.
	// If not provided latest version will be returned.
	Version uint32 `protobuf:"varint,4,opt,name=version,proto3" json:"version,omitempty"`
	// secret_encoding
	//
	// x-displayName: "Secret Encoding"
	// This field defines the encoding type of the secret BEFORE the secret is put into Hashicorp Vault.
	SecretEncoding SecretEncodingType `protobuf:"varint,5,opt,name=secret_encoding,json=secretEncoding,proto3,enum=ves.io.schema.SecretEncodingType" json:"secret_encoding,omitempty"`
}

func (m *VaultSecretInfoType) Reset()      { *m = VaultSecretInfoType{} }
func (*VaultSecretInfoType) ProtoMessage() {}
func (*VaultSecretInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{23}
}
func (m *VaultSecretInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VaultSecretInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VaultSecretInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VaultSecretInfoType.Merge(m, src)
}
func (m *VaultSecretInfoType) XXX_Size() int {
	return m.Size()
}
func (m *VaultSecretInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_VaultSecretInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_VaultSecretInfoType proto.InternalMessageInfo

func (m *VaultSecretInfoType) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *VaultSecretInfoType) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *VaultSecretInfoType) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *VaultSecretInfoType) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *VaultSecretInfoType) GetSecretEncoding() SecretEncodingType {
	if m != nil {
		return m.SecretEncoding
	}
	return EncodingNone
}

// ClearSecretInfoType
//
// x-displayName: "In-Clear Secret"
// ClearSecretInfoType specifies information about the Secret that is not encrypted.
type ClearSecretInfoType struct {
	// Provider
	//
	// x-displayName: "Provider"
	// x-example: "box-provider"
	// Name of the Secret Management Access object that contains information about the store to get encrypted bytes
	// This field needs to be provided only if the url scheme is not string:///
	Provider string `protobuf:"bytes,1,opt,name=provider,proto3" json:"provider,omitempty"`
	// URL
	//
	// x-displayName: "URL"
	// x-required
	// x-example: "string:///U2VjcmV0SW5mb3JtYXRpb24="
	// URL of the secret. Currently supported URL schemes is string:///.
	// For string:/// scheme, Secret needs to be encoded Base64 format.
	// When asked for this secret, caller will get Secret bytes after Base64 decoding.
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *ClearSecretInfoType) Reset()      { *m = ClearSecretInfoType{} }
func (*ClearSecretInfoType) ProtoMessage() {}
func (*ClearSecretInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{24}
}
func (m *ClearSecretInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearSecretInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ClearSecretInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearSecretInfoType.Merge(m, src)
}
func (m *ClearSecretInfoType) XXX_Size() int {
	return m.Size()
}
func (m *ClearSecretInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearSecretInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_ClearSecretInfoType proto.InternalMessageInfo

func (m *ClearSecretInfoType) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *ClearSecretInfoType) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// WingmanSecretInfoType
//
// x-displayName: "Wingman Secret"
// WingmanSecretInfoType specifies the handle to the wingman secret
type WingmanSecretInfoType struct {
	// Name
	//
	// x-displayName: "Name"
	// x-required
	// x-example: "ChargeBack-API-Key"
	// Name of the secret.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *WingmanSecretInfoType) Reset()      { *m = WingmanSecretInfoType{} }
func (*WingmanSecretInfoType) ProtoMessage() {}
func (*WingmanSecretInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{25}
}
func (m *WingmanSecretInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WingmanSecretInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WingmanSecretInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WingmanSecretInfoType.Merge(m, src)
}
func (m *WingmanSecretInfoType) XXX_Size() int {
	return m.Size()
}
func (m *WingmanSecretInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_WingmanSecretInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_WingmanSecretInfoType proto.InternalMessageInfo

func (m *WingmanSecretInfoType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// SecretType
//
// x-displayName: "Secret"
// SecretType is used in an object to indicate a sensitive/confidential field
type SecretType struct {
	// SecretInfoOneof
	//
	// x-displayName: "Secret Info"
	// x-required
	// Secret can be one of the following types -
	// * Blindfold Secret - Secret is managed by F5XC Secret Management System
	// * Clear Secret - Secret is not encrypted
	//
	// Types that are valid to be assigned to SecretInfoOneof:
	//	*SecretType_BlindfoldSecretInfo
	//	*SecretType_VaultSecretInfo
	//	*SecretType_ClearSecretInfo
	//	*SecretType_WingmanSecretInfo
	SecretInfoOneof isSecretType_SecretInfoOneof `protobuf_oneof:"secret_info_oneof"`
	// Blindfold Secret Internal
	//
	// x-displayName: "Blindfold Secret Internal"
	// Blindfold Secret Internal is used for the putting re-encrypted blindfold secret
	BlindfoldSecretInfoInternal *BlindfoldSecretInfoType `protobuf:"bytes,10,opt,name=blindfold_secret_info_internal,json=blindfoldSecretInfoInternal,proto3" json:"blindfold_secret_info_internal,omitempty"`
	// secret_encoding_type
	//
	// x-displayName: "Secret Encoding"
	// This field defines the encoding type of the secret BEFORE the secret is given to any Secret Management System.
	// this will be set if the secret is encoded and not plaintext BEFORE it is encrypted and put it in SecretType.
	// Note - Do NOT set this field for Clear Secret with string:/// scheme.
	// e.g. if a secret is base64 encoded and then put into vault.
	SecretEncodingType SecretEncodingType `protobuf:"varint,8,opt,name=secret_encoding_type,json=secretEncodingType,proto3,enum=ves.io.schema.SecretEncodingType" json:"secret_encoding_type,omitempty"` // Deprecated: Do not use.
}

func (m *SecretType) Reset()      { *m = SecretType{} }
func (*SecretType) ProtoMessage() {}
func (*SecretType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{26}
}
func (m *SecretType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecretType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SecretType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecretType.Merge(m, src)
}
func (m *SecretType) XXX_Size() int {
	return m.Size()
}
func (m *SecretType) XXX_DiscardUnknown() {
	xxx_messageInfo_SecretType.DiscardUnknown(m)
}

var xxx_messageInfo_SecretType proto.InternalMessageInfo

type isSecretType_SecretInfoOneof interface {
	isSecretType_SecretInfoOneof()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SecretType_BlindfoldSecretInfo struct {
	BlindfoldSecretInfo *BlindfoldSecretInfoType `protobuf:"bytes,4,opt,name=blindfold_secret_info,json=blindfoldSecretInfo,proto3,oneof" json:"blindfold_secret_info,omitempty"`
}
type SecretType_VaultSecretInfo struct {
	VaultSecretInfo *VaultSecretInfoType `protobuf:"bytes,5,opt,name=vault_secret_info,json=vaultSecretInfo,proto3,oneof" json:"vault_secret_info,omitempty"`
}
type SecretType_ClearSecretInfo struct {
	ClearSecretInfo *ClearSecretInfoType `protobuf:"bytes,6,opt,name=clear_secret_info,json=clearSecretInfo,proto3,oneof" json:"clear_secret_info,omitempty"`
}
type SecretType_WingmanSecretInfo struct {
	WingmanSecretInfo *WingmanSecretInfoType `protobuf:"bytes,7,opt,name=wingman_secret_info,json=wingmanSecretInfo,proto3,oneof" json:"wingman_secret_info,omitempty"`
}

func (*SecretType_BlindfoldSecretInfo) isSecretType_SecretInfoOneof() {}
func (*SecretType_VaultSecretInfo) isSecretType_SecretInfoOneof()     {}
func (*SecretType_ClearSecretInfo) isSecretType_SecretInfoOneof()     {}
func (*SecretType_WingmanSecretInfo) isSecretType_SecretInfoOneof()   {}

func (m *SecretType) GetSecretInfoOneof() isSecretType_SecretInfoOneof {
	if m != nil {
		return m.SecretInfoOneof
	}
	return nil
}

func (m *SecretType) GetBlindfoldSecretInfo() *BlindfoldSecretInfoType {
	if x, ok := m.GetSecretInfoOneof().(*SecretType_BlindfoldSecretInfo); ok {
		return x.BlindfoldSecretInfo
	}
	return nil
}

// Deprecated: Do not use.
func (m *SecretType) GetVaultSecretInfo() *VaultSecretInfoType {
	if x, ok := m.GetSecretInfoOneof().(*SecretType_VaultSecretInfo); ok {
		return x.VaultSecretInfo
	}
	return nil
}

func (m *SecretType) GetClearSecretInfo() *ClearSecretInfoType {
	if x, ok := m.GetSecretInfoOneof().(*SecretType_ClearSecretInfo); ok {
		return x.ClearSecretInfo
	}
	return nil
}

func (m *SecretType) GetWingmanSecretInfo() *WingmanSecretInfoType {
	if x, ok := m.GetSecretInfoOneof().(*SecretType_WingmanSecretInfo); ok {
		return x.WingmanSecretInfo
	}
	return nil
}

func (m *SecretType) GetBlindfoldSecretInfoInternal() *BlindfoldSecretInfoType {
	if m != nil {
		return m.BlindfoldSecretInfoInternal
	}
	return nil
}

// Deprecated: Do not use.
func (m *SecretType) GetSecretEncodingType() SecretEncodingType {
	if m != nil {
		return m.SecretEncodingType
	}
	return EncodingNone
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SecretType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SecretType_BlindfoldSecretInfo)(nil),
		(*SecretType_VaultSecretInfo)(nil),
		(*SecretType_ClearSecretInfo)(nil),
		(*SecretType_WingmanSecretInfo)(nil),
	}
}

// NetworkRefType
//
// x-displayName: "Network Reference"
// This specifies a direct reference to a network configuration object
type NetworkRefType struct {
	// ref
	//
	// x-displayName: "Reference"
	// x-required
	// A virtual network direct reference
	Ref []*ObjectRefType `protobuf:"bytes,1,rep,name=ref,proto3" json:"ref,omitempty"`
}

func (m *NetworkRefType) Reset()      { *m = NetworkRefType{} }
func (*NetworkRefType) ProtoMessage() {}
func (*NetworkRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{27}
}
func (m *NetworkRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NetworkRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkRefType.Merge(m, src)
}
func (m *NetworkRefType) XXX_Size() int {
	return m.Size()
}
func (m *NetworkRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkRefType.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkRefType proto.InternalMessageInfo

func (m *NetworkRefType) GetRef() []*ObjectRefType {
	if m != nil {
		return m.Ref
	}
	return nil
}

// SiteRefType
//
// x-displayName: "Site Reference"
// This specifies a direct reference to a site configuration object
type SiteRefType struct {
	// ref
	//
	// x-displayName: "Reference"
	// x-required
	// A site direct reference
	Ref []*ObjectRefType `protobuf:"bytes,1,rep,name=ref,proto3" json:"ref,omitempty"`
	// network_type
	//
	// x-displayName: "Network Type"
	// The type of network on the referred site
	NetworkType VirtualNetworkType `protobuf:"varint,2,opt,name=network_type,json=networkType,proto3,enum=ves.io.schema.VirtualNetworkType" json:"network_type,omitempty"`
	// Internet VIP Choice
	//
	// x-displayName: "Internet VIP Choice"
	// x-required
	// x-example: "Internet VIP Choice"
	// Internet VIP Choice
	//
	// Types that are valid to be assigned to InternetVipChoice:
	//	*SiteRefType_DisableInternetVip
	//	*SiteRefType_EnableInternetVip
	InternetVipChoice isSiteRefType_InternetVipChoice `protobuf_oneof:"internet_vip_choice"`
	// Virtual Network Reference
	//
	// x-displayName: "Virtual Network Reference"
	// Reference to virtual network
	Refs []*ObjectRefType `protobuf:"bytes,7,rep,name=refs,proto3" json:"refs,omitempty"`
}

func (m *SiteRefType) Reset()      { *m = SiteRefType{} }
func (*SiteRefType) ProtoMessage() {}
func (*SiteRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{28}
}
func (m *SiteRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SiteRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SiteRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SiteRefType.Merge(m, src)
}
func (m *SiteRefType) XXX_Size() int {
	return m.Size()
}
func (m *SiteRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_SiteRefType.DiscardUnknown(m)
}

var xxx_messageInfo_SiteRefType proto.InternalMessageInfo

type isSiteRefType_InternetVipChoice interface {
	isSiteRefType_InternetVipChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SiteRefType_DisableInternetVip struct {
	DisableInternetVip *Empty `protobuf:"bytes,6,opt,name=disable_internet_vip,json=disableInternetVip,proto3,oneof" json:"disable_internet_vip,omitempty"`
}
type SiteRefType_EnableInternetVip struct {
	EnableInternetVip *Empty `protobuf:"bytes,5,opt,name=enable_internet_vip,json=enableInternetVip,proto3,oneof" json:"enable_internet_vip,omitempty"`
}

func (*SiteRefType_DisableInternetVip) isSiteRefType_InternetVipChoice() {}
func (*SiteRefType_EnableInternetVip) isSiteRefType_InternetVipChoice()  {}

func (m *SiteRefType) GetInternetVipChoice() isSiteRefType_InternetVipChoice {
	if m != nil {
		return m.InternetVipChoice
	}
	return nil
}

func (m *SiteRefType) GetRef() []*ObjectRefType {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *SiteRefType) GetNetworkType() VirtualNetworkType {
	if m != nil {
		return m.NetworkType
	}
	return VIRTUAL_NETWORK_SITE_LOCAL
}

func (m *SiteRefType) GetDisableInternetVip() *Empty {
	if x, ok := m.GetInternetVipChoice().(*SiteRefType_DisableInternetVip); ok {
		return x.DisableInternetVip
	}
	return nil
}

func (m *SiteRefType) GetEnableInternetVip() *Empty {
	if x, ok := m.GetInternetVipChoice().(*SiteRefType_EnableInternetVip); ok {
		return x.EnableInternetVip
	}
	return nil
}

func (m *SiteRefType) GetRefs() []*ObjectRefType {
	if m != nil {
		return m.Refs
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SiteRefType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SiteRefType_DisableInternetVip)(nil),
		(*SiteRefType_EnableInternetVip)(nil),
	}
}

// IpPrefixSetRefType
//
// x-displayName: "IP Prefix Set Reference"
// A list of references to ip_prefix_set objects.
type IpPrefixSetRefType struct {
	// ref
	//
	// x-displayName: "Reference"
	// A list of references to ip_prefix_set objects.
	Ref []*ObjectRefType `protobuf:"bytes,1,rep,name=ref,proto3" json:"ref,omitempty"`
}

func (m *IpPrefixSetRefType) Reset()      { *m = IpPrefixSetRefType{} }
func (*IpPrefixSetRefType) ProtoMessage() {}
func (*IpPrefixSetRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{29}
}
func (m *IpPrefixSetRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpPrefixSetRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IpPrefixSetRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpPrefixSetRefType.Merge(m, src)
}
func (m *IpPrefixSetRefType) XXX_Size() int {
	return m.Size()
}
func (m *IpPrefixSetRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_IpPrefixSetRefType.DiscardUnknown(m)
}

var xxx_messageInfo_IpPrefixSetRefType proto.InternalMessageInfo

func (m *IpPrefixSetRefType) GetRef() []*ObjectRefType {
	if m != nil {
		return m.Ref
	}
	return nil
}

// VSiteRefType
//
// x-displayName: "Virtual Site"
// A reference to virtual_site object
type VSiteRefType struct {
	// ref
	//
	// x-displayName: "Reference"
	// x-required
	// A virtual_site direct reference
	Ref []*ObjectRefType `protobuf:"bytes,1,rep,name=ref,proto3" json:"ref,omitempty"`
	// network_type
	//
	// x-displayName: "Network Type"
	// The type of network on the referred virtual_site
	NetworkType VirtualNetworkType `protobuf:"varint,2,opt,name=network_type,json=networkType,proto3,enum=ves.io.schema.VirtualNetworkType" json:"network_type,omitempty"`
	// Internet VIP Choice
	//
	// x-displayName: "Internet VIP Choice"
	// x-required
	// x-example: "Internet VIP Choice"
	// Internet VIP Choice
	//
	// Types that are valid to be assigned to InternetVipChoice:
	//	*VSiteRefType_DisableInternetVip
	//	*VSiteRefType_EnableInternetVip
	InternetVipChoice isVSiteRefType_InternetVipChoice `protobuf_oneof:"internet_vip_choice"`
	// Virtual Network Reference
	//
	// x-displayName: "Virtual Network Reference"
	// Reference to virtual network
	Refs []*ObjectRefType `protobuf:"bytes,7,rep,name=refs,proto3" json:"refs,omitempty"`
}

func (m *VSiteRefType) Reset()      { *m = VSiteRefType{} }
func (*VSiteRefType) ProtoMessage() {}
func (*VSiteRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{30}
}
func (m *VSiteRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VSiteRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VSiteRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VSiteRefType.Merge(m, src)
}
func (m *VSiteRefType) XXX_Size() int {
	return m.Size()
}
func (m *VSiteRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_VSiteRefType.DiscardUnknown(m)
}

var xxx_messageInfo_VSiteRefType proto.InternalMessageInfo

type isVSiteRefType_InternetVipChoice interface {
	isVSiteRefType_InternetVipChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type VSiteRefType_DisableInternetVip struct {
	DisableInternetVip *Empty `protobuf:"bytes,6,opt,name=disable_internet_vip,json=disableInternetVip,proto3,oneof" json:"disable_internet_vip,omitempty"`
}
type VSiteRefType_EnableInternetVip struct {
	EnableInternetVip *Empty `protobuf:"bytes,5,opt,name=enable_internet_vip,json=enableInternetVip,proto3,oneof" json:"enable_internet_vip,omitempty"`
}

func (*VSiteRefType_DisableInternetVip) isVSiteRefType_InternetVipChoice() {}
func (*VSiteRefType_EnableInternetVip) isVSiteRefType_InternetVipChoice()  {}

func (m *VSiteRefType) GetInternetVipChoice() isVSiteRefType_InternetVipChoice {
	if m != nil {
		return m.InternetVipChoice
	}
	return nil
}

func (m *VSiteRefType) GetRef() []*ObjectRefType {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *VSiteRefType) GetNetworkType() VirtualNetworkType {
	if m != nil {
		return m.NetworkType
	}
	return VIRTUAL_NETWORK_SITE_LOCAL
}

func (m *VSiteRefType) GetDisableInternetVip() *Empty {
	if x, ok := m.GetInternetVipChoice().(*VSiteRefType_DisableInternetVip); ok {
		return x.DisableInternetVip
	}
	return nil
}

func (m *VSiteRefType) GetEnableInternetVip() *Empty {
	if x, ok := m.GetInternetVipChoice().(*VSiteRefType_EnableInternetVip); ok {
		return x.EnableInternetVip
	}
	return nil
}

func (m *VSiteRefType) GetRefs() []*ObjectRefType {
	if m != nil {
		return m.Refs
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VSiteRefType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VSiteRefType_DisableInternetVip)(nil),
		(*VSiteRefType_EnableInternetVip)(nil),
	}
}

// PolicerRefType
//
// x-displayName: "Policer Reference"
// Reference to policer object
type PolicerRefType struct {
	// ref
	//
	// x-displayName: "Reference"
	// A policer direct reference
	Ref []*ObjectRefType `protobuf:"bytes,1,rep,name=ref,proto3" json:"ref,omitempty"`
}

func (m *PolicerRefType) Reset()      { *m = PolicerRefType{} }
func (*PolicerRefType) ProtoMessage() {}
func (*PolicerRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{31}
}
func (m *PolicerRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicerRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PolicerRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicerRefType.Merge(m, src)
}
func (m *PolicerRefType) XXX_Size() int {
	return m.Size()
}
func (m *PolicerRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicerRefType.DiscardUnknown(m)
}

var xxx_messageInfo_PolicerRefType proto.InternalMessageInfo

func (m *PolicerRefType) GetRef() []*ObjectRefType {
	if m != nil {
		return m.Ref
	}
	return nil
}

// ProtocolPolicerRefType
//
// x-displayName: "Protocol Policer Reference"
// Reference to policer object
type ProtocolPolicerRefType struct {
	// ref
	//
	// x-displayName: "Protocol policer Reference"
	// Reference to protocol policer object
	Ref []*ObjectRefType `protobuf:"bytes,1,rep,name=ref,proto3" json:"ref,omitempty"`
}

func (m *ProtocolPolicerRefType) Reset()      { *m = ProtocolPolicerRefType{} }
func (*ProtocolPolicerRefType) ProtoMessage() {}
func (*ProtocolPolicerRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{32}
}
func (m *ProtocolPolicerRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtocolPolicerRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProtocolPolicerRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtocolPolicerRefType.Merge(m, src)
}
func (m *ProtocolPolicerRefType) XXX_Size() int {
	return m.Size()
}
func (m *ProtocolPolicerRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtocolPolicerRefType.DiscardUnknown(m)
}

var xxx_messageInfo_ProtocolPolicerRefType proto.InternalMessageInfo

func (m *ProtocolPolicerRefType) GetRef() []*ObjectRefType {
	if m != nil {
		return m.Ref
	}
	return nil
}

// NetworkSiteRefSelector
//
// x-displayName: "Network or Site Reference"
// NetworkSiteRefSelector defines a union of reference to site or reference to virtual_network  or reference to virtual_site
// It is used to determine virtual network using following rules
//   - Direct reference to virtual_network object
//   - Site local network when refering to site object
//   - All site local networks for sites selected by refering to virtual_site object
type NetworkSiteRefSelector struct {
	// ref_or_selector
	//
	// x-displayName: "Virtual-Site or Site or Network"
	// x-required
	// One of following
	//
	// Types that are valid to be assigned to RefOrSelector:
	//	*NetworkSiteRefSelector_VirtualNetwork
	//	*NetworkSiteRefSelector_Site
	//	*NetworkSiteRefSelector_VirtualSite
	RefOrSelector isNetworkSiteRefSelector_RefOrSelector `protobuf_oneof:"ref_or_selector"`
}

func (m *NetworkSiteRefSelector) Reset()      { *m = NetworkSiteRefSelector{} }
func (*NetworkSiteRefSelector) ProtoMessage() {}
func (*NetworkSiteRefSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{33}
}
func (m *NetworkSiteRefSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkSiteRefSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NetworkSiteRefSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkSiteRefSelector.Merge(m, src)
}
func (m *NetworkSiteRefSelector) XXX_Size() int {
	return m.Size()
}
func (m *NetworkSiteRefSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkSiteRefSelector.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkSiteRefSelector proto.InternalMessageInfo

type isNetworkSiteRefSelector_RefOrSelector interface {
	isNetworkSiteRefSelector_RefOrSelector()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type NetworkSiteRefSelector_VirtualNetwork struct {
	VirtualNetwork *NetworkRefType `protobuf:"bytes,1,opt,name=virtual_network,json=virtualNetwork,proto3,oneof" json:"virtual_network,omitempty"`
}
type NetworkSiteRefSelector_Site struct {
	Site *SiteRefType `protobuf:"bytes,2,opt,name=site,proto3,oneof" json:"site,omitempty"`
}
type NetworkSiteRefSelector_VirtualSite struct {
	VirtualSite *VSiteRefType `protobuf:"bytes,3,opt,name=virtual_site,json=virtualSite,proto3,oneof" json:"virtual_site,omitempty"`
}

func (*NetworkSiteRefSelector_VirtualNetwork) isNetworkSiteRefSelector_RefOrSelector() {}
func (*NetworkSiteRefSelector_Site) isNetworkSiteRefSelector_RefOrSelector()           {}
func (*NetworkSiteRefSelector_VirtualSite) isNetworkSiteRefSelector_RefOrSelector()    {}

func (m *NetworkSiteRefSelector) GetRefOrSelector() isNetworkSiteRefSelector_RefOrSelector {
	if m != nil {
		return m.RefOrSelector
	}
	return nil
}

func (m *NetworkSiteRefSelector) GetVirtualNetwork() *NetworkRefType {
	if x, ok := m.GetRefOrSelector().(*NetworkSiteRefSelector_VirtualNetwork); ok {
		return x.VirtualNetwork
	}
	return nil
}

func (m *NetworkSiteRefSelector) GetSite() *SiteRefType {
	if x, ok := m.GetRefOrSelector().(*NetworkSiteRefSelector_Site); ok {
		return x.Site
	}
	return nil
}

func (m *NetworkSiteRefSelector) GetVirtualSite() *VSiteRefType {
	if x, ok := m.GetRefOrSelector().(*NetworkSiteRefSelector_VirtualSite); ok {
		return x.VirtualSite
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*NetworkSiteRefSelector) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*NetworkSiteRefSelector_VirtualNetwork)(nil),
		(*NetworkSiteRefSelector_Site)(nil),
		(*NetworkSiteRefSelector_VirtualSite)(nil),
	}
}

// SiteVirtualSiteRefSelector
//
// x-displayName: "Site or Virtual Site Reference"
// VirtualSiteSiteRefSelector defines a union of reference to site  or reference to virtual_site
// It used to refer site or a group of sites indicated by virtual site.
type SiteVirtualSiteRefSelector struct {
	// ref_or_selector
	//
	// x-displayName: "Direct/Selector Reference"
	// x-required
	// One of following
	//
	// Types that are valid to be assigned to RefOrSelector:
	//	*SiteVirtualSiteRefSelector_Site
	//	*SiteVirtualSiteRefSelector_VirtualSite
	RefOrSelector isSiteVirtualSiteRefSelector_RefOrSelector `protobuf_oneof:"ref_or_selector"`
}

func (m *SiteVirtualSiteRefSelector) Reset()      { *m = SiteVirtualSiteRefSelector{} }
func (*SiteVirtualSiteRefSelector) ProtoMessage() {}
func (*SiteVirtualSiteRefSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{34}
}
func (m *SiteVirtualSiteRefSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SiteVirtualSiteRefSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SiteVirtualSiteRefSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SiteVirtualSiteRefSelector.Merge(m, src)
}
func (m *SiteVirtualSiteRefSelector) XXX_Size() int {
	return m.Size()
}
func (m *SiteVirtualSiteRefSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_SiteVirtualSiteRefSelector.DiscardUnknown(m)
}

var xxx_messageInfo_SiteVirtualSiteRefSelector proto.InternalMessageInfo

type isSiteVirtualSiteRefSelector_RefOrSelector interface {
	isSiteVirtualSiteRefSelector_RefOrSelector()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SiteVirtualSiteRefSelector_Site struct {
	Site *SiteRefType `protobuf:"bytes,2,opt,name=site,proto3,oneof" json:"site,omitempty"`
}
type SiteVirtualSiteRefSelector_VirtualSite struct {
	VirtualSite *VSiteRefType `protobuf:"bytes,3,opt,name=virtual_site,json=virtualSite,proto3,oneof" json:"virtual_site,omitempty"`
}

func (*SiteVirtualSiteRefSelector_Site) isSiteVirtualSiteRefSelector_RefOrSelector()        {}
func (*SiteVirtualSiteRefSelector_VirtualSite) isSiteVirtualSiteRefSelector_RefOrSelector() {}

func (m *SiteVirtualSiteRefSelector) GetRefOrSelector() isSiteVirtualSiteRefSelector_RefOrSelector {
	if m != nil {
		return m.RefOrSelector
	}
	return nil
}

func (m *SiteVirtualSiteRefSelector) GetSite() *SiteRefType {
	if x, ok := m.GetRefOrSelector().(*SiteVirtualSiteRefSelector_Site); ok {
		return x.Site
	}
	return nil
}

func (m *SiteVirtualSiteRefSelector) GetVirtualSite() *VSiteRefType {
	if x, ok := m.GetRefOrSelector().(*SiteVirtualSiteRefSelector_VirtualSite); ok {
		return x.VirtualSite
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SiteVirtualSiteRefSelector) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SiteVirtualSiteRefSelector_Site)(nil),
		(*SiteVirtualSiteRefSelector_VirtualSite)(nil),
	}
}

// HeaderManipulationOptionType
//
// x-displayName: "Header Manipulation Option"
// HTTP header is a key-value pair.
// The name acts as key of HTTP header
// The value acts as the data/value of HTTP header
// Example HTTP header
//
//	Host: user.volterra.com
//
// In the above example, Host is the name or key of HTTP header
// In the above example, user.volterra.com is the value of HTTP header
type HeaderManipulationOptionType struct {
	// name
	//
	// x-displayName: "Name"
	// x-example: "value"
	// x-required
	// Name of the HTTP header.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// value
	//
	// x-displayName: "Value or Secret"
	// x-required
	// Enter Header value as string or blindfolded secret.
	//
	// Types that are valid to be assigned to ValueChoice:
	//	*HeaderManipulationOptionType_Value
	//	*HeaderManipulationOptionType_SecretValue
	ValueChoice isHeaderManipulationOptionType_ValueChoice `protobuf_oneof:"value_choice"`
	// append
	//
	// x-displayName: "Append"
	// Should the value be appended? If true, the value is appended to existing values.
	// Default value is do not append
	Append bool `protobuf:"varint,3,opt,name=append,proto3" json:"append,omitempty"`
}

func (m *HeaderManipulationOptionType) Reset()      { *m = HeaderManipulationOptionType{} }
func (*HeaderManipulationOptionType) ProtoMessage() {}
func (*HeaderManipulationOptionType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{35}
}
func (m *HeaderManipulationOptionType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeaderManipulationOptionType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HeaderManipulationOptionType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeaderManipulationOptionType.Merge(m, src)
}
func (m *HeaderManipulationOptionType) XXX_Size() int {
	return m.Size()
}
func (m *HeaderManipulationOptionType) XXX_DiscardUnknown() {
	xxx_messageInfo_HeaderManipulationOptionType.DiscardUnknown(m)
}

var xxx_messageInfo_HeaderManipulationOptionType proto.InternalMessageInfo

type isHeaderManipulationOptionType_ValueChoice interface {
	isHeaderManipulationOptionType_ValueChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type HeaderManipulationOptionType_Value struct {
	Value string `protobuf:"bytes,2,opt,name=value,proto3,oneof" json:"value,omitempty"`
}
type HeaderManipulationOptionType_SecretValue struct {
	SecretValue *SecretType `protobuf:"bytes,5,opt,name=secret_value,json=secretValue,proto3,oneof" json:"secret_value,omitempty"`
}

func (*HeaderManipulationOptionType_Value) isHeaderManipulationOptionType_ValueChoice()       {}
func (*HeaderManipulationOptionType_SecretValue) isHeaderManipulationOptionType_ValueChoice() {}

func (m *HeaderManipulationOptionType) GetValueChoice() isHeaderManipulationOptionType_ValueChoice {
	if m != nil {
		return m.ValueChoice
	}
	return nil
}

func (m *HeaderManipulationOptionType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HeaderManipulationOptionType) GetValue() string {
	if x, ok := m.GetValueChoice().(*HeaderManipulationOptionType_Value); ok {
		return x.Value
	}
	return ""
}

func (m *HeaderManipulationOptionType) GetSecretValue() *SecretType {
	if x, ok := m.GetValueChoice().(*HeaderManipulationOptionType_SecretValue); ok {
		return x.SecretValue
	}
	return nil
}

func (m *HeaderManipulationOptionType) GetAppend() bool {
	if m != nil {
		return m.Append
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HeaderManipulationOptionType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HeaderManipulationOptionType_Value)(nil),
		(*HeaderManipulationOptionType_SecretValue)(nil),
	}
}

// CookieManipulationOptionType
//
// x-displayName: "Cookie Protection"
// Set Cookie protection attributes.
type CookieManipulationOptionType struct {
	// name
	//
	// x-displayName: "Cookie Name"
	// x-example: "value"
	// x-required
	// Name of the Cookie
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// samesite
	//
	// x-displayName: "SameSite"
	// Controls whether or not a cookie is sent with cross-site requests
	//
	// Types that are valid to be assigned to Samesite:
	//	*CookieManipulationOptionType_IgnoreSamesite
	//	*CookieManipulationOptionType_SamesiteStrict
	//	*CookieManipulationOptionType_SamesiteLax
	//	*CookieManipulationOptionType_SamesiteNone
	Samesite isCookieManipulationOptionType_Samesite `protobuf_oneof:"samesite"`
	// secure
	//
	// x-displayName: "Secure"
	// A cookie with the Secure attribute is only sent to the server with an
	// encrypted request over the HTTPS protocol and therefore, is more
	// resistant to man-in-the-middle attacks.
	//
	// Types that are valid to be assigned to Secure:
	//	*CookieManipulationOptionType_IgnoreSecure
	//	*CookieManipulationOptionType_AddSecure
	Secure isCookieManipulationOptionType_Secure `protobuf_oneof:"secure"`
	// httponly
	//
	// x-displayName: "HttpOnly"
	// A cookie with the HttpOnly attribute is inaccessible to the JavaScript.
	//
	// Types that are valid to be assigned to Httponly:
	//	*CookieManipulationOptionType_IgnoreHttponly
	//	*CookieManipulationOptionType_AddHttponly
	Httponly isCookieManipulationOptionType_Httponly `protobuf_oneof:"httponly"`
	// max_age
	//
	// x-displayName: "Max Age"
	// Enter the maximum age in minutes for session cookies after which cookies are automatically expired
	//
	// Types that are valid to be assigned to MaxAge:
	//	*CookieManipulationOptionType_IgnoreMaxAge
	//	*CookieManipulationOptionType_MaxAgeValue
	MaxAge isCookieManipulationOptionType_MaxAge `protobuf_oneof:"max_age"`
	// cookie_tampering
	//
	// x-displayName: "Cookie Tampering Protection"
	// x-required
	// Cookie Tampering Protection prevents attackers from modifying the value of session cookies.
	// To use this feature, Web Application Firewall must be enabled.
	//
	// Types that are valid to be assigned to CookieTampering:
	//	*CookieManipulationOptionType_DisableTamperingProtection
	//	*CookieManipulationOptionType_EnableTamperingProtection
	CookieTampering isCookieManipulationOptionType_CookieTampering `protobuf_oneof:"cookie_tampering"`
}

func (m *CookieManipulationOptionType) Reset()      { *m = CookieManipulationOptionType{} }
func (*CookieManipulationOptionType) ProtoMessage() {}
func (*CookieManipulationOptionType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{36}
}
func (m *CookieManipulationOptionType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CookieManipulationOptionType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CookieManipulationOptionType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CookieManipulationOptionType.Merge(m, src)
}
func (m *CookieManipulationOptionType) XXX_Size() int {
	return m.Size()
}
func (m *CookieManipulationOptionType) XXX_DiscardUnknown() {
	xxx_messageInfo_CookieManipulationOptionType.DiscardUnknown(m)
}

var xxx_messageInfo_CookieManipulationOptionType proto.InternalMessageInfo

type isCookieManipulationOptionType_Samesite interface {
	isCookieManipulationOptionType_Samesite()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCookieManipulationOptionType_Secure interface {
	isCookieManipulationOptionType_Secure()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCookieManipulationOptionType_Httponly interface {
	isCookieManipulationOptionType_Httponly()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCookieManipulationOptionType_MaxAge interface {
	isCookieManipulationOptionType_MaxAge()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isCookieManipulationOptionType_CookieTampering interface {
	isCookieManipulationOptionType_CookieTampering()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CookieManipulationOptionType_IgnoreSamesite struct {
	IgnoreSamesite *Empty `protobuf:"bytes,15,opt,name=ignore_samesite,json=ignoreSamesite,proto3,oneof" json:"ignore_samesite,omitempty"`
}
type CookieManipulationOptionType_SamesiteStrict struct {
	SamesiteStrict *Empty `protobuf:"bytes,3,opt,name=samesite_strict,json=samesiteStrict,proto3,oneof" json:"samesite_strict,omitempty"`
}
type CookieManipulationOptionType_SamesiteLax struct {
	SamesiteLax *Empty `protobuf:"bytes,4,opt,name=samesite_lax,json=samesiteLax,proto3,oneof" json:"samesite_lax,omitempty"`
}
type CookieManipulationOptionType_SamesiteNone struct {
	SamesiteNone *Empty `protobuf:"bytes,5,opt,name=samesite_none,json=samesiteNone,proto3,oneof" json:"samesite_none,omitempty"`
}
type CookieManipulationOptionType_IgnoreSecure struct {
	IgnoreSecure *Empty `protobuf:"bytes,7,opt,name=ignore_secure,json=ignoreSecure,proto3,oneof" json:"ignore_secure,omitempty"`
}
type CookieManipulationOptionType_AddSecure struct {
	AddSecure *Empty `protobuf:"bytes,8,opt,name=add_secure,json=addSecure,proto3,oneof" json:"add_secure,omitempty"`
}
type CookieManipulationOptionType_IgnoreHttponly struct {
	IgnoreHttponly *Empty `protobuf:"bytes,10,opt,name=ignore_httponly,json=ignoreHttponly,proto3,oneof" json:"ignore_httponly,omitempty"`
}
type CookieManipulationOptionType_AddHttponly struct {
	AddHttponly *Empty `protobuf:"bytes,11,opt,name=add_httponly,json=addHttponly,proto3,oneof" json:"add_httponly,omitempty"`
}
type CookieManipulationOptionType_IgnoreMaxAge struct {
	IgnoreMaxAge *Empty `protobuf:"bytes,13,opt,name=ignore_max_age,json=ignoreMaxAge,proto3,oneof" json:"ignore_max_age,omitempty"`
}
type CookieManipulationOptionType_MaxAgeValue struct {
	MaxAgeValue int32 `protobuf:"varint,14,opt,name=max_age_value,json=maxAgeValue,proto3,oneof" json:"max_age_value,omitempty"`
}
type CookieManipulationOptionType_DisableTamperingProtection struct {
	DisableTamperingProtection *Empty `protobuf:"bytes,17,opt,name=disable_tampering_protection,json=disableTamperingProtection,proto3,oneof" json:"disable_tampering_protection,omitempty"`
}
type CookieManipulationOptionType_EnableTamperingProtection struct {
	EnableTamperingProtection *Empty `protobuf:"bytes,19,opt,name=enable_tampering_protection,json=enableTamperingProtection,proto3,oneof" json:"enable_tampering_protection,omitempty"`
}

func (*CookieManipulationOptionType_IgnoreSamesite) isCookieManipulationOptionType_Samesite() {}
func (*CookieManipulationOptionType_SamesiteStrict) isCookieManipulationOptionType_Samesite() {}
func (*CookieManipulationOptionType_SamesiteLax) isCookieManipulationOptionType_Samesite()    {}
func (*CookieManipulationOptionType_SamesiteNone) isCookieManipulationOptionType_Samesite()   {}
func (*CookieManipulationOptionType_IgnoreSecure) isCookieManipulationOptionType_Secure()     {}
func (*CookieManipulationOptionType_AddSecure) isCookieManipulationOptionType_Secure()        {}
func (*CookieManipulationOptionType_IgnoreHttponly) isCookieManipulationOptionType_Httponly() {}
func (*CookieManipulationOptionType_AddHttponly) isCookieManipulationOptionType_Httponly()    {}
func (*CookieManipulationOptionType_IgnoreMaxAge) isCookieManipulationOptionType_MaxAge()     {}
func (*CookieManipulationOptionType_MaxAgeValue) isCookieManipulationOptionType_MaxAge()      {}
func (*CookieManipulationOptionType_DisableTamperingProtection) isCookieManipulationOptionType_CookieTampering() {
}
func (*CookieManipulationOptionType_EnableTamperingProtection) isCookieManipulationOptionType_CookieTampering() {
}

func (m *CookieManipulationOptionType) GetSamesite() isCookieManipulationOptionType_Samesite {
	if m != nil {
		return m.Samesite
	}
	return nil
}
func (m *CookieManipulationOptionType) GetSecure() isCookieManipulationOptionType_Secure {
	if m != nil {
		return m.Secure
	}
	return nil
}
func (m *CookieManipulationOptionType) GetHttponly() isCookieManipulationOptionType_Httponly {
	if m != nil {
		return m.Httponly
	}
	return nil
}
func (m *CookieManipulationOptionType) GetMaxAge() isCookieManipulationOptionType_MaxAge {
	if m != nil {
		return m.MaxAge
	}
	return nil
}
func (m *CookieManipulationOptionType) GetCookieTampering() isCookieManipulationOptionType_CookieTampering {
	if m != nil {
		return m.CookieTampering
	}
	return nil
}

func (m *CookieManipulationOptionType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CookieManipulationOptionType) GetIgnoreSamesite() *Empty {
	if x, ok := m.GetSamesite().(*CookieManipulationOptionType_IgnoreSamesite); ok {
		return x.IgnoreSamesite
	}
	return nil
}

func (m *CookieManipulationOptionType) GetSamesiteStrict() *Empty {
	if x, ok := m.GetSamesite().(*CookieManipulationOptionType_SamesiteStrict); ok {
		return x.SamesiteStrict
	}
	return nil
}

func (m *CookieManipulationOptionType) GetSamesiteLax() *Empty {
	if x, ok := m.GetSamesite().(*CookieManipulationOptionType_SamesiteLax); ok {
		return x.SamesiteLax
	}
	return nil
}

func (m *CookieManipulationOptionType) GetSamesiteNone() *Empty {
	if x, ok := m.GetSamesite().(*CookieManipulationOptionType_SamesiteNone); ok {
		return x.SamesiteNone
	}
	return nil
}

func (m *CookieManipulationOptionType) GetIgnoreSecure() *Empty {
	if x, ok := m.GetSecure().(*CookieManipulationOptionType_IgnoreSecure); ok {
		return x.IgnoreSecure
	}
	return nil
}

func (m *CookieManipulationOptionType) GetAddSecure() *Empty {
	if x, ok := m.GetSecure().(*CookieManipulationOptionType_AddSecure); ok {
		return x.AddSecure
	}
	return nil
}

func (m *CookieManipulationOptionType) GetIgnoreHttponly() *Empty {
	if x, ok := m.GetHttponly().(*CookieManipulationOptionType_IgnoreHttponly); ok {
		return x.IgnoreHttponly
	}
	return nil
}

func (m *CookieManipulationOptionType) GetAddHttponly() *Empty {
	if x, ok := m.GetHttponly().(*CookieManipulationOptionType_AddHttponly); ok {
		return x.AddHttponly
	}
	return nil
}

func (m *CookieManipulationOptionType) GetIgnoreMaxAge() *Empty {
	if x, ok := m.GetMaxAge().(*CookieManipulationOptionType_IgnoreMaxAge); ok {
		return x.IgnoreMaxAge
	}
	return nil
}

func (m *CookieManipulationOptionType) GetMaxAgeValue() int32 {
	if x, ok := m.GetMaxAge().(*CookieManipulationOptionType_MaxAgeValue); ok {
		return x.MaxAgeValue
	}
	return 0
}

func (m *CookieManipulationOptionType) GetDisableTamperingProtection() *Empty {
	if x, ok := m.GetCookieTampering().(*CookieManipulationOptionType_DisableTamperingProtection); ok {
		return x.DisableTamperingProtection
	}
	return nil
}

func (m *CookieManipulationOptionType) GetEnableTamperingProtection() *Empty {
	if x, ok := m.GetCookieTampering().(*CookieManipulationOptionType_EnableTamperingProtection); ok {
		return x.EnableTamperingProtection
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CookieManipulationOptionType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CookieManipulationOptionType_IgnoreSamesite)(nil),
		(*CookieManipulationOptionType_SamesiteStrict)(nil),
		(*CookieManipulationOptionType_SamesiteLax)(nil),
		(*CookieManipulationOptionType_SamesiteNone)(nil),
		(*CookieManipulationOptionType_IgnoreSecure)(nil),
		(*CookieManipulationOptionType_AddSecure)(nil),
		(*CookieManipulationOptionType_IgnoreHttponly)(nil),
		(*CookieManipulationOptionType_AddHttponly)(nil),
		(*CookieManipulationOptionType_IgnoreMaxAge)(nil),
		(*CookieManipulationOptionType_MaxAgeValue)(nil),
		(*CookieManipulationOptionType_DisableTamperingProtection)(nil),
		(*CookieManipulationOptionType_EnableTamperingProtection)(nil),
	}
}

// Root CA Certificate
//
// x-displayName: "Root CA Certificate Reference"
// Reference to Root CA Certificate
type TrustedCAList struct {
	// Root CA Certificate
	//
	// x-displayName: "Root CA Certificate Reference"
	// Reference to Root CA Certificate
	TrustedCaList []*ObjectRefType `protobuf:"bytes,1,rep,name=trusted_ca_list,json=trustedCaList,proto3" json:"trusted_ca_list,omitempty"`
}

func (m *TrustedCAList) Reset()      { *m = TrustedCAList{} }
func (*TrustedCAList) ProtoMessage() {}
func (*TrustedCAList) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{37}
}
func (m *TrustedCAList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrustedCAList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TrustedCAList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrustedCAList.Merge(m, src)
}
func (m *TrustedCAList) XXX_Size() int {
	return m.Size()
}
func (m *TrustedCAList) XXX_DiscardUnknown() {
	xxx_messageInfo_TrustedCAList.DiscardUnknown(m)
}

var xxx_messageInfo_TrustedCAList proto.InternalMessageInfo

func (m *TrustedCAList) GetTrustedCaList() []*ObjectRefType {
	if m != nil {
		return m.TrustedCaList
	}
	return nil
}

// TlsValidationParamsType
//
// x-displayName: "TLS Certificate Validation Parameters"
// This includes URL for a trust store, whether SAN verification is required
// and list of Subject Alt Names for verification
type TlsValidationParamsType struct {
	// trusted_ca_choice
	//
	// x-displayName: "Root CA Certificate"
	// x-required
	// Root CA configuration for downstream TLS connections
	//
	// Types that are valid to be assigned to TrustedCaChoice:
	//	*TlsValidationParamsType_TrustedCaUrl
	//	*TlsValidationParamsType_TrustedCa
	TrustedCaChoice isTlsValidationParamsType_TrustedCaChoice `protobuf_oneof:"trusted_ca_choice"`
	// skip_hostname_verification
	//
	// x-displayName: "Skip verification of hostname"
	// When True, skip verification of hostname i.e. CN/Subject Alt Name of certificate
	// is not matched to the connecting hostname
	SkipHostnameVerification bool `protobuf:"varint,2,opt,name=skip_hostname_verification,json=skipHostnameVerification,proto3" json:"skip_hostname_verification,omitempty"`
	// verify_subject_alt_names
	//
	// x-displayName: "List of SANs for matching"
	// x-example: "value"
	// List of acceptable Subject Alt Names/CN in the peer's certificate.
	// When skip_hostname_verification is false and verify_subject_alt_names is empty,
	// the hostname of the peer will be used for matching against SAN/CN of peer's certificate
	VerifySubjectAltNames []string `protobuf:"bytes,3,rep,name=verify_subject_alt_names,json=verifySubjectAltNames,proto3" json:"verify_subject_alt_names,omitempty"`
	// use_volterra_trusted_ca_url
	//
	// x-displayName: "Use F5XC CA Certificate for hostname verification"
	// Use the F5XC default Root CA URL from the global config for hostname verification.
	UseVolterraTrustedCaUrl bool `protobuf:"varint,4,opt,name=use_volterra_trusted_ca_url,json=useVolterraTrustedCaUrl,proto3" json:"use_volterra_trusted_ca_url,omitempty"`
}

func (m *TlsValidationParamsType) Reset()      { *m = TlsValidationParamsType{} }
func (*TlsValidationParamsType) ProtoMessage() {}
func (*TlsValidationParamsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{38}
}
func (m *TlsValidationParamsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TlsValidationParamsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TlsValidationParamsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TlsValidationParamsType.Merge(m, src)
}
func (m *TlsValidationParamsType) XXX_Size() int {
	return m.Size()
}
func (m *TlsValidationParamsType) XXX_DiscardUnknown() {
	xxx_messageInfo_TlsValidationParamsType.DiscardUnknown(m)
}

var xxx_messageInfo_TlsValidationParamsType proto.InternalMessageInfo

type isTlsValidationParamsType_TrustedCaChoice interface {
	isTlsValidationParamsType_TrustedCaChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type TlsValidationParamsType_TrustedCaUrl struct {
	TrustedCaUrl string `protobuf:"bytes,1,opt,name=trusted_ca_url,json=trustedCaUrl,proto3,oneof" json:"trusted_ca_url,omitempty"`
}
type TlsValidationParamsType_TrustedCa struct {
	TrustedCa *TrustedCAList `protobuf:"bytes,6,opt,name=trusted_ca,json=trustedCa,proto3,oneof" json:"trusted_ca,omitempty"`
}

func (*TlsValidationParamsType_TrustedCaUrl) isTlsValidationParamsType_TrustedCaChoice() {}
func (*TlsValidationParamsType_TrustedCa) isTlsValidationParamsType_TrustedCaChoice()    {}

func (m *TlsValidationParamsType) GetTrustedCaChoice() isTlsValidationParamsType_TrustedCaChoice {
	if m != nil {
		return m.TrustedCaChoice
	}
	return nil
}

func (m *TlsValidationParamsType) GetTrustedCaUrl() string {
	if x, ok := m.GetTrustedCaChoice().(*TlsValidationParamsType_TrustedCaUrl); ok {
		return x.TrustedCaUrl
	}
	return ""
}

func (m *TlsValidationParamsType) GetTrustedCa() *TrustedCAList {
	if x, ok := m.GetTrustedCaChoice().(*TlsValidationParamsType_TrustedCa); ok {
		return x.TrustedCa
	}
	return nil
}

func (m *TlsValidationParamsType) GetSkipHostnameVerification() bool {
	if m != nil {
		return m.SkipHostnameVerification
	}
	return false
}

func (m *TlsValidationParamsType) GetVerifySubjectAltNames() []string {
	if m != nil {
		return m.VerifySubjectAltNames
	}
	return nil
}

func (m *TlsValidationParamsType) GetUseVolterraTrustedCaUrl() bool {
	if m != nil {
		return m.UseVolterraTrustedCaUrl
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TlsValidationParamsType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TlsValidationParamsType_TrustedCaUrl)(nil),
		(*TlsValidationParamsType_TrustedCa)(nil),
	}
}

// HashAlgorithms
//
// x-displayName: "Hash Algorithms"
// Specifies the hash algorithms to be used
type HashAlgorithms struct {
	// Hash Algorithms
	//
	// x-displayName: "Hash Algorithms"
	// x-required
	// Ordered list of hash algorithms to be used.
	HashAlgorithms []HashAlgorithm `protobuf:"varint,1,rep,packed,name=hash_algorithms,json=hashAlgorithms,proto3,enum=ves.io.schema.HashAlgorithm" json:"hash_algorithms,omitempty"`
}

func (m *HashAlgorithms) Reset()      { *m = HashAlgorithms{} }
func (*HashAlgorithms) ProtoMessage() {}
func (*HashAlgorithms) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{39}
}
func (m *HashAlgorithms) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HashAlgorithms) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HashAlgorithms) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HashAlgorithms.Merge(m, src)
}
func (m *HashAlgorithms) XXX_Size() int {
	return m.Size()
}
func (m *HashAlgorithms) XXX_DiscardUnknown() {
	xxx_messageInfo_HashAlgorithms.DiscardUnknown(m)
}

var xxx_messageInfo_HashAlgorithms proto.InternalMessageInfo

func (m *HashAlgorithms) GetHashAlgorithms() []HashAlgorithm {
	if m != nil {
		return m.HashAlgorithms
	}
	return nil
}

// TlsCertificateType
//
// x-displayName: "TLS Certificate"
// Handle to fetch certificate and key
type TlsCertificateType struct {
	// certificate_url
	//
	// x-displayName: "Certificate"
	// x-example: "value"
	// x-required
	// TLS certificate.
	// Certificate or certificate chain in PEM format including the PEM headers.
	CertificateUrl string `protobuf:"bytes,1,opt,name=certificate_url,json=certificateUrl,proto3" json:"certificate_url,omitempty"`
	// private_key
	//
	// x-displayName: "Private Key"
	// x-required
	// TLS Private Key data in unencrypted PEM format including the PEM headers. The data may be optionally secured using BlindFold. TLS key has to match the accompanying certificate.
	PrivateKey *SecretType `protobuf:"bytes,4,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	// description
	//
	// x-displayName: "Description"
	// x-example: "Certificate used in production environment"
	// Description for the certificate
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	// OCSP Response choice
	//
	// x-displayName: "OCSP Stapling choice"
	// OCSP Stapling choice
	//
	// Types that are valid to be assigned to OcspStaplingChoice:
	//	*TlsCertificateType_UseSystemDefaults
	//	*TlsCertificateType_DisableOcspStapling
	//	*TlsCertificateType_CustomHashAlgorithms
	OcspStaplingChoice isTlsCertificateType_OcspStaplingChoice `protobuf_oneof:"ocsp_stapling_choice"`
}

func (m *TlsCertificateType) Reset()      { *m = TlsCertificateType{} }
func (*TlsCertificateType) ProtoMessage() {}
func (*TlsCertificateType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{40}
}
func (m *TlsCertificateType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TlsCertificateType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TlsCertificateType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TlsCertificateType.Merge(m, src)
}
func (m *TlsCertificateType) XXX_Size() int {
	return m.Size()
}
func (m *TlsCertificateType) XXX_DiscardUnknown() {
	xxx_messageInfo_TlsCertificateType.DiscardUnknown(m)
}

var xxx_messageInfo_TlsCertificateType proto.InternalMessageInfo

type isTlsCertificateType_OcspStaplingChoice interface {
	isTlsCertificateType_OcspStaplingChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type TlsCertificateType_UseSystemDefaults struct {
	UseSystemDefaults *Empty `protobuf:"bytes,7,opt,name=use_system_defaults,json=useSystemDefaults,proto3,oneof" json:"use_system_defaults,omitempty"`
}
type TlsCertificateType_DisableOcspStapling struct {
	DisableOcspStapling *Empty `protobuf:"bytes,8,opt,name=disable_ocsp_stapling,json=disableOcspStapling,proto3,oneof" json:"disable_ocsp_stapling,omitempty"`
}
type TlsCertificateType_CustomHashAlgorithms struct {
	CustomHashAlgorithms *HashAlgorithms `protobuf:"bytes,9,opt,name=custom_hash_algorithms,json=customHashAlgorithms,proto3,oneof" json:"custom_hash_algorithms,omitempty"`
}

func (*TlsCertificateType_UseSystemDefaults) isTlsCertificateType_OcspStaplingChoice()    {}
func (*TlsCertificateType_DisableOcspStapling) isTlsCertificateType_OcspStaplingChoice()  {}
func (*TlsCertificateType_CustomHashAlgorithms) isTlsCertificateType_OcspStaplingChoice() {}

func (m *TlsCertificateType) GetOcspStaplingChoice() isTlsCertificateType_OcspStaplingChoice {
	if m != nil {
		return m.OcspStaplingChoice
	}
	return nil
}

func (m *TlsCertificateType) GetCertificateUrl() string {
	if m != nil {
		return m.CertificateUrl
	}
	return ""
}

func (m *TlsCertificateType) GetPrivateKey() *SecretType {
	if m != nil {
		return m.PrivateKey
	}
	return nil
}

func (m *TlsCertificateType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *TlsCertificateType) GetUseSystemDefaults() *Empty {
	if x, ok := m.GetOcspStaplingChoice().(*TlsCertificateType_UseSystemDefaults); ok {
		return x.UseSystemDefaults
	}
	return nil
}

func (m *TlsCertificateType) GetDisableOcspStapling() *Empty {
	if x, ok := m.GetOcspStaplingChoice().(*TlsCertificateType_DisableOcspStapling); ok {
		return x.DisableOcspStapling
	}
	return nil
}

func (m *TlsCertificateType) GetCustomHashAlgorithms() *HashAlgorithms {
	if x, ok := m.GetOcspStaplingChoice().(*TlsCertificateType_CustomHashAlgorithms); ok {
		return x.CustomHashAlgorithms
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TlsCertificateType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TlsCertificateType_UseSystemDefaults)(nil),
		(*TlsCertificateType_DisableOcspStapling)(nil),
		(*TlsCertificateType_CustomHashAlgorithms)(nil),
	}
}

// Domains
//
// x-displayName: "Domains"
// Domains names
type DomainType struct {
	//  Domain choice
	//
	// x-displayName: "Enter Domain"
	// x-required
	// Method to specify domain part
	//
	// Types that are valid to be assigned to DomainChoice:
	//	*DomainType_ExactValue
	//	*DomainType_SuffixValue
	//	*DomainType_RegexValue
	DomainChoice isDomainType_DomainChoice `protobuf_oneof:"domain_choice"`
}

func (m *DomainType) Reset()      { *m = DomainType{} }
func (*DomainType) ProtoMessage() {}
func (*DomainType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{41}
}
func (m *DomainType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DomainType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DomainType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DomainType.Merge(m, src)
}
func (m *DomainType) XXX_Size() int {
	return m.Size()
}
func (m *DomainType) XXX_DiscardUnknown() {
	xxx_messageInfo_DomainType.DiscardUnknown(m)
}

var xxx_messageInfo_DomainType proto.InternalMessageInfo

type isDomainType_DomainChoice interface {
	isDomainType_DomainChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DomainType_ExactValue struct {
	ExactValue string `protobuf:"bytes,1,opt,name=exact_value,json=exactValue,proto3,oneof" json:"exact_value,omitempty"`
}
type DomainType_SuffixValue struct {
	SuffixValue string `protobuf:"bytes,2,opt,name=suffix_value,json=suffixValue,proto3,oneof" json:"suffix_value,omitempty"`
}
type DomainType_RegexValue struct {
	RegexValue string `protobuf:"bytes,3,opt,name=regex_value,json=regexValue,proto3,oneof" json:"regex_value,omitempty"`
}

func (*DomainType_ExactValue) isDomainType_DomainChoice()  {}
func (*DomainType_SuffixValue) isDomainType_DomainChoice() {}
func (*DomainType_RegexValue) isDomainType_DomainChoice()  {}

func (m *DomainType) GetDomainChoice() isDomainType_DomainChoice {
	if m != nil {
		return m.DomainChoice
	}
	return nil
}

func (m *DomainType) GetExactValue() string {
	if x, ok := m.GetDomainChoice().(*DomainType_ExactValue); ok {
		return x.ExactValue
	}
	return ""
}

func (m *DomainType) GetSuffixValue() string {
	if x, ok := m.GetDomainChoice().(*DomainType_SuffixValue); ok {
		return x.SuffixValue
	}
	return ""
}

func (m *DomainType) GetRegexValue() string {
	if x, ok := m.GetDomainChoice().(*DomainType_RegexValue); ok {
		return x.RegexValue
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DomainType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DomainType_ExactValue)(nil),
		(*DomainType_SuffixValue)(nil),
		(*DomainType_RegexValue)(nil),
	}
}

// L4 Dest Type
//
// x-displayName: "L4 Destination"
// L4 Destination consisting of IPv4 Prefixes and TCP Port Range
type L4DestType struct {
	// prefixes
	//
	// x-displayName: "IPv4 Prefixes"
	// x-example: "10.0.0.1/24"
	// x-required
	// Destination IPv4 prefixes.
	Prefixes []string `protobuf:"bytes,1,rep,name=prefixes,proto3" json:"prefixes,omitempty"`
	// port_ranges
	//
	// x-displayName: "Port Ranges"
	// x-required
	// x-example: "80,443,8080-8191,9080"
	// A string containing a comma separated list of port ranges.
	// Each port range consists of a single port or two ports separated by "-".
	PortRanges string `protobuf:"bytes,2,opt,name=port_ranges,json=portRanges,proto3" json:"port_ranges,omitempty"`
}

func (m *L4DestType) Reset()      { *m = L4DestType{} }
func (*L4DestType) ProtoMessage() {}
func (*L4DestType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{42}
}
func (m *L4DestType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L4DestType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *L4DestType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L4DestType.Merge(m, src)
}
func (m *L4DestType) XXX_Size() int {
	return m.Size()
}
func (m *L4DestType) XXX_DiscardUnknown() {
	xxx_messageInfo_L4DestType.DiscardUnknown(m)
}

var xxx_messageInfo_L4DestType proto.InternalMessageInfo

func (m *L4DestType) GetPrefixes() []string {
	if m != nil {
		return m.Prefixes
	}
	return nil
}

func (m *L4DestType) GetPortRanges() string {
	if m != nil {
		return m.PortRanges
	}
	return ""
}

// TlsInterceptionRule
//
// x-displayName: "TLS Interception Rule"
// x-required
// Rule to enable or disable TLS interception based on domain match
type TlsInterceptionRule struct {
	// Domain Match
	//
	// x-displayName: "Match Domain"
	// x-required
	// Domain value or regular expression to match
	DomainMatch *DomainType `protobuf:"bytes,1,opt,name=domain_match,json=domainMatch,proto3" json:"domain_match,omitempty"`
	// Enable/Disable Interception
	//
	// x-displayName: "Enable/Disable Interception"
	// x-required
	// Enable or disable interception for the domain
	//
	// Types that are valid to be assigned to EnableDisableChoice:
	//	*TlsInterceptionRule_DisableInterception
	//	*TlsInterceptionRule_EnableInterception
	EnableDisableChoice isTlsInterceptionRule_EnableDisableChoice `protobuf_oneof:"enable_disable_choice"`
}

func (m *TlsInterceptionRule) Reset()      { *m = TlsInterceptionRule{} }
func (*TlsInterceptionRule) ProtoMessage() {}
func (*TlsInterceptionRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{43}
}
func (m *TlsInterceptionRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TlsInterceptionRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TlsInterceptionRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TlsInterceptionRule.Merge(m, src)
}
func (m *TlsInterceptionRule) XXX_Size() int {
	return m.Size()
}
func (m *TlsInterceptionRule) XXX_DiscardUnknown() {
	xxx_messageInfo_TlsInterceptionRule.DiscardUnknown(m)
}

var xxx_messageInfo_TlsInterceptionRule proto.InternalMessageInfo

type isTlsInterceptionRule_EnableDisableChoice interface {
	isTlsInterceptionRule_EnableDisableChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type TlsInterceptionRule_DisableInterception struct {
	DisableInterception *Empty `protobuf:"bytes,3,opt,name=disable_interception,json=disableInterception,proto3,oneof" json:"disable_interception,omitempty"`
}
type TlsInterceptionRule_EnableInterception struct {
	EnableInterception *Empty `protobuf:"bytes,4,opt,name=enable_interception,json=enableInterception,proto3,oneof" json:"enable_interception,omitempty"`
}

func (*TlsInterceptionRule_DisableInterception) isTlsInterceptionRule_EnableDisableChoice() {}
func (*TlsInterceptionRule_EnableInterception) isTlsInterceptionRule_EnableDisableChoice()  {}

func (m *TlsInterceptionRule) GetEnableDisableChoice() isTlsInterceptionRule_EnableDisableChoice {
	if m != nil {
		return m.EnableDisableChoice
	}
	return nil
}

func (m *TlsInterceptionRule) GetDomainMatch() *DomainType {
	if m != nil {
		return m.DomainMatch
	}
	return nil
}

func (m *TlsInterceptionRule) GetDisableInterception() *Empty {
	if x, ok := m.GetEnableDisableChoice().(*TlsInterceptionRule_DisableInterception); ok {
		return x.DisableInterception
	}
	return nil
}

func (m *TlsInterceptionRule) GetEnableInterception() *Empty {
	if x, ok := m.GetEnableDisableChoice().(*TlsInterceptionRule_EnableInterception); ok {
		return x.EnableInterception
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TlsInterceptionRule) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TlsInterceptionRule_DisableInterception)(nil),
		(*TlsInterceptionRule_EnableInterception)(nil),
	}
}

// TlsInterceptionPolicy
//
// x-displayName: "TLS Interception Policy"
// Policy to enable or disable TLS interception.
type TlsInterceptionPolicy struct {
	// Interception Rules
	//
	// x-displayName: "TLS Interception Rules"
	// x-required
	// List of ordered rules to enable or disable for TLS interception
	InterceptionRules []*TlsInterceptionRule `protobuf:"bytes,1,rep,name=interception_rules,json=interceptionRules,proto3" json:"interception_rules,omitempty"`
}

func (m *TlsInterceptionPolicy) Reset()      { *m = TlsInterceptionPolicy{} }
func (*TlsInterceptionPolicy) ProtoMessage() {}
func (*TlsInterceptionPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{44}
}
func (m *TlsInterceptionPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TlsInterceptionPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TlsInterceptionPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TlsInterceptionPolicy.Merge(m, src)
}
func (m *TlsInterceptionPolicy) XXX_Size() int {
	return m.Size()
}
func (m *TlsInterceptionPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_TlsInterceptionPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_TlsInterceptionPolicy proto.InternalMessageInfo

func (m *TlsInterceptionPolicy) GetInterceptionRules() []*TlsInterceptionRule {
	if m != nil {
		return m.InterceptionRules
	}
	return nil
}

// TlsInterceptionType
//
// x-displayName: "Configuration for TLS interception"
// Configuration to enable TLS interception
type TlsInterceptionType struct {
	// Interception Policy
	//
	// x-displayName: "Interception Policy"
	// x-required
	// Interception policy choice - enable for all domains or custom policies
	//
	// Types that are valid to be assigned to InterceptionPolicyChoice:
	//	*TlsInterceptionType_EnableForAllDomains
	//	*TlsInterceptionType_Policy
	InterceptionPolicyChoice isTlsInterceptionType_InterceptionPolicyChoice `protobuf_oneof:"interception_policy_choice"`
	// Signing Certificate
	//
	// x-displayName: "Select Signing Certificate"
	// x-required
	// Certificate used to generate intermediate certificate for interception
	//
	// Types that are valid to be assigned to SigningCertChoice:
	//	*TlsInterceptionType_CustomCertificate
	//	*TlsInterceptionType_VolterraCertificate
	SigningCertChoice isTlsInterceptionType_SigningCertChoice `protobuf_oneof:"signing_cert_choice"`
	// Root CA Certificate
	//
	// x-displayName: "Select Root CA Certificate"
	// x-required
	// Select Root CA Certificate for upstream connection
	//
	// Types that are valid to be assigned to TrustedCaChoice:
	//	*TlsInterceptionType_TrustedCaUrl
	//	*TlsInterceptionType_VolterraTrustedCa
	TrustedCaChoice isTlsInterceptionType_TrustedCaChoice `protobuf_oneof:"trusted_ca_choice"`
}

func (m *TlsInterceptionType) Reset()      { *m = TlsInterceptionType{} }
func (*TlsInterceptionType) ProtoMessage() {}
func (*TlsInterceptionType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{45}
}
func (m *TlsInterceptionType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TlsInterceptionType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TlsInterceptionType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TlsInterceptionType.Merge(m, src)
}
func (m *TlsInterceptionType) XXX_Size() int {
	return m.Size()
}
func (m *TlsInterceptionType) XXX_DiscardUnknown() {
	xxx_messageInfo_TlsInterceptionType.DiscardUnknown(m)
}

var xxx_messageInfo_TlsInterceptionType proto.InternalMessageInfo

type isTlsInterceptionType_InterceptionPolicyChoice interface {
	isTlsInterceptionType_InterceptionPolicyChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isTlsInterceptionType_SigningCertChoice interface {
	isTlsInterceptionType_SigningCertChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isTlsInterceptionType_TrustedCaChoice interface {
	isTlsInterceptionType_TrustedCaChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type TlsInterceptionType_EnableForAllDomains struct {
	EnableForAllDomains *Empty `protobuf:"bytes,9,opt,name=enable_for_all_domains,json=enableForAllDomains,proto3,oneof" json:"enable_for_all_domains,omitempty"`
}
type TlsInterceptionType_Policy struct {
	Policy *TlsInterceptionPolicy `protobuf:"bytes,1,opt,name=policy,proto3,oneof" json:"policy,omitempty"`
}
type TlsInterceptionType_CustomCertificate struct {
	CustomCertificate *TlsCertificateType `protobuf:"bytes,3,opt,name=custom_certificate,json=customCertificate,proto3,oneof" json:"custom_certificate,omitempty"`
}
type TlsInterceptionType_VolterraCertificate struct {
	VolterraCertificate *Empty `protobuf:"bytes,4,opt,name=volterra_certificate,json=volterraCertificate,proto3,oneof" json:"volterra_certificate,omitempty"`
}
type TlsInterceptionType_TrustedCaUrl struct {
	TrustedCaUrl string `protobuf:"bytes,6,opt,name=trusted_ca_url,json=trustedCaUrl,proto3,oneof" json:"trusted_ca_url,omitempty"`
}
type TlsInterceptionType_VolterraTrustedCa struct {
	VolterraTrustedCa *Empty `protobuf:"bytes,7,opt,name=volterra_trusted_ca,json=volterraTrustedCa,proto3,oneof" json:"volterra_trusted_ca,omitempty"`
}

func (*TlsInterceptionType_EnableForAllDomains) isTlsInterceptionType_InterceptionPolicyChoice() {}
func (*TlsInterceptionType_Policy) isTlsInterceptionType_InterceptionPolicyChoice()              {}
func (*TlsInterceptionType_CustomCertificate) isTlsInterceptionType_SigningCertChoice()          {}
func (*TlsInterceptionType_VolterraCertificate) isTlsInterceptionType_SigningCertChoice()        {}
func (*TlsInterceptionType_TrustedCaUrl) isTlsInterceptionType_TrustedCaChoice()                 {}
func (*TlsInterceptionType_VolterraTrustedCa) isTlsInterceptionType_TrustedCaChoice()            {}

func (m *TlsInterceptionType) GetInterceptionPolicyChoice() isTlsInterceptionType_InterceptionPolicyChoice {
	if m != nil {
		return m.InterceptionPolicyChoice
	}
	return nil
}
func (m *TlsInterceptionType) GetSigningCertChoice() isTlsInterceptionType_SigningCertChoice {
	if m != nil {
		return m.SigningCertChoice
	}
	return nil
}
func (m *TlsInterceptionType) GetTrustedCaChoice() isTlsInterceptionType_TrustedCaChoice {
	if m != nil {
		return m.TrustedCaChoice
	}
	return nil
}

func (m *TlsInterceptionType) GetEnableForAllDomains() *Empty {
	if x, ok := m.GetInterceptionPolicyChoice().(*TlsInterceptionType_EnableForAllDomains); ok {
		return x.EnableForAllDomains
	}
	return nil
}

func (m *TlsInterceptionType) GetPolicy() *TlsInterceptionPolicy {
	if x, ok := m.GetInterceptionPolicyChoice().(*TlsInterceptionType_Policy); ok {
		return x.Policy
	}
	return nil
}

func (m *TlsInterceptionType) GetCustomCertificate() *TlsCertificateType {
	if x, ok := m.GetSigningCertChoice().(*TlsInterceptionType_CustomCertificate); ok {
		return x.CustomCertificate
	}
	return nil
}

func (m *TlsInterceptionType) GetVolterraCertificate() *Empty {
	if x, ok := m.GetSigningCertChoice().(*TlsInterceptionType_VolterraCertificate); ok {
		return x.VolterraCertificate
	}
	return nil
}

func (m *TlsInterceptionType) GetTrustedCaUrl() string {
	if x, ok := m.GetTrustedCaChoice().(*TlsInterceptionType_TrustedCaUrl); ok {
		return x.TrustedCaUrl
	}
	return ""
}

func (m *TlsInterceptionType) GetVolterraTrustedCa() *Empty {
	if x, ok := m.GetTrustedCaChoice().(*TlsInterceptionType_VolterraTrustedCa); ok {
		return x.VolterraTrustedCa
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TlsInterceptionType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TlsInterceptionType_EnableForAllDomains)(nil),
		(*TlsInterceptionType_Policy)(nil),
		(*TlsInterceptionType_CustomCertificate)(nil),
		(*TlsInterceptionType_VolterraCertificate)(nil),
		(*TlsInterceptionType_TrustedCaUrl)(nil),
		(*TlsInterceptionType_VolterraTrustedCa)(nil),
	}
}

// FractionalPercent
//
// x-displayName: "Fractional Percent"
// Fraction used where sampling percentages are needed. example sampled requests
type FractionalPercent struct {
	// numerator
	//
	// x-displayName: "Numerator"
	// x-required
	// x-example: "5"
	// sampled parts per denominator. If denominator was 10000, then value of 5 will be 5 in 10000
	Numerator uint32 `protobuf:"varint,1,opt,name=numerator,proto3" json:"numerator,omitempty"`
	// denominator
	//
	// x-displayName: "Denominator"
	// x-required
	// Samples per denominator. numerator part per 100 or 10000 ro 1000000
	Denominator DenominatorType `protobuf:"varint,2,opt,name=denominator,proto3,enum=ves.io.schema.DenominatorType" json:"denominator,omitempty"`
}

func (m *FractionalPercent) Reset()      { *m = FractionalPercent{} }
func (*FractionalPercent) ProtoMessage() {}
func (*FractionalPercent) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{46}
}
func (m *FractionalPercent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FractionalPercent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FractionalPercent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FractionalPercent.Merge(m, src)
}
func (m *FractionalPercent) XXX_Size() int {
	return m.Size()
}
func (m *FractionalPercent) XXX_DiscardUnknown() {
	xxx_messageInfo_FractionalPercent.DiscardUnknown(m)
}

var xxx_messageInfo_FractionalPercent proto.InternalMessageInfo

func (m *FractionalPercent) GetNumerator() uint32 {
	if m != nil {
		return m.Numerator
	}
	return 0
}

func (m *FractionalPercent) GetDenominator() DenominatorType {
	if m != nil {
		return m.Denominator
	}
	return HUNDRED
}

// BufferConfigType
//
// x-displayName: "Buffer Configuration"
// Some upstream applications are not capable of handling streamed data. This config
// enables buffering the entire request before sending to upstream application. We can
// specify the maximum buffer size and buffer interval with this config.
//
// Buffering can be enabled and disabled at VirtualHost and Route levels
// Route level buffer configuration takes precedence.
type BufferConfigType struct {
	// disable
	//
	// x-displayName: "Disable"
	// Disable buffering for a particular route. This is useful when virtual-host
	// has buffering, but we need to disable it on a specific route.
	// The value of this field is ignored for virtual-host
	Disabled bool `protobuf:"varint,1,opt,name=disabled,proto3" json:"disabled,omitempty"`
	// max_request_bytes
	//
	// x-displayName: "Max Request Bytes"
	// x-example: "2048"
	// The maximum request size that the filter will buffer before the connection
	// manager will stop buffering and return a RequestEntityTooLarge (413) response.
	MaxRequestBytes uint32 `protobuf:"varint,2,opt,name=max_request_bytes,json=maxRequestBytes,proto3" json:"max_request_bytes,omitempty"`
	// max_request_time
	//
	// x-displayName: "Max Request Time"
	// x-example: "30"
	// The maximum number of seconds that the filter will wait for a complete
	// request before returning a RequestTimeout (408) response
	MaxRequestTime uint32 `protobuf:"varint,3,opt,name=max_request_time,json=maxRequestTime,proto3" json:"max_request_time,omitempty"` // Deprecated: Do not use.
}

func (m *BufferConfigType) Reset()      { *m = BufferConfigType{} }
func (*BufferConfigType) ProtoMessage() {}
func (*BufferConfigType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{47}
}
func (m *BufferConfigType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BufferConfigType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BufferConfigType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BufferConfigType.Merge(m, src)
}
func (m *BufferConfigType) XXX_Size() int {
	return m.Size()
}
func (m *BufferConfigType) XXX_DiscardUnknown() {
	xxx_messageInfo_BufferConfigType.DiscardUnknown(m)
}

var xxx_messageInfo_BufferConfigType proto.InternalMessageInfo

func (m *BufferConfigType) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func (m *BufferConfigType) GetMaxRequestBytes() uint32 {
	if m != nil {
		return m.MaxRequestBytes
	}
	return 0
}

// Deprecated: Do not use.
func (m *BufferConfigType) GetMaxRequestTime() uint32 {
	if m != nil {
		return m.MaxRequestTime
	}
	return 0
}

// CorsPolicy
//
// x-displayName: "CORS Policy"
// Cross-Origin Resource Sharing requests configuration specified at Virtual-host or
// Route level. Route level configuration takes precedence.
//
// An example of an Cross origin HTTP request
//
//	GET /resources/public-data/ HTTP/1.1
//	Host: bar.other
//	User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
//	Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
//	Accept-Language: en-us,en;q=0.5
//	Accept-Encoding: gzip,deflate
//	Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
//	Connection: keep-alive
//	Referrer: http://foo.example/examples/access-control/simpleXSInvocation.html
//	Origin: http://foo.example
//
//
//	HTTP/1.1 200 OK
//	Date: Mon, 01 Dec 2008 00:23:53 GMT
//	Server: Apache/2.0.61
//	Access-Control-Allow-Origin: *
//	Keep-Alive: timeout=2, max=100
//	Connection: Keep-Alive
//	Transfer-Encoding: chunked
//	Content-Type: application/xml
//
// An example for cross origin HTTP OPTIONS request with Access-Control-Request-* header
//
//	OPTIONS /resources/post-here/ HTTP/1.1
//	Host: bar.other
//	User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
//	Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
//	Accept-Language: en-us,en;q=0.5
//	Accept-Encoding: gzip,deflate
//	Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
//	Connection: keep-alive
//	Origin: http://foo.example
//	Access-Control-Request-Method: POST
//	Access-Control-Request-Headers: X-PINGOTHER, Content-Type
//
//
//	HTTP/1.1 204 No Content
//	Date: Mon, 01 Dec 2008 01:15:39 GMT
//	Server: Apache/2.0.61 (Unix)
//	Access-Control-Allow-Origin: http://foo.example
//	Access-Control-Allow-Methods: POST, GET, OPTIONS
//	Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
//	Access-Control-Max-Age: 86400
//	Vary: Accept-Encoding, Origin
//	Keep-Alive: timeout=2, max=100
//	Connection: Keep-Alive
type CorsPolicy struct {
	// disabled
	//
	// x-displayName: "Disabled"
	// Disable the CorsPolicy for a particular route. This is useful when
	// virtual-host has CorsPolicy, but we need to disable it on a specific route.
	// The value of this field is ignored for virtual-host
	Disabled bool `protobuf:"varint,1,opt,name=disabled,proto3" json:"disabled,omitempty"`
	// allow_origin
	//
	// x-displayName: "Allow Origin"
	// x-example: "value"
	// Specifies the origins that will be allowed to do CORS requests.
	// An origin is allowed if either allow_origin or allow_origin_regex match
	AllowOrigin []string `protobuf:"bytes,2,rep,name=allow_origin,json=allowOrigin,proto3" json:"allow_origin,omitempty"`
	// allow_origin_regex
	//
	// x-displayName: "Allow Origin Regex"
	// x-example: "value"
	// Specifies regex patterns that match allowed origins.
	// An origin is allowed if either allow_origin or allow_origin_regex match
	AllowOriginRegex []string `protobuf:"bytes,3,rep,name=allow_origin_regex,json=allowOriginRegex,proto3" json:"allow_origin_regex,omitempty"`
	// allow_methods
	//
	// x-displayName: "Allow Methods"
	// x-example: "GET"
	// Specifies the content for the access-control-allow-methods header
	AllowMethods string `protobuf:"bytes,4,opt,name=allow_methods,json=allowMethods,proto3" json:"allow_methods,omitempty"`
	// allow_headers
	//
	// x-displayName: "Allow Headers"
	// x-example: "value"
	// Specifies the content for the access-control-allow-headers header
	AllowHeaders string `protobuf:"bytes,5,opt,name=allow_headers,json=allowHeaders,proto3" json:"allow_headers,omitempty"`
	// expose_headers
	//
	// x-displayName: "Expose Headers"
	// x-example: "value"
	// Specifies the content for the access-control-expose-headers header
	ExposeHeaders string `protobuf:"bytes,6,opt,name=expose_headers,json=exposeHeaders,proto3" json:"expose_headers,omitempty"`
	// max_age
	//
	// x-displayName: "Max Age"
	// x-example: "value"
	// Specifies the content for the access-control-max-age header
	MaxAge string `protobuf:"bytes,7,opt,name=max_age,json=maxAge,proto3" json:"max_age,omitempty"` // Deprecated: Do not use.
	// maximum_age
	//
	// x-displayName: "Maximum Age"
	// x-example: "-1"
	// Specifies the content for the access-control-max-age header in seconds.
	// This indicates the maximum number of seconds the results can be cached
	// A value of -1 will disable caching.
	// Maximum permitted value is 86400 seconds (24 hours)
	MaximumAge int32 `protobuf:"varint,9,opt,name=maximum_age,json=maximumAge,proto3" json:"maximum_age,omitempty"`
	// allow_credentials
	//
	// x-displayName: "Allow Credentials"
	// Specifies whether the resource allows credentials
	AllowCredentials bool `protobuf:"varint,8,opt,name=allow_credentials,json=allowCredentials,proto3" json:"allow_credentials,omitempty"`
}

func (m *CorsPolicy) Reset()      { *m = CorsPolicy{} }
func (*CorsPolicy) ProtoMessage() {}
func (*CorsPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{48}
}
func (m *CorsPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CorsPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CorsPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CorsPolicy.Merge(m, src)
}
func (m *CorsPolicy) XXX_Size() int {
	return m.Size()
}
func (m *CorsPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_CorsPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_CorsPolicy proto.InternalMessageInfo

func (m *CorsPolicy) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func (m *CorsPolicy) GetAllowOrigin() []string {
	if m != nil {
		return m.AllowOrigin
	}
	return nil
}

func (m *CorsPolicy) GetAllowOriginRegex() []string {
	if m != nil {
		return m.AllowOriginRegex
	}
	return nil
}

func (m *CorsPolicy) GetAllowMethods() string {
	if m != nil {
		return m.AllowMethods
	}
	return ""
}

func (m *CorsPolicy) GetAllowHeaders() string {
	if m != nil {
		return m.AllowHeaders
	}
	return ""
}

func (m *CorsPolicy) GetExposeHeaders() string {
	if m != nil {
		return m.ExposeHeaders
	}
	return ""
}

// Deprecated: Do not use.
func (m *CorsPolicy) GetMaxAge() string {
	if m != nil {
		return m.MaxAge
	}
	return ""
}

func (m *CorsPolicy) GetMaximumAge() int32 {
	if m != nil {
		return m.MaximumAge
	}
	return 0
}

func (m *CorsPolicy) GetAllowCredentials() bool {
	if m != nil {
		return m.AllowCredentials
	}
	return false
}

// CsrfPolicy
//
// x-displayName: "CSRF Policy"
// To mitigate CSRF attack , the policy checks where a request is coming from to determine if the request's origin is the same as its detination.The policy relies on two pieces of information used in determining if a request originated from the same host.
//
// 1. The origin that caused the user agent to issue the request (source origin).
// 2. The origin that the request is going to (target origin).
// When the policy evaluating a request, it ensures both pieces of information are present and compare their values. If the source origin is missing or origins do not match the request is rejected. The exception to this being if the source-origin has been added to they policy as valid.
// Because CSRF attacks specifically target state-changing requests, the policy only acts on the HTTP requests that have state-changing method (PUT,POST, etc.).
type CsrfPolicy struct {
	// allowed_domains
	//
	// x-displayName: "Allowed Domains (Source Origin)"
	// x-required
	// The list of source origin that should be allowed.
	//
	// Types that are valid to be assigned to AllowedDomains:
	//
	//	*CsrfPolicy_AllLoadBalancerDomains
	//	*CsrfPolicy_CustomDomainList
	//	*CsrfPolicy_Disabled
	AllowedDomains isCsrfPolicy_AllowedDomains `protobuf_oneof:"allowed_domains"`
}

func (m *CsrfPolicy) Reset()      { *m = CsrfPolicy{} }
func (*CsrfPolicy) ProtoMessage() {}
func (*CsrfPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{49}
}
func (m *CsrfPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CsrfPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CsrfPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CsrfPolicy.Merge(m, src)
}
func (m *CsrfPolicy) XXX_Size() int {
	return m.Size()
}
func (m *CsrfPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_CsrfPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_CsrfPolicy proto.InternalMessageInfo

type isCsrfPolicy_AllowedDomains interface {
	isCsrfPolicy_AllowedDomains()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CsrfPolicy_AllLoadBalancerDomains struct {
	AllLoadBalancerDomains *Empty `protobuf:"bytes,2,opt,name=all_load_balancer_domains,json=allLoadBalancerDomains,proto3,oneof" json:"all_load_balancer_domains,omitempty"`
}
type CsrfPolicy_CustomDomainList struct {
	CustomDomainList *DomainNameList `protobuf:"bytes,3,opt,name=custom_domain_list,json=customDomainList,proto3,oneof" json:"custom_domain_list,omitempty"`
}
type CsrfPolicy_Disabled struct {
	Disabled *Empty `protobuf:"bytes,4,opt,name=disabled,proto3,oneof" json:"disabled,omitempty"`
}

func (*CsrfPolicy_AllLoadBalancerDomains) isCsrfPolicy_AllowedDomains() {}
func (*CsrfPolicy_CustomDomainList) isCsrfPolicy_AllowedDomains()       {}
func (*CsrfPolicy_Disabled) isCsrfPolicy_AllowedDomains()               {}

func (m *CsrfPolicy) GetAllowedDomains() isCsrfPolicy_AllowedDomains {
	if m != nil {
		return m.AllowedDomains
	}
	return nil
}

func (m *CsrfPolicy) GetAllLoadBalancerDomains() *Empty {
	if x, ok := m.GetAllowedDomains().(*CsrfPolicy_AllLoadBalancerDomains); ok {
		return x.AllLoadBalancerDomains
	}
	return nil
}

func (m *CsrfPolicy) GetCustomDomainList() *DomainNameList {
	if x, ok := m.GetAllowedDomains().(*CsrfPolicy_CustomDomainList); ok {
		return x.CustomDomainList
	}
	return nil
}

func (m *CsrfPolicy) GetDisabled() *Empty {
	if x, ok := m.GetAllowedDomains().(*CsrfPolicy_Disabled); ok {
		return x.Disabled
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CsrfPolicy) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CsrfPolicy_AllLoadBalancerDomains)(nil),
		(*CsrfPolicy_CustomDomainList)(nil),
		(*CsrfPolicy_Disabled)(nil),
	}
}

// PathMatcherType
//
// x-displayName: "Path to Match"
// Path match of the URI can be either be, Prefix match or exact match or regular expression match
type PathMatcherType struct {
	// path_match
	//
	// x-displayName: "Path Match"
	// x-required
	// A specification of path match
	//
	// Types that are valid to be assigned to PathMatch:
	//
	//	*PathMatcherType_Prefix
	//	*PathMatcherType_Path
	//	*PathMatcherType_Regex
	PathMatch isPathMatcherType_PathMatch `protobuf_oneof:"path_match"`
}

func (m *PathMatcherType) Reset()      { *m = PathMatcherType{} }
func (*PathMatcherType) ProtoMessage() {}
func (*PathMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{50}
}
func (m *PathMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PathMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PathMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PathMatcherType.Merge(m, src)
}
func (m *PathMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *PathMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_PathMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_PathMatcherType proto.InternalMessageInfo

type isPathMatcherType_PathMatch interface {
	isPathMatcherType_PathMatch()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PathMatcherType_Prefix struct {
	Prefix string `protobuf:"bytes,1,opt,name=prefix,proto3,oneof" json:"prefix,omitempty"`
}
type PathMatcherType_Path struct {
	Path string `protobuf:"bytes,2,opt,name=path,proto3,oneof" json:"path,omitempty"`
}
type PathMatcherType_Regex struct {
	Regex string `protobuf:"bytes,3,opt,name=regex,proto3,oneof" json:"regex,omitempty"`
}

func (*PathMatcherType_Prefix) isPathMatcherType_PathMatch() {}
func (*PathMatcherType_Path) isPathMatcherType_PathMatch()   {}
func (*PathMatcherType_Regex) isPathMatcherType_PathMatch()  {}

func (m *PathMatcherType) GetPathMatch() isPathMatcherType_PathMatch {
	if m != nil {
		return m.PathMatch
	}
	return nil
}

func (m *PathMatcherType) GetPrefix() string {
	if x, ok := m.GetPathMatch().(*PathMatcherType_Prefix); ok {
		return x.Prefix
	}
	return ""
}

func (m *PathMatcherType) GetPath() string {
	if x, ok := m.GetPathMatch().(*PathMatcherType_Path); ok {
		return x.Path
	}
	return ""
}

func (m *PathMatcherType) GetRegex() string {
	if x, ok := m.GetPathMatch().(*PathMatcherType_Regex); ok {
		return x.Regex
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PathMatcherType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PathMatcherType_Prefix)(nil),
		(*PathMatcherType_Path)(nil),
		(*PathMatcherType_Regex)(nil),
	}
}

// PortMatcherType
//
// x-displayName: "Port to Match"
// Port match of the request can be a range or a specific port
type PortMatcherType struct {
	// port_match
	//
	// x-displayName: "Port Match"
	// A specification of port match
	//
	// Types that are valid to be assigned to PortMatch:
	//
	//	*PortMatcherType_Port
	//	*PortMatcherType_PortRanges
	//	*PortMatcherType_NoPortMatch
	PortMatch isPortMatcherType_PortMatch `protobuf_oneof:"port_match"`
}

func (m *PortMatcherType) Reset()      { *m = PortMatcherType{} }
func (*PortMatcherType) ProtoMessage() {}
func (*PortMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{51}
}
func (m *PortMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PortMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortMatcherType.Merge(m, src)
}
func (m *PortMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *PortMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_PortMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_PortMatcherType proto.InternalMessageInfo

type isPortMatcherType_PortMatch interface {
	isPortMatcherType_PortMatch()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PortMatcherType_Port struct {
	Port uint32 `protobuf:"varint,1,opt,name=port,proto3,oneof" json:"port,omitempty"`
}
type PortMatcherType_PortRanges struct {
	PortRanges string `protobuf:"bytes,2,opt,name=port_ranges,json=portRanges,proto3,oneof" json:"port_ranges,omitempty"`
}
type PortMatcherType_NoPortMatch struct {
	NoPortMatch *Empty `protobuf:"bytes,4,opt,name=no_port_match,json=noPortMatch,proto3,oneof" json:"no_port_match,omitempty"`
}

func (*PortMatcherType_Port) isPortMatcherType_PortMatch()        {}
func (*PortMatcherType_PortRanges) isPortMatcherType_PortMatch()  {}
func (*PortMatcherType_NoPortMatch) isPortMatcherType_PortMatch() {}

func (m *PortMatcherType) GetPortMatch() isPortMatcherType_PortMatch {
	if m != nil {
		return m.PortMatch
	}
	return nil
}

func (m *PortMatcherType) GetPort() uint32 {
	if x, ok := m.GetPortMatch().(*PortMatcherType_Port); ok {
		return x.Port
	}
	return 0
}

func (m *PortMatcherType) GetPortRanges() string {
	if x, ok := m.GetPortMatch().(*PortMatcherType_PortRanges); ok {
		return x.PortRanges
	}
	return ""
}

func (m *PortMatcherType) GetNoPortMatch() *Empty {
	if x, ok := m.GetPortMatch().(*PortMatcherType_NoPortMatch); ok {
		return x.NoPortMatch
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PortMatcherType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PortMatcherType_Port)(nil),
		(*PortMatcherType_PortRanges)(nil),
		(*PortMatcherType_NoPortMatch)(nil),
	}
}

// HeaderMatcherType
//
// x-displayName: "Header to Match"
// Header match is done using the name of the header and its value.
// The value match is done using one of the following
//
//	regex match on value
//	exact match of value
//	presence of header
//
// Header Match can also be inverse of above, which be used to check
//
//	missing header or
//	non-matching value
type HeaderMatcherType struct {
	// name
	//
	// x-displayName: "Name"
	// x-required
	// x-example: "Content-Type"
	// Name of the header
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// value_match
	//
	// x-displayName: "Value"
	// The variants of matching a header value
	//
	// Types that are valid to be assigned to ValueMatch:
	//
	//	*HeaderMatcherType_Exact
	//	*HeaderMatcherType_Regex
	//	*HeaderMatcherType_Presence
	ValueMatch isHeaderMatcherType_ValueMatch `protobuf_oneof:"value_match"`
	// invert_match
	//
	// x-displayName: "NOT of match"
	// Invert the result of the match to detect missing header or non-matching value
	InvertMatch bool `protobuf:"varint,5,opt,name=invert_match,json=invertMatch,proto3" json:"invert_match,omitempty"`
}

func (m *HeaderMatcherType) Reset()      { *m = HeaderMatcherType{} }
func (*HeaderMatcherType) ProtoMessage() {}
func (*HeaderMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{52}
}
func (m *HeaderMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeaderMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HeaderMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeaderMatcherType.Merge(m, src)
}
func (m *HeaderMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *HeaderMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_HeaderMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_HeaderMatcherType proto.InternalMessageInfo

type isHeaderMatcherType_ValueMatch interface {
	isHeaderMatcherType_ValueMatch()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type HeaderMatcherType_Exact struct {
	Exact string `protobuf:"bytes,2,opt,name=exact,proto3,oneof" json:"exact,omitempty"`
}
type HeaderMatcherType_Regex struct {
	Regex string `protobuf:"bytes,3,opt,name=regex,proto3,oneof" json:"regex,omitempty"`
}
type HeaderMatcherType_Presence struct {
	Presence bool `protobuf:"varint,4,opt,name=presence,proto3,oneof" json:"presence,omitempty"`
}

func (*HeaderMatcherType_Exact) isHeaderMatcherType_ValueMatch()    {}
func (*HeaderMatcherType_Regex) isHeaderMatcherType_ValueMatch()    {}
func (*HeaderMatcherType_Presence) isHeaderMatcherType_ValueMatch() {}

func (m *HeaderMatcherType) GetValueMatch() isHeaderMatcherType_ValueMatch {
	if m != nil {
		return m.ValueMatch
	}
	return nil
}

func (m *HeaderMatcherType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HeaderMatcherType) GetExact() string {
	if x, ok := m.GetValueMatch().(*HeaderMatcherType_Exact); ok {
		return x.Exact
	}
	return ""
}

func (m *HeaderMatcherType) GetRegex() string {
	if x, ok := m.GetValueMatch().(*HeaderMatcherType_Regex); ok {
		return x.Regex
	}
	return ""
}

func (m *HeaderMatcherType) GetPresence() bool {
	if x, ok := m.GetValueMatch().(*HeaderMatcherType_Presence); ok {
		return x.Presence
	}
	return false
}

func (m *HeaderMatcherType) GetInvertMatch() bool {
	if m != nil {
		return m.InvertMatch
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HeaderMatcherType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HeaderMatcherType_Exact)(nil),
		(*HeaderMatcherType_Regex)(nil),
		(*HeaderMatcherType_Presence)(nil),
	}
}

// QueryParameterMatcherType
//
// x-displayName: "Query Parameter to Match"
// Query parameter match can be either regex match on value or exact match of value for given key
// An example for HTTP request with query parameter https://gitlab.com/dashboard/issues?assignee_username=xxyyxx
type QueryParameterMatcherType struct {
	// key
	//
	// x-displayName: "Key"
	// x-required
	// x-example: "assignee_username"
	// Query parameter key
	// In the above example, assignee_username is the key
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// value_match
	//
	// x-displayName: "Value"
	// Query parameter value regex match or exact match
	// In the above example, xxyyxx is the value for the matching key
	//
	// Types that are valid to be assigned to ValueMatch:
	//
	//	*QueryParameterMatcherType_Exact
	//	*QueryParameterMatcherType_Regex
	ValueMatch isQueryParameterMatcherType_ValueMatch `protobuf_oneof:"value_match"`
}

func (m *QueryParameterMatcherType) Reset()      { *m = QueryParameterMatcherType{} }
func (*QueryParameterMatcherType) ProtoMessage() {}
func (*QueryParameterMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{53}
}
func (m *QueryParameterMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryParameterMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *QueryParameterMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryParameterMatcherType.Merge(m, src)
}
func (m *QueryParameterMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *QueryParameterMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryParameterMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_QueryParameterMatcherType proto.InternalMessageInfo

type isQueryParameterMatcherType_ValueMatch interface {
	isQueryParameterMatcherType_ValueMatch()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type QueryParameterMatcherType_Exact struct {
	Exact string `protobuf:"bytes,2,opt,name=exact,proto3,oneof" json:"exact,omitempty"`
}
type QueryParameterMatcherType_Regex struct {
	Regex string `protobuf:"bytes,3,opt,name=regex,proto3,oneof" json:"regex,omitempty"`
}

func (*QueryParameterMatcherType_Exact) isQueryParameterMatcherType_ValueMatch() {}
func (*QueryParameterMatcherType_Regex) isQueryParameterMatcherType_ValueMatch() {}

func (m *QueryParameterMatcherType) GetValueMatch() isQueryParameterMatcherType_ValueMatch {
	if m != nil {
		return m.ValueMatch
	}
	return nil
}

func (m *QueryParameterMatcherType) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *QueryParameterMatcherType) GetExact() string {
	if x, ok := m.GetValueMatch().(*QueryParameterMatcherType_Exact); ok {
		return x.Exact
	}
	return ""
}

func (m *QueryParameterMatcherType) GetRegex() string {
	if x, ok := m.GetValueMatch().(*QueryParameterMatcherType_Regex); ok {
		return x.Regex
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*QueryParameterMatcherType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*QueryParameterMatcherType_Exact)(nil),
		(*QueryParameterMatcherType_Regex)(nil),
	}
}

// RouteMatch
//
// x-displayName: "Match"
// Route Match can be specified to match five things
// 1. In case of HTTP "path" specifies URI part URL (path excluding hostname) in request.
// 2. List of headers  to match in incoming request.
// 3. Query parameters (key, value) in the request. (Not the Query expression)
// 4. HTTP method
// 5. The port on which the request is received
type RouteMatch struct {
	// path
	//
	// x-displayName: "Path"
	// URI path of route
	Path *PathMatcherType `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// headers
	//
	// x-displayName: "Headers"
	// List of (key, value) headers
	Headers []*HeaderMatcherType `protobuf:"bytes,2,rep,name=headers,proto3" json:"headers,omitempty"`
	// query_params
	//
	// x-displayName: "Query Parameters"
	// List of (key, value) query parameters
	QueryParams []*QueryParameterMatcherType `protobuf:"bytes,3,rep,name=query_params,json=queryParams,proto3" json:"query_params,omitempty"`
	// http_method
	//
	// x-displayName: "HTTP Method"
	// The name of the HTTP Method (GET, PUT, POST, etc)
	HttpMethod HttpMethod `protobuf:"varint,4,opt,name=http_method,json=httpMethod,proto3,enum=ves.io.schema.HttpMethod" json:"http_method,omitempty"`
	// incoming_port
	//
	// x-displayName: "Match LB port"
	// The port on which the request is received
	IncomingPort *PortMatcherType `protobuf:"bytes,5,opt,name=incoming_port,json=incomingPort,proto3" json:"incoming_port,omitempty"`
}

func (m *RouteMatch) Reset()      { *m = RouteMatch{} }
func (*RouteMatch) ProtoMessage() {}
func (*RouteMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{54}
}
func (m *RouteMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteMatch.Merge(m, src)
}
func (m *RouteMatch) XXX_Size() int {
	return m.Size()
}
func (m *RouteMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteMatch.DiscardUnknown(m)
}

var xxx_messageInfo_RouteMatch proto.InternalMessageInfo

func (m *RouteMatch) GetPath() *PathMatcherType {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *RouteMatch) GetHeaders() []*HeaderMatcherType {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *RouteMatch) GetQueryParams() []*QueryParameterMatcherType {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

func (m *RouteMatch) GetHttpMethod() HttpMethod {
	if m != nil {
		return m.HttpMethod
	}
	return ANY
}

func (m *RouteMatch) GetIncomingPort() *PortMatcherType {
	if m != nil {
		return m.IncomingPort
	}
	return nil
}

// AppFirewallRefType
//
// x-displayName: "App Firewall Reference"
// A list of references to the app_firewall configuration objects
type AppFirewallRefType struct {
	// app_firewall
	//
	// x-displayName: "Application Firewall"
	// x-required
	// References to an Application Firewall configuration object
	AppFirewall []*ObjectRefType `protobuf:"bytes,1,rep,name=app_firewall,json=appFirewall,proto3" json:"app_firewall,omitempty"`
}

func (m *AppFirewallRefType) Reset()      { *m = AppFirewallRefType{} }
func (*AppFirewallRefType) ProtoMessage() {}
func (*AppFirewallRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{55}
}
func (m *AppFirewallRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppFirewallRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AppFirewallRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppFirewallRefType.Merge(m, src)
}
func (m *AppFirewallRefType) XXX_Size() int {
	return m.Size()
}
func (m *AppFirewallRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_AppFirewallRefType.DiscardUnknown(m)
}

var xxx_messageInfo_AppFirewallRefType proto.InternalMessageInfo

func (m *AppFirewallRefType) GetAppFirewall() []*ObjectRefType {
	if m != nil {
		return m.AppFirewall
	}
	return nil
}

// WafType
//
// x-displayName: "WAF Instance"
// WAF instance will be pointing to an app_firewall object
type WafType struct {
	// WAF config
	//
	// x-displayName: "WAF Config"
	// The variants of direct reference of WAF
	//
	// Types that are valid to be assigned to RefType:
	//
	//	*WafType_AppFirewall
	//	*WafType_DisableWaf
	//	*WafType_InheritWaf
	RefType isWafType_RefType `protobuf_oneof:"ref_type"`
}

func (m *WafType) Reset()      { *m = WafType{} }
func (*WafType) ProtoMessage() {}
func (*WafType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{56}
}
func (m *WafType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WafType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WafType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WafType.Merge(m, src)
}
func (m *WafType) XXX_Size() int {
	return m.Size()
}
func (m *WafType) XXX_DiscardUnknown() {
	xxx_messageInfo_WafType.DiscardUnknown(m)
}

var xxx_messageInfo_WafType proto.InternalMessageInfo

type isWafType_RefType interface {
	isWafType_RefType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type WafType_AppFirewall struct {
	AppFirewall *AppFirewallRefType `protobuf:"bytes,4,opt,name=app_firewall,json=appFirewall,proto3,oneof" json:"app_firewall,omitempty"`
}
type WafType_DisableWaf struct {
	DisableWaf *Empty `protobuf:"bytes,5,opt,name=disable_waf,json=disableWaf,proto3,oneof" json:"disable_waf,omitempty"`
}
type WafType_InheritWaf struct {
	InheritWaf *Empty `protobuf:"bytes,6,opt,name=inherit_waf,json=inheritWaf,proto3,oneof" json:"inherit_waf,omitempty"`
}

func (*WafType_AppFirewall) isWafType_RefType() {}
func (*WafType_DisableWaf) isWafType_RefType()  {}
func (*WafType_InheritWaf) isWafType_RefType()  {}

func (m *WafType) GetRefType() isWafType_RefType {
	if m != nil {
		return m.RefType
	}
	return nil
}

func (m *WafType) GetAppFirewall() *AppFirewallRefType {
	if x, ok := m.GetRefType().(*WafType_AppFirewall); ok {
		return x.AppFirewall
	}
	return nil
}

func (m *WafType) GetDisableWaf() *Empty {
	if x, ok := m.GetRefType().(*WafType_DisableWaf); ok {
		return x.DisableWaf
	}
	return nil
}

func (m *WafType) GetInheritWaf() *Empty {
	if x, ok := m.GetRefType().(*WafType_InheritWaf); ok {
		return x.InheritWaf
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*WafType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*WafType_AppFirewall)(nil),
		(*WafType_DisableWaf)(nil),
		(*WafType_InheritWaf)(nil),
	}
}

// AppRoleAuthInfoType
//
// x-displayName: "Vault AppRole Authentication Parameters"
// AppRoleAuthInfoType contains parameters for AppRole authentication in Hashicorp Vault
type AppRoleAuthInfoType struct {
	// role-id
	//
	// x-displayName: "Role ID"
	// x-example: "value"
	// role-id to be used for authentication
	RoleId string `protobuf:"bytes,1,opt,name=role_id,json=roleId,proto3" json:"role_id,omitempty"`
	// secret-id
	//
	// x-displayName: "Secret ID"
	// F5XC Secret. Secret-id to be used for authentication. secret-id has to be long lived.
	SecretId *SecretType `protobuf:"bytes,2,opt,name=secret_id,json=secretId,proto3" json:"secret_id,omitempty"`
}

func (m *AppRoleAuthInfoType) Reset()      { *m = AppRoleAuthInfoType{} }
func (*AppRoleAuthInfoType) ProtoMessage() {}
func (*AppRoleAuthInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{57}
}
func (m *AppRoleAuthInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppRoleAuthInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AppRoleAuthInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppRoleAuthInfoType.Merge(m, src)
}
func (m *AppRoleAuthInfoType) XXX_Size() int {
	return m.Size()
}
func (m *AppRoleAuthInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_AppRoleAuthInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_AppRoleAuthInfoType proto.InternalMessageInfo

func (m *AppRoleAuthInfoType) GetRoleId() string {
	if m != nil {
		return m.RoleId
	}
	return ""
}

func (m *AppRoleAuthInfoType) GetSecretId() *SecretType {
	if m != nil {
		return m.SecretId
	}
	return nil
}

// VaultAuthTypeInfo
//
// x-displayName: "Vault Authentication Parameters"
// Authentication parameters for Hashicorp Vault hosts
type VaultAuthInfoType struct {
	// Authentication Parameters
	//
	// x-displayName: "Authentication Parameters"
	// Different authentication parameters for authentication to Hashicorp Vault backend. Currently supported methods are -
	// * AppRole authentication - Authentication using AppRole method
	// * Token authentication - Authentication using Token
	//
	// Types that are valid to be assigned to AuthParams:
	//
	//	*VaultAuthInfoType_AppRoleAuth
	//	*VaultAuthInfoType_Token
	AuthParams isVaultAuthInfoType_AuthParams `protobuf_oneof:"auth_params"`
}

func (m *VaultAuthInfoType) Reset()      { *m = VaultAuthInfoType{} }
func (*VaultAuthInfoType) ProtoMessage() {}
func (*VaultAuthInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{58}
}
func (m *VaultAuthInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VaultAuthInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VaultAuthInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VaultAuthInfoType.Merge(m, src)
}
func (m *VaultAuthInfoType) XXX_Size() int {
	return m.Size()
}
func (m *VaultAuthInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_VaultAuthInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_VaultAuthInfoType proto.InternalMessageInfo

type isVaultAuthInfoType_AuthParams interface {
	isVaultAuthInfoType_AuthParams()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type VaultAuthInfoType_AppRoleAuth struct {
	AppRoleAuth *AppRoleAuthInfoType `protobuf:"bytes,1,opt,name=app_role_auth,json=appRoleAuth,proto3,oneof" json:"app_role_auth,omitempty"`
}
type VaultAuthInfoType_Token struct {
	Token *SecretType `protobuf:"bytes,2,opt,name=token,proto3,oneof" json:"token,omitempty"`
}

func (*VaultAuthInfoType_AppRoleAuth) isVaultAuthInfoType_AuthParams() {}
func (*VaultAuthInfoType_Token) isVaultAuthInfoType_AuthParams()       {}

func (m *VaultAuthInfoType) GetAuthParams() isVaultAuthInfoType_AuthParams {
	if m != nil {
		return m.AuthParams
	}
	return nil
}

func (m *VaultAuthInfoType) GetAppRoleAuth() *AppRoleAuthInfoType {
	if x, ok := m.GetAuthParams().(*VaultAuthInfoType_AppRoleAuth); ok {
		return x.AppRoleAuth
	}
	return nil
}

func (m *VaultAuthInfoType) GetToken() *SecretType {
	if x, ok := m.GetAuthParams().(*VaultAuthInfoType_Token); ok {
		return x.Token
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VaultAuthInfoType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VaultAuthInfoType_AppRoleAuth)(nil),
		(*VaultAuthInfoType_Token)(nil),
	}
}

// RestAuthInfoType
//
// x-displayName: "Rest Authentication Parameters"
// Authentication parameters for REST based hosts
type RestAuthInfoType struct {
	// Authentication Parameters
	//
	// x-displayName: "Authentication Parameters"
	// Different authentication parameters for authenticating to REST backend, Currently supported are -
	// BasicAuth - Authentication using basic auth
	// Authentication Headers - Authentication using Headers
	// Authentication QueryParams - Authentication using QueryParams
	//
	// Types that are valid to be assigned to AuthParams:
	//
	//	*RestAuthInfoType_BasicAuth
	//	*RestAuthInfoType_HeadersAuth
	//	*RestAuthInfoType_QueryParamsAuth
	AuthParams isRestAuthInfoType_AuthParams `protobuf_oneof:"auth_params"`
}

func (m *RestAuthInfoType) Reset()      { *m = RestAuthInfoType{} }
func (*RestAuthInfoType) ProtoMessage() {}
func (*RestAuthInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{59}
}
func (m *RestAuthInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestAuthInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RestAuthInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestAuthInfoType.Merge(m, src)
}
func (m *RestAuthInfoType) XXX_Size() int {
	return m.Size()
}
func (m *RestAuthInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_RestAuthInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_RestAuthInfoType proto.InternalMessageInfo

type isRestAuthInfoType_AuthParams interface {
	isRestAuthInfoType_AuthParams()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type RestAuthInfoType_BasicAuth struct {
	BasicAuth *AuthnTypeBasicAuth `protobuf:"bytes,1,opt,name=basic_auth,json=basicAuth,proto3,oneof" json:"basic_auth,omitempty"`
}
type RestAuthInfoType_HeadersAuth struct {
	HeadersAuth *AuthnTypeHeaders `protobuf:"bytes,2,opt,name=headers_auth,json=headersAuth,proto3,oneof" json:"headers_auth,omitempty"`
}
type RestAuthInfoType_QueryParamsAuth struct {
	QueryParamsAuth *AuthnTypeQueryParams `protobuf:"bytes,3,opt,name=query_params_auth,json=queryParamsAuth,proto3,oneof" json:"query_params_auth,omitempty"`
}

func (*RestAuthInfoType_BasicAuth) isRestAuthInfoType_AuthParams()       {}
func (*RestAuthInfoType_HeadersAuth) isRestAuthInfoType_AuthParams()     {}
func (*RestAuthInfoType_QueryParamsAuth) isRestAuthInfoType_AuthParams() {}

func (m *RestAuthInfoType) GetAuthParams() isRestAuthInfoType_AuthParams {
	if m != nil {
		return m.AuthParams
	}
	return nil
}

func (m *RestAuthInfoType) GetBasicAuth() *AuthnTypeBasicAuth {
	if x, ok := m.GetAuthParams().(*RestAuthInfoType_BasicAuth); ok {
		return x.BasicAuth
	}
	return nil
}

func (m *RestAuthInfoType) GetHeadersAuth() *AuthnTypeHeaders {
	if x, ok := m.GetAuthParams().(*RestAuthInfoType_HeadersAuth); ok {
		return x.HeadersAuth
	}
	return nil
}

func (m *RestAuthInfoType) GetQueryParamsAuth() *AuthnTypeQueryParams {
	if x, ok := m.GetAuthParams().(*RestAuthInfoType_QueryParamsAuth); ok {
		return x.QueryParamsAuth
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RestAuthInfoType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RestAuthInfoType_BasicAuth)(nil),
		(*RestAuthInfoType_HeadersAuth)(nil),
		(*RestAuthInfoType_QueryParamsAuth)(nil),
	}
}

// VaultAccessInfoType
//
// x-displayName: "Vault Access Information"
// VaultAccessInfoType contains information about how to connect to Hashicorp vault.
type VaultAccessInfoType struct {
	// vault_addr
	//
	// x-displayName: "Vault Address"
	// vault_address defines the address of the vault in <host:port> format
	VaultAddr string `protobuf:"bytes,1,opt,name=vault_addr,json=vaultAddr,proto3" json:"vault_addr,omitempty"`
	// vault_ca_url
	//
	// x-displayName: "Vault CA URL"
	// vault_ca_url contains the CA to trust for remote vault
	VaultCaUrl string `protobuf:"bytes,2,opt,name=vault_ca_url,json=vaultCaUrl,proto3" json:"vault_ca_url,omitempty"`
	// Types that are valid to be assigned to AuthnChoice:
	//
	//	*VaultAccessInfoType_AppRoleAuth
	//	*VaultAccessInfoType_Token
	AuthnChoice isVaultAccessInfoType_AuthnChoice `protobuf_oneof:"authn_choice"`
}

func (m *VaultAccessInfoType) Reset()      { *m = VaultAccessInfoType{} }
func (*VaultAccessInfoType) ProtoMessage() {}
func (*VaultAccessInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{60}
}
func (m *VaultAccessInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VaultAccessInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VaultAccessInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VaultAccessInfoType.Merge(m, src)
}
func (m *VaultAccessInfoType) XXX_Size() int {
	return m.Size()
}
func (m *VaultAccessInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_VaultAccessInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_VaultAccessInfoType proto.InternalMessageInfo

type isVaultAccessInfoType_AuthnChoice interface {
	isVaultAccessInfoType_AuthnChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type VaultAccessInfoType_AppRoleAuth struct {
	AppRoleAuth *AppRoleAuthInfoType `protobuf:"bytes,3,opt,name=app_role_auth,json=appRoleAuth,proto3,oneof" json:"app_role_auth,omitempty"`
}
type VaultAccessInfoType_Token struct {
	Token *SecretType `protobuf:"bytes,4,opt,name=token,proto3,oneof" json:"token,omitempty"`
}

func (*VaultAccessInfoType_AppRoleAuth) isVaultAccessInfoType_AuthnChoice() {}
func (*VaultAccessInfoType_Token) isVaultAccessInfoType_AuthnChoice()       {}

func (m *VaultAccessInfoType) GetAuthnChoice() isVaultAccessInfoType_AuthnChoice {
	if m != nil {
		return m.AuthnChoice
	}
	return nil
}

func (m *VaultAccessInfoType) GetVaultAddr() string {
	if m != nil {
		return m.VaultAddr
	}
	return ""
}

func (m *VaultAccessInfoType) GetVaultCaUrl() string {
	if m != nil {
		return m.VaultCaUrl
	}
	return ""
}

func (m *VaultAccessInfoType) GetAppRoleAuth() *AppRoleAuthInfoType {
	if x, ok := m.GetAuthnChoice().(*VaultAccessInfoType_AppRoleAuth); ok {
		return x.AppRoleAuth
	}
	return nil
}

func (m *VaultAccessInfoType) GetToken() *SecretType {
	if x, ok := m.GetAuthnChoice().(*VaultAccessInfoType_Token); ok {
		return x.Token
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VaultAccessInfoType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VaultAccessInfoType_AppRoleAuth)(nil),
		(*VaultAccessInfoType_Token)(nil),
	}
}

// VaultSecretType
//
// x-displayName: "Vault Secret"
// VaultSecretType contains the information about a secret stored in Hashicorp vault
type VaultSecretType struct {
	// Types that are valid to be assigned to AccessChoice:
	//
	//	*VaultSecretType_VaultAccessInfo
	//	*VaultSecretType_ProviderName
	AccessChoice isVaultSecretType_AccessChoice `protobuf_oneof:"access_choice"`
	// secret_path
	//
	// x-displayName: "Secret Path"
	// secret_path provider, or can give access information inline.
	SecretPath string `protobuf:"bytes,3,opt,name=secret_path,json=secretPath,proto3" json:"secret_path,omitempty"`
	// secret_sub_path
	//
	// x-displayName: "Secret SubPath"
	// secret_sub_path contains the subPath of the secret in Hashicorp vault.
	SecretSubPath string `protobuf:"bytes,4,opt,name=secret_sub_path,json=secretSubPath,proto3" json:"secret_sub_path,omitempty"`
	// secret_version
	//
	// x-displayName: "Secret Version"
	// secret_version contains the version of the secret to be fetched from Hashicorp vault.
	SecretVersion string `protobuf:"bytes,5,opt,name=secret_version,json=secretVersion,proto3" json:"secret_version,omitempty"`
}

func (m *VaultSecretType) Reset()      { *m = VaultSecretType{} }
func (*VaultSecretType) ProtoMessage() {}
func (*VaultSecretType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{61}
}
func (m *VaultSecretType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VaultSecretType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VaultSecretType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VaultSecretType.Merge(m, src)
}
func (m *VaultSecretType) XXX_Size() int {
	return m.Size()
}
func (m *VaultSecretType) XXX_DiscardUnknown() {
	xxx_messageInfo_VaultSecretType.DiscardUnknown(m)
}

var xxx_messageInfo_VaultSecretType proto.InternalMessageInfo

type isVaultSecretType_AccessChoice interface {
	isVaultSecretType_AccessChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type VaultSecretType_VaultAccessInfo struct {
	VaultAccessInfo *VaultAccessInfoType `protobuf:"bytes,1,opt,name=vault_access_info,json=vaultAccessInfo,proto3,oneof" json:"vault_access_info,omitempty"`
}
type VaultSecretType_ProviderName struct {
	ProviderName string `protobuf:"bytes,2,opt,name=provider_name,json=providerName,proto3,oneof" json:"provider_name,omitempty"`
}

func (*VaultSecretType_VaultAccessInfo) isVaultSecretType_AccessChoice() {}
func (*VaultSecretType_ProviderName) isVaultSecretType_AccessChoice()    {}

func (m *VaultSecretType) GetAccessChoice() isVaultSecretType_AccessChoice {
	if m != nil {
		return m.AccessChoice
	}
	return nil
}

func (m *VaultSecretType) GetVaultAccessInfo() *VaultAccessInfoType {
	if x, ok := m.GetAccessChoice().(*VaultSecretType_VaultAccessInfo); ok {
		return x.VaultAccessInfo
	}
	return nil
}

func (m *VaultSecretType) GetProviderName() string {
	if x, ok := m.GetAccessChoice().(*VaultSecretType_ProviderName); ok {
		return x.ProviderName
	}
	return ""
}

func (m *VaultSecretType) GetSecretPath() string {
	if m != nil {
		return m.SecretPath
	}
	return ""
}

func (m *VaultSecretType) GetSecretSubPath() string {
	if m != nil {
		return m.SecretSubPath
	}
	return ""
}

func (m *VaultSecretType) GetSecretVersion() string {
	if m != nil {
		return m.SecretVersion
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VaultSecretType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VaultSecretType_VaultAccessInfo)(nil),
		(*VaultSecretType_ProviderName)(nil),
	}
}

// VolterraSecretType
//
// x-displayName: "F5XC Secret"
// VolterraSecretType contains the information about secret distributed by volterra.
type VolterraSecretType struct {
	// Types that are valid to be assigned to SecretTypeChoice:
	//
	//	*VolterraSecretType_BlindfoldSecretInfo
	//	*VolterraSecretType_VaultSecretInfo
	SecretTypeChoice isVolterraSecretType_SecretTypeChoice `protobuf_oneof:"secret_type_choice"`
}

func (m *VolterraSecretType) Reset()      { *m = VolterraSecretType{} }
func (*VolterraSecretType) ProtoMessage() {}
func (*VolterraSecretType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{62}
}
func (m *VolterraSecretType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VolterraSecretType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VolterraSecretType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolterraSecretType.Merge(m, src)
}
func (m *VolterraSecretType) XXX_Size() int {
	return m.Size()
}
func (m *VolterraSecretType) XXX_DiscardUnknown() {
	xxx_messageInfo_VolterraSecretType.DiscardUnknown(m)
}

var xxx_messageInfo_VolterraSecretType proto.InternalMessageInfo

type isVolterraSecretType_SecretTypeChoice interface {
	isVolterraSecretType_SecretTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type VolterraSecretType_BlindfoldSecretInfo struct {
	BlindfoldSecretInfo *BlindfoldSecretInfoType `protobuf:"bytes,1,opt,name=blindfold_secret_info,json=blindfoldSecretInfo,proto3,oneof" json:"blindfold_secret_info,omitempty"`
}
type VolterraSecretType_VaultSecretInfo struct {
	VaultSecretInfo *VaultAccessInfoType `protobuf:"bytes,2,opt,name=vault_secret_info,json=vaultSecretInfo,proto3,oneof" json:"vault_secret_info,omitempty"`
}

func (*VolterraSecretType_BlindfoldSecretInfo) isVolterraSecretType_SecretTypeChoice() {}
func (*VolterraSecretType_VaultSecretInfo) isVolterraSecretType_SecretTypeChoice()     {}

func (m *VolterraSecretType) GetSecretTypeChoice() isVolterraSecretType_SecretTypeChoice {
	if m != nil {
		return m.SecretTypeChoice
	}
	return nil
}

func (m *VolterraSecretType) GetBlindfoldSecretInfo() *BlindfoldSecretInfoType {
	if x, ok := m.GetSecretTypeChoice().(*VolterraSecretType_BlindfoldSecretInfo); ok {
		return x.BlindfoldSecretInfo
	}
	return nil
}

func (m *VolterraSecretType) GetVaultSecretInfo() *VaultAccessInfoType {
	if x, ok := m.GetSecretTypeChoice().(*VolterraSecretType_VaultSecretInfo); ok {
		return x.VaultSecretInfo
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VolterraSecretType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VolterraSecretType_BlindfoldSecretInfo)(nil),
		(*VolterraSecretType_VaultSecretInfo)(nil),
	}
}

// PortValueType
//
// x-displayName: "Port Value Type"
// PortValueType specifies the port value
// Can be any or a specified port
type PortValueType struct {
	// port_value_type_choice
	//
	// x-displayName: "Port Value Type"
	// Match criteria for port
	//
	// Types that are valid to be assigned to PortValueTypeChoice:
	//
	//	*PortValueType_All
	//	*PortValueType_UserDefined
	//	*PortValueType_Dns
	PortValueTypeChoice isPortValueType_PortValueTypeChoice `protobuf_oneof:"port_value_type_choice"`
}

func (m *PortValueType) Reset()      { *m = PortValueType{} }
func (*PortValueType) ProtoMessage() {}
func (*PortValueType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{63}
}
func (m *PortValueType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortValueType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PortValueType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortValueType.Merge(m, src)
}
func (m *PortValueType) XXX_Size() int {
	return m.Size()
}
func (m *PortValueType) XXX_DiscardUnknown() {
	xxx_messageInfo_PortValueType.DiscardUnknown(m)
}

var xxx_messageInfo_PortValueType proto.InternalMessageInfo

type isPortValueType_PortValueTypeChoice interface {
	isPortValueType_PortValueTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PortValueType_All struct {
	All *Empty `protobuf:"bytes,1,opt,name=all,proto3,oneof" json:"all,omitempty"`
}
type PortValueType_UserDefined struct {
	UserDefined uint32 `protobuf:"varint,2,opt,name=user_defined,json=userDefined,proto3,oneof" json:"user_defined,omitempty"`
}
type PortValueType_Dns struct {
	Dns *Empty `protobuf:"bytes,3,opt,name=dns,proto3,oneof" json:"dns,omitempty"`
}

func (*PortValueType_All) isPortValueType_PortValueTypeChoice()         {}
func (*PortValueType_UserDefined) isPortValueType_PortValueTypeChoice() {}
func (*PortValueType_Dns) isPortValueType_PortValueTypeChoice()         {}

func (m *PortValueType) GetPortValueTypeChoice() isPortValueType_PortValueTypeChoice {
	if m != nil {
		return m.PortValueTypeChoice
	}
	return nil
}

func (m *PortValueType) GetAll() *Empty {
	if x, ok := m.GetPortValueTypeChoice().(*PortValueType_All); ok {
		return x.All
	}
	return nil
}

func (m *PortValueType) GetUserDefined() uint32 {
	if x, ok := m.GetPortValueTypeChoice().(*PortValueType_UserDefined); ok {
		return x.UserDefined
	}
	return 0
}

func (m *PortValueType) GetDns() *Empty {
	if x, ok := m.GetPortValueTypeChoice().(*PortValueType_Dns); ok {
		return x.Dns
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PortValueType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PortValueType_All)(nil),
		(*PortValueType_UserDefined)(nil),
		(*PortValueType_Dns)(nil),
	}
}

// VirtualNetworkReferenceType
//
// x-displayName: "Virtual Network Reference Type"
// Carries the reference to virtual network
type VirtualNetworkReferenceType struct {
	// Virtual Network Reference
	//
	// x-displayName: "Virtual Network Reference"
	// Reference to virtual network
	Refs []*ObjectRefType `protobuf:"bytes,1,rep,name=refs,proto3" json:"refs,omitempty"`
}

func (m *VirtualNetworkReferenceType) Reset()      { *m = VirtualNetworkReferenceType{} }
func (*VirtualNetworkReferenceType) ProtoMessage() {}
func (*VirtualNetworkReferenceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{64}
}
func (m *VirtualNetworkReferenceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VirtualNetworkReferenceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VirtualNetworkReferenceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualNetworkReferenceType.Merge(m, src)
}
func (m *VirtualNetworkReferenceType) XXX_Size() int {
	return m.Size()
}
func (m *VirtualNetworkReferenceType) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualNetworkReferenceType.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualNetworkReferenceType proto.InternalMessageInfo

func (m *VirtualNetworkReferenceType) GetRefs() []*ObjectRefType {
	if m != nil {
		return m.Refs
	}
	return nil
}

// VirtualNetworkSelectorType
//
// x-displayName: "Virtual Network Type"
// Different types of virtual networks understood by the system
type VirtualNetworkSelectorType struct {
	// vn_type_choice
	//
	// x-displayName: "Virtual Network"
	// Different types of virtual networks understood by the system
	//
	// Types that are valid to be assigned to VnTypeChoice:
	//
	//	*VirtualNetworkSelectorType_SiteLocal
	//	*VirtualNetworkSelectorType_SiteLocalInside
	//	*VirtualNetworkSelectorType_Public
	VnTypeChoice isVirtualNetworkSelectorType_VnTypeChoice `protobuf_oneof:"vn_type_choice"`
}

func (m *VirtualNetworkSelectorType) Reset()      { *m = VirtualNetworkSelectorType{} }
func (*VirtualNetworkSelectorType) ProtoMessage() {}
func (*VirtualNetworkSelectorType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{65}
}
func (m *VirtualNetworkSelectorType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VirtualNetworkSelectorType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VirtualNetworkSelectorType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualNetworkSelectorType.Merge(m, src)
}
func (m *VirtualNetworkSelectorType) XXX_Size() int {
	return m.Size()
}
func (m *VirtualNetworkSelectorType) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualNetworkSelectorType.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualNetworkSelectorType proto.InternalMessageInfo

type isVirtualNetworkSelectorType_VnTypeChoice interface {
	isVirtualNetworkSelectorType_VnTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type VirtualNetworkSelectorType_SiteLocal struct {
	SiteLocal *Empty `protobuf:"bytes,1,opt,name=site_local,json=siteLocal,proto3,oneof" json:"site_local,omitempty"`
}
type VirtualNetworkSelectorType_SiteLocalInside struct {
	SiteLocalInside *Empty `protobuf:"bytes,2,opt,name=site_local_inside,json=siteLocalInside,proto3,oneof" json:"site_local_inside,omitempty"`
}
type VirtualNetworkSelectorType_Public struct {
	Public *Empty `protobuf:"bytes,4,opt,name=public,proto3,oneof" json:"public,omitempty"`
}

func (*VirtualNetworkSelectorType_SiteLocal) isVirtualNetworkSelectorType_VnTypeChoice()       {}
func (*VirtualNetworkSelectorType_SiteLocalInside) isVirtualNetworkSelectorType_VnTypeChoice() {}
func (*VirtualNetworkSelectorType_Public) isVirtualNetworkSelectorType_VnTypeChoice()          {}

func (m *VirtualNetworkSelectorType) GetVnTypeChoice() isVirtualNetworkSelectorType_VnTypeChoice {
	if m != nil {
		return m.VnTypeChoice
	}
	return nil
}

func (m *VirtualNetworkSelectorType) GetSiteLocal() *Empty {
	if x, ok := m.GetVnTypeChoice().(*VirtualNetworkSelectorType_SiteLocal); ok {
		return x.SiteLocal
	}
	return nil
}

func (m *VirtualNetworkSelectorType) GetSiteLocalInside() *Empty {
	if x, ok := m.GetVnTypeChoice().(*VirtualNetworkSelectorType_SiteLocalInside); ok {
		return x.SiteLocalInside
	}
	return nil
}

func (m *VirtualNetworkSelectorType) GetPublic() *Empty {
	if x, ok := m.GetVnTypeChoice().(*VirtualNetworkSelectorType_Public); ok {
		return x.Public
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VirtualNetworkSelectorType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VirtualNetworkSelectorType_SiteLocal)(nil),
		(*VirtualNetworkSelectorType_SiteLocalInside)(nil),
		(*VirtualNetworkSelectorType_Public)(nil),
	}
}

// RetryBackOff
//
// x-displayName: "Retry BackOff Interval"
// Specifies parameters that control retry back off.
type RetryBackOff struct {
	// base_interval
	//
	// x-displayName: "Base Retry Interval"
	// x-example: "5"
	// Specifies the base interval between retries in milliseconds
	BaseInterval uint32 `protobuf:"varint,1,opt,name=base_interval,json=baseInterval,proto3" json:"base_interval,omitempty"`
	// max_interval
	//
	// x-displayName: "Maximum Retry Interval"
	// x-example: "60"
	// Specifies the maximum interval between retries in milliseconds.
	// This parameter is optional, but must be greater than or equal
	// to the base_interval if set. The default is 10 times the base_interval.
	MaxInterval uint32 `protobuf:"varint,2,opt,name=max_interval,json=maxInterval,proto3" json:"max_interval,omitempty"`
}

func (m *RetryBackOff) Reset()      { *m = RetryBackOff{} }
func (*RetryBackOff) ProtoMessage() {}
func (*RetryBackOff) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{66}
}
func (m *RetryBackOff) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RetryBackOff) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RetryBackOff) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetryBackOff.Merge(m, src)
}
func (m *RetryBackOff) XXX_Size() int {
	return m.Size()
}
func (m *RetryBackOff) XXX_DiscardUnknown() {
	xxx_messageInfo_RetryBackOff.DiscardUnknown(m)
}

var xxx_messageInfo_RetryBackOff proto.InternalMessageInfo

func (m *RetryBackOff) GetBaseInterval() uint32 {
	if m != nil {
		return m.BaseInterval
	}
	return 0
}

func (m *RetryBackOff) GetMaxInterval() uint32 {
	if m != nil {
		return m.MaxInterval
	}
	return 0
}

// RetryPolicyType
//
// x-displayName: "Retry Policy"
// Retry policy configuration for route destination.
type RetryPolicyType struct {
	// retry_on
	//
	// x-displayName: "Retry On"
	// x-example: "5xx"
	// Specifies the conditions under which retry takes place.
	// Retries can be on different types of condition depending on application requirements.
	// For example, network failure, all 5xx response codes, idempotent 4xx response codes, etc
	//
	// # The possible values are
	//
	// "5xx"             : Retry will be done if the upstream server responds with any 5xx response code,
	//
	//	or does not respond at all (disconnect/reset/read timeout).
	//
	// "gateway-error"   : Retry will be done only if the upstream server responds with 502, 503 or
	//
	//	504 responses (Included in 5xx)
	//
	// "connect-failure" : Retry will be done if the request fails because of a connection failure to the
	//
	//	upstream server (connect timeout, etc.). (Included in 5xx)
	//
	// "refused-stream"  : Retry is done if the upstream server resets the stream with a REFUSED_STREAM
	//
	//	error code (Included in 5xx)
	//
	// "retriable-4xx"   : Retry is done if the upstream server responds with a retriable 4xx response code.
	//
	//	The only response code in this category is HTTP CONFLICT (409)
	//
	// "retriable-status-codes" :  Retry is done if the upstream server responds with any response code
	//
	//	matching one defined in retriable_status_codes field
	RetryOn string `protobuf:"bytes,1,opt,name=retry_on,json=retryOn,proto3" json:"retry_on,omitempty"` // Deprecated: Do not use.
	// retry_condition
	//
	// x-displayName: "Retry Condition"
	// x-example: "5xx"
	// x-required
	// Specifies the conditions under which retry takes place.
	// Retries can be on different types of condition depending on application requirements.
	// For example, network failure, all 5xx response codes, idempotent 4xx response codes, etc
	//
	// # The possible values are
	//
	// "5xx"             : Retry will be done if the upstream server responds with any 5xx response code,
	//
	//	or does not respond at all (disconnect/reset/read timeout).
	//
	// "gateway-error"   : Retry will be done only if the upstream server responds with 502, 503 or
	//
	//	504 responses (Included in 5xx)
	//
	// "connect-failure" : Retry will be done if the request fails because of a connection failure to the
	//
	//	upstream server (connect timeout, etc.). (Included in 5xx)
	//
	// "refused-stream"  : Retry is done if the upstream server resets the stream with a REFUSED_STREAM
	//
	//	error code (Included in 5xx)
	//
	// "retriable-4xx"   : Retry is done if the upstream server responds with a retriable 4xx response code.
	//
	//	The only response code in this category is HTTP CONFLICT (409)
	//
	// "retriable-status-codes" :  Retry is done if the upstream server responds with any response code
	//
	//	matching one defined in retriable_status_codes field
	//
	// "reset"           : Retry is done if the upstream server does not respond at all
	//
	//	(disconnect/reset/read timeout.)
	RetryCondition []string `protobuf:"bytes,6,rep,name=retry_condition,json=retryCondition,proto3" json:"retry_condition,omitempty"`
	// num_retries
	//
	// x-displayName: "Number of Retries"
	// x-example: "3"
	// Specifies the allowed number of retries. Defaults to 1.
	// Retries can be done any number of times. An exponential back-off algorithm
	// is used between each retry
	NumRetries uint32 `protobuf:"varint,2,opt,name=num_retries,json=numRetries,proto3" json:"num_retries,omitempty"`
	// per_try_timeout
	//
	// x-displayName: "Per Try Timeout"
	// x-example: "1000"
	// Specifies a non-zero timeout per retry attempt. In milliseconds
	PerTryTimeout uint32 `protobuf:"varint,3,opt,name=per_try_timeout,json=perTryTimeout,proto3" json:"per_try_timeout,omitempty"`
	// Retriable status Code
	//
	// x-displayName: "Status Code to Retry"
	// x-example: "403"
	// HTTP status codes that should trigger a retry in addition to those specified by retry_on.
	RetriableStatusCodes []uint32 `protobuf:"varint,4,rep,packed,name=retriable_status_codes,json=retriableStatusCodes,proto3" json:"retriable_status_codes,omitempty"`
	// Retry BackOff
	//
	// x-displayName: "Retry BackOff interval"
	// Specifies parameters that control retry back off.
	// This parameter is optional, in which case the default base
	// interval is 25 milliseconds. The default maximum interval is
	// 10 times the base interval
	BackOff *RetryBackOff `protobuf:"bytes,5,opt,name=back_off,json=backOff,proto3" json:"back_off,omitempty"`
}

func (m *RetryPolicyType) Reset()      { *m = RetryPolicyType{} }
func (*RetryPolicyType) ProtoMessage() {}
func (*RetryPolicyType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{67}
}
func (m *RetryPolicyType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RetryPolicyType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RetryPolicyType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetryPolicyType.Merge(m, src)
}
func (m *RetryPolicyType) XXX_Size() int {
	return m.Size()
}
func (m *RetryPolicyType) XXX_DiscardUnknown() {
	xxx_messageInfo_RetryPolicyType.DiscardUnknown(m)
}

var xxx_messageInfo_RetryPolicyType proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *RetryPolicyType) GetRetryOn() string {
	if m != nil {
		return m.RetryOn
	}
	return ""
}

func (m *RetryPolicyType) GetRetryCondition() []string {
	if m != nil {
		return m.RetryCondition
	}
	return nil
}

func (m *RetryPolicyType) GetNumRetries() uint32 {
	if m != nil {
		return m.NumRetries
	}
	return 0
}

func (m *RetryPolicyType) GetPerTryTimeout() uint32 {
	if m != nil {
		return m.PerTryTimeout
	}
	return 0
}

func (m *RetryPolicyType) GetRetriableStatusCodes() []uint32 {
	if m != nil {
		return m.RetriableStatusCodes
	}
	return nil
}

func (m *RetryPolicyType) GetBackOff() *RetryBackOff {
	if m != nil {
		return m.BackOff
	}
	return nil
}

// Metric Value
//
// x-displayName: "Metric Value"
// Metric data contains timestamp and the value.
type MetricValue struct {
	// Timestamp
	//
	// x-displayName: "Timestamp"
	// x-example: "1570007981"
	// timestamp
	Timestamp float64 `protobuf:"fixed64,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Value
	//
	// x-displayName: "Value"
	// x-example: "15"
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// Trend value
	//
	// x-displayName: "Trend Value"
	// x-example: "100.000000"
	// trend value for the metric
	TrendValue *TrendValue `protobuf:"bytes,3,opt,name=trend_value,json=trendValue,proto3" json:"trend_value,omitempty"`
}

func (m *MetricValue) Reset()      { *m = MetricValue{} }
func (*MetricValue) ProtoMessage() {}
func (*MetricValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{68}
}
func (m *MetricValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MetricValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricValue.Merge(m, src)
}
func (m *MetricValue) XXX_Size() int {
	return m.Size()
}
func (m *MetricValue) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricValue.DiscardUnknown(m)
}

var xxx_messageInfo_MetricValue proto.InternalMessageInfo

func (m *MetricValue) GetTimestamp() float64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *MetricValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *MetricValue) GetTrendValue() *TrendValue {
	if m != nil {
		return m.TrendValue
	}
	return nil
}

// Metric Type Data
//
// x-displayName: "Metric Type Data"
// Metric Type Data contains key that uniquely identifies individual entity and its corresponding metric values.
type MetricTypeData struct {
	// Labels
	//
	// x-displayName: "Labels"
	// Labels contains the name/value pair that uniquely identifies an entity whose metric is being reported.
	// If the Labels is empty, then the metric value is aggregated across all labels.
	Labels map[string]string `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Value
	//
	// x-displayName: "Value"
	// List of metric values. May contain more than one value if timeseries data is requested.
	Values []*MetricValue `protobuf:"bytes,2,rep,name=values,proto3" json:"values,omitempty"`
}

func (m *MetricTypeData) Reset()      { *m = MetricTypeData{} }
func (*MetricTypeData) ProtoMessage() {}
func (*MetricTypeData) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{69}
}
func (m *MetricTypeData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricTypeData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MetricTypeData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricTypeData.Merge(m, src)
}
func (m *MetricTypeData) XXX_Size() int {
	return m.Size()
}
func (m *MetricTypeData) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricTypeData.DiscardUnknown(m)
}

var xxx_messageInfo_MetricTypeData proto.InternalMessageInfo

func (m *MetricTypeData) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *MetricTypeData) GetValues() []*MetricValue {
	if m != nil {
		return m.Values
	}
	return nil
}

// Trend Value
//
// x-displayName: "Trend Value"
// Trend value contains trend value, trend sentiment and trend calculation description and window size.
type TrendValue struct {
	// Value
	//
	// x-displayName: "Value"
	// x-example: "-15"
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// Sentiment
	//
	// x-displayName: "Sentiment"
	// x-example: "Positive"
	Sentiment TrendSentiment `protobuf:"varint,2,opt,name=sentiment,proto3,enum=ves.io.schema.TrendSentiment" json:"sentiment,omitempty"`
	// Description
	//
	// x-displayName: "Description"
	// x-example: "Trend was calculated by comparing the avg of window size intervals of end-start Time and last window time interval"
	// description of the method used to calculate trend.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Previous Value
	//
	// x-displayName: "Previous Value"
	// x-example: "200.00"
	PreviousValue string `protobuf:"bytes,4,opt,name=previous_value,json=previousValue,proto3" json:"previous_value,omitempty"`
}

func (m *TrendValue) Reset()      { *m = TrendValue{} }
func (*TrendValue) ProtoMessage() {}
func (*TrendValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{70}
}
func (m *TrendValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrendValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TrendValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrendValue.Merge(m, src)
}
func (m *TrendValue) XXX_Size() int {
	return m.Size()
}
func (m *TrendValue) XXX_DiscardUnknown() {
	xxx_messageInfo_TrendValue.DiscardUnknown(m)
}

var xxx_messageInfo_TrendValue proto.InternalMessageInfo

func (m *TrendValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *TrendValue) GetSentiment() TrendSentiment {
	if m != nil {
		return m.Sentiment
	}
	return TREND_SENTIMENT_NONE
}

func (m *TrendValue) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *TrendValue) GetPreviousValue() string {
	if m != nil {
		return m.PreviousValue
	}
	return ""
}

// Nexthop
//
// x-displayName: "Nexthop"
// Identifies the next-hop for a route
type NextHopType struct {
	// Type
	//
	// x-displayName: "Type"
	// Identifies the type of next-hop
	Type NextHopTypes `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.NextHopTypes" json:"type,omitempty"`
	// Nexthop Address
	//
	// x-displayName: "Address"
	// Nexthop address when type is "Use-Configured"
	NexthopAddress *IpAddressType `protobuf:"bytes,2,opt,name=nexthop_address,json=nexthopAddress,proto3" json:"nexthop_address,omitempty"`
	// Network Interface
	//
	// x-displayName: "Network Interface"
	// Nexthop is network interface when type is "Network-Interface"
	Interface []*ObjectRefType `protobuf:"bytes,3,rep,name=interface,proto3" json:"interface,omitempty"`
}

func (m *NextHopType) Reset()      { *m = NextHopType{} }
func (*NextHopType) ProtoMessage() {}
func (*NextHopType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{71}
}
func (m *NextHopType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NextHopType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NextHopType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NextHopType.Merge(m, src)
}
func (m *NextHopType) XXX_Size() int {
	return m.Size()
}
func (m *NextHopType) XXX_DiscardUnknown() {
	xxx_messageInfo_NextHopType.DiscardUnknown(m)
}

var xxx_messageInfo_NextHopType proto.InternalMessageInfo

func (m *NextHopType) GetType() NextHopTypes {
	if m != nil {
		return m.Type
	}
	return NEXT_HOP_DEFAULT_GATEWAY
}

func (m *NextHopType) GetNexthopAddress() *IpAddressType {
	if m != nil {
		return m.NexthopAddress
	}
	return nil
}

func (m *NextHopType) GetInterface() []*ObjectRefType {
	if m != nil {
		return m.Interface
	}
	return nil
}

// Static Route
//
// x-displayName: "Static Route"
// Defines a static route, configuring a list of prefixes and a next-hop to be used for them
type StaticRouteType struct {
	// Attributes
	//
	// x-displayName: "Attributes"
	// List of route attributes associated with the static route
	Attrs []RouteAttrType `protobuf:"varint,1,rep,packed,name=attrs,proto3,enum=ves.io.schema.RouteAttrType" json:"attrs,omitempty"`
	// Subnets
	//
	// x-displayName: "Subnets"
	// x-required
	// List of route prefixes
	Subnets []*IpSubnetType `protobuf:"bytes,2,rep,name=subnets,proto3" json:"subnets,omitempty"`
	// Nexthop
	//
	// x-displayName: "Nexthop"
	// Nexthop for the route
	Nexthop *NextHopType `protobuf:"bytes,10,opt,name=nexthop,proto3" json:"nexthop,omitempty"`
	// Static Route labels
	//
	// x-displayName: "Static Route Labels"
	// x-example: "value"
	// Add Labels for this Static Route, these labels can be used in network policy
	Labels map[string]string `protobuf:"bytes,11,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *StaticRouteType) Reset()      { *m = StaticRouteType{} }
func (*StaticRouteType) ProtoMessage() {}
func (*StaticRouteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{72}
}
func (m *StaticRouteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StaticRouteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StaticRouteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StaticRouteType.Merge(m, src)
}
func (m *StaticRouteType) XXX_Size() int {
	return m.Size()
}
func (m *StaticRouteType) XXX_DiscardUnknown() {
	xxx_messageInfo_StaticRouteType.DiscardUnknown(m)
}

var xxx_messageInfo_StaticRouteType proto.InternalMessageInfo

func (m *StaticRouteType) GetAttrs() []RouteAttrType {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *StaticRouteType) GetSubnets() []*IpSubnetType {
	if m != nil {
		return m.Subnets
	}
	return nil
}

func (m *StaticRouteType) GetNexthop() *NextHopType {
	if m != nil {
		return m.Nexthop
	}
	return nil
}

func (m *StaticRouteType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// ForwardProxyConfigType
//
// x-displayName: "Forward Proxy Configuration"
// Fine tune forward proxy behavior
//
// Few configurations allowed are
//
//	White listed ports and ip prefixes:
//	  Forward proxy does application protocol detection and server name(SNI) detection by peeking into
//	  the traffic on the incoming downstream connection. Few protocols doesn't have client sending
//	  the first data. In such cases, protocol and SNI detection fails. This configuration allows,
//	  skipping protocol and SNI detection for whitelisted ip-prefix-list and ports
//	connection_timeout:
//	  The timeout for new network connections to upstream server.
//	max_connect_attempts:
//	  Maximum number of attempts made to make new network connection to upstream server.
type ForwardProxyConfigType struct {
	// IP prefix list
	//
	// x-displayName: "IP Prefixes to Skip Protocol Parsing"
	// x-example: "['10.2.1.0/24', '192.168.8.0/29', '10.7.64.160/27']"
	// Traffic to these destination ip prefixes is not subjected to protocol parsing
	// Example "tmate" server ip
	WhiteListedPrefixes []string `protobuf:"bytes,1,rep,name=white_listed_prefixes,json=whiteListedPrefixes,proto3" json:"white_listed_prefixes,omitempty"`
	// Port list
	//
	// x-displayName: "TCP Ports to Skip Protocol Parsing"
	// x-example: "[22, 9400]"
	// Traffic to these destination TCP ports is not subjected to protocol parsing
	// Example "tmate" server port
	WhiteListedPorts []uint32 `protobuf:"varint,2,rep,packed,name=white_listed_ports,json=whiteListedPorts,proto3" json:"white_listed_ports,omitempty"`
	// max_connect_attempts
	//
	// x-displayName: "Number of connect attempts"
	// x-example: "3"
	// Specifies the allowed number of retries on connect failure to upstream server. Defaults to 1.
	MaxConnectAttempts uint32 `protobuf:"varint,3,opt,name=max_connect_attempts,json=maxConnectAttempts,proto3" json:"max_connect_attempts,omitempty"`
	// connection_timeout
	//
	// x-displayName: "Connection Timeout"
	// x-example: "4000"
	// The timeout for new network connections to upstream server.
	// This is specified in milliseconds. The default value is 2000 (2 seconds)
	ConnectionTimeout uint32 `protobuf:"varint,4,opt,name=connection_timeout,json=connectionTimeout,proto3" json:"connection_timeout,omitempty"`
	// TLS Interception choice
	//
	// x-displayName: "Enable TLS Interception"
	// TLS interception is enabled for HTTPS connections
	// This configuration is applicable only when ForwardProxy and DynamicReverseProxy is enabled on the network connector
	//
	// Types that are valid to be assigned to TlsInterceptionChoice:
	//
	//	*ForwardProxyConfigType_NoInterception
	//	*ForwardProxyConfigType_TlsIntercept
	TlsInterceptionChoice isForwardProxyConfigType_TlsInterceptionChoice `protobuf_oneof:"tls_interception_choice"`
}

func (m *ForwardProxyConfigType) Reset()      { *m = ForwardProxyConfigType{} }
func (*ForwardProxyConfigType) ProtoMessage() {}
func (*ForwardProxyConfigType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{73}
}
func (m *ForwardProxyConfigType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForwardProxyConfigType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ForwardProxyConfigType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForwardProxyConfigType.Merge(m, src)
}
func (m *ForwardProxyConfigType) XXX_Size() int {
	return m.Size()
}
func (m *ForwardProxyConfigType) XXX_DiscardUnknown() {
	xxx_messageInfo_ForwardProxyConfigType.DiscardUnknown(m)
}

var xxx_messageInfo_ForwardProxyConfigType proto.InternalMessageInfo

type isForwardProxyConfigType_TlsInterceptionChoice interface {
	isForwardProxyConfigType_TlsInterceptionChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ForwardProxyConfigType_NoInterception struct {
	NoInterception *Empty `protobuf:"bytes,6,opt,name=no_interception,json=noInterception,proto3,oneof" json:"no_interception,omitempty"`
}
type ForwardProxyConfigType_TlsIntercept struct {
	TlsIntercept *TlsInterceptionType `protobuf:"bytes,7,opt,name=tls_intercept,json=tlsIntercept,proto3,oneof" json:"tls_intercept,omitempty"`
}

func (*ForwardProxyConfigType_NoInterception) isForwardProxyConfigType_TlsInterceptionChoice() {}
func (*ForwardProxyConfigType_TlsIntercept) isForwardProxyConfigType_TlsInterceptionChoice()   {}

func (m *ForwardProxyConfigType) GetTlsInterceptionChoice() isForwardProxyConfigType_TlsInterceptionChoice {
	if m != nil {
		return m.TlsInterceptionChoice
	}
	return nil
}

func (m *ForwardProxyConfigType) GetWhiteListedPrefixes() []string {
	if m != nil {
		return m.WhiteListedPrefixes
	}
	return nil
}

func (m *ForwardProxyConfigType) GetWhiteListedPorts() []uint32 {
	if m != nil {
		return m.WhiteListedPorts
	}
	return nil
}

func (m *ForwardProxyConfigType) GetMaxConnectAttempts() uint32 {
	if m != nil {
		return m.MaxConnectAttempts
	}
	return 0
}

func (m *ForwardProxyConfigType) GetConnectionTimeout() uint32 {
	if m != nil {
		return m.ConnectionTimeout
	}
	return 0
}

func (m *ForwardProxyConfigType) GetNoInterception() *Empty {
	if x, ok := m.GetTlsInterceptionChoice().(*ForwardProxyConfigType_NoInterception); ok {
		return x.NoInterception
	}
	return nil
}

func (m *ForwardProxyConfigType) GetTlsIntercept() *TlsInterceptionType {
	if x, ok := m.GetTlsInterceptionChoice().(*ForwardProxyConfigType_TlsIntercept); ok {
		return x.TlsIntercept
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ForwardProxyConfigType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ForwardProxyConfigType_NoInterception)(nil),
		(*ForwardProxyConfigType_TlsIntercept)(nil),
	}
}

// Host Identifier
//
// x-displayName: "Host Identifier"
// Host Identifier identifies a host, either by its DNS name (hostname) or by its IP address.
type HostIdentifier struct {
	// hostname_or_ip
	//
	// x-displayName: "Hostname/IP"
	// One of following
	//
	// Types that are valid to be assigned to HostnameOrIp:
	//
	//	*HostIdentifier_Ip
	//	*HostIdentifier_Hostname
	HostnameOrIp isHostIdentifier_HostnameOrIp `protobuf_oneof:"hostname_or_ip"`
}

func (m *HostIdentifier) Reset()      { *m = HostIdentifier{} }
func (*HostIdentifier) ProtoMessage() {}
func (*HostIdentifier) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{74}
}
func (m *HostIdentifier) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HostIdentifier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HostIdentifier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostIdentifier.Merge(m, src)
}
func (m *HostIdentifier) XXX_Size() int {
	return m.Size()
}
func (m *HostIdentifier) XXX_DiscardUnknown() {
	xxx_messageInfo_HostIdentifier.DiscardUnknown(m)
}

var xxx_messageInfo_HostIdentifier proto.InternalMessageInfo

type isHostIdentifier_HostnameOrIp interface {
	isHostIdentifier_HostnameOrIp()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type HostIdentifier_Ip struct {
	Ip string `protobuf:"bytes,1,opt,name=ip,proto3,oneof" json:"ip,omitempty"`
}
type HostIdentifier_Hostname struct {
	Hostname string `protobuf:"bytes,2,opt,name=hostname,proto3,oneof" json:"hostname,omitempty"`
}

func (*HostIdentifier_Ip) isHostIdentifier_HostnameOrIp()       {}
func (*HostIdentifier_Hostname) isHostIdentifier_HostnameOrIp() {}

func (m *HostIdentifier) GetHostnameOrIp() isHostIdentifier_HostnameOrIp {
	if m != nil {
		return m.HostnameOrIp
	}
	return nil
}

func (m *HostIdentifier) GetIp() string {
	if x, ok := m.GetHostnameOrIp().(*HostIdentifier_Ip); ok {
		return x.Ip
	}
	return ""
}

func (m *HostIdentifier) GetHostname() string {
	if x, ok := m.GetHostnameOrIp().(*HostIdentifier_Hostname); ok {
		return x.Hostname
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HostIdentifier) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HostIdentifier_Ip)(nil),
		(*HostIdentifier_Hostname)(nil),
	}
}

// Interface Identifier
//
// x-displayName: "Interface Identifier"
// Interface Identifier identifies one or all interfaces on a node
type InterfaceIdentifier struct {
	// Interface Choice
	//
	// x-displayName: "Interface Choice"
	// One of following
	//
	// Types that are valid to be assigned to InterfaceChoice:
	//
	//	*InterfaceIdentifier_AnyIntf
	//	*InterfaceIdentifier_Intf
	InterfaceChoice isInterfaceIdentifier_InterfaceChoice `protobuf_oneof:"interface_choice"`
}

func (m *InterfaceIdentifier) Reset()      { *m = InterfaceIdentifier{} }
func (*InterfaceIdentifier) ProtoMessage() {}
func (*InterfaceIdentifier) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{75}
}
func (m *InterfaceIdentifier) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceIdentifier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InterfaceIdentifier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceIdentifier.Merge(m, src)
}
func (m *InterfaceIdentifier) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceIdentifier) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceIdentifier.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceIdentifier proto.InternalMessageInfo

type isInterfaceIdentifier_InterfaceChoice interface {
	isInterfaceIdentifier_InterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type InterfaceIdentifier_AnyIntf struct {
	AnyIntf *Empty `protobuf:"bytes,1,opt,name=any_intf,json=anyIntf,proto3,oneof" json:"any_intf,omitempty"`
}
type InterfaceIdentifier_Intf struct {
	Intf string `protobuf:"bytes,2,opt,name=intf,proto3,oneof" json:"intf,omitempty"`
}

func (*InterfaceIdentifier_AnyIntf) isInterfaceIdentifier_InterfaceChoice() {}
func (*InterfaceIdentifier_Intf) isInterfaceIdentifier_InterfaceChoice()    {}

func (m *InterfaceIdentifier) GetInterfaceChoice() isInterfaceIdentifier_InterfaceChoice {
	if m != nil {
		return m.InterfaceChoice
	}
	return nil
}

func (m *InterfaceIdentifier) GetAnyIntf() *Empty {
	if x, ok := m.GetInterfaceChoice().(*InterfaceIdentifier_AnyIntf); ok {
		return x.AnyIntf
	}
	return nil
}

func (m *InterfaceIdentifier) GetIntf() string {
	if x, ok := m.GetInterfaceChoice().(*InterfaceIdentifier_Intf); ok {
		return x.Intf
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*InterfaceIdentifier) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*InterfaceIdentifier_AnyIntf)(nil),
		(*InterfaceIdentifier_Intf)(nil),
	}
}

// Interface Or Network
//
// x-displayName: "Interface Or Network"
// Selects an interface on a node
type InterfaceOrNetwork struct {
	// Interface Choice
	//
	// x-displayName: "Interface Choice"
	// One of following
	//
	// Types that are valid to be assigned to InterfaceChoice:
	//
	//	*InterfaceOrNetwork_Intf
	//	*InterfaceOrNetwork_Pod
	//	*InterfaceOrNetwork_VnType
	//	*InterfaceOrNetwork_Vn
	InterfaceChoice isInterfaceOrNetwork_InterfaceChoice `protobuf_oneof:"interface_choice"`
}

func (m *InterfaceOrNetwork) Reset()      { *m = InterfaceOrNetwork{} }
func (*InterfaceOrNetwork) ProtoMessage() {}
func (*InterfaceOrNetwork) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{76}
}
func (m *InterfaceOrNetwork) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceOrNetwork) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InterfaceOrNetwork) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceOrNetwork.Merge(m, src)
}
func (m *InterfaceOrNetwork) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceOrNetwork) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceOrNetwork.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceOrNetwork proto.InternalMessageInfo

type isInterfaceOrNetwork_InterfaceChoice interface {
	isInterfaceOrNetwork_InterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type InterfaceOrNetwork_Intf struct {
	Intf string `protobuf:"bytes,1,opt,name=intf,proto3,oneof" json:"intf,omitempty"`
}
type InterfaceOrNetwork_Pod struct {
	Pod string `protobuf:"bytes,2,opt,name=pod,proto3,oneof" json:"pod,omitempty"`
}
type InterfaceOrNetwork_VnType struct {
	VnType VirtualNetworkType `protobuf:"varint,3,opt,name=vn_type,json=vnType,proto3,enum=ves.io.schema.VirtualNetworkType,oneof" json:"vn_type,omitempty"`
}
type InterfaceOrNetwork_Vn struct {
	Vn string `protobuf:"bytes,4,opt,name=vn,proto3,oneof" json:"vn,omitempty"`
}

func (*InterfaceOrNetwork_Intf) isInterfaceOrNetwork_InterfaceChoice()   {}
func (*InterfaceOrNetwork_Pod) isInterfaceOrNetwork_InterfaceChoice()    {}
func (*InterfaceOrNetwork_VnType) isInterfaceOrNetwork_InterfaceChoice() {}
func (*InterfaceOrNetwork_Vn) isInterfaceOrNetwork_InterfaceChoice()     {}

func (m *InterfaceOrNetwork) GetInterfaceChoice() isInterfaceOrNetwork_InterfaceChoice {
	if m != nil {
		return m.InterfaceChoice
	}
	return nil
}

func (m *InterfaceOrNetwork) GetIntf() string {
	if x, ok := m.GetInterfaceChoice().(*InterfaceOrNetwork_Intf); ok {
		return x.Intf
	}
	return ""
}

func (m *InterfaceOrNetwork) GetPod() string {
	if x, ok := m.GetInterfaceChoice().(*InterfaceOrNetwork_Pod); ok {
		return x.Pod
	}
	return ""
}

func (m *InterfaceOrNetwork) GetVnType() VirtualNetworkType {
	if x, ok := m.GetInterfaceChoice().(*InterfaceOrNetwork_VnType); ok {
		return x.VnType
	}
	return VIRTUAL_NETWORK_SITE_LOCAL
}

func (m *InterfaceOrNetwork) GetVn() string {
	if x, ok := m.GetInterfaceChoice().(*InterfaceOrNetwork_Vn); ok {
		return x.Vn
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*InterfaceOrNetwork) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*InterfaceOrNetwork_Intf)(nil),
		(*InterfaceOrNetwork_Pod)(nil),
		(*InterfaceOrNetwork_VnType)(nil),
		(*InterfaceOrNetwork_Vn)(nil),
	}
}

// RouteTarget2ByteAsn
//
// x-displayName: "Route Target"
// BGP Two-Octet AS Specific Route Target as per RFC 4360.
type RouteTarget2ByteAsn struct {
	// as_number
	//
	// x-displayName: "AS Number"
	// x-example: "100"
	// x-required
	// Two-Octet AS Number.
	AsNumber uint32 `protobuf:"varint,3,opt,name=as_number,json=asNumber,proto3" json:"as_number,omitempty"`
	// value
	//
	// x-displayName: "Local Administrator Field"
	// x-example: "100"
	// x-required
	// A 4-byte value that is unique in the scope of the ASN.
	Value uint32 `protobuf:"varint,4,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *RouteTarget2ByteAsn) Reset()      { *m = RouteTarget2ByteAsn{} }
func (*RouteTarget2ByteAsn) ProtoMessage() {}
func (*RouteTarget2ByteAsn) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{77}
}
func (m *RouteTarget2ByteAsn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteTarget2ByteAsn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteTarget2ByteAsn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteTarget2ByteAsn.Merge(m, src)
}
func (m *RouteTarget2ByteAsn) XXX_Size() int {
	return m.Size()
}
func (m *RouteTarget2ByteAsn) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteTarget2ByteAsn.DiscardUnknown(m)
}

var xxx_messageInfo_RouteTarget2ByteAsn proto.InternalMessageInfo

func (m *RouteTarget2ByteAsn) GetAsNumber() uint32 {
	if m != nil {
		return m.AsNumber
	}
	return 0
}

func (m *RouteTarget2ByteAsn) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

// RouteTarget4ByteAsn
//
// x-displayName: "Four-Octet AS Specific Route Target"
// BGP Four-Octet AS Specific Route Target as per RFC 5668.
type RouteTarget4ByteAsn struct {
	// as_number
	//
	// x-displayName: "AS Number"
	// x-example: "100000"
	// x-required
	// Four-Octet AS Number.
	AsNumber uint32 `protobuf:"varint,3,opt,name=as_number,json=asNumber,proto3" json:"as_number,omitempty"`
	// value
	//
	// x-displayName: "Local Administrator Field"
	// x-example: "100"
	// x-required
	// A 2-byte value that is unique in the scope of the ASN.
	Value uint32 `protobuf:"varint,4,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *RouteTarget4ByteAsn) Reset()      { *m = RouteTarget4ByteAsn{} }
func (*RouteTarget4ByteAsn) ProtoMessage() {}
func (*RouteTarget4ByteAsn) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{78}
}
func (m *RouteTarget4ByteAsn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteTarget4ByteAsn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteTarget4ByteAsn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteTarget4ByteAsn.Merge(m, src)
}
func (m *RouteTarget4ByteAsn) XXX_Size() int {
	return m.Size()
}
func (m *RouteTarget4ByteAsn) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteTarget4ByteAsn.DiscardUnknown(m)
}

var xxx_messageInfo_RouteTarget4ByteAsn proto.InternalMessageInfo

func (m *RouteTarget4ByteAsn) GetAsNumber() uint32 {
	if m != nil {
		return m.AsNumber
	}
	return 0
}

func (m *RouteTarget4ByteAsn) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

// RouteTargetIPv4Addr
//
// x-displayName: "IPv4 Address Specific Route Target"
// BGP IPv4 Address Specific Route Target as per RFC 4360.
type RouteTargetIPv4Addr struct {
	// address
	//
	// x-displayName: "IPv4 Address"
	// x-example: "1.1.1.1"
	// x-required
	// IPv4 Address
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// value
	//
	// x-displayName: "Local Administrator Field"
	// x-example: "100"
	// x-required
	// A 2-byte value that is unique in the scope of the IPv4 address.
	Value uint32 `protobuf:"varint,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *RouteTargetIPv4Addr) Reset()      { *m = RouteTargetIPv4Addr{} }
func (*RouteTargetIPv4Addr) ProtoMessage() {}
func (*RouteTargetIPv4Addr) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{79}
}
func (m *RouteTargetIPv4Addr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteTargetIPv4Addr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteTargetIPv4Addr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteTargetIPv4Addr.Merge(m, src)
}
func (m *RouteTargetIPv4Addr) XXX_Size() int {
	return m.Size()
}
func (m *RouteTargetIPv4Addr) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteTargetIPv4Addr.DiscardUnknown(m)
}

var xxx_messageInfo_RouteTargetIPv4Addr proto.InternalMessageInfo

func (m *RouteTargetIPv4Addr) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RouteTargetIPv4Addr) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

// RouteTarget
//
// x-displayName: "Route Target"
// BGP Route Target extended community as per RFC 4360.
type RouteTarget struct {
	// rtarget_choice
	//
	// x-displayName: "Route Target Type"
	// x-required
	// Select type of Route Target.
	//
	// Types that are valid to be assigned to RtargetChoice:
	//
	//	*RouteTarget_Asn2ByteRtarget
	//	*RouteTarget_Ipv4AddrRtarget
	//	*RouteTarget_Asn4ByteRtarget
	RtargetChoice isRouteTarget_RtargetChoice `protobuf_oneof:"rtarget_choice"`
}

func (m *RouteTarget) Reset()      { *m = RouteTarget{} }
func (*RouteTarget) ProtoMessage() {}
func (*RouteTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{80}
}
func (m *RouteTarget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteTarget.Merge(m, src)
}
func (m *RouteTarget) XXX_Size() int {
	return m.Size()
}
func (m *RouteTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteTarget.DiscardUnknown(m)
}

var xxx_messageInfo_RouteTarget proto.InternalMessageInfo

type isRouteTarget_RtargetChoice interface {
	isRouteTarget_RtargetChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type RouteTarget_Asn2ByteRtarget struct {
	Asn2ByteRtarget *RouteTarget2ByteAsn `protobuf:"bytes,2,opt,name=asn2byte_rtarget,json=asn2byteRtarget,proto3,oneof" json:"asn2byte_rtarget,omitempty"`
}
type RouteTarget_Ipv4AddrRtarget struct {
	Ipv4AddrRtarget *RouteTargetIPv4Addr `protobuf:"bytes,3,opt,name=ipv4_addr_rtarget,json=ipv4AddrRtarget,proto3,oneof" json:"ipv4_addr_rtarget,omitempty"`
}
type RouteTarget_Asn4ByteRtarget struct {
	Asn4ByteRtarget *RouteTarget4ByteAsn `protobuf:"bytes,4,opt,name=asn4byte_rtarget,json=asn4byteRtarget,proto3,oneof" json:"asn4byte_rtarget,omitempty"`
}

func (*RouteTarget_Asn2ByteRtarget) isRouteTarget_RtargetChoice() {}
func (*RouteTarget_Ipv4AddrRtarget) isRouteTarget_RtargetChoice() {}
func (*RouteTarget_Asn4ByteRtarget) isRouteTarget_RtargetChoice() {}

func (m *RouteTarget) GetRtargetChoice() isRouteTarget_RtargetChoice {
	if m != nil {
		return m.RtargetChoice
	}
	return nil
}

func (m *RouteTarget) GetAsn2ByteRtarget() *RouteTarget2ByteAsn {
	if x, ok := m.GetRtargetChoice().(*RouteTarget_Asn2ByteRtarget); ok {
		return x.Asn2ByteRtarget
	}
	return nil
}

func (m *RouteTarget) GetIpv4AddrRtarget() *RouteTargetIPv4Addr {
	if x, ok := m.GetRtargetChoice().(*RouteTarget_Ipv4AddrRtarget); ok {
		return x.Ipv4AddrRtarget
	}
	return nil
}

func (m *RouteTarget) GetAsn4ByteRtarget() *RouteTarget4ByteAsn {
	if x, ok := m.GetRtargetChoice().(*RouteTarget_Asn4ByteRtarget); ok {
		return x.Asn4ByteRtarget
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RouteTarget) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RouteTarget_Asn2ByteRtarget)(nil),
		(*RouteTarget_Ipv4AddrRtarget)(nil),
		(*RouteTarget_Asn4ByteRtarget)(nil),
	}
}

// Port Range List
//
// x-displayName: "Port Range List"
// List of port ranges
type PortRangesType struct {
	// ports
	//
	// x-displayName: "Port Ranges"
	// x-example: "100-200"
	// x-required
	// List of port ranges. Each range is a single port or a pair of start and end ports e.g. 8080-8192
	Ports []string `protobuf:"bytes,1,rep,name=ports,proto3" json:"ports,omitempty"`
}

func (m *PortRangesType) Reset()      { *m = PortRangesType{} }
func (*PortRangesType) ProtoMessage() {}
func (*PortRangesType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{81}
}
func (m *PortRangesType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortRangesType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PortRangesType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortRangesType.Merge(m, src)
}
func (m *PortRangesType) XXX_Size() int {
	return m.Size()
}
func (m *PortRangesType) XXX_DiscardUnknown() {
	xxx_messageInfo_PortRangesType.DiscardUnknown(m)
}

var xxx_messageInfo_PortRangesType proto.InternalMessageInfo

func (m *PortRangesType) GetPorts() []string {
	if m != nil {
		return m.Ports
	}
	return nil
}

// List of Domain names
//
// x-displayName: "Domain name list"
// List of domain names used for Host header matching
type DomainNameList struct {
	// Domains
	//
	// x-displayName: "Domain names"
	// x-example: "www.foo.com"
	// x-required
	//
	// A list of domain names that will be matched to loadbalancer.
	// These domains are not used for SNI match.
	// Wildcard names are supported in the suffix or prefix form.
	Domains []string `protobuf:"bytes,1,rep,name=domains,proto3" json:"domains,omitempty"`
}

func (m *DomainNameList) Reset()      { *m = DomainNameList{} }
func (*DomainNameList) ProtoMessage() {}
func (*DomainNameList) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{82}
}
func (m *DomainNameList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DomainNameList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DomainNameList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DomainNameList.Merge(m, src)
}
func (m *DomainNameList) XXX_Size() int {
	return m.Size()
}
func (m *DomainNameList) XXX_DiscardUnknown() {
	xxx_messageInfo_DomainNameList.DiscardUnknown(m)
}

var xxx_messageInfo_DomainNameList proto.InternalMessageInfo

func (m *DomainNameList) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

// Namespace role
//
// x-displayName: "Namespace Role"
// Allows linking namespaces and roles
type NamespaceRoleType struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "ns1"
	// x-required
	// Namespace the role applies to
	// '*' value implies all namespaces
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Role
	//
	// x-displayName: "Role"
	// x-example: "ves-io-monitor-role"
	// x-required
	// Users role for this namespace
	Role string `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
}

func (m *NamespaceRoleType) Reset()      { *m = NamespaceRoleType{} }
func (*NamespaceRoleType) ProtoMessage() {}
func (*NamespaceRoleType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{83}
}
func (m *NamespaceRoleType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamespaceRoleType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NamespaceRoleType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamespaceRoleType.Merge(m, src)
}
func (m *NamespaceRoleType) XXX_Size() int {
	return m.Size()
}
func (m *NamespaceRoleType) XXX_DiscardUnknown() {
	xxx_messageInfo_NamespaceRoleType.DiscardUnknown(m)
}

var xxx_messageInfo_NamespaceRoleType proto.InternalMessageInfo

func (m *NamespaceRoleType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *NamespaceRoleType) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

// List of Roles
//
// x-displayName: "Role List"
// Role list
type RoleListType struct {
	// Roles List
	//
	// x-displayName: "Roles List"
	// x-example: ["ves-io-monitor-role", "ves-io-uam-admin-role"]
	// x-required
	// List of all the roles
	Names []string `protobuf:"bytes,1,rep,name=names,proto3" json:"names,omitempty"`
}

func (m *RoleListType) Reset()      { *m = RoleListType{} }
func (*RoleListType) ProtoMessage() {}
func (*RoleListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{84}
}
func (m *RoleListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RoleListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleListType.Merge(m, src)
}
func (m *RoleListType) XXX_Size() int {
	return m.Size()
}
func (m *RoleListType) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleListType.DiscardUnknown(m)
}

var xxx_messageInfo_RoleListType proto.InternalMessageInfo

func (m *RoleListType) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

// Namespace Access
//
// x-displayName: "Namespace Access"
// Access info in the namespaces for the entity
type NamespaceAccessType struct {
	// Namespace Role Map
	//
	// x-displayName: "Namespace Role Map"
	// x-example: '<namespace> : [<roles>]'
	// x-required
	// List of all the roles for the entity in the namespaces
	NamespaceRoleMap map[string]*RoleListType `protobuf:"bytes,1,rep,name=namespace_role_map,json=namespaceRoleMap,proto3" json:"namespace_role_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *NamespaceAccessType) Reset()      { *m = NamespaceAccessType{} }
func (*NamespaceAccessType) ProtoMessage() {}
func (*NamespaceAccessType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{85}
}
func (m *NamespaceAccessType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamespaceAccessType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NamespaceAccessType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamespaceAccessType.Merge(m, src)
}
func (m *NamespaceAccessType) XXX_Size() int {
	return m.Size()
}
func (m *NamespaceAccessType) XXX_DiscardUnknown() {
	xxx_messageInfo_NamespaceAccessType.DiscardUnknown(m)
}

var xxx_messageInfo_NamespaceAccessType proto.InternalMessageInfo

func (m *NamespaceAccessType) GetNamespaceRoleMap() map[string]*RoleListType {
	if m != nil {
		return m.NamespaceRoleMap
	}
	return nil
}

// Site Info
//
// x-displayName: "Site Info"
// Information about a particular site.
type SiteInfo struct {
	// site
	//
	// x-required
	// x-displayName: "site"
	// 'site' refers to a site.
	Site []*ObjectRefType `protobuf:"bytes,1,rep,name=site,proto3" json:"site,omitempty"`
	// annotations
	//
	// x-required
	// x-displayName: "annotations"
	// The list of annotations providing information about the referenced site.
	Annotations []string `protobuf:"bytes,2,rep,name=annotations,proto3" json:"annotations,omitempty"`
}

func (m *SiteInfo) Reset()      { *m = SiteInfo{} }
func (*SiteInfo) ProtoMessage() {}
func (*SiteInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{86}
}
func (m *SiteInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SiteInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SiteInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SiteInfo.Merge(m, src)
}
func (m *SiteInfo) XXX_Size() int {
	return m.Size()
}
func (m *SiteInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SiteInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SiteInfo proto.InternalMessageInfo

func (m *SiteInfo) GetSite() []*ObjectRefType {
	if m != nil {
		return m.Site
	}
	return nil
}

func (m *SiteInfo) GetAnnotations() []string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

// SiteReferenceListType
//
// x-displayName: "List of sites"
// Carries the references to one or more sites
type SiteReferenceListType struct {
	// Site References
	//
	// x-displayName: "Site References"
	// Reference to one or more sites
	Refs []*ObjectRefType `protobuf:"bytes,1,rep,name=refs,proto3" json:"refs,omitempty"`
}

func (m *SiteReferenceListType) Reset()      { *m = SiteReferenceListType{} }
func (*SiteReferenceListType) ProtoMessage() {}
func (*SiteReferenceListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{87}
}
func (m *SiteReferenceListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SiteReferenceListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SiteReferenceListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SiteReferenceListType.Merge(m, src)
}
func (m *SiteReferenceListType) XXX_Size() int {
	return m.Size()
}
func (m *SiteReferenceListType) XXX_DiscardUnknown() {
	xxx_messageInfo_SiteReferenceListType.DiscardUnknown(m)
}

var xxx_messageInfo_SiteReferenceListType proto.InternalMessageInfo

func (m *SiteReferenceListType) GetRefs() []*ObjectRefType {
	if m != nil {
		return m.Refs
	}
	return nil
}

// HeaderTransformationType
//
// x-displayName: "Header Transformation"
// Header Transformation options for HTTP/1.1 request/response headers
type HeaderTransformationType struct {
	// Header transformation
	//
	// x-displayName: "Header transformation"
	// x-required
	// Select header transformation options for HTTP/1.1
	//
	// Types that are valid to be assigned to HeaderTransformationChoice:
	//
	//	*HeaderTransformationType_LegacyHeaderTransformation
	//	*HeaderTransformationType_DefaultHeaderTransformation
	//	*HeaderTransformationType_ProperCaseHeaderTransformation
	//	*HeaderTransformationType_PreserveCaseHeaderTransformation
	HeaderTransformationChoice isHeaderTransformationType_HeaderTransformationChoice `protobuf_oneof:"header_transformation_choice"`
}

func (m *HeaderTransformationType) Reset()      { *m = HeaderTransformationType{} }
func (*HeaderTransformationType) ProtoMessage() {}
func (*HeaderTransformationType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{88}
}
func (m *HeaderTransformationType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeaderTransformationType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HeaderTransformationType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeaderTransformationType.Merge(m, src)
}
func (m *HeaderTransformationType) XXX_Size() int {
	return m.Size()
}
func (m *HeaderTransformationType) XXX_DiscardUnknown() {
	xxx_messageInfo_HeaderTransformationType.DiscardUnknown(m)
}

var xxx_messageInfo_HeaderTransformationType proto.InternalMessageInfo

type isHeaderTransformationType_HeaderTransformationChoice interface {
	isHeaderTransformationType_HeaderTransformationChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type HeaderTransformationType_LegacyHeaderTransformation struct {
	LegacyHeaderTransformation *Empty `protobuf:"bytes,5,opt,name=legacy_header_transformation,json=legacyHeaderTransformation,proto3,oneof" json:"legacy_header_transformation,omitempty"`
}
type HeaderTransformationType_DefaultHeaderTransformation struct {
	DefaultHeaderTransformation *Empty `protobuf:"bytes,2,opt,name=default_header_transformation,json=defaultHeaderTransformation,proto3,oneof" json:"default_header_transformation,omitempty"`
}
type HeaderTransformationType_ProperCaseHeaderTransformation struct {
	ProperCaseHeaderTransformation *Empty `protobuf:"bytes,3,opt,name=proper_case_header_transformation,json=properCaseHeaderTransformation,proto3,oneof" json:"proper_case_header_transformation,omitempty"`
}
type HeaderTransformationType_PreserveCaseHeaderTransformation struct {
	PreserveCaseHeaderTransformation *Empty `protobuf:"bytes,4,opt,name=preserve_case_header_transformation,json=preserveCaseHeaderTransformation,proto3,oneof" json:"preserve_case_header_transformation,omitempty"`
}

func (*HeaderTransformationType_LegacyHeaderTransformation) isHeaderTransformationType_HeaderTransformationChoice() {
}
func (*HeaderTransformationType_DefaultHeaderTransformation) isHeaderTransformationType_HeaderTransformationChoice() {
}
func (*HeaderTransformationType_ProperCaseHeaderTransformation) isHeaderTransformationType_HeaderTransformationChoice() {
}
func (*HeaderTransformationType_PreserveCaseHeaderTransformation) isHeaderTransformationType_HeaderTransformationChoice() {
}

func (m *HeaderTransformationType) GetHeaderTransformationChoice() isHeaderTransformationType_HeaderTransformationChoice {
	if m != nil {
		return m.HeaderTransformationChoice
	}
	return nil
}

func (m *HeaderTransformationType) GetLegacyHeaderTransformation() *Empty {
	if x, ok := m.GetHeaderTransformationChoice().(*HeaderTransformationType_LegacyHeaderTransformation); ok {
		return x.LegacyHeaderTransformation
	}
	return nil
}

func (m *HeaderTransformationType) GetDefaultHeaderTransformation() *Empty {
	if x, ok := m.GetHeaderTransformationChoice().(*HeaderTransformationType_DefaultHeaderTransformation); ok {
		return x.DefaultHeaderTransformation
	}
	return nil
}

func (m *HeaderTransformationType) GetProperCaseHeaderTransformation() *Empty {
	if x, ok := m.GetHeaderTransformationChoice().(*HeaderTransformationType_ProperCaseHeaderTransformation); ok {
		return x.ProperCaseHeaderTransformation
	}
	return nil
}

func (m *HeaderTransformationType) GetPreserveCaseHeaderTransformation() *Empty {
	if x, ok := m.GetHeaderTransformationChoice().(*HeaderTransformationType_PreserveCaseHeaderTransformation); ok {
		return x.PreserveCaseHeaderTransformation
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HeaderTransformationType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HeaderTransformationType_LegacyHeaderTransformation)(nil),
		(*HeaderTransformationType_DefaultHeaderTransformation)(nil),
		(*HeaderTransformationType_ProperCaseHeaderTransformation)(nil),
		(*HeaderTransformationType_PreserveCaseHeaderTransformation)(nil),
	}
}

// BotDefenseFlowLabelCategoryChoiceType
//
// x-displayName: "Bot Defense Flow Label Category"
// Bot Defense Flow Label Category allows to associate traffic with selected category
type BotDefenseFlowLabelCategoriesChoiceType struct {
	// Flow label category
	//
	// x-displayName: "Flow Label Category"
	// x-required
	// Select flow label category
	//
	// Types that are valid to be assigned to FlowLabelChoice:
	//
	//	*BotDefenseFlowLabelCategoriesChoiceType_Authentication
	//	*BotDefenseFlowLabelCategoriesChoiceType_AccountManagement
	//	*BotDefenseFlowLabelCategoriesChoiceType_ProfileManagement
	//	*BotDefenseFlowLabelCategoriesChoiceType_ShoppingGiftCards
	//	*BotDefenseFlowLabelCategoriesChoiceType_FinancialServices
	//	*BotDefenseFlowLabelCategoriesChoiceType_Search
	//	*BotDefenseFlowLabelCategoriesChoiceType_Flight
	FlowLabelChoice isBotDefenseFlowLabelCategoriesChoiceType_FlowLabelChoice `protobuf_oneof:"flow_label_choice"`
}

func (m *BotDefenseFlowLabelCategoriesChoiceType) Reset() {
	*m = BotDefenseFlowLabelCategoriesChoiceType{}
}
func (*BotDefenseFlowLabelCategoriesChoiceType) ProtoMessage() {}
func (*BotDefenseFlowLabelCategoriesChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{89}
}
func (m *BotDefenseFlowLabelCategoriesChoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BotDefenseFlowLabelCategoriesChoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BotDefenseFlowLabelCategoriesChoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BotDefenseFlowLabelCategoriesChoiceType.Merge(m, src)
}
func (m *BotDefenseFlowLabelCategoriesChoiceType) XXX_Size() int {
	return m.Size()
}
func (m *BotDefenseFlowLabelCategoriesChoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_BotDefenseFlowLabelCategoriesChoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_BotDefenseFlowLabelCategoriesChoiceType proto.InternalMessageInfo

type isBotDefenseFlowLabelCategoriesChoiceType_FlowLabelChoice interface {
	isBotDefenseFlowLabelCategoriesChoiceType_FlowLabelChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type BotDefenseFlowLabelCategoriesChoiceType_Authentication struct {
	Authentication *BotDefenseFlowLabelAuthenticationChoiceType `protobuf:"bytes,2,opt,name=authentication,proto3,oneof" json:"authentication,omitempty"`
}
type BotDefenseFlowLabelCategoriesChoiceType_AccountManagement struct {
	AccountManagement *BotDefenseFlowLabelAccountManagementChoiceType `protobuf:"bytes,3,opt,name=account_management,json=accountManagement,proto3,oneof" json:"account_management,omitempty"`
}
type BotDefenseFlowLabelCategoriesChoiceType_ProfileManagement struct {
	ProfileManagement *BotDefenseFlowLabelProfileManagementChoiceType `protobuf:"bytes,4,opt,name=profile_management,json=profileManagement,proto3,oneof" json:"profile_management,omitempty"`
}
type BotDefenseFlowLabelCategoriesChoiceType_ShoppingGiftCards struct {
	ShoppingGiftCards *BotDefenseFlowLabelShoppingGiftCardsChoiceType `protobuf:"bytes,5,opt,name=shopping_gift_cards,json=shoppingGiftCards,proto3,oneof" json:"shopping_gift_cards,omitempty"`
}
type BotDefenseFlowLabelCategoriesChoiceType_FinancialServices struct {
	FinancialServices *BotDefenseFlowLabelFinancialServicesChoiceType `protobuf:"bytes,6,opt,name=financial_services,json=financialServices,proto3,oneof" json:"financial_services,omitempty"`
}
type BotDefenseFlowLabelCategoriesChoiceType_Search struct {
	Search *BotDefenseFlowLabelSearchChoiceType `protobuf:"bytes,7,opt,name=search,proto3,oneof" json:"search,omitempty"`
}
type BotDefenseFlowLabelCategoriesChoiceType_Flight struct {
	Flight *BotDefenseFlowLabelFlightChoiceType `protobuf:"bytes,8,opt,name=flight,proto3,oneof" json:"flight,omitempty"`
}

func (*BotDefenseFlowLabelCategoriesChoiceType_Authentication) isBotDefenseFlowLabelCategoriesChoiceType_FlowLabelChoice() {
}
func (*BotDefenseFlowLabelCategoriesChoiceType_AccountManagement) isBotDefenseFlowLabelCategoriesChoiceType_FlowLabelChoice() {
}
func (*BotDefenseFlowLabelCategoriesChoiceType_ProfileManagement) isBotDefenseFlowLabelCategoriesChoiceType_FlowLabelChoice() {
}
func (*BotDefenseFlowLabelCategoriesChoiceType_ShoppingGiftCards) isBotDefenseFlowLabelCategoriesChoiceType_FlowLabelChoice() {
}
func (*BotDefenseFlowLabelCategoriesChoiceType_FinancialServices) isBotDefenseFlowLabelCategoriesChoiceType_FlowLabelChoice() {
}
func (*BotDefenseFlowLabelCategoriesChoiceType_Search) isBotDefenseFlowLabelCategoriesChoiceType_FlowLabelChoice() {
}
func (*BotDefenseFlowLabelCategoriesChoiceType_Flight) isBotDefenseFlowLabelCategoriesChoiceType_FlowLabelChoice() {
}

func (m *BotDefenseFlowLabelCategoriesChoiceType) GetFlowLabelChoice() isBotDefenseFlowLabelCategoriesChoiceType_FlowLabelChoice {
	if m != nil {
		return m.FlowLabelChoice
	}
	return nil
}

func (m *BotDefenseFlowLabelCategoriesChoiceType) GetAuthentication() *BotDefenseFlowLabelAuthenticationChoiceType {
	if x, ok := m.GetFlowLabelChoice().(*BotDefenseFlowLabelCategoriesChoiceType_Authentication); ok {
		return x.Authentication
	}
	return nil
}

func (m *BotDefenseFlowLabelCategoriesChoiceType) GetAccountManagement() *BotDefenseFlowLabelAccountManagementChoiceType {
	if x, ok := m.GetFlowLabelChoice().(*BotDefenseFlowLabelCategoriesChoiceType_AccountManagement); ok {
		return x.AccountManagement
	}
	return nil
}

func (m *BotDefenseFlowLabelCategoriesChoiceType) GetProfileManagement() *BotDefenseFlowLabelProfileManagementChoiceType {
	if x, ok := m.GetFlowLabelChoice().(*BotDefenseFlowLabelCategoriesChoiceType_ProfileManagement); ok {
		return x.ProfileManagement
	}
	return nil
}

func (m *BotDefenseFlowLabelCategoriesChoiceType) GetShoppingGiftCards() *BotDefenseFlowLabelShoppingGiftCardsChoiceType {
	if x, ok := m.GetFlowLabelChoice().(*BotDefenseFlowLabelCategoriesChoiceType_ShoppingGiftCards); ok {
		return x.ShoppingGiftCards
	}
	return nil
}

func (m *BotDefenseFlowLabelCategoriesChoiceType) GetFinancialServices() *BotDefenseFlowLabelFinancialServicesChoiceType {
	if x, ok := m.GetFlowLabelChoice().(*BotDefenseFlowLabelCategoriesChoiceType_FinancialServices); ok {
		return x.FinancialServices
	}
	return nil
}

func (m *BotDefenseFlowLabelCategoriesChoiceType) GetSearch() *BotDefenseFlowLabelSearchChoiceType {
	if x, ok := m.GetFlowLabelChoice().(*BotDefenseFlowLabelCategoriesChoiceType_Search); ok {
		return x.Search
	}
	return nil
}

func (m *BotDefenseFlowLabelCategoriesChoiceType) GetFlight() *BotDefenseFlowLabelFlightChoiceType {
	if x, ok := m.GetFlowLabelChoice().(*BotDefenseFlowLabelCategoriesChoiceType_Flight); ok {
		return x.Flight
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*BotDefenseFlowLabelCategoriesChoiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*BotDefenseFlowLabelCategoriesChoiceType_Authentication)(nil),
		(*BotDefenseFlowLabelCategoriesChoiceType_AccountManagement)(nil),
		(*BotDefenseFlowLabelCategoriesChoiceType_ProfileManagement)(nil),
		(*BotDefenseFlowLabelCategoriesChoiceType_ShoppingGiftCards)(nil),
		(*BotDefenseFlowLabelCategoriesChoiceType_FinancialServices)(nil),
		(*BotDefenseFlowLabelCategoriesChoiceType_Search)(nil),
		(*BotDefenseFlowLabelCategoriesChoiceType_Flight)(nil),
	}
}

// BotDefenseFlowLabelCategoryChoiceType
//
// x-displayName: "Bot Defense Flow Label Authentication Category"
// Bot Defense Flow Label Authentication Category
type BotDefenseFlowLabelAuthenticationChoiceType struct {
	// Flow label
	//
	// x-displayName: "Flow Label"
	// x-required
	// Flow label category
	//
	// Types that are valid to be assigned to LabelChoice:
	//
	//	*BotDefenseFlowLabelAuthenticationChoiceType_Login
	//	*BotDefenseFlowLabelAuthenticationChoiceType_LoginMfa
	//	*BotDefenseFlowLabelAuthenticationChoiceType_LoginPartner
	//	*BotDefenseFlowLabelAuthenticationChoiceType_Logout
	//	*BotDefenseFlowLabelAuthenticationChoiceType_TokenRefresh
	LabelChoice isBotDefenseFlowLabelAuthenticationChoiceType_LabelChoice `protobuf_oneof:"label_choice"`
}

func (m *BotDefenseFlowLabelAuthenticationChoiceType) Reset() {
	*m = BotDefenseFlowLabelAuthenticationChoiceType{}
}
func (*BotDefenseFlowLabelAuthenticationChoiceType) ProtoMessage() {}
func (*BotDefenseFlowLabelAuthenticationChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{90}
}
func (m *BotDefenseFlowLabelAuthenticationChoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BotDefenseFlowLabelAuthenticationChoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BotDefenseFlowLabelAuthenticationChoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BotDefenseFlowLabelAuthenticationChoiceType.Merge(m, src)
}
func (m *BotDefenseFlowLabelAuthenticationChoiceType) XXX_Size() int {
	return m.Size()
}
func (m *BotDefenseFlowLabelAuthenticationChoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_BotDefenseFlowLabelAuthenticationChoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_BotDefenseFlowLabelAuthenticationChoiceType proto.InternalMessageInfo

type isBotDefenseFlowLabelAuthenticationChoiceType_LabelChoice interface {
	isBotDefenseFlowLabelAuthenticationChoiceType_LabelChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type BotDefenseFlowLabelAuthenticationChoiceType_Login struct {
	Login *BotDefenseTransactionResult `protobuf:"bytes,2,opt,name=login,proto3,oneof" json:"login,omitempty"`
}
type BotDefenseFlowLabelAuthenticationChoiceType_LoginMfa struct {
	LoginMfa *Empty `protobuf:"bytes,3,opt,name=login_mfa,json=loginMfa,proto3,oneof" json:"login_mfa,omitempty"`
}
type BotDefenseFlowLabelAuthenticationChoiceType_LoginPartner struct {
	LoginPartner *Empty `protobuf:"bytes,4,opt,name=login_partner,json=loginPartner,proto3,oneof" json:"login_partner,omitempty"`
}
type BotDefenseFlowLabelAuthenticationChoiceType_Logout struct {
	Logout *Empty `protobuf:"bytes,5,opt,name=logout,proto3,oneof" json:"logout,omitempty"`
}
type BotDefenseFlowLabelAuthenticationChoiceType_TokenRefresh struct {
	TokenRefresh *Empty `protobuf:"bytes,6,opt,name=token_refresh,json=tokenRefresh,proto3,oneof" json:"token_refresh,omitempty"`
}

func (*BotDefenseFlowLabelAuthenticationChoiceType_Login) isBotDefenseFlowLabelAuthenticationChoiceType_LabelChoice() {
}
func (*BotDefenseFlowLabelAuthenticationChoiceType_LoginMfa) isBotDefenseFlowLabelAuthenticationChoiceType_LabelChoice() {
}
func (*BotDefenseFlowLabelAuthenticationChoiceType_LoginPartner) isBotDefenseFlowLabelAuthenticationChoiceType_LabelChoice() {
}
func (*BotDefenseFlowLabelAuthenticationChoiceType_Logout) isBotDefenseFlowLabelAuthenticationChoiceType_LabelChoice() {
}
func (*BotDefenseFlowLabelAuthenticationChoiceType_TokenRefresh) isBotDefenseFlowLabelAuthenticationChoiceType_LabelChoice() {
}

func (m *BotDefenseFlowLabelAuthenticationChoiceType) GetLabelChoice() isBotDefenseFlowLabelAuthenticationChoiceType_LabelChoice {
	if m != nil {
		return m.LabelChoice
	}
	return nil
}

func (m *BotDefenseFlowLabelAuthenticationChoiceType) GetLogin() *BotDefenseTransactionResult {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelAuthenticationChoiceType_Login); ok {
		return x.Login
	}
	return nil
}

func (m *BotDefenseFlowLabelAuthenticationChoiceType) GetLoginMfa() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelAuthenticationChoiceType_LoginMfa); ok {
		return x.LoginMfa
	}
	return nil
}

func (m *BotDefenseFlowLabelAuthenticationChoiceType) GetLoginPartner() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelAuthenticationChoiceType_LoginPartner); ok {
		return x.LoginPartner
	}
	return nil
}

func (m *BotDefenseFlowLabelAuthenticationChoiceType) GetLogout() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelAuthenticationChoiceType_Logout); ok {
		return x.Logout
	}
	return nil
}

func (m *BotDefenseFlowLabelAuthenticationChoiceType) GetTokenRefresh() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelAuthenticationChoiceType_TokenRefresh); ok {
		return x.TokenRefresh
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*BotDefenseFlowLabelAuthenticationChoiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*BotDefenseFlowLabelAuthenticationChoiceType_Login)(nil),
		(*BotDefenseFlowLabelAuthenticationChoiceType_LoginMfa)(nil),
		(*BotDefenseFlowLabelAuthenticationChoiceType_LoginPartner)(nil),
		(*BotDefenseFlowLabelAuthenticationChoiceType_Logout)(nil),
		(*BotDefenseFlowLabelAuthenticationChoiceType_TokenRefresh)(nil),
	}
}

// BotDefenseTransactionResult
//
// x-displayName: "Bot Defense Transaction Result"
// Bot Defense Transaction Result
type BotDefenseTransactionResult struct {
	// Transaction result
	//
	// x-displayName: "Transaction Result"
	// Transaction Result
	//
	// Types that are valid to be assigned to TransactionResultChoice:
	//
	//	*BotDefenseTransactionResult_DisableTransactionResult
	//	*BotDefenseTransactionResult_TransactionResult
	TransactionResultChoice isBotDefenseTransactionResult_TransactionResultChoice `protobuf_oneof:"transaction_result_choice"`
}

func (m *BotDefenseTransactionResult) Reset()      { *m = BotDefenseTransactionResult{} }
func (*BotDefenseTransactionResult) ProtoMessage() {}
func (*BotDefenseTransactionResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{91}
}
func (m *BotDefenseTransactionResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BotDefenseTransactionResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BotDefenseTransactionResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BotDefenseTransactionResult.Merge(m, src)
}
func (m *BotDefenseTransactionResult) XXX_Size() int {
	return m.Size()
}
func (m *BotDefenseTransactionResult) XXX_DiscardUnknown() {
	xxx_messageInfo_BotDefenseTransactionResult.DiscardUnknown(m)
}

var xxx_messageInfo_BotDefenseTransactionResult proto.InternalMessageInfo

type isBotDefenseTransactionResult_TransactionResultChoice interface {
	isBotDefenseTransactionResult_TransactionResultChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type BotDefenseTransactionResult_DisableTransactionResult struct {
	DisableTransactionResult *Empty `protobuf:"bytes,2,opt,name=disable_transaction_result,json=disableTransactionResult,proto3,oneof" json:"disable_transaction_result,omitempty"`
}
type BotDefenseTransactionResult_TransactionResult struct {
	TransactionResult *BotDefenseTransactionResultType `protobuf:"bytes,3,opt,name=transaction_result,json=transactionResult,proto3,oneof" json:"transaction_result,omitempty"`
}

func (*BotDefenseTransactionResult_DisableTransactionResult) isBotDefenseTransactionResult_TransactionResultChoice() {
}
func (*BotDefenseTransactionResult_TransactionResult) isBotDefenseTransactionResult_TransactionResultChoice() {
}

func (m *BotDefenseTransactionResult) GetTransactionResultChoice() isBotDefenseTransactionResult_TransactionResultChoice {
	if m != nil {
		return m.TransactionResultChoice
	}
	return nil
}

func (m *BotDefenseTransactionResult) GetDisableTransactionResult() *Empty {
	if x, ok := m.GetTransactionResultChoice().(*BotDefenseTransactionResult_DisableTransactionResult); ok {
		return x.DisableTransactionResult
	}
	return nil
}

func (m *BotDefenseTransactionResult) GetTransactionResult() *BotDefenseTransactionResultType {
	if x, ok := m.GetTransactionResultChoice().(*BotDefenseTransactionResult_TransactionResult); ok {
		return x.TransactionResult
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*BotDefenseTransactionResult) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*BotDefenseTransactionResult_DisableTransactionResult)(nil),
		(*BotDefenseTransactionResult_TransactionResult)(nil),
	}
}

// BotDefenseTransactionResultType
//
// x-displayName: "Bot Defense Transaction Result Type"
// Bot Defense Transaction ResultType
type BotDefenseTransactionResultType struct {
	// Success Conditions
	//
	// x-displayName: "Success Conditions"
	// Success Conditions
	SuccessConditions []*BotDefenseTransactionResultCondition `protobuf:"bytes,3,rep,name=success_conditions,json=successConditions,proto3" json:"success_conditions,omitempty"`
	// Failure Conditions
	//
	// x-displayName: "Failure Conditions"
	// Failure Conditions
	FailureConditions []*BotDefenseTransactionResultCondition `protobuf:"bytes,4,rep,name=failure_conditions,json=failureConditions,proto3" json:"failure_conditions,omitempty"`
}

func (m *BotDefenseTransactionResultType) Reset()      { *m = BotDefenseTransactionResultType{} }
func (*BotDefenseTransactionResultType) ProtoMessage() {}
func (*BotDefenseTransactionResultType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{92}
}
func (m *BotDefenseTransactionResultType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BotDefenseTransactionResultType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BotDefenseTransactionResultType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BotDefenseTransactionResultType.Merge(m, src)
}
func (m *BotDefenseTransactionResultType) XXX_Size() int {
	return m.Size()
}
func (m *BotDefenseTransactionResultType) XXX_DiscardUnknown() {
	xxx_messageInfo_BotDefenseTransactionResultType.DiscardUnknown(m)
}

var xxx_messageInfo_BotDefenseTransactionResultType proto.InternalMessageInfo

func (m *BotDefenseTransactionResultType) GetSuccessConditions() []*BotDefenseTransactionResultCondition {
	if m != nil {
		return m.SuccessConditions
	}
	return nil
}

func (m *BotDefenseTransactionResultType) GetFailureConditions() []*BotDefenseTransactionResultCondition {
	if m != nil {
		return m.FailureConditions
	}
	return nil
}

// BotDefenseTransactionResultCondition
//
// x-displayName: "Bot Defense Transaction Result Condition"
// Bot Defense Transaction Result Condition
type BotDefenseTransactionResultCondition struct {
	// name
	//
	// x-displayName: "Header Name"
	// x-example: "Accept-Encoding"
	// A case-insensitive HTTP header name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// regex values
	//
	// x-displayName: "Regex Values"
	// x-example: "['^new .*$', 'san f.*', '.* del .*']"
	// A list of regular expressions to match the input against.
	RegexValues []string `protobuf:"bytes,2,rep,name=regex_values,json=regexValues,proto3" json:"regex_values,omitempty"`
	// HTTP Status code for response
	//
	// x-displayName: "HTTP Status code"
	// x-required
	// HTTP Status code
	Status HttpStatusCode `protobuf:"varint,3,opt,name=status,proto3,enum=ves.io.schema.HttpStatusCode" json:"status,omitempty"`
}

func (m *BotDefenseTransactionResultCondition) Reset()      { *m = BotDefenseTransactionResultCondition{} }
func (*BotDefenseTransactionResultCondition) ProtoMessage() {}
func (*BotDefenseTransactionResultCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{93}
}
func (m *BotDefenseTransactionResultCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BotDefenseTransactionResultCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BotDefenseTransactionResultCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BotDefenseTransactionResultCondition.Merge(m, src)
}
func (m *BotDefenseTransactionResultCondition) XXX_Size() int {
	return m.Size()
}
func (m *BotDefenseTransactionResultCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_BotDefenseTransactionResultCondition.DiscardUnknown(m)
}

var xxx_messageInfo_BotDefenseTransactionResultCondition proto.InternalMessageInfo

func (m *BotDefenseTransactionResultCondition) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BotDefenseTransactionResultCondition) GetRegexValues() []string {
	if m != nil {
		return m.RegexValues
	}
	return nil
}

func (m *BotDefenseTransactionResultCondition) GetStatus() HttpStatusCode {
	if m != nil {
		return m.Status
	}
	return EmptyStatusCode
}

// BotDefenseFlowLabelAccountManagementChoiceType
//
// x-displayName: "Bot Defense Flow Label Account Management Category"
// Bot Defense Flow Label Account Management Category
type BotDefenseFlowLabelAccountManagementChoiceType struct {
	// Flow label
	//
	// x-displayName: "Flow Label"
	// x-required
	// Flow label category
	//
	// Types that are valid to be assigned to LabelChoice:
	//
	//	*BotDefenseFlowLabelAccountManagementChoiceType_Create
	//	*BotDefenseFlowLabelAccountManagementChoiceType_PasswordReset
	LabelChoice isBotDefenseFlowLabelAccountManagementChoiceType_LabelChoice `protobuf_oneof:"label_choice"`
}

func (m *BotDefenseFlowLabelAccountManagementChoiceType) Reset() {
	*m = BotDefenseFlowLabelAccountManagementChoiceType{}
}
func (*BotDefenseFlowLabelAccountManagementChoiceType) ProtoMessage() {}
func (*BotDefenseFlowLabelAccountManagementChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{94}
}
func (m *BotDefenseFlowLabelAccountManagementChoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BotDefenseFlowLabelAccountManagementChoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BotDefenseFlowLabelAccountManagementChoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BotDefenseFlowLabelAccountManagementChoiceType.Merge(m, src)
}
func (m *BotDefenseFlowLabelAccountManagementChoiceType) XXX_Size() int {
	return m.Size()
}
func (m *BotDefenseFlowLabelAccountManagementChoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_BotDefenseFlowLabelAccountManagementChoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_BotDefenseFlowLabelAccountManagementChoiceType proto.InternalMessageInfo

type isBotDefenseFlowLabelAccountManagementChoiceType_LabelChoice interface {
	isBotDefenseFlowLabelAccountManagementChoiceType_LabelChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type BotDefenseFlowLabelAccountManagementChoiceType_Create struct {
	Create *Empty `protobuf:"bytes,2,opt,name=create,proto3,oneof" json:"create,omitempty"`
}
type BotDefenseFlowLabelAccountManagementChoiceType_PasswordReset struct {
	PasswordReset *Empty `protobuf:"bytes,3,opt,name=password_reset,json=passwordReset,proto3,oneof" json:"password_reset,omitempty"`
}

func (*BotDefenseFlowLabelAccountManagementChoiceType_Create) isBotDefenseFlowLabelAccountManagementChoiceType_LabelChoice() {
}
func (*BotDefenseFlowLabelAccountManagementChoiceType_PasswordReset) isBotDefenseFlowLabelAccountManagementChoiceType_LabelChoice() {
}

func (m *BotDefenseFlowLabelAccountManagementChoiceType) GetLabelChoice() isBotDefenseFlowLabelAccountManagementChoiceType_LabelChoice {
	if m != nil {
		return m.LabelChoice
	}
	return nil
}

func (m *BotDefenseFlowLabelAccountManagementChoiceType) GetCreate() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelAccountManagementChoiceType_Create); ok {
		return x.Create
	}
	return nil
}

func (m *BotDefenseFlowLabelAccountManagementChoiceType) GetPasswordReset() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelAccountManagementChoiceType_PasswordReset); ok {
		return x.PasswordReset
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*BotDefenseFlowLabelAccountManagementChoiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*BotDefenseFlowLabelAccountManagementChoiceType_Create)(nil),
		(*BotDefenseFlowLabelAccountManagementChoiceType_PasswordReset)(nil),
	}
}

// BotDefenseFlowLabelProfileManagementChoiceType
//
// x-displayName: "Bot Defense Flow Label Profile Management Category"
// Bot Defense Flow Label Profile Management Category
type BotDefenseFlowLabelProfileManagementChoiceType struct {
	// Flow label
	//
	// x-displayName: "Flow Label"
	// x-required
	// Flow label category
	//
	// Types that are valid to be assigned to LabelChoice:
	//
	//	*BotDefenseFlowLabelProfileManagementChoiceType_Create
	//	*BotDefenseFlowLabelProfileManagementChoiceType_Update
	//	*BotDefenseFlowLabelProfileManagementChoiceType_View
	LabelChoice isBotDefenseFlowLabelProfileManagementChoiceType_LabelChoice `protobuf_oneof:"label_choice"`
}

func (m *BotDefenseFlowLabelProfileManagementChoiceType) Reset() {
	*m = BotDefenseFlowLabelProfileManagementChoiceType{}
}
func (*BotDefenseFlowLabelProfileManagementChoiceType) ProtoMessage() {}
func (*BotDefenseFlowLabelProfileManagementChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{95}
}
func (m *BotDefenseFlowLabelProfileManagementChoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BotDefenseFlowLabelProfileManagementChoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BotDefenseFlowLabelProfileManagementChoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BotDefenseFlowLabelProfileManagementChoiceType.Merge(m, src)
}
func (m *BotDefenseFlowLabelProfileManagementChoiceType) XXX_Size() int {
	return m.Size()
}
func (m *BotDefenseFlowLabelProfileManagementChoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_BotDefenseFlowLabelProfileManagementChoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_BotDefenseFlowLabelProfileManagementChoiceType proto.InternalMessageInfo

type isBotDefenseFlowLabelProfileManagementChoiceType_LabelChoice interface {
	isBotDefenseFlowLabelProfileManagementChoiceType_LabelChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type BotDefenseFlowLabelProfileManagementChoiceType_Create struct {
	Create *Empty `protobuf:"bytes,2,opt,name=create,proto3,oneof" json:"create,omitempty"`
}
type BotDefenseFlowLabelProfileManagementChoiceType_Update struct {
	Update *Empty `protobuf:"bytes,3,opt,name=update,proto3,oneof" json:"update,omitempty"`
}
type BotDefenseFlowLabelProfileManagementChoiceType_View struct {
	View *Empty `protobuf:"bytes,4,opt,name=view,proto3,oneof" json:"view,omitempty"`
}

func (*BotDefenseFlowLabelProfileManagementChoiceType_Create) isBotDefenseFlowLabelProfileManagementChoiceType_LabelChoice() {
}
func (*BotDefenseFlowLabelProfileManagementChoiceType_Update) isBotDefenseFlowLabelProfileManagementChoiceType_LabelChoice() {
}
func (*BotDefenseFlowLabelProfileManagementChoiceType_View) isBotDefenseFlowLabelProfileManagementChoiceType_LabelChoice() {
}

func (m *BotDefenseFlowLabelProfileManagementChoiceType) GetLabelChoice() isBotDefenseFlowLabelProfileManagementChoiceType_LabelChoice {
	if m != nil {
		return m.LabelChoice
	}
	return nil
}

func (m *BotDefenseFlowLabelProfileManagementChoiceType) GetCreate() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelProfileManagementChoiceType_Create); ok {
		return x.Create
	}
	return nil
}

func (m *BotDefenseFlowLabelProfileManagementChoiceType) GetUpdate() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelProfileManagementChoiceType_Update); ok {
		return x.Update
	}
	return nil
}

func (m *BotDefenseFlowLabelProfileManagementChoiceType) GetView() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelProfileManagementChoiceType_View); ok {
		return x.View
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*BotDefenseFlowLabelProfileManagementChoiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*BotDefenseFlowLabelProfileManagementChoiceType_Create)(nil),
		(*BotDefenseFlowLabelProfileManagementChoiceType_Update)(nil),
		(*BotDefenseFlowLabelProfileManagementChoiceType_View)(nil),
	}
}

// BotDefenseFlowLabelShoppingGiftCardsChoiceType
//
// x-displayName: "Bot Defense Flow Label Shopping & Gift Cards Category"
// Bot Defense Flow Label Shopping & Gift Cards Category
type BotDefenseFlowLabelShoppingGiftCardsChoiceType struct {
	// Flow label
	//
	// x-displayName: "Flow Label"
	// Flow label category
	//
	// Types that are valid to be assigned to LabelChoice:
	//
	//	*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopAddToCart
	//	*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPromoCodeValidation
	//	*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopCheckout
	//	*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopMakePayment
	//	*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopOrder
	//	*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPriceInquiry
	//	*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPurchaseGiftCard
	//	*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopUpdateQuantity
	//	*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopChooseSeat
	//	*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopEnterDrawingSubmission
	//	*BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardValidation
	//	*BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardMakePurchaseWithGiftCard
	LabelChoice isBotDefenseFlowLabelShoppingGiftCardsChoiceType_LabelChoice `protobuf_oneof:"label_choice"`
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) Reset() {
	*m = BotDefenseFlowLabelShoppingGiftCardsChoiceType{}
}
func (*BotDefenseFlowLabelShoppingGiftCardsChoiceType) ProtoMessage() {}
func (*BotDefenseFlowLabelShoppingGiftCardsChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{96}
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BotDefenseFlowLabelShoppingGiftCardsChoiceType.Merge(m, src)
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) XXX_Size() int {
	return m.Size()
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_BotDefenseFlowLabelShoppingGiftCardsChoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_BotDefenseFlowLabelShoppingGiftCardsChoiceType proto.InternalMessageInfo

type isBotDefenseFlowLabelShoppingGiftCardsChoiceType_LabelChoice interface {
	isBotDefenseFlowLabelShoppingGiftCardsChoiceType_LabelChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopAddToCart struct {
	ShopAddToCart *Empty `protobuf:"bytes,2,opt,name=shop_add_to_cart,json=shopAddToCart,proto3,oneof" json:"shop_add_to_cart,omitempty"`
}
type BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPromoCodeValidation struct {
	ShopPromoCodeValidation *Empty `protobuf:"bytes,3,opt,name=shop_promo_code_validation,json=shopPromoCodeValidation,proto3,oneof" json:"shop_promo_code_validation,omitempty"`
}
type BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopCheckout struct {
	ShopCheckout *Empty `protobuf:"bytes,4,opt,name=shop_checkout,json=shopCheckout,proto3,oneof" json:"shop_checkout,omitempty"`
}
type BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopMakePayment struct {
	ShopMakePayment *Empty `protobuf:"bytes,5,opt,name=shop_make_payment,json=shopMakePayment,proto3,oneof" json:"shop_make_payment,omitempty"`
}
type BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopOrder struct {
	ShopOrder *Empty `protobuf:"bytes,6,opt,name=shop_order,json=shopOrder,proto3,oneof" json:"shop_order,omitempty"`
}
type BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPriceInquiry struct {
	ShopPriceInquiry *Empty `protobuf:"bytes,7,opt,name=shop_price_inquiry,json=shopPriceInquiry,proto3,oneof" json:"shop_price_inquiry,omitempty"`
}
type BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPurchaseGiftCard struct {
	ShopPurchaseGiftCard *Empty `protobuf:"bytes,8,opt,name=shop_purchase_gift_card,json=shopPurchaseGiftCard,proto3,oneof" json:"shop_purchase_gift_card,omitempty"`
}
type BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopUpdateQuantity struct {
	ShopUpdateQuantity *Empty `protobuf:"bytes,9,opt,name=shop_update_quantity,json=shopUpdateQuantity,proto3,oneof" json:"shop_update_quantity,omitempty"`
}
type BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopChooseSeat struct {
	ShopChooseSeat *Empty `protobuf:"bytes,10,opt,name=shop_choose_seat,json=shopChooseSeat,proto3,oneof" json:"shop_choose_seat,omitempty"`
}
type BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopEnterDrawingSubmission struct {
	ShopEnterDrawingSubmission *Empty `protobuf:"bytes,11,opt,name=shop_enter_drawing_submission,json=shopEnterDrawingSubmission,proto3,oneof" json:"shop_enter_drawing_submission,omitempty"`
}
type BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardValidation struct {
	GiftCardValidation *Empty `protobuf:"bytes,12,opt,name=gift_card_validation,json=giftCardValidation,proto3,oneof" json:"gift_card_validation,omitempty"`
}
type BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardMakePurchaseWithGiftCard struct {
	GiftCardMakePurchaseWithGiftCard *Empty `protobuf:"bytes,13,opt,name=gift_card_make_purchase_with_gift_card,json=giftCardMakePurchaseWithGiftCard,proto3,oneof" json:"gift_card_make_purchase_with_gift_card,omitempty"`
}

func (*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopAddToCart) isBotDefenseFlowLabelShoppingGiftCardsChoiceType_LabelChoice() {
}
func (*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPromoCodeValidation) isBotDefenseFlowLabelShoppingGiftCardsChoiceType_LabelChoice() {
}
func (*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopCheckout) isBotDefenseFlowLabelShoppingGiftCardsChoiceType_LabelChoice() {
}
func (*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopMakePayment) isBotDefenseFlowLabelShoppingGiftCardsChoiceType_LabelChoice() {
}
func (*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopOrder) isBotDefenseFlowLabelShoppingGiftCardsChoiceType_LabelChoice() {
}
func (*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPriceInquiry) isBotDefenseFlowLabelShoppingGiftCardsChoiceType_LabelChoice() {
}
func (*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPurchaseGiftCard) isBotDefenseFlowLabelShoppingGiftCardsChoiceType_LabelChoice() {
}
func (*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopUpdateQuantity) isBotDefenseFlowLabelShoppingGiftCardsChoiceType_LabelChoice() {
}
func (*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopChooseSeat) isBotDefenseFlowLabelShoppingGiftCardsChoiceType_LabelChoice() {
}
func (*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopEnterDrawingSubmission) isBotDefenseFlowLabelShoppingGiftCardsChoiceType_LabelChoice() {
}
func (*BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardValidation) isBotDefenseFlowLabelShoppingGiftCardsChoiceType_LabelChoice() {
}
func (*BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardMakePurchaseWithGiftCard) isBotDefenseFlowLabelShoppingGiftCardsChoiceType_LabelChoice() {
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) GetLabelChoice() isBotDefenseFlowLabelShoppingGiftCardsChoiceType_LabelChoice {
	if m != nil {
		return m.LabelChoice
	}
	return nil
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) GetShopAddToCart() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopAddToCart); ok {
		return x.ShopAddToCart
	}
	return nil
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) GetShopPromoCodeValidation() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPromoCodeValidation); ok {
		return x.ShopPromoCodeValidation
	}
	return nil
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) GetShopCheckout() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopCheckout); ok {
		return x.ShopCheckout
	}
	return nil
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) GetShopMakePayment() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopMakePayment); ok {
		return x.ShopMakePayment
	}
	return nil
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) GetShopOrder() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopOrder); ok {
		return x.ShopOrder
	}
	return nil
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) GetShopPriceInquiry() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPriceInquiry); ok {
		return x.ShopPriceInquiry
	}
	return nil
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) GetShopPurchaseGiftCard() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPurchaseGiftCard); ok {
		return x.ShopPurchaseGiftCard
	}
	return nil
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) GetShopUpdateQuantity() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopUpdateQuantity); ok {
		return x.ShopUpdateQuantity
	}
	return nil
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) GetShopChooseSeat() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopChooseSeat); ok {
		return x.ShopChooseSeat
	}
	return nil
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) GetShopEnterDrawingSubmission() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopEnterDrawingSubmission); ok {
		return x.ShopEnterDrawingSubmission
	}
	return nil
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) GetGiftCardValidation() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardValidation); ok {
		return x.GiftCardValidation
	}
	return nil
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) GetGiftCardMakePurchaseWithGiftCard() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardMakePurchaseWithGiftCard); ok {
		return x.GiftCardMakePurchaseWithGiftCard
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*BotDefenseFlowLabelShoppingGiftCardsChoiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopAddToCart)(nil),
		(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPromoCodeValidation)(nil),
		(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopCheckout)(nil),
		(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopMakePayment)(nil),
		(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopOrder)(nil),
		(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPriceInquiry)(nil),
		(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPurchaseGiftCard)(nil),
		(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopUpdateQuantity)(nil),
		(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopChooseSeat)(nil),
		(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopEnterDrawingSubmission)(nil),
		(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardValidation)(nil),
		(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardMakePurchaseWithGiftCard)(nil),
	}
}

// BotDefenseFlowLabelFinancialServicesChoiceType
//
// x-displayName: "Bot Defense Flow Label Financial Services Category"
// Bot Defense Flow Label Financial Services Category
type BotDefenseFlowLabelFinancialServicesChoiceType struct {
	// Flow label
	//
	// x-displayName: "Flow Label"
	// x-required
	// Flow label category
	//
	// Types that are valid to be assigned to LabelChoice:
	//
	//	*BotDefenseFlowLabelFinancialServicesChoiceType_Apply
	//	*BotDefenseFlowLabelFinancialServicesChoiceType_MoneyTransfer
	LabelChoice isBotDefenseFlowLabelFinancialServicesChoiceType_LabelChoice `protobuf_oneof:"label_choice"`
}

func (m *BotDefenseFlowLabelFinancialServicesChoiceType) Reset() {
	*m = BotDefenseFlowLabelFinancialServicesChoiceType{}
}
func (*BotDefenseFlowLabelFinancialServicesChoiceType) ProtoMessage() {}
func (*BotDefenseFlowLabelFinancialServicesChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{97}
}
func (m *BotDefenseFlowLabelFinancialServicesChoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BotDefenseFlowLabelFinancialServicesChoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BotDefenseFlowLabelFinancialServicesChoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BotDefenseFlowLabelFinancialServicesChoiceType.Merge(m, src)
}
func (m *BotDefenseFlowLabelFinancialServicesChoiceType) XXX_Size() int {
	return m.Size()
}
func (m *BotDefenseFlowLabelFinancialServicesChoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_BotDefenseFlowLabelFinancialServicesChoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_BotDefenseFlowLabelFinancialServicesChoiceType proto.InternalMessageInfo

type isBotDefenseFlowLabelFinancialServicesChoiceType_LabelChoice interface {
	isBotDefenseFlowLabelFinancialServicesChoiceType_LabelChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type BotDefenseFlowLabelFinancialServicesChoiceType_Apply struct {
	Apply *Empty `protobuf:"bytes,2,opt,name=apply,proto3,oneof" json:"apply,omitempty"`
}
type BotDefenseFlowLabelFinancialServicesChoiceType_MoneyTransfer struct {
	MoneyTransfer *Empty `protobuf:"bytes,3,opt,name=money_transfer,json=moneyTransfer,proto3,oneof" json:"money_transfer,omitempty"`
}

func (*BotDefenseFlowLabelFinancialServicesChoiceType_Apply) isBotDefenseFlowLabelFinancialServicesChoiceType_LabelChoice() {
}
func (*BotDefenseFlowLabelFinancialServicesChoiceType_MoneyTransfer) isBotDefenseFlowLabelFinancialServicesChoiceType_LabelChoice() {
}

func (m *BotDefenseFlowLabelFinancialServicesChoiceType) GetLabelChoice() isBotDefenseFlowLabelFinancialServicesChoiceType_LabelChoice {
	if m != nil {
		return m.LabelChoice
	}
	return nil
}

func (m *BotDefenseFlowLabelFinancialServicesChoiceType) GetApply() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelFinancialServicesChoiceType_Apply); ok {
		return x.Apply
	}
	return nil
}

func (m *BotDefenseFlowLabelFinancialServicesChoiceType) GetMoneyTransfer() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelFinancialServicesChoiceType_MoneyTransfer); ok {
		return x.MoneyTransfer
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*BotDefenseFlowLabelFinancialServicesChoiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*BotDefenseFlowLabelFinancialServicesChoiceType_Apply)(nil),
		(*BotDefenseFlowLabelFinancialServicesChoiceType_MoneyTransfer)(nil),
	}
}

// BotDefenseFlowLabelSearchChoiceType
//
// x-displayName: "Bot Defense Flow Label Search Category"
// Bot Defense Flow Label Search Category
type BotDefenseFlowLabelSearchChoiceType struct {
	// Flow label
	//
	// x-displayName: "Flow Label"
	// Flow label category
	//
	// Types that are valid to be assigned to LabelChoice:
	//
	//	*BotDefenseFlowLabelSearchChoiceType_FlightSearch
	//	*BotDefenseFlowLabelSearchChoiceType_ProductSearch
	//	*BotDefenseFlowLabelSearchChoiceType_RoomSearch
	//	*BotDefenseFlowLabelSearchChoiceType_ReservationSearch
	LabelChoice isBotDefenseFlowLabelSearchChoiceType_LabelChoice `protobuf_oneof:"label_choice"`
}

func (m *BotDefenseFlowLabelSearchChoiceType) Reset()      { *m = BotDefenseFlowLabelSearchChoiceType{} }
func (*BotDefenseFlowLabelSearchChoiceType) ProtoMessage() {}
func (*BotDefenseFlowLabelSearchChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{98}
}
func (m *BotDefenseFlowLabelSearchChoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BotDefenseFlowLabelSearchChoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BotDefenseFlowLabelSearchChoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BotDefenseFlowLabelSearchChoiceType.Merge(m, src)
}
func (m *BotDefenseFlowLabelSearchChoiceType) XXX_Size() int {
	return m.Size()
}
func (m *BotDefenseFlowLabelSearchChoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_BotDefenseFlowLabelSearchChoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_BotDefenseFlowLabelSearchChoiceType proto.InternalMessageInfo

type isBotDefenseFlowLabelSearchChoiceType_LabelChoice interface {
	isBotDefenseFlowLabelSearchChoiceType_LabelChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type BotDefenseFlowLabelSearchChoiceType_FlightSearch struct {
	FlightSearch *Empty `protobuf:"bytes,2,opt,name=flight_search,json=flightSearch,proto3,oneof" json:"flight_search,omitempty"`
}
type BotDefenseFlowLabelSearchChoiceType_ProductSearch struct {
	ProductSearch *Empty `protobuf:"bytes,3,opt,name=product_search,json=productSearch,proto3,oneof" json:"product_search,omitempty"`
}
type BotDefenseFlowLabelSearchChoiceType_RoomSearch struct {
	RoomSearch *Empty `protobuf:"bytes,4,opt,name=room_search,json=roomSearch,proto3,oneof" json:"room_search,omitempty"`
}
type BotDefenseFlowLabelSearchChoiceType_ReservationSearch struct {
	ReservationSearch *Empty `protobuf:"bytes,5,opt,name=reservation_search,json=reservationSearch,proto3,oneof" json:"reservation_search,omitempty"`
}

func (*BotDefenseFlowLabelSearchChoiceType_FlightSearch) isBotDefenseFlowLabelSearchChoiceType_LabelChoice() {
}
func (*BotDefenseFlowLabelSearchChoiceType_ProductSearch) isBotDefenseFlowLabelSearchChoiceType_LabelChoice() {
}
func (*BotDefenseFlowLabelSearchChoiceType_RoomSearch) isBotDefenseFlowLabelSearchChoiceType_LabelChoice() {
}
func (*BotDefenseFlowLabelSearchChoiceType_ReservationSearch) isBotDefenseFlowLabelSearchChoiceType_LabelChoice() {
}

func (m *BotDefenseFlowLabelSearchChoiceType) GetLabelChoice() isBotDefenseFlowLabelSearchChoiceType_LabelChoice {
	if m != nil {
		return m.LabelChoice
	}
	return nil
}

func (m *BotDefenseFlowLabelSearchChoiceType) GetFlightSearch() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelSearchChoiceType_FlightSearch); ok {
		return x.FlightSearch
	}
	return nil
}

func (m *BotDefenseFlowLabelSearchChoiceType) GetProductSearch() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelSearchChoiceType_ProductSearch); ok {
		return x.ProductSearch
	}
	return nil
}

func (m *BotDefenseFlowLabelSearchChoiceType) GetRoomSearch() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelSearchChoiceType_RoomSearch); ok {
		return x.RoomSearch
	}
	return nil
}

func (m *BotDefenseFlowLabelSearchChoiceType) GetReservationSearch() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelSearchChoiceType_ReservationSearch); ok {
		return x.ReservationSearch
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*BotDefenseFlowLabelSearchChoiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*BotDefenseFlowLabelSearchChoiceType_FlightSearch)(nil),
		(*BotDefenseFlowLabelSearchChoiceType_ProductSearch)(nil),
		(*BotDefenseFlowLabelSearchChoiceType_RoomSearch)(nil),
		(*BotDefenseFlowLabelSearchChoiceType_ReservationSearch)(nil),
	}
}

// BotDefenseFlowLabelFlightChoiceType
//
// x-displayName: "Bot Defense Flow Label Flight Category"
// Bot Defense Flow Label Flight Category
type BotDefenseFlowLabelFlightChoiceType struct {
	// Flow label
	//
	// x-displayName: "Flow Label"
	// x-required
	// Flow label category
	//
	// Types that are valid to be assigned to LabelChoice:
	//
	//	*BotDefenseFlowLabelFlightChoiceType_Checkin
	LabelChoice isBotDefenseFlowLabelFlightChoiceType_LabelChoice `protobuf_oneof:"label_choice"`
}

func (m *BotDefenseFlowLabelFlightChoiceType) Reset()      { *m = BotDefenseFlowLabelFlightChoiceType{} }
func (*BotDefenseFlowLabelFlightChoiceType) ProtoMessage() {}
func (*BotDefenseFlowLabelFlightChoiceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{99}
}
func (m *BotDefenseFlowLabelFlightChoiceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BotDefenseFlowLabelFlightChoiceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BotDefenseFlowLabelFlightChoiceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BotDefenseFlowLabelFlightChoiceType.Merge(m, src)
}
func (m *BotDefenseFlowLabelFlightChoiceType) XXX_Size() int {
	return m.Size()
}
func (m *BotDefenseFlowLabelFlightChoiceType) XXX_DiscardUnknown() {
	xxx_messageInfo_BotDefenseFlowLabelFlightChoiceType.DiscardUnknown(m)
}

var xxx_messageInfo_BotDefenseFlowLabelFlightChoiceType proto.InternalMessageInfo

type isBotDefenseFlowLabelFlightChoiceType_LabelChoice interface {
	isBotDefenseFlowLabelFlightChoiceType_LabelChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type BotDefenseFlowLabelFlightChoiceType_Checkin struct {
	Checkin *Empty `protobuf:"bytes,2,opt,name=checkin,proto3,oneof" json:"checkin,omitempty"`
}

func (*BotDefenseFlowLabelFlightChoiceType_Checkin) isBotDefenseFlowLabelFlightChoiceType_LabelChoice() {
}

func (m *BotDefenseFlowLabelFlightChoiceType) GetLabelChoice() isBotDefenseFlowLabelFlightChoiceType_LabelChoice {
	if m != nil {
		return m.LabelChoice
	}
	return nil
}

func (m *BotDefenseFlowLabelFlightChoiceType) GetCheckin() *Empty {
	if x, ok := m.GetLabelChoice().(*BotDefenseFlowLabelFlightChoiceType_Checkin); ok {
		return x.Checkin
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*BotDefenseFlowLabelFlightChoiceType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*BotDefenseFlowLabelFlightChoiceType_Checkin)(nil),
	}
}

// NetworkingStackType
//
// x-displayName: "Networking Stack"
// Type of networking stack
type NetworkingStackType struct {
	// Networking Stack
	//
	// x-displayName: "Networking Stack"
	// Type of networking stack
	//
	// Types that are valid to be assigned to Choice:
	//
	//	*NetworkingStackType_Ipv4
	//	*NetworkingStackType_Ipv6
	//	*NetworkingStackType_Dual
	Choice isNetworkingStackType_Choice `protobuf_oneof:"choice"`
}

func (m *NetworkingStackType) Reset()      { *m = NetworkingStackType{} }
func (*NetworkingStackType) ProtoMessage() {}
func (*NetworkingStackType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{100}
}
func (m *NetworkingStackType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkingStackType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NetworkingStackType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkingStackType.Merge(m, src)
}
func (m *NetworkingStackType) XXX_Size() int {
	return m.Size()
}
func (m *NetworkingStackType) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkingStackType.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkingStackType proto.InternalMessageInfo

type isNetworkingStackType_Choice interface {
	isNetworkingStackType_Choice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type NetworkingStackType_Ipv4 struct {
	Ipv4 *Empty `protobuf:"bytes,2,opt,name=ipv4,proto3,oneof" json:"ipv4,omitempty"`
}
type NetworkingStackType_Ipv6 struct {
	Ipv6 *Empty `protobuf:"bytes,3,opt,name=ipv6,proto3,oneof" json:"ipv6,omitempty"`
}
type NetworkingStackType_Dual struct {
	Dual *Empty `protobuf:"bytes,4,opt,name=dual,proto3,oneof" json:"dual,omitempty"`
}

func (*NetworkingStackType_Ipv4) isNetworkingStackType_Choice() {}
func (*NetworkingStackType_Ipv6) isNetworkingStackType_Choice() {}
func (*NetworkingStackType_Dual) isNetworkingStackType_Choice() {}

func (m *NetworkingStackType) GetChoice() isNetworkingStackType_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *NetworkingStackType) GetIpv4() *Empty {
	if x, ok := m.GetChoice().(*NetworkingStackType_Ipv4); ok {
		return x.Ipv4
	}
	return nil
}

func (m *NetworkingStackType) GetIpv6() *Empty {
	if x, ok := m.GetChoice().(*NetworkingStackType_Ipv6); ok {
		return x.Ipv6
	}
	return nil
}

func (m *NetworkingStackType) GetDual() *Empty {
	if x, ok := m.GetChoice().(*NetworkingStackType_Dual); ok {
		return x.Dual
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*NetworkingStackType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*NetworkingStackType_Ipv4)(nil),
		(*NetworkingStackType_Ipv6)(nil),
		(*NetworkingStackType_Dual)(nil),
	}
}

// DateRange
//
// x-displayName: "Date Range"
// Date range is for selecting a date range
type DateRange struct {
	// start_date
	//
	// x-required
	// x-displayName: "Start Date"
	// Contains start date
	StartDate *types.Timestamp `protobuf:"bytes,1,opt,name=start_date,json=startDate,proto3" json:"start_date,omitempty"`
	// end_date
	//
	// x-required
	// x-displayName: "End Date"
	// Contains end date
	EndDate *types.Timestamp `protobuf:"bytes,2,opt,name=end_date,json=endDate,proto3" json:"end_date,omitempty"`
}

func (m *DateRange) Reset()      { *m = DateRange{} }
func (*DateRange) ProtoMessage() {}
func (*DateRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{101}
}
func (m *DateRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DateRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DateRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DateRange.Merge(m, src)
}
func (m *DateRange) XXX_Size() int {
	return m.Size()
}
func (m *DateRange) XXX_DiscardUnknown() {
	xxx_messageInfo_DateRange.DiscardUnknown(m)
}

var xxx_messageInfo_DateRange proto.InternalMessageInfo

func (m *DateRange) GetStartDate() *types.Timestamp {
	if m != nil {
		return m.StartDate
	}
	return nil
}

func (m *DateRange) GetEndDate() *types.Timestamp {
	if m != nil {
		return m.EndDate
	}
	return nil
}

// File
//
// x-displayName: "File"
// Contains file data
type File struct {
	// ContentType
	//
	// x-displayName: "Content Type"
	// Content type of the file (MIME type)
	// x-example: "image/jpeg"
	ContentType string `protobuf:"bytes,1,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	// Content
	//
	// x-displayName: "Content"
	// Content of the file
	// x-example: "dXNlci1pbWFnZS5qcGVn"
	Content []byte `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
	// FileId
	//
	// x-displayName: "File Id"
	// Id of the file
	// x-example: "file-123"
	FileId string `protobuf:"bytes,3,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	// StorageProvider
	//
	// x-displayName: "Storage Provider"
	// Storage provider that will store the content
	//
	// Types that are valid to be assigned to StorageProvider:
	//
	//	*File_AwsS3
	StorageProvider isFile_StorageProvider `protobuf_oneof:"storage_provider"`
}

func (m *File) Reset()      { *m = File{} }
func (*File) ProtoMessage() {}
func (*File) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{102}
}
func (m *File) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *File) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *File) XXX_Merge(src proto.Message) {
	xxx_messageInfo_File.Merge(m, src)
}
func (m *File) XXX_Size() int {
	return m.Size()
}
func (m *File) XXX_DiscardUnknown() {
	xxx_messageInfo_File.DiscardUnknown(m)
}

var xxx_messageInfo_File proto.InternalMessageInfo

type isFile_StorageProvider interface {
	isFile_StorageProvider()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type File_AwsS3 struct {
	AwsS3 *Empty `protobuf:"bytes,4,opt,name=aws_s3,json=awsS3,proto3,oneof" json:"aws_s3,omitempty"`
}

func (*File_AwsS3) isFile_StorageProvider() {}

func (m *File) GetStorageProvider() isFile_StorageProvider {
	if m != nil {
		return m.StorageProvider
	}
	return nil
}

func (m *File) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *File) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *File) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *File) GetAwsS3() *Empty {
	if x, ok := m.GetStorageProvider().(*File_AwsS3); ok {
		return x.AwsS3
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*File) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*File_AwsS3)(nil),
	}
}

// ResponseMeta
//
// x-displayName: "Response Meta"
// ResponseMeta to identify the error status of the operation.
type ResponseMeta struct {
	// error_code
	//
	// x-displayName: "ErrorCode"
	// x-example: "ErrNotFound"
	// ErrorCode is for identifying the status of the operation
	ErrorCode ErrorCode `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3,enum=ves.io.schema.ErrorCode" json:"error_code,omitempty"`
	// display_message
	//
	// x-displayName: "DisplayMessage"
	// x-example: "the tenant with name 'f5-xyz' not found"
	// DisplayMessage holds the message to be shown to the user
	DisplayMessage string `protobuf:"bytes,2,opt,name=display_message,json=displayMessage,proto3" json:"display_message,omitempty"`
	// description
	//
	// x-displayName: "Description"
	// x-example: "request failed with request: {"tenant_id": "f5-xyz"}. the tenant with name 'f5-xyz' not found"
	// Description holds the additional details regarding the error if any
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *ResponseMeta) Reset()      { *m = ResponseMeta{} }
func (*ResponseMeta) ProtoMessage() {}
func (*ResponseMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{103}
}
func (m *ResponseMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResponseMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseMeta.Merge(m, src)
}
func (m *ResponseMeta) XXX_Size() int {
	return m.Size()
}
func (m *ResponseMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseMeta.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseMeta proto.InternalMessageInfo

func (m *ResponseMeta) GetErrorCode() ErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return EOK
}

func (m *ResponseMeta) GetDisplayMessage() string {
	if m != nil {
		return m.DisplayMessage
	}
	return ""
}

func (m *ResponseMeta) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// action
//
// x-displayName: "Action"
type Action struct {
	// action
	//
	// x-required
	// x-displayName: "Action"
	// Action to be enforced if JWT is not valid.
	//
	// Types that are valid to be assigned to ActionChoice:
	//
	//	*Action_Block
	//	*Action_Report
	ActionChoice isAction_ActionChoice `protobuf_oneof:"action_choice"`
}

func (m *Action) Reset()      { *m = Action{} }
func (*Action) ProtoMessage() {}
func (*Action) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{104}
}
func (m *Action) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Action) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Action) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action.Merge(m, src)
}
func (m *Action) XXX_Size() int {
	return m.Size()
}
func (m *Action) XXX_DiscardUnknown() {
	xxx_messageInfo_Action.DiscardUnknown(m)
}

var xxx_messageInfo_Action proto.InternalMessageInfo

type isAction_ActionChoice interface {
	isAction_ActionChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Action_Block struct {
	Block *Empty `protobuf:"bytes,2,opt,name=block,proto3,oneof" json:"block,omitempty"`
}
type Action_Report struct {
	Report *Empty `protobuf:"bytes,3,opt,name=report,proto3,oneof" json:"report,omitempty"`
}

func (*Action_Block) isAction_ActionChoice()  {}
func (*Action_Report) isAction_ActionChoice() {}

func (m *Action) GetActionChoice() isAction_ActionChoice {
	if m != nil {
		return m.ActionChoice
	}
	return nil
}

func (m *Action) GetBlock() *Empty {
	if x, ok := m.GetActionChoice().(*Action_Block); ok {
		return x.Block
	}
	return nil
}

func (m *Action) GetReport() *Empty {
	if x, ok := m.GetActionChoice().(*Action_Report); ok {
		return x.Report
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Action) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Action_Block)(nil),
		(*Action_Report)(nil),
	}
}

// CRM Information
//
// x-displayName: "CRM Information"
// CRM Information
type CRMInfo struct {
	// AccountId
	//
	// x-displayName: "Account Id"
	// x-example: "SFA-1478257"
	// Source Account Id
	AccountId string `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
	// EntitlementID
	//
	// x-displayName: "Entitlement ID"
	// x-example: "e5712007-0560-4fcc-b8c9-f4ffbeaf3e4e"
	// Source Entitlement ID
	EntitlementId string `protobuf:"bytes,2,opt,name=entitlement_id,json=entitlementId,proto3" json:"entitlement_id,omitempty"`
	// SubscriptionId
	//
	// x-displayName: "Subscription Id"
	// x-example: "A-S00012023"
	// source subscription id
	SubscriptionId string `protobuf:"bytes,3,opt,name=subscription_id,json=subscriptionId,proto3" json:"subscription_id,omitempty"`
	// OrderType
	//
	// x-displayName: "Order Type"
	// x-example: "PAID"
	// source order type
	OrderType string `protobuf:"bytes,4,opt,name=order_type,json=orderType,proto3" json:"order_type,omitempty"`
	// Entitled SKUs
	//
	// x-displayName: "Entitled SKUs"
	// x-example: "['F5-V-O-ALL-BASE-PK-B','F5-XC-O-ALL-BOT-STD-B','F5-V-O-ADN-MSH-API-B','F5-V-O-ADN-MSH-RLM-B']"
	// SKU information that is used mostly for reporting purposes.
	EntitledSkus []string `protobuf:"bytes,5,rep,name=entitled_skus,json=entitledSkus,proto3" json:"entitled_skus,omitempty"`
	// Customer Identifier
	//
	// x-displayName: "Customer Identifier"
	// x-example: "HHhd4MFcSzM"
	// Customer identifier is a unique account(tenant) identifier provided by source
	CustomerIdentifier string `protobuf:"bytes,6,opt,name=customer_identifier,json=customerIdentifier,proto3" json:"customer_identifier,omitempty"`
}

func (m *CRMInfo) Reset()      { *m = CRMInfo{} }
func (*CRMInfo) ProtoMessage() {}
func (*CRMInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{105}
}
func (m *CRMInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CRMInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CRMInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CRMInfo.Merge(m, src)
}
func (m *CRMInfo) XXX_Size() int {
	return m.Size()
}
func (m *CRMInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CRMInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CRMInfo proto.InternalMessageInfo

func (m *CRMInfo) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *CRMInfo) GetEntitlementId() string {
	if m != nil {
		return m.EntitlementId
	}
	return ""
}

func (m *CRMInfo) GetSubscriptionId() string {
	if m != nil {
		return m.SubscriptionId
	}
	return ""
}

func (m *CRMInfo) GetOrderType() string {
	if m != nil {
		return m.OrderType
	}
	return ""
}

func (m *CRMInfo) GetEntitledSkus() []string {
	if m != nil {
		return m.EntitledSkus
	}
	return nil
}

func (m *CRMInfo) GetCustomerIdentifier() string {
	if m != nil {
		return m.CustomerIdentifier
	}
	return ""
}

// RegexMatchRewrite
//
// x-displayName: "Regex Match Rewrite"
// RegexMatchRewrite describes how to match a string and then produce a new string using a
// regular expression and a substitution string.
type RegexMatchRewrite struct {
	// Pattern
	//
	// x-displayName: "Pattern"
	// x-example: "^/service/([^/]+)(/.*)$"
	// The regular expression used to find portions of a string that should be replaced.
	Pattern string `protobuf:"bytes,1,opt,name=pattern,proto3" json:"pattern,omitempty"`
	// Substitution
	//
	// x-displayName: "Substitution"
	// x-example: "\\2/instance/\\1"
	// The string that should be substituted into matching portions of the subject string during a
	// substitution operation to produce a new string.
	Substitution string `protobuf:"bytes,2,opt,name=substitution,proto3" json:"substitution,omitempty"`
}

func (m *RegexMatchRewrite) Reset()      { *m = RegexMatchRewrite{} }
func (*RegexMatchRewrite) ProtoMessage() {}
func (*RegexMatchRewrite) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{106}
}
func (m *RegexMatchRewrite) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegexMatchRewrite) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RegexMatchRewrite) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegexMatchRewrite.Merge(m, src)
}
func (m *RegexMatchRewrite) XXX_Size() int {
	return m.Size()
}
func (m *RegexMatchRewrite) XXX_DiscardUnknown() {
	xxx_messageInfo_RegexMatchRewrite.DiscardUnknown(m)
}

var xxx_messageInfo_RegexMatchRewrite proto.InternalMessageInfo

func (m *RegexMatchRewrite) GetPattern() string {
	if m != nil {
		return m.Pattern
	}
	return ""
}

func (m *RegexMatchRewrite) GetSubstitution() string {
	if m != nil {
		return m.Substitution
	}
	return ""
}

func init() {
	proto.RegisterEnum("ves.io.schema.HttpMethod", HttpMethod_name, HttpMethod_value)
	golang_proto.RegisterEnum("ves.io.schema.HttpMethod", HttpMethod_name, HttpMethod_value)
	proto.RegisterEnum("ves.io.schema.BotHttpMethod", BotHttpMethod_name, BotHttpMethod_value)
	golang_proto.RegisterEnum("ves.io.schema.BotHttpMethod", BotHttpMethod_name, BotHttpMethod_value)
	proto.RegisterEnum("ves.io.schema.OpenApiValidationProperties", OpenApiValidationProperties_name, OpenApiValidationProperties_value)
	golang_proto.RegisterEnum("ves.io.schema.OpenApiValidationProperties", OpenApiValidationProperties_name, OpenApiValidationProperties_value)
	proto.RegisterEnum("ves.io.schema.HttpStatusCode", HttpStatusCode_name, HttpStatusCode_value)
	golang_proto.RegisterEnum("ves.io.schema.HttpStatusCode", HttpStatusCode_name, HttpStatusCode_value)
	proto.RegisterEnum("ves.io.schema.HttpResponseCodeClass", HttpResponseCodeClass_name, HttpResponseCodeClass_value)
	golang_proto.RegisterEnum("ves.io.schema.HttpResponseCodeClass", HttpResponseCodeClass_name, HttpResponseCodeClass_value)
	proto.RegisterEnum("ves.io.schema.HttpSections", HttpSections_name, HttpSections_value)
	golang_proto.RegisterEnum("ves.io.schema.HttpSections", HttpSections_name, HttpSections_value)
	proto.RegisterEnum("ves.io.schema.StatusPublishType", StatusPublishType_name, StatusPublishType_value)
	golang_proto.RegisterEnum("ves.io.schema.StatusPublishType", StatusPublishType_name, StatusPublishType_value)
	proto.RegisterEnum("ves.io.schema.SecretEncodingType", SecretEncodingType_name, SecretEncodingType_value)
	golang_proto.RegisterEnum("ves.io.schema.SecretEncodingType", SecretEncodingType_name, SecretEncodingType_value)
	proto.RegisterEnum("ves.io.schema.URLSchemeType", URLSchemeType_name, URLSchemeType_value)
	golang_proto.RegisterEnum("ves.io.schema.URLSchemeType", URLSchemeType_name, URLSchemeType_value)
	proto.RegisterEnum("ves.io.schema.TlsProtocol", TlsProtocol_name, TlsProtocol_value)
	golang_proto.RegisterEnum("ves.io.schema.TlsProtocol", TlsProtocol_name, TlsProtocol_value)
	proto.RegisterEnum("ves.io.schema.XfccElement", XfccElement_name, XfccElement_value)
	golang_proto.RegisterEnum("ves.io.schema.XfccElement", XfccElement_name, XfccElement_value)
	proto.RegisterEnum("ves.io.schema.HashAlgorithm", HashAlgorithm_name, HashAlgorithm_value)
	golang_proto.RegisterEnum("ves.io.schema.HashAlgorithm", HashAlgorithm_name, HashAlgorithm_value)
	proto.RegisterEnum("ves.io.schema.RoutingPriority", RoutingPriority_name, RoutingPriority_value)
	golang_proto.RegisterEnum("ves.io.schema.RoutingPriority", RoutingPriority_name, RoutingPriority_value)
	proto.RegisterEnum("ves.io.schema.DenominatorType", DenominatorType_name, DenominatorType_value)
	golang_proto.RegisterEnum("ves.io.schema.DenominatorType", DenominatorType_name, DenominatorType_value)
	proto.RegisterEnum("ves.io.schema.DiscoveryType", DiscoveryType_name, DiscoveryType_value)
	golang_proto.RegisterEnum("ves.io.schema.DiscoveryType", DiscoveryType_name, DiscoveryType_value)
	proto.RegisterEnum("ves.io.schema.VipVrrpType", VipVrrpType_name, VipVrrpType_value)
	golang_proto.RegisterEnum("ves.io.schema.VipVrrpType", VipVrrpType_name, VipVrrpType_value)
	proto.RegisterEnum("ves.io.schema.SiteToSiteTunnelType", SiteToSiteTunnelType_name, SiteToSiteTunnelType_value)
	golang_proto.RegisterEnum("ves.io.schema.SiteToSiteTunnelType", SiteToSiteTunnelType_name, SiteToSiteTunnelType_value)
	proto.RegisterEnum("ves.io.schema.SortOrder", SortOrder_name, SortOrder_value)
	golang_proto.RegisterEnum("ves.io.schema.SortOrder", SortOrder_name, SortOrder_value)
	proto.RegisterEnum("ves.io.schema.TunnelEncapsulationType", TunnelEncapsulationType_name, TunnelEncapsulationType_value)
	golang_proto.RegisterEnum("ves.io.schema.TunnelEncapsulationType", TunnelEncapsulationType_name, TunnelEncapsulationType_value)
	proto.RegisterEnum("ves.io.schema.TenantType", TenantType_name, TenantType_value)
	golang_proto.RegisterEnum("ves.io.schema.TenantType", TenantType_name, TenantType_value)
	proto.RegisterEnum("ves.io.schema.TaxExemptionType", TaxExemptionType_name, TaxExemptionType_value)
	golang_proto.RegisterEnum("ves.io.schema.TaxExemptionType", TaxExemptionType_name, TaxExemptionType_value)
	proto.RegisterEnum("ves.io.schema.PlanType", PlanType_name, PlanType_value)
	golang_proto.RegisterEnum("ves.io.schema.PlanType", PlanType_name, PlanType_value)
	proto.RegisterEnum("ves.io.schema.MetricLabelOp", MetricLabelOp_name, MetricLabelOp_value)
	golang_proto.RegisterEnum("ves.io.schema.MetricLabelOp", MetricLabelOp_name, MetricLabelOp_value)
	proto.RegisterEnum("ves.io.schema.TrendSentiment", TrendSentiment_name, TrendSentiment_value)
	golang_proto.RegisterEnum("ves.io.schema.TrendSentiment", TrendSentiment_name, TrendSentiment_value)
	proto.RegisterEnum("ves.io.schema.RouteAttrType", RouteAttrType_name, RouteAttrType_value)
	golang_proto.RegisterEnum("ves.io.schema.RouteAttrType", RouteAttrType_name, RouteAttrType_value)
	proto.RegisterEnum("ves.io.schema.NextHopTypes", NextHopTypes_name, NextHopTypes_value)
	golang_proto.RegisterEnum("ves.io.schema.NextHopTypes", NextHopTypes_name, NextHopTypes_value)
	proto.RegisterEnum("ves.io.schema.AddonServiceState", AddonServiceState_name, AddonServiceState_value)
	golang_proto.RegisterEnum("ves.io.schema.AddonServiceState", AddonServiceState_name, AddonServiceState_value)
	proto.RegisterEnum("ves.io.schema.AddonServiceCheckSubscribe", AddonServiceCheckSubscribe_name, AddonServiceCheckSubscribe_value)
	golang_proto.RegisterEnum("ves.io.schema.AddonServiceCheckSubscribe", AddonServiceCheckSubscribe_name, AddonServiceCheckSubscribe_value)
	proto.RegisterEnum("ves.io.schema.AddonServiceSubscribeAction", AddonServiceSubscribeAction_name, AddonServiceSubscribeAction_value)
	golang_proto.RegisterEnum("ves.io.schema.AddonServiceSubscribeAction", AddonServiceSubscribeAction_name, AddonServiceSubscribeAction_value)
	proto.RegisterEnum("ves.io.schema.AddonServiceAccess", AddonServiceAccess_name, AddonServiceAccess_value)
	golang_proto.RegisterEnum("ves.io.schema.AddonServiceAccess", AddonServiceAccess_name, AddonServiceAccess_value)
	proto.RegisterEnum("ves.io.schema.TileAccessState", TileAccessState_name, TileAccessState_value)
	golang_proto.RegisterEnum("ves.io.schema.TileAccessState", TileAccessState_name, TileAccessState_value)
	proto.RegisterEnum("ves.io.schema.SyncMode", SyncMode_name, SyncMode_value)
	golang_proto.RegisterEnum("ves.io.schema.SyncMode", SyncMode_name, SyncMode_value)
	proto.RegisterEnum("ves.io.schema.JavaScriptMode", JavaScriptMode_name, JavaScriptMode_value)
	golang_proto.RegisterEnum("ves.io.schema.JavaScriptMode", JavaScriptMode_name, JavaScriptMode_value)
	proto.RegisterEnum("ves.io.schema.FeatureTag", FeatureTag_name, FeatureTag_value)
	golang_proto.RegisterEnum("ves.io.schema.FeatureTag", FeatureTag_name, FeatureTag_value)
	proto.RegisterEnum("ves.io.schema.AddonServiceTierType", AddonServiceTierType_name, AddonServiceTierType_value)
	golang_proto.RegisterEnum("ves.io.schema.AddonServiceTierType", AddonServiceTierType_name, AddonServiceTierType_value)
	proto.RegisterEnum("ves.io.schema.CloudLinkState", CloudLinkState_name, CloudLinkState_value)
	golang_proto.RegisterEnum("ves.io.schema.CloudLinkState", CloudLinkState_name, CloudLinkState_value)
	proto.RegisterEnum("ves.io.schema.SignupOrigin", SignupOrigin_name, SignupOrigin_value)
	golang_proto.RegisterEnum("ves.io.schema.SignupOrigin", SignupOrigin_name, SignupOrigin_value)
	proto.RegisterType((*Empty)(nil), "ves.io.schema.Empty")
	golang_proto.RegisterType((*Empty)(nil), "ves.io.schema.Empty")
	proto.RegisterType((*ObjectRefType)(nil), "ves.io.schema.ObjectRefType")
	golang_proto.RegisterType((*ObjectRefType)(nil), "ves.io.schema.ObjectRefType")
	proto.RegisterType((*LabelSelectorType)(nil), "ves.io.schema.LabelSelectorType")
	golang_proto.RegisterType((*LabelSelectorType)(nil), "ves.io.schema.LabelSelectorType")
	proto.RegisterType((*LabelMatcherType)(nil), "ves.io.schema.LabelMatcherType")
	golang_proto.RegisterType((*LabelMatcherType)(nil), "ves.io.schema.LabelMatcherType")
	proto.RegisterType((*ConditionType)(nil), "ves.io.schema.ConditionType")
	golang_proto.RegisterType((*ConditionType)(nil), "ves.io.schema.ConditionType")
	proto.RegisterType((*StatusType)(nil), "ves.io.schema.StatusType")
	golang_proto.RegisterType((*StatusType)(nil), "ves.io.schema.StatusType")
	proto.RegisterType((*InitializerType)(nil), "ves.io.schema.InitializerType")
	golang_proto.RegisterType((*InitializerType)(nil), "ves.io.schema.InitializerType")
	proto.RegisterType((*InitializersType)(nil), "ves.io.schema.InitializersType")
	golang_proto.RegisterType((*InitializersType)(nil), "ves.io.schema.InitializersType")
	proto.RegisterType((*StatusMetaType)(nil), "ves.io.schema.StatusMetaType")
	golang_proto.RegisterType((*StatusMetaType)(nil), "ves.io.schema.StatusMetaType")
	proto.RegisterType((*ObjectMetaType)(nil), "ves.io.schema.ObjectMetaType")
	golang_proto.RegisterType((*ObjectMetaType)(nil), "ves.io.schema.ObjectMetaType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectMetaType.AnnotationsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectMetaType.AnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectMetaType.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectMetaType.LabelsEntry")
	proto.RegisterType((*ListMetaType)(nil), "ves.io.schema.ListMetaType")
	golang_proto.RegisterType((*ListMetaType)(nil), "ves.io.schema.ListMetaType")
	proto.RegisterType((*ObjectGetMetaType)(nil), "ves.io.schema.ObjectGetMetaType")
	golang_proto.RegisterType((*ObjectGetMetaType)(nil), "ves.io.schema.ObjectGetMetaType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectGetMetaType.AnnotationsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectGetMetaType.AnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectGetMetaType.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectGetMetaType.LabelsEntry")
	proto.RegisterType((*ObjectCreateMetaType)(nil), "ves.io.schema.ObjectCreateMetaType")
	golang_proto.RegisterType((*ObjectCreateMetaType)(nil), "ves.io.schema.ObjectCreateMetaType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectCreateMetaType.AnnotationsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectCreateMetaType.AnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectCreateMetaType.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectCreateMetaType.LabelsEntry")
	proto.RegisterType((*ObjectReplaceMetaType)(nil), "ves.io.schema.ObjectReplaceMetaType")
	golang_proto.RegisterType((*ObjectReplaceMetaType)(nil), "ves.io.schema.ObjectReplaceMetaType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectReplaceMetaType.AnnotationsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectReplaceMetaType.AnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectReplaceMetaType.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectReplaceMetaType.LabelsEntry")
	proto.RegisterType((*MessageMetaType)(nil), "ves.io.schema.MessageMetaType")
	golang_proto.RegisterType((*MessageMetaType)(nil), "ves.io.schema.MessageMetaType")
	proto.RegisterType((*ViewRefType)(nil), "ves.io.schema.ViewRefType")
	golang_proto.RegisterType((*ViewRefType)(nil), "ves.io.schema.ViewRefType")
	proto.RegisterType((*KubeRefType)(nil), "ves.io.schema.KubeRefType")
	golang_proto.RegisterType((*KubeRefType)(nil), "ves.io.schema.KubeRefType")
	proto.RegisterType((*SystemObjectMetaType)(nil), "ves.io.schema.SystemObjectMetaType")
	golang_proto.RegisterType((*SystemObjectMetaType)(nil), "ves.io.schema.SystemObjectMetaType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.SystemObjectMetaType.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.SystemObjectMetaType.LabelsEntry")
	proto.RegisterType((*SystemObjectGetMetaType)(nil), "ves.io.schema.SystemObjectGetMetaType")
	golang_proto.RegisterType((*SystemObjectGetMetaType)(nil), "ves.io.schema.SystemObjectGetMetaType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.SystemObjectGetMetaType.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.SystemObjectGetMetaType.LabelsEntry")
	proto.RegisterType((*AuthnTypeBasicAuth)(nil), "ves.io.schema.AuthnTypeBasicAuth")
	golang_proto.RegisterType((*AuthnTypeBasicAuth)(nil), "ves.io.schema.AuthnTypeBasicAuth")
	proto.RegisterType((*AuthnTypeHeaders)(nil), "ves.io.schema.AuthnTypeHeaders")
	golang_proto.RegisterType((*AuthnTypeHeaders)(nil), "ves.io.schema.AuthnTypeHeaders")
	proto.RegisterMapType((map[string]*SecretType)(nil), "ves.io.schema.AuthnTypeHeaders.HeadersEntry")
	golang_proto.RegisterMapType((map[string]*SecretType)(nil), "ves.io.schema.AuthnTypeHeaders.HeadersEntry")
	proto.RegisterType((*AuthnTypeQueryParams)(nil), "ves.io.schema.AuthnTypeQueryParams")
	golang_proto.RegisterType((*AuthnTypeQueryParams)(nil), "ves.io.schema.AuthnTypeQueryParams")
	proto.RegisterMapType((map[string]*SecretType)(nil), "ves.io.schema.AuthnTypeQueryParams.QueryParamsEntry")
	golang_proto.RegisterMapType((map[string]*SecretType)(nil), "ves.io.schema.AuthnTypeQueryParams.QueryParamsEntry")
	proto.RegisterType((*BlindfoldSecretInfoType)(nil), "ves.io.schema.BlindfoldSecretInfoType")
	golang_proto.RegisterType((*BlindfoldSecretInfoType)(nil), "ves.io.schema.BlindfoldSecretInfoType")
	proto.RegisterType((*VaultSecretInfoType)(nil), "ves.io.schema.VaultSecretInfoType")
	golang_proto.RegisterType((*VaultSecretInfoType)(nil), "ves.io.schema.VaultSecretInfoType")
	proto.RegisterType((*ClearSecretInfoType)(nil), "ves.io.schema.ClearSecretInfoType")
	golang_proto.RegisterType((*ClearSecretInfoType)(nil), "ves.io.schema.ClearSecretInfoType")
	proto.RegisterType((*WingmanSecretInfoType)(nil), "ves.io.schema.WingmanSecretInfoType")
	golang_proto.RegisterType((*WingmanSecretInfoType)(nil), "ves.io.schema.WingmanSecretInfoType")
	proto.RegisterType((*SecretType)(nil), "ves.io.schema.SecretType")
	golang_proto.RegisterType((*SecretType)(nil), "ves.io.schema.SecretType")
	proto.RegisterType((*NetworkRefType)(nil), "ves.io.schema.NetworkRefType")
	golang_proto.RegisterType((*NetworkRefType)(nil), "ves.io.schema.NetworkRefType")
	proto.RegisterType((*SiteRefType)(nil), "ves.io.schema.SiteRefType")
	golang_proto.RegisterType((*SiteRefType)(nil), "ves.io.schema.SiteRefType")
	proto.RegisterType((*IpPrefixSetRefType)(nil), "ves.io.schema.IpPrefixSetRefType")
	golang_proto.RegisterType((*IpPrefixSetRefType)(nil), "ves.io.schema.IpPrefixSetRefType")
	proto.RegisterType((*VSiteRefType)(nil), "ves.io.schema.VSiteRefType")
	golang_proto.RegisterType((*VSiteRefType)(nil), "ves.io.schema.VSiteRefType")
	proto.RegisterType((*PolicerRefType)(nil), "ves.io.schema.PolicerRefType")
	golang_proto.RegisterType((*PolicerRefType)(nil), "ves.io.schema.PolicerRefType")
	proto.RegisterType((*ProtocolPolicerRefType)(nil), "ves.io.schema.ProtocolPolicerRefType")
	golang_proto.RegisterType((*ProtocolPolicerRefType)(nil), "ves.io.schema.ProtocolPolicerRefType")
	proto.RegisterType((*NetworkSiteRefSelector)(nil), "ves.io.schema.NetworkSiteRefSelector")
	golang_proto.RegisterType((*NetworkSiteRefSelector)(nil), "ves.io.schema.NetworkSiteRefSelector")
	proto.RegisterType((*SiteVirtualSiteRefSelector)(nil), "ves.io.schema.SiteVirtualSiteRefSelector")
	golang_proto.RegisterType((*SiteVirtualSiteRefSelector)(nil), "ves.io.schema.SiteVirtualSiteRefSelector")
	proto.RegisterType((*HeaderManipulationOptionType)(nil), "ves.io.schema.HeaderManipulationOptionType")
	golang_proto.RegisterType((*HeaderManipulationOptionType)(nil), "ves.io.schema.HeaderManipulationOptionType")
	proto.RegisterType((*CookieManipulationOptionType)(nil), "ves.io.schema.CookieManipulationOptionType")
	golang_proto.RegisterType((*CookieManipulationOptionType)(nil), "ves.io.schema.CookieManipulationOptionType")
	proto.RegisterType((*TrustedCAList)(nil), "ves.io.schema.TrustedCAList")
	golang_proto.RegisterType((*TrustedCAList)(nil), "ves.io.schema.TrustedCAList")
	proto.RegisterType((*TlsValidationParamsType)(nil), "ves.io.schema.TlsValidationParamsType")
	golang_proto.RegisterType((*TlsValidationParamsType)(nil), "ves.io.schema.TlsValidationParamsType")
	proto.RegisterType((*HashAlgorithms)(nil), "ves.io.schema.HashAlgorithms")
	golang_proto.RegisterType((*HashAlgorithms)(nil), "ves.io.schema.HashAlgorithms")
	proto.RegisterType((*TlsCertificateType)(nil), "ves.io.schema.TlsCertificateType")
	golang_proto.RegisterType((*TlsCertificateType)(nil), "ves.io.schema.TlsCertificateType")
	proto.RegisterType((*DomainType)(nil), "ves.io.schema.DomainType")
	golang_proto.RegisterType((*DomainType)(nil), "ves.io.schema.DomainType")
	proto.RegisterType((*L4DestType)(nil), "ves.io.schema.L4DestType")
	golang_proto.RegisterType((*L4DestType)(nil), "ves.io.schema.L4DestType")
	proto.RegisterType((*TlsInterceptionRule)(nil), "ves.io.schema.TlsInterceptionRule")
	golang_proto.RegisterType((*TlsInterceptionRule)(nil), "ves.io.schema.TlsInterceptionRule")
	proto.RegisterType((*TlsInterceptionPolicy)(nil), "ves.io.schema.TlsInterceptionPolicy")
	golang_proto.RegisterType((*TlsInterceptionPolicy)(nil), "ves.io.schema.TlsInterceptionPolicy")
	proto.RegisterType((*TlsInterceptionType)(nil), "ves.io.schema.TlsInterceptionType")
	golang_proto.RegisterType((*TlsInterceptionType)(nil), "ves.io.schema.TlsInterceptionType")
	proto.RegisterType((*FractionalPercent)(nil), "ves.io.schema.FractionalPercent")
	golang_proto.RegisterType((*FractionalPercent)(nil), "ves.io.schema.FractionalPercent")
	proto.RegisterType((*BufferConfigType)(nil), "ves.io.schema.BufferConfigType")
	golang_proto.RegisterType((*BufferConfigType)(nil), "ves.io.schema.BufferConfigType")
	proto.RegisterType((*CorsPolicy)(nil), "ves.io.schema.CorsPolicy")
	golang_proto.RegisterType((*CorsPolicy)(nil), "ves.io.schema.CorsPolicy")
	proto.RegisterType((*CsrfPolicy)(nil), "ves.io.schema.CsrfPolicy")
	golang_proto.RegisterType((*CsrfPolicy)(nil), "ves.io.schema.CsrfPolicy")
	proto.RegisterType((*PathMatcherType)(nil), "ves.io.schema.PathMatcherType")
	golang_proto.RegisterType((*PathMatcherType)(nil), "ves.io.schema.PathMatcherType")
	proto.RegisterType((*PortMatcherType)(nil), "ves.io.schema.PortMatcherType")
	golang_proto.RegisterType((*PortMatcherType)(nil), "ves.io.schema.PortMatcherType")
	proto.RegisterType((*HeaderMatcherType)(nil), "ves.io.schema.HeaderMatcherType")
	golang_proto.RegisterType((*HeaderMatcherType)(nil), "ves.io.schema.HeaderMatcherType")
	proto.RegisterType((*QueryParameterMatcherType)(nil), "ves.io.schema.QueryParameterMatcherType")
	golang_proto.RegisterType((*QueryParameterMatcherType)(nil), "ves.io.schema.QueryParameterMatcherType")
	proto.RegisterType((*RouteMatch)(nil), "ves.io.schema.RouteMatch")
	golang_proto.RegisterType((*RouteMatch)(nil), "ves.io.schema.RouteMatch")
	proto.RegisterType((*AppFirewallRefType)(nil), "ves.io.schema.AppFirewallRefType")
	golang_proto.RegisterType((*AppFirewallRefType)(nil), "ves.io.schema.AppFirewallRefType")
	proto.RegisterType((*WafType)(nil), "ves.io.schema.WafType")
	golang_proto.RegisterType((*WafType)(nil), "ves.io.schema.WafType")
	proto.RegisterType((*AppRoleAuthInfoType)(nil), "ves.io.schema.AppRoleAuthInfoType")
	golang_proto.RegisterType((*AppRoleAuthInfoType)(nil), "ves.io.schema.AppRoleAuthInfoType")
	proto.RegisterType((*VaultAuthInfoType)(nil), "ves.io.schema.VaultAuthInfoType")
	golang_proto.RegisterType((*VaultAuthInfoType)(nil), "ves.io.schema.VaultAuthInfoType")
	proto.RegisterType((*RestAuthInfoType)(nil), "ves.io.schema.RestAuthInfoType")
	golang_proto.RegisterType((*RestAuthInfoType)(nil), "ves.io.schema.RestAuthInfoType")
	proto.RegisterType((*VaultAccessInfoType)(nil), "ves.io.schema.VaultAccessInfoType")
	golang_proto.RegisterType((*VaultAccessInfoType)(nil), "ves.io.schema.VaultAccessInfoType")
	proto.RegisterType((*VaultSecretType)(nil), "ves.io.schema.VaultSecretType")
	golang_proto.RegisterType((*VaultSecretType)(nil), "ves.io.schema.VaultSecretType")
	proto.RegisterType((*VolterraSecretType)(nil), "ves.io.schema.VolterraSecretType")
	golang_proto.RegisterType((*VolterraSecretType)(nil), "ves.io.schema.VolterraSecretType")
	proto.RegisterType((*PortValueType)(nil), "ves.io.schema.PortValueType")
	golang_proto.RegisterType((*PortValueType)(nil), "ves.io.schema.PortValueType")
	proto.RegisterType((*VirtualNetworkReferenceType)(nil), "ves.io.schema.VirtualNetworkReferenceType")
	golang_proto.RegisterType((*VirtualNetworkReferenceType)(nil), "ves.io.schema.VirtualNetworkReferenceType")
	proto.RegisterType((*VirtualNetworkSelectorType)(nil), "ves.io.schema.VirtualNetworkSelectorType")
	golang_proto.RegisterType((*VirtualNetworkSelectorType)(nil), "ves.io.schema.VirtualNetworkSelectorType")
	proto.RegisterType((*RetryBackOff)(nil), "ves.io.schema.RetryBackOff")
	golang_proto.RegisterType((*RetryBackOff)(nil), "ves.io.schema.RetryBackOff")
	proto.RegisterType((*RetryPolicyType)(nil), "ves.io.schema.RetryPolicyType")
	golang_proto.RegisterType((*RetryPolicyType)(nil), "ves.io.schema.RetryPolicyType")
	proto.RegisterType((*MetricValue)(nil), "ves.io.schema.MetricValue")
	golang_proto.RegisterType((*MetricValue)(nil), "ves.io.schema.MetricValue")
	proto.RegisterType((*MetricTypeData)(nil), "ves.io.schema.MetricTypeData")
	golang_proto.RegisterType((*MetricTypeData)(nil), "ves.io.schema.MetricTypeData")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.MetricTypeData.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.MetricTypeData.LabelsEntry")
	proto.RegisterType((*TrendValue)(nil), "ves.io.schema.TrendValue")
	golang_proto.RegisterType((*TrendValue)(nil), "ves.io.schema.TrendValue")
	proto.RegisterType((*NextHopType)(nil), "ves.io.schema.NextHopType")
	golang_proto.RegisterType((*NextHopType)(nil), "ves.io.schema.NextHopType")
	proto.RegisterType((*StaticRouteType)(nil), "ves.io.schema.StaticRouteType")
	golang_proto.RegisterType((*StaticRouteType)(nil), "ves.io.schema.StaticRouteType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.StaticRouteType.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.StaticRouteType.LabelsEntry")
	proto.RegisterType((*ForwardProxyConfigType)(nil), "ves.io.schema.ForwardProxyConfigType")
	golang_proto.RegisterType((*ForwardProxyConfigType)(nil), "ves.io.schema.ForwardProxyConfigType")
	proto.RegisterType((*HostIdentifier)(nil), "ves.io.schema.HostIdentifier")
	golang_proto.RegisterType((*HostIdentifier)(nil), "ves.io.schema.HostIdentifier")
	proto.RegisterType((*InterfaceIdentifier)(nil), "ves.io.schema.InterfaceIdentifier")
	golang_proto.RegisterType((*InterfaceIdentifier)(nil), "ves.io.schema.InterfaceIdentifier")
	proto.RegisterType((*InterfaceOrNetwork)(nil), "ves.io.schema.InterfaceOrNetwork")
	golang_proto.RegisterType((*InterfaceOrNetwork)(nil), "ves.io.schema.InterfaceOrNetwork")
	proto.RegisterType((*RouteTarget2ByteAsn)(nil), "ves.io.schema.RouteTarget2ByteAsn")
	golang_proto.RegisterType((*RouteTarget2ByteAsn)(nil), "ves.io.schema.RouteTarget2ByteAsn")
	proto.RegisterType((*RouteTarget4ByteAsn)(nil), "ves.io.schema.RouteTarget4ByteAsn")
	golang_proto.RegisterType((*RouteTarget4ByteAsn)(nil), "ves.io.schema.RouteTarget4ByteAsn")
	proto.RegisterType((*RouteTargetIPv4Addr)(nil), "ves.io.schema.RouteTargetIPv4Addr")
	golang_proto.RegisterType((*RouteTargetIPv4Addr)(nil), "ves.io.schema.RouteTargetIPv4Addr")
	proto.RegisterType((*RouteTarget)(nil), "ves.io.schema.RouteTarget")
	golang_proto.RegisterType((*RouteTarget)(nil), "ves.io.schema.RouteTarget")
	proto.RegisterType((*PortRangesType)(nil), "ves.io.schema.PortRangesType")
	golang_proto.RegisterType((*PortRangesType)(nil), "ves.io.schema.PortRangesType")
	proto.RegisterType((*DomainNameList)(nil), "ves.io.schema.DomainNameList")
	golang_proto.RegisterType((*DomainNameList)(nil), "ves.io.schema.DomainNameList")
	proto.RegisterType((*NamespaceRoleType)(nil), "ves.io.schema.NamespaceRoleType")
	golang_proto.RegisterType((*NamespaceRoleType)(nil), "ves.io.schema.NamespaceRoleType")
	proto.RegisterType((*RoleListType)(nil), "ves.io.schema.RoleListType")
	golang_proto.RegisterType((*RoleListType)(nil), "ves.io.schema.RoleListType")
	proto.RegisterType((*NamespaceAccessType)(nil), "ves.io.schema.NamespaceAccessType")
	golang_proto.RegisterType((*NamespaceAccessType)(nil), "ves.io.schema.NamespaceAccessType")
	proto.RegisterMapType((map[string]*RoleListType)(nil), "ves.io.schema.NamespaceAccessType.NamespaceRoleMapEntry")
	golang_proto.RegisterMapType((map[string]*RoleListType)(nil), "ves.io.schema.NamespaceAccessType.NamespaceRoleMapEntry")
	proto.RegisterType((*SiteInfo)(nil), "ves.io.schema.SiteInfo")
	golang_proto.RegisterType((*SiteInfo)(nil), "ves.io.schema.SiteInfo")
	proto.RegisterType((*SiteReferenceListType)(nil), "ves.io.schema.SiteReferenceListType")
	golang_proto.RegisterType((*SiteReferenceListType)(nil), "ves.io.schema.SiteReferenceListType")
	proto.RegisterType((*HeaderTransformationType)(nil), "ves.io.schema.HeaderTransformationType")
	golang_proto.RegisterType((*HeaderTransformationType)(nil), "ves.io.schema.HeaderTransformationType")
	proto.RegisterType((*BotDefenseFlowLabelCategoriesChoiceType)(nil), "ves.io.schema.BotDefenseFlowLabelCategoriesChoiceType")
	golang_proto.RegisterType((*BotDefenseFlowLabelCategoriesChoiceType)(nil), "ves.io.schema.BotDefenseFlowLabelCategoriesChoiceType")
	proto.RegisterType((*BotDefenseFlowLabelAuthenticationChoiceType)(nil), "ves.io.schema.BotDefenseFlowLabelAuthenticationChoiceType")
	golang_proto.RegisterType((*BotDefenseFlowLabelAuthenticationChoiceType)(nil), "ves.io.schema.BotDefenseFlowLabelAuthenticationChoiceType")
	proto.RegisterType((*BotDefenseTransactionResult)(nil), "ves.io.schema.BotDefenseTransactionResult")
	golang_proto.RegisterType((*BotDefenseTransactionResult)(nil), "ves.io.schema.BotDefenseTransactionResult")
	proto.RegisterType((*BotDefenseTransactionResultType)(nil), "ves.io.schema.BotDefenseTransactionResultType")
	golang_proto.RegisterType((*BotDefenseTransactionResultType)(nil), "ves.io.schema.BotDefenseTransactionResultType")
	proto.RegisterType((*BotDefenseTransactionResultCondition)(nil), "ves.io.schema.BotDefenseTransactionResultCondition")
	golang_proto.RegisterType((*BotDefenseTransactionResultCondition)(nil), "ves.io.schema.BotDefenseTransactionResultCondition")
	proto.RegisterType((*BotDefenseFlowLabelAccountManagementChoiceType)(nil), "ves.io.schema.BotDefenseFlowLabelAccountManagementChoiceType")
	golang_proto.RegisterType((*BotDefenseFlowLabelAccountManagementChoiceType)(nil), "ves.io.schema.BotDefenseFlowLabelAccountManagementChoiceType")
	proto.RegisterType((*BotDefenseFlowLabelProfileManagementChoiceType)(nil), "ves.io.schema.BotDefenseFlowLabelProfileManagementChoiceType")
	golang_proto.RegisterType((*BotDefenseFlowLabelProfileManagementChoiceType)(nil), "ves.io.schema.BotDefenseFlowLabelProfileManagementChoiceType")
	proto.RegisterType((*BotDefenseFlowLabelShoppingGiftCardsChoiceType)(nil), "ves.io.schema.BotDefenseFlowLabelShoppingGiftCardsChoiceType")
	golang_proto.RegisterType((*BotDefenseFlowLabelShoppingGiftCardsChoiceType)(nil), "ves.io.schema.BotDefenseFlowLabelShoppingGiftCardsChoiceType")
	proto.RegisterType((*BotDefenseFlowLabelFinancialServicesChoiceType)(nil), "ves.io.schema.BotDefenseFlowLabelFinancialServicesChoiceType")
	golang_proto.RegisterType((*BotDefenseFlowLabelFinancialServicesChoiceType)(nil), "ves.io.schema.BotDefenseFlowLabelFinancialServicesChoiceType")
	proto.RegisterType((*BotDefenseFlowLabelSearchChoiceType)(nil), "ves.io.schema.BotDefenseFlowLabelSearchChoiceType")
	golang_proto.RegisterType((*BotDefenseFlowLabelSearchChoiceType)(nil), "ves.io.schema.BotDefenseFlowLabelSearchChoiceType")
	proto.RegisterType((*BotDefenseFlowLabelFlightChoiceType)(nil), "ves.io.schema.BotDefenseFlowLabelFlightChoiceType")
	golang_proto.RegisterType((*BotDefenseFlowLabelFlightChoiceType)(nil), "ves.io.schema.BotDefenseFlowLabelFlightChoiceType")
	proto.RegisterType((*NetworkingStackType)(nil), "ves.io.schema.NetworkingStackType")
	golang_proto.RegisterType((*NetworkingStackType)(nil), "ves.io.schema.NetworkingStackType")
	proto.RegisterType((*DateRange)(nil), "ves.io.schema.DateRange")
	golang_proto.RegisterType((*DateRange)(nil), "ves.io.schema.DateRange")
	proto.RegisterType((*File)(nil), "ves.io.schema.File")
	golang_proto.RegisterType((*File)(nil), "ves.io.schema.File")
	proto.RegisterType((*ResponseMeta)(nil), "ves.io.schema.ResponseMeta")
	golang_proto.RegisterType((*ResponseMeta)(nil), "ves.io.schema.ResponseMeta")
	proto.RegisterType((*Action)(nil), "ves.io.schema.Action")
	golang_proto.RegisterType((*Action)(nil), "ves.io.schema.Action")
	proto.RegisterType((*CRMInfo)(nil), "ves.io.schema.CRMInfo")
	golang_proto.RegisterType((*CRMInfo)(nil), "ves.io.schema.CRMInfo")
	proto.RegisterType((*RegexMatchRewrite)(nil), "ves.io.schema.RegexMatchRewrite")
	golang_proto.RegisterType((*RegexMatchRewrite)(nil), "ves.io.schema.RegexMatchRewrite")
}

func init() { proto.RegisterFile("ves.io/schema/types.proto", fileDescriptor_f21334e98d27f9ba) }
func init() { golang_proto.RegisterFile("ves.io/schema/types.proto", fileDescriptor_f21334e98d27f9ba) }

var fileDescriptor_f21334e98d27f9ba = []byte{
	// 13327 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0xbd, 0x7d, 0x70, 0x1b, 0x49,
	0x76, 0x18, 0xce, 0xc6, 0x17, 0xc1, 0x07, 0x10, 0x1c, 0x36, 0xf5, 0x41, 0x41, 0x1f, 0x0b, 0x61,
	0xbf, 0x74, 0x38, 0x8a, 0x12, 0x29, 0x4a, 0xab, 0xd5, 0xdd, 0x69, 0x17, 0x00, 0x41, 0x11, 0x12,
	0x09, 0x62, 0x07, 0xa0, 0xa4, 0xbd, 0x73, 0x79, 0x76, 0x08, 0x34, 0xc8, 0xb1, 0x80, 0x19, 0xec,
	0xcc, 0x80, 0x22, 0xfd, 0xfb, 0xc9, 0x3f, 0xfd, 0xee, 0xf7, 0xab, 0xd4, 0x65, 0x1d, 0xdb, 0xe7,
	0xf5, 0x39, 0xbe, 0x6c, 0xe2, 0x78, 0x1d, 0x3b, 0xf6, 0xd5, 0x96, 0x1d, 0x9f, 0xcb, 0x4e, 0x55,
	0x12, 0xc8, 0x95, 0xad, 0x75, 0xe2, 0x3a, 0x2b, 0xce, 0x59, 0x95, 0xaa, 0x54, 0x6d, 0xdd, 0xb9,
	0x52, 0x67, 0x6d, 0x1c, 0x9f, 0x5d, 0xae, 0xca, 0xd5, 0x26, 0x8e, 0x2f, 0x1f, 0x95, 0x4b, 0xf5,
	0xc7, 0x0c, 0x66, 0x40, 0x10, 0xd4, 0xde, 0x9d, 0xcb, 0xa9, 0x8a, 0xf7, 0x8f, 0x15, 0xa7, 0xfb,
	0xbd, 0xd7, 0xdd, 0xef, 0xbd, 0xee, 0x7e, 0xef, 0xf5, 0xeb, 0x06, 0x1c, 0xdb, 0x26, 0xd6, 0xac,
	0x66, 0x9c, 0xb3, 0x6a, 0x5b, 0xa4, 0xa5, 0x9e, 0xb3, 0x77, 0xdb, 0xc4, 0x9a, 0x6d, 0x9b, 0x86,
	0x6d, 0xe0, 0x71, 0x5e, 0x35, 0xcb, 0xab, 0x92, 0x67, 0x37, 0x35, 0x7b, 0xab, 0xb3, 0x31, 0x5b,
	0x33, 0x5a, 0xe7, 0x36, 0x8d, 0x4d, 0xe3, 0x1c, 0x83, 0xda, 0xe8, 0x34, 0xd8, 0x17, 0xfb, 0x60,
	0x7f, 0x71, 0xec, 0xe4, 0x53, 0x9b, 0x86, 0xb1, 0xd9, 0x24, 0x3d, 0x28, 0x5b, 0x6b, 0x11, 0xcb,
	0x56, 0x5b, 0x6d, 0x01, 0x90, 0xf4, 0xb7, 0x4c, 0x4c, 0xd3, 0x30, 0x45, 0xd3, 0xc9, 0xa3, 0xfe,
	0x3a, 0x9d, 0xd8, 0xa2, 0xe2, 0xb8, 0xbf, 0xc2, 0x68, 0xdb, 0x9a, 0xa1, 0x3b, 0x58, 0x27, 0xfc,
	0x95, 0xdb, 0x6a, 0x53, 0xab, 0xab, 0x36, 0x11, 0xb5, 0xa9, 0xbe, 0x5a, 0x8d, 0xdc, 0x55, 0x7c,
	0xf8, 0xe9, 0x51, 0x08, 0x17, 0x5a, 0x6d, 0x7b, 0x37, 0xfd, 0x36, 0x82, 0xf1, 0xb5, 0x8d, 0x1f,
	0x22, 0x35, 0x5b, 0x26, 0x8d, 0xea, 0x6e, 0x9b, 0xe0, 0xa3, 0x10, 0xba, 0xa3, 0xe9, 0xf5, 0x69,
	0x94, 0x42, 0x67, 0xc6, 0x72, 0xc1, 0x47, 0xf7, 0x90, 0xcc, 0x0a, 0xf0, 0x61, 0x08, 0x76, 0xb4,
	0xfa, 0x74, 0xa0, 0x57, 0x4e, 0xbf, 0xf1, 0x71, 0x88, 0xd8, 0x44, 0x57, 0x75, 0x7b, 0x3a, 0xd8,
	0xab, 0x11, 0x45, 0xf8, 0x34, 0x8c, 0xe9, 0x6a, 0x8b, 0x58, 0x6d, 0xb5, 0x46, 0xa6, 0x43, 0xbd,
	0xfa, 0x5e, 0x29, 0x6d, 0x8f, 0x7e, 0x4c, 0x87, 0x3d, 0xed, 0xd1, 0x82, 0x2b, 0x91, 0x87, 0x5d,
	0x14, 0x90, 0x50, 0xfa, 0x55, 0x98, 0x5c, 0x51, 0x37, 0x48, 0xb3, 0x42, 0x9a, 0xa4, 0x66, 0x1b,
	0x26, 0xeb, 0xe5, 0x22, 0xc4, 0xc8, 0x4e, 0xdb, 0x24, 0x96, 0x45, 0x47, 0x35, 0x8d, 0x52, 0xc1,
	0x33, 0x63, 0xb9, 0xf4, 0xb7, 0xbb, 0x28, 0xf0, 0xcf, 0xfe, 0xe4, 0xdd, 0xe0, 0xc4, 0x9b, 0x28,
	0x9e, 0x06, 0x33, 0x2a, 0xa1, 0xe9, 0xfb, 0xa9, 0x6f, 0x04, 0x10, 0x2d, 0x0b, 0xbf, 0x49, 0xa9,
	0xc9, 0x5e, 0xb4, 0xf4, 0x0a, 0x48, 0x8c, 0xf4, 0xaa, 0x6a, 0xd7, 0xb6, 0x08, 0xa7, 0x7c, 0x19,
	0x42, 0x77, 0xc8, 0xae, 0x43, 0xf2, 0x19, 0x8a, 0x1a, 0x7b, 0x13, 0x45, 0xd3, 0x11, 0x33, 0x24,
	0xa1, 0xe9, 0x97, 0x5d, 0x52, 0x92, 0xf3, 0xd7, 0x34, 0x65, 0x10, 0xd9, 0xb5, 0xd2, 0xbf, 0x12,
	0x84, 0xf1, 0xbc, 0xa1, 0xd7, 0x35, 0xca, 0x69, 0x46, 0x6b, 0x01, 0x42, 0x54, 0xcd, 0x04, 0x2f,
	0x53, 0x14, 0xe3, 0xb8, 0x79, 0x4c, 0x86, 0x9b, 0x5c, 0x5e, 0x9a, 0xa1, 0xcb, 0xb1, 0xb5, 0x36,
	0x31, 0xd9, 0x9f, 0x6a, 0x53, 0x66, 0xd0, 0xb8, 0x01, 0x11, 0xcb, 0x56, 0xed, 0x8e, 0x25, 0x78,
	0x5d, 0xa2, 0x78, 0x45, 0xf3, 0x9a, 0x3c, 0x5a, 0xe9, 0xd4, 0x6a, 0xc4, 0xb2, 0xe4, 0xc8, 0x92,
	0xaa, 0x35, 0x49, 0x5d, 0x86, 0xa2, 0x5e, 0x33, 0x5a, 0xed, 0x26, 0xb1, 0x89, 0x3c, 0x56, 0xd4,
	0x2d, 0x5b, 0x6d, 0xd2, 0xe2, 0xd0, 0xa2, 0x71, 0x57, 0x97, 0xa3, 0x8b, 0x9a, 0xa5, 0x6e, 0xd0,
	0xef, 0xf1, 0x92, 0x61, 0x67, 0xdb, 0xed, 0xa6, 0x56, 0xa3, 0xdf, 0xb2, 0xa0, 0x8e, 0x8f, 0x40,
	0xc4, 0x24, 0xaa, 0x65, 0xe8, 0x5c, 0x72, 0xb2, 0xf8, 0xc2, 0x8b, 0x20, 0x35, 0x55, 0xcb, 0x56,
	0x3a, 0x6d, 0xaa, 0x53, 0x0a, 0xd5, 0x66, 0x26, 0x9d, 0xd8, 0x7c, 0x72, 0x96, 0xab, 0xfa, 0xac,
	0xa3, 0xea, 0xb3, 0x55, 0x47, 0xd5, 0xe5, 0x04, 0xc5, 0x59, 0x67, 0x28, 0xb4, 0x10, 0x27, 0x21,
	0xba, 0x65, 0x58, 0x36, 0x93, 0x6d, 0x84, 0xd1, 0x77, 0xbf, 0xf1, 0x69, 0x88, 0x5b, 0xc4, 0xdc,
	0xd6, 0x6a, 0x44, 0x61, 0xf5, 0xa3, 0xac, 0x3e, 0x26, 0xca, 0x4a, 0x54, 0xfa, 0xaf, 0x3d, 0xec,
	0xa2, 0x1f, 0x80, 0x04, 0x84, 0x28, 0x23, 0x93, 0x11, 0xce, 0x48, 0xc0, 0x10, 0xa9, 0xb0, 0xce,
	0x27, 0xa3, 0x0e, 0x93, 0x68, 0x99, 0xcc, 0x3a, 0x4e, 0xcb, 0xf8, 0x10, 0x20, 0x0d, 0xf1, 0x15,
	0xd5, 0xb2, 0x53, 0xbc, 0x3f, 0xf5, 0x24, 0xde, 0x3b, 0xa4, 0x74, 0x19, 0x80, 0xd3, 0x62, 0xa2,
	0x3a, 0xe2, 0x32, 0x1d, 0x71, 0x66, 0x1c, 0xc0, 0x24, 0x0c, 0xa1, 0x9a, 0x51, 0xe7, 0x4a, 0x1d,
	0x96, 0xd9, 0xdf, 0xe9, 0x67, 0x61, 0xa2, 0xa8, 0x6b, 0xb6, 0xa6, 0x36, 0xb5, 0x1f, 0x16, 0xda,
	0x84, 0x85, 0x76, 0x73, 0xa2, 0xec, 0xef, 0xf4, 0xff, 0x03, 0x92, 0x07, 0xcc, 0x12, 0x5a, 0x37,
	0xda, 0x26, 0x7a, 0x5d, 0xd3, 0x37, 0x99, 0xe2, 0xc5, 0xe6, 0x4f, 0xcd, 0xfa, 0xd6, 0xa4, 0xd9,
	0x3e, 0xc2, 0xb2, 0x03, 0x8e, 0xe7, 0x68, 0x07, 0xad, 0x4e, 0xd3, 0x66, 0xda, 0x12, 0x9b, 0x3f,
	0xd6, 0x87, 0xd8, 0x1b, 0xa3, 0x2c, 0x00, 0xd3, 0x7f, 0x14, 0x80, 0x04, 0x2f, 0x5e, 0x25, 0xb6,
	0xca, 0xda, 0x17, 0x93, 0x1b, 0xf5, 0x4d, 0xee, 0x33, 0x30, 0x5e, 0x33, 0x89, 0x6a, 0x1b, 0xa6,
	0x52, 0x6b, 0xaa, 0x96, 0xe5, 0x9d, 0xfd, 0x71, 0x51, 0x93, 0xa7, 0x15, 0x38, 0x0d, 0xe0, 0x40,
	0x6a, 0x75, 0xef, 0x52, 0x30, 0x26, 0x8a, 0x8b, 0x75, 0x9c, 0x82, 0x31, 0xce, 0x55, 0x0a, 0xe2,
	0x59, 0x0d, 0xa2, 0xbc, 0xb4, 0x58, 0xc7, 0x25, 0xc0, 0x0c, 0x5c, 0x33, 0x74, 0xc5, 0x5d, 0x45,
	0x0f, 0x56, 0x3e, 0x4e, 0x66, 0xd2, 0x41, 0x75, 0xcb, 0xf1, 0x15, 0x18, 0x6d, 0x77, 0x36, 0x9a,
	0x9a, 0xb5, 0xc5, 0x74, 0x30, 0x31, 0x9f, 0x1a, 0xc8, 0x9d, 0x32, 0x87, 0x11, 0x8c, 0xe5, 0x1f,
	0xf8, 0x04, 0x8c, 0x6e, 0xdb, 0x66, 0x9b, 0xf6, 0x75, 0xd4, 0xb3, 0xb2, 0xd1, 0xb2, 0x62, 0x9d,
	0x8e, 0x97, 0xd5, 0xd2, 0x39, 0x47, 0xa6, 0xa3, 0x29, 0x74, 0x26, 0x2a, 0xc6, 0x4b, 0x8b, 0x2b,
	0xb4, 0x34, 0xfd, 0x85, 0x10, 0x24, 0xf8, 0xe2, 0xea, 0xf2, 0xf9, 0xa8, 0x57, 0x1f, 0x3c, 0xab,
	0x1d, 0x3e, 0xe1, 0x5d, 0x29, 0x19, 0x97, 0xbd, 0x8b, 0xa4, 0x10, 0x4f, 0xb0, 0x4f, 0x3c, 0x25,
	0x88, 0x34, 0xe9, 0xfa, 0x65, 0x4d, 0x87, 0x98, 0xd2, 0x7c, 0xac, 0x6f, 0x74, 0xfe, 0xc6, 0x67,
	0xd9, 0x5a, 0x67, 0x15, 0x74, 0xdb, 0xdc, 0xcd, 0xc5, 0x1e, 0x7f, 0xe3, 0x5f, 0x06, 0x23, 0x6f,
	0x3c, 0x40, 0x81, 0xe8, 0x88, 0x2c, 0xa8, 0xe0, 0xb7, 0x11, 0xc4, 0x54, 0x5d, 0x37, 0x6c, 0xc6,
	0x46, 0x6b, 0x3a, 0xcc, 0xa8, 0xce, 0x0e, 0xa7, 0x9a, 0xed, 0x21, 0x70, 0xd2, 0xa5, 0x47, 0x5d,
	0xc4, 0x96, 0xdc, 0xd8, 0x5b, 0xfe, 0x75, 0x33, 0xfe, 0x16, 0x1a, 0xcb, 0x8c, 0x9a, 0x61, 0xba,
	0x2c, 0x47, 0x69, 0xfb, 0xf0, 0xc6, 0x03, 0x14, 0xc1, 0xa1, 0xaf, 0x74, 0xd1, 0x48, 0xaf, 0x3b,
	0xc8, 0xad, 0x49, 0xd2, 0x9a, 0xa0, 0xec, 0xed, 0x12, 0x9e, 0x81, 0x58, 0x9d, 0x58, 0x35, 0x53,
	0x63, 0xfb, 0x19, 0x5f, 0x59, 0x72, 0xc0, 0xd6, 0x62, 0x33, 0x78, 0xe6, 0xcb, 0x63, 0xb2, 0xb7,
	0x1a, 0x4f, 0xc3, 0x68, 0x9d, 0xaf, 0x82, 0x4c, 0x86, 0x51, 0xd9, 0xf9, 0x4c, 0xbe, 0x08, 0x31,
	0x0f, 0x3b, 0xb0, 0x04, 0xc1, 0x3b, 0x64, 0x57, 0x4c, 0x53, 0xfa, 0x27, 0x3e, 0x04, 0xe1, 0x6d,
	0xb5, 0xd9, 0x71, 0x84, 0xc1, 0x3f, 0xae, 0x04, 0x2e, 0xa3, 0xe4, 0x55, 0x90, 0xfa, 0xc7, 0xfc,
	0x51, 0xf0, 0xd3, 0x1b, 0x10, 0x5f, 0xd1, 0xac, 0x9e, 0x4e, 0x9c, 0x03, 0xc9, 0x24, 0x96, 0xd1,
	0x31, 0x6b, 0x44, 0xd9, 0x26, 0x26, 0xdd, 0x9a, 0x84, 0x7e, 0x84, 0xbe, 0xd9, 0x45, 0x48, 0x9e,
	0x70, 0x6a, 0x6f, 0xf2, 0x4a, 0xb6, 0xab, 0x92, 0x1d, 0x5b, 0x69, 0xab, 0x9b, 0x82, 0xbc, 0x80,
	0x8c, 0xd2, 0xe2, 0xb2, 0xba, 0xc9, 0x54, 0x6f, 0x92, 0xcb, 0xe9, 0x1a, 0xe9, 0xb5, 0x34, 0x60,
	0x35, 0x3a, 0x40, 0xf1, 0x5e, 0xe9, 0xd3, 0xb0, 0x99, 0x81, 0xba, 0xe0, 0x69, 0xe3, 0x60, 0x25,
	0xfb, 0x85, 0x81, 0x4a, 0x36, 0x77, 0x20, 0xe1, 0xbf, 0xd6, 0xb3, 0x8f, 0x86, 0x7f, 0x65, 0xf2,
	0xe1, 0xd5, 0xbe, 0xe5, 0x27, 0xfd, 0xb3, 0x21, 0x38, 0xc4, 0x8b, 0xf2, 0x74, 0xad, 0x24, 0xdf,
	0x83, 0x66, 0x54, 0xfb, 0x34, 0xe3, 0xdc, 0x40, 0x01, 0xfa, 0x9b, 0x39, 0x58, 0x39, 0x7e, 0x69,
	0xa0, 0x72, 0x2c, 0x3c, 0x09, 0xed, 0xbf, 0xd6, 0x8f, 0xef, 0x5d, 0x3f, 0xde, 0x0e, 0xc1, 0x61,
	0xc7, 0x1d, 0x68, 0x37, 0xd5, 0xda, 0xf7, 0xa2, 0x20, 0xeb, 0xae, 0x82, 0x04, 0x99, 0x10, 0xcf,
	0x0f, 0x14, 0x62, 0x5f, 0x3b, 0x07, 0x6b, 0xc8, 0x2f, 0xf7, 0x69, 0x08, 0xd7, 0xbe, 0x8b, 0x4f,
	0x44, 0xfc, 0xaf, 0x54, 0x45, 0xc2, 0x4f, 0xac, 0x22, 0x91, 0xff, 0x9d, 0x55, 0xe4, 0x47, 0x11,
	0x4c, 0xac, 0x12, 0xcb, 0x52, 0x37, 0x7b, 0xca, 0xf1, 0xbc, 0xcf, 0xaa, 0x99, 0xa2, 0x43, 0x0c,
	0x99, 0x01, 0x09, 0x89, 0xb1, 0xbe, 0x1d, 0x70, 0xac, 0x9c, 0x3e, 0x96, 0x04, 0x7c, 0x2c, 0x99,
	0xbe, 0x1f, 0xf0, 0xb3, 0xe4, 0x74, 0x8f, 0x25, 0x41, 0x66, 0x60, 0x8d, 0xbe, 0x7f, 0x0f, 0xb1,
	0x8d, 0xce, 0x29, 0x4f, 0x13, 0x88, 0xdd, 0xd4, 0xc8, 0x5d, 0xc7, 0x79, 0xc5, 0x5e, 0xe7, 0x55,
	0xf8, 0xad, 0x92, 0xc7, 0x6f, 0xe5, 0x66, 0xd3, 0x89, 0x3d, 0x5e, 0xa9, 0x57, 0x6f, 0xb1, 0xd7,
	0x21, 0x15, 0x26, 0x7b, 0x05, 0x62, 0x37, 0x3a, 0x1b, 0x64, 0x58, 0x33, 0xc3, 0x27, 0x83, 0x43,
	0x34, 0xe8, 0x21, 0xfa, 0x9f, 0x46, 0xe1, 0x50, 0x65, 0xd7, 0xb2, 0x49, 0xab, 0xcf, 0x48, 0xdc,
	0xc7, 0x18, 0x1f, 0x6c, 0x1c, 0x07, 0xbf, 0x6b, 0xe3, 0xb8, 0x08, 0xb8, 0x4e, 0x9a, 0xa4, 0x8f,
	0x5e, 0xe8, 0x40, 0x4f, 0x6f, 0xd2, 0xc1, 0xea, 0x91, 0xba, 0x09, 0x47, 0x5a, 0x46, 0x5d, 0x6b,
	0x68, 0xb5, 0xef, 0xd2, 0x76, 0x3f, 0xec, 0x45, 0xef, 0xd1, 0xcd, 0x43, 0x5c, 0xf3, 0xb8, 0x4a,
	0x6c, 0x66, 0xc4, 0xe6, 0x9f, 0xda, 0xdf, 0x37, 0xe2, 0x8e, 0x8e, 0x0f, 0x09, 0x9f, 0x02, 0x68,
	0x68, 0xba, 0x43, 0x62, 0x94, 0xfa, 0xf5, 0xb2, 0xa7, 0xc4, 0x13, 0xc1, 0x88, 0xee, 0x8d, 0x60,
	0xec, 0xf1, 0x80, 0xc6, 0x9e, 0xcc, 0x03, 0x82, 0x81, 0x1e, 0x50, 0x06, 0x12, 0x2e, 0x35, 0xc3,
	0xb8, 0xa3, 0x91, 0xe9, 0x44, 0x0f, 0xce, 0x69, 0x28, 0xcf, 0x6a, 0x28, 0x3d, 0xdb, 0x54, 0x6b,
	0x44, 0xd1, 0xf4, 0x86, 0x31, 0x1d, 0xf3, 0xd0, 0x63, 0xc5, 0x45, 0xbd, 0x61, 0xe0, 0xe7, 0x20,
	0x6e, 0x30, 0xdd, 0x51, 0x34, 0xbd, 0x4e, 0x76, 0xa6, 0xe3, 0x29, 0x74, 0x66, 0x9c, 0x43, 0xc5,
	0x78, 0x45, 0x91, 0x96, 0x63, 0xd9, 0xab, 0x9c, 0xe3, 0x6c, 0xc5, 0x3c, 0xb1, 0xcf, 0x8a, 0xc9,
	0x34, 0x3c, 0x77, 0xe4, 0x9d, 0x7b, 0x3d, 0x0c, 0x4f, 0xf8, 0xc4, 0xa3, 0xd2, 0x2f, 0x02, 0x18,
	0x77, 0x75, 0x62, 0x2a, 0xdb, 0x1a, 0xb9, 0x3b, 0x3d, 0x21, 0xe4, 0xec, 0x27, 0xea, 0x99, 0x9b,
	0xf2, 0x18, 0x83, 0xa6, 0x25, 0xf8, 0x19, 0x88, 0x59, 0x26, 0x51, 0x9c, 0xc9, 0x2d, 0xf5, 0xbc,
	0x27, 0xb0, 0x4c, 0x22, 0xe2, 0x16, 0x5e, 0x07, 0x6c, 0xf2, 0x20, 0x07, 0x0c, 0x0f, 0x72, 0xc0,
	0xf0, 0x2d, 0x77, 0x0b, 0x9a, 0x1a, 0x68, 0xa3, 0x0c, 0x9a, 0x7d, 0xbe, 0x1d, 0x28, 0xf1, 0xe8,
	0x1e, 0x1a, 0xb0, 0x09, 0x7d, 0x0f, 0x4b, 0x72, 0xfa, 0x83, 0x30, 0x1c, 0xf5, 0xb6, 0xeb, 0xb5,
	0xcf, 0x25, 0xcf, 0xc4, 0xe7, 0x73, 0xbe, 0xf8, 0xdd, 0xcd, 0xf9, 0xbf, 0xe4, 0xe9, 0xfe, 0xca,
	0x77, 0x3f, 0xdd, 0xff, 0x4a, 0x67, 0xfa, 0x11, 0xff, 0x4c, 0x77, 0x27, 0xf9, 0xd3, 0x03, 0x27,
	0x79, 0xdf, 0xfc, 0x3e, 0xb9, 0x77, 0x7e, 0x7b, 0xa7, 0xf6, 0xe9, 0x41, 0x53, 0xd1, 0x3f, 0x0b,
	0xbf, 0x87, 0x19, 0xf3, 0xe9, 0x3e, 0x4d, 0x9e, 0x1f, 0xa2, 0xc9, 0xfb, 0x79, 0x63, 0xdf, 0x7f,
	0x65, 0xbe, 0x72, 0xf4, 0xe1, 0xd5, 0x81, 0x5b, 0x58, 0xba, 0x05, 0x38, 0xdb, 0xb1, 0xb7, 0x58,
	0x18, 0x34, 0xa7, 0x5a, 0x5a, 0x8d, 0x7e, 0xe1, 0x24, 0x44, 0x3b, 0x16, 0x31, 0x3d, 0x86, 0xa4,
	0xfb, 0x8d, 0x3f, 0x01, 0xd1, 0xb6, 0x6a, 0x59, 0x77, 0x0d, 0xb3, 0xbe, 0x5f, 0x24, 0x8b, 0xd4,
	0x4c, 0x62, 0x33, 0x8a, 0xa1, 0x47, 0xcc, 0xdd, 0x75, 0x10, 0xd2, 0xdd, 0x20, 0x48, 0x6e, 0x7b,
	0xcb, 0x44, 0xad, 0x53, 0x69, 0xff, 0x62, 0x00, 0x46, 0xb7, 0xf8, 0xdf, 0x22, 0xa8, 0xd6, 0xef,
	0xbd, 0xf6, 0xa3, 0xcc, 0x8a, 0x7f, 0x39, 0xbf, 0xbe, 0x8e, 0x1c, 0x4b, 0x30, 0x2d, 0x2c, 0x41,
	0x16, 0x5c, 0x0e, 0xbf, 0x85, 0x02, 0x92, 0x44, 0x19, 0x79, 0xe2, 0x8d, 0x07, 0x68, 0x1a, 0x1f,
	0xf9, 0xd3, 0x2e, 0xc2, 0xcb, 0xd5, 0x6a, 0x39, 0xc5, 0x1b, 0x4b, 0x59, 0xb6, 0xa9, 0xe9, 0x9b,
	0x14, 0xe0, 0xf0, 0x1b, 0x0f, 0xd0, 0x24, 0x9e, 0x78, 0xdc, 0x45, 0x31, 0x06, 0xc0, 0xc9, 0x0f,
	0x37, 0x27, 0x73, 0x6f, 0x3c, 0x40, 0x57, 0x93, 0x9f, 0xfc, 0xd3, 0x2e, 0xba, 0x9c, 0x6b, 0x6a,
	0x7a, 0xbd, 0x61, 0x34, 0xeb, 0x29, 0xc3, 0x4c, 0xd5, 0x9a, 0x44, 0x35, 0x53, 0x16, 0xe3, 0x41,
	0x8a, 0x49, 0x20, 0xd5, 0x30, 0xcc, 0x94, 0xbd, 0xa5, 0x59, 0xa9, 0x2d, 0xdb, 0x6e, 0x3b, 0xad,
	0xdf, 0x21, 0xbb, 0x94, 0x8c, 0xf4, 0xc6, 0x03, 0x14, 0x4f, 0xc2, 0xe3, 0x2e, 0x8a, 0x70, 0xbe,
	0x79, 0x4c, 0xd5, 0x77, 0x99, 0x09, 0x25, 0x58, 0x93, 0x5c, 0x87, 0xb8, 0x77, 0xd8, 0x03, 0xe4,
	0x7f, 0xce, 0x2b, 0xff, 0x61, 0x72, 0xf1, 0xaa, 0xc6, 0xc7, 0xde, 0xeb, 0xa2, 0x67, 0xe1, 0x69,
	0x38, 0xb5, 0xa2, 0x59, 0x76, 0xca, 0x68, 0xa4, 0x28, 0xb3, 0x89, 0x6e, 0x8b, 0x99, 0x9f, 0x72,
	0xa4, 0x84, 0xe6, 0xd2, 0xff, 0x3e, 0x08, 0x87, 0x5c, 0x51, 0xbc, 0xd2, 0x21, 0xe6, 0x6e, 0x59,
	0x35, 0xd5, 0x96, 0x85, 0x7f, 0x2b, 0x00, 0xf1, 0xd7, 0xe9, 0xb7, 0xd2, 0x66, 0x05, 0x42, 0x8c,
	0x0b, 0xfb, 0x89, 0xd1, 0x83, 0x3b, 0xeb, 0xf9, 0x9b, 0x8b, 0xf3, 0x83, 0x83, 0xc4, 0x99, 0x7a,
	0xe3, 0x01, 0x3a, 0x81, 0x93, 0x7f, 0xda, 0x45, 0x47, 0x18, 0x72, 0x8a, 0x61, 0x13, 0xdb, 0x27,
	0xd2, 0x63, 0x6f, 0x3c, 0x40, 0x87, 0xf1, 0xd4, 0xe3, 0x2e, 0x9a, 0xe8, 0x03, 0xfa, 0xfe, 0x8b,
	0x95, 0x0d, 0x3d, 0xd5, 0xf6, 0x36, 0x70, 0xa0, 0x58, 0x63, 0xaf, 0xf7, 0xc6, 0x9d, 0x7c, 0x15,
	0xa4, 0x7e, 0x36, 0x7c, 0xbf, 0xc4, 0x3b, 0xf7, 0x5e, 0x17, 0x9d, 0x85, 0x8f, 0xc3, 0x73, 0x15,
	0x32, 0x48, 0xba, 0x7d, 0xbc, 0x61, 0x62, 0xfe, 0x65, 0x04, 0x47, 0xdd, 0xb1, 0x73, 0xaa, 0xd4,
	0x88, 0x11, 0x31, 0xb0, 0xa9, 0x3a, 0xa9, 0x99, 0xbb, 0xcc, 0xf0, 0x57, 0xda, 0xa6, 0xb1, 0xad,
	0xd5, 0x89, 0x29, 0x7a, 0x89, 0x7b, 0x55, 0x65, 0x51, 0x83, 0x9f, 0x85, 0x84, 0x65, 0x1b, 0x26,
	0xe9, 0xc1, 0xf2, 0xc5, 0x69, 0x9c, 0x95, 0xba, 0x60, 0x19, 0x88, 0x36, 0x0d, 0xde, 0x27, 0x11,
	0x3d, 0x4d, 0x7c, 0xbb, 0x8b, 0x82, 0xc2, 0xe3, 0xf8, 0x3c, 0x5d, 0x44, 0x9c, 0xfa, 0x2b, 0xd1,
	0x0f, 0xaf, 0x86, 0x2f, 0xcc, 0xcc, 0xcd, 0xcc, 0xa7, 0xff, 0x03, 0x82, 0xa9, 0x9b, 0x6a, 0xa7,
	0x69, 0xf7, 0xf5, 0xf2, 0x2c, 0x44, 0xfd, 0x5d, 0xcb, 0x4d, 0x7e, 0xad, 0x8b, 0xc6, 0xeb, 0xa4,
	0x41, 0x81, 0xcf, 0x6e, 0xd3, 0xff, 0xcb, 0x2e, 0x08, 0x5d, 0xee, 0xdc, 0xc6, 0x79, 0xef, 0xdc,
	0x6f, 0x47, 0x0c, 0xc1, 0x9e, 0x18, 0xa6, 0x61, 0xd4, 0x89, 0xfe, 0x85, 0xd8, 0xde, 0xe1, 0x7c,
	0xe2, 0xeb, 0x30, 0xc1, 0x15, 0x44, 0x21, 0x7a, 0xcd, 0x60, 0x87, 0x04, 0x61, 0x16, 0xcd, 0x3e,
	0x3d, 0x50, 0x54, 0x05, 0x01, 0xc4, 0x44, 0x96, 0xb0, 0x7c, 0x65, 0x57, 0xe2, 0x1f, 0x5e, 0x1d,
	0x9b, 0x9b, 0x99, 0x9f, 0xb9, 0x30, 0xb3, 0x30, 0x73, 0x31, 0x6d, 0xc0, 0x54, 0x9e, 0x2a, 0x60,
	0xdf, 0x38, 0x93, 0xfd, 0xe3, 0xf4, 0x0c, 0x6a, 0x01, 0x82, 0x1d, 0xb3, 0x29, 0x5c, 0xb7, 0xf4,
	0xb7, 0xbb, 0x28, 0xf4, 0x0f, 0x1e, 0xa0, 0xb8, 0x4d, 0x76, 0xec, 0x99, 0xd4, 0x86, 0x6a, 0x91,
	0x4b, 0x0b, 0x94, 0xb9, 0x63, 0xe6, 0xe8, 0x99, 0xfb, 0xf7, 0xa3, 0x94, 0xc1, 0x14, 0xfc, 0x4a,
	0xe4, 0xc3, 0xab, 0xc1, 0xf9, 0x99, 0xb9, 0xf4, 0xc7, 0xe1, 0xf0, 0x2d, 0x4d, 0xdf, 0x6c, 0xa9,
	0x7a, 0x5f, 0x93, 0x83, 0x0e, 0x4a, 0x7e, 0x37, 0x02, 0xd0, 0xd3, 0x3e, 0xfc, 0x03, 0x70, 0x78,
	0xc3, 0x51, 0x1f, 0x45, 0x30, 0x84, 0xd9, 0xc6, 0xdc, 0x86, 0x79, 0xae, 0x8f, 0x19, 0xfb, 0xa8,
	0xda, 0xf2, 0x88, 0x3c, 0xb5, 0xb1, 0xb7, 0x0a, 0x7f, 0x06, 0x26, 0x99, 0xfc, 0x7c, 0x94, 0xb9,
	0x39, 0x93, 0xee, 0xdf, 0xa3, 0xf7, 0xaa, 0x46, 0x6e, 0x4c, 0xb8, 0xa6, 0xd3, 0x68, 0x79, 0x44,
	0x9e, 0xd8, 0xf6, 0x43, 0xe0, 0x32, 0x4c, 0xb2, 0x89, 0xee, 0x23, 0x1e, 0x19, 0x48, 0x7c, 0x80,
	0x3c, 0x28, 0xc5, 0x9a, 0xbf, 0x18, 0x2b, 0x30, 0x75, 0x97, 0x33, 0xd2, 0x47, 0x73, 0x94, 0xd1,
	0x7c, 0xa6, 0x8f, 0xe6, 0x40, 0x96, 0xbb, 0xde, 0xf4, 0xf2, 0x88, 0x3c, 0x79, 0xb7, 0x1f, 0x02,
	0xdb, 0x70, 0x6a, 0x20, 0xb7, 0x15, 0x4d, 0xb7, 0xe9, 0x96, 0xdd, 0x64, 0x26, 0xd0, 0x13, 0xb3,
	0xbd, 0xe7, 0xbb, 0x1f, 0x1f, 0xc0, 0xfd, 0xa2, 0xa0, 0x89, 0x7f, 0x10, 0x0e, 0xf5, 0xa9, 0xba,
	0xc2, 0x4e, 0x50, 0xa3, 0x4f, 0xa8, 0xef, 0x1e, 0x39, 0xc8, 0xd8, 0xda, 0x53, 0x7d, 0xe5, 0x37,
	0xd1, 0x37, 0xae, 0xa2, 0x87, 0x5d, 0xf4, 0x36, 0x82, 0x9f, 0x45, 0xfc, 0x70, 0x31, 0xf3, 0x05,
	0x04, 0x9f, 0x43, 0x90, 0xde, 0x47, 0xbb, 0xe6, 0xc7, 0xdc, 0x11, 0xc1, 0x33, 0x03, 0x74, 0x64,
	0x7e, 0x62, 0x59, 0xb5, 0xb6, 0xb4, 0x9a, 0x61, 0xb6, 0x53, 0x4c, 0x31, 0x20, 0x39, 0x40, 0xd8,
	0xf3, 0x61, 0x26, 0x57, 0x48, 0x0d, 0x14, 0xdb, 0xfc, 0x58, 0xce, 0x30, 0x6c, 0xcb, 0x36, 0xd5,
	0x36, 0x1e, 0x5d, 0xd7, 0xef, 0xe8, 0xc6, 0x5d, 0xfd, 0x8b, 0x6f, 0x3f, 0x35, 0xf2, 0xe5, 0xb7,
	0x9f, 0x1a, 0xb9, 0xff, 0x07, 0xa9, 0x91, 0xdc, 0x19, 0x98, 0xf4, 0x8a, 0xc0, 0xd0, 0x89, 0xd1,
	0xc0, 0x53, 0xef, 0x76, 0x11, 0x35, 0x84, 0xc6, 0x1e, 0x77, 0xd1, 0xe8, 0xc2, 0xcc, 0xc5, 0x99,
	0x4b, 0x33, 0x2f, 0x5c, 0x0f, 0x45, 0x91, 0x14, 0xb8, 0x1e, 0x8a, 0x06, 0xa4, 0xe0, 0xf5, 0x50,
	0x34, 0x28, 0x85, 0xae, 0x87, 0xa2, 0x63, 0x12, 0xa4, 0x37, 0x20, 0x51, 0x22, 0xf6, 0x5d, 0xc3,
	0xbc, 0xe3, 0x04, 0x31, 0xca, 0x10, 0x34, 0x49, 0x43, 0x6c, 0xa9, 0xc3, 0xbd, 0xc1, 0xd4, 0x3b,
	0xf7, 0x26, 0xb6, 0x35, 0xd3, 0xee, 0xa8, 0x4d, 0x45, 0xe7, 0x54, 0xee, 0x3f, 0x40, 0xde, 0x63,
	0x75, 0x4a, 0x2a, 0xfd, 0x38, 0x08, 0xb1, 0x8a, 0x66, 0xbb, 0x61, 0x92, 0xe2, 0x93, 0xb7, 0x70,
	0xec, 0x9d, 0x7b, 0x21, 0x4b, 0xb3, 0x09, 0x25, 0xfb, 0x95, 0xbd, 0xa4, 0xf1, 0x1a, 0xc4, 0x45,
	0xc3, 0x5c, 0x1f, 0x02, 0x03, 0xf5, 0xe1, 0x26, 0xef, 0xa3, 0x18, 0x28, 0xd7, 0x87, 0x77, 0x1e,
	0xa0, 0x30, 0x04, 0x37, 0x36, 0xdb, 0x72, 0x4c, 0xef, 0x95, 0xe3, 0x65, 0x38, 0x24, 0xdc, 0x4f,
	0xa1, 0xd0, 0xc4, 0x56, 0xb6, 0xb5, 0xb6, 0x98, 0x94, 0x87, 0xfa, 0x08, 0xb3, 0x64, 0x89, 0xe5,
	0x11, 0x19, 0x0b, 0x9c, 0xa2, 0x40, 0xb9, 0xa9, 0xb5, 0xf1, 0x12, 0x4c, 0x11, 0x7d, 0x2f, 0xa1,
	0xf0, 0x50, 0x42, 0x93, 0x1c, 0xc5, 0x4b, 0xe7, 0x55, 0x08, 0x99, 0xa4, 0xc1, 0xdd, 0x96, 0x83,
	0xd8, 0xf5, 0xfc, 0x5e, 0x81, 0x08, 0xbd, 0xef, 0x93, 0x0b, 0x23, 0x99, 0xbb, 0x0a, 0x53, 0xde,
	0xbe, 0x29, 0xb5, 0x2d, 0x43, 0xab, 0x11, 0xfc, 0xfc, 0xbb, 0x5d, 0x14, 0x79, 0xd4, 0x45, 0xc1,
	0xc7, 0x5d, 0x14, 0xbc, 0x34, 0x73, 0xf1, 0x8d, 0x07, 0xe8, 0x10, 0x48, 0x6a, 0x7d, 0x9b, 0x98,
	0xb6, 0x66, 0x11, 0xa5, 0x6d, 0x34, 0xb5, 0xda, 0x6e, 0x0a, 0xb9, 0x8a, 0x14, 0x92, 0xc2, 0xe9,
	0xd7, 0x00, 0x17, 0xdb, 0x65, 0x93, 0x34, 0xb4, 0x9d, 0x0a, 0x71, 0xb3, 0x46, 0xae, 0x3f, 0xb9,
	0xa8, 0x93, 0xef, 0xdc, 0x1b, 0xd7, 0xda, 0x4a, 0x9b, 0x91, 0x50, 0x2c, 0x62, 0xf7, 0xab, 0xd1,
	0x4f, 0x84, 0x20, 0x7e, 0xf3, 0xbb, 0xd7, 0xa3, 0xb8, 0xc3, 0x18, 0xaa, 0x4f, 0xff, 0x07, 0xea,
	0xd1, 0xff, 0x8f, 0x3e, 0x82, 0x22, 0xc9, 0x43, 0x15, 0xe9, 0x9d, 0x07, 0xe8, 0x79, 0x88, 0x12,
	0xbd, 0xde, 0x36, 0x34, 0xdd, 0xde, 0xab, 0x1a, 0x30, 0x56, 0xd7, 0xac, 0x9a, 0xb1, 0x4d, 0xcc,
	0xdd, 0xbf, 0x54, 0x9d, 0xbb, 0x09, 0x89, 0x32, 0x2d, 0x27, 0xa6, 0xa3, 0x12, 0x8b, 0x4f, 0xae,
	0x12, 0x87, 0xde, 0xb9, 0x37, 0xda, 0xe6, 0xd8, 0xfd, 0x9a, 0xb6, 0x09, 0x47, 0xca, 0xa6, 0x61,
	0x1b, 0x35, 0xa3, 0xd9, 0x47, 0x7f, 0xf5, 0xc9, 0xe9, 0x9f, 0x7c, 0xe7, 0x9e, 0xd4, 0x16, 0x54,
	0x94, 0x7d, 0x1a, 0x7a, 0x3b, 0x00, 0x47, 0x84, 0x36, 0x09, 0xc5, 0x76, 0xb2, 0x99, 0x70, 0x09,
	0xfa, 0x05, 0xc0, 0x6c, 0xa0, 0xd8, 0xfc, 0xc9, 0xbe, 0x56, 0xfd, 0xcb, 0x77, 0x8e, 0x99, 0xfb,
	0xcb, 0x23, 0x72, 0x62, 0xdb, 0xa7, 0xac, 0xf8, 0x3c, 0xb0, 0x85, 0x54, 0x18, 0xf3, 0xfd, 0xe1,
	0x05, 0xcf, 0xb4, 0x5a, 0x1e, 0x91, 0x19, 0x24, 0x7e, 0x19, 0x7c, 0x53, 0x46, 0x44, 0x97, 0x8e,
	0xf7, 0xcf, 0x09, 0x3f, 0x6a, 0x4c, 0xa0, 0xd0, 0xd2, 0xdc, 0x33, 0x30, 0x61, 0x92, 0x86, 0x62,
	0xd0, 0x2d, 0x4f, 0x0c, 0x6b, 0xf2, 0xdd, 0x2e, 0x0a, 0x3e, 0xea, 0xa2, 0xf0, 0xe3, 0x2e, 0x0a,
	0x5f, 0x98, 0x99, 0x9f, 0x99, 0xe3, 0xb2, 0xbc, 0x1e, 0x8a, 0x86, 0xa5, 0xc8, 0xf5, 0x50, 0x34,
	0x22, 0x8d, 0x5e, 0x0f, 0x45, 0x47, 0xa5, 0xe8, 0xf5, 0x50, 0x34, 0x2a, 0x8d, 0xa5, 0x7f, 0x03,
	0x41, 0x92, 0x12, 0xbb, 0xd9, 0xa3, 0xeb, 0x65, 0xd3, 0x5f, 0xc5, 0xb0, 0x8e, 0xef, 0x1d, 0x56,
	0xf4, 0xdd, 0x2e, 0x0a, 0x3c, 0xea, 0x22, 0x47, 0x33, 0x3f, 0x1b, 0x84, 0x13, 0xdc, 0x93, 0x5d,
	0x55, 0x75, 0xad, 0xdd, 0x69, 0x32, 0xeb, 0x7e, 0xad, 0xed, 0xa6, 0x80, 0xa5, 0x7d, 0x47, 0x23,
	0xd4, 0xf9, 0x18, 0xf1, 0x1c, 0x77, 0xf0, 0x53, 0x91, 0xe7, 0x7c, 0xf1, 0x15, 0x3f, 0xd0, 0xdb,
	0x2f, 0x2d, 0x8f, 0x08, 0xbf, 0x0b, 0x2f, 0x42, 0x5c, 0x58, 0x01, 0x1c, 0x3c, 0xfc, 0x44, 0x61,
	0x12, 0x3a, 0x2a, 0x8e, 0x76, 0x93, 0x51, 0x99, 0x87, 0x88, 0xda, 0x6e, 0x13, 0xbd, 0x2e, 0x0e,
	0x55, 0x92, 0xb4, 0xb9, 0x77, 0x1e, 0x20, 0x0c, 0x52, 0xad, 0xae, 0x2b, 0x4d, 0x43, 0xad, 0x6f,
	0xa8, 0x4d, 0x55, 0xa7, 0xb3, 0x41, 0x40, 0x5e, 0xe9, 0xbc, 0xd7, 0x45, 0xc7, 0xe0, 0x28, 0x24,
	0x84, 0xd7, 0x9e, 0xb2, 0x8d, 0x54, 0xb6, 0x5e, 0xc7, 0xe1, 0xb9, 0x99, 0x85, 0x99, 0x0b, 0x0f,
	0xbb, 0xa8, 0x0a, 0x09, 0x08, 0x95, 0xd4, 0x16, 0x4b, 0xd5, 0xa2, 0x83, 0x82, 0x59, 0x08, 0xb3,
	0xf6, 0x32, 0xcf, 0xc2, 0xd3, 0x30, 0x2a, 0x46, 0x08, 0xd3, 0xfe, 0x21, 0xcc, 0x47, 0x65, 0x52,
	0x57, 0x6b, 0x36, 0xa9, 0x03, 0x86, 0x48, 0x96, 0x35, 0x96, 0x8c, 0x3a, 0x1d, 0xcc, 0x3d, 0x05,
	0x71, 0x06, 0xe6, 0x2c, 0x1e, 0x13, 0x0e, 0xf7, 0xe9, 0xe2, 0x31, 0x3f, 0x73, 0x51, 0x08, 0xe1,
	0x51, 0x0c, 0x4e, 0xf0, 0xa0, 0xf9, 0x3e, 0x42, 0x38, 0xe3, 0x13, 0xc2, 0xa1, 0x9e, 0x00, 0xc4,
	0x5f, 0x5f, 0x09, 0x39, 0x07, 0x54, 0x2f, 0xc1, 0x84, 0xb6, 0xa9, 0x53, 0xbf, 0xd2, 0x52, 0x5b,
	0x84, 0xe9, 0xcd, 0xc4, 0xd0, 0x05, 0x38, 0xc1, 0xc1, 0x2b, 0x02, 0x9a, 0x12, 0x70, 0x30, 0x15,
	0xcb, 0x36, 0xb5, 0x9a, 0x2d, 0x14, 0x6f, 0x5f, 0x02, 0x0e, 0x78, 0x85, 0x41, 0xe3, 0x17, 0x21,
	0xee, 0x12, 0x68, 0xaa, 0x3b, 0xc2, 0xb9, 0xd9, 0x0f, 0x3b, 0xe6, 0xc0, 0xae, 0xa8, 0x3b, 0xf8,
	0x13, 0x30, 0xee, 0xa2, 0xea, 0x86, 0x4e, 0x0e, 0xd8, 0x3b, 0xdc, 0x76, 0x4a, 0x86, 0x4e, 0x28,
	0xb2, 0x33, 0x72, 0x52, 0xeb, 0x98, 0x44, 0xb8, 0x12, 0x83, 0x91, 0x91, 0x1c, 0x17, 0xe3, 0x66,
	0xb0, 0xf8, 0x22, 0x80, 0x5a, 0xaf, 0x3b, 0x98, 0xd1, 0xa1, 0x98, 0x63, 0x6a, 0xbd, 0x2e, 0xd0,
	0x7a, 0xdc, 0xde, 0xb2, 0xed, 0xb6, 0xa1, 0x37, 0x77, 0x85, 0x53, 0x31, 0x18, 0x37, 0xe0, 0x70,
	0x7b, 0x59, 0x40, 0x53, 0x66, 0xd1, 0x76, 0x5d, 0xec, 0xd8, 0x50, 0xec, 0x98, 0x5a, 0xaf, 0xbb,
	0xa8, 0x9f, 0x04, 0x41, 0x4c, 0x69, 0xa9, 0x3b, 0x8a, 0xba, 0x49, 0xa6, 0xc7, 0x87, 0x20, 0x07,
	0x9d, 0x01, 0xaf, 0xaa, 0x3b, 0xd9, 0x4d, 0xda, 0xf3, 0x71, 0x81, 0x26, 0xe6, 0x62, 0x22, 0x85,
	0xce, 0x84, 0x73, 0xc7, 0xbe, 0xd6, 0x45, 0xe1, 0xcb, 0x97, 0x16, 0xce, 0x9f, 0xff, 0x9c, 0xb0,
	0xc3, 0x46, 0x33, 0xe1, 0xe9, 0xfb, 0x5f, 0xfe, 0x2d, 0x69, 0x39, 0x28, 0xc7, 0x5a, 0x0c, 0x97,
	0xcf, 0xc2, 0xdb, 0x70, 0xc2, 0xb1, 0x1b, 0x6c, 0xb5, 0xd5, 0x26, 0x26, 0x75, 0x75, 0xe8, 0x36,
	0x42, 0x6a, 0x2c, 0x5e, 0x30, 0x39, 0xa4, 0x33, 0x21, 0x39, 0x29, 0x70, 0xab, 0x0e, 0x6a, 0xd9,
	0xc5, 0xc4, 0x37, 0xe1, 0xb8, 0xb0, 0x23, 0x06, 0x12, 0x9e, 0x1a, 0x4a, 0xf8, 0x18, 0x47, 0x1d,
	0x40, 0xf7, 0xca, 0xcf, 0x07, 0xdf, 0xeb, 0xa2, 0x8f, 0xc1, 0xf3, 0x70, 0x84, 0xcf, 0xb5, 0x54,
	0xaf, 0x2e, 0x25, 0x77, 0x9a, 0x04, 0x8f, 0xcf, 0xcd, 0xcc, 0xcf, 0x5c, 0x9a, 0x79, 0x71, 0x66,
	0x6e, 0x7e, 0x66, 0xee, 0xd2, 0xc3, 0x2e, 0xfa, 0x8f, 0x81, 0x3d, 0xab, 0x42, 0x1b, 0xa2, 0xce,
	0x54, 0xc9, 0xd4, 0x61, 0x03, 0x8e, 0xed, 0x99, 0x6f, 0xf3, 0x91, 0x22, 0x2b, 0xa0, 0x55, 0x7d,
	0x33, 0x69, 0x3e, 0xc2, 0xe7, 0x08, 0x4c, 0xf9, 0xe7, 0xc8, 0x7c, 0x70, 0x45, 0xdd, 0x81, 0xc3,
	0x7d, 0xda, 0x3f, 0x1f, 0xa2, 0x7a, 0x0d, 0x97, 0x21, 0xc2, 0xb5, 0x2d, 0x33, 0x0b, 0x33, 0x70,
	0xb4, 0x4f, 0xcb, 0xdd, 0xd6, 0x26, 0xbd, 0x1a, 0x3c, 0x1f, 0xac, 0x10, 0x1b, 0xae, 0x42, 0x94,
	0x6a, 0xcb, 0x9a, 0xde, 0xdc, 0xcd, 0xcc, 0xc3, 0x79, 0x4f, 0x5f, 0x1d, 0x7d, 0x73, 0xb1, 0xa7,
	0xfc, 0x7a, 0xc8, 0xf1, 0x5f, 0x87, 0xe3, 0x82, 0x53, 0x2e, 0x3b, 0x3d, 0x3c, 0xcb, 0xc8, 0x50,
	0x86, 0xe7, 0x87, 0x6b, 0xc1, 0xfc, 0xa8, 0x38, 0x0b, 0x83, 0x67, 0x87, 0x0a, 0x75, 0x3e, 0x52,
	0x60, 0x95, 0xb9, 0x14, 0x44, 0x1d, 0x1e, 0xe0, 0x43, 0xef, 0x76, 0xd1, 0xc4, 0xa3, 0x2e, 0x0a,
	0x3c, 0xee, 0xa2, 0xe8, 0xdc, 0x45, 0x1e, 0xf1, 0xc9, 0x1d, 0x83, 0x08, 0x1f, 0x23, 0x5b, 0x4c,
	0xa3, 0x8f, 0xba, 0x28, 0x42, 0x17, 0xd3, 0x17, 0x66, 0x2e, 0xe7, 0x4e, 0x42, 0xd4, 0x19, 0x00,
	0xdb, 0xbe, 0x63, 0xc2, 0xb7, 0x0c, 0xcf, 0x9d, 0x9f, 0x99, 0x9b, 0xcb, 0xa5, 0x60, 0x54, 0xa8,
	0x3c, 0x3e, 0xfc, 0x6e, 0x17, 0x8d, 0x3f, 0xea, 0xa2, 0x38, 0xab, 0xbd, 0x30, 0x33, 0xb7, 0xf0,
	0xad, 0x2e, 0x42, 0xb9, 0x67, 0x41, 0xe2, 0xa7, 0x9a, 0xbd, 0x4e, 0x32, 0x42, 0x93, 0x8f, 0xba,
	0x48, 0x62, 0xa0, 0x2f, 0xcc, 0xcc, 0xbd, 0xe8, 0x3a, 0xa7, 0xdc, 0x02, 0x18, 0x93, 0xe0, 0x7a,
	0x28, 0x1a, 0x97, 0xc6, 0xaf, 0x87, 0xa2, 0x92, 0x34, 0x79, 0x3d, 0x14, 0xc5, 0xd2, 0x54, 0xda,
	0x82, 0xf1, 0xaa, 0xd9, 0xb1, 0x6c, 0x52, 0xcf, 0x67, 0x57, 0x34, 0xcb, 0xc6, 0x1b, 0x30, 0x61,
	0xf3, 0x02, 0xa5, 0xa6, 0x2a, 0x4d, 0xcd, 0xb2, 0x9f, 0xc8, 0x38, 0x3b, 0xf1, 0xce, 0xbd, 0x7e,
	0x3c, 0x8f, 0x6d, 0x36, 0x2e, 0xaa, 0xf2, 0x2a, 0x6d, 0x23, 0xfd, 0xc5, 0x20, 0x1c, 0xad, 0x36,
	0xad, 0x5e, 0x76, 0x36, 0x8f, 0x9b, 0x0a, 0x6f, 0x39, 0xe1, 0xa1, 0xd3, 0x31, 0x9b, 0x62, 0x33,
	0x39, 0x23, 0x22, 0x60, 0xb1, 0x36, 0x69, 0x79, 0x03, 0x60, 0x11, 0x33, 0x74, 0xe6, 0xfe, 0xfd,
	0xa8, 0xd8, 0x60, 0x3e, 0x17, 0xa4, 0xdb, 0x70, 0xdc, 0x6d, 0x6e, 0xdd, 0x6c, 0xe2, 0x4f, 0x01,
	0xf4, 0x28, 0x0a, 0x7f, 0xa1, 0x7f, 0x30, 0x3e, 0x1e, 0x2c, 0x8f, 0xc8, 0x63, 0x2e, 0x05, 0xfc,
	0x49, 0x48, 0x5a, 0x77, 0xb4, 0xb6, 0xe2, 0x24, 0x55, 0x2b, 0xdb, 0xc4, 0x74, 0xcf, 0xd5, 0x98,
	0x25, 0x11, 0x95, 0xa7, 0x29, 0xc4, 0xb2, 0x00, 0xb8, 0xe9, 0xa9, 0xc7, 0x2f, 0xc0, 0x34, 0x83,
	0xdf, 0x55, 0xac, 0x0e, 0x3f, 0xb5, 0x52, 0x9b, 0x36, 0x4b, 0xc6, 0xe6, 0xe9, 0x3a, 0x63, 0xf2,
	0x61, 0x5e, 0x5f, 0xe1, 0xd5, 0xd9, 0xa6, 0x4d, 0xe7, 0xb1, 0x85, 0x0b, 0x70, 0xbc, 0x63, 0x11,
	0x65, 0xdb, 0x68, 0xda, 0xc4, 0x34, 0x55, 0xa5, 0x8f, 0x29, 0x21, 0x7f, 0x9e, 0xc6, 0xd1, 0x8e,
	0x45, 0x6e, 0x0a, 0xd0, 0xaa, 0x67, 0xf0, 0xb9, 0x33, 0x30, 0xe9, 0xc1, 0x14, 0xdb, 0xfb, 0x94,
	0xf0, 0x0d, 0xc2, 0xdc, 0x37, 0x98, 0x7b, 0xfb, 0x01, 0x42, 0xdc, 0x5e, 0x4c, 0xdf, 0x85, 0xc4,
	0xb2, 0x6a, 0x6d, 0x65, 0x9b, 0x9b, 0x86, 0xa9, 0xd9, 0x5b, 0x2d, 0x0b, 0x13, 0x98, 0xd8, 0x52,
	0xad, 0x2d, 0x45, 0x75, 0x8b, 0x98, 0x42, 0x24, 0xf6, 0xf0, 0xd0, 0x87, 0x97, 0x3b, 0xe5, 0x8a,
	0x3f, 0xe4, 0xfc, 0x15, 0x45, 0x9e, 0x54, 0xfe, 0xc4, 0x96, 0xaf, 0x99, 0xf4, 0x2f, 0x46, 0x00,
	0x57, 0x9b, 0x56, 0x9e, 0xba, 0x27, 0x8c, 0x7b, 0x84, 0xa9, 0x43, 0x05, 0x26, 0x6a, 0xbd, 0x22,
	0x8f, 0x3e, 0x64, 0xf6, 0xd1, 0x87, 0xa8, 0x49, 0x25, 0xdc, 0xd3, 0x88, 0xfb, 0x41, 0x24, 0x27,
	0x3c, 0x24, 0xa8, 0x46, 0xbc, 0x0c, 0xb1, 0xb6, 0xa9, 0x6d, 0x53, 0x82, 0x77, 0xc8, 0xae, 0xd8,
	0xf9, 0x0f, 0x3c, 0x05, 0x03, 0x81, 0x73, 0x83, 0xec, 0xe2, 0xd4, 0x80, 0x94, 0x23, 0x7f, 0x4e,
	0xcd, 0x12, 0x4c, 0x51, 0xf9, 0x59, 0xec, 0xd0, 0x4e, 0x11, 0x91, 0x6b, 0x6b, 0xe8, 0x66, 0x3f,
	0x22, 0x4f, 0x76, 0x2c, 0xc2, 0x8f, 0xf9, 0x16, 0x05, 0x02, 0xbe, 0x0e, 0x87, 0x9d, 0x95, 0xcb,
	0xa8, 0x59, 0xec, 0x18, 0xbe, 0xdd, 0xd4, 0xf4, 0xcd, 0xa1, 0x9b, 0xff, 0x88, 0x3c, 0x25, 0x90,
	0xd6, 0x6a, 0x56, 0xbb, 0x22, 0x50, 0xf0, 0x3a, 0x1c, 0xa9, 0x75, 0x2c, 0xdb, 0x68, 0x29, 0xfd,
	0x12, 0x1d, 0x1b, 0xe8, 0x09, 0xf9, 0x35, 0x61, 0x79, 0x44, 0x3e, 0xc4, 0xd1, 0xfd, 0xe5, 0x57,
	0x5e, 0x7b, 0xaf, 0x8b, 0x4e, 0x40, 0x12, 0x26, 0xaa, 0x2b, 0x95, 0x94, 0x47, 0x80, 0x78, 0x94,
	0x5a, 0xad, 0x17, 0x67, 0xe8, 0x16, 0xf5, 0x49, 0x38, 0x01, 0xb1, 0x32, 0x67, 0x60, 0xea, 0x06,
	0xd9, 0x4d, 0x8e, 0xfb, 0x64, 0x40, 0x6b, 0x17, 0x7b, 0xdc, 0xa3, 0xb5, 0x1e, 0x66, 0xe6, 0xfe,
	0x1c, 0xc1, 0x21, 0xdf, 0xe8, 0x1d, 0x4d, 0xfe, 0x03, 0xe4, 0x59, 0x5c, 0xc3, 0x2f, 0xcc, 0x5c,
	0x9e, 0x79, 0xf1, 0x8d, 0x07, 0xe8, 0x77, 0x50, 0xf2, 0x93, 0x74, 0x85, 0xf5, 0xd9, 0xd8, 0xb3,
	0x56, 0x9b, 0xd4, 0x66, 0x69, 0xb1, 0x35, 0x6b, 0x37, 0x2d, 0xc5, 0x3d, 0xee, 0xe1, 0x9f, 0x1e,
	0x15, 0xb1, 0x92, 0x2f, 0x39, 0x0e, 0x0d, 0x9d, 0xf4, 0x1c, 0xb1, 0x0f, 0xa5, 0x66, 0xb4, 0x5a,
	0x86, 0x2e, 0x8e, 0xcb, 0xf6, 0x12, 0xc8, 0xf7, 0x3b, 0xda, 0xdf, 0x05, 0x11, 0x8f, 0x6f, 0xee,
	0xae, 0xe3, 0xe9, 0xbf, 0x19, 0x04, 0x58, 0x34, 0x5a, 0xaa, 0xc6, 0x0d, 0xee, 0x8b, 0x10, 0x23,
	0x3b, 0x6a, 0xcd, 0x71, 0x54, 0xf8, 0xd4, 0xc0, 0x8e, 0x5f, 0x33, 0x66, 0x8e, 0xb2, 0xe3, 0xb7,
	0x2d, 0xba, 0x28, 0x02, 0x03, 0xe4, 0x46, 0xd1, 0x0b, 0x10, 0xb7, 0x3a, 0x8d, 0x86, 0xb6, 0xa3,
	0x78, 0xfd, 0xa1, 0xc1, 0x78, 0x31, 0x0e, 0xc9, 0x11, 0x2f, 0x41, 0xcc, 0x24, 0x9b, 0xc4, 0xc1,
	0xe3, 0x27, 0x3d, 0x53, 0x0e, 0x9e, 0xb8, 0x09, 0x14, 0x78, 0x97, 0x39, 0x43, 0xc0, 0x20, 0x19,
	0xde, 0x95, 0x2f, 0xa1, 0xf7, 0xba, 0x28, 0x01, 0x71, 0x18, 0xe5, 0x9d, 0xb7, 0x30, 0x5a, 0x78,
	0xd8, 0x45, 0x3f, 0x89, 0x60, 0x1d, 0x62, 0xbc, 0x28, 0xc5, 0x62, 0xc4, 0x4b, 0xb0, 0x08, 0x87,
	0x7c, 0x83, 0x9a, 0x0f, 0x17, 0xe8, 0x07, 0x1c, 0xf1, 0xf7, 0x79, 0x3e, 0x52, 0x61, 0x5f, 0x14,
	0xda, 0xd3, 0xa5, 0xf9, 0xb0, 0x4c, 0x3f, 0xe0, 0x32, 0xc4, 0x05, 0x59, 0xd6, 0x81, 0xf9, 0x33,
	0x3e, 0x9a, 0x7e, 0x52, 0x3e, 0x02, 0xb9, 0x34, 0x8c, 0xd7, 0x19, 0xa6, 0xa3, 0x63, 0x74, 0x67,
	0x45, 0xc2, 0x19, 0x0a, 0xb3, 0x23, 0x1d, 0xe1, 0x0e, 0x7d, 0x80, 0x00, 0x56, 0x16, 0x16, 0x89,
	0x65, 0x8b, 0xe8, 0x59, 0x94, 0xc7, 0xda, 0x88, 0x73, 0xa9, 0xe9, 0x2c, 0x63, 0xca, 0x9b, 0x68,
	0x34, 0x1d, 0x36, 0x83, 0xdf, 0xf6, 0xc4, 0x0b, 0x53, 0x03, 0x97, 0x44, 0x17, 0x1d, 0x17, 0x21,
	0xd6, 0x36, 0x4c, 0x5b, 0x31, 0x55, 0x7d, 0x93, 0x38, 0x97, 0x41, 0xce, 0x7c, 0xad, 0x8b, 0x46,
	0xcf, 0x9f, 0xbd, 0x74, 0xf1, 0xe2, 0x85, 0x8b, 0xae, 0x67, 0x15, 0xea, 0xcf, 0x01, 0xfc, 0x4a,
	0x80, 0xae, 0x54, 0x86, 0x69, 0xcb, 0x0c, 0xf7, 0xca, 0x4b, 0x0f, 0xbb, 0xe8, 0x13, 0x70, 0x1c,
	0x62, 0xc5, 0x72, 0xaa, 0x2c, 0xe8, 0xe7, 0xe2, 0xbd, 0xae, 0x4a, 0x61, 0x36, 0x33, 0x0d, 0xd3,
	0x4e, 0x71, 0x0c, 0x36, 0x33, 0x7b, 0x8d, 0xa7, 0xff, 0x4d, 0x08, 0xa6, 0xaa, 0x4d, 0x8b, 0x45,
	0xbe, 0x6a, 0x84, 0xcd, 0x47, 0x66, 0x85, 0x7e, 0x12, 0xe2, 0x82, 0x4f, 0x2d, 0xd5, 0xae, 0x6d,
	0x89, 0x60, 0x4a, 0xff, 0x2a, 0xda, 0xd3, 0x55, 0x39, 0xc6, 0xc1, 0xd9, 0x1d, 0x30, 0x5c, 0xec,
	0x0b, 0xe7, 0x09, 0xca, 0x07, 0xf8, 0x70, 0x53, 0xde, 0x70, 0x9e, 0x40, 0xc1, 0xd7, 0xfc, 0xf1,
	0x3c, 0x87, 0xd2, 0x70, 0x7f, 0x0e, 0x7b, 0xe2, 0x79, 0x02, 0xe3, 0xca, 0x3f, 0x09, 0x3c, 0xec,
	0xa2, 0xdf, 0x08, 0xc0, 0xff, 0xed, 0x57, 0xc9, 0x16, 0xdc, 0x81, 0xd3, 0x30, 0xed, 0x1d, 0xec,
	0xec, 0x00, 0xfd, 0x7c, 0x1a, 0x8e, 0xf9, 0x40, 0x06, 0x2a, 0x6b, 0x3f, 0x9d, 0x01, 0x9a, 0xab,
	0xf4, 0x69, 0xee, 0xda, 0xfe, 0x4d, 0x0f, 0x69, 0x71, 0xff, 0x76, 0x40, 0x86, 0xb8, 0x77, 0xd8,
	0x99, 0x1c, 0xbc, 0x0c, 0x4f, 0x0d, 0x16, 0x47, 0xcf, 0x2e, 0x3e, 0x39, 0x90, 0xc9, 0xae, 0x3d,
	0x7c, 0x06, 0x0e, 0x8b, 0x6a, 0x87, 0x8c, 0x27, 0x92, 0x10, 0x14, 0xc6, 0x71, 0xf0, 0xc2, 0xcc,
	0x02, 0x5f, 0xcc, 0xd2, 0x6f, 0x20, 0x38, 0xdc, 0xa7, 0x54, 0x2c, 0x30, 0xb8, 0x8b, 0x5f, 0x07,
	0xec, 0x6d, 0x41, 0x31, 0x3b, 0x4d, 0xe2, 0xe4, 0x23, 0xf4, 0x1f, 0xe1, 0x0d, 0x50, 0x4b, 0x8f,
	0xdd, 0x31, 0x78, 0x92, 0x4d, 0x6a, 0x7d, 0x18, 0x56, 0xfa, 0xf7, 0xc2, 0x7b, 0x34, 0x9c, 0x4d,
	0xe8, 0x1b, 0x70, 0x44, 0x0c, 0xaa, 0x61, 0x98, 0x8a, 0xda, 0x6c, 0x2a, 0x9c, 0xa7, 0xce, 0x76,
	0xb9, 0xaf, 0x96, 0x72, 0xac, 0x25, 0xc3, 0xcc, 0x36, 0x9b, 0xce, 0x7a, 0x77, 0x15, 0x22, 0x7c,
	0x27, 0x10, 0x13, 0xe5, 0x99, 0xe1, 0x63, 0xe1, 0xdc, 0x58, 0x1e, 0x91, 0x05, 0x16, 0x96, 0x01,
	0x8b, 0xbd, 0xdb, 0xb3, 0x47, 0x88, 0xe9, 0x72, 0x7a, 0x2f, 0xad, 0x3e, 0x3b, 0x6a, 0x19, 0xc9,
	0x93, 0x1c, 0xdd, 0xbb, 0x3f, 0x17, 0xe1, 0x90, 0x6b, 0x5f, 0x7a, 0xa9, 0x86, 0x86, 0xc6, 0x15,
	0xa6, 0x1c, 0x1c, 0x2f, 0xa9, 0xbd, 0x66, 0x7b, 0xe4, 0x23, 0x98, 0xed, 0x9f, 0x47, 0x68, 0x39,
	0xd0, 0x67, 0xb6, 0x2f, 0xc1, 0xd4, 0x00, 0xe3, 0x77, 0xa8, 0x01, 0x15, 0x90, 0x27, 0xb7, 0xfb,
	0x8d, 0x60, 0x66, 0x9d, 0xfc, 0x00, 0x7c, 0x0c, 0x9e, 0x59, 0x34, 0xee, 0xea, 0x96, 0x6d, 0x12,
	0xb5, 0xe5, 0x35, 0x52, 0x52, 0x79, 0x43, 0x6f, 0x68, 0x9b, 0x1d, 0x7e, 0x37, 0x14, 0xa3, 0x79,
	0x38, 0x0c, 0xd2, 0x7a, 0x5b, 0x00, 0xca, 0x86, 0x61, 0xa7, 0xf2, 0x59, 0x8c, 0x2e, 0xc2, 0x34,
	0x4c, 0x79, 0x05, 0x94, 0x12, 0xfa, 0x8a, 0x2e, 0xe7, 0xce, 0x42, 0xd2, 0xa7, 0xb2, 0x5c, 0x62,
	0xde, 0x19, 0x30, 0xf6, 0xa8, 0x8b, 0xa2, 0x74, 0x06, 0xbc, 0x38, 0x33, 0x97, 0x7b, 0x0e, 0xa6,
	0x2c, 0x6d, 0x53, 0x67, 0x56, 0x0c, 0x31, 0xed, 0xfd, 0x66, 0x4a, 0xee, 0x99, 0x41, 0xa6, 0x3b,
	0x85, 0x1a, 0x75, 0x4c, 0xf7, 0x17, 0x66, 0x2e, 0xf1, 0xa0, 0xae, 0x6b, 0x22, 0x50, 0x13, 0xfe,
	0x6f, 0x21, 0x98, 0x5c, 0x32, 0xd5, 0x1a, 0xbf, 0xeb, 0x5a, 0xa6, 0xfd, 0xd2, 0x6d, 0xfc, 0x3c,
	0x8c, 0xe9, 0x9d, 0x16, 0x31, 0x55, 0xdb, 0xe0, 0xb9, 0x06, 0xe3, 0xb9, 0xb1, 0xaf, 0x75, 0x11,
	0xba, 0x48, 0x37, 0x6f, 0xb9, 0x57, 0x87, 0x97, 0xa8, 0xe9, 0xa5, 0x1b, 0x2d, 0x4d, 0x67, 0xa0,
	0xfc, 0xe0, 0xa6, 0xff, 0x96, 0xe4, 0x62, 0x0f, 0x82, 0x5b, 0xc8, 0x8c, 0x8a, 0x17, 0x91, 0x65,
	0x22, 0xcc, 0xcd, 0xcc, 0xa7, 0xff, 0x39, 0x02, 0x29, 0xd7, 0x69, 0x34, 0x88, 0xc9, 0x39, 0xcd,
	0xa6, 0x56, 0x0a, 0xa2, 0x62, 0xa1, 0xe0, 0x59, 0x98, 0x51, 0x41, 0xc1, 0x2d, 0xc5, 0x9f, 0x84,
	0x49, 0xea, 0x05, 0x9b, 0xe4, 0xf5, 0x0e, 0xb1, 0x6c, 0x65, 0x63, 0xd7, 0x16, 0x1b, 0xe1, 0x78,
	0x4e, 0x72, 0xec, 0x0d, 0x16, 0xf3, 0xb9, 0x7f, 0x3f, 0x2c, 0x4f, 0xb4, 0xd4, 0x1d, 0x99, 0x43,
	0xe6, 0x28, 0x20, 0xce, 0x82, 0xe4, 0xc5, 0x66, 0x57, 0x6b, 0x83, 0x0c, 0xf9, 0xa8, 0x70, 0x99,
	0xdc, 0xd8, 0x6f, 0x26, 0x38, 0xfd, 0x7e, 0x88, 0x3a, 0x24, 0x3d, 0x1a, 0x55, 0xad, 0x45, 0x58,
	0x96, 0xca, 0xfc, 0xcc, 0x85, 0x99, 0xb9, 0xf4, 0x97, 0x43, 0x00, 0x79, 0xc3, 0xb4, 0x84, 0xc4,
	0x93, 0xfd, 0x7d, 0xf7, 0xf4, 0xba, 0x08, 0x71, 0xb5, 0xd9, 0x34, 0xee, 0x2a, 0x86, 0xa9, 0x6d,
	0x6a, 0xd4, 0x3d, 0xa4, 0x76, 0xc0, 0x73, 0x2c, 0x21, 0xea, 0xcd, 0xbe, 0x84, 0xa8, 0xc8, 0x9b,
	0x28, 0x28, 0xdd, 0xf7, 0xae, 0x4d, 0x31, 0x86, 0xbb, 0xc6, 0x50, 0xb1, 0x0e, 0xd8, 0x4b, 0x4a,
	0x61, 0x4b, 0x38, 0xf7, 0x19, 0x73, 0x2f, 0x7b, 0x0d, 0x8b, 0x33, 0x9c, 0xdc, 0xd8, 0x9b, 0x28,
	0x92, 0x0e, 0x99, 0x81, 0x14, 0xf2, 0x56, 0xbe, 0xeb, 0xb1, 0x3a, 0xbc, 0x37, 0xa9, 0x25, 0x4f,
	0x53, 0x6c, 0xdf, 0xc1, 0xe7, 0x60, 0x9c, 0xb7, 0xd7, 0x22, 0xf6, 0x96, 0x51, 0xb7, 0xc4, 0xc5,
	0x51, 0xe7, 0xd2, 0xc0, 0xb7, 0x43, 0x48, 0xe6, 0x63, 0x5b, 0xe5, 0xf5, 0xf8, 0x69, 0x07, 0xc1,
	0xc9, 0xfd, 0xe3, 0x5e, 0x10, 0x07, 0x72, 0xb2, 0xce, 0x9e, 0x85, 0x04, 0xd9, 0x69, 0x1b, 0x16,
	0x71, 0xa1, 0xf8, 0x1d, 0xe5, 0x71, 0x5e, 0xea, 0x80, 0xa5, 0xdd, 0x98, 0x87, 0xb8, 0x03, 0xea,
	0x49, 0x2f, 0x88, 0xf0, 0x70, 0x1e, 0x7e, 0x01, 0x62, 0x2d, 0x75, 0x47, 0x6b, 0x75, 0x5a, 0x0c,
	0x6e, 0x8c, 0x05, 0x02, 0x8f, 0xd0, 0xee, 0x4d, 0x26, 0x27, 0xa6, 0xef, 0xff, 0x42, 0xf8, 0xcc,
	0x77, 0x9c, 0xff, 0x90, 0x0c, 0x02, 0x94, 0x22, 0x7e, 0x1c, 0x26, 0x79, 0x47, 0x6b, 0x26, 0xa9,
	0x13, 0xdd, 0xd6, 0xd4, 0xa6, 0xc5, 0x6f, 0x92, 0x0a, 0x36, 0xe4, 0x7b, 0xe5, 0x57, 0x16, 0x3f,
	0xbc, 0x3a, 0x21, 0xb2, 0x76, 0x58, 0x8c, 0xed, 0xf2, 0xcc, 0xdc, 0x7b, 0x5d, 0x34, 0x0b, 0x33,
	0x70, 0x2c, 0xbf, 0x26, 0x57, 0xc4, 0xb4, 0xef, 0x5b, 0x35, 0xfa, 0x31, 0xd2, 0x5f, 0x0d, 0x00,
	0xe4, 0x2d, 0xb3, 0x21, 0x54, 0xe6, 0x15, 0x38, 0x46, 0xb7, 0x0f, 0xea, 0x8e, 0x28, 0x8e, 0x3f,
	0xe2, 0x6e, 0x26, 0x81, 0xa1, 0x9b, 0xc9, 0x11, 0xb5, 0xd9, 0x5c, 0x31, 0xd4, 0x7a, 0x4e, 0xa0,
	0x39, 0xfb, 0xc9, 0xaa, 0xbb, 0x1f, 0x88, 0x8d, 0x9e, 0x85, 0x6a, 0x82, 0x03, 0xfd, 0x38, 0x8e,
	0x53, 0x52, 0x5b, 0x44, 0x84, 0x37, 0x24, 0x8e, 0xca, 0xcb, 0x59, 0xd8, 0xe7, 0xff, 0xf2, 0x28,
	0xf5, 0x90, 0xe5, 0x3f, 0x77, 0xed, 0x9d, 0x07, 0x28, 0x9f, 0x4c, 0xef, 0xe3, 0x5d, 0xd5, 0x2c,
	0xb3, 0x21, 0x96, 0xbf, 0xe4, 0xc9, 0xbd, 0x3e, 0x94, 0xa7, 0x7a, 0xd9, 0x33, 0xd7, 0x73, 0xc7,
	0x61, 0x82, 0xc9, 0x81, 0xd4, 0x1d, 0xa6, 0xb8, 0xe7, 0x3f, 0x88, 0x27, 0x5a, 0xa4, 0x7f, 0x1b,
	0xc1, 0x44, 0x59, 0xb5, 0xb7, 0xbc, 0x2f, 0x08, 0x3c, 0x0f, 0x11, 0x6e, 0xc5, 0x0a, 0xbf, 0x67,
	0x5c, 0xf8, 0xff, 0xd3, 0xf7, 0x03, 0xdf, 0x0c, 0x20, 0xb6, 0x77, 0xb2, 0x6a, 0xfc, 0x34, 0x84,
	0xda, 0xaa, 0xbd, 0x25, 0xec, 0xe8, 0x3d, 0x60, 0xac, 0x12, 0x5f, 0x84, 0xb0, 0x33, 0xc5, 0x28,
	0xd4, 0x49, 0xe7, 0xfe, 0x10, 0x9f, 0x5d, 0xee, 0xc4, 0xe2, 0x73, 0x6a, 0x79, 0x44, 0xe6, 0xd0,
	0x57, 0x42, 0x1f, 0x5e, 0x45, 0x0b, 0xb9, 0xa7, 0x00, 0x28, 0x11, 0x6e, 0x6d, 0xed, 0xef, 0x31,
	0xfc, 0x3b, 0x3a, 0x0a, 0xc3, 0xb4, 0xbd, 0xa3, 0x38, 0x0d, 0x21, 0x6a, 0x6e, 0x8b, 0x35, 0x39,
	0xc6, 0x56, 0x86, 0x4c, 0x68, 0xfa, 0x3b, 0xdf, 0x09, 0xb2, 0xae, 0x19, 0xa6, 0x8d, 0x5f, 0x1a,
	0xe4, 0x0e, 0x9c, 0x10, 0xdd, 0x9a, 0x4e, 0xf5, 0xbb, 0x00, 0x5f, 0xe6, 0xee, 0x57, 0xcf, 0x09,
	0xc0, 0x57, 0x60, 0x5c, 0x37, 0x14, 0x46, 0x83, 0x1b, 0xeb, 0x07, 0x1c, 0x76, 0xe8, 0x86, 0xdb,
	0x4b, 0x36, 0xc0, 0x0b, 0x6c, 0x80, 0x2e, 0x3a, 0x1b, 0x60, 0x48, 0x1c, 0x2e, 0x87, 0x17, 0x66,
	0xe6, 0x66, 0xe6, 0xb9, 0xab, 0x9a, 0x7e, 0x1c, 0x84, 0x49, 0xe7, 0x98, 0xae, 0x37, 0xc4, 0x39,
	0xdf, 0xb1, 0x90, 0xc3, 0xd9, 0xaf, 0x20, 0x34, 0x80, 0xc7, 0xee, 0x05, 0xa6, 0x30, 0x33, 0x74,
	0xc5, 0x60, 0x0f, 0xf9, 0x21, 0xc3, 0x66, 0xf0, 0x7d, 0x2e, 0x04, 0x06, 0x84, 0x2f, 0xf9, 0x65,
	0x77, 0x6a, 0x10, 0xf4, 0x00, 0xe1, 0xe1, 0x13, 0xcc, 0x0f, 0xb2, 0x88, 0x2e, 0xee, 0x27, 0x45,
	0xa9, 0x5a, 0x3a, 0x25, 0xf8, 0x34, 0xc4, 0x35, 0x9d, 0xba, 0xf1, 0x82, 0x69, 0x61, 0xb6, 0x64,
	0xc4, 0x78, 0x19, 0x67, 0xce, 0xbf, 0xa0, 0x7e, 0x6d, 0x12, 0xa6, 0x61, 0x82, 0x8f, 0x3a, 0x65,
	0x1b, 0x29, 0xee, 0xe0, 0x84, 0xe7, 0x66, 0x2e, 0xcd, 0x5c, 0x7c, 0xd8, 0x45, 0x3f, 0x8f, 0xf6,
	0x04, 0xe7, 0x97, 0x00, 0x18, 0x10, 0xf7, 0x2f, 0x2e, 0xc3, 0x25, 0x48, 0x88, 0xe1, 0x3a, 0xce,
	0x44, 0x42, 0x0c, 0xc8, 0x71, 0x0a, 0x0e, 0xf5, 0x3a, 0x3a, 0x1f, 0x2d, 0x8b, 0xbf, 0xe0, 0x79,
	0x88, 0x71, 0x3a, 0xdc, 0x53, 0x98, 0x16, 0x44, 0x04, 0x6e, 0x0f, 0x05, 0x4e, 0x51, 0x93, 0x9f,
	0xf6, 0x9a, 0x77, 0x2e, 0x99, 0xf0, 0x8f, 0x2c, 0x97, 0x82, 0x18, 0x3f, 0xff, 0xeb, 0x89, 0x37,
	0xe0, 0x04, 0x55, 0xd8, 0xd2, 0xe6, 0x9e, 0x20, 0x47, 0xa4, 0xd1, 0xf4, 0x7b, 0x01, 0x38, 0xd6,
	0x4b, 0x77, 0x25, 0xb6, 0x5f, 0xd8, 0xcf, 0x7a, 0xf2, 0x5e, 0xf9, 0x15, 0xb5, 0x7e, 0x09, 0xb3,
	0x2c, 0xcc, 0x23, 0x3e, 0x01, 0xf7, 0x44, 0xf9, 0x5d, 0x4e, 0xc3, 0xcf, 0x51, 0x41, 0x9c, 0x86,
	0xa7, 0x60, 0xba, 0x3f, 0xa5, 0xb8, 0xea, 0x48, 0x24, 0x38, 0x37, 0xb3, 0xf0, 0xb0, 0x8b, 0x14,
	0x88, 0x43, 0xf0, 0x06, 0xd9, 0x4d, 0x86, 0x59, 0x47, 0xe1, 0xbc, 0x4f, 0x18, 0x69, 0x48, 0x1d,
	0x28, 0x8c, 0x93, 0x7e, 0xb6, 0x27, 0xfc, 0x6c, 0xcf, 0x9d, 0xf2, 0x33, 0xb3, 0xef, 0x2c, 0xd5,
	0x59, 0x0a, 0xbe, 0x1a, 0x06, 0x90, 0x8d, 0x8e, 0x4d, 0x78, 0xe7, 0x2e, 0x8b, 0x25, 0x8a, 0x3b,
	0x07, 0xfd, 0xe6, 0x56, 0xdf, 0xca, 0x97, 0x0b, 0x7d, 0xab, 0x8b, 0x90, 0x58, 0xb7, 0xca, 0xbd,
	0xe4, 0xfb, 0x00, 0xf3, 0x92, 0xfa, 0x9f, 0x5e, 0xd8, 0x33, 0x1f, 0xc5, 0x6c, 0xea, 0x37, 0x09,
	0x1c, 0x32, 0x58, 0xed, 0x4b, 0x06, 0xe7, 0xd7, 0x4a, 0xcf, 0xf4, 0x91, 0xdd, 0x57, 0x03, 0xf6,
	0x21, 0xef, 0x4d, 0x98, 0xc6, 0x57, 0x20, 0xc6, 0xb6, 0x10, 0x6e, 0x6b, 0xb0, 0xb9, 0x97, 0xd8,
	0x13, 0x3b, 0x58, 0xb6, 0xed, 0x36, 0x37, 0x36, 0x64, 0xd8, 0x72, 0xff, 0xc6, 0x45, 0x18, 0xd7,
	0xf4, 0x1a, 0xb5, 0x33, 0x37, 0xd9, 0x92, 0x26, 0x4e, 0x5f, 0xf7, 0xf0, 0xcc, 0xbf, 0xce, 0x0a,
	0x9e, 0xc5, 0x1d, 0x54, 0x5a, 0x7d, 0xe5, 0x77, 0x03, 0x1f, 0x5e, 0x1d, 0xa3, 0xeb, 0xd7, 0x85,
	0x99, 0xf9, 0x99, 0x8b, 0x4e, 0x18, 0x93, 0x0b, 0xd7, 0x7d, 0x61, 0x06, 0x8f, 0x0a, 0x88, 0x87,
	0x5d, 0xf4, 0xc5, 0x00, 0x1c, 0x83, 0x08, 0xef, 0x48, 0x72, 0xc2, 0x37, 0x88, 0x14, 0x82, 0x35,
	0x18, 0xa3, 0x92, 0xe2, 0x9a, 0x44, 0xdd, 0xea, 0xc3, 0x10, 0xa3, 0x32, 0x9a, 0xe5, 0xfb, 0xd0,
	0x7c, 0x84, 0x07, 0x60, 0x00, 0xc3, 0x18, 0x2f, 0x56, 0xed, 0x2d, 0x47, 0xc9, 0xa6, 0xf8, 0x0e,
	0x32, 0xeb, 0xd3, 0xb4, 0x79, 0x00, 0x46, 0x90, 0x2b, 0xda, 0x33, 0x3e, 0x6a, 0x1e, 0x1a, 0x5e,
	0x54, 0x78, 0x09, 0x26, 0x3d, 0x53, 0x80, 0xeb, 0x7e, 0x3a, 0xe3, 0x17, 0x29, 0x06, 0xc7, 0x7e,
	0x21, 0xf5, 0x64, 0xa2, 0x44, 0x7d, 0x1c, 0xf7, 0x1b, 0x2e, 0x3a, 0xf7, 0x14, 0x04, 0xee, 0xb3,
	0xae, 0x82, 0x0d, 0x43, 0x4b, 0xbf, 0x0e, 0x38, 0xdb, 0x6e, 0x2f, 0x69, 0x26, 0xb9, 0xab, 0x36,
	0x9b, 0x4e, 0x7e, 0xcf, 0x67, 0x20, 0xae, 0xb6, 0xdb, 0x4a, 0x43, 0x14, 0x3f, 0x69, 0xe2, 0x9a,
	0x0f, 0xc9, 0x31, 0x96, 0x33, 0x68, 0x4e, 0x8e, 0xa9, 0xbd, 0x36, 0xd2, 0x9f, 0x0b, 0xc0, 0xe8,
	0x2d, 0x95, 0x37, 0xb4, 0xd4, 0xd7, 0x50, 0x68, 0xa0, 0x67, 0xbc, 0xb7, 0x87, 0x74, 0xbb, 0xf3,
	0xd0, 0xa4, 0x56, 0xa6, 0x13, 0xc2, 0xb8, 0xab, 0x36, 0x0e, 0x38, 0xd9, 0x07, 0x01, 0x7a, 0x4b,
	0x6d, 0xe0, 0x1b, 0x10, 0xd3, 0xf4, 0x2d, 0x62, 0x6a, 0x36, 0x43, 0x1c, 0x92, 0x97, 0x96, 0xc3,
	0xef, 0x3c, 0x40, 0x89, 0x5e, 0xd6, 0x0c, 0x35, 0x90, 0x28, 0x31, 0x81, 0x7e, 0x4b, 0x6d, 0xe4,
	0x4e, 0x42, 0xd4, 0x24, 0x0d, 0x96, 0x3a, 0xc7, 0x56, 0x63, 0x27, 0x93, 0x2b, 0x7c, 0x69, 0xe6,
	0x22, 0x5b, 0x8d, 0xfb, 0x92, 0x4f, 0xd3, 0x4d, 0x98, 0xca, 0xb6, 0xdb, 0xb2, 0xd1, 0x24, 0xd9,
	0x8e, 0xbd, 0xe5, 0x66, 0x7b, 0x1f, 0x85, 0x51, 0xd3, 0x68, 0x12, 0xc5, 0xbd, 0xec, 0x16, 0xa1,
	0x9f, 0x45, 0xea, 0x5e, 0x8d, 0x39, 0x89, 0xae, 0x4f, 0x7e, 0x0d, 0x88, 0x63, 0x14, 0xeb, 0xe9,
	0x7f, 0x8c, 0x60, 0x92, 0xe5, 0xe0, 0xfa, 0x1a, 0x5b, 0x86, 0x71, 0x2a, 0x02, 0xd6, 0xa0, 0xda,
	0x71, 0x17, 0xb3, 0xf4, 0x5e, 0x19, 0xf4, 0xf7, 0x53, 0x08, 0xc1, 0x29, 0xc6, 0x2f, 0x40, 0xd8,
	0x36, 0xee, 0x10, 0xfd, 0x09, 0x7b, 0x46, 0xb7, 0x01, 0x06, 0x9f, 0x3b, 0x0a, 0x31, 0xda, 0xb2,
	0xa3, 0xe6, 0x51, 0x61, 0x88, 0x39, 0x5c, 0x7a, 0x2b, 0x00, 0x92, 0x4c, 0x2c, 0x7f, 0xb7, 0x73,
	0x00, 0x1b, 0xaa, 0xa5, 0xd5, 0xbc, 0x7d, 0x3e, 0xbd, 0xdf, 0xcd, 0x17, 0xf7, 0x8e, 0xd5, 0xf2,
	0x88, 0x3c, 0xb6, 0xe1, 0x5e, 0xb8, 0xba, 0x0e, 0x71, 0x31, 0x47, 0x38, 0x95, 0xc0, 0xc0, 0x5b,
	0x75, 0xfd, 0xd7, 0xa0, 0x7a, 0x79, 0x43, 0x02, 0x99, 0xd1, 0xba, 0x05, 0x93, 0xde, 0xb9, 0xca,
	0x09, 0x72, 0xc3, 0xfe, 0xe9, 0x27, 0xb8, 0x90, 0xe3, 0x12, 0x9d, 0xf0, 0x2c, 0xb8, 0x14, 0x70,
	0x3f, 0xe6, 0x38, 0x29, 0x56, 0x7f, 0xe2, 0x5c, 0xc6, 0xc8, 0xb2, 0xc7, 0xaf, 0x5c, 0xfe, 0x9c,
	0x04, 0xe0, 0xc9, 0xd8, 0x6a, 0xbd, 0xee, 0x5c, 0x53, 0x18, 0x63, 0x25, 0xd9, 0x7a, 0xdd, 0xc4,
	0x29, 0x88, 0xf3, 0x6a, 0x11, 0xf7, 0xe1, 0x17, 0x30, 0x38, 0x0a, 0x8f, 0xe4, 0xec, 0xd1, 0x8b,
	0xe0, 0xf7, 0xac, 0x17, 0xa1, 0x8f, 0xa8, 0x17, 0x09, 0x88, 0xd3, 0x96, 0x9d, 0x98, 0x7e, 0xfa,
	0x47, 0x03, 0x30, 0xe1, 0xb9, 0x5d, 0x20, 0x4e, 0x9e, 0x45, 0xd2, 0xb9, 0xca, 0xc6, 0xcf, 0xf3,
	0xfc, 0xd1, 0xfe, 0x17, 0x13, 0xfc, 0x6c, 0x72, 0x6f, 0x23, 0xf4, 0x8a, 0xf1, 0xb3, 0x30, 0xee,
	0x5c, 0xe7, 0xe0, 0xef, 0x6f, 0x39, 0xb6, 0x4e, 0xdc, 0x29, 0xa6, 0x66, 0x21, 0x7e, 0x0a, 0x44,
	0xde, 0x98, 0xc2, 0x4c, 0x00, 0x7e, 0x55, 0x05, 0x78, 0x11, 0x5d, 0xfe, 0xf1, 0x73, 0xee, 0xbd,
	0x14, 0xab, 0xb3, 0xc1, 0x81, 0x42, 0xe2, 0x12, 0x0e, 0x2b, 0xae, 0x74, 0x36, 0x18, 0xdc, 0xb3,
	0x90, 0x70, 0x92, 0xbe, 0xc4, 0x05, 0x97, 0xb0, 0x17, 0x4c, 0x3c, 0x6b, 0x93, 0x9b, 0x80, 0x71,
	0x31, 0x44, 0xc1, 0x8d, 0xaf, 0x21, 0xc0, 0xce, 0xe9, 0xf1, 0x93, 0xdc, 0x03, 0x41, 0xdf, 0x8f,
	0x7b, 0x20, 0xe5, 0x41, 0xf7, 0x40, 0x02, 0x1f, 0x99, 0xdd, 0x3d, 0x8a, 0xb9, 0x43, 0x20, 0x6e,
	0x22, 0xb0, 0x75, 0xd3, 0x19, 0xdc, 0xfd, 0x00, 0x8c, 0xd3, 0xcd, 0x9e, 0xed, 0xa1, 0x22, 0x4b,
	0x2d, 0xc8, 0xb7, 0xa2, 0x61, 0x4b, 0x3b, 0x05, 0xc1, 0xf3, 0x10, 0xef, 0x58, 0xd4, 0x55, 0x27,
	0x0d, 0x4d, 0x27, 0x75, 0x11, 0x7f, 0xe2, 0x0e, 0x64, 0x26, 0x42, 0x7d, 0xb4, 0x33, 0x6c, 0xfa,
	0x52, 0xa0, 0x45, 0x0e, 0x43, 0xa9, 0xd7, 0x75, 0xeb, 0x80, 0x83, 0x0c, 0x0a, 0x72, 0xe5, 0x53,
	0x0f, 0xbb, 0xe8, 0x45, 0x78, 0x01, 0x42, 0xb4, 0x7b, 0x99, 0x73, 0x70, 0x16, 0x80, 0xf5, 0x6c,
	0x3e, 0x98, 0xd5, 0x77, 0x21, 0xe1, 0x6f, 0x1b, 0x26, 0x18, 0xdd, 0xf9, 0xe8, 0x62, 0xa9, 0x92,
	0x3a, 0x73, 0xf1, 0xc2, 0xc7, 0x72, 0x69, 0x38, 0xc2, 0x5c, 0x32, 0x6e, 0x6c, 0x7a, 0x86, 0xbc,
	0x67, 0x66, 0xbf, 0x0e, 0xc7, 0xfd, 0x99, 0xd6, 0x32, 0x69, 0x10, 0x93, 0x7a, 0x06, 0x8c, 0x1f,
	0xb2, 0xc8, 0x63, 0xfe, 0xfe, 0xdc, 0x50, 0x60, 0xb4, 0xe8, 0x62, 0x92, 0xf4, 0xb7, 0xe9, 0x7b,
	0x56, 0xf0, 0x22, 0x00, 0x4f, 0x2a, 0x32, 0x6a, 0xea, 0x41, 0x92, 0x18, 0x63, 0x69, 0x77, 0x14,
	0x10, 0xe7, 0x60, 0xb2, 0x87, 0xa6, 0x68, 0xba, 0xa5, 0xd5, 0xc9, 0x01, 0xf1, 0x93, 0x09, 0x17,
	0xbb, 0xc8, 0xc0, 0xf1, 0x2c, 0x44, 0xd8, 0xcb, 0x63, 0xb5, 0x03, 0x9c, 0x60, 0x01, 0x95, 0x4b,
	0x42, 0x62, 0x5b, 0x1f, 0xc8, 0xde, 0xb0, 0x9b, 0x33, 0x11, 0x97, 0x89, 0x6d, 0xee, 0xe6, 0xd4,
	0xda, 0x9d, 0xb5, 0x46, 0x03, 0x5f, 0x82, 0xf1, 0x0d, 0xd5, 0x12, 0x27, 0x25, 0xdb, 0x62, 0x7c,
	0xe3, 0xec, 0x0a, 0x5b, 0x60, 0xfe, 0xa2, 0x13, 0x78, 0x0c, 0x64, 0x46, 0xe4, 0x38, 0x85, 0x2b,
	0x0a, 0x30, 0xfc, 0x3c, 0xc4, 0x5b, 0xea, 0x4e, 0x0f, 0x8d, 0x6b, 0x9b, 0x08, 0xad, 0xb6, 0xd4,
	0x1d, 0x07, 0xd0, 0x0d, 0xad, 0xfe, 0x51, 0x08, 0x26, 0x58, 0xcb, 0x3c, 0xcc, 0xc4, 0x38, 0xfb,
	0x63, 0x88, 0x9a, 0x0e, 0xb6, 0xb9, 0xab, 0xb8, 0xaf, 0x5b, 0x99, 0x7d, 0x21, 0xcf, 0xd7, 0xcc,
	0x1f, 0x94, 0x47, 0xe4, 0xe0, 0xc5, 0x9d, 0x1d, 0x79, 0x7c, 0x53, 0xb5, 0xc9, 0x5d, 0x75, 0xf7,
	0x2c, 0x7b, 0x2b, 0x53, 0x9e, 0xa8, 0x19, 0xba, 0x4e, 0x6a, 0xf6, 0xd9, 0x86, 0xaa, 0x35, 0x3b,
	0x26, 0x91, 0x13, 0x26, 0x69, 0x74, 0x2c, 0x52, 0x3f, 0xcb, 0xe3, 0xe1, 0xf2, 0x38, 0x25, 0xad,
	0x51, 0x93, 0xe7, 0xec, 0xc2, 0xce, 0x8e, 0x7c, 0xa4, 0xf7, 0xc9, 0x9f, 0x96, 0x3b, 0x5b, 0x33,
	0xea, 0xc4, 0xa2, 0xce, 0x04, 0xeb, 0xc3, 0x9a, 0x8e, 0xbb, 0x08, 0x26, 0x78, 0x7f, 0x6a, 0x8e,
	0x41, 0x3d, 0x1d, 0x61, 0x41, 0xcc, 0x9f, 0x74, 0x3b, 0xf4, 0x43, 0x6f, 0xa2, 0xcd, 0x34, 0x31,
	0x6b, 0x7f, 0x99, 0x7d, 0xa2, 0x8e, 0xa2, 0xf7, 0x0e, 0xc4, 0xe8, 0xe0, 0xac, 0x14, 0xd6, 0xd5,
	0x9e, 0xe9, 0x7f, 0x01, 0x62, 0x7a, 0xa7, 0xa5, 0x30, 0x92, 0x6e, 0xfc, 0x19, 0x7f, 0xad, 0x8b,
	0xd0, 0x9c, 0xd3, 0xf9, 0x50, 0x26, 0x30, 0x1d, 0x95, 0x41, 0xef, 0xb4, 0x64, 0x0e, 0x85, 0x5f,
	0x80, 0x89, 0x36, 0x31, 0x15, 0x3a, 0x66, 0x5b, 0x6b, 0x11, 0xa3, 0x63, 0x8b, 0xd8, 0xf3, 0x84,
	0x83, 0x13, 0xc9, 0x84, 0xa6, 0xdf, 0xfd, 0xfd, 0x67, 0xe4, 0xf1, 0x36, 0x31, 0xab, 0xe6, 0x6e,
	0x95, 0x43, 0xe1, 0x12, 0xf4, 0x3a, 0xaf, 0x88, 0x17, 0xfc, 0x38, 0x43, 0x43, 0xa9, 0xe0, 0x99,
	0xf1, 0xdc, 0xb4, 0x1b, 0xb4, 0xee, 0x77, 0xae, 0x0e, 0xb9, 0x78, 0xfc, 0xa1, 0xbd, 0x3c, 0xc5,
	0xc2, 0x97, 0x20, 0xba, 0xa1, 0xd6, 0xee, 0x28, 0x46, 0xc3, 0x31, 0x64, 0xfb, 0xb3, 0xb2, 0xbd,
	0x7a, 0x2b, 0x8f, 0x6e, 0xf0, 0x3f, 0xae, 0x24, 0x3e, 0xbc, 0x1a, 0x9b, 0x9b, 0xb9, 0xe4, 0xde,
	0x5e, 0xbc, 0x07, 0xb1, 0x55, 0x4a, 0xbf, 0xc6, 0x93, 0x00, 0x4e, 0xc0, 0x58, 0xef, 0x21, 0x02,
	0xaa, 0x62, 0x48, 0xee, 0x15, 0x0c, 0xbe, 0xc4, 0x4e, 0x1d, 0x3e, 0xdb, 0x24, 0x7a, 0xdd, 0x93,
	0x38, 0xb0, 0x77, 0xff, 0xae, 0x52, 0x08, 0xd6, 0x86, 0x0c, 0xb6, 0xfb, 0x77, 0xfa, 0x3d, 0x04,
	0x09, 0xde, 0x3e, 0xd5, 0xf0, 0x45, 0xd5, 0x56, 0x71, 0xd6, 0xbd, 0xa6, 0x8f, 0x06, 0x3e, 0xc8,
	0xe7, 0x07, 0xf7, 0xde, 0xce, 0x77, 0xdf, 0x37, 0x9a, 0x87, 0x08, 0xeb, 0x8b, 0xe3, 0x36, 0x27,
	0x07, 0x92, 0xe0, 0xbd, 0x11, 0x90, 0xdf, 0xcb, 0x73, 0x14, 0x5f, 0x42, 0x00, 0xbd, 0xf1, 0xf5,
	0x00, 0x91, 0x97, 0x4b, 0x9f, 0xa0, 0x56, 0xb9, 0x4e, 0x79, 0xa9, 0xdb, 0xe2, 0xe4, 0xe5, 0xe4,
	0x20, 0x1e, 0x55, 0x1c, 0x20, 0xb9, 0x07, 0xdf, 0x9f, 0x93, 0x14, 0xdc, 0x9b, 0x93, 0xf4, 0x2c,
	0x24, 0xda, 0x26, 0xd9, 0xd6, 0x8c, 0x8e, 0x25, 0xe4, 0x20, 0xcc, 0x08, 0xa7, 0x94, 0xf3, 0xfb,
	0x8f, 0x11, 0xc4, 0x4a, 0x64, 0xc7, 0x5e, 0x36, 0xda, 0xe2, 0xce, 0x70, 0xef, 0x75, 0xd5, 0xc4,
	0x1e, 0x15, 0xf2, 0x40, 0x5a, 0xe2, 0x61, 0xd5, 0x1b, 0x30, 0xa1, 0x93, 0x1d, 0x7b, 0xcb, 0x68,
	0x33, 0x9b, 0x91, 0x58, 0x4e, 0x90, 0xbb, 0x7f, 0x6f, 0x29, 0xb6, 0xb3, 0xbc, 0xde, 0xe3, 0xa1,
	0x27, 0x04, 0xaa, 0xa8, 0xc1, 0x9f, 0x86, 0x31, 0xb6, 0x22, 0x36, 0xd4, 0x1a, 0x11, 0xa1, 0x88,
	0xe1, 0x5b, 0xd4, 0xa9, 0x77, 0xee, 0x4d, 0x3a, 0x77, 0x8f, 0x5c, 0x4c, 0xef, 0xd3, 0x2a, 0x6e,
	0x61, 0xfa, 0xab, 0x21, 0x98, 0xa0, 0x13, 0x46, 0xab, 0xb1, 0x50, 0x0c, 0x1b, 0xed, 0x55, 0x08,
	0xab, 0xb6, 0x6d, 0xee, 0x97, 0xe5, 0xc6, 0x00, 0xb3, 0xb6, 0xcd, 0x83, 0x0a, 0xd0, 0xcb, 0x72,
	0x93, 0x39, 0x1a, 0xce, 0xc1, 0xa8, 0xd5, 0xd9, 0xd0, 0x89, 0xed, 0x28, 0xd6, 0xf1, 0x3d, 0x83,
	0xae, 0xb0, 0x7a, 0x46, 0x20, 0xd6, 0x3b, 0x09, 0x0a, 0xc8, 0x0e, 0x22, 0x5e, 0x80, 0x51, 0xc1,
	0x05, 0x91, 0xa7, 0x9d, 0xdc, 0x9f, 0xe9, 0xb2, 0x03, 0xea, 0x79, 0x85, 0x25, 0xc6, 0x1a, 0xce,
	0x0c, 0x78, 0x83, 0xd3, 0x33, 0x52, 0xdf, 0x9b, 0x15, 0x53, 0x6f, 0x3d, 0x40, 0x21, 0x08, 0x78,
	0xaf, 0xd3, 0x7f, 0x5f, 0x1e, 0xae, 0xf8, 0x33, 0xf4, 0xe1, 0xd5, 0xb1, 0xf9, 0x19, 0x96, 0xd9,
	0x3a, 0x33, 0xf7, 0xb0, 0x8b, 0xbe, 0x8e, 0xe0, 0x08, 0x8c, 0x72, 0x0e, 0x58, 0xb9, 0x98, 0xcb,
	0x2c, 0x29, 0x04, 0x4d, 0x88, 0xd2, 0x71, 0xa5, 0x96, 0x8d, 0x76, 0xe6, 0x35, 0xf8, 0x41, 0x78,
	0x1a, 0x4e, 0x8b, 0xa1, 0xcd, 0xf6, 0xa9, 0xd3, 0xac, 0xd6, 0xde, 0x5e, 0x98, 0xa5, 0x1f, 0x07,
	0x00, 0x5d, 0xe2, 0x40, 0x18, 0xe2, 0x0e, 0x10, 0x53, 0xd0, 0x40, 0x0a, 0x41, 0x1a, 0xc6, 0x8a,
	0x8e, 0x22, 0xe4, 0x0e, 0xc3, 0xa4, 0x03, 0xe0, 0x6a, 0x87, 0x84, 0xe0, 0x18, 0x00, 0x15, 0xb5,
	0xb6, 0xd1, 0xb1, 0x09, 0xed, 0x2c, 0x17, 0xb1, 0x14, 0x3a, 0x8f, 0xe0, 0x10, 0x44, 0x38, 0x4f,
	0xae, 0x83, 0xc3, 0x76, 0x29, 0x94, 0x7e, 0x1c, 0x82, 0x23, 0x4b, 0x86, 0x79, 0x57, 0x35, 0xeb,
	0x65, 0xd3, 0xd8, 0xd9, 0xf5, 0x1c, 0x79, 0x7e, 0x06, 0x0e, 0xdf, 0xdd, 0x62, 0xc6, 0x8b, 0xc6,
	0xce, 0x74, 0xfb, 0x72, 0x85, 0x9e, 0x77, 0x93, 0xa8, 0x06, 0xe4, 0x0b, 0xbd, 0xec, 0x59, 0xea,
	0xa7, 0x18, 0x95, 0x15, 0x46, 0xc4, 0x49, 0xe8, 0xc1, 0xcb, 0x80, 0xfd, 0xc4, 0x0d, 0x53, 0xe8,
	0xdf, 0x78, 0x2e, 0xd9, 0x7b, 0x5a, 0x99, 0x9f, 0x2b, 0xf4, 0xc8, 0xca, 0x92, 0x97, 0x18, 0xc5,
	0xc1, 0x2f, 0xc3, 0x21, 0x6a, 0x84, 0x88, 0x4d, 0x57, 0x51, 0x6d, 0x9b, 0xb4, 0xda, 0xb6, 0x25,
	0x76, 0xb0, 0x04, 0xdb, 0xfa, 0x7a, 0xdb, 0x1e, 0x6e, 0xa9, 0x3b, 0x79, 0x0e, 0x9a, 0x15, 0x90,
	0x38, 0x07, 0x58, 0x60, 0x3b, 0x4f, 0xd6, 0xd0, 0x1d, 0x90, 0x5d, 0xb5, 0xcf, 0x4d, 0x7d, 0xad,
	0x8b, 0x42, 0xf3, 0xe7, 0xcf, 0x9f, 0xf7, 0xee, 0x82, 0x93, 0x3d, 0x70, 0x67, 0x27, 0x7c, 0x09,
	0x26, 0x74, 0xc3, 0x9f, 0xcf, 0x33, 0xfc, 0xa2, 0x5f, 0x42, 0x37, 0x7c, 0x49, 0x41, 0x6b, 0x30,
	0x6e, 0x37, 0xad, 0x1e, 0x05, 0x91, 0x37, 0x70, 0x40, 0x06, 0x89, 0xcf, 0x75, 0x8c, 0xdb, 0x9e,
	0xca, 0x2b, 0x95, 0xf7, 0xba, 0x68, 0x0d, 0x4e, 0xc0, 0xe1, 0xca, 0x1d, 0xad, 0x9d, 0x72, 0x6e,
	0xb3, 0xa5, 0xda, 0xaa, 0x69, 0x69, 0xfa, 0x26, 0xa6, 0xf6, 0x18, 0x9c, 0x83, 0x33, 0x4b, 0xdc,
	0x48, 0x49, 0x6d, 0xa9, 0x7a, 0xbd, 0xa9, 0xe9, 0x9b, 0xec, 0x91, 0x89, 0x8e, 0x93, 0x4e, 0xd0,
	0x1b, 0x28, 0x66, 0x47, 0xfc, 0xb3, 0x70, 0xd4, 0xd7, 0x4b, 0xca, 0xb0, 0xc1, 0x39, 0xba, 0x2f,
	0x7c, 0xab, 0xeb, 0xe6, 0xe8, 0xbe, 0x81, 0x20, 0xb1, 0x6c, 0x58, 0x76, 0x91, 0x1d, 0x5a, 0x36,
	0x34, 0x62, 0xe2, 0xa7, 0x20, 0xa0, 0xb5, 0x9d, 0x63, 0x30, 0xd7, 0x32, 0x31, 0x03, 0x6d, 0x3a,
	0x90, 0x80, 0xd6, 0xc6, 0x17, 0x3d, 0xaf, 0x44, 0xf3, 0x23, 0x95, 0xa3, 0xfe, 0x2b, 0x52, 0x02,
	0x81, 0xa5, 0xfc, 0xb9, 0xa0, 0xd4, 0xf8, 0x75, 0xf3, 0x9e, 0x0d, 0x53, 0xd1, 0xda, 0x7b, 0x7c,
	0x8b, 0x2f, 0x20, 0x91, 0x17, 0x41, 0xa7, 0x8c, 0xa7, 0x47, 0x73, 0x10, 0x55, 0xf5, 0x5d, 0x3a,
	0xb4, 0xc6, 0x01, 0xf6, 0xfd, 0xa8, 0xaa, 0xef, 0x16, 0x75, 0xbb, 0x81, 0x9f, 0x83, 0x10, 0x03,
	0xe7, 0xfd, 0xeb, 0x9d, 0xf2, 0x8b, 0x33, 0xf3, 0xe5, 0x11, 0x99, 0xd5, 0xe7, 0x4e, 0x80, 0xe4,
	0x4e, 0xd2, 0xfd, 0x5c, 0x9e, 0xbf, 0x40, 0x80, 0xdd, 0x6e, 0xad, 0x99, 0xce, 0xa5, 0x3d, 0xa7,
	0x09, 0x34, 0xbc, 0x09, 0xfc, 0x0c, 0x04, 0xdb, 0x46, 0x7d, 0x48, 0x4f, 0x68, 0x35, 0xbe, 0x01,
	0xa3, 0xc2, 0x35, 0x60, 0xd3, 0xe3, 0x89, 0xee, 0xb7, 0x72, 0xe7, 0xf1, 0xb3, 0x28, 0x9c, 0x0c,
	0x8e, 0xa0, 0x20, 0xf5, 0x33, 0xb6, 0x9d, 0x0b, 0x6c, 0x81, 0x6d, 0x5d, 0x1c, 0xba, 0x0f, 0x6a,
	0x31, 0xb0, 0xad, 0x0f, 0x1d, 0xb9, 0xe3, 0x8d, 0x98, 0x30, 0xc5, 0x97, 0x78, 0xd5, 0xdc, 0x24,
	0xf6, 0x7c, 0x6e, 0xd7, 0x26, 0x59, 0x4b, 0xc7, 0x19, 0x18, 0x53, 0x2d, 0x45, 0xef, 0xb4, 0x36,
	0x88, 0x29, 0x26, 0xb3, 0xdf, 0x8f, 0x95, 0xa3, 0xaa, 0x55, 0x62, 0xd5, 0xf8, 0x69, 0x67, 0x39,
	0x0f, 0xf5, 0xc3, 0x7d, 0xe7, 0x3b, 0x13, 0x62, 0x75, 0xf7, 0xc6, 0x20, 0xd3, 0xb6, 0xaf, 0xcd,
	0x05, 0xa7, 0xcd, 0xd9, 0xbd, 0x6d, 0x4e, 0xb2, 0x54, 0x88, 0x0c, 0x70, 0x5a, 0x67, 0xee, 0xdf,
	0x0f, 0x79, 0xda, 0x3d, 0xed, 0x6f, 0xd7, 0x7b, 0x16, 0x3a, 0xa8, 0xd5, 0x9a, 0xaf, 0xd5, 0x62,
	0x79, 0x7b, 0x81, 0x05, 0xa4, 0x9e, 0x86, 0x51, 0xc7, 0xea, 0xe0, 0x62, 0x1e, 0x13, 0xba, 0xbd,
	0x83, 0x64, 0xa7, 0xa6, 0xd7, 0x54, 0x70, 0x48, 0x53, 0xb4, 0x91, 0x9f, 0x09, 0x43, 0xcc, 0xd3,
	0x0a, 0x5e, 0x03, 0x49, 0xb5, 0xf4, 0xf9, 0x8d, 0x5d, 0x9b, 0x28, 0xa6, 0xcd, 0xca, 0xf6, 0x89,
	0x5a, 0x0c, 0x90, 0x02, 0xf5, 0x47, 0x1d, 0x6c, 0x99, 0x23, 0xe3, 0x32, 0x4c, 0xd2, 0xdd, 0x8c,
	0xed, 0x5a, 0x2e, 0xc5, 0xe0, 0x41, 0x14, 0x9d, 0xd1, 0x52, 0x8a, 0x14, 0x9d, 0xfe, 0xed, 0x50,
	0xe4, 0x5d, 0x5c, 0xf0, 0x75, 0x31, 0x74, 0x10, 0xc1, 0x05, 0x7f, 0x17, 0x17, 0x3c, 0x5d, 0xbc,
	0xf2, 0xcd, 0xc0, 0xc3, 0x2e, 0xfa, 0x20, 0x00, 0x5f, 0x74, 0x5e, 0x72, 0xf8, 0x09, 0x04, 0xff,
	0x1f, 0x82, 0x8f, 0xed, 0x65, 0xc5, 0xfc, 0xe1, 0xea, 0x5d, 0xe3, 0xec, 0x5a, 0xcd, 0x26, 0x76,
	0x2a, 0x5b, 0x49, 0x55, 0xda, 0xa4, 0xa6, 0x35, 0xb4, 0x1a, 0x64, 0x06, 0x0c, 0x72, 0xfe, 0x30,
	0x1d, 0x44, 0x4a, 0xd8, 0x79, 0x5e, 0xd8, 0x3d, 0xdd, 0x9f, 0x3f, 0xb2, 0x64, 0x74, 0xcc, 0xbd,
	0x74, 0xdd, 0x47, 0x1c, 0xa0, 0x0e, 0xe3, 0xd9, 0x4a, 0x29, 0x75, 0xce, 0x21, 0x37, 0x5f, 0x81,
	0x64, 0x7f, 0xe7, 0x66, 0x5d, 0x65, 0x84, 0x63, 0x7b, 0x7a, 0x33, 0x2b, 0x34, 0x83, 0xa1, 0x2d,
	0xec, 0x83, 0xf6, 0x1a, 0x4c, 0xb1, 0x50, 0x42, 0x2a, 0x5b, 0x6f, 0x69, 0xba, 0x66, 0xd9, 0x2c,
	0x65, 0x6a, 0xbe, 0x08, 0x47, 0xf6, 0xb4, 0xc5, 0x73, 0x2d, 0x8f, 0xee, 0x6d, 0x87, 0x57, 0x1c,
	0xd9, 0xd3, 0x0a, 0xcf, 0x3e, 0x7e, 0x1a, 0x12, 0xa2, 0xc0, 0x9b, 0x7e, 0xcc, 0x32, 0x21, 0xbc,
	0x87, 0xb1, 0x48, 0x0a, 0xa4, 0x73, 0x90, 0x28, 0xbb, 0x47, 0xfc, 0x6c, 0x09, 0x39, 0x0f, 0x61,
	0xbe, 0xf1, 0x73, 0x93, 0x22, 0xe9, 0x35, 0x27, 0xbe, 0xcc, 0xcd, 0x09, 0x91, 0x74, 0x24, 0x73,
	0xc0, 0xf4, 0x36, 0x24, 0xfc, 0xc9, 0x21, 0xb8, 0x0e, 0xa3, 0x4e, 0x62, 0x0a, 0xa7, 0x72, 0xdd,
	0x4b, 0x65, 0xda, 0x9f, 0x6b, 0x24, 0xf9, 0x72, 0x8d, 0x3e, 0x17, 0x38, 0x28, 0xc3, 0xd9, 0x21,
	0x9d, 0xde, 0x84, 0xc9, 0x92, 0xf3, 0xc0, 0xa1, 0x6c, 0x34, 0x9d, 0xb8, 0x9c, 0xe7, 0xf1, 0x44,
	0xb4, 0xe7, 0xc9, 0x52, 0xcf, 0x93, 0x88, 0x67, 0x20, 0x64, 0x1a, 0x4d, 0xd2, 0x97, 0x1c, 0xd0,
	0xbb, 0x67, 0xca, 0x1e, 0x42, 0xa5, 0x10, 0xe9, 0x12, 0xc4, 0x29, 0x7d, 0x3a, 0x34, 0xc7, 0xba,
	0xe7, 0x97, 0x6f, 0xf8, 0xe0, 0xce, 0x0c, 0x18, 0x9c, 0xf3, 0xf9, 0x76, 0xc0, 0xdb, 0x75, 0x8e,
	0x96, 0xbe, 0x1f, 0x80, 0x29, 0xb7, 0xe7, 0x3c, 0x24, 0xc9, 0xe8, 0xfe, 0x0d, 0x04, 0xd8, 0xed,
	0x1f, 0x0f, 0x75, 0xb7, 0xd4, 0xb6, 0xf0, 0x4e, 0x2f, 0xf7, 0x5b, 0xef, 0x7b, 0x09, 0xcc, 0xfa,
	0xd8, 0xb1, 0xaa, 0xb6, 0xb9, 0x59, 0xce, 0x32, 0x19, 0xe0, 0x2d, 0x7f, 0xff, 0xde, 0x72, 0xfb,
	0x27, 0x4b, 0x7a, 0x1f, 0x5a, 0xf2, 0x35, 0x38, 0x3c, 0x90, 0xd4, 0x00, 0xab, 0x7d, 0xce, 0xff,
	0x1e, 0xd5, 0x9e, 0xd8, 0x80, 0x87, 0x6f, 0x5e, 0x4f, 0xf6, 0x75, 0x88, 0x56, 0x34, 0x9b, 0xbf,
	0x8b, 0x99, 0x17, 0xb7, 0xc5, 0x9f, 0x24, 0x74, 0x38, 0x29, 0x9e, 0x1e, 0xf1, 0xc6, 0x0a, 0xd9,
	0x05, 0xba, 0x94, 0xff, 0xa1, 0x61, 0x96, 0x33, 0xe7, 0x7b, 0xe1, 0x37, 0xfd, 0x1a, 0x1c, 0x16,
	0xd7, 0xc7, 0x79, 0xd8, 0xd2, 0x15, 0xe7, 0xb5, 0x8f, 0x10, 0xba, 0x3c, 0xec, 0x79, 0xfa, 0xc4,
	0x63, 0x02, 0xf3, 0x78, 0xe5, 0xd7, 0x83, 0x30, 0xcd, 0x4f, 0x65, 0xaa, 0xa6, 0xaa, 0x5b, 0x0d,
	0xc3, 0x6c, 0xa9, 0x6e, 0x22, 0xf0, 0x6d, 0x38, 0xd1, 0x24, 0x9b, 0x6a, 0x6d, 0x57, 0x24, 0xb1,
	0x29, 0xb6, 0x0f, 0xe6, 0x80, 0x43, 0xc2, 0x24, 0xc7, 0x1d, 0x44, 0x1d, 0x7f, 0x1a, 0x4e, 0x8a,
	0xab, 0x41, 0xfb, 0x90, 0x1e, 0x1e, 0xdc, 0x3c, 0x2e, 0x90, 0x07, 0xd2, 0x56, 0xe1, 0x74, 0xdb,
	0x34, 0xda, 0xc4, 0x54, 0x6a, 0xaa, 0x9b, 0x7f, 0xd7, 0x4f, 0x7f, 0x78, 0x98, 0xfa, 0x14, 0x27,
	0x90, 0x57, 0x9d, 0x4c, 0xbd, 0xbe, 0x26, 0x08, 0x3c, 0xcd, 0x72, 0x4c, 0xcc, 0x6d, 0x32, 0xac,
	0x91, 0xe1, 0x81, 0xd6, 0x94, 0x43, 0x62, 0xbf, 0x66, 0x58, 0x0a, 0xd2, 0x5c, 0xee, 0x02, 0x9c,
	0x18, 0x48, 0xde, 0x6b, 0x31, 0x87, 0xc5, 0x42, 0x39, 0x2a, 0x42, 0x57, 0x62, 0xa9, 0xfc, 0xb1,
	0x08, 0x3c, 0x9f, 0x33, 0xec, 0x45, 0xd2, 0x20, 0xba, 0x45, 0x96, 0x9a, 0xc6, 0x5d, 0xe6, 0xbb,
	0xe5, 0x55, 0x9b, 0x6c, 0x1a, 0xa6, 0x46, 0xac, 0x3c, 0x23, 0xc1, 0x84, 0x5d, 0x87, 0x84, 0xea,
	0x7b, 0x63, 0x4d, 0xc8, 0xe0, 0x4a, 0xff, 0x71, 0xc7, 0x5e, 0x7a, 0xfe, 0xb7, 0xd9, 0x7a, 0x34,
	0xa9, 0x7f, 0xe2, 0xa7, 0xc9, 0xb2, 0x3b, 0x6b, 0x35, 0xa3, 0xa3, 0xdb, 0x4a, 0x4b, 0xd5, 0xd5,
	0x4d, 0xc2, 0x42, 0x3e, 0x5c, 0x1a, 0x9f, 0x7a, 0x82, 0x96, 0x38, 0xee, 0xaa, 0x8b, 0xea, 0x6b,
	0x6c, 0x52, 0xed, 0xaf, 0xa6, 0xed, 0xb5, 0x4d, 0xa3, 0xa1, 0xb1, 0x75, 0xc9, 0x6d, 0x2f, 0xf4,
	0xa4, 0xed, 0x95, 0x39, 0xee, 0x7e, 0xed, 0xb5, 0xfb, 0xab, 0xb1, 0x01, 0x53, 0xd6, 0x96, 0xd1,
	0x6e, 0x6b, 0xfa, 0xa6, 0xb2, 0xa9, 0x35, 0x6c, 0xa5, 0xa6, 0x9a, 0x75, 0x4b, 0xcc, 0x94, 0x27,
	0x68, 0xb0, 0x22, 0x90, 0xaf, 0x69, 0x0d, 0x3b, 0x4f, 0x51, 0xfd, 0x0d, 0x5a, 0xfd, 0xd5, 0x74,
	0x80, 0x0d, 0x4d, 0x57, 0xf5, 0x9a, 0xa6, 0x36, 0x15, 0xf1, 0x03, 0x37, 0xce, 0xeb, 0xa6, 0x4f,
	0xd0, 0xde, 0x92, 0x83, 0x5b, 0x11, 0xa8, 0xfe, 0xf6, 0x1a, 0xfd, 0xd5, 0x78, 0x05, 0x22, 0x16,
	0x51, 0xcd, 0xda, 0x96, 0xf0, 0x2c, 0xe7, 0x9f, 0x60, 0x4c, 0x0c, 0xde, 0x47, 0x58, 0xd0, 0xa0,
	0xd4, 0x1a, 0x4d, 0x6d, 0x73, 0xcb, 0x16, 0xd7, 0xfa, 0x9e, 0x80, 0xda, 0x12, 0x83, 0xf7, 0x53,
	0xe3, 0x34, 0x72, 0xc7, 0x60, 0xb2, 0xd1, 0x34, 0xee, 0x2a, 0x2c, 0x2c, 0xe1, 0x4c, 0x8f, 0x90,
	0x27, 0x9b, 0xf2, 0xcf, 0x02, 0xf0, 0xf1, 0x8f, 0xa0, 0xbf, 0x38, 0x07, 0xe1, 0xa6, 0xc1, 0xf3,
	0x99, 0xd1, 0x80, 0xc0, 0x52, 0x8f, 0x14, 0x9b, 0xb8, 0x3c, 0xf5, 0x5c, 0x66, 0xbf, 0x81, 0xb3,
	0x3c, 0x22, 0x73, 0x54, 0x7c, 0x01, 0xc6, 0xd8, 0x1f, 0x4a, 0xab, 0xa1, 0x1e, 0xb0, 0xec, 0x44,
	0x19, 0xe0, 0x6a, 0x43, 0xc5, 0x9f, 0x80, 0x71, 0x8e, 0xd4, 0x56, 0x4d, 0x5b, 0x27, 0xe6, 0x01,
	0x4b, 0x49, 0x9c, 0x01, 0x97, 0x39, 0x2c, 0x9e, 0x85, 0x48, 0xd3, 0xd8, 0x34, 0x3a, 0xf6, 0x01,
	0x0b, 0xb4, 0x80, 0xa2, 0x8d, 0xb1, 0xd3, 0x62, 0xc5, 0x24, 0x0d, 0x93, 0x88, 0x9f, 0xb2, 0x19,
	0xd2, 0x18, 0x03, 0x96, 0x39, 0x6c, 0xee, 0x10, 0xc4, 0xf7, 0x65, 0xf7, 0xb7, 0x03, 0x70, 0x7c,
	0x08, 0x8f, 0x70, 0x15, 0x92, 0xee, 0xed, 0xf4, 0x5e, 0xa5, 0xe2, 0xfb, 0xb9, 0xa1, 0xfd, 0x7a,
	0x31, 0xed, 0xbc, 0x50, 0xb0, 0x87, 0x2a, 0x01, 0x3c, 0x80, 0x1a, 0xe7, 0xfc, 0xec, 0x93, 0x4b,
	0xd0, 0x17, 0x13, 0x99, 0xb4, 0xfb, 0xab, 0x73, 0x3f, 0x8d, 0xe0, 0xd8, 0xde, 0x76, 0x1c, 0x36,
	0xec, 0x38, 0xd6, 0xeb, 0x1b, 0x0f, 0x50, 0x33, 0xb9, 0x28, 0xae, 0xd2, 0x93, 0xba, 0xa2, 0xf2,
	0xdf, 0xc9, 0xa2, 0x28, 0x22, 0x39, 0xb8, 0x69, 0x74, 0xea, 0x0d, 0xd3, 0xd0, 0xf9, 0x0f, 0xb3,
	0x71, 0x28, 0xe7, 0x49, 0x24, 0x6b, 0xb6, 0xa7, 0xd0, 0x99, 0x51, 0xcb, 0x56, 0x37, 0x35, 0x7d,
	0x33, 0x13, 0x6a, 0x9b, 0x46, 0x3d, 0x13, 0xb7, 0x8c, 0x86, 0xbd, 0xa1, 0xea, 0x77, 0x94, 0x16,
	0xa9, 0x65, 0x46, 0x1b, 0xa4, 0x6e, 0xaa, 0xad, 0xb6, 0x60, 0xfd, 0xd7, 0x03, 0xf0, 0xd4, 0x01,
	0x83, 0xc3, 0x3b, 0x80, 0xad, 0x8e, 0x38, 0x10, 0x77, 0x4e, 0x7e, 0x9c, 0xac, 0xb7, 0x0b, 0x4f,
	0xce, 0x28, 0xf7, 0xd4, 0xc8, 0x93, 0x00, 0x17, 0xf4, 0xde, 0x3c, 0x12, 0x8d, 0xb8, 0x70, 0x16,
	0x6d, 0x59, 0x9c, 0x6a, 0x79, 0x5b, 0x0e, 0x7d, 0xdf, 0x5b, 0x16, 0x8d, 0xf4, 0x5a, 0xbe, 0x72,
	0xf9, 0xc3, 0xab, 0xc1, 0x85, 0x99, 0x0b, 0x2c, 0xb5, 0xfd, 0x30, 0x48, 0x4e, 0xd8, 0x2a, 0x6f,
	0x6a, 0x36, 0x31, 0x35, 0x15, 0xa3, 0x05, 0x5a, 0x2c, 0x7e, 0x07, 0xcd, 0x53, 0x7c, 0xc1, 0xe7,
	0x81, 0xff, 0x79, 0x00, 0x9e, 0x79, 0x92, 0x7e, 0xed, 0xf3, 0x30, 0x8c, 0x2f, 0x03, 0x58, 0x24,
	0xfe, 0xd6, 0x21, 0xee, 0xb9, 0xac, 0x26, 0xac, 0xc1, 0x5c, 0x76, 0xc0, 0x85, 0x07, 0xe7, 0x53,
	0xe4, 0xf6, 0x1e, 0x74, 0xe3, 0x21, 0xd6, 0xbb, 0x8e, 0x6a, 0xe1, 0xac, 0xfb, 0x2b, 0x64, 0xc1,
	0x81, 0xa7, 0x2c, 0xcb, 0xb6, 0xdd, 0xee, 0x9d, 0xa4, 0x09, 0x37, 0xe4, 0xb3, 0xcc, 0x66, 0x15,
	0x88, 0x57, 0x7e, 0xd8, 0x79, 0xc5, 0xf4, 0xbd, 0x2e, 0x3a, 0x09, 0xc7, 0x01, 0xbb, 0xa3, 0xf5,
	0x24, 0x01, 0x33, 0x80, 0x87, 0x5d, 0xb4, 0x0a, 0xc7, 0x20, 0xc6, 0x09, 0xa6, 0x28, 0xc5, 0x24,
	0x38, 0x1d, 0x48, 0xed, 0x4d, 0x0f, 0x4e, 0x41, 0x9c, 0xa5, 0xff, 0xf1, 0xb4, 0x3f, 0x2b, 0x27,
	0xf9, 0x59, 0x22, 0x05, 0xd2, 0x5d, 0x04, 0x1f, 0xd1, 0x2a, 0xa0, 0x8b, 0x21, 0x7b, 0x43, 0xfb,
	0xa0, 0xf3, 0x72, 0x01, 0x85, 0x3f, 0x05, 0x09, 0xe7, 0xd5, 0x67, 0x85, 0x9d, 0x9c, 0x1e, 0xb0,
	0x66, 0x8f, 0x3b, 0xd0, 0x32, 0x05, 0x1e, 0xba, 0x1c, 0xbe, 0x3f, 0xb8, 0xf7, 0x43, 0x6c, 0x8c,
	0x8f, 0xdc, 0xfb, 0x59, 0x88, 0xf0, 0x9f, 0xa0, 0x3b, 0xa0, 0xd7, 0x02, 0x0a, 0x67, 0x20, 0xc4,
	0xde, 0x0a, 0x1f, 0xbe, 0xbd, 0x30, 0x98, 0xa1, 0x43, 0x7b, 0x38, 0x0a, 0x1f, 0xd1, 0x9a, 0xc1,
	0x2f, 0x81, 0x64, 0x89, 0x53, 0x0b, 0xc5, 0x36, 0xa8, 0x9d, 0x74, 0xd0, 0x92, 0x3f, 0x6e, 0xf1,
	0xe3, 0xb1, 0xaa, 0x91, 0x57, 0x4d, 0x1b, 0x57, 0x20, 0xc9, 0x08, 0xb4, 0x4d, 0xa3, 0x65, 0xb0,
	0xf3, 0x62, 0x65, 0xdb, 0x7d, 0x59, 0xe3, 0x80, 0xf1, 0x1f, 0xa5, 0x98, 0x65, 0x8a, 0x48, 0xb5,
	0xb2, 0xf7, 0x20, 0x07, 0x7b, 0xe2, 0x88, 0x12, 0xad, 0x6d, 0x91, 0xda, 0x1d, 0x27, 0x7e, 0x3f,
	0xec, 0x89, 0xa3, 0x2d, 0xa3, 0x9d, 0x17, 0xb0, 0x2c, 0x4d, 0x83, 0x22, 0xb7, 0xd4, 0x3b, 0x44,
	0x69, 0xab, 0xbb, 0xcc, 0xd6, 0x0c, 0x1f, 0x90, 0xa6, 0xb1, 0x65, 0xb4, 0x57, 0xd5, 0x3b, 0xa4,
	0xcc, 0xc1, 0x59, 0x86, 0x08, 0xa5, 0x61, 0x98, 0x75, 0x62, 0x1e, 0xb0, 0x13, 0x8f, 0x51, 0xc8,
	0x35, 0x0a, 0x88, 0x17, 0x01, 0x0b, 0x66, 0x68, 0xec, 0x17, 0x1d, 0x5e, 0xef, 0x68, 0xe6, 0xee,
	0x01, 0xaf, 0x2e, 0x48, 0x9c, 0x09, 0x5a, 0x8d, 0x14, 0x39, 0x3c, 0x5e, 0x85, 0xa3, 0x9c, 0x4a,
	0xc7, 0xac, 0x6d, 0x51, 0xbf, 0xc6, 0x35, 0x61, 0x0f, 0x78, 0x76, 0xe1, 0x10, 0x23, 0x25, 0xb0,
	0x1c, 0x69, 0xe3, 0x65, 0x60, 0xe5, 0xce, 0xaf, 0x22, 0xbe, 0xde, 0x51, 0x75, 0x5b, 0xb3, 0x77,
	0x0f, 0xb8, 0x46, 0xca, 0x06, 0xc2, 0x7f, 0x58, 0xf1, 0x15, 0x81, 0x81, 0x5f, 0x16, 0xca, 0x52,
	0xdb, 0x32, 0x0c, 0x8b, 0x28, 0x16, 0x51, 0xed, 0xa1, 0x2f, 0x39, 0x8d, 0xc8, 0x09, 0x2e, 0x19,
	0x0a, 0x5e, 0x21, 0xaa, 0x8d, 0x5f, 0x85, 0x93, 0x8c, 0x02, 0xd1, 0x6d, 0x62, 0x2a, 0x75, 0x53,
	0xbd, 0x4b, 0x4d, 0x74, 0xab, 0xb3, 0xd1, 0xd2, 0xd8, 0x8f, 0x75, 0x0e, 0x7d, 0xda, 0x69, 0x44,
	0x66, 0xaa, 0x56, 0xa0, 0xb8, 0x8b, 0x1c, 0xb5, 0xe2, 0x62, 0xd2, 0x61, 0xba, 0x7c, 0xf2, 0xaa,
	0x60, 0x7c, 0xf8, 0x30, 0x37, 0x05, 0x9b, 0x3c, 0xda, 0xb7, 0x05, 0xcf, 0xf5, 0x28, 0x71, 0x2d,
	0x72, 0x24, 0x71, 0x57, 0xb3, 0xb7, 0x3c, 0xe2, 0x18, 0x1f, 0xee, 0x5a, 0x3a, 0xb4, 0x99, 0x66,
	0x09, 0x12, 0xb7, 0x34, 0x7b, 0xcb, 0x11, 0xcd, 0xd0, 0xc9, 0xfc, 0x4f, 0x07, 0xaf, 0x53, 0x43,
	0x5c, 0x05, 0x3c, 0x03, 0x61, 0x6a, 0xd8, 0xec, 0x1e, 0x30, 0x83, 0x39, 0x10, 0x5d, 0x63, 0x5b,
	0x86, 0x4e, 0x76, 0x85, 0x43, 0x2b, 0x82, 0xe4, 0x43, 0x26, 0x3e, 0x83, 0xae, 0x0a, 0xe0, 0xa1,
	0x7d, 0xff, 0xad, 0x00, 0x3c, 0xfd, 0x04, 0x2e, 0x08, 0x9d, 0xe7, 0xdc, 0x69, 0x50, 0x84, 0x37,
	0x33, 0xbc, 0xe3, 0x71, 0x0e, 0xcc, 0xc9, 0xb0, 0x3d, 0xc2, 0x34, 0xea, 0x9d, 0x9a, 0x8b, 0x7d,
	0xd0, 0x1e, 0xc1, 0xa1, 0x05, 0xfa, 0x0b, 0x10, 0x33, 0x0d, 0xa3, 0xe5, 0xe0, 0x0e, 0x5f, 0x61,
	0x80, 0x82, 0x0a, 0xc4, 0x02, 0x60, 0x1e, 0x32, 0xe0, 0xfe, 0xbf, 0xc0, 0x3f, 0xe0, 0x01, 0x4f,
	0x0f, 0x06, 0x27, 0x33, 0x94, 0x7f, 0x77, 0x07, 0xb2, 0xaf, 0xdf, 0xe7, 0xc2, 0xe7, 0x61, 0x94,
	0xad, 0x90, 0xda, 0x41, 0x91, 0x1a, 0x07, 0x2c, 0x37, 0xdd, 0xd7, 0x68, 0xff, 0x45, 0xb7, 0x07,
	0x08, 0xa6, 0xc4, 0x79, 0x11, 0x9d, 0x5d, 0xb6, 0x5a, 0xe3, 0xef, 0x9f, 0x66, 0x20, 0xa4, 0xb5,
	0xb7, 0x17, 0x0e, 0x68, 0x86, 0xc1, 0x08, 0xd8, 0x4b, 0x07, 0x48, 0x83, 0xc1, 0x50, 0xd8, 0x7a,
	0x47, 0x6d, 0x1e, 0xb4, 0xf3, 0x51, 0x98, 0xdc, 0x71, 0x88, 0x0c, 0x0e, 0x4a, 0x2f, 0xcc, 0x08,
	0xbb, 0x30, 0x7d, 0x0f, 0xc6, 0x16, 0x55, 0x9b, 0xb0, 0xa0, 0x34, 0x7e, 0x11, 0xc0, 0xb2, 0x55,
	0xd3, 0x56, 0xd8, 0x4e, 0x8c, 0x0e, 0xfc, 0xc9, 0x92, 0x31, 0x06, 0x4d, 0xf1, 0xf1, 0x45, 0xf6,
	0x1c, 0x2a, 0x47, 0x0c, 0x1c, 0x88, 0x38, 0x4a, 0xf4, 0x3a, 0x45, 0x4b, 0xff, 0x0e, 0x82, 0xd0,
	0x92, 0xd6, 0x64, 0x77, 0xb7, 0x6a, 0x86, 0x6e, 0x13, 0x9d, 0x27, 0x83, 0x8a, 0xb0, 0x67, 0x4c,
	0x94, 0x31, 0x8e, 0x4e, 0xc3, 0xa8, 0xf8, 0x64, 0x2d, 0xc4, 0x65, 0xe7, 0x13, 0xa7, 0x60, 0x94,
	0x45, 0x4a, 0xdc, 0x5f, 0x02, 0x75, 0xdf, 0x59, 0x8a, 0xd0, 0xf2, 0x62, 0x9d, 0xbd, 0xed, 0x78,
	0xd7, 0x52, 0xac, 0x0b, 0x43, 0x2f, 0x4b, 0x06, 0xdf, 0xbf, 0xc7, 0x72, 0x90, 0xd5, 0xbb, 0x56,
	0xe5, 0x42, 0xee, 0x59, 0x90, 0x2c, 0xdb, 0x30, 0xd5, 0xcd, 0xde, 0x5b, 0xfa, 0xee, 0x45, 0xba,
	0xf0, 0xe3, 0x2e, 0x42, 0x0b, 0x9e, 0x33, 0xde, 0x37, 0x11, 0x35, 0x02, 0xad, 0xb6, 0xa1, 0x5b,
	0xec, 0xe7, 0xbf, 0xf0, 0x0b, 0x00, 0x2c, 0x1f, 0x8e, 0x6d, 0xf0, 0x22, 0x15, 0x67, 0xba, 0xbf,
	0x55, 0x0a, 0x40, 0x37, 0x72, 0x79, 0x8c, 0x38, 0x7f, 0xe2, 0xe7, 0x61, 0xa2, 0xae, 0x59, 0xed,
	0xa6, 0xba, 0xab, 0xb4, 0xf8, 0xcf, 0x89, 0x89, 0x2c, 0x8d, 0x84, 0x28, 0x16, 0x3f, 0x32, 0x76,
	0x70, 0xfe, 0x50, 0xfa, 0xc7, 0x11, 0x44, 0xb2, 0xfc, 0xf8, 0x7a, 0x06, 0xc2, 0x1b, 0x4d, 0xa3,
	0x76, 0xe7, 0xa0, 0x85, 0x8e, 0x01, 0x51, 0x73, 0xcc, 0x24, 0xec, 0xae, 0xce, 0x01, 0xe6, 0x18,
	0x87, 0xca, 0xa5, 0x60, 0x5c, 0x78, 0x93, 0x7d, 0x0f, 0x52, 0xa2, 0xde, 0x25, 0x2a, 0xaa, 0x6d,
	0xff, 0x36, 0x00, 0xa3, 0x79, 0x79, 0x95, 0x85, 0xa2, 0xcf, 0x03, 0x38, 0x11, 0x35, 0xf7, 0x37,
	0xbd, 0x26, 0x85, 0xdc, 0xbc, 0xa7, 0x08, 0x02, 0xa8, 0x58, 0xc7, 0x97, 0x21, 0x41, 0xe8, 0xb6,
	0xda, 0x64, 0xd6, 0xa6, 0xe2, 0xfe, 0xe6, 0xf6, 0x00, 0xac, 0x71, 0x0f, 0x60, 0xb1, 0x8e, 0xaf,
	0xc0, 0x84, 0xd5, 0xd9, 0x70, 0x19, 0xd3, 0x53, 0x94, 0x01, 0xa8, 0x09, 0x2f, 0x64, 0xb1, 0x4e,
	0xfb, 0xc9, 0x6c, 0x1a, 0xae, 0x97, 0xa1, 0x7d, 0xfb, 0xc9, 0x80, 0xc4, 0xa6, 0xe2, 0x34, 0x5f,
	0x57, 0xac, 0x3b, 0x1d, 0xfe, 0x63, 0x8d, 0x1e, 0xa5, 0x8c, 0x3b, 0xb5, 0x95, 0x3b, 0x1d, 0x0b,
	0xe7, 0x60, 0x8a, 0xdf, 0xee, 0x25, 0xa6, 0xa2, 0xb9, 0xe7, 0xf1, 0xe2, 0x39, 0x86, 0xfe, 0x86,
	0xbe, 0x83, 0x64, 0xec, 0x40, 0xf7, 0x0e, 0xef, 0xd3, 0x26, 0x4c, 0x32, 0x0f, 0x84, 0x79, 0x31,
	0x32, 0xb9, 0x4b, 0xdd, 0x3f, 0x7c, 0x16, 0x46, 0xdb, 0xaa, 0x6d, 0x13, 0xd3, 0xc9, 0x2b, 0x1d,
	0xf4, 0xee, 0x8f, 0xec, 0xc0, 0xe0, 0x59, 0x88, 0xd3, 0x91, 0xdb, 0x9a, 0xdd, 0xd9, 0xe7, 0x37,
	0xe8, 0x7c, 0xf5, 0x99, 0x9f, 0x43, 0x00, 0xbd, 0x1b, 0x5f, 0xf8, 0x1c, 0x04, 0xb3, 0xa5, 0x57,
	0xa5, 0x91, 0xe4, 0x73, 0x0f, 0xbb, 0x28, 0x8d, 0x53, 0x7e, 0x85, 0xa1, 0x86, 0xb8, 0x35, 0x9b,
	0x6d, 0x6b, 0xee, 0xaf, 0x7a, 0xe3, 0x51, 0x08, 0x5e, 0x2b, 0x54, 0x25, 0x84, 0xa3, 0x10, 0x5a,
	0x2e, 0x64, 0x17, 0xa5, 0x00, 0xfd, 0xab, 0xbc, 0x56, 0xa9, 0x4a, 0x41, 0x5a, 0x59, 0x5e, 0xaf,
	0x4a, 0x21, 0x0c, 0x10, 0x59, 0x2c, 0xac, 0x14, 0xaa, 0x05, 0x29, 0x8c, 0x63, 0x30, 0x9a, 0x5f,
	0x2b, 0x95, 0x0a, 0xf9, 0xaa, 0x14, 0xa1, 0x1f, 0x6b, 0xe5, 0x6a, 0x71, 0xad, 0x54, 0x91, 0x46,
	0xf1, 0x18, 0x84, 0xab, 0x72, 0x36, 0x5f, 0x90, 0xa2, 0xf4, 0xcf, 0x72, 0xb6, 0x9a, 0x5f, 0x96,
	0xc6, 0x32, 0x3f, 0x8e, 0x60, 0x3c, 0x67, 0xd8, 0x9e, 0x4e, 0x26, 0x00, 0x56, 0x0b, 0xd5, 0xe5,
	0xb5, 0x45, 0x85, 0xf5, 0xd5, 0xf3, 0xcd, 0xbb, 0x32, 0x01, 0x31, 0xf1, 0x2d, 0xfa, 0xd1, 0x03,
	0xe0, 0xdd, 0x91, 0x20, 0xee, 0x7c, 0xb3, 0x46, 0xc2, 0x78, 0x12, 0xc6, 0x45, 0x89, 0xe8, 0x67,
	0x04, 0x1f, 0x85, 0xa9, 0x1e, 0x55, 0x65, 0x71, 0x2d, 0xbf, 0xbe, 0x5a, 0x28, 0x55, 0x25, 0xc8,
	0x7c, 0x36, 0x00, 0xc7, 0xd7, 0xda, 0x44, 0xcf, 0xb6, 0x35, 0xcf, 0x5b, 0x7a, 0x2c, 0x64, 0x6f,
	0x6b, 0xc4, 0xc2, 0x27, 0xe1, 0x58, 0x59, 0x5e, 0x2b, 0x17, 0xe4, 0xea, 0xab, 0xca, 0x2b, 0xeb,
	0x05, 0xf9, 0x55, 0xa5, 0x9c, 0x95, 0xb3, 0xab, 0x85, 0x6a, 0x41, 0xae, 0x48, 0x23, 0xf8, 0x04,
	0x4c, 0xbb, 0xd5, 0xe5, 0x6c, 0x75, 0xd9, 0x5b, 0x8b, 0xf0, 0x31, 0x38, 0xec, 0xd6, 0xe6, 0xd7,
	0x4a, 0xd5, 0x42, 0xa9, 0xaa, 0x54, 0x5f, 0x2d, 0x17, 0xa4, 0x00, 0x3e, 0x05, 0x49, 0x4f, 0xd5,
	0xda, 0x8d, 0x62, 0xc1, 0x8b, 0x1a, 0xf4, 0xa1, 0x2e, 0x57, 0xab, 0x65, 0x85, 0xca, 0x83, 0x56,
	0x85, 0xf0, 0x11, 0xc0, 0xfe, 0xaa, 0xdc, 0xda, 0xe2, 0xab, 0x52, 0xd8, 0xd7, 0x97, 0x4a, 0x21,
	0xbf, 0x2e, 0x17, 0xe9, 0x1f, 0xf9, 0xe5, 0xc2, 0x6a, 0x56, 0x8a, 0xe0, 0x24, 0x1c, 0x71, 0x6b,
	0xe5, 0x42, 0xa5, 0xbc, 0x56, 0xaa, 0x14, 0x94, 0xfc, 0xda, 0x62, 0x41, 0x1a, 0xcd, 0xfc, 0xf6,
	0x18, 0x24, 0xfc, 0xee, 0x3a, 0x9e, 0x82, 0x09, 0xb6, 0xa2, 0xf4, 0x8a, 0xa4, 0x11, 0x1c, 0x87,
	0x68, 0xde, 0xd0, 0x6d, 0x4d, 0xef, 0x10, 0xa9, 0x8e, 0x47, 0x21, 0xb0, 0x76, 0x43, 0xfa, 0x0a,
	0xc2, 0x71, 0x18, 0xe5, 0xbf, 0x6f, 0x5a, 0x97, 0x7e, 0x17, 0xe1, 0x71, 0x88, 0x66, 0x6b, 0x35,
	0xd2, 0xa6, 0x9f, 0x0f, 0x11, 0x4e, 0xc1, 0xf1, 0x92, 0xa1, 0x67, 0x3b, 0xf6, 0x96, 0x61, 0x6a,
	0xb6, 0x6a, 0x6b, 0xdb, 0xec, 0xd8, 0x4b, 0x1c, 0x3c, 0x48, 0xff, 0x0a, 0xe1, 0x04, 0x8c, 0x95,
	0x8c, 0x3c, 0xdf, 0x37, 0xa4, 0xdf, 0x43, 0x78, 0x92, 0x2d, 0xdb, 0xc4, 0x76, 0x8a, 0xfe, 0x35,
	0xc2, 0x53, 0x90, 0x28, 0xab, 0xa6, 0xad, 0xa9, 0x4d, 0xa7, 0xf0, 0xab, 0x08, 0x4b, 0x10, 0x5b,
	0xed, 0x34, 0x6d, 0x8d, 0x77, 0x51, 0xfa, 0x7d, 0x84, 0x0f, 0xc1, 0x44, 0xb6, 0x69, 0x12, 0xb5,
	0xbe, 0x2b, 0xb3, 0x45, 0x90, 0xd4, 0xa5, 0x47, 0x08, 0xc7, 0x20, 0x52, 0x5c, 0x5d, 0xb7, 0x48,
	0x5d, 0x7a, 0xcc, 0x40, 0x18, 0x52, 0xbb, 0x49, 0xb8, 0x0d, 0x62, 0x49, 0xbf, 0x12, 0xc0, 0x87,
	0x41, 0x5a, 0x35, 0xb6, 0x49, 0xbd, 0x4c, 0xcc, 0x96, 0xaa, 0x13, 0xdd, 0x6e, 0xee, 0x4a, 0xbf,
	0x1a, 0xc0, 0x00, 0xe1, 0x25, 0xa3, 0xa3, 0xd7, 0xa5, 0x7f, 0x14, 0xa0, 0xc3, 0xaa, 0x10, 0xb2,
	0x66, 0x6f, 0x11, 0x53, 0xfa, 0xb5, 0x00, 0x6d, 0xbc, 0x64, 0xd8, 0xab, 0xec, 0xf7, 0xc1, 0x48,
	0x5d, 0xfa, 0x32, 0x03, 0x58, 0xb7, 0x08, 0x4b, 0x59, 0x93, 0x7e, 0x3d, 0x80, 0x8f, 0xc0, 0x64,
	0x95, 0xb4, 0xda, 0x86, 0xa9, 0x9a, 0xbb, 0x32, 0xa9, 0x6b, 0x26, 0xa9, 0xd9, 0xd2, 0x6f, 0xb0,
	0x72, 0xb7, 0x15, 0xb7, 0xfc, 0x37, 0x03, 0x78, 0x02, 0x20, 0xa7, 0xd6, 0xc5, 0xeb, 0x19, 0xd2,
	0xe7, 0x83, 0x94, 0x0d, 0xeb, 0xba, 0xca, 0xf9, 0xf6, 0xc3, 0xa4, 0x2e, 0xfd, 0x64, 0x90, 0x76,
	0x5e, 0xf8, 0x76, 0x14, 0x4e, 0x33, 0x49, 0x5d, 0x7a, 0x93, 0x4e, 0x88, 0xb1, 0x25, 0xc3, 0xdc,
	0xd0, 0xea, 0x75, 0xa2, 0x4b, 0x3f, 0x15, 0xa4, 0x1d, 0x29, 0x19, 0x36, 0xef, 0xf8, 0x17, 0x82,
	0x6c, 0x6c, 0x6c, 0xaa, 0x95, 0x0c, 0x3b, 0xcb, 0x9f, 0x08, 0x90, 0x7e, 0x3a, 0x88, 0x31, 0xb0,
	0x9f, 0xda, 0x67, 0x92, 0x52, 0x37, 0x9a, 0x44, 0xfa, 0xdb, 0x41, 0x2a, 0x2b, 0xd6, 0x7f, 0x7f,
	0x10, 0xdb, 0x6d, 0xeb, 0x67, 0x82, 0x54, 0x10, 0x9e, 0x07, 0x3e, 0x8c, 0x8e, 0x2d, 0x7d, 0x91,
	0x35, 0x98, 0x37, 0xf4, 0x46, 0x53, 0xab, 0xd9, 0xd2, 0xdf, 0x09, 0xe2, 0x31, 0x08, 0x5d, 0x33,
	0x74, 0x22, 0xbd, 0xc5, 0xc0, 0x57, 0x88, 0xbe, 0x69, 0x6f, 0xb9, 0x34, 0xfe, 0x6e, 0x10, 0x1f,
	0x05, 0x5c, 0x36, 0x89, 0x1b, 0xac, 0x5b, 0x52, 0xb5, 0x26, 0xa9, 0x4b, 0x7f, 0xcf, 0x19, 0x5e,
	0xd3, 0x50, 0xeb, 0x55, 0xc3, 0x58, 0x51, 0xcd, 0x4d, 0x22, 0xfd, 0x6c, 0x90, 0x32, 0x86, 0xaa,
	0xb2, 0x61, 0xac, 0x18, 0xfa, 0xa6, 0xf4, 0xf7, 0xe9, 0xd4, 0x38, 0xb4, 0xae, 0x5b, 0x9d, 0x36,
	0x97, 0xf0, 0x2a, 0xa9, 0x6b, 0xec, 0x77, 0xbc, 0xa4, 0x9f, 0x0b, 0xe2, 0x69, 0x98, 0x62, 0x66,
	0x53, 0xc9, 0xb0, 0x2b, 0xaa, 0xad, 0x59, 0x0d, 0x96, 0xcf, 0x2d, 0xbd, 0x1d, 0xa4, 0x6c, 0x2f,
	0xec, 0xb4, 0x49, 0x8d, 0x1f, 0x87, 0x8a, 0x36, 0x7f, 0x9e, 0x75, 0x66, 0x55, 0xb3, 0xb8, 0x18,
	0x88, 0xcb, 0xfe, 0x7f, 0xc8, 0x48, 0xad, 0xeb, 0x6d, 0xd3, 0xa8, 0xd1, 0xad, 0x7d, 0xa3, 0x49,
	0x0a, 0xcc, 0x7b, 0x94, 0x7e, 0x29, 0x48, 0xf5, 0x69, 0xc5, 0xa8, 0xdd, 0x21, 0x75, 0xe9, 0x97,
	0x19, 0x77, 0x39, 0xb1, 0x45, 0xd2, 0x26, 0x7a, 0x9d, 0xe8, 0xb5, 0x5d, 0xe9, 0x4b, 0x6c, 0x28,
	0xeb, 0xed, 0x4d, 0x53, 0xad, 0x13, 0x77, 0xe4, 0xef, 0xb0, 0x9e, 0x7b, 0x47, 0xee, 0x56, 0xfd,
	0x0a, 0x43, 0xa8, 0x1a, 0xc6, 0xaa, 0xaa, 0xef, 0x8a, 0x3e, 0x58, 0xd2, 0xaf, 0x32, 0x81, 0x88,
	0x4f, 0x7e, 0xa8, 0xb7, 0xa4, 0x91, 0x66, 0xdd, 0x72, 0xb9, 0xf3, 0x6b, 0xac, 0x9b, 0xce, 0x0f,
	0x92, 0x50, 0x5f, 0x8a, 0x98, 0xcc, 0x80, 0x91, 0xfe, 0x33, 0xe3, 0x7d, 0xc9, 0xb0, 0x8b, 0xad,
	0x36, 0xdf, 0x72, 0x49, 0x5d, 0xfa, 0xf3, 0xa0, 0xd0, 0xb2, 0x6b, 0xfc, 0x76, 0x80, 0xf4, 0x5f,
	0xd8, 0xf8, 0x85, 0x0f, 0xb6, 0xae, 0xab, 0xdb, 0xaa, 0xd6, 0x64, 0x0c, 0xfb, 0x0b, 0x86, 0x2e,
	0xc0, 0x1c, 0x49, 0x7f, 0x3b, 0x88, 0x4f, 0xc0, 0x51, 0xba, 0xe2, 0x88, 0x5b, 0x50, 0x94, 0xcb,
	0x8e, 0x18, 0xa4, 0xff, 0x1a, 0xc4, 0x49, 0x38, 0x7c, 0x53, 0x35, 0x35, 0x55, 0xb7, 0xb3, 0x4d,
	0xcb, 0x28, 0x91, 0x4d, 0xc3, 0xd6, 0x54, 0x9b, 0x58, 0xd2, 0x7f, 0x13, 0xfd, 0x64, 0xaf, 0x6b,
	0xd5, 0x34, 0xa2, 0xdb, 0x15, 0x6e, 0xc5, 0x49, 0xff, 0x9d, 0xe9, 0xf9, 0x8a, 0x61, 0xb4, 0x17,
	0x09, 0x8f, 0x57, 0x4b, 0xff, 0x23, 0x28, 0x26, 0x57, 0x61, 0xc7, 0xa6, 0x1c, 0xad, 0x4b, 0xff,
	0x33, 0x88, 0xd3, 0x70, 0x52, 0x58, 0xf4, 0xfb, 0xe8, 0xe6, 0x77, 0x82, 0x99, 0x3f, 0x46, 0x70,
	0x98, 0xae, 0x62, 0x8e, 0xcd, 0x47, 0x17, 0x2d, 0xfe, 0x73, 0x78, 0xcf, 0x40, 0x8a, 0x2d, 0x94,
	0xbe, 0x75, 0x4f, 0xc9, 0xaf, 0x64, 0x2b, 0x15, 0x65, 0xbd, 0x74, 0xa3, 0xb4, 0x76, 0xab, 0x24,
	0x8d, 0xe0, 0x14, 0x9c, 0xd8, 0x17, 0x6a, 0xee, 0xf6, 0x6d, 0x09, 0x0d, 0x85, 0x98, 0xbf, 0x7d,
	0x5b, 0x0a, 0x0c, 0x85, 0xb8, 0x70, 0xfb, 0xb6, 0x14, 0x1c, 0x0a, 0xb1, 0x70, 0xfb, 0xb6, 0x14,
	0x1a, 0x0a, 0x71, 0xf1, 0xf6, 0x6d, 0x29, 0x9c, 0x79, 0x80, 0x20, 0xce, 0xd6, 0x6b, 0x9e, 0x08,
	0x69, 0xe1, 0xe3, 0x30, 0xc9, 0x50, 0x2a, 0x85, 0x3c, 0xdd, 0x7f, 0x95, 0xd2, 0x5a, 0xa9, 0x20,
	0x8d, 0xf0, 0x9f, 0xd9, 0xa2, 0x5b, 0x98, 0xaf, 0xd2, 0xb3, 0x8d, 0xd1, 0x4d, 0xea, 0x04, 0x4c,
	0xfb, 0xaa, 0xe5, 0xc2, 0x2b, 0xee, 0x66, 0x13, 0xd8, 0x5b, 0x5b, 0xe9, 0x6d, 0x45, 0x6c, 0x97,
	0xda, 0x83, 0x2b, 0x76, 0xa3, 0x3d, 0x55, 0x15, 0xb1, 0x51, 0x45, 0x32, 0x39, 0x98, 0xe4, 0x6b,
	0x76, 0xb9, 0xb3, 0xd1, 0xd4, 0xac, 0x2d, 0x66, 0xa1, 0x1d, 0x83, 0xc3, 0x95, 0x6a, 0xb6, 0xba,
	0x5e, 0x51, 0x16, 0xd7, 0x94, 0xd2, 0x5a, 0x55, 0x29, 0xaf, 0xe7, 0x56, 0x8a, 0x95, 0x65, 0x69,
	0x04, 0x63, 0x48, 0x88, 0x2a, 0xa7, 0x0c, 0x65, 0xae, 0x50, 0xbd, 0xed, 0xff, 0xc9, 0x1c, 0x6a,
	0x0b, 0x38, 0xdf, 0x25, 0xba, 0x04, 0x31, 0x5c, 0xa7, 0x24, 0xc7, 0x5e, 0xce, 0x92, 0x50, 0xe6,
	0x19, 0x18, 0x5f, 0x97, 0x57, 0x2a, 0xd4, 0x0c, 0xe2, 0x2e, 0x28, 0x35, 0x77, 0xaa, 0xd5, 0xb2,
	0x34, 0x42, 0x4d, 0x15, 0xfa, 0x57, 0x45, 0x42, 0x99, 0x35, 0x88, 0x55, 0x9b, 0x96, 0x93, 0xa5,
	0x4a, 0xf7, 0xbe, 0xea, 0x4a, 0x45, 0xc9, 0xae, 0x57, 0xd7, 0xa4, 0x11, 0x6a, 0xea, 0x54, 0x57,
	0x2a, 0xdb, 0x73, 0xca, 0x79, 0x09, 0xf5, 0x3e, 0xe6, 0xa4, 0x40, 0xef, 0x63, 0x5e, 0x0a, 0xf6,
	0x3e, 0x2e, 0x48, 0xa1, 0x8c, 0x06, 0xb1, 0xdb, 0x8d, 0x5a, 0xad, 0xc0, 0xe7, 0x23, 0x1e, 0x87,
	0xb1, 0xdb, 0x4b, 0xf9, 0xbc, 0x90, 0x95, 0xfb, 0x99, 0x2f, 0xc8, 0xd4, 0xec, 0x49, 0x00, 0xf0,
	0xcf, 0xe5, 0x6c, 0xb1, 0x24, 0xd1, 0xfd, 0x26, 0xce, 0xbe, 0x2b, 0xeb, 0xb9, 0xeb, 0xd4, 0xda,
	0x0a, 0xd2, 0x0e, 0xb1, 0x92, 0x75, 0xb9, 0x28, 0x85, 0xdc, 0xaf, 0xc5, 0x52, 0x45, 0x0a, 0x67,
	0x96, 0x60, 0xdc, 0xf7, 0xc0, 0x28, 0x7e, 0x0a, 0x8e, 0x14, 0x4b, 0x37, 0xb3, 0x2b, 0xc5, 0x45,
	0x65, 0x39, 0x5b, 0x59, 0x56, 0xb2, 0x2b, 0xd7, 0xd6, 0xe4, 0x62, 0x75, 0x79, 0x55, 0x1a, 0x49,
	0x06, 0xef, 0xdf, 0x43, 0xd4, 0xa8, 0xab, 0x2c, 0x67, 0xe7, 0x2f, 0x5e, 0xe2, 0xd6, 0x5f, 0x65,
	0x39, 0x3b, 0x27, 0x05, 0x32, 0x67, 0x60, 0x42, 0x36, 0x3a, 0x36, 0x7b, 0x5c, 0x5b, 0xa3, 0xa4,
	0x76, 0xe9, 0x90, 0x16, 0x0b, 0x4b, 0xd9, 0xf5, 0x95, 0xaa, 0x34, 0xc2, 0x18, 0x57, 0xbc, 0x46,
	0xe5, 0xf1, 0x29, 0x98, 0xe8, 0x7b, 0xd0, 0x8a, 0x42, 0x2e, 0xaf, 0x97, 0x16, 0xe5, 0xc2, 0xa2,
	0x34, 0x42, 0xfb, 0x5f, 0x2d, 0x94, 0x94, 0xea, 0xf2, 0xda, 0x7a, 0x25, 0x5b, 0x5a, 0xe4, 0x5c,
	0x5b, 0x2d, 0xae, 0xac, 0x14, 0xd7, 0x4a, 0x52, 0x20, 0xf3, 0x32, 0x8c, 0x2f, 0x3a, 0x3f, 0xcf,
	0x21, 0x7e, 0xd6, 0x6b, 0xd2, 0xe9, 0xf0, 0x62, 0xb1, 0x92, 0x5f, 0xbb, 0x59, 0x90, 0x5f, 0x75,
	0xfa, 0x3a, 0x0a, 0xc1, 0x1b, 0x97, 0xa9, 0xea, 0x02, 0x44, 0xf2, 0x6b, 0xa5, 0xca, 0xfa, 0x8a,
	0x14, 0xc8, 0x54, 0x20, 0x76, 0x53, 0x6b, 0xdf, 0x34, 0xcd, 0xb6, 0x50, 0x27, 0xe9, 0x66, 0xb1,
	0xac, 0xdc, 0x94, 0xe5, 0xb2, 0x22, 0x08, 0x39, 0xe8, 0x53, 0x30, 0xe1, 0x56, 0x15, 0x4a, 0xd9,
	0xdc, 0x4a, 0x41, 0xa2, 0x76, 0x41, 0x0f, 0x7e, 0xb1, 0x58, 0x61, 0xa5, 0x81, 0xcc, 0x8f, 0xc0,
	0xa1, 0x8a, 0x66, 0x93, 0xaa, 0xc1, 0xfe, 0xdf, 0xd1, 0x75, 0xd2, 0x64, 0xd4, 0x9f, 0x81, 0x54,
	0xa5, 0x58, 0x2d, 0x28, 0xd5, 0x35, 0x85, 0xff, 0xbb, 0x5e, 0x2a, 0x15, 0x56, 0x94, 0x62, 0xb9,
	0x52, 0xc8, 0x2b, 0x6b, 0xb2, 0x52, 0xa9, 0xac, 0x48, 0x23, 0x74, 0xe2, 0xed, 0x0b, 0x25, 0x21,
	0x7c, 0x1c, 0x8e, 0x0e, 0xaa, 0xa6, 0xb8, 0x81, 0x74, 0x28, 0x1a, 0x94, 0x82, 0x99, 0x0c, 0x8c,
	0x55, 0x0c, 0xd3, 0xe6, 0x71, 0xd9, 0x04, 0xc0, 0x62, 0xa1, 0x92, 0x2f, 0x94, 0x16, 0x8b, 0xa5,
	0x6b, 0x5c, 0x63, 0xb2, 0xee, 0x27, 0xca, 0x14, 0xe1, 0x28, 0xef, 0x61, 0x41, 0xaf, 0xa9, 0x6d,
	0x4b, 0xfc, 0xb2, 0x00, 0xeb, 0xee, 0x38, 0x8c, 0xf1, 0xae, 0x95, 0x6f, 0x14, 0x39, 0xa2, 0xf8,
	0xac, 0xdc, 0x90, 0x18, 0x3b, 0x59, 0x9b, 0xcc, 0xfc, 0x97, 0x0b, 0x52, 0x30, 0xf3, 0x02, 0x40,
	0x95, 0xfd, 0xda, 0xa8, 0x23, 0xc7, 0xde, 0x22, 0x19, 0x87, 0xe8, 0x92, 0x5c, 0x28, 0xac, 0x16,
	0xd7, 0x57, 0xb9, 0x96, 0x16, 0x4a, 0xd5, 0x82, 0x5c, 0x96, 0x8b, 0x15, 0xca, 0xaf, 0x5f, 0x47,
	0x20, 0x55, 0xd5, 0x9d, 0xc2, 0x0e, 0x69, 0xf5, 0xde, 0x00, 0x9c, 0x80, 0x58, 0x35, 0x7b, 0xdb,
	0xb3, 0xd0, 0x8a, 0x02, 0xb9, 0x70, 0x6d, 0x7d, 0x25, 0x2b, 0x73, 0x3b, 0x99, 0x16, 0x14, 0x6e,
	0x17, 0x56, 0xcb, 0x55, 0x65, 0xbd, 0x74, 0xb3, 0x20, 0x17, 0x97, 0x8a, 0x05, 0xea, 0x7f, 0x1c,
	0x85, 0x29, 0x4f, 0x95, 0x5b, 0x41, 0x77, 0x84, 0x53, 0x7b, 0x2a, 0xf2, 0x59, 0xb6, 0xd4, 0x2c,
	0x65, 0x8b, 0x2b, 0x85, 0x45, 0x29, 0x84, 0x9f, 0x86, 0xa7, 0xf6, 0x83, 0x29, 0x0b, 0xbe, 0x85,
	0x33, 0x9f, 0x81, 0x68, 0xb9, 0xa9, 0xea, 0xce, 0x42, 0x40, 0x47, 0xc7, 0xdd, 0x90, 0x62, 0x69,
	0xb1, 0x78, 0xb3, 0xb8, 0xb8, 0x9e, 0x5d, 0xe1, 0x73, 0xa2, 0x5a, 0xc8, 0xae, 0xf2, 0x99, 0xb8,
	0x26, 0x5f, 0xcb, 0x96, 0x8a, 0x9f, 0x66, 0x94, 0x84, 0xad, 0xbe, 0x92, 0x2d, 0x31, 0xd3, 0x5e,
	0x59, 0x2f, 0x55, 0xca, 0x85, 0x3c, 0xef, 0x65, 0x28, 0x93, 0x82, 0x71, 0x7e, 0x09, 0x8a, 0xc5,
	0xbe, 0xd6, 0xda, 0x38, 0x02, 0x81, 0xc2, 0x2b, 0xd2, 0x08, 0xe5, 0x75, 0xa9, 0xf0, 0x8a, 0x84,
	0x32, 0x0d, 0x48, 0xf8, 0xef, 0x23, 0xe1, 0x69, 0x38, 0x54, 0x95, 0x0b, 0xa5, 0x45, 0xa5, 0x52,
	0x28, 0x55, 0x8b, 0xd4, 0x4f, 0x71, 0xd6, 0x88, 0x13, 0x30, 0xdd, 0x5f, 0x53, 0x5e, 0xab, 0x14,
	0xab, 0xc5, 0x9b, 0x05, 0xbe, 0x90, 0xef, 0xc1, 0x2b, 0x5c, 0xcb, 0xb2, 0xda, 0x40, 0xe6, 0x2d,
	0x04, 0xe3, 0xbe, 0x8b, 0x37, 0x54, 0xe5, 0xe5, 0xb5, 0xf5, 0x6a, 0x41, 0xc9, 0x56, 0xab, 0xb2,
	0x52, 0x5a, 0x53, 0xd6, 0xe8, 0x0a, 0x38, 0x0d, 0x87, 0x3c, 0xa5, 0xd9, 0xc5, 0x9b, 0x05, 0xb9,
	0x4a, 0x85, 0xcb, 0xf4, 0xd5, 0x53, 0x53, 0x2c, 0x55, 0xaa, 0xd9, 0x95, 0x15, 0x65, 0x99, 0x7a,
	0x65, 0x01, 0x7c, 0x1a, 0x4e, 0x0e, 0xa8, 0x5c, 0x5a, 0x93, 0x6f, 0x65, 0x65, 0xc6, 0x68, 0xc6,
	0x26, 0x0f, 0xc8, 0x6a, 0x41, 0xbe, 0x56, 0x50, 0xd6, 0x4a, 0x2b, 0xaf, 0x4a, 0xa1, 0xcc, 0x97,
	0x10, 0xc4, 0xbd, 0x97, 0xa0, 0xe8, 0x58, 0x4a, 0x85, 0xdb, 0x55, 0x65, 0x79, 0xad, 0xac, 0x88,
	0xe5, 0x46, 0xb9, 0x96, 0xad, 0x16, 0x6e, 0x65, 0xa9, 0x8f, 0x78, 0x1c, 0x8e, 0xba, 0xb5, 0xeb,
	0x6c, 0x83, 0x2c, 0x2d, 0x15, 0xaf, 0xad, 0xd3, 0x95, 0x06, 0x51, 0xcf, 0xca, 0xad, 0x2c, 0x15,
	0xaa, 0xb7, 0xd6, 0xe4, 0x1b, 0x4a, 0x91, 0x2a, 0xe9, 0x12, 0xf5, 0x46, 0x03, 0x38, 0x09, 0x52,
	0x8f, 0x74, 0xb1, 0x92, 0xcf, 0xca, 0x8b, 0x52, 0x50, 0x6c, 0x95, 0xa7, 0x3d, 0x84, 0x2b, 0xa5,
	0x6c, 0x95, 0xce, 0x4d, 0xb6, 0xe7, 0xe4, 0xa5, 0x10, 0x07, 0xc9, 0xdc, 0x82, 0xc9, 0x6c, 0xbd,
	0x6e, 0xe8, 0xc2, 0x6a, 0xa2, 0x1b, 0x19, 0x9b, 0x22, 0xd9, 0x8a, 0x23, 0xa5, 0x04, 0x40, 0xb6,
	0xe2, 0x2a, 0x18, 0xf5, 0x67, 0xc6, 0xb3, 0x15, 0xba, 0x70, 0x57, 0xf2, 0x72, 0x31, 0xc7, 0xb4,
	0x3a, 0x0e, 0xd1, 0x6c, 0x45, 0x29, 0xc8, 0xf2, 0x9a, 0x2c, 0x05, 0xd3, 0xa1, 0x68, 0x48, 0x0a,
	0x65, 0xee, 0x41, 0xd2, 0x4b, 0x98, 0x9d, 0x04, 0x55, 0x78, 0xdc, 0x63, 0x83, 0x4d, 0x22, 0x4e,
	0xc4, 0x69, 0x05, 0x43, 0x42, 0x14, 0x64, 0x57, 0x56, 0xd6, 0x6e, 0xb1, 0xa1, 0xbb, 0x2d, 0x29,
	0x8b, 0x85, 0x12, 0x9f, 0x3f, 0x87, 0x61, 0xd2, 0x2d, 0x2a, 0x3b, 0xc5, 0xd4, 0xc2, 0x8a, 0x8b,
	0xe2, 0xc2, 0xed, 0x62, 0xa5, 0x2a, 0x85, 0x32, 0x3f, 0x02, 0xc7, 0x7d, 0xe3, 0x72, 0x5a, 0x16,
	0xc1, 0x2a, 0x17, 0x81, 0x0f, 0xc2, 0xed, 0xc0, 0x7a, 0xa9, 0x57, 0x86, 0xa8, 0xf2, 0x78, 0xa1,
	0x5c, 0x26, 0x04, 0xf0, 0x53, 0x70, 0x3c, 0x5b, 0x51, 0xf2, 0xd9, 0x52, 0x9e, 0x2e, 0x71, 0x7b,
	0x00, 0x82, 0x99, 0x9f, 0x42, 0x80, 0xbd, 0x1d, 0xe0, 0x79, 0x9d, 0x82, 0x99, 0x59, 0x77, 0x9b,
	0xe4, 0x43, 0xcc, 0xe6, 0x3d, 0xa3, 0x9e, 0x82, 0x09, 0x5e, 0x54, 0xce, 0x65, 0xf3, 0x74, 0x88,
	0xaf, 0x72, 0x43, 0xac, 0xaf, 0x50, 0x59, 0x2f, 0x5f, 0x93, 0xb3, 0x8b, 0x05, 0x85, 0xce, 0x55,
	0x29, 0x48, 0x17, 0x87, 0x7e, 0x08, 0xb9, 0xf0, 0xca, 0x7a, 0xa1, 0x52, 0x55, 0x2a, 0x05, 0xf9,
	0x66, 0x31, 0x5f, 0x90, 0x42, 0x19, 0x1d, 0x26, 0xaa, 0x5a, 0x53, 0x74, 0x86, 0xcb, 0x9a, 0xee,
	0x64, 0xc5, 0x95, 0x82, 0xa7, 0x4f, 0x53, 0x30, 0xe1, 0x94, 0xf4, 0x7a, 0x45, 0x67, 0xb1, 0x28,
	0xf4, 0x35, 0x4c, 0x15, 0xf0, 0x48, 0x8f, 0x40, 0xd5, 0xab, 0x18, 0xc1, 0xcc, 0x29, 0x88, 0x56,
	0x76, 0xf5, 0xda, 0x2a, 0x75, 0xc1, 0xe9, 0x36, 0x5c, 0x58, 0x59, 0xe2, 0xdb, 0x6c, 0x25, 0x5f,
	0x5c, 0x95, 0x20, 0x63, 0x42, 0xe2, 0xba, 0xba, 0xad, 0x56, 0x58, 0x30, 0x8c, 0x41, 0x1d, 0x85,
	0xa9, 0x6c, 0xe5, 0xd5, 0x52, 0x5e, 0xb9, 0x4e, 0x15, 0x50, 0xc9, 0x67, 0xf3, 0xcb, 0x7c, 0x7b,
	0x38, 0x04, 0x92, 0x5b, 0xe1, 0x94, 0x22, 0x7c, 0x04, 0xf0, 0x00, 0xe8, 0x00, 0x1d, 0x43, 0x3f,
	0x30, 0x9f, 0x14, 0x23, 0x99, 0x2c, 0xc0, 0x12, 0x51, 0xed, 0x8e, 0x49, 0xaa, 0xea, 0x26, 0xed,
	0x8b, 0x18, 0x36, 0x5b, 0xc2, 0x6e, 0xf1, 0x9d, 0xbc, 0x2c, 0x17, 0x6e, 0x16, 0x0b, 0xb7, 0x38,
	0xa1, 0xb2, 0x5c, 0xbc, 0x99, 0xad, 0x16, 0x14, 0xa7, 0x30, 0x98, 0xb9, 0x05, 0x87, 0xbc, 0xb2,
	0xad, 0x6a, 0xc4, 0x35, 0x11, 0x4a, 0x6b, 0x4a, 0xb5, 0x58, 0x90, 0xb9, 0xed, 0x95, 0xcb, 0x56,
	0x8a, 0x74, 0x6b, 0x8c, 0x43, 0xb4, 0x52, 0xcd, 0x96, 0x16, 0xe9, 0xdc, 0xe4, 0xb3, 0x65, 0xf1,
	0x26, 0x55, 0x9d, 0x45, 0x6e, 0x53, 0x95, 0x65, 0xbe, 0x01, 0x85, 0x32, 0xe7, 0x21, 0x91, 0x6f,
	0x1a, 0x9d, 0xfa, 0x8a, 0xa6, 0xdf, 0xe1, 0xe2, 0x89, 0x40, 0x60, 0xbd, 0xcc, 0x79, 0xb6, 0x48,
	0xb7, 0x1b, 0x46, 0x6c, 0xb1, 0xc0, 0x24, 0xb0, 0x28, 0x05, 0x32, 0x79, 0x88, 0x57, 0xb4, 0x4d,
	0xbd, 0xd3, 0x16, 0x6f, 0x44, 0x62, 0x48, 0xac, 0xc9, 0xc5, 0x6b, 0xc5, 0x92, 0x7f, 0x83, 0x12,
	0x65, 0x4b, 0x17, 0x6f, 0xe7, 0xf9, 0x3e, 0x27, 0x0a, 0xb2, 0xb7, 0x2a, 0x52, 0x20, 0xf7, 0xff,
	0xa2, 0x47, 0x7f, 0x78, 0x6a, 0xe4, 0xfd, 0x3f, 0x3c, 0x35, 0xf2, 0xad, 0x3f, 0x3c, 0x85, 0xee,
	0x3f, 0x3e, 0x85, 0xbe, 0xf4, 0xf8, 0x14, 0xfa, 0xca, 0xe3, 0x53, 0xe8, 0xd1, 0xe3, 0x53, 0xe8,
	0xfd, 0xc7, 0xa7, 0xd0, 0x37, 0x1e, 0x9f, 0x42, 0xdf, 0x7c, 0x7c, 0x6a, 0xe4, 0x5b, 0x8f, 0x4f,
	0xa1, 0xcf, 0x7f, 0x70, 0x6a, 0xe4, 0xdd, 0x0f, 0x4e, 0xa1, 0x47, 0x1f, 0x9c, 0x1a, 0x79, 0xff,
	0x83, 0x53, 0x23, 0x9f, 0xce, 0x6f, 0x1a, 0xed, 0x3b, 0x9b, 0xb3, 0xce, 0x43, 0xab, 0xb3, 0x1d,
	0xeb, 0x1c, 0xfb, 0xa3, 0x61, 0x98, 0xad, 0xb3, 0x4e, 0x60, 0xfb, 0xac, 0x53, 0x7d, 0xae, 0xbd,
	0xb1, 0x69, 0x9c, 0x23, 0x3b, 0x36, 0x0f, 0xdc, 0x9d, 0xe3, 0xff, 0x6c, 0x44, 0x58, 0x10, 0xff,
	0xc2, 0xff, 0x0a, 0x00, 0x00, 0xff, 0xff, 0x8a, 0xd9, 0xc7, 0x4f, 0x2c, 0x92, 0x00, 0x00,
}

func (x HttpMethod) String() string {
	s, ok := HttpMethod_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x BotHttpMethod) String() string {
	s, ok := BotHttpMethod_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x OpenApiValidationProperties) String() string {
	s, ok := OpenApiValidationProperties_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x HttpStatusCode) String() string {
	s, ok := HttpStatusCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x HttpResponseCodeClass) String() string {
	s, ok := HttpResponseCodeClass_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x HttpSections) String() string {
	s, ok := HttpSections_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x StatusPublishType) String() string {
	s, ok := StatusPublishType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SecretEncodingType) String() string {
	s, ok := SecretEncodingType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x URLSchemeType) String() string {
	s, ok := URLSchemeType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TlsProtocol) String() string {
	s, ok := TlsProtocol_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x XfccElement) String() string {
	s, ok := XfccElement_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x HashAlgorithm) String() string {
	s, ok := HashAlgorithm_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RoutingPriority) String() string {
	s, ok := RoutingPriority_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DenominatorType) String() string {
	s, ok := DenominatorType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DiscoveryType) String() string {
	s, ok := DiscoveryType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x VipVrrpType) String() string {
	s, ok := VipVrrpType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SiteToSiteTunnelType) String() string {
	s, ok := SiteToSiteTunnelType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SortOrder) String() string {
	s, ok := SortOrder_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TunnelEncapsulationType) String() string {
	s, ok := TunnelEncapsulationType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TenantType) String() string {
	s, ok := TenantType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TaxExemptionType) String() string {
	s, ok := TaxExemptionType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PlanType) String() string {
	s, ok := PlanType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MetricLabelOp) String() string {
	s, ok := MetricLabelOp_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TrendSentiment) String() string {
	s, ok := TrendSentiment_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RouteAttrType) String() string {
	s, ok := RouteAttrType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NextHopTypes) String() string {
	s, ok := NextHopTypes_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x AddonServiceState) String() string {
	s, ok := AddonServiceState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x AddonServiceCheckSubscribe) String() string {
	s, ok := AddonServiceCheckSubscribe_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x AddonServiceSubscribeAction) String() string {
	s, ok := AddonServiceSubscribeAction_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x AddonServiceAccess) String() string {
	s, ok := AddonServiceAccess_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TileAccessState) String() string {
	s, ok := TileAccessState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SyncMode) String() string {
	s, ok := SyncMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x JavaScriptMode) String() string {
	s, ok := JavaScriptMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x FeatureTag) String() string {
	s, ok := FeatureTag_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x AddonServiceTierType) String() string {
	s, ok := AddonServiceTierType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CloudLinkState) String() string {
	s, ok := CloudLinkState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SignupOrigin) String() string {
	s, ok := SignupOrigin_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Empty) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Empty)
	if !ok {
		that2, ok := that.(Empty)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ObjectRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ObjectRefType)
	if !ok {
		that2, ok := that.(ObjectRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if this.Tenant != that1.Tenant {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *LabelSelectorType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LabelSelectorType)
	if !ok {
		that2, ok := that.(LabelSelectorType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Expressions) != len(that1.Expressions) {
		return false
	}
	for i := range this.Expressions {
		if this.Expressions[i] != that1.Expressions[i] {
			return false
		}
	}
	return true
}
func (this *LabelMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LabelMatcherType)
	if !ok {
		that2, ok := that.(LabelMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Keys) != len(that1.Keys) {
		return false
	}
	for i := range this.Keys {
		if this.Keys[i] != that1.Keys[i] {
			return false
		}
	}
	return true
}
func (this *ConditionType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConditionType)
	if !ok {
		that2, ok := that.(ConditionType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	if !this.LastUpdateTime.Equal(that1.LastUpdateTime) {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if this.ServiceName != that1.ServiceName {
		return false
	}
	return true
}
func (this *StatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StatusType)
	if !ok {
		that2, ok := that.(StatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	return true
}
func (this *InitializerType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InitializerType)
	if !ok {
		that2, ok := that.(InitializerType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *InitializersType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InitializersType)
	if !ok {
		that2, ok := that.(InitializersType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Pending) != len(that1.Pending) {
		return false
	}
	for i := range this.Pending {
		if !this.Pending[i].Equal(that1.Pending[i]) {
			return false
		}
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	return true
}
func (this *StatusMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StatusMetaType)
	if !ok {
		that2, ok := that.(StatusMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if this.CreatorClass != that1.CreatorClass {
		return false
	}
	if this.CreatorId != that1.CreatorId {
		return false
	}
	if this.StatusId != that1.StatusId {
		return false
	}
	if !this.CreationTimestamp.Equal(that1.CreationTimestamp) {
		return false
	}
	if this.Publish != that1.Publish {
		return false
	}
	if this.VtrpId != that1.VtrpId {
		return false
	}
	if this.VtrpStale != that1.VtrpStale {
		return false
	}
	return true
}
func (this *ObjectMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ObjectMetaType)
	if !ok {
		that2, ok := that.(ObjectMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Annotations) != len(that1.Annotations) {
		return false
	}
	for i := range this.Annotations {
		if this.Annotations[i] != that1.Annotations[i] {
			return false
		}
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Disable != that1.Disable {
		return false
	}
	return true
}
func (this *ListMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListMetaType)
	if !ok {
		that2, ok := that.(ListMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ResourceVersion != that1.ResourceVersion {
		return false
	}
	if this.NextPage != that1.NextPage {
		return false
	}
	return true
}
func (this *ObjectGetMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ObjectGetMetaType)
	if !ok {
		that2, ok := that.(ObjectGetMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Annotations) != len(that1.Annotations) {
		return false
	}
	for i := range this.Annotations {
		if this.Annotations[i] != that1.Annotations[i] {
			return false
		}
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Disable != that1.Disable {
		return false
	}
	return true
}
func (this *ObjectCreateMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ObjectCreateMetaType)
	if !ok {
		that2, ok := that.(ObjectCreateMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Annotations) != len(that1.Annotations) {
		return false
	}
	for i := range this.Annotations {
		if this.Annotations[i] != that1.Annotations[i] {
			return false
		}
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Disable != that1.Disable {
		return false
	}
	return true
}
func (this *ObjectReplaceMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ObjectReplaceMetaType)
	if !ok {
		that2, ok := that.(ObjectReplaceMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Annotations) != len(that1.Annotations) {
		return false
	}
	for i := range this.Annotations {
		if this.Annotations[i] != that1.Annotations[i] {
			return false
		}
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Disable != that1.Disable {
		return false
	}
	return true
}
func (this *MessageMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MessageMetaType)
	if !ok {
		that2, ok := that.(MessageMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Disable != that1.Disable {
		return false
	}
	return true
}
func (this *ViewRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ViewRefType)
	if !ok {
		that2, ok := that.(ViewRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *KubeRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*KubeRefType)
	if !ok {
		that2, ok := that.(KubeRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *SystemObjectMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SystemObjectMetaType)
	if !ok {
		that2, ok := that.(SystemObjectMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if !this.CreationTimestamp.Equal(that1.CreationTimestamp) {
		return false
	}
	if !this.DeletionTimestamp.Equal(that1.DeletionTimestamp) {
		return false
	}
	if !this.ModificationTimestamp.Equal(that1.ModificationTimestamp) {
		return false
	}
	if !this.Initializers.Equal(that1.Initializers) {
		return false
	}
	if len(this.Finalizers) != len(that1.Finalizers) {
		return false
	}
	for i := range this.Finalizers {
		if this.Finalizers[i] != that1.Finalizers[i] {
			return false
		}
	}
	if this.Tenant != that1.Tenant {
		return false
	}
	if this.CreatorClass != that1.CreatorClass {
		return false
	}
	if this.CreatorId != that1.CreatorId {
		return false
	}
	if this.CreatorCookie != that1.CreatorCookie {
		return false
	}
	if this.TraceInfo != that1.TraceInfo {
		return false
	}
	if this.ObjectIndex != that1.ObjectIndex {
		return false
	}
	if len(this.Namespace) != len(that1.Namespace) {
		return false
	}
	for i := range this.Namespace {
		if !this.Namespace[i].Equal(that1.Namespace[i]) {
			return false
		}
	}
	if !this.OwnerView.Equal(that1.OwnerView) {
		return false
	}
	if this.SreDisable != that1.SreDisable {
		return false
	}
	if this.VtrpId != that1.VtrpId {
		return false
	}
	if this.VtrpStale != that1.VtrpStale {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	return true
}
func (this *SystemObjectGetMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SystemObjectGetMetaType)
	if !ok {
		that2, ok := that.(SystemObjectGetMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if !this.CreationTimestamp.Equal(that1.CreationTimestamp) {
		return false
	}
	if !this.DeletionTimestamp.Equal(that1.DeletionTimestamp) {
		return false
	}
	if !this.ModificationTimestamp.Equal(that1.ModificationTimestamp) {
		return false
	}
	if !this.Initializers.Equal(that1.Initializers) {
		return false
	}
	if len(this.Finalizers) != len(that1.Finalizers) {
		return false
	}
	for i := range this.Finalizers {
		if this.Finalizers[i] != that1.Finalizers[i] {
			return false
		}
	}
	if this.Tenant != that1.Tenant {
		return false
	}
	if this.CreatorClass != that1.CreatorClass {
		return false
	}
	if this.CreatorId != that1.CreatorId {
		return false
	}
	if this.ObjectIndex != that1.ObjectIndex {
		return false
	}
	if !this.OwnerView.Equal(that1.OwnerView) {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	return true
}
func (this *AuthnTypeBasicAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthnTypeBasicAuth)
	if !ok {
		that2, ok := that.(AuthnTypeBasicAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if !this.Password.Equal(that1.Password) {
		return false
	}
	return true
}
func (this *AuthnTypeHeaders) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthnTypeHeaders)
	if !ok {
		that2, ok := that.(AuthnTypeHeaders)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	return true
}
func (this *AuthnTypeQueryParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthnTypeQueryParams)
	if !ok {
		that2, ok := that.(AuthnTypeQueryParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.QueryParams) != len(that1.QueryParams) {
		return false
	}
	for i := range this.QueryParams {
		if !this.QueryParams[i].Equal(that1.QueryParams[i]) {
			return false
		}
	}
	return true
}
func (this *BlindfoldSecretInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BlindfoldSecretInfoType)
	if !ok {
		that2, ok := that.(BlindfoldSecretInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DecryptionProvider != that1.DecryptionProvider {
		return false
	}
	if this.StoreProvider != that1.StoreProvider {
		return false
	}
	if this.Location != that1.Location {
		return false
	}
	return true
}
func (this *VaultSecretInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultSecretInfoType)
	if !ok {
		that2, ok := that.(VaultSecretInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Provider != that1.Provider {
		return false
	}
	if this.Location != that1.Location {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.SecretEncoding != that1.SecretEncoding {
		return false
	}
	return true
}
func (this *ClearSecretInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClearSecretInfoType)
	if !ok {
		that2, ok := that.(ClearSecretInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Provider != that1.Provider {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	return true
}
func (this *WingmanSecretInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WingmanSecretInfoType)
	if !ok {
		that2, ok := that.(WingmanSecretInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *SecretType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecretType)
	if !ok {
		that2, ok := that.(SecretType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.SecretInfoOneof == nil {
		if this.SecretInfoOneof != nil {
			return false
		}
	} else if this.SecretInfoOneof == nil {
		return false
	} else if !this.SecretInfoOneof.Equal(that1.SecretInfoOneof) {
		return false
	}
	if !this.BlindfoldSecretInfoInternal.Equal(that1.BlindfoldSecretInfoInternal) {
		return false
	}
	if this.SecretEncodingType != that1.SecretEncodingType {
		return false
	}
	return true
}
func (this *SecretType_BlindfoldSecretInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecretType_BlindfoldSecretInfo)
	if !ok {
		that2, ok := that.(SecretType_BlindfoldSecretInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BlindfoldSecretInfo.Equal(that1.BlindfoldSecretInfo) {
		return false
	}
	return true
}
func (this *SecretType_VaultSecretInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecretType_VaultSecretInfo)
	if !ok {
		that2, ok := that.(SecretType_VaultSecretInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VaultSecretInfo.Equal(that1.VaultSecretInfo) {
		return false
	}
	return true
}
func (this *SecretType_ClearSecretInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecretType_ClearSecretInfo)
	if !ok {
		that2, ok := that.(SecretType_ClearSecretInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClearSecretInfo.Equal(that1.ClearSecretInfo) {
		return false
	}
	return true
}
func (this *SecretType_WingmanSecretInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecretType_WingmanSecretInfo)
	if !ok {
		that2, ok := that.(SecretType_WingmanSecretInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.WingmanSecretInfo.Equal(that1.WingmanSecretInfo) {
		return false
	}
	return true
}
func (this *NetworkRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkRefType)
	if !ok {
		that2, ok := that.(NetworkRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ref) != len(that1.Ref) {
		return false
	}
	for i := range this.Ref {
		if !this.Ref[i].Equal(that1.Ref[i]) {
			return false
		}
	}
	return true
}
func (this *SiteRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteRefType)
	if !ok {
		that2, ok := that.(SiteRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ref) != len(that1.Ref) {
		return false
	}
	for i := range this.Ref {
		if !this.Ref[i].Equal(that1.Ref[i]) {
			return false
		}
	}
	if this.NetworkType != that1.NetworkType {
		return false
	}
	if that1.InternetVipChoice == nil {
		if this.InternetVipChoice != nil {
			return false
		}
	} else if this.InternetVipChoice == nil {
		return false
	} else if !this.InternetVipChoice.Equal(that1.InternetVipChoice) {
		return false
	}
	if len(this.Refs) != len(that1.Refs) {
		return false
	}
	for i := range this.Refs {
		if !this.Refs[i].Equal(that1.Refs[i]) {
			return false
		}
	}
	return true
}
func (this *SiteRefType_DisableInternetVip) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteRefType_DisableInternetVip)
	if !ok {
		that2, ok := that.(SiteRefType_DisableInternetVip)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableInternetVip.Equal(that1.DisableInternetVip) {
		return false
	}
	return true
}
func (this *SiteRefType_EnableInternetVip) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteRefType_EnableInternetVip)
	if !ok {
		that2, ok := that.(SiteRefType_EnableInternetVip)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableInternetVip.Equal(that1.EnableInternetVip) {
		return false
	}
	return true
}
func (this *IpPrefixSetRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpPrefixSetRefType)
	if !ok {
		that2, ok := that.(IpPrefixSetRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ref) != len(that1.Ref) {
		return false
	}
	for i := range this.Ref {
		if !this.Ref[i].Equal(that1.Ref[i]) {
			return false
		}
	}
	return true
}
func (this *VSiteRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VSiteRefType)
	if !ok {
		that2, ok := that.(VSiteRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ref) != len(that1.Ref) {
		return false
	}
	for i := range this.Ref {
		if !this.Ref[i].Equal(that1.Ref[i]) {
			return false
		}
	}
	if this.NetworkType != that1.NetworkType {
		return false
	}
	if that1.InternetVipChoice == nil {
		if this.InternetVipChoice != nil {
			return false
		}
	} else if this.InternetVipChoice == nil {
		return false
	} else if !this.InternetVipChoice.Equal(that1.InternetVipChoice) {
		return false
	}
	if len(this.Refs) != len(that1.Refs) {
		return false
	}
	for i := range this.Refs {
		if !this.Refs[i].Equal(that1.Refs[i]) {
			return false
		}
	}
	return true
}
func (this *VSiteRefType_DisableInternetVip) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VSiteRefType_DisableInternetVip)
	if !ok {
		that2, ok := that.(VSiteRefType_DisableInternetVip)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableInternetVip.Equal(that1.DisableInternetVip) {
		return false
	}
	return true
}
func (this *VSiteRefType_EnableInternetVip) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VSiteRefType_EnableInternetVip)
	if !ok {
		that2, ok := that.(VSiteRefType_EnableInternetVip)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableInternetVip.Equal(that1.EnableInternetVip) {
		return false
	}
	return true
}
func (this *PolicerRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PolicerRefType)
	if !ok {
		that2, ok := that.(PolicerRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ref) != len(that1.Ref) {
		return false
	}
	for i := range this.Ref {
		if !this.Ref[i].Equal(that1.Ref[i]) {
			return false
		}
	}
	return true
}
func (this *ProtocolPolicerRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtocolPolicerRefType)
	if !ok {
		that2, ok := that.(ProtocolPolicerRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ref) != len(that1.Ref) {
		return false
	}
	for i := range this.Ref {
		if !this.Ref[i].Equal(that1.Ref[i]) {
			return false
		}
	}
	return true
}
func (this *NetworkSiteRefSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkSiteRefSelector)
	if !ok {
		that2, ok := that.(NetworkSiteRefSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.RefOrSelector == nil {
		if this.RefOrSelector != nil {
			return false
		}
	} else if this.RefOrSelector == nil {
		return false
	} else if !this.RefOrSelector.Equal(that1.RefOrSelector) {
		return false
	}
	return true
}
func (this *NetworkSiteRefSelector_VirtualNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkSiteRefSelector_VirtualNetwork)
	if !ok {
		that2, ok := that.(NetworkSiteRefSelector_VirtualNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VirtualNetwork.Equal(that1.VirtualNetwork) {
		return false
	}
	return true
}
func (this *NetworkSiteRefSelector_Site) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkSiteRefSelector_Site)
	if !ok {
		that2, ok := that.(NetworkSiteRefSelector_Site)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Site.Equal(that1.Site) {
		return false
	}
	return true
}
func (this *NetworkSiteRefSelector_VirtualSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkSiteRefSelector_VirtualSite)
	if !ok {
		that2, ok := that.(NetworkSiteRefSelector_VirtualSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VirtualSite.Equal(that1.VirtualSite) {
		return false
	}
	return true
}
func (this *SiteVirtualSiteRefSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteVirtualSiteRefSelector)
	if !ok {
		that2, ok := that.(SiteVirtualSiteRefSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.RefOrSelector == nil {
		if this.RefOrSelector != nil {
			return false
		}
	} else if this.RefOrSelector == nil {
		return false
	} else if !this.RefOrSelector.Equal(that1.RefOrSelector) {
		return false
	}
	return true
}
func (this *SiteVirtualSiteRefSelector_Site) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteVirtualSiteRefSelector_Site)
	if !ok {
		that2, ok := that.(SiteVirtualSiteRefSelector_Site)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Site.Equal(that1.Site) {
		return false
	}
	return true
}
func (this *SiteVirtualSiteRefSelector_VirtualSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteVirtualSiteRefSelector_VirtualSite)
	if !ok {
		that2, ok := that.(SiteVirtualSiteRefSelector_VirtualSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VirtualSite.Equal(that1.VirtualSite) {
		return false
	}
	return true
}
func (this *HeaderManipulationOptionType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderManipulationOptionType)
	if !ok {
		that2, ok := that.(HeaderManipulationOptionType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.ValueChoice == nil {
		if this.ValueChoice != nil {
			return false
		}
	} else if this.ValueChoice == nil {
		return false
	} else if !this.ValueChoice.Equal(that1.ValueChoice) {
		return false
	}
	if this.Append != that1.Append {
		return false
	}
	return true
}
func (this *HeaderManipulationOptionType_Value) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderManipulationOptionType_Value)
	if !ok {
		that2, ok := that.(HeaderManipulationOptionType_Value)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *HeaderManipulationOptionType_SecretValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderManipulationOptionType_SecretValue)
	if !ok {
		that2, ok := that.(HeaderManipulationOptionType_SecretValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SecretValue.Equal(that1.SecretValue) {
		return false
	}
	return true
}
func (this *CookieManipulationOptionType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieManipulationOptionType)
	if !ok {
		that2, ok := that.(CookieManipulationOptionType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.Samesite == nil {
		if this.Samesite != nil {
			return false
		}
	} else if this.Samesite == nil {
		return false
	} else if !this.Samesite.Equal(that1.Samesite) {
		return false
	}
	if that1.Secure == nil {
		if this.Secure != nil {
			return false
		}
	} else if this.Secure == nil {
		return false
	} else if !this.Secure.Equal(that1.Secure) {
		return false
	}
	if that1.Httponly == nil {
		if this.Httponly != nil {
			return false
		}
	} else if this.Httponly == nil {
		return false
	} else if !this.Httponly.Equal(that1.Httponly) {
		return false
	}
	if that1.MaxAge == nil {
		if this.MaxAge != nil {
			return false
		}
	} else if this.MaxAge == nil {
		return false
	} else if !this.MaxAge.Equal(that1.MaxAge) {
		return false
	}
	if that1.CookieTampering == nil {
		if this.CookieTampering != nil {
			return false
		}
	} else if this.CookieTampering == nil {
		return false
	} else if !this.CookieTampering.Equal(that1.CookieTampering) {
		return false
	}
	return true
}
func (this *CookieManipulationOptionType_IgnoreSamesite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieManipulationOptionType_IgnoreSamesite)
	if !ok {
		that2, ok := that.(CookieManipulationOptionType_IgnoreSamesite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IgnoreSamesite.Equal(that1.IgnoreSamesite) {
		return false
	}
	return true
}
func (this *CookieManipulationOptionType_SamesiteStrict) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieManipulationOptionType_SamesiteStrict)
	if !ok {
		that2, ok := that.(CookieManipulationOptionType_SamesiteStrict)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SamesiteStrict.Equal(that1.SamesiteStrict) {
		return false
	}
	return true
}
func (this *CookieManipulationOptionType_SamesiteLax) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieManipulationOptionType_SamesiteLax)
	if !ok {
		that2, ok := that.(CookieManipulationOptionType_SamesiteLax)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SamesiteLax.Equal(that1.SamesiteLax) {
		return false
	}
	return true
}
func (this *CookieManipulationOptionType_SamesiteNone) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieManipulationOptionType_SamesiteNone)
	if !ok {
		that2, ok := that.(CookieManipulationOptionType_SamesiteNone)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SamesiteNone.Equal(that1.SamesiteNone) {
		return false
	}
	return true
}
func (this *CookieManipulationOptionType_IgnoreSecure) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieManipulationOptionType_IgnoreSecure)
	if !ok {
		that2, ok := that.(CookieManipulationOptionType_IgnoreSecure)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IgnoreSecure.Equal(that1.IgnoreSecure) {
		return false
	}
	return true
}
func (this *CookieManipulationOptionType_AddSecure) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieManipulationOptionType_AddSecure)
	if !ok {
		that2, ok := that.(CookieManipulationOptionType_AddSecure)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AddSecure.Equal(that1.AddSecure) {
		return false
	}
	return true
}
func (this *CookieManipulationOptionType_IgnoreHttponly) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieManipulationOptionType_IgnoreHttponly)
	if !ok {
		that2, ok := that.(CookieManipulationOptionType_IgnoreHttponly)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IgnoreHttponly.Equal(that1.IgnoreHttponly) {
		return false
	}
	return true
}
func (this *CookieManipulationOptionType_AddHttponly) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieManipulationOptionType_AddHttponly)
	if !ok {
		that2, ok := that.(CookieManipulationOptionType_AddHttponly)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AddHttponly.Equal(that1.AddHttponly) {
		return false
	}
	return true
}
func (this *CookieManipulationOptionType_IgnoreMaxAge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieManipulationOptionType_IgnoreMaxAge)
	if !ok {
		that2, ok := that.(CookieManipulationOptionType_IgnoreMaxAge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.IgnoreMaxAge.Equal(that1.IgnoreMaxAge) {
		return false
	}
	return true
}
func (this *CookieManipulationOptionType_MaxAgeValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieManipulationOptionType_MaxAgeValue)
	if !ok {
		that2, ok := that.(CookieManipulationOptionType_MaxAgeValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MaxAgeValue != that1.MaxAgeValue {
		return false
	}
	return true
}
func (this *CookieManipulationOptionType_DisableTamperingProtection) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieManipulationOptionType_DisableTamperingProtection)
	if !ok {
		that2, ok := that.(CookieManipulationOptionType_DisableTamperingProtection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableTamperingProtection.Equal(that1.DisableTamperingProtection) {
		return false
	}
	return true
}
func (this *CookieManipulationOptionType_EnableTamperingProtection) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CookieManipulationOptionType_EnableTamperingProtection)
	if !ok {
		that2, ok := that.(CookieManipulationOptionType_EnableTamperingProtection)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableTamperingProtection.Equal(that1.EnableTamperingProtection) {
		return false
	}
	return true
}
func (this *TrustedCAList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TrustedCAList)
	if !ok {
		that2, ok := that.(TrustedCAList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.TrustedCaList) != len(that1.TrustedCaList) {
		return false
	}
	for i := range this.TrustedCaList {
		if !this.TrustedCaList[i].Equal(that1.TrustedCaList[i]) {
			return false
		}
	}
	return true
}
func (this *TlsValidationParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsValidationParamsType)
	if !ok {
		that2, ok := that.(TlsValidationParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.TrustedCaChoice == nil {
		if this.TrustedCaChoice != nil {
			return false
		}
	} else if this.TrustedCaChoice == nil {
		return false
	} else if !this.TrustedCaChoice.Equal(that1.TrustedCaChoice) {
		return false
	}
	if this.SkipHostnameVerification != that1.SkipHostnameVerification {
		return false
	}
	if len(this.VerifySubjectAltNames) != len(that1.VerifySubjectAltNames) {
		return false
	}
	for i := range this.VerifySubjectAltNames {
		if this.VerifySubjectAltNames[i] != that1.VerifySubjectAltNames[i] {
			return false
		}
	}
	if this.UseVolterraTrustedCaUrl != that1.UseVolterraTrustedCaUrl {
		return false
	}
	return true
}
func (this *TlsValidationParamsType_TrustedCaUrl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsValidationParamsType_TrustedCaUrl)
	if !ok {
		that2, ok := that.(TlsValidationParamsType_TrustedCaUrl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TrustedCaUrl != that1.TrustedCaUrl {
		return false
	}
	return true
}
func (this *TlsValidationParamsType_TrustedCa) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsValidationParamsType_TrustedCa)
	if !ok {
		that2, ok := that.(TlsValidationParamsType_TrustedCa)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TrustedCa.Equal(that1.TrustedCa) {
		return false
	}
	return true
}
func (this *HashAlgorithms) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HashAlgorithms)
	if !ok {
		that2, ok := that.(HashAlgorithms)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.HashAlgorithms) != len(that1.HashAlgorithms) {
		return false
	}
	for i := range this.HashAlgorithms {
		if this.HashAlgorithms[i] != that1.HashAlgorithms[i] {
			return false
		}
	}
	return true
}
func (this *TlsCertificateType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsCertificateType)
	if !ok {
		that2, ok := that.(TlsCertificateType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CertificateUrl != that1.CertificateUrl {
		return false
	}
	if !this.PrivateKey.Equal(that1.PrivateKey) {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if that1.OcspStaplingChoice == nil {
		if this.OcspStaplingChoice != nil {
			return false
		}
	} else if this.OcspStaplingChoice == nil {
		return false
	} else if !this.OcspStaplingChoice.Equal(that1.OcspStaplingChoice) {
		return false
	}
	return true
}
func (this *TlsCertificateType_UseSystemDefaults) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsCertificateType_UseSystemDefaults)
	if !ok {
		that2, ok := that.(TlsCertificateType_UseSystemDefaults)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UseSystemDefaults.Equal(that1.UseSystemDefaults) {
		return false
	}
	return true
}
func (this *TlsCertificateType_DisableOcspStapling) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsCertificateType_DisableOcspStapling)
	if !ok {
		that2, ok := that.(TlsCertificateType_DisableOcspStapling)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableOcspStapling.Equal(that1.DisableOcspStapling) {
		return false
	}
	return true
}
func (this *TlsCertificateType_CustomHashAlgorithms) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsCertificateType_CustomHashAlgorithms)
	if !ok {
		that2, ok := that.(TlsCertificateType_CustomHashAlgorithms)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CustomHashAlgorithms.Equal(that1.CustomHashAlgorithms) {
		return false
	}
	return true
}
func (this *DomainType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DomainType)
	if !ok {
		that2, ok := that.(DomainType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.DomainChoice == nil {
		if this.DomainChoice != nil {
			return false
		}
	} else if this.DomainChoice == nil {
		return false
	} else if !this.DomainChoice.Equal(that1.DomainChoice) {
		return false
	}
	return true
}
func (this *DomainType_ExactValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DomainType_ExactValue)
	if !ok {
		that2, ok := that.(DomainType_ExactValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExactValue != that1.ExactValue {
		return false
	}
	return true
}
func (this *DomainType_SuffixValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DomainType_SuffixValue)
	if !ok {
		that2, ok := that.(DomainType_SuffixValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SuffixValue != that1.SuffixValue {
		return false
	}
	return true
}
func (this *DomainType_RegexValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DomainType_RegexValue)
	if !ok {
		that2, ok := that.(DomainType_RegexValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RegexValue != that1.RegexValue {
		return false
	}
	return true
}
func (this *L4DestType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*L4DestType)
	if !ok {
		that2, ok := that.(L4DestType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Prefixes) != len(that1.Prefixes) {
		return false
	}
	for i := range this.Prefixes {
		if this.Prefixes[i] != that1.Prefixes[i] {
			return false
		}
	}
	if this.PortRanges != that1.PortRanges {
		return false
	}
	return true
}
func (this *TlsInterceptionRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionRule)
	if !ok {
		that2, ok := that.(TlsInterceptionRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DomainMatch.Equal(that1.DomainMatch) {
		return false
	}
	if that1.EnableDisableChoice == nil {
		if this.EnableDisableChoice != nil {
			return false
		}
	} else if this.EnableDisableChoice == nil {
		return false
	} else if !this.EnableDisableChoice.Equal(that1.EnableDisableChoice) {
		return false
	}
	return true
}
func (this *TlsInterceptionRule_DisableInterception) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionRule_DisableInterception)
	if !ok {
		that2, ok := that.(TlsInterceptionRule_DisableInterception)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableInterception.Equal(that1.DisableInterception) {
		return false
	}
	return true
}
func (this *TlsInterceptionRule_EnableInterception) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionRule_EnableInterception)
	if !ok {
		that2, ok := that.(TlsInterceptionRule_EnableInterception)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableInterception.Equal(that1.EnableInterception) {
		return false
	}
	return true
}
func (this *TlsInterceptionPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionPolicy)
	if !ok {
		that2, ok := that.(TlsInterceptionPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.InterceptionRules) != len(that1.InterceptionRules) {
		return false
	}
	for i := range this.InterceptionRules {
		if !this.InterceptionRules[i].Equal(that1.InterceptionRules[i]) {
			return false
		}
	}
	return true
}
func (this *TlsInterceptionType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionType)
	if !ok {
		that2, ok := that.(TlsInterceptionType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.InterceptionPolicyChoice == nil {
		if this.InterceptionPolicyChoice != nil {
			return false
		}
	} else if this.InterceptionPolicyChoice == nil {
		return false
	} else if !this.InterceptionPolicyChoice.Equal(that1.InterceptionPolicyChoice) {
		return false
	}
	if that1.SigningCertChoice == nil {
		if this.SigningCertChoice != nil {
			return false
		}
	} else if this.SigningCertChoice == nil {
		return false
	} else if !this.SigningCertChoice.Equal(that1.SigningCertChoice) {
		return false
	}
	if that1.TrustedCaChoice == nil {
		if this.TrustedCaChoice != nil {
			return false
		}
	} else if this.TrustedCaChoice == nil {
		return false
	} else if !this.TrustedCaChoice.Equal(that1.TrustedCaChoice) {
		return false
	}
	return true
}
func (this *TlsInterceptionType_EnableForAllDomains) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionType_EnableForAllDomains)
	if !ok {
		that2, ok := that.(TlsInterceptionType_EnableForAllDomains)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableForAllDomains.Equal(that1.EnableForAllDomains) {
		return false
	}
	return true
}
func (this *TlsInterceptionType_Policy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionType_Policy)
	if !ok {
		that2, ok := that.(TlsInterceptionType_Policy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Policy.Equal(that1.Policy) {
		return false
	}
	return true
}
func (this *TlsInterceptionType_CustomCertificate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionType_CustomCertificate)
	if !ok {
		that2, ok := that.(TlsInterceptionType_CustomCertificate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CustomCertificate.Equal(that1.CustomCertificate) {
		return false
	}
	return true
}
func (this *TlsInterceptionType_VolterraCertificate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionType_VolterraCertificate)
	if !ok {
		that2, ok := that.(TlsInterceptionType_VolterraCertificate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VolterraCertificate.Equal(that1.VolterraCertificate) {
		return false
	}
	return true
}
func (this *TlsInterceptionType_TrustedCaUrl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionType_TrustedCaUrl)
	if !ok {
		that2, ok := that.(TlsInterceptionType_TrustedCaUrl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TrustedCaUrl != that1.TrustedCaUrl {
		return false
	}
	return true
}
func (this *TlsInterceptionType_VolterraTrustedCa) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionType_VolterraTrustedCa)
	if !ok {
		that2, ok := that.(TlsInterceptionType_VolterraTrustedCa)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VolterraTrustedCa.Equal(that1.VolterraTrustedCa) {
		return false
	}
	return true
}
func (this *FractionalPercent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FractionalPercent)
	if !ok {
		that2, ok := that.(FractionalPercent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Numerator != that1.Numerator {
		return false
	}
	if this.Denominator != that1.Denominator {
		return false
	}
	return true
}
func (this *BufferConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BufferConfigType)
	if !ok {
		that2, ok := that.(BufferConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Disabled != that1.Disabled {
		return false
	}
	if this.MaxRequestBytes != that1.MaxRequestBytes {
		return false
	}
	if this.MaxRequestTime != that1.MaxRequestTime {
		return false
	}
	return true
}
func (this *CorsPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CorsPolicy)
	if !ok {
		that2, ok := that.(CorsPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Disabled != that1.Disabled {
		return false
	}
	if len(this.AllowOrigin) != len(that1.AllowOrigin) {
		return false
	}
	for i := range this.AllowOrigin {
		if this.AllowOrigin[i] != that1.AllowOrigin[i] {
			return false
		}
	}
	if len(this.AllowOriginRegex) != len(that1.AllowOriginRegex) {
		return false
	}
	for i := range this.AllowOriginRegex {
		if this.AllowOriginRegex[i] != that1.AllowOriginRegex[i] {
			return false
		}
	}
	if this.AllowMethods != that1.AllowMethods {
		return false
	}
	if this.AllowHeaders != that1.AllowHeaders {
		return false
	}
	if this.ExposeHeaders != that1.ExposeHeaders {
		return false
	}
	if this.MaxAge != that1.MaxAge {
		return false
	}
	if this.MaximumAge != that1.MaximumAge {
		return false
	}
	if this.AllowCredentials != that1.AllowCredentials {
		return false
	}
	return true
}
func (this *CsrfPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CsrfPolicy)
	if !ok {
		that2, ok := that.(CsrfPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AllowedDomains == nil {
		if this.AllowedDomains != nil {
			return false
		}
	} else if this.AllowedDomains == nil {
		return false
	} else if !this.AllowedDomains.Equal(that1.AllowedDomains) {
		return false
	}
	return true
}
func (this *CsrfPolicy_AllLoadBalancerDomains) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CsrfPolicy_AllLoadBalancerDomains)
	if !ok {
		that2, ok := that.(CsrfPolicy_AllLoadBalancerDomains)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllLoadBalancerDomains.Equal(that1.AllLoadBalancerDomains) {
		return false
	}
	return true
}
func (this *CsrfPolicy_CustomDomainList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CsrfPolicy_CustomDomainList)
	if !ok {
		that2, ok := that.(CsrfPolicy_CustomDomainList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CustomDomainList.Equal(that1.CustomDomainList) {
		return false
	}
	return true
}
func (this *CsrfPolicy_Disabled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CsrfPolicy_Disabled)
	if !ok {
		that2, ok := that.(CsrfPolicy_Disabled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Disabled.Equal(that1.Disabled) {
		return false
	}
	return true
}
func (this *PathMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PathMatcherType)
	if !ok {
		that2, ok := that.(PathMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PathMatch == nil {
		if this.PathMatch != nil {
			return false
		}
	} else if this.PathMatch == nil {
		return false
	} else if !this.PathMatch.Equal(that1.PathMatch) {
		return false
	}
	return true
}
func (this *PathMatcherType_Prefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PathMatcherType_Prefix)
	if !ok {
		that2, ok := that.(PathMatcherType_Prefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Prefix != that1.Prefix {
		return false
	}
	return true
}
func (this *PathMatcherType_Path) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PathMatcherType_Path)
	if !ok {
		that2, ok := that.(PathMatcherType_Path)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	return true
}
func (this *PathMatcherType_Regex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PathMatcherType_Regex)
	if !ok {
		that2, ok := that.(PathMatcherType_Regex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Regex != that1.Regex {
		return false
	}
	return true
}
func (this *PortMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortMatcherType)
	if !ok {
		that2, ok := that.(PortMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PortMatch == nil {
		if this.PortMatch != nil {
			return false
		}
	} else if this.PortMatch == nil {
		return false
	} else if !this.PortMatch.Equal(that1.PortMatch) {
		return false
	}
	return true
}
func (this *PortMatcherType_Port) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortMatcherType_Port)
	if !ok {
		that2, ok := that.(PortMatcherType_Port)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	return true
}
func (this *PortMatcherType_PortRanges) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortMatcherType_PortRanges)
	if !ok {
		that2, ok := that.(PortMatcherType_PortRanges)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PortRanges != that1.PortRanges {
		return false
	}
	return true
}
func (this *PortMatcherType_NoPortMatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortMatcherType_NoPortMatch)
	if !ok {
		that2, ok := that.(PortMatcherType_NoPortMatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoPortMatch.Equal(that1.NoPortMatch) {
		return false
	}
	return true
}
func (this *HeaderMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType)
	if !ok {
		that2, ok := that.(HeaderMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.ValueMatch == nil {
		if this.ValueMatch != nil {
			return false
		}
	} else if this.ValueMatch == nil {
		return false
	} else if !this.ValueMatch.Equal(that1.ValueMatch) {
		return false
	}
	if this.InvertMatch != that1.InvertMatch {
		return false
	}
	return true
}
func (this *HeaderMatcherType_Exact) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType_Exact)
	if !ok {
		that2, ok := that.(HeaderMatcherType_Exact)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Exact != that1.Exact {
		return false
	}
	return true
}
func (this *HeaderMatcherType_Regex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType_Regex)
	if !ok {
		that2, ok := that.(HeaderMatcherType_Regex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Regex != that1.Regex {
		return false
	}
	return true
}
func (this *HeaderMatcherType_Presence) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType_Presence)
	if !ok {
		that2, ok := that.(HeaderMatcherType_Presence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Presence != that1.Presence {
		return false
	}
	return true
}
func (this *QueryParameterMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcherType)
	if !ok {
		that2, ok := that.(QueryParameterMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if that1.ValueMatch == nil {
		if this.ValueMatch != nil {
			return false
		}
	} else if this.ValueMatch == nil {
		return false
	} else if !this.ValueMatch.Equal(that1.ValueMatch) {
		return false
	}
	return true
}
func (this *QueryParameterMatcherType_Exact) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcherType_Exact)
	if !ok {
		that2, ok := that.(QueryParameterMatcherType_Exact)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Exact != that1.Exact {
		return false
	}
	return true
}
func (this *QueryParameterMatcherType_Regex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcherType_Regex)
	if !ok {
		that2, ok := that.(QueryParameterMatcherType_Regex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Regex != that1.Regex {
		return false
	}
	return true
}
func (this *RouteMatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteMatch)
	if !ok {
		that2, ok := that.(RouteMatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Path.Equal(that1.Path) {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if len(this.QueryParams) != len(that1.QueryParams) {
		return false
	}
	for i := range this.QueryParams {
		if !this.QueryParams[i].Equal(that1.QueryParams[i]) {
			return false
		}
	}
	if this.HttpMethod != that1.HttpMethod {
		return false
	}
	if !this.IncomingPort.Equal(that1.IncomingPort) {
		return false
	}
	return true
}
func (this *AppFirewallRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AppFirewallRefType)
	if !ok {
		that2, ok := that.(AppFirewallRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.AppFirewall) != len(that1.AppFirewall) {
		return false
	}
	for i := range this.AppFirewall {
		if !this.AppFirewall[i].Equal(that1.AppFirewall[i]) {
			return false
		}
	}
	return true
}
func (this *WafType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafType)
	if !ok {
		that2, ok := that.(WafType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.RefType == nil {
		if this.RefType != nil {
			return false
		}
	} else if this.RefType == nil {
		return false
	} else if !this.RefType.Equal(that1.RefType) {
		return false
	}
	return true
}
func (this *WafType_AppFirewall) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafType_AppFirewall)
	if !ok {
		that2, ok := that.(WafType_AppFirewall)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AppFirewall.Equal(that1.AppFirewall) {
		return false
	}
	return true
}
func (this *WafType_DisableWaf) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafType_DisableWaf)
	if !ok {
		that2, ok := that.(WafType_DisableWaf)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableWaf.Equal(that1.DisableWaf) {
		return false
	}
	return true
}
func (this *WafType_InheritWaf) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafType_InheritWaf)
	if !ok {
		that2, ok := that.(WafType_InheritWaf)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InheritWaf.Equal(that1.InheritWaf) {
		return false
	}
	return true
}
func (this *AppRoleAuthInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AppRoleAuthInfoType)
	if !ok {
		that2, ok := that.(AppRoleAuthInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RoleId != that1.RoleId {
		return false
	}
	if !this.SecretId.Equal(that1.SecretId) {
		return false
	}
	return true
}
func (this *VaultAuthInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultAuthInfoType)
	if !ok {
		that2, ok := that.(VaultAuthInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AuthParams == nil {
		if this.AuthParams != nil {
			return false
		}
	} else if this.AuthParams == nil {
		return false
	} else if !this.AuthParams.Equal(that1.AuthParams) {
		return false
	}
	return true
}
func (this *VaultAuthInfoType_AppRoleAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultAuthInfoType_AppRoleAuth)
	if !ok {
		that2, ok := that.(VaultAuthInfoType_AppRoleAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AppRoleAuth.Equal(that1.AppRoleAuth) {
		return false
	}
	return true
}
func (this *VaultAuthInfoType_Token) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultAuthInfoType_Token)
	if !ok {
		that2, ok := that.(VaultAuthInfoType_Token)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Token.Equal(that1.Token) {
		return false
	}
	return true
}
func (this *RestAuthInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RestAuthInfoType)
	if !ok {
		that2, ok := that.(RestAuthInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AuthParams == nil {
		if this.AuthParams != nil {
			return false
		}
	} else if this.AuthParams == nil {
		return false
	} else if !this.AuthParams.Equal(that1.AuthParams) {
		return false
	}
	return true
}
func (this *RestAuthInfoType_BasicAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RestAuthInfoType_BasicAuth)
	if !ok {
		that2, ok := that.(RestAuthInfoType_BasicAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BasicAuth.Equal(that1.BasicAuth) {
		return false
	}
	return true
}
func (this *RestAuthInfoType_HeadersAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RestAuthInfoType_HeadersAuth)
	if !ok {
		that2, ok := that.(RestAuthInfoType_HeadersAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HeadersAuth.Equal(that1.HeadersAuth) {
		return false
	}
	return true
}
func (this *RestAuthInfoType_QueryParamsAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RestAuthInfoType_QueryParamsAuth)
	if !ok {
		that2, ok := that.(RestAuthInfoType_QueryParamsAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.QueryParamsAuth.Equal(that1.QueryParamsAuth) {
		return false
	}
	return true
}
func (this *VaultAccessInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultAccessInfoType)
	if !ok {
		that2, ok := that.(VaultAccessInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VaultAddr != that1.VaultAddr {
		return false
	}
	if this.VaultCaUrl != that1.VaultCaUrl {
		return false
	}
	if that1.AuthnChoice == nil {
		if this.AuthnChoice != nil {
			return false
		}
	} else if this.AuthnChoice == nil {
		return false
	} else if !this.AuthnChoice.Equal(that1.AuthnChoice) {
		return false
	}
	return true
}
func (this *VaultAccessInfoType_AppRoleAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultAccessInfoType_AppRoleAuth)
	if !ok {
		that2, ok := that.(VaultAccessInfoType_AppRoleAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AppRoleAuth.Equal(that1.AppRoleAuth) {
		return false
	}
	return true
}
func (this *VaultAccessInfoType_Token) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultAccessInfoType_Token)
	if !ok {
		that2, ok := that.(VaultAccessInfoType_Token)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Token.Equal(that1.Token) {
		return false
	}
	return true
}
func (this *VaultSecretType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultSecretType)
	if !ok {
		that2, ok := that.(VaultSecretType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AccessChoice == nil {
		if this.AccessChoice != nil {
			return false
		}
	} else if this.AccessChoice == nil {
		return false
	} else if !this.AccessChoice.Equal(that1.AccessChoice) {
		return false
	}
	if this.SecretPath != that1.SecretPath {
		return false
	}
	if this.SecretSubPath != that1.SecretSubPath {
		return false
	}
	if this.SecretVersion != that1.SecretVersion {
		return false
	}
	return true
}
func (this *VaultSecretType_VaultAccessInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultSecretType_VaultAccessInfo)
	if !ok {
		that2, ok := that.(VaultSecretType_VaultAccessInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VaultAccessInfo.Equal(that1.VaultAccessInfo) {
		return false
	}
	return true
}
func (this *VaultSecretType_ProviderName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultSecretType_ProviderName)
	if !ok {
		that2, ok := that.(VaultSecretType_ProviderName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProviderName != that1.ProviderName {
		return false
	}
	return true
}
func (this *VolterraSecretType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VolterraSecretType)
	if !ok {
		that2, ok := that.(VolterraSecretType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.SecretTypeChoice == nil {
		if this.SecretTypeChoice != nil {
			return false
		}
	} else if this.SecretTypeChoice == nil {
		return false
	} else if !this.SecretTypeChoice.Equal(that1.SecretTypeChoice) {
		return false
	}
	return true
}
func (this *VolterraSecretType_BlindfoldSecretInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VolterraSecretType_BlindfoldSecretInfo)
	if !ok {
		that2, ok := that.(VolterraSecretType_BlindfoldSecretInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BlindfoldSecretInfo.Equal(that1.BlindfoldSecretInfo) {
		return false
	}
	return true
}
func (this *VolterraSecretType_VaultSecretInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VolterraSecretType_VaultSecretInfo)
	if !ok {
		that2, ok := that.(VolterraSecretType_VaultSecretInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VaultSecretInfo.Equal(that1.VaultSecretInfo) {
		return false
	}
	return true
}
func (this *PortValueType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortValueType)
	if !ok {
		that2, ok := that.(PortValueType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PortValueTypeChoice == nil {
		if this.PortValueTypeChoice != nil {
			return false
		}
	} else if this.PortValueTypeChoice == nil {
		return false
	} else if !this.PortValueTypeChoice.Equal(that1.PortValueTypeChoice) {
		return false
	}
	return true
}
func (this *PortValueType_All) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortValueType_All)
	if !ok {
		that2, ok := that.(PortValueType_All)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.All.Equal(that1.All) {
		return false
	}
	return true
}
func (this *PortValueType_UserDefined) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortValueType_UserDefined)
	if !ok {
		that2, ok := that.(PortValueType_UserDefined)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserDefined != that1.UserDefined {
		return false
	}
	return true
}
func (this *PortValueType_Dns) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortValueType_Dns)
	if !ok {
		that2, ok := that.(PortValueType_Dns)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Dns.Equal(that1.Dns) {
		return false
	}
	return true
}
func (this *VirtualNetworkReferenceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualNetworkReferenceType)
	if !ok {
		that2, ok := that.(VirtualNetworkReferenceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Refs) != len(that1.Refs) {
		return false
	}
	for i := range this.Refs {
		if !this.Refs[i].Equal(that1.Refs[i]) {
			return false
		}
	}
	return true
}
func (this *VirtualNetworkSelectorType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualNetworkSelectorType)
	if !ok {
		that2, ok := that.(VirtualNetworkSelectorType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.VnTypeChoice == nil {
		if this.VnTypeChoice != nil {
			return false
		}
	} else if this.VnTypeChoice == nil {
		return false
	} else if !this.VnTypeChoice.Equal(that1.VnTypeChoice) {
		return false
	}
	return true
}
func (this *VirtualNetworkSelectorType_SiteLocal) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualNetworkSelectorType_SiteLocal)
	if !ok {
		that2, ok := that.(VirtualNetworkSelectorType_SiteLocal)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteLocal.Equal(that1.SiteLocal) {
		return false
	}
	return true
}
func (this *VirtualNetworkSelectorType_SiteLocalInside) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualNetworkSelectorType_SiteLocalInside)
	if !ok {
		that2, ok := that.(VirtualNetworkSelectorType_SiteLocalInside)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteLocalInside.Equal(that1.SiteLocalInside) {
		return false
	}
	return true
}
func (this *VirtualNetworkSelectorType_Public) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualNetworkSelectorType_Public)
	if !ok {
		that2, ok := that.(VirtualNetworkSelectorType_Public)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Public.Equal(that1.Public) {
		return false
	}
	return true
}
func (this *RetryBackOff) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RetryBackOff)
	if !ok {
		that2, ok := that.(RetryBackOff)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BaseInterval != that1.BaseInterval {
		return false
	}
	if this.MaxInterval != that1.MaxInterval {
		return false
	}
	return true
}
func (this *RetryPolicyType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RetryPolicyType)
	if !ok {
		that2, ok := that.(RetryPolicyType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RetryOn != that1.RetryOn {
		return false
	}
	if len(this.RetryCondition) != len(that1.RetryCondition) {
		return false
	}
	for i := range this.RetryCondition {
		if this.RetryCondition[i] != that1.RetryCondition[i] {
			return false
		}
	}
	if this.NumRetries != that1.NumRetries {
		return false
	}
	if this.PerTryTimeout != that1.PerTryTimeout {
		return false
	}
	if len(this.RetriableStatusCodes) != len(that1.RetriableStatusCodes) {
		return false
	}
	for i := range this.RetriableStatusCodes {
		if this.RetriableStatusCodes[i] != that1.RetriableStatusCodes[i] {
			return false
		}
	}
	if !this.BackOff.Equal(that1.BackOff) {
		return false
	}
	return true
}
func (this *MetricValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetricValue)
	if !ok {
		that2, ok := that.(MetricValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if !this.TrendValue.Equal(that1.TrendValue) {
		return false
	}
	return true
}
func (this *MetricTypeData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetricTypeData)
	if !ok {
		that2, ok := that.(MetricTypeData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Values) != len(that1.Values) {
		return false
	}
	for i := range this.Values {
		if !this.Values[i].Equal(that1.Values[i]) {
			return false
		}
	}
	return true
}
func (this *TrendValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TrendValue)
	if !ok {
		that2, ok := that.(TrendValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Sentiment != that1.Sentiment {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.PreviousValue != that1.PreviousValue {
		return false
	}
	return true
}
func (this *NextHopType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NextHopType)
	if !ok {
		that2, ok := that.(NextHopType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.NexthopAddress.Equal(that1.NexthopAddress) {
		return false
	}
	if len(this.Interface) != len(that1.Interface) {
		return false
	}
	for i := range this.Interface {
		if !this.Interface[i].Equal(that1.Interface[i]) {
			return false
		}
	}
	return true
}
func (this *StaticRouteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StaticRouteType)
	if !ok {
		that2, ok := that.(StaticRouteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Attrs) != len(that1.Attrs) {
		return false
	}
	for i := range this.Attrs {
		if this.Attrs[i] != that1.Attrs[i] {
			return false
		}
	}
	if len(this.Subnets) != len(that1.Subnets) {
		return false
	}
	for i := range this.Subnets {
		if !this.Subnets[i].Equal(that1.Subnets[i]) {
			return false
		}
	}
	if !this.Nexthop.Equal(that1.Nexthop) {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	return true
}
func (this *ForwardProxyConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ForwardProxyConfigType)
	if !ok {
		that2, ok := that.(ForwardProxyConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.WhiteListedPrefixes) != len(that1.WhiteListedPrefixes) {
		return false
	}
	for i := range this.WhiteListedPrefixes {
		if this.WhiteListedPrefixes[i] != that1.WhiteListedPrefixes[i] {
			return false
		}
	}
	if len(this.WhiteListedPorts) != len(that1.WhiteListedPorts) {
		return false
	}
	for i := range this.WhiteListedPorts {
		if this.WhiteListedPorts[i] != that1.WhiteListedPorts[i] {
			return false
		}
	}
	if this.MaxConnectAttempts != that1.MaxConnectAttempts {
		return false
	}
	if this.ConnectionTimeout != that1.ConnectionTimeout {
		return false
	}
	if that1.TlsInterceptionChoice == nil {
		if this.TlsInterceptionChoice != nil {
			return false
		}
	} else if this.TlsInterceptionChoice == nil {
		return false
	} else if !this.TlsInterceptionChoice.Equal(that1.TlsInterceptionChoice) {
		return false
	}
	return true
}
func (this *ForwardProxyConfigType_NoInterception) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ForwardProxyConfigType_NoInterception)
	if !ok {
		that2, ok := that.(ForwardProxyConfigType_NoInterception)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoInterception.Equal(that1.NoInterception) {
		return false
	}
	return true
}
func (this *ForwardProxyConfigType_TlsIntercept) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ForwardProxyConfigType_TlsIntercept)
	if !ok {
		that2, ok := that.(ForwardProxyConfigType_TlsIntercept)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TlsIntercept.Equal(that1.TlsIntercept) {
		return false
	}
	return true
}
func (this *HostIdentifier) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HostIdentifier)
	if !ok {
		that2, ok := that.(HostIdentifier)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.HostnameOrIp == nil {
		if this.HostnameOrIp != nil {
			return false
		}
	} else if this.HostnameOrIp == nil {
		return false
	} else if !this.HostnameOrIp.Equal(that1.HostnameOrIp) {
		return false
	}
	return true
}
func (this *HostIdentifier_Ip) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HostIdentifier_Ip)
	if !ok {
		that2, ok := that.(HostIdentifier_Ip)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ip != that1.Ip {
		return false
	}
	return true
}
func (this *HostIdentifier_Hostname) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HostIdentifier_Hostname)
	if !ok {
		that2, ok := that.(HostIdentifier_Hostname)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	return true
}
func (this *InterfaceIdentifier) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceIdentifier)
	if !ok {
		that2, ok := that.(InterfaceIdentifier)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.InterfaceChoice == nil {
		if this.InterfaceChoice != nil {
			return false
		}
	} else if this.InterfaceChoice == nil {
		return false
	} else if !this.InterfaceChoice.Equal(that1.InterfaceChoice) {
		return false
	}
	return true
}
func (this *InterfaceIdentifier_AnyIntf) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceIdentifier_AnyIntf)
	if !ok {
		that2, ok := that.(InterfaceIdentifier_AnyIntf)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyIntf.Equal(that1.AnyIntf) {
		return false
	}
	return true
}
func (this *InterfaceIdentifier_Intf) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceIdentifier_Intf)
	if !ok {
		that2, ok := that.(InterfaceIdentifier_Intf)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Intf != that1.Intf {
		return false
	}
	return true
}
func (this *InterfaceOrNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceOrNetwork)
	if !ok {
		that2, ok := that.(InterfaceOrNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.InterfaceChoice == nil {
		if this.InterfaceChoice != nil {
			return false
		}
	} else if this.InterfaceChoice == nil {
		return false
	} else if !this.InterfaceChoice.Equal(that1.InterfaceChoice) {
		return false
	}
	return true
}
func (this *InterfaceOrNetwork_Intf) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceOrNetwork_Intf)
	if !ok {
		that2, ok := that.(InterfaceOrNetwork_Intf)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Intf != that1.Intf {
		return false
	}
	return true
}
func (this *InterfaceOrNetwork_Pod) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceOrNetwork_Pod)
	if !ok {
		that2, ok := that.(InterfaceOrNetwork_Pod)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Pod != that1.Pod {
		return false
	}
	return true
}
func (this *InterfaceOrNetwork_VnType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceOrNetwork_VnType)
	if !ok {
		that2, ok := that.(InterfaceOrNetwork_VnType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VnType != that1.VnType {
		return false
	}
	return true
}
func (this *InterfaceOrNetwork_Vn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceOrNetwork_Vn)
	if !ok {
		that2, ok := that.(InterfaceOrNetwork_Vn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Vn != that1.Vn {
		return false
	}
	return true
}
func (this *RouteTarget2ByteAsn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteTarget2ByteAsn)
	if !ok {
		that2, ok := that.(RouteTarget2ByteAsn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AsNumber != that1.AsNumber {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *RouteTarget4ByteAsn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteTarget4ByteAsn)
	if !ok {
		that2, ok := that.(RouteTarget4ByteAsn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AsNumber != that1.AsNumber {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *RouteTargetIPv4Addr) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteTargetIPv4Addr)
	if !ok {
		that2, ok := that.(RouteTargetIPv4Addr)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *RouteTarget) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteTarget)
	if !ok {
		that2, ok := that.(RouteTarget)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.RtargetChoice == nil {
		if this.RtargetChoice != nil {
			return false
		}
	} else if this.RtargetChoice == nil {
		return false
	} else if !this.RtargetChoice.Equal(that1.RtargetChoice) {
		return false
	}
	return true
}
func (this *RouteTarget_Asn2ByteRtarget) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteTarget_Asn2ByteRtarget)
	if !ok {
		that2, ok := that.(RouteTarget_Asn2ByteRtarget)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Asn2ByteRtarget.Equal(that1.Asn2ByteRtarget) {
		return false
	}
	return true
}
func (this *RouteTarget_Ipv4AddrRtarget) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteTarget_Ipv4AddrRtarget)
	if !ok {
		that2, ok := that.(RouteTarget_Ipv4AddrRtarget)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipv4AddrRtarget.Equal(that1.Ipv4AddrRtarget) {
		return false
	}
	return true
}
func (this *RouteTarget_Asn4ByteRtarget) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteTarget_Asn4ByteRtarget)
	if !ok {
		that2, ok := that.(RouteTarget_Asn4ByteRtarget)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Asn4ByteRtarget.Equal(that1.Asn4ByteRtarget) {
		return false
	}
	return true
}
func (this *PortRangesType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortRangesType)
	if !ok {
		that2, ok := that.(PortRangesType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if this.Ports[i] != that1.Ports[i] {
			return false
		}
	}
	return true
}
func (this *DomainNameList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DomainNameList)
	if !ok {
		that2, ok := that.(DomainNameList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Domains) != len(that1.Domains) {
		return false
	}
	for i := range this.Domains {
		if this.Domains[i] != that1.Domains[i] {
			return false
		}
	}
	return true
}
func (this *NamespaceRoleType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamespaceRoleType)
	if !ok {
		that2, ok := that.(NamespaceRoleType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Role != that1.Role {
		return false
	}
	return true
}
func (this *RoleListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoleListType)
	if !ok {
		that2, ok := that.(RoleListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Names) != len(that1.Names) {
		return false
	}
	for i := range this.Names {
		if this.Names[i] != that1.Names[i] {
			return false
		}
	}
	return true
}
func (this *NamespaceAccessType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamespaceAccessType)
	if !ok {
		that2, ok := that.(NamespaceAccessType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.NamespaceRoleMap) != len(that1.NamespaceRoleMap) {
		return false
	}
	for i := range this.NamespaceRoleMap {
		if !this.NamespaceRoleMap[i].Equal(that1.NamespaceRoleMap[i]) {
			return false
		}
	}
	return true
}
func (this *SiteInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteInfo)
	if !ok {
		that2, ok := that.(SiteInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Site) != len(that1.Site) {
		return false
	}
	for i := range this.Site {
		if !this.Site[i].Equal(that1.Site[i]) {
			return false
		}
	}
	if len(this.Annotations) != len(that1.Annotations) {
		return false
	}
	for i := range this.Annotations {
		if this.Annotations[i] != that1.Annotations[i] {
			return false
		}
	}
	return true
}
func (this *SiteReferenceListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteReferenceListType)
	if !ok {
		that2, ok := that.(SiteReferenceListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Refs) != len(that1.Refs) {
		return false
	}
	for i := range this.Refs {
		if !this.Refs[i].Equal(that1.Refs[i]) {
			return false
		}
	}
	return true
}
func (this *HeaderTransformationType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderTransformationType)
	if !ok {
		that2, ok := that.(HeaderTransformationType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.HeaderTransformationChoice == nil {
		if this.HeaderTransformationChoice != nil {
			return false
		}
	} else if this.HeaderTransformationChoice == nil {
		return false
	} else if !this.HeaderTransformationChoice.Equal(that1.HeaderTransformationChoice) {
		return false
	}
	return true
}
func (this *HeaderTransformationType_LegacyHeaderTransformation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderTransformationType_LegacyHeaderTransformation)
	if !ok {
		that2, ok := that.(HeaderTransformationType_LegacyHeaderTransformation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LegacyHeaderTransformation.Equal(that1.LegacyHeaderTransformation) {
		return false
	}
	return true
}
func (this *HeaderTransformationType_DefaultHeaderTransformation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderTransformationType_DefaultHeaderTransformation)
	if !ok {
		that2, ok := that.(HeaderTransformationType_DefaultHeaderTransformation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultHeaderTransformation.Equal(that1.DefaultHeaderTransformation) {
		return false
	}
	return true
}
func (this *HeaderTransformationType_ProperCaseHeaderTransformation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderTransformationType_ProperCaseHeaderTransformation)
	if !ok {
		that2, ok := that.(HeaderTransformationType_ProperCaseHeaderTransformation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ProperCaseHeaderTransformation.Equal(that1.ProperCaseHeaderTransformation) {
		return false
	}
	return true
}
func (this *HeaderTransformationType_PreserveCaseHeaderTransformation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderTransformationType_PreserveCaseHeaderTransformation)
	if !ok {
		that2, ok := that.(HeaderTransformationType_PreserveCaseHeaderTransformation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PreserveCaseHeaderTransformation.Equal(that1.PreserveCaseHeaderTransformation) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelCategoriesChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelCategoriesChoiceType)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelCategoriesChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.FlowLabelChoice == nil {
		if this.FlowLabelChoice != nil {
			return false
		}
	} else if this.FlowLabelChoice == nil {
		return false
	} else if !this.FlowLabelChoice.Equal(that1.FlowLabelChoice) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelCategoriesChoiceType_Authentication) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelCategoriesChoiceType_Authentication)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelCategoriesChoiceType_Authentication)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Authentication.Equal(that1.Authentication) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelCategoriesChoiceType_AccountManagement) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelCategoriesChoiceType_AccountManagement)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelCategoriesChoiceType_AccountManagement)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AccountManagement.Equal(that1.AccountManagement) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelCategoriesChoiceType_ProfileManagement) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelCategoriesChoiceType_ProfileManagement)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelCategoriesChoiceType_ProfileManagement)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ProfileManagement.Equal(that1.ProfileManagement) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelCategoriesChoiceType_ShoppingGiftCards) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelCategoriesChoiceType_ShoppingGiftCards)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelCategoriesChoiceType_ShoppingGiftCards)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ShoppingGiftCards.Equal(that1.ShoppingGiftCards) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelCategoriesChoiceType_FinancialServices) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelCategoriesChoiceType_FinancialServices)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelCategoriesChoiceType_FinancialServices)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FinancialServices.Equal(that1.FinancialServices) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelCategoriesChoiceType_Search) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelCategoriesChoiceType_Search)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelCategoriesChoiceType_Search)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Search.Equal(that1.Search) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelCategoriesChoiceType_Flight) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelCategoriesChoiceType_Flight)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelCategoriesChoiceType_Flight)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Flight.Equal(that1.Flight) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelAuthenticationChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelAuthenticationChoiceType)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelAuthenticationChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.LabelChoice == nil {
		if this.LabelChoice != nil {
			return false
		}
	} else if this.LabelChoice == nil {
		return false
	} else if !this.LabelChoice.Equal(that1.LabelChoice) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelAuthenticationChoiceType_Login) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelAuthenticationChoiceType_Login)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelAuthenticationChoiceType_Login)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Login.Equal(that1.Login) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelAuthenticationChoiceType_LoginMfa) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelAuthenticationChoiceType_LoginMfa)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelAuthenticationChoiceType_LoginMfa)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LoginMfa.Equal(that1.LoginMfa) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelAuthenticationChoiceType_LoginPartner) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelAuthenticationChoiceType_LoginPartner)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelAuthenticationChoiceType_LoginPartner)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LoginPartner.Equal(that1.LoginPartner) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelAuthenticationChoiceType_Logout) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelAuthenticationChoiceType_Logout)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelAuthenticationChoiceType_Logout)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Logout.Equal(that1.Logout) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelAuthenticationChoiceType_TokenRefresh) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelAuthenticationChoiceType_TokenRefresh)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelAuthenticationChoiceType_TokenRefresh)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TokenRefresh.Equal(that1.TokenRefresh) {
		return false
	}
	return true
}
func (this *BotDefenseTransactionResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseTransactionResult)
	if !ok {
		that2, ok := that.(BotDefenseTransactionResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.TransactionResultChoice == nil {
		if this.TransactionResultChoice != nil {
			return false
		}
	} else if this.TransactionResultChoice == nil {
		return false
	} else if !this.TransactionResultChoice.Equal(that1.TransactionResultChoice) {
		return false
	}
	return true
}
func (this *BotDefenseTransactionResult_DisableTransactionResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseTransactionResult_DisableTransactionResult)
	if !ok {
		that2, ok := that.(BotDefenseTransactionResult_DisableTransactionResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableTransactionResult.Equal(that1.DisableTransactionResult) {
		return false
	}
	return true
}
func (this *BotDefenseTransactionResult_TransactionResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseTransactionResult_TransactionResult)
	if !ok {
		that2, ok := that.(BotDefenseTransactionResult_TransactionResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TransactionResult.Equal(that1.TransactionResult) {
		return false
	}
	return true
}
func (this *BotDefenseTransactionResultType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseTransactionResultType)
	if !ok {
		that2, ok := that.(BotDefenseTransactionResultType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SuccessConditions) != len(that1.SuccessConditions) {
		return false
	}
	for i := range this.SuccessConditions {
		if !this.SuccessConditions[i].Equal(that1.SuccessConditions[i]) {
			return false
		}
	}
	if len(this.FailureConditions) != len(that1.FailureConditions) {
		return false
	}
	for i := range this.FailureConditions {
		if !this.FailureConditions[i].Equal(that1.FailureConditions[i]) {
			return false
		}
	}
	return true
}
func (this *BotDefenseTransactionResultCondition) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseTransactionResultCondition)
	if !ok {
		that2, ok := that.(BotDefenseTransactionResultCondition)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.RegexValues) != len(that1.RegexValues) {
		return false
	}
	for i := range this.RegexValues {
		if this.RegexValues[i] != that1.RegexValues[i] {
			return false
		}
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelAccountManagementChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelAccountManagementChoiceType)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelAccountManagementChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.LabelChoice == nil {
		if this.LabelChoice != nil {
			return false
		}
	} else if this.LabelChoice == nil {
		return false
	} else if !this.LabelChoice.Equal(that1.LabelChoice) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelAccountManagementChoiceType_Create) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelAccountManagementChoiceType_Create)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelAccountManagementChoiceType_Create)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Create.Equal(that1.Create) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelAccountManagementChoiceType_PasswordReset) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelAccountManagementChoiceType_PasswordReset)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelAccountManagementChoiceType_PasswordReset)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PasswordReset.Equal(that1.PasswordReset) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelProfileManagementChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelProfileManagementChoiceType)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelProfileManagementChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.LabelChoice == nil {
		if this.LabelChoice != nil {
			return false
		}
	} else if this.LabelChoice == nil {
		return false
	} else if !this.LabelChoice.Equal(that1.LabelChoice) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelProfileManagementChoiceType_Create) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelProfileManagementChoiceType_Create)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelProfileManagementChoiceType_Create)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Create.Equal(that1.Create) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelProfileManagementChoiceType_Update) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelProfileManagementChoiceType_Update)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelProfileManagementChoiceType_Update)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Update.Equal(that1.Update) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelProfileManagementChoiceType_View) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelProfileManagementChoiceType_View)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelProfileManagementChoiceType_View)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.View.Equal(that1.View) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelShoppingGiftCardsChoiceType)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelShoppingGiftCardsChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.LabelChoice == nil {
		if this.LabelChoice != nil {
			return false
		}
	} else if this.LabelChoice == nil {
		return false
	} else if !this.LabelChoice.Equal(that1.LabelChoice) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopAddToCart) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopAddToCart)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopAddToCart)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ShopAddToCart.Equal(that1.ShopAddToCart) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPromoCodeValidation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPromoCodeValidation)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPromoCodeValidation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ShopPromoCodeValidation.Equal(that1.ShopPromoCodeValidation) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopCheckout) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopCheckout)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopCheckout)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ShopCheckout.Equal(that1.ShopCheckout) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopMakePayment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopMakePayment)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopMakePayment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ShopMakePayment.Equal(that1.ShopMakePayment) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopOrder) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopOrder)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopOrder)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ShopOrder.Equal(that1.ShopOrder) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPriceInquiry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPriceInquiry)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPriceInquiry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ShopPriceInquiry.Equal(that1.ShopPriceInquiry) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPurchaseGiftCard) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPurchaseGiftCard)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPurchaseGiftCard)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ShopPurchaseGiftCard.Equal(that1.ShopPurchaseGiftCard) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopUpdateQuantity) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopUpdateQuantity)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopUpdateQuantity)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ShopUpdateQuantity.Equal(that1.ShopUpdateQuantity) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopChooseSeat) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopChooseSeat)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopChooseSeat)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ShopChooseSeat.Equal(that1.ShopChooseSeat) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopEnterDrawingSubmission) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopEnterDrawingSubmission)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopEnterDrawingSubmission)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ShopEnterDrawingSubmission.Equal(that1.ShopEnterDrawingSubmission) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardValidation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardValidation)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardValidation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GiftCardValidation.Equal(that1.GiftCardValidation) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardMakePurchaseWithGiftCard) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardMakePurchaseWithGiftCard)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardMakePurchaseWithGiftCard)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GiftCardMakePurchaseWithGiftCard.Equal(that1.GiftCardMakePurchaseWithGiftCard) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelFinancialServicesChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelFinancialServicesChoiceType)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelFinancialServicesChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.LabelChoice == nil {
		if this.LabelChoice != nil {
			return false
		}
	} else if this.LabelChoice == nil {
		return false
	} else if !this.LabelChoice.Equal(that1.LabelChoice) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelFinancialServicesChoiceType_Apply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelFinancialServicesChoiceType_Apply)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelFinancialServicesChoiceType_Apply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Apply.Equal(that1.Apply) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelFinancialServicesChoiceType_MoneyTransfer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelFinancialServicesChoiceType_MoneyTransfer)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelFinancialServicesChoiceType_MoneyTransfer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MoneyTransfer.Equal(that1.MoneyTransfer) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelSearchChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelSearchChoiceType)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelSearchChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.LabelChoice == nil {
		if this.LabelChoice != nil {
			return false
		}
	} else if this.LabelChoice == nil {
		return false
	} else if !this.LabelChoice.Equal(that1.LabelChoice) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelSearchChoiceType_FlightSearch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelSearchChoiceType_FlightSearch)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelSearchChoiceType_FlightSearch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FlightSearch.Equal(that1.FlightSearch) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelSearchChoiceType_ProductSearch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelSearchChoiceType_ProductSearch)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelSearchChoiceType_ProductSearch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ProductSearch.Equal(that1.ProductSearch) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelSearchChoiceType_RoomSearch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelSearchChoiceType_RoomSearch)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelSearchChoiceType_RoomSearch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RoomSearch.Equal(that1.RoomSearch) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelSearchChoiceType_ReservationSearch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelSearchChoiceType_ReservationSearch)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelSearchChoiceType_ReservationSearch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ReservationSearch.Equal(that1.ReservationSearch) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelFlightChoiceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelFlightChoiceType)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelFlightChoiceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.LabelChoice == nil {
		if this.LabelChoice != nil {
			return false
		}
	} else if this.LabelChoice == nil {
		return false
	} else if !this.LabelChoice.Equal(that1.LabelChoice) {
		return false
	}
	return true
}
func (this *BotDefenseFlowLabelFlightChoiceType_Checkin) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BotDefenseFlowLabelFlightChoiceType_Checkin)
	if !ok {
		that2, ok := that.(BotDefenseFlowLabelFlightChoiceType_Checkin)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Checkin.Equal(that1.Checkin) {
		return false
	}
	return true
}
func (this *NetworkingStackType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkingStackType)
	if !ok {
		that2, ok := that.(NetworkingStackType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Choice == nil {
		if this.Choice != nil {
			return false
		}
	} else if this.Choice == nil {
		return false
	} else if !this.Choice.Equal(that1.Choice) {
		return false
	}
	return true
}
func (this *NetworkingStackType_Ipv4) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkingStackType_Ipv4)
	if !ok {
		that2, ok := that.(NetworkingStackType_Ipv4)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipv4.Equal(that1.Ipv4) {
		return false
	}
	return true
}
func (this *NetworkingStackType_Ipv6) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkingStackType_Ipv6)
	if !ok {
		that2, ok := that.(NetworkingStackType_Ipv6)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipv6.Equal(that1.Ipv6) {
		return false
	}
	return true
}
func (this *NetworkingStackType_Dual) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkingStackType_Dual)
	if !ok {
		that2, ok := that.(NetworkingStackType_Dual)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Dual.Equal(that1.Dual) {
		return false
	}
	return true
}
func (this *DateRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DateRange)
	if !ok {
		that2, ok := that.(DateRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StartDate.Equal(that1.StartDate) {
		return false
	}
	if !this.EndDate.Equal(that1.EndDate) {
		return false
	}
	return true
}
func (this *File) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*File)
	if !ok {
		that2, ok := that.(File)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ContentType != that1.ContentType {
		return false
	}
	if !bytes.Equal(this.Content, that1.Content) {
		return false
	}
	if this.FileId != that1.FileId {
		return false
	}
	if that1.StorageProvider == nil {
		if this.StorageProvider != nil {
			return false
		}
	} else if this.StorageProvider == nil {
		return false
	} else if !this.StorageProvider.Equal(that1.StorageProvider) {
		return false
	}
	return true
}
func (this *File_AwsS3) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*File_AwsS3)
	if !ok {
		that2, ok := that.(File_AwsS3)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AwsS3.Equal(that1.AwsS3) {
		return false
	}
	return true
}
func (this *ResponseMeta) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseMeta)
	if !ok {
		that2, ok := that.(ResponseMeta)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ErrorCode != that1.ErrorCode {
		return false
	}
	if this.DisplayMessage != that1.DisplayMessage {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	return true
}
func (this *Action) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action)
	if !ok {
		that2, ok := that.(Action)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ActionChoice == nil {
		if this.ActionChoice != nil {
			return false
		}
	} else if this.ActionChoice == nil {
		return false
	} else if !this.ActionChoice.Equal(that1.ActionChoice) {
		return false
	}
	return true
}
func (this *Action_Block) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_Block)
	if !ok {
		that2, ok := that.(Action_Block)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Block.Equal(that1.Block) {
		return false
	}
	return true
}
func (this *Action_Report) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Action_Report)
	if !ok {
		that2, ok := that.(Action_Report)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Report.Equal(that1.Report) {
		return false
	}
	return true
}
func (this *CRMInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CRMInfo)
	if !ok {
		that2, ok := that.(CRMInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AccountId != that1.AccountId {
		return false
	}
	if this.EntitlementId != that1.EntitlementId {
		return false
	}
	if this.SubscriptionId != that1.SubscriptionId {
		return false
	}
	if this.OrderType != that1.OrderType {
		return false
	}
	if len(this.EntitledSkus) != len(that1.EntitledSkus) {
		return false
	}
	for i := range this.EntitledSkus {
		if this.EntitledSkus[i] != that1.EntitledSkus[i] {
			return false
		}
	}
	if this.CustomerIdentifier != that1.CustomerIdentifier {
		return false
	}
	return true
}
func (this *RegexMatchRewrite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RegexMatchRewrite)
	if !ok {
		that2, ok := that.(RegexMatchRewrite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Pattern != that1.Pattern {
		return false
	}
	if this.Substitution != that1.Substitution {
		return false
	}
	return true
}
func (this *Empty) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&schema.Empty{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ObjectRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.ObjectRefType{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	s = append(s, "Tenant: "+fmt.Sprintf("%#v", this.Tenant)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LabelSelectorType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.LabelSelectorType{")
	s = append(s, "Expressions: "+fmt.Sprintf("%#v", this.Expressions)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LabelMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.LabelMatcherType{")
	s = append(s, "Keys: "+fmt.Sprintf("%#v", this.Keys)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConditionType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.ConditionType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Reason: "+fmt.Sprintf("%#v", this.Reason)+",\n")
	if this.LastUpdateTime != nil {
		s = append(s, "LastUpdateTime: "+fmt.Sprintf("%#v", this.LastUpdateTime)+",\n")
	}
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	s = append(s, "ServiceName: "+fmt.Sprintf("%#v", this.ServiceName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.StatusType{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Reason: "+fmt.Sprintf("%#v", this.Reason)+",\n")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InitializerType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.InitializerType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InitializersType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.InitializersType{")
	if this.Pending != nil {
		s = append(s, "Pending: "+fmt.Sprintf("%#v", this.Pending)+",\n")
	}
	if this.Result != nil {
		s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StatusMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&schema.StatusMetaType{")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	s = append(s, "CreatorClass: "+fmt.Sprintf("%#v", this.CreatorClass)+",\n")
	s = append(s, "CreatorId: "+fmt.Sprintf("%#v", this.CreatorId)+",\n")
	s = append(s, "StatusId: "+fmt.Sprintf("%#v", this.StatusId)+",\n")
	if this.CreationTimestamp != nil {
		s = append(s, "CreationTimestamp: "+fmt.Sprintf("%#v", this.CreationTimestamp)+",\n")
	}
	s = append(s, "Publish: "+fmt.Sprintf("%#v", this.Publish)+",\n")
	s = append(s, "VtrpId: "+fmt.Sprintf("%#v", this.VtrpId)+",\n")
	s = append(s, "VtrpStale: "+fmt.Sprintf("%#v", this.VtrpStale)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ObjectMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&schema.ObjectMetaType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%#v: %#v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	if this.Annotations != nil {
		s = append(s, "Annotations: "+mapStringForAnnotations+",\n")
	}
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Disable: "+fmt.Sprintf("%#v", this.Disable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.ListMetaType{")
	s = append(s, "ResourceVersion: "+fmt.Sprintf("%#v", this.ResourceVersion)+",\n")
	s = append(s, "NextPage: "+fmt.Sprintf("%#v", this.NextPage)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ObjectGetMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.ObjectGetMetaType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%#v: %#v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	if this.Annotations != nil {
		s = append(s, "Annotations: "+mapStringForAnnotations+",\n")
	}
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Disable: "+fmt.Sprintf("%#v", this.Disable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ObjectCreateMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.ObjectCreateMetaType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%#v: %#v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	if this.Annotations != nil {
		s = append(s, "Annotations: "+mapStringForAnnotations+",\n")
	}
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Disable: "+fmt.Sprintf("%#v", this.Disable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ObjectReplaceMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.ObjectReplaceMetaType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%#v: %#v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	if this.Annotations != nil {
		s = append(s, "Annotations: "+mapStringForAnnotations+",\n")
	}
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Disable: "+fmt.Sprintf("%#v", this.Disable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MessageMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.MessageMetaType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Disable: "+fmt.Sprintf("%#v", this.Disable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ViewRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.ViewRefType{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *KubeRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.KubeRefType{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SystemObjectMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 22)
	s = append(s, "&schema.SystemObjectMetaType{")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	if this.CreationTimestamp != nil {
		s = append(s, "CreationTimestamp: "+fmt.Sprintf("%#v", this.CreationTimestamp)+",\n")
	}
	if this.DeletionTimestamp != nil {
		s = append(s, "DeletionTimestamp: "+fmt.Sprintf("%#v", this.DeletionTimestamp)+",\n")
	}
	if this.ModificationTimestamp != nil {
		s = append(s, "ModificationTimestamp: "+fmt.Sprintf("%#v", this.ModificationTimestamp)+",\n")
	}
	if this.Initializers != nil {
		s = append(s, "Initializers: "+fmt.Sprintf("%#v", this.Initializers)+",\n")
	}
	s = append(s, "Finalizers: "+fmt.Sprintf("%#v", this.Finalizers)+",\n")
	s = append(s, "Tenant: "+fmt.Sprintf("%#v", this.Tenant)+",\n")
	s = append(s, "CreatorClass: "+fmt.Sprintf("%#v", this.CreatorClass)+",\n")
	s = append(s, "CreatorId: "+fmt.Sprintf("%#v", this.CreatorId)+",\n")
	s = append(s, "CreatorCookie: "+fmt.Sprintf("%#v", this.CreatorCookie)+",\n")
	s = append(s, "TraceInfo: "+fmt.Sprintf("%#v", this.TraceInfo)+",\n")
	s = append(s, "ObjectIndex: "+fmt.Sprintf("%#v", this.ObjectIndex)+",\n")
	if this.Namespace != nil {
		s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	}
	if this.OwnerView != nil {
		s = append(s, "OwnerView: "+fmt.Sprintf("%#v", this.OwnerView)+",\n")
	}
	s = append(s, "SreDisable: "+fmt.Sprintf("%#v", this.SreDisable)+",\n")
	s = append(s, "VtrpId: "+fmt.Sprintf("%#v", this.VtrpId)+",\n")
	s = append(s, "VtrpStale: "+fmt.Sprintf("%#v", this.VtrpStale)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SystemObjectGetMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&schema.SystemObjectGetMetaType{")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	if this.CreationTimestamp != nil {
		s = append(s, "CreationTimestamp: "+fmt.Sprintf("%#v", this.CreationTimestamp)+",\n")
	}
	if this.DeletionTimestamp != nil {
		s = append(s, "DeletionTimestamp: "+fmt.Sprintf("%#v", this.DeletionTimestamp)+",\n")
	}
	if this.ModificationTimestamp != nil {
		s = append(s, "ModificationTimestamp: "+fmt.Sprintf("%#v", this.ModificationTimestamp)+",\n")
	}
	if this.Initializers != nil {
		s = append(s, "Initializers: "+fmt.Sprintf("%#v", this.Initializers)+",\n")
	}
	s = append(s, "Finalizers: "+fmt.Sprintf("%#v", this.Finalizers)+",\n")
	s = append(s, "Tenant: "+fmt.Sprintf("%#v", this.Tenant)+",\n")
	s = append(s, "CreatorClass: "+fmt.Sprintf("%#v", this.CreatorClass)+",\n")
	s = append(s, "CreatorId: "+fmt.Sprintf("%#v", this.CreatorId)+",\n")
	s = append(s, "ObjectIndex: "+fmt.Sprintf("%#v", this.ObjectIndex)+",\n")
	if this.OwnerView != nil {
		s = append(s, "OwnerView: "+fmt.Sprintf("%#v", this.OwnerView)+",\n")
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthnTypeBasicAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.AuthnTypeBasicAuth{")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	if this.Password != nil {
		s = append(s, "Password: "+fmt.Sprintf("%#v", this.Password)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthnTypeHeaders) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.AuthnTypeHeaders{")
	keysForHeaders := make([]string, 0, len(this.Headers))
	for k, _ := range this.Headers {
		keysForHeaders = append(keysForHeaders, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHeaders)
	mapStringForHeaders := "map[string]*SecretType{"
	for _, k := range keysForHeaders {
		mapStringForHeaders += fmt.Sprintf("%#v: %#v,", k, this.Headers[k])
	}
	mapStringForHeaders += "}"
	if this.Headers != nil {
		s = append(s, "Headers: "+mapStringForHeaders+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthnTypeQueryParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.AuthnTypeQueryParams{")
	keysForQueryParams := make([]string, 0, len(this.QueryParams))
	for k, _ := range this.QueryParams {
		keysForQueryParams = append(keysForQueryParams, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForQueryParams)
	mapStringForQueryParams := "map[string]*SecretType{"
	for _, k := range keysForQueryParams {
		mapStringForQueryParams += fmt.Sprintf("%#v: %#v,", k, this.QueryParams[k])
	}
	mapStringForQueryParams += "}"
	if this.QueryParams != nil {
		s = append(s, "QueryParams: "+mapStringForQueryParams+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BlindfoldSecretInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.BlindfoldSecretInfoType{")
	s = append(s, "DecryptionProvider: "+fmt.Sprintf("%#v", this.DecryptionProvider)+",\n")
	s = append(s, "StoreProvider: "+fmt.Sprintf("%#v", this.StoreProvider)+",\n")
	s = append(s, "Location: "+fmt.Sprintf("%#v", this.Location)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VaultSecretInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.VaultSecretInfoType{")
	s = append(s, "Provider: "+fmt.Sprintf("%#v", this.Provider)+",\n")
	s = append(s, "Location: "+fmt.Sprintf("%#v", this.Location)+",\n")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "SecretEncoding: "+fmt.Sprintf("%#v", this.SecretEncoding)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ClearSecretInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.ClearSecretInfoType{")
	s = append(s, "Provider: "+fmt.Sprintf("%#v", this.Provider)+",\n")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WingmanSecretInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.WingmanSecretInfoType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.NetworkRefType{")
	if this.Ref != nil {
		s = append(s, "Ref: "+fmt.Sprintf("%#v", this.Ref)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.SiteRefType{")
	if this.Ref != nil {
		s = append(s, "Ref: "+fmt.Sprintf("%#v", this.Ref)+",\n")
	}
	s = append(s, "NetworkType: "+fmt.Sprintf("%#v", this.NetworkType)+",\n")
	if this.InternetVipChoice != nil {
		s = append(s, "InternetVipChoice: "+fmt.Sprintf("%#v", this.InternetVipChoice)+",\n")
	}
	if this.Refs != nil {
		s = append(s, "Refs: "+fmt.Sprintf("%#v", this.Refs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteRefType_DisableInternetVip) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.SiteRefType_DisableInternetVip{` +
		`DisableInternetVip:` + fmt.Sprintf("%#v", this.DisableInternetVip) + `}`}, ", ")
	return s
}
func (this *SiteRefType_EnableInternetVip) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.SiteRefType_EnableInternetVip{` +
		`EnableInternetVip:` + fmt.Sprintf("%#v", this.EnableInternetVip) + `}`}, ", ")
	return s
}
func (this *IpPrefixSetRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.IpPrefixSetRefType{")
	if this.Ref != nil {
		s = append(s, "Ref: "+fmt.Sprintf("%#v", this.Ref)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VSiteRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.VSiteRefType{")
	if this.Ref != nil {
		s = append(s, "Ref: "+fmt.Sprintf("%#v", this.Ref)+",\n")
	}
	s = append(s, "NetworkType: "+fmt.Sprintf("%#v", this.NetworkType)+",\n")
	if this.InternetVipChoice != nil {
		s = append(s, "InternetVipChoice: "+fmt.Sprintf("%#v", this.InternetVipChoice)+",\n")
	}
	if this.Refs != nil {
		s = append(s, "Refs: "+fmt.Sprintf("%#v", this.Refs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VSiteRefType_DisableInternetVip) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VSiteRefType_DisableInternetVip{` +
		`DisableInternetVip:` + fmt.Sprintf("%#v", this.DisableInternetVip) + `}`}, ", ")
	return s
}
func (this *VSiteRefType_EnableInternetVip) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VSiteRefType_EnableInternetVip{` +
		`EnableInternetVip:` + fmt.Sprintf("%#v", this.EnableInternetVip) + `}`}, ", ")
	return s
}
func (this *PolicerRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.PolicerRefType{")
	if this.Ref != nil {
		s = append(s, "Ref: "+fmt.Sprintf("%#v", this.Ref)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProtocolPolicerRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.ProtocolPolicerRefType{")
	if this.Ref != nil {
		s = append(s, "Ref: "+fmt.Sprintf("%#v", this.Ref)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkSiteRefSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.NetworkSiteRefSelector{")
	if this.RefOrSelector != nil {
		s = append(s, "RefOrSelector: "+fmt.Sprintf("%#v", this.RefOrSelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkSiteRefSelector_VirtualNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.NetworkSiteRefSelector_VirtualNetwork{` +
		`VirtualNetwork:` + fmt.Sprintf("%#v", this.VirtualNetwork) + `}`}, ", ")
	return s
}
func (this *NetworkSiteRefSelector_Site) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.NetworkSiteRefSelector_Site{` +
		`Site:` + fmt.Sprintf("%#v", this.Site) + `}`}, ", ")
	return s
}
func (this *NetworkSiteRefSelector_VirtualSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.NetworkSiteRefSelector_VirtualSite{` +
		`VirtualSite:` + fmt.Sprintf("%#v", this.VirtualSite) + `}`}, ", ")
	return s
}
func (this *SiteVirtualSiteRefSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.SiteVirtualSiteRefSelector{")
	if this.RefOrSelector != nil {
		s = append(s, "RefOrSelector: "+fmt.Sprintf("%#v", this.RefOrSelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteVirtualSiteRefSelector_Site) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.SiteVirtualSiteRefSelector_Site{` +
		`Site:` + fmt.Sprintf("%#v", this.Site) + `}`}, ", ")
	return s
}
func (this *SiteVirtualSiteRefSelector_VirtualSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.SiteVirtualSiteRefSelector_VirtualSite{` +
		`VirtualSite:` + fmt.Sprintf("%#v", this.VirtualSite) + `}`}, ", ")
	return s
}
func (this *HeaderManipulationOptionType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.HeaderManipulationOptionType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.ValueChoice != nil {
		s = append(s, "ValueChoice: "+fmt.Sprintf("%#v", this.ValueChoice)+",\n")
	}
	s = append(s, "Append: "+fmt.Sprintf("%#v", this.Append)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HeaderManipulationOptionType_Value) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HeaderManipulationOptionType_Value{` +
		`Value:` + fmt.Sprintf("%#v", this.Value) + `}`}, ", ")
	return s
}
func (this *HeaderManipulationOptionType_SecretValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HeaderManipulationOptionType_SecretValue{` +
		`SecretValue:` + fmt.Sprintf("%#v", this.SecretValue) + `}`}, ", ")
	return s
}
func (this *CookieManipulationOptionType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&schema.CookieManipulationOptionType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Samesite != nil {
		s = append(s, "Samesite: "+fmt.Sprintf("%#v", this.Samesite)+",\n")
	}
	if this.Secure != nil {
		s = append(s, "Secure: "+fmt.Sprintf("%#v", this.Secure)+",\n")
	}
	if this.Httponly != nil {
		s = append(s, "Httponly: "+fmt.Sprintf("%#v", this.Httponly)+",\n")
	}
	if this.MaxAge != nil {
		s = append(s, "MaxAge: "+fmt.Sprintf("%#v", this.MaxAge)+",\n")
	}
	if this.CookieTampering != nil {
		s = append(s, "CookieTampering: "+fmt.Sprintf("%#v", this.CookieTampering)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CookieManipulationOptionType_IgnoreSamesite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.CookieManipulationOptionType_IgnoreSamesite{` +
		`IgnoreSamesite:` + fmt.Sprintf("%#v", this.IgnoreSamesite) + `}`}, ", ")
	return s
}
func (this *CookieManipulationOptionType_SamesiteStrict) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.CookieManipulationOptionType_SamesiteStrict{` +
		`SamesiteStrict:` + fmt.Sprintf("%#v", this.SamesiteStrict) + `}`}, ", ")
	return s
}
func (this *CookieManipulationOptionType_SamesiteLax) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.CookieManipulationOptionType_SamesiteLax{` +
		`SamesiteLax:` + fmt.Sprintf("%#v", this.SamesiteLax) + `}`}, ", ")
	return s
}
func (this *CookieManipulationOptionType_SamesiteNone) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.CookieManipulationOptionType_SamesiteNone{` +
		`SamesiteNone:` + fmt.Sprintf("%#v", this.SamesiteNone) + `}`}, ", ")
	return s
}
func (this *CookieManipulationOptionType_IgnoreSecure) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.CookieManipulationOptionType_IgnoreSecure{` +
		`IgnoreSecure:` + fmt.Sprintf("%#v", this.IgnoreSecure) + `}`}, ", ")
	return s
}
func (this *CookieManipulationOptionType_AddSecure) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.CookieManipulationOptionType_AddSecure{` +
		`AddSecure:` + fmt.Sprintf("%#v", this.AddSecure) + `}`}, ", ")
	return s
}
func (this *CookieManipulationOptionType_IgnoreHttponly) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.CookieManipulationOptionType_IgnoreHttponly{` +
		`IgnoreHttponly:` + fmt.Sprintf("%#v", this.IgnoreHttponly) + `}`}, ", ")
	return s
}
func (this *CookieManipulationOptionType_AddHttponly) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.CookieManipulationOptionType_AddHttponly{` +
		`AddHttponly:` + fmt.Sprintf("%#v", this.AddHttponly) + `}`}, ", ")
	return s
}
func (this *CookieManipulationOptionType_IgnoreMaxAge) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.CookieManipulationOptionType_IgnoreMaxAge{` +
		`IgnoreMaxAge:` + fmt.Sprintf("%#v", this.IgnoreMaxAge) + `}`}, ", ")
	return s
}
func (this *CookieManipulationOptionType_MaxAgeValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.CookieManipulationOptionType_MaxAgeValue{` +
		`MaxAgeValue:` + fmt.Sprintf("%#v", this.MaxAgeValue) + `}`}, ", ")
	return s
}
func (this *CookieManipulationOptionType_DisableTamperingProtection) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.CookieManipulationOptionType_DisableTamperingProtection{` +
		`DisableTamperingProtection:` + fmt.Sprintf("%#v", this.DisableTamperingProtection) + `}`}, ", ")
	return s
}
func (this *CookieManipulationOptionType_EnableTamperingProtection) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.CookieManipulationOptionType_EnableTamperingProtection{` +
		`EnableTamperingProtection:` + fmt.Sprintf("%#v", this.EnableTamperingProtection) + `}`}, ", ")
	return s
}
func (this *TrustedCAList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.TrustedCAList{")
	if this.TrustedCaList != nil {
		s = append(s, "TrustedCaList: "+fmt.Sprintf("%#v", this.TrustedCaList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TlsValidationParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.TlsValidationParamsType{")
	if this.TrustedCaChoice != nil {
		s = append(s, "TrustedCaChoice: "+fmt.Sprintf("%#v", this.TrustedCaChoice)+",\n")
	}
	s = append(s, "SkipHostnameVerification: "+fmt.Sprintf("%#v", this.SkipHostnameVerification)+",\n")
	s = append(s, "VerifySubjectAltNames: "+fmt.Sprintf("%#v", this.VerifySubjectAltNames)+",\n")
	s = append(s, "UseVolterraTrustedCaUrl: "+fmt.Sprintf("%#v", this.UseVolterraTrustedCaUrl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TlsValidationParamsType_TrustedCaUrl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsValidationParamsType_TrustedCaUrl{` +
		`TrustedCaUrl:` + fmt.Sprintf("%#v", this.TrustedCaUrl) + `}`}, ", ")
	return s
}
func (this *TlsValidationParamsType_TrustedCa) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsValidationParamsType_TrustedCa{` +
		`TrustedCa:` + fmt.Sprintf("%#v", this.TrustedCa) + `}`}, ", ")
	return s
}
func (this *HashAlgorithms) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.HashAlgorithms{")
	s = append(s, "HashAlgorithms: "+fmt.Sprintf("%#v", this.HashAlgorithms)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TlsCertificateType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.TlsCertificateType{")
	s = append(s, "CertificateUrl: "+fmt.Sprintf("%#v", this.CertificateUrl)+",\n")
	if this.PrivateKey != nil {
		s = append(s, "PrivateKey: "+fmt.Sprintf("%#v", this.PrivateKey)+",\n")
	}
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	if this.OcspStaplingChoice != nil {
		s = append(s, "OcspStaplingChoice: "+fmt.Sprintf("%#v", this.OcspStaplingChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TlsCertificateType_UseSystemDefaults) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsCertificateType_UseSystemDefaults{` +
		`UseSystemDefaults:` + fmt.Sprintf("%#v", this.UseSystemDefaults) + `}`}, ", ")
	return s
}
func (this *TlsCertificateType_DisableOcspStapling) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsCertificateType_DisableOcspStapling{` +
		`DisableOcspStapling:` + fmt.Sprintf("%#v", this.DisableOcspStapling) + `}`}, ", ")
	return s
}
func (this *TlsCertificateType_CustomHashAlgorithms) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsCertificateType_CustomHashAlgorithms{` +
		`CustomHashAlgorithms:` + fmt.Sprintf("%#v", this.CustomHashAlgorithms) + `}`}, ", ")
	return s
}
func (this *DomainType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.DomainType{")
	if this.DomainChoice != nil {
		s = append(s, "DomainChoice: "+fmt.Sprintf("%#v", this.DomainChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DomainType_ExactValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.DomainType_ExactValue{` +
		`ExactValue:` + fmt.Sprintf("%#v", this.ExactValue) + `}`}, ", ")
	return s
}
func (this *DomainType_SuffixValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.DomainType_SuffixValue{` +
		`SuffixValue:` + fmt.Sprintf("%#v", this.SuffixValue) + `}`}, ", ")
	return s
}
func (this *DomainType_RegexValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.DomainType_RegexValue{` +
		`RegexValue:` + fmt.Sprintf("%#v", this.RegexValue) + `}`}, ", ")
	return s
}
func (this *L4DestType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.L4DestType{")
	s = append(s, "Prefixes: "+fmt.Sprintf("%#v", this.Prefixes)+",\n")
	s = append(s, "PortRanges: "+fmt.Sprintf("%#v", this.PortRanges)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TlsInterceptionRule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.TlsInterceptionRule{")
	if this.DomainMatch != nil {
		s = append(s, "DomainMatch: "+fmt.Sprintf("%#v", this.DomainMatch)+",\n")
	}
	if this.EnableDisableChoice != nil {
		s = append(s, "EnableDisableChoice: "+fmt.Sprintf("%#v", this.EnableDisableChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TlsInterceptionRule_DisableInterception) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsInterceptionRule_DisableInterception{` +
		`DisableInterception:` + fmt.Sprintf("%#v", this.DisableInterception) + `}`}, ", ")
	return s
}
func (this *TlsInterceptionRule_EnableInterception) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsInterceptionRule_EnableInterception{` +
		`EnableInterception:` + fmt.Sprintf("%#v", this.EnableInterception) + `}`}, ", ")
	return s
}
func (this *TlsInterceptionPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.TlsInterceptionPolicy{")
	if this.InterceptionRules != nil {
		s = append(s, "InterceptionRules: "+fmt.Sprintf("%#v", this.InterceptionRules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TlsInterceptionType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.TlsInterceptionType{")
	if this.InterceptionPolicyChoice != nil {
		s = append(s, "InterceptionPolicyChoice: "+fmt.Sprintf("%#v", this.InterceptionPolicyChoice)+",\n")
	}
	if this.SigningCertChoice != nil {
		s = append(s, "SigningCertChoice: "+fmt.Sprintf("%#v", this.SigningCertChoice)+",\n")
	}
	if this.TrustedCaChoice != nil {
		s = append(s, "TrustedCaChoice: "+fmt.Sprintf("%#v", this.TrustedCaChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TlsInterceptionType_EnableForAllDomains) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsInterceptionType_EnableForAllDomains{` +
		`EnableForAllDomains:` + fmt.Sprintf("%#v", this.EnableForAllDomains) + `}`}, ", ")
	return s
}
func (this *TlsInterceptionType_Policy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsInterceptionType_Policy{` +
		`Policy:` + fmt.Sprintf("%#v", this.Policy) + `}`}, ", ")
	return s
}
func (this *TlsInterceptionType_CustomCertificate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsInterceptionType_CustomCertificate{` +
		`CustomCertificate:` + fmt.Sprintf("%#v", this.CustomCertificate) + `}`}, ", ")
	return s
}
func (this *TlsInterceptionType_VolterraCertificate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsInterceptionType_VolterraCertificate{` +
		`VolterraCertificate:` + fmt.Sprintf("%#v", this.VolterraCertificate) + `}`}, ", ")
	return s
}
func (this *TlsInterceptionType_TrustedCaUrl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsInterceptionType_TrustedCaUrl{` +
		`TrustedCaUrl:` + fmt.Sprintf("%#v", this.TrustedCaUrl) + `}`}, ", ")
	return s
}
func (this *TlsInterceptionType_VolterraTrustedCa) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsInterceptionType_VolterraTrustedCa{` +
		`VolterraTrustedCa:` + fmt.Sprintf("%#v", this.VolterraTrustedCa) + `}`}, ", ")
	return s
}
func (this *FractionalPercent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.FractionalPercent{")
	s = append(s, "Numerator: "+fmt.Sprintf("%#v", this.Numerator)+",\n")
	s = append(s, "Denominator: "+fmt.Sprintf("%#v", this.Denominator)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BufferConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.BufferConfigType{")
	s = append(s, "Disabled: "+fmt.Sprintf("%#v", this.Disabled)+",\n")
	s = append(s, "MaxRequestBytes: "+fmt.Sprintf("%#v", this.MaxRequestBytes)+",\n")
	s = append(s, "MaxRequestTime: "+fmt.Sprintf("%#v", this.MaxRequestTime)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CorsPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&schema.CorsPolicy{")
	s = append(s, "Disabled: "+fmt.Sprintf("%#v", this.Disabled)+",\n")
	s = append(s, "AllowOrigin: "+fmt.Sprintf("%#v", this.AllowOrigin)+",\n")
	s = append(s, "AllowOriginRegex: "+fmt.Sprintf("%#v", this.AllowOriginRegex)+",\n")
	s = append(s, "AllowMethods: "+fmt.Sprintf("%#v", this.AllowMethods)+",\n")
	s = append(s, "AllowHeaders: "+fmt.Sprintf("%#v", this.AllowHeaders)+",\n")
	s = append(s, "ExposeHeaders: "+fmt.Sprintf("%#v", this.ExposeHeaders)+",\n")
	s = append(s, "MaxAge: "+fmt.Sprintf("%#v", this.MaxAge)+",\n")
	s = append(s, "MaximumAge: "+fmt.Sprintf("%#v", this.MaximumAge)+",\n")
	s = append(s, "AllowCredentials: "+fmt.Sprintf("%#v", this.AllowCredentials)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CsrfPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.CsrfPolicy{")
	if this.AllowedDomains != nil {
		s = append(s, "AllowedDomains: "+fmt.Sprintf("%#v", this.AllowedDomains)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CsrfPolicy_AllLoadBalancerDomains) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.CsrfPolicy_AllLoadBalancerDomains{` +
		`AllLoadBalancerDomains:` + fmt.Sprintf("%#v", this.AllLoadBalancerDomains) + `}`}, ", ")
	return s
}
func (this *CsrfPolicy_CustomDomainList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.CsrfPolicy_CustomDomainList{` +
		`CustomDomainList:` + fmt.Sprintf("%#v", this.CustomDomainList) + `}`}, ", ")
	return s
}
func (this *CsrfPolicy_Disabled) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.CsrfPolicy_Disabled{` +
		`Disabled:` + fmt.Sprintf("%#v", this.Disabled) + `}`}, ", ")
	return s
}
func (this *PathMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.PathMatcherType{")
	if this.PathMatch != nil {
		s = append(s, "PathMatch: "+fmt.Sprintf("%#v", this.PathMatch)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PathMatcherType_Prefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.PathMatcherType_Prefix{` +
		`Prefix:` + fmt.Sprintf("%#v", this.Prefix) + `}`}, ", ")
	return s
}
func (this *PathMatcherType_Path) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.PathMatcherType_Path{` +
		`Path:` + fmt.Sprintf("%#v", this.Path) + `}`}, ", ")
	return s
}
func (this *PathMatcherType_Regex) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.PathMatcherType_Regex{` +
		`Regex:` + fmt.Sprintf("%#v", this.Regex) + `}`}, ", ")
	return s
}
func (this *PortMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.PortMatcherType{")
	if this.PortMatch != nil {
		s = append(s, "PortMatch: "+fmt.Sprintf("%#v", this.PortMatch)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PortMatcherType_Port) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.PortMatcherType_Port{` +
		`Port:` + fmt.Sprintf("%#v", this.Port) + `}`}, ", ")
	return s
}
func (this *PortMatcherType_PortRanges) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.PortMatcherType_PortRanges{` +
		`PortRanges:` + fmt.Sprintf("%#v", this.PortRanges) + `}`}, ", ")
	return s
}
func (this *PortMatcherType_NoPortMatch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.PortMatcherType_NoPortMatch{` +
		`NoPortMatch:` + fmt.Sprintf("%#v", this.NoPortMatch) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.HeaderMatcherType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.ValueMatch != nil {
		s = append(s, "ValueMatch: "+fmt.Sprintf("%#v", this.ValueMatch)+",\n")
	}
	s = append(s, "InvertMatch: "+fmt.Sprintf("%#v", this.InvertMatch)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HeaderMatcherType_Exact) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HeaderMatcherType_Exact{` +
		`Exact:` + fmt.Sprintf("%#v", this.Exact) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherType_Regex) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HeaderMatcherType_Regex{` +
		`Regex:` + fmt.Sprintf("%#v", this.Regex) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherType_Presence) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HeaderMatcherType_Presence{` +
		`Presence:` + fmt.Sprintf("%#v", this.Presence) + `}`}, ", ")
	return s
}
func (this *QueryParameterMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.QueryParameterMatcherType{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	if this.ValueMatch != nil {
		s = append(s, "ValueMatch: "+fmt.Sprintf("%#v", this.ValueMatch)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueryParameterMatcherType_Exact) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.QueryParameterMatcherType_Exact{` +
		`Exact:` + fmt.Sprintf("%#v", this.Exact) + `}`}, ", ")
	return s
}
func (this *QueryParameterMatcherType_Regex) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.QueryParameterMatcherType_Regex{` +
		`Regex:` + fmt.Sprintf("%#v", this.Regex) + `}`}, ", ")
	return s
}
func (this *RouteMatch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.RouteMatch{")
	if this.Path != nil {
		s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	}
	if this.Headers != nil {
		s = append(s, "Headers: "+fmt.Sprintf("%#v", this.Headers)+",\n")
	}
	if this.QueryParams != nil {
		s = append(s, "QueryParams: "+fmt.Sprintf("%#v", this.QueryParams)+",\n")
	}
	s = append(s, "HttpMethod: "+fmt.Sprintf("%#v", this.HttpMethod)+",\n")
	if this.IncomingPort != nil {
		s = append(s, "IncomingPort: "+fmt.Sprintf("%#v", this.IncomingPort)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AppFirewallRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.AppFirewallRefType{")
	if this.AppFirewall != nil {
		s = append(s, "AppFirewall: "+fmt.Sprintf("%#v", this.AppFirewall)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WafType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.WafType{")
	if this.RefType != nil {
		s = append(s, "RefType: "+fmt.Sprintf("%#v", this.RefType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WafType_AppFirewall) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.WafType_AppFirewall{` +
		`AppFirewall:` + fmt.Sprintf("%#v", this.AppFirewall) + `}`}, ", ")
	return s
}
func (this *WafType_DisableWaf) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.WafType_DisableWaf{` +
		`DisableWaf:` + fmt.Sprintf("%#v", this.DisableWaf) + `}`}, ", ")
	return s
}
func (this *WafType_InheritWaf) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.WafType_InheritWaf{` +
		`InheritWaf:` + fmt.Sprintf("%#v", this.InheritWaf) + `}`}, ", ")
	return s
}
func (this *AppRoleAuthInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.AppRoleAuthInfoType{")
	s = append(s, "RoleId: "+fmt.Sprintf("%#v", this.RoleId)+",\n")
	if this.SecretId != nil {
		s = append(s, "SecretId: "+fmt.Sprintf("%#v", this.SecretId)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VaultAuthInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.VaultAuthInfoType{")
	if this.AuthParams != nil {
		s = append(s, "AuthParams: "+fmt.Sprintf("%#v", this.AuthParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VaultAuthInfoType_AppRoleAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VaultAuthInfoType_AppRoleAuth{` +
		`AppRoleAuth:` + fmt.Sprintf("%#v", this.AppRoleAuth) + `}`}, ", ")
	return s
}
func (this *VaultAuthInfoType_Token) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VaultAuthInfoType_Token{` +
		`Token:` + fmt.Sprintf("%#v", this.Token) + `}`}, ", ")
	return s
}
func (this *RestAuthInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.RestAuthInfoType{")
	if this.AuthParams != nil {
		s = append(s, "AuthParams: "+fmt.Sprintf("%#v", this.AuthParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RestAuthInfoType_BasicAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.RestAuthInfoType_BasicAuth{` +
		`BasicAuth:` + fmt.Sprintf("%#v", this.BasicAuth) + `}`}, ", ")
	return s
}
func (this *RestAuthInfoType_HeadersAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.RestAuthInfoType_HeadersAuth{` +
		`HeadersAuth:` + fmt.Sprintf("%#v", this.HeadersAuth) + `}`}, ", ")
	return s
}
func (this *RestAuthInfoType_QueryParamsAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.RestAuthInfoType_QueryParamsAuth{` +
		`QueryParamsAuth:` + fmt.Sprintf("%#v", this.QueryParamsAuth) + `}`}, ", ")
	return s
}
func (this *VaultAccessInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.VaultAccessInfoType{")
	s = append(s, "VaultAddr: "+fmt.Sprintf("%#v", this.VaultAddr)+",\n")
	s = append(s, "VaultCaUrl: "+fmt.Sprintf("%#v", this.VaultCaUrl)+",\n")
	if this.AuthnChoice != nil {
		s = append(s, "AuthnChoice: "+fmt.Sprintf("%#v", this.AuthnChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VaultAccessInfoType_AppRoleAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VaultAccessInfoType_AppRoleAuth{` +
		`AppRoleAuth:` + fmt.Sprintf("%#v", this.AppRoleAuth) + `}`}, ", ")
	return s
}
func (this *VaultAccessInfoType_Token) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VaultAccessInfoType_Token{` +
		`Token:` + fmt.Sprintf("%#v", this.Token) + `}`}, ", ")
	return s
}
func (this *VaultSecretType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.VaultSecretType{")
	if this.AccessChoice != nil {
		s = append(s, "AccessChoice: "+fmt.Sprintf("%#v", this.AccessChoice)+",\n")
	}
	s = append(s, "SecretPath: "+fmt.Sprintf("%#v", this.SecretPath)+",\n")
	s = append(s, "SecretSubPath: "+fmt.Sprintf("%#v", this.SecretSubPath)+",\n")
	s = append(s, "SecretVersion: "+fmt.Sprintf("%#v", this.SecretVersion)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VaultSecretType_VaultAccessInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VaultSecretType_VaultAccessInfo{` +
		`VaultAccessInfo:` + fmt.Sprintf("%#v", this.VaultAccessInfo) + `}`}, ", ")
	return s
}
func (this *VaultSecretType_ProviderName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VaultSecretType_ProviderName{` +
		`ProviderName:` + fmt.Sprintf("%#v", this.ProviderName) + `}`}, ", ")
	return s
}
func (this *VolterraSecretType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.VolterraSecretType{")
	if this.SecretTypeChoice != nil {
		s = append(s, "SecretTypeChoice: "+fmt.Sprintf("%#v", this.SecretTypeChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VolterraSecretType_BlindfoldSecretInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VolterraSecretType_BlindfoldSecretInfo{` +
		`BlindfoldSecretInfo:` + fmt.Sprintf("%#v", this.BlindfoldSecretInfo) + `}`}, ", ")
	return s
}
func (this *VolterraSecretType_VaultSecretInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VolterraSecretType_VaultSecretInfo{` +
		`VaultSecretInfo:` + fmt.Sprintf("%#v", this.VaultSecretInfo) + `}`}, ", ")
	return s
}
func (this *PortValueType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.PortValueType{")
	if this.PortValueTypeChoice != nil {
		s = append(s, "PortValueTypeChoice: "+fmt.Sprintf("%#v", this.PortValueTypeChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PortValueType_All) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.PortValueType_All{` +
		`All:` + fmt.Sprintf("%#v", this.All) + `}`}, ", ")
	return s
}
func (this *PortValueType_UserDefined) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.PortValueType_UserDefined{` +
		`UserDefined:` + fmt.Sprintf("%#v", this.UserDefined) + `}`}, ", ")
	return s
}
func (this *PortValueType_Dns) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.PortValueType_Dns{` +
		`Dns:` + fmt.Sprintf("%#v", this.Dns) + `}`}, ", ")
	return s
}
func (this *VirtualNetworkReferenceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.VirtualNetworkReferenceType{")
	if this.Refs != nil {
		s = append(s, "Refs: "+fmt.Sprintf("%#v", this.Refs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VirtualNetworkSelectorType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.VirtualNetworkSelectorType{")
	if this.VnTypeChoice != nil {
		s = append(s, "VnTypeChoice: "+fmt.Sprintf("%#v", this.VnTypeChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VirtualNetworkSelectorType_SiteLocal) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VirtualNetworkSelectorType_SiteLocal{` +
		`SiteLocal:` + fmt.Sprintf("%#v", this.SiteLocal) + `}`}, ", ")
	return s
}
func (this *VirtualNetworkSelectorType_SiteLocalInside) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VirtualNetworkSelectorType_SiteLocalInside{` +
		`SiteLocalInside:` + fmt.Sprintf("%#v", this.SiteLocalInside) + `}`}, ", ")
	return s
}
func (this *VirtualNetworkSelectorType_Public) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VirtualNetworkSelectorType_Public{` +
		`Public:` + fmt.Sprintf("%#v", this.Public) + `}`}, ", ")
	return s
}
func (this *RetryBackOff) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.RetryBackOff{")
	s = append(s, "BaseInterval: "+fmt.Sprintf("%#v", this.BaseInterval)+",\n")
	s = append(s, "MaxInterval: "+fmt.Sprintf("%#v", this.MaxInterval)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RetryPolicyType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.RetryPolicyType{")
	s = append(s, "RetryOn: "+fmt.Sprintf("%#v", this.RetryOn)+",\n")
	s = append(s, "RetryCondition: "+fmt.Sprintf("%#v", this.RetryCondition)+",\n")
	s = append(s, "NumRetries: "+fmt.Sprintf("%#v", this.NumRetries)+",\n")
	s = append(s, "PerTryTimeout: "+fmt.Sprintf("%#v", this.PerTryTimeout)+",\n")
	s = append(s, "RetriableStatusCodes: "+fmt.Sprintf("%#v", this.RetriableStatusCodes)+",\n")
	if this.BackOff != nil {
		s = append(s, "BackOff: "+fmt.Sprintf("%#v", this.BackOff)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MetricValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.MetricValue{")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	if this.TrendValue != nil {
		s = append(s, "TrendValue: "+fmt.Sprintf("%#v", this.TrendValue)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MetricTypeData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.MetricTypeData{")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	if this.Values != nil {
		s = append(s, "Values: "+fmt.Sprintf("%#v", this.Values)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TrendValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.TrendValue{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "Sentiment: "+fmt.Sprintf("%#v", this.Sentiment)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "PreviousValue: "+fmt.Sprintf("%#v", this.PreviousValue)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NextHopType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.NextHopType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.NexthopAddress != nil {
		s = append(s, "NexthopAddress: "+fmt.Sprintf("%#v", this.NexthopAddress)+",\n")
	}
	if this.Interface != nil {
		s = append(s, "Interface: "+fmt.Sprintf("%#v", this.Interface)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StaticRouteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.StaticRouteType{")
	s = append(s, "Attrs: "+fmt.Sprintf("%#v", this.Attrs)+",\n")
	if this.Subnets != nil {
		s = append(s, "Subnets: "+fmt.Sprintf("%#v", this.Subnets)+",\n")
	}
	if this.Nexthop != nil {
		s = append(s, "Nexthop: "+fmt.Sprintf("%#v", this.Nexthop)+",\n")
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ForwardProxyConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.ForwardProxyConfigType{")
	s = append(s, "WhiteListedPrefixes: "+fmt.Sprintf("%#v", this.WhiteListedPrefixes)+",\n")
	s = append(s, "WhiteListedPorts: "+fmt.Sprintf("%#v", this.WhiteListedPorts)+",\n")
	s = append(s, "MaxConnectAttempts: "+fmt.Sprintf("%#v", this.MaxConnectAttempts)+",\n")
	s = append(s, "ConnectionTimeout: "+fmt.Sprintf("%#v", this.ConnectionTimeout)+",\n")
	if this.TlsInterceptionChoice != nil {
		s = append(s, "TlsInterceptionChoice: "+fmt.Sprintf("%#v", this.TlsInterceptionChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ForwardProxyConfigType_NoInterception) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.ForwardProxyConfigType_NoInterception{` +
		`NoInterception:` + fmt.Sprintf("%#v", this.NoInterception) + `}`}, ", ")
	return s
}
func (this *ForwardProxyConfigType_TlsIntercept) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.ForwardProxyConfigType_TlsIntercept{` +
		`TlsIntercept:` + fmt.Sprintf("%#v", this.TlsIntercept) + `}`}, ", ")
	return s
}
func (this *HostIdentifier) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.HostIdentifier{")
	if this.HostnameOrIp != nil {
		s = append(s, "HostnameOrIp: "+fmt.Sprintf("%#v", this.HostnameOrIp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HostIdentifier_Ip) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HostIdentifier_Ip{` +
		`Ip:` + fmt.Sprintf("%#v", this.Ip) + `}`}, ", ")
	return s
}
func (this *HostIdentifier_Hostname) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HostIdentifier_Hostname{` +
		`Hostname:` + fmt.Sprintf("%#v", this.Hostname) + `}`}, ", ")
	return s
}
func (this *InterfaceIdentifier) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.InterfaceIdentifier{")
	if this.InterfaceChoice != nil {
		s = append(s, "InterfaceChoice: "+fmt.Sprintf("%#v", this.InterfaceChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InterfaceIdentifier_AnyIntf) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.InterfaceIdentifier_AnyIntf{` +
		`AnyIntf:` + fmt.Sprintf("%#v", this.AnyIntf) + `}`}, ", ")
	return s
}
func (this *InterfaceIdentifier_Intf) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.InterfaceIdentifier_Intf{` +
		`Intf:` + fmt.Sprintf("%#v", this.Intf) + `}`}, ", ")
	return s
}
func (this *InterfaceOrNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.InterfaceOrNetwork{")
	if this.InterfaceChoice != nil {
		s = append(s, "InterfaceChoice: "+fmt.Sprintf("%#v", this.InterfaceChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InterfaceOrNetwork_Intf) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.InterfaceOrNetwork_Intf{` +
		`Intf:` + fmt.Sprintf("%#v", this.Intf) + `}`}, ", ")
	return s
}
func (this *InterfaceOrNetwork_Pod) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.InterfaceOrNetwork_Pod{` +
		`Pod:` + fmt.Sprintf("%#v", this.Pod) + `}`}, ", ")
	return s
}
func (this *InterfaceOrNetwork_VnType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.InterfaceOrNetwork_VnType{` +
		`VnType:` + fmt.Sprintf("%#v", this.VnType) + `}`}, ", ")
	return s
}
func (this *InterfaceOrNetwork_Vn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.InterfaceOrNetwork_Vn{` +
		`Vn:` + fmt.Sprintf("%#v", this.Vn) + `}`}, ", ")
	return s
}
func (this *RouteTarget2ByteAsn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.RouteTarget2ByteAsn{")
	s = append(s, "AsNumber: "+fmt.Sprintf("%#v", this.AsNumber)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteTarget4ByteAsn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.RouteTarget4ByteAsn{")
	s = append(s, "AsNumber: "+fmt.Sprintf("%#v", this.AsNumber)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteTargetIPv4Addr) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.RouteTargetIPv4Addr{")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteTarget) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.RouteTarget{")
	if this.RtargetChoice != nil {
		s = append(s, "RtargetChoice: "+fmt.Sprintf("%#v", this.RtargetChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteTarget_Asn2ByteRtarget) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.RouteTarget_Asn2ByteRtarget{` +
		`Asn2ByteRtarget:` + fmt.Sprintf("%#v", this.Asn2ByteRtarget) + `}`}, ", ")
	return s
}
func (this *RouteTarget_Ipv4AddrRtarget) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.RouteTarget_Ipv4AddrRtarget{` +
		`Ipv4AddrRtarget:` + fmt.Sprintf("%#v", this.Ipv4AddrRtarget) + `}`}, ", ")
	return s
}
func (this *RouteTarget_Asn4ByteRtarget) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.RouteTarget_Asn4ByteRtarget{` +
		`Asn4ByteRtarget:` + fmt.Sprintf("%#v", this.Asn4ByteRtarget) + `}`}, ", ")
	return s
}
func (this *PortRangesType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.PortRangesType{")
	s = append(s, "Ports: "+fmt.Sprintf("%#v", this.Ports)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DomainNameList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DomainNameList{")
	s = append(s, "Domains: "+fmt.Sprintf("%#v", this.Domains)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NamespaceRoleType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.NamespaceRoleType{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RoleListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.RoleListType{")
	s = append(s, "Names: "+fmt.Sprintf("%#v", this.Names)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NamespaceAccessType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.NamespaceAccessType{")
	keysForNamespaceRoleMap := make([]string, 0, len(this.NamespaceRoleMap))
	for k, _ := range this.NamespaceRoleMap {
		keysForNamespaceRoleMap = append(keysForNamespaceRoleMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForNamespaceRoleMap)
	mapStringForNamespaceRoleMap := "map[string]*RoleListType{"
	for _, k := range keysForNamespaceRoleMap {
		mapStringForNamespaceRoleMap += fmt.Sprintf("%#v: %#v,", k, this.NamespaceRoleMap[k])
	}
	mapStringForNamespaceRoleMap += "}"
	if this.NamespaceRoleMap != nil {
		s = append(s, "NamespaceRoleMap: "+mapStringForNamespaceRoleMap+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.SiteInfo{")
	if this.Site != nil {
		s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	}
	s = append(s, "Annotations: "+fmt.Sprintf("%#v", this.Annotations)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteReferenceListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.SiteReferenceListType{")
	if this.Refs != nil {
		s = append(s, "Refs: "+fmt.Sprintf("%#v", this.Refs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HeaderTransformationType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.HeaderTransformationType{")
	if this.HeaderTransformationChoice != nil {
		s = append(s, "HeaderTransformationChoice: "+fmt.Sprintf("%#v", this.HeaderTransformationChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HeaderTransformationType_LegacyHeaderTransformation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HeaderTransformationType_LegacyHeaderTransformation{` +
		`LegacyHeaderTransformation:` + fmt.Sprintf("%#v", this.LegacyHeaderTransformation) + `}`}, ", ")
	return s
}
func (this *HeaderTransformationType_DefaultHeaderTransformation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HeaderTransformationType_DefaultHeaderTransformation{` +
		`DefaultHeaderTransformation:` + fmt.Sprintf("%#v", this.DefaultHeaderTransformation) + `}`}, ", ")
	return s
}
func (this *HeaderTransformationType_ProperCaseHeaderTransformation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HeaderTransformationType_ProperCaseHeaderTransformation{` +
		`ProperCaseHeaderTransformation:` + fmt.Sprintf("%#v", this.ProperCaseHeaderTransformation) + `}`}, ", ")
	return s
}
func (this *HeaderTransformationType_PreserveCaseHeaderTransformation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HeaderTransformationType_PreserveCaseHeaderTransformation{` +
		`PreserveCaseHeaderTransformation:` + fmt.Sprintf("%#v", this.PreserveCaseHeaderTransformation) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelCategoriesChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&schema.BotDefenseFlowLabelCategoriesChoiceType{")
	if this.FlowLabelChoice != nil {
		s = append(s, "FlowLabelChoice: "+fmt.Sprintf("%#v", this.FlowLabelChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BotDefenseFlowLabelCategoriesChoiceType_Authentication) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelCategoriesChoiceType_Authentication{` +
		`Authentication:` + fmt.Sprintf("%#v", this.Authentication) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelCategoriesChoiceType_AccountManagement) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelCategoriesChoiceType_AccountManagement{` +
		`AccountManagement:` + fmt.Sprintf("%#v", this.AccountManagement) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelCategoriesChoiceType_ProfileManagement) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelCategoriesChoiceType_ProfileManagement{` +
		`ProfileManagement:` + fmt.Sprintf("%#v", this.ProfileManagement) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelCategoriesChoiceType_ShoppingGiftCards) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelCategoriesChoiceType_ShoppingGiftCards{` +
		`ShoppingGiftCards:` + fmt.Sprintf("%#v", this.ShoppingGiftCards) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelCategoriesChoiceType_FinancialServices) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelCategoriesChoiceType_FinancialServices{` +
		`FinancialServices:` + fmt.Sprintf("%#v", this.FinancialServices) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelCategoriesChoiceType_Search) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelCategoriesChoiceType_Search{` +
		`Search:` + fmt.Sprintf("%#v", this.Search) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelCategoriesChoiceType_Flight) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelCategoriesChoiceType_Flight{` +
		`Flight:` + fmt.Sprintf("%#v", this.Flight) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelAuthenticationChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.BotDefenseFlowLabelAuthenticationChoiceType{")
	if this.LabelChoice != nil {
		s = append(s, "LabelChoice: "+fmt.Sprintf("%#v", this.LabelChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BotDefenseFlowLabelAuthenticationChoiceType_Login) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelAuthenticationChoiceType_Login{` +
		`Login:` + fmt.Sprintf("%#v", this.Login) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelAuthenticationChoiceType_LoginMfa) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelAuthenticationChoiceType_LoginMfa{` +
		`LoginMfa:` + fmt.Sprintf("%#v", this.LoginMfa) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelAuthenticationChoiceType_LoginPartner) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelAuthenticationChoiceType_LoginPartner{` +
		`LoginPartner:` + fmt.Sprintf("%#v", this.LoginPartner) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelAuthenticationChoiceType_Logout) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelAuthenticationChoiceType_Logout{` +
		`Logout:` + fmt.Sprintf("%#v", this.Logout) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelAuthenticationChoiceType_TokenRefresh) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelAuthenticationChoiceType_TokenRefresh{` +
		`TokenRefresh:` + fmt.Sprintf("%#v", this.TokenRefresh) + `}`}, ", ")
	return s
}
func (this *BotDefenseTransactionResult) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.BotDefenseTransactionResult{")
	if this.TransactionResultChoice != nil {
		s = append(s, "TransactionResultChoice: "+fmt.Sprintf("%#v", this.TransactionResultChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BotDefenseTransactionResult_DisableTransactionResult) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseTransactionResult_DisableTransactionResult{` +
		`DisableTransactionResult:` + fmt.Sprintf("%#v", this.DisableTransactionResult) + `}`}, ", ")
	return s
}
func (this *BotDefenseTransactionResult_TransactionResult) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseTransactionResult_TransactionResult{` +
		`TransactionResult:` + fmt.Sprintf("%#v", this.TransactionResult) + `}`}, ", ")
	return s
}
func (this *BotDefenseTransactionResultType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.BotDefenseTransactionResultType{")
	if this.SuccessConditions != nil {
		s = append(s, "SuccessConditions: "+fmt.Sprintf("%#v", this.SuccessConditions)+",\n")
	}
	if this.FailureConditions != nil {
		s = append(s, "FailureConditions: "+fmt.Sprintf("%#v", this.FailureConditions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BotDefenseTransactionResultCondition) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.BotDefenseTransactionResultCondition{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "RegexValues: "+fmt.Sprintf("%#v", this.RegexValues)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BotDefenseFlowLabelAccountManagementChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.BotDefenseFlowLabelAccountManagementChoiceType{")
	if this.LabelChoice != nil {
		s = append(s, "LabelChoice: "+fmt.Sprintf("%#v", this.LabelChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BotDefenseFlowLabelAccountManagementChoiceType_Create) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelAccountManagementChoiceType_Create{` +
		`Create:` + fmt.Sprintf("%#v", this.Create) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelAccountManagementChoiceType_PasswordReset) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelAccountManagementChoiceType_PasswordReset{` +
		`PasswordReset:` + fmt.Sprintf("%#v", this.PasswordReset) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelProfileManagementChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.BotDefenseFlowLabelProfileManagementChoiceType{")
	if this.LabelChoice != nil {
		s = append(s, "LabelChoice: "+fmt.Sprintf("%#v", this.LabelChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BotDefenseFlowLabelProfileManagementChoiceType_Create) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelProfileManagementChoiceType_Create{` +
		`Create:` + fmt.Sprintf("%#v", this.Create) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelProfileManagementChoiceType_Update) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelProfileManagementChoiceType_Update{` +
		`Update:` + fmt.Sprintf("%#v", this.Update) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelProfileManagementChoiceType_View) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelProfileManagementChoiceType_View{` +
		`View:` + fmt.Sprintf("%#v", this.View) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&schema.BotDefenseFlowLabelShoppingGiftCardsChoiceType{")
	if this.LabelChoice != nil {
		s = append(s, "LabelChoice: "+fmt.Sprintf("%#v", this.LabelChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopAddToCart) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopAddToCart{` +
		`ShopAddToCart:` + fmt.Sprintf("%#v", this.ShopAddToCart) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPromoCodeValidation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPromoCodeValidation{` +
		`ShopPromoCodeValidation:` + fmt.Sprintf("%#v", this.ShopPromoCodeValidation) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopCheckout) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopCheckout{` +
		`ShopCheckout:` + fmt.Sprintf("%#v", this.ShopCheckout) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopMakePayment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopMakePayment{` +
		`ShopMakePayment:` + fmt.Sprintf("%#v", this.ShopMakePayment) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopOrder) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopOrder{` +
		`ShopOrder:` + fmt.Sprintf("%#v", this.ShopOrder) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPriceInquiry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPriceInquiry{` +
		`ShopPriceInquiry:` + fmt.Sprintf("%#v", this.ShopPriceInquiry) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPurchaseGiftCard) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPurchaseGiftCard{` +
		`ShopPurchaseGiftCard:` + fmt.Sprintf("%#v", this.ShopPurchaseGiftCard) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopUpdateQuantity) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopUpdateQuantity{` +
		`ShopUpdateQuantity:` + fmt.Sprintf("%#v", this.ShopUpdateQuantity) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopChooseSeat) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopChooseSeat{` +
		`ShopChooseSeat:` + fmt.Sprintf("%#v", this.ShopChooseSeat) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopEnterDrawingSubmission) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopEnterDrawingSubmission{` +
		`ShopEnterDrawingSubmission:` + fmt.Sprintf("%#v", this.ShopEnterDrawingSubmission) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardValidation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardValidation{` +
		`GiftCardValidation:` + fmt.Sprintf("%#v", this.GiftCardValidation) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardMakePurchaseWithGiftCard) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardMakePurchaseWithGiftCard{` +
		`GiftCardMakePurchaseWithGiftCard:` + fmt.Sprintf("%#v", this.GiftCardMakePurchaseWithGiftCard) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelFinancialServicesChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.BotDefenseFlowLabelFinancialServicesChoiceType{")
	if this.LabelChoice != nil {
		s = append(s, "LabelChoice: "+fmt.Sprintf("%#v", this.LabelChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BotDefenseFlowLabelFinancialServicesChoiceType_Apply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelFinancialServicesChoiceType_Apply{` +
		`Apply:` + fmt.Sprintf("%#v", this.Apply) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelFinancialServicesChoiceType_MoneyTransfer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelFinancialServicesChoiceType_MoneyTransfer{` +
		`MoneyTransfer:` + fmt.Sprintf("%#v", this.MoneyTransfer) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelSearchChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.BotDefenseFlowLabelSearchChoiceType{")
	if this.LabelChoice != nil {
		s = append(s, "LabelChoice: "+fmt.Sprintf("%#v", this.LabelChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BotDefenseFlowLabelSearchChoiceType_FlightSearch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelSearchChoiceType_FlightSearch{` +
		`FlightSearch:` + fmt.Sprintf("%#v", this.FlightSearch) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelSearchChoiceType_ProductSearch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelSearchChoiceType_ProductSearch{` +
		`ProductSearch:` + fmt.Sprintf("%#v", this.ProductSearch) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelSearchChoiceType_RoomSearch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelSearchChoiceType_RoomSearch{` +
		`RoomSearch:` + fmt.Sprintf("%#v", this.RoomSearch) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelSearchChoiceType_ReservationSearch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelSearchChoiceType_ReservationSearch{` +
		`ReservationSearch:` + fmt.Sprintf("%#v", this.ReservationSearch) + `}`}, ", ")
	return s
}
func (this *BotDefenseFlowLabelFlightChoiceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.BotDefenseFlowLabelFlightChoiceType{")
	if this.LabelChoice != nil {
		s = append(s, "LabelChoice: "+fmt.Sprintf("%#v", this.LabelChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BotDefenseFlowLabelFlightChoiceType_Checkin) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.BotDefenseFlowLabelFlightChoiceType_Checkin{` +
		`Checkin:` + fmt.Sprintf("%#v", this.Checkin) + `}`}, ", ")
	return s
}
func (this *NetworkingStackType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.NetworkingStackType{")
	if this.Choice != nil {
		s = append(s, "Choice: "+fmt.Sprintf("%#v", this.Choice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkingStackType_Ipv4) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.NetworkingStackType_Ipv4{` +
		`Ipv4:` + fmt.Sprintf("%#v", this.Ipv4) + `}`}, ", ")
	return s
}
func (this *NetworkingStackType_Ipv6) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.NetworkingStackType_Ipv6{` +
		`Ipv6:` + fmt.Sprintf("%#v", this.Ipv6) + `}`}, ", ")
	return s
}
func (this *NetworkingStackType_Dual) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.NetworkingStackType_Dual{` +
		`Dual:` + fmt.Sprintf("%#v", this.Dual) + `}`}, ", ")
	return s
}
func (this *DateRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.DateRange{")
	if this.StartDate != nil {
		s = append(s, "StartDate: "+fmt.Sprintf("%#v", this.StartDate)+",\n")
	}
	if this.EndDate != nil {
		s = append(s, "EndDate: "+fmt.Sprintf("%#v", this.EndDate)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *File) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.File{")
	s = append(s, "ContentType: "+fmt.Sprintf("%#v", this.ContentType)+",\n")
	s = append(s, "Content: "+fmt.Sprintf("%#v", this.Content)+",\n")
	s = append(s, "FileId: "+fmt.Sprintf("%#v", this.FileId)+",\n")
	if this.StorageProvider != nil {
		s = append(s, "StorageProvider: "+fmt.Sprintf("%#v", this.StorageProvider)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *File_AwsS3) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.File_AwsS3{` +
		`AwsS3:` + fmt.Sprintf("%#v", this.AwsS3) + `}`}, ", ")
	return s
}
func (this *ResponseMeta) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.ResponseMeta{")
	s = append(s, "ErrorCode: "+fmt.Sprintf("%#v", this.ErrorCode)+",\n")
	s = append(s, "DisplayMessage: "+fmt.Sprintf("%#v", this.DisplayMessage)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Action) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.Action{")
	if this.ActionChoice != nil {
		s = append(s, "ActionChoice: "+fmt.Sprintf("%#v", this.ActionChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Action_Block) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.Action_Block{` +
		`Block:` + fmt.Sprintf("%#v", this.Block) + `}`}, ", ")
	return s
}
func (this *Action_Report) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.Action_Report{` +
		`Report:` + fmt.Sprintf("%#v", this.Report) + `}`}, ", ")
	return s
}
func (this *CRMInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.CRMInfo{")
	s = append(s, "AccountId: "+fmt.Sprintf("%#v", this.AccountId)+",\n")
	s = append(s, "EntitlementId: "+fmt.Sprintf("%#v", this.EntitlementId)+",\n")
	s = append(s, "SubscriptionId: "+fmt.Sprintf("%#v", this.SubscriptionId)+",\n")
	s = append(s, "OrderType: "+fmt.Sprintf("%#v", this.OrderType)+",\n")
	s = append(s, "EntitledSkus: "+fmt.Sprintf("%#v", this.EntitledSkus)+",\n")
	s = append(s, "CustomerIdentifier: "+fmt.Sprintf("%#v", this.CustomerIdentifier)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RegexMatchRewrite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.RegexMatchRewrite{")
	s = append(s, "Pattern: "+fmt.Sprintf("%#v", this.Pattern)+",\n")
	s = append(s, "Substitution: "+fmt.Sprintf("%#v", this.Substitution)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ObjectRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Tenant) > 0 {
		i -= len(m.Tenant)
		copy(dAtA[i:], m.Tenant)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Tenant)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LabelSelectorType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelSelectorType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LabelSelectorType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Expressions) > 0 {
		for iNdEx := len(m.Expressions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Expressions[iNdEx])
			copy(dAtA[i:], m.Expressions[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Expressions[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LabelMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LabelMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ConditionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConditionType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConditionType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ServiceName) > 0 {
		i -= len(m.ServiceName)
		copy(dAtA[i:], m.ServiceName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServiceName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x32
	}
	if m.LastUpdateTime != nil {
		{
			size, err := m.LastUpdateTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InitializerType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitializerType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InitializerType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InitializersType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitializersType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InitializersType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Pending) > 0 {
		for iNdEx := len(m.Pending) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pending[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StatusMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusMetaType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusMetaType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VtrpStale {
		i--
		if m.VtrpStale {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.VtrpId) > 0 {
		i -= len(m.VtrpId)
		copy(dAtA[i:], m.VtrpId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VtrpId)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Publish != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Publish))
		i--
		dAtA[i] = 0x30
	}
	if m.CreationTimestamp != nil {
		{
			size, err := m.CreationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StatusId) > 0 {
		i -= len(m.StatusId)
		copy(dAtA[i:], m.StatusId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StatusId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CreatorId) > 0 {
		i -= len(m.CreatorId)
		copy(dAtA[i:], m.CreatorId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreatorId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CreatorClass) > 0 {
		i -= len(m.CreatorClass)
		copy(dAtA[i:], m.CreatorClass)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreatorClass)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ObjectMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectMetaType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectMetaType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Disable {
		i--
		if m.Disable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Annotations) > 0 {
		keysForAnnotations := make([]string, 0, len(m.Annotations))
		for k := range m.Annotations {
			keysForAnnotations = append(keysForAnnotations, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
		for iNdEx := len(keysForAnnotations) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Annotations[string(keysForAnnotations[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForAnnotations[iNdEx])
			copy(dAtA[i:], keysForAnnotations[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForAnnotations[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListMetaType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListMetaType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NextPage) > 0 {
		i -= len(m.NextPage)
		copy(dAtA[i:], m.NextPage)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NextPage)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ResourceVersion) > 0 {
		i -= len(m.ResourceVersion)
		copy(dAtA[i:], m.ResourceVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResourceVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ObjectGetMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectGetMetaType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectGetMetaType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Disable {
		i--
		if m.Disable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Annotations) > 0 {
		keysForAnnotations := make([]string, 0, len(m.Annotations))
		for k := range m.Annotations {
			keysForAnnotations = append(keysForAnnotations, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
		for iNdEx := len(keysForAnnotations) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Annotations[string(keysForAnnotations[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForAnnotations[iNdEx])
			copy(dAtA[i:], keysForAnnotations[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForAnnotations[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ObjectCreateMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectCreateMetaType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectCreateMetaType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Disable {
		i--
		if m.Disable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Annotations) > 0 {
		keysForAnnotations := make([]string, 0, len(m.Annotations))
		for k := range m.Annotations {
			keysForAnnotations = append(keysForAnnotations, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
		for iNdEx := len(keysForAnnotations) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Annotations[string(keysForAnnotations[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForAnnotations[iNdEx])
			copy(dAtA[i:], keysForAnnotations[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForAnnotations[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ObjectReplaceMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectReplaceMetaType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectReplaceMetaType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Disable {
		i--
		if m.Disable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Annotations) > 0 {
		keysForAnnotations := make([]string, 0, len(m.Annotations))
		for k := range m.Annotations {
			keysForAnnotations = append(keysForAnnotations, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
		for iNdEx := len(keysForAnnotations) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Annotations[string(keysForAnnotations[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForAnnotations[iNdEx])
			copy(dAtA[i:], keysForAnnotations[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForAnnotations[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageMetaType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageMetaType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Disable {
		i--
		if m.Disable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ViewRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ViewRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KubeRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubeRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubeRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SystemObjectMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SystemObjectMetaType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SystemObjectMetaType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.VtrpStale {
		i--
		if m.VtrpStale {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.VtrpId) > 0 {
		i -= len(m.VtrpId)
		copy(dAtA[i:], m.VtrpId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VtrpId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.SreDisable {
		i--
		if m.SreDisable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.OwnerView != nil {
		{
			size, err := m.OwnerView.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if len(m.CreatorCookie) > 0 {
		i -= len(m.CreatorCookie)
		copy(dAtA[i:], m.CreatorCookie)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreatorCookie)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Namespace) > 0 {
		for iNdEx := len(m.Namespace) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Namespace[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.ObjectIndex != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ObjectIndex))
		i--
		dAtA[i] = 0x60
	}
	if len(m.TraceInfo) > 0 {
		i -= len(m.TraceInfo)
		copy(dAtA[i:], m.TraceInfo)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TraceInfo)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.CreatorId) > 0 {
		i -= len(m.CreatorId)
		copy(dAtA[i:], m.CreatorId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreatorId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.CreatorClass) > 0 {
		i -= len(m.CreatorClass)
		copy(dAtA[i:], m.CreatorClass)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreatorClass)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Tenant) > 0 {
		i -= len(m.Tenant)
		copy(dAtA[i:], m.Tenant)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Tenant)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Finalizers) > 0 {
		for iNdEx := len(m.Finalizers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Finalizers[iNdEx])
			copy(dAtA[i:], m.Finalizers[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Finalizers[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Initializers != nil {
		{
			size, err := m.Initializers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ModificationTimestamp != nil {
		{
			size, err := m.ModificationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DeletionTimestamp != nil {
		{
			size, err := m.DeletionTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CreationTimestamp != nil {
		{
			size, err := m.CreationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SystemObjectGetMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SystemObjectGetMetaType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SystemObjectGetMetaType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.OwnerView != nil {
		{
			size, err := m.OwnerView.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.ObjectIndex != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ObjectIndex))
		i--
		dAtA[i] = 0x60
	}
	if len(m.CreatorId) > 0 {
		i -= len(m.CreatorId)
		copy(dAtA[i:], m.CreatorId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreatorId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.CreatorClass) > 0 {
		i -= len(m.CreatorClass)
		copy(dAtA[i:], m.CreatorClass)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreatorClass)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Tenant) > 0 {
		i -= len(m.Tenant)
		copy(dAtA[i:], m.Tenant)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Tenant)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Finalizers) > 0 {
		for iNdEx := len(m.Finalizers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Finalizers[iNdEx])
			copy(dAtA[i:], m.Finalizers[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Finalizers[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Initializers != nil {
		{
			size, err := m.Initializers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ModificationTimestamp != nil {
		{
			size, err := m.ModificationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DeletionTimestamp != nil {
		{
			size, err := m.DeletionTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CreationTimestamp != nil {
		{
			size, err := m.CreationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthnTypeBasicAuth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthnTypeBasicAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthnTypeBasicAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Password != nil {
		{
			size, err := m.Password.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthnTypeHeaders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthnTypeHeaders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthnTypeHeaders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Headers) > 0 {
		keysForHeaders := make([]string, 0, len(m.Headers))
		for k := range m.Headers {
			keysForHeaders = append(keysForHeaders, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForHeaders)
		for iNdEx := len(keysForHeaders) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Headers[string(keysForHeaders[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTypes(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForHeaders[iNdEx])
			copy(dAtA[i:], keysForHeaders[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForHeaders[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AuthnTypeQueryParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthnTypeQueryParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthnTypeQueryParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.QueryParams) > 0 {
		keysForQueryParams := make([]string, 0, len(m.QueryParams))
		for k := range m.QueryParams {
			keysForQueryParams = append(keysForQueryParams, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForQueryParams)
		for iNdEx := len(keysForQueryParams) - 1; iNdEx >= 0; iNdEx-- {
			v := m.QueryParams[string(keysForQueryParams[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTypes(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForQueryParams[iNdEx])
			copy(dAtA[i:], keysForQueryParams[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForQueryParams[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BlindfoldSecretInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlindfoldSecretInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlindfoldSecretInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StoreProvider) > 0 {
		i -= len(m.StoreProvider)
		copy(dAtA[i:], m.StoreProvider)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StoreProvider)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DecryptionProvider) > 0 {
		i -= len(m.DecryptionProvider)
		copy(dAtA[i:], m.DecryptionProvider)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DecryptionProvider)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VaultSecretInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VaultSecretInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultSecretInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SecretEncoding != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SecretEncoding))
		i--
		dAtA[i] = 0x28
	}
	if m.Version != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClearSecretInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearSecretInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearSecretInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WingmanSecretInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WingmanSecretInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WingmanSecretInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecretType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecretType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecretType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlindfoldSecretInfoInternal != nil {
		{
			size, err := m.BlindfoldSecretInfoInternal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.SecretEncodingType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SecretEncodingType))
		i--
		dAtA[i] = 0x40
	}
	if m.SecretInfoOneof != nil {
		{
			size := m.SecretInfoOneof.Size()
			i -= size
			if _, err := m.SecretInfoOneof.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SecretType_BlindfoldSecretInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecretType_BlindfoldSecretInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BlindfoldSecretInfo != nil {
		{
			size, err := m.BlindfoldSecretInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *SecretType_VaultSecretInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecretType_VaultSecretInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VaultSecretInfo != nil {
		{
			size, err := m.VaultSecretInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *SecretType_ClearSecretInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecretType_ClearSecretInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClearSecretInfo != nil {
		{
			size, err := m.ClearSecretInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *SecretType_WingmanSecretInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecretType_WingmanSecretInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.WingmanSecretInfo != nil {
		{
			size, err := m.WingmanSecretInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *NetworkRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for iNdEx := len(m.Ref) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ref[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SiteRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Refs) > 0 {
		for iNdEx := len(m.Refs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Refs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.InternetVipChoice != nil {
		{
			size := m.InternetVipChoice.Size()
			i -= size
			if _, err := m.InternetVipChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.NetworkType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NetworkType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Ref) > 0 {
		for iNdEx := len(m.Ref) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ref[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SiteRefType_EnableInternetVip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteRefType_EnableInternetVip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableInternetVip != nil {
		{
			size, err := m.EnableInternetVip.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *SiteRefType_DisableInternetVip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteRefType_DisableInternetVip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableInternetVip != nil {
		{
			size, err := m.DisableInternetVip.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *IpPrefixSetRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpPrefixSetRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpPrefixSetRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for iNdEx := len(m.Ref) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ref[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VSiteRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VSiteRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VSiteRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Refs) > 0 {
		for iNdEx := len(m.Refs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Refs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.InternetVipChoice != nil {
		{
			size := m.InternetVipChoice.Size()
			i -= size
			if _, err := m.InternetVipChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.NetworkType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NetworkType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Ref) > 0 {
		for iNdEx := len(m.Ref) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ref[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VSiteRefType_EnableInternetVip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VSiteRefType_EnableInternetVip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableInternetVip != nil {
		{
			size, err := m.EnableInternetVip.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *VSiteRefType_DisableInternetVip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VSiteRefType_DisableInternetVip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableInternetVip != nil {
		{
			size, err := m.DisableInternetVip.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *PolicerRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicerRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for iNdEx := len(m.Ref) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ref[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProtocolPolicerRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtocolPolicerRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtocolPolicerRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for iNdEx := len(m.Ref) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ref[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NetworkSiteRefSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkSiteRefSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkSiteRefSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RefOrSelector != nil {
		{
			size := m.RefOrSelector.Size()
			i -= size
			if _, err := m.RefOrSelector.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *NetworkSiteRefSelector_VirtualNetwork) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkSiteRefSelector_VirtualNetwork) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VirtualNetwork != nil {
		{
			size, err := m.VirtualNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *NetworkSiteRefSelector_Site) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkSiteRefSelector_Site) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Site != nil {
		{
			size, err := m.Site.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *NetworkSiteRefSelector_VirtualSite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkSiteRefSelector_VirtualSite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VirtualSite != nil {
		{
			size, err := m.VirtualSite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SiteVirtualSiteRefSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteVirtualSiteRefSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteVirtualSiteRefSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RefOrSelector != nil {
		{
			size := m.RefOrSelector.Size()
			i -= size
			if _, err := m.RefOrSelector.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SiteVirtualSiteRefSelector_Site) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteVirtualSiteRefSelector_Site) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Site != nil {
		{
			size, err := m.Site.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SiteVirtualSiteRefSelector_VirtualSite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteVirtualSiteRefSelector_VirtualSite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VirtualSite != nil {
		{
			size, err := m.VirtualSite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *HeaderManipulationOptionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeaderManipulationOptionType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderManipulationOptionType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValueChoice != nil {
		{
			size := m.ValueChoice.Size()
			i -= size
			if _, err := m.ValueChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Append {
		i--
		if m.Append {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HeaderManipulationOptionType_Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderManipulationOptionType_Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Value)
	copy(dAtA[i:], m.Value)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *HeaderManipulationOptionType_SecretValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderManipulationOptionType_SecretValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SecretValue != nil {
		{
			size, err := m.SecretValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *CookieManipulationOptionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CookieManipulationOptionType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieManipulationOptionType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CookieTampering != nil {
		{
			size := m.CookieTampering.Size()
			i -= size
			if _, err := m.CookieTampering.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Samesite != nil {
		{
			size := m.Samesite.Size()
			i -= size
			if _, err := m.Samesite.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.MaxAge != nil {
		{
			size := m.MaxAge.Size()
			i -= size
			if _, err := m.MaxAge.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Httponly != nil {
		{
			size := m.Httponly.Size()
			i -= size
			if _, err := m.Httponly.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Secure != nil {
		{
			size := m.Secure.Size()
			i -= size
			if _, err := m.Secure.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CookieManipulationOptionType_SamesiteStrict) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieManipulationOptionType_SamesiteStrict) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SamesiteStrict != nil {
		{
			size, err := m.SamesiteStrict.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CookieManipulationOptionType_SamesiteLax) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieManipulationOptionType_SamesiteLax) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SamesiteLax != nil {
		{
			size, err := m.SamesiteLax.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CookieManipulationOptionType_SamesiteNone) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieManipulationOptionType_SamesiteNone) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SamesiteNone != nil {
		{
			size, err := m.SamesiteNone.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *CookieManipulationOptionType_IgnoreSecure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieManipulationOptionType_IgnoreSecure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IgnoreSecure != nil {
		{
			size, err := m.IgnoreSecure.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *CookieManipulationOptionType_AddSecure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieManipulationOptionType_AddSecure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddSecure != nil {
		{
			size, err := m.AddSecure.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *CookieManipulationOptionType_IgnoreHttponly) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieManipulationOptionType_IgnoreHttponly) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IgnoreHttponly != nil {
		{
			size, err := m.IgnoreHttponly.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *CookieManipulationOptionType_AddHttponly) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieManipulationOptionType_AddHttponly) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddHttponly != nil {
		{
			size, err := m.AddHttponly.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *CookieManipulationOptionType_IgnoreMaxAge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieManipulationOptionType_IgnoreMaxAge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IgnoreMaxAge != nil {
		{
			size, err := m.IgnoreMaxAge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *CookieManipulationOptionType_MaxAgeValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieManipulationOptionType_MaxAgeValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.MaxAgeValue))
	i--
	dAtA[i] = 0x70
	return len(dAtA) - i, nil
}
func (m *CookieManipulationOptionType_IgnoreSamesite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieManipulationOptionType_IgnoreSamesite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IgnoreSamesite != nil {
		{
			size, err := m.IgnoreSamesite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *CookieManipulationOptionType_DisableTamperingProtection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieManipulationOptionType_DisableTamperingProtection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableTamperingProtection != nil {
		{
			size, err := m.DisableTamperingProtection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *CookieManipulationOptionType_EnableTamperingProtection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CookieManipulationOptionType_EnableTamperingProtection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableTamperingProtection != nil {
		{
			size, err := m.EnableTamperingProtection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *TrustedCAList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrustedCAList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrustedCAList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TrustedCaList) > 0 {
		for iNdEx := len(m.TrustedCaList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrustedCaList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TlsValidationParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsValidationParamsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsValidationParamsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TrustedCaChoice != nil {
		{
			size := m.TrustedCaChoice.Size()
			i -= size
			if _, err := m.TrustedCaChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.UseVolterraTrustedCaUrl {
		i--
		if m.UseVolterraTrustedCaUrl {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.VerifySubjectAltNames) > 0 {
		for iNdEx := len(m.VerifySubjectAltNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.VerifySubjectAltNames[iNdEx])
			copy(dAtA[i:], m.VerifySubjectAltNames[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.VerifySubjectAltNames[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.SkipHostnameVerification {
		i--
		if m.SkipHostnameVerification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *TlsValidationParamsType_TrustedCaUrl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsValidationParamsType_TrustedCaUrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.TrustedCaUrl)
	copy(dAtA[i:], m.TrustedCaUrl)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.TrustedCaUrl)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *TlsValidationParamsType_TrustedCa) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsValidationParamsType_TrustedCa) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TrustedCa != nil {
		{
			size, err := m.TrustedCa.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *HashAlgorithms) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HashAlgorithms) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HashAlgorithms) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HashAlgorithms) > 0 {
		dAtA45 := make([]byte, len(m.HashAlgorithms)*10)
		var j44 int
		for _, num := range m.HashAlgorithms {
			for num >= 1<<7 {
				dAtA45[j44] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j44++
			}
			dAtA45[j44] = uint8(num)
			j44++
		}
		i -= j44
		copy(dAtA[i:], dAtA45[:j44])
		i = encodeVarintTypes(dAtA, i, uint64(j44))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TlsCertificateType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsCertificateType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsCertificateType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OcspStaplingChoice != nil {
		{
			size := m.OcspStaplingChoice.Size()
			i -= size
			if _, err := m.OcspStaplingChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if m.PrivateKey != nil {
		{
			size, err := m.PrivateKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.CertificateUrl) > 0 {
		i -= len(m.CertificateUrl)
		copy(dAtA[i:], m.CertificateUrl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CertificateUrl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TlsCertificateType_UseSystemDefaults) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsCertificateType_UseSystemDefaults) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UseSystemDefaults != nil {
		{
			size, err := m.UseSystemDefaults.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *TlsCertificateType_DisableOcspStapling) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsCertificateType_DisableOcspStapling) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableOcspStapling != nil {
		{
			size, err := m.DisableOcspStapling.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *TlsCertificateType_CustomHashAlgorithms) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsCertificateType_CustomHashAlgorithms) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CustomHashAlgorithms != nil {
		{
			size, err := m.CustomHashAlgorithms.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *DomainType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DomainType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DomainType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DomainChoice != nil {
		{
			size := m.DomainChoice.Size()
			i -= size
			if _, err := m.DomainChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DomainType_ExactValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DomainType_ExactValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ExactValue)
	copy(dAtA[i:], m.ExactValue)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ExactValue)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *DomainType_SuffixValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DomainType_SuffixValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.SuffixValue)
	copy(dAtA[i:], m.SuffixValue)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.SuffixValue)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *DomainType_RegexValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DomainType_RegexValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.RegexValue)
	copy(dAtA[i:], m.RegexValue)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.RegexValue)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *L4DestType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4DestType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L4DestType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PortRanges) > 0 {
		i -= len(m.PortRanges)
		copy(dAtA[i:], m.PortRanges)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PortRanges)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Prefixes) > 0 {
		for iNdEx := len(m.Prefixes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Prefixes[iNdEx])
			copy(dAtA[i:], m.Prefixes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Prefixes[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TlsInterceptionRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsInterceptionRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsInterceptionRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableDisableChoice != nil {
		{
			size := m.EnableDisableChoice.Size()
			i -= size
			if _, err := m.EnableDisableChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DomainMatch != nil {
		{
			size, err := m.DomainMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TlsInterceptionRule_DisableInterception) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsInterceptionRule_DisableInterception) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableInterception != nil {
		{
			size, err := m.DisableInterception.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *TlsInterceptionRule_EnableInterception) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsInterceptionRule_EnableInterception) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableInterception != nil {
		{
			size, err := m.EnableInterception.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *TlsInterceptionPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsInterceptionPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsInterceptionPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InterceptionRules) > 0 {
		for iNdEx := len(m.InterceptionRules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InterceptionRules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TlsInterceptionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsInterceptionType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsInterceptionType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InterceptionPolicyChoice != nil {
		{
			size := m.InterceptionPolicyChoice.Size()
			i -= size
			if _, err := m.InterceptionPolicyChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TrustedCaChoice != nil {
		{
			size := m.TrustedCaChoice.Size()
			i -= size
			if _, err := m.TrustedCaChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SigningCertChoice != nil {
		{
			size := m.SigningCertChoice.Size()
			i -= size
			if _, err := m.SigningCertChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *TlsInterceptionType_Policy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsInterceptionType_Policy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Policy != nil {
		{
			size, err := m.Policy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *TlsInterceptionType_CustomCertificate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsInterceptionType_CustomCertificate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CustomCertificate != nil {
		{
			size, err := m.CustomCertificate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *TlsInterceptionType_VolterraCertificate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsInterceptionType_VolterraCertificate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VolterraCertificate != nil {
		{
			size, err := m.VolterraCertificate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *TlsInterceptionType_TrustedCaUrl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsInterceptionType_TrustedCaUrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.TrustedCaUrl)
	copy(dAtA[i:], m.TrustedCaUrl)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.TrustedCaUrl)))
	i--
	dAtA[i] = 0x32
	return len(dAtA) - i, nil
}
func (m *TlsInterceptionType_VolterraTrustedCa) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsInterceptionType_VolterraTrustedCa) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VolterraTrustedCa != nil {
		{
			size, err := m.VolterraTrustedCa.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *TlsInterceptionType_EnableForAllDomains) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsInterceptionType_EnableForAllDomains) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableForAllDomains != nil {
		{
			size, err := m.EnableForAllDomains.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *FractionalPercent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FractionalPercent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FractionalPercent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Denominator != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Denominator))
		i--
		dAtA[i] = 0x10
	}
	if m.Numerator != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Numerator))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BufferConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufferConfigType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BufferConfigType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxRequestTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxRequestTime))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxRequestBytes != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxRequestBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.Disabled {
		i--
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CorsPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CorsPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CorsPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaximumAge != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaximumAge))
		i--
		dAtA[i] = 0x48
	}
	if m.AllowCredentials {
		i--
		if m.AllowCredentials {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.MaxAge) > 0 {
		i -= len(m.MaxAge)
		copy(dAtA[i:], m.MaxAge)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MaxAge)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ExposeHeaders) > 0 {
		i -= len(m.ExposeHeaders)
		copy(dAtA[i:], m.ExposeHeaders)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ExposeHeaders)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AllowHeaders) > 0 {
		i -= len(m.AllowHeaders)
		copy(dAtA[i:], m.AllowHeaders)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AllowHeaders)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AllowMethods) > 0 {
		i -= len(m.AllowMethods)
		copy(dAtA[i:], m.AllowMethods)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AllowMethods)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AllowOriginRegex) > 0 {
		for iNdEx := len(m.AllowOriginRegex) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowOriginRegex[iNdEx])
			copy(dAtA[i:], m.AllowOriginRegex[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AllowOriginRegex[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.AllowOrigin) > 0 {
		for iNdEx := len(m.AllowOrigin) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowOrigin[iNdEx])
			copy(dAtA[i:], m.AllowOrigin[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AllowOrigin[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Disabled {
		i--
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CsrfPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CsrfPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CsrfPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AllowedDomains != nil {
		{
			size := m.AllowedDomains.Size()
			i -= size
			if _, err := m.AllowedDomains.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CsrfPolicy_AllLoadBalancerDomains) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CsrfPolicy_AllLoadBalancerDomains) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllLoadBalancerDomains != nil {
		{
			size, err := m.AllLoadBalancerDomains.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CsrfPolicy_CustomDomainList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CsrfPolicy_CustomDomainList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CustomDomainList != nil {
		{
			size, err := m.CustomDomainList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CsrfPolicy_Disabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CsrfPolicy_Disabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Disabled != nil {
		{
			size, err := m.Disabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *PathMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PathMatch != nil {
		{
			size := m.PathMatch.Size()
			i -= size
			if _, err := m.PathMatch.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *PathMatcherType_Prefix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathMatcherType_Prefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Prefix)
	copy(dAtA[i:], m.Prefix)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Prefix)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *PathMatcherType_Path) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathMatcherType_Path) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Path)
	copy(dAtA[i:], m.Path)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Path)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *PathMatcherType_Regex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathMatcherType_Regex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Regex)
	copy(dAtA[i:], m.Regex)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Regex)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *PortMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PortMatch != nil {
		{
			size := m.PortMatch.Size()
			i -= size
			if _, err := m.PortMatch.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *PortMatcherType_Port) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortMatcherType_Port) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.Port))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *PortMatcherType_PortRanges) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortMatcherType_PortRanges) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.PortRanges)
	copy(dAtA[i:], m.PortRanges)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.PortRanges)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *PortMatcherType_NoPortMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortMatcherType_NoPortMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoPortMatch != nil {
		{
			size, err := m.NoPortMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeaderMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InvertMatch {
		i--
		if m.InvertMatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.ValueMatch != nil {
		{
			size := m.ValueMatch.Size()
			i -= size
			if _, err := m.ValueMatch.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HeaderMatcherType_Exact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherType_Exact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Exact)
	copy(dAtA[i:], m.Exact)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Exact)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherType_Regex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherType_Regex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Regex)
	copy(dAtA[i:], m.Regex)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Regex)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherType_Presence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherType_Presence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Presence {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *QueryParameterMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParameterMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParameterMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValueMatch != nil {
		{
			size := m.ValueMatch.Size()
			i -= size
			if _, err := m.ValueMatch.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryParameterMatcherType_Exact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParameterMatcherType_Exact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Exact)
	copy(dAtA[i:], m.Exact)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Exact)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *QueryParameterMatcherType_Regex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParameterMatcherType_Regex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Regex)
	copy(dAtA[i:], m.Regex)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Regex)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *RouteMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IncomingPort != nil {
		{
			size, err := m.IncomingPort.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.HttpMethod != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.HttpMethod))
		i--
		dAtA[i] = 0x20
	}
	if len(m.QueryParams) > 0 {
		for iNdEx := len(m.QueryParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QueryParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Path != nil {
		{
			size, err := m.Path.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppFirewallRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppFirewallRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppFirewallRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AppFirewall) > 0 {
		for iNdEx := len(m.AppFirewall) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AppFirewall[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WafType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WafType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RefType != nil {
		{
			size := m.RefType.Size()
			i -= size
			if _, err := m.RefType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *WafType_AppFirewall) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafType_AppFirewall) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AppFirewall != nil {
		{
			size, err := m.AppFirewall.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *WafType_DisableWaf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafType_DisableWaf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableWaf != nil {
		{
			size, err := m.DisableWaf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *WafType_InheritWaf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafType_InheritWaf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.InheritWaf != nil {
		{
			size, err := m.InheritWaf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *AppRoleAuthInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppRoleAuthInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppRoleAuthInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SecretId != nil {
		{
			size, err := m.SecretId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.RoleId) > 0 {
		i -= len(m.RoleId)
		copy(dAtA[i:], m.RoleId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RoleId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VaultAuthInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VaultAuthInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultAuthInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthParams != nil {
		{
			size := m.AuthParams.Size()
			i -= size
			if _, err := m.AuthParams.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *VaultAuthInfoType_AppRoleAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultAuthInfoType_AppRoleAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AppRoleAuth != nil {
		{
			size, err := m.AppRoleAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *VaultAuthInfoType_Token) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultAuthInfoType_Token) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *RestAuthInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestAuthInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestAuthInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthParams != nil {
		{
			size := m.AuthParams.Size()
			i -= size
			if _, err := m.AuthParams.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RestAuthInfoType_BasicAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestAuthInfoType_BasicAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BasicAuth != nil {
		{
			size, err := m.BasicAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *RestAuthInfoType_HeadersAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestAuthInfoType_HeadersAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HeadersAuth != nil {
		{
			size, err := m.HeadersAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *RestAuthInfoType_QueryParamsAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestAuthInfoType_QueryParamsAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.QueryParamsAuth != nil {
		{
			size, err := m.QueryParamsAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *VaultAccessInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VaultAccessInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultAccessInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthnChoice != nil {
		{
			size := m.AuthnChoice.Size()
			i -= size
			if _, err := m.AuthnChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.VaultCaUrl) > 0 {
		i -= len(m.VaultCaUrl)
		copy(dAtA[i:], m.VaultCaUrl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VaultCaUrl)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VaultAddr) > 0 {
		i -= len(m.VaultAddr)
		copy(dAtA[i:], m.VaultAddr)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VaultAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VaultAccessInfoType_AppRoleAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultAccessInfoType_AppRoleAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AppRoleAuth != nil {
		{
			size, err := m.AppRoleAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *VaultAccessInfoType_Token) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultAccessInfoType_Token) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *VaultSecretType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VaultSecretType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultSecretType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SecretVersion) > 0 {
		i -= len(m.SecretVersion)
		copy(dAtA[i:], m.SecretVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SecretVersion)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SecretSubPath) > 0 {
		i -= len(m.SecretSubPath)
		copy(dAtA[i:], m.SecretSubPath)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SecretSubPath)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SecretPath) > 0 {
		i -= len(m.SecretPath)
		copy(dAtA[i:], m.SecretPath)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SecretPath)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AccessChoice != nil {
		{
			size := m.AccessChoice.Size()
			i -= size
			if _, err := m.AccessChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *VaultSecretType_VaultAccessInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultSecretType_VaultAccessInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VaultAccessInfo != nil {
		{
			size, err := m.VaultAccessInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *VaultSecretType_ProviderName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultSecretType_ProviderName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ProviderName)
	copy(dAtA[i:], m.ProviderName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ProviderName)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *VolterraSecretType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolterraSecretType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VolterraSecretType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SecretTypeChoice != nil {
		{
			size := m.SecretTypeChoice.Size()
			i -= size
			if _, err := m.SecretTypeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *VolterraSecretType_BlindfoldSecretInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VolterraSecretType_BlindfoldSecretInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BlindfoldSecretInfo != nil {
		{
			size, err := m.BlindfoldSecretInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *VolterraSecretType_VaultSecretInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VolterraSecretType_VaultSecretInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VaultSecretInfo != nil {
		{
			size, err := m.VaultSecretInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *PortValueType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortValueType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortValueType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PortValueTypeChoice != nil {
		{
			size := m.PortValueTypeChoice.Size()
			i -= size
			if _, err := m.PortValueTypeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *PortValueType_All) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortValueType_All) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.All != nil {
		{
			size, err := m.All.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *PortValueType_UserDefined) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortValueType_UserDefined) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.UserDefined))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *PortValueType_Dns) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortValueType_Dns) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Dns != nil {
		{
			size, err := m.Dns.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *VirtualNetworkReferenceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualNetworkReferenceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VirtualNetworkReferenceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Refs) > 0 {
		for iNdEx := len(m.Refs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Refs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VirtualNetworkSelectorType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualNetworkSelectorType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VirtualNetworkSelectorType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VnTypeChoice != nil {
		{
			size := m.VnTypeChoice.Size()
			i -= size
			if _, err := m.VnTypeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *VirtualNetworkSelectorType_SiteLocal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VirtualNetworkSelectorType_SiteLocal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteLocal != nil {
		{
			size, err := m.SiteLocal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *VirtualNetworkSelectorType_SiteLocalInside) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VirtualNetworkSelectorType_SiteLocalInside) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteLocalInside != nil {
		{
			size, err := m.SiteLocalInside.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *VirtualNetworkSelectorType_Public) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VirtualNetworkSelectorType_Public) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Public != nil {
		{
			size, err := m.Public.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *RetryBackOff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetryBackOff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RetryBackOff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxInterval != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxInterval))
		i--
		dAtA[i] = 0x10
	}
	if m.BaseInterval != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BaseInterval))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RetryPolicyType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetryPolicyType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RetryPolicyType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RetryCondition) > 0 {
		for iNdEx := len(m.RetryCondition) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RetryCondition[iNdEx])
			copy(dAtA[i:], m.RetryCondition[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RetryCondition[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.BackOff != nil {
		{
			size, err := m.BackOff.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RetriableStatusCodes) > 0 {
		dAtA85 := make([]byte, len(m.RetriableStatusCodes)*10)
		var j84 int
		for _, num := range m.RetriableStatusCodes {
			for num >= 1<<7 {
				dAtA85[j84] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j84++
			}
			dAtA85[j84] = uint8(num)
			j84++
		}
		i -= j84
		copy(dAtA[i:], dAtA85[:j84])
		i = encodeVarintTypes(dAtA, i, uint64(j84))
		i--
		dAtA[i] = 0x22
	}
	if m.PerTryTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PerTryTimeout))
		i--
		dAtA[i] = 0x18
	}
	if m.NumRetries != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NumRetries))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RetryOn) > 0 {
		i -= len(m.RetryOn)
		copy(dAtA[i:], m.RetryOn)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RetryOn)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetricValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TrendValue != nil {
		{
			size, err := m.TrendValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Timestamp))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *MetricTypeData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricTypeData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricTypeData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TrendValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrendValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrendValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PreviousValue) > 0 {
		i -= len(m.PreviousValue)
		copy(dAtA[i:], m.PreviousValue)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PreviousValue)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Sentiment != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Sentiment))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NextHopType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NextHopType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NextHopType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Interface) > 0 {
		for iNdEx := len(m.Interface) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Interface[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.NexthopAddress != nil {
		{
			size, err := m.NexthopAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StaticRouteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaticRouteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StaticRouteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.Nexthop != nil {
		{
			size, err := m.Nexthop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Subnets) > 0 {
		for iNdEx := len(m.Subnets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subnets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Attrs) > 0 {
		dAtA90 := make([]byte, len(m.Attrs)*10)
		var j89 int
		for _, num := range m.Attrs {
			for num >= 1<<7 {
				dAtA90[j89] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j89++
			}
			dAtA90[j89] = uint8(num)
			j89++
		}
		i -= j89
		copy(dAtA[i:], dAtA90[:j89])
		i = encodeVarintTypes(dAtA, i, uint64(j89))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ForwardProxyConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForwardProxyConfigType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForwardProxyConfigType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TlsInterceptionChoice != nil {
		{
			size := m.TlsInterceptionChoice.Size()
			i -= size
			if _, err := m.TlsInterceptionChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ConnectionTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ConnectionTimeout))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxConnectAttempts != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxConnectAttempts))
		i--
		dAtA[i] = 0x18
	}
	if len(m.WhiteListedPorts) > 0 {
		dAtA92 := make([]byte, len(m.WhiteListedPorts)*10)
		var j91 int
		for _, num := range m.WhiteListedPorts {
			for num >= 1<<7 {
				dAtA92[j91] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j91++
			}
			dAtA92[j91] = uint8(num)
			j91++
		}
		i -= j91
		copy(dAtA[i:], dAtA92[:j91])
		i = encodeVarintTypes(dAtA, i, uint64(j91))
		i--
		dAtA[i] = 0x12
	}
	if len(m.WhiteListedPrefixes) > 0 {
		for iNdEx := len(m.WhiteListedPrefixes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.WhiteListedPrefixes[iNdEx])
			copy(dAtA[i:], m.WhiteListedPrefixes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.WhiteListedPrefixes[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ForwardProxyConfigType_NoInterception) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForwardProxyConfigType_NoInterception) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoInterception != nil {
		{
			size, err := m.NoInterception.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *ForwardProxyConfigType_TlsIntercept) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForwardProxyConfigType_TlsIntercept) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TlsIntercept != nil {
		{
			size, err := m.TlsIntercept.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *HostIdentifier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostIdentifier) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HostIdentifier) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HostnameOrIp != nil {
		{
			size := m.HostnameOrIp.Size()
			i -= size
			if _, err := m.HostnameOrIp.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *HostIdentifier_Ip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HostIdentifier_Ip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Ip)
	copy(dAtA[i:], m.Ip)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Ip)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *HostIdentifier_Hostname) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HostIdentifier_Hostname) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Hostname)
	copy(dAtA[i:], m.Hostname)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Hostname)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *InterfaceIdentifier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceIdentifier) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceIdentifier) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InterfaceChoice != nil {
		{
			size := m.InterfaceChoice.Size()
			i -= size
			if _, err := m.InterfaceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceIdentifier_AnyIntf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceIdentifier_AnyIntf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyIntf != nil {
		{
			size, err := m.AnyIntf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *InterfaceIdentifier_Intf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceIdentifier_Intf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Intf)
	copy(dAtA[i:], m.Intf)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Intf)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *InterfaceOrNetwork) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceOrNetwork) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceOrNetwork) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InterfaceChoice != nil {
		{
			size := m.InterfaceChoice.Size()
			i -= size
			if _, err := m.InterfaceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceOrNetwork_Intf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceOrNetwork_Intf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Intf)
	copy(dAtA[i:], m.Intf)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Intf)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *InterfaceOrNetwork_Pod) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceOrNetwork_Pod) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Pod)
	copy(dAtA[i:], m.Pod)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Pod)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *InterfaceOrNetwork_VnType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceOrNetwork_VnType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.VnType))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *InterfaceOrNetwork_Vn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceOrNetwork_Vn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Vn)
	copy(dAtA[i:], m.Vn)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Vn)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *RouteTarget2ByteAsn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTarget2ByteAsn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTarget2ByteAsn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x20
	}
	if m.AsNumber != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AsNumber))
		i--
		dAtA[i] = 0x18
	}
	return len(dAtA) - i, nil
}

func (m *RouteTarget4ByteAsn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTarget4ByteAsn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTarget4ByteAsn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x20
	}
	if m.AsNumber != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AsNumber))
		i--
		dAtA[i] = 0x18
	}
	return len(dAtA) - i, nil
}

func (m *RouteTargetIPv4Addr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTargetIPv4Addr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTargetIPv4Addr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteTarget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RtargetChoice != nil {
		{
			size := m.RtargetChoice.Size()
			i -= size
			if _, err := m.RtargetChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RouteTarget_Asn2ByteRtarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTarget_Asn2ByteRtarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Asn2ByteRtarget != nil {
		{
			size, err := m.Asn2ByteRtarget.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *RouteTarget_Ipv4AddrRtarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTarget_Ipv4AddrRtarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ipv4AddrRtarget != nil {
		{
			size, err := m.Ipv4AddrRtarget.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *RouteTarget_Asn4ByteRtarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTarget_Asn4ByteRtarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Asn4ByteRtarget != nil {
		{
			size, err := m.Asn4ByteRtarget.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *PortRangesType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortRangesType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortRangesType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for iNdEx := len(m.Ports) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Ports[iNdEx])
			copy(dAtA[i:], m.Ports[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Ports[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DomainNameList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DomainNameList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DomainNameList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for iNdEx := len(m.Domains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Domains[iNdEx])
			copy(dAtA[i:], m.Domains[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Domains[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NamespaceRoleType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespaceRoleType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamespaceRoleType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RoleListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Names) > 0 {
		for iNdEx := len(m.Names) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Names[iNdEx])
			copy(dAtA[i:], m.Names[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Names[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NamespaceAccessType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespaceAccessType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NamespaceAccessType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NamespaceRoleMap) > 0 {
		keysForNamespaceRoleMap := make([]string, 0, len(m.NamespaceRoleMap))
		for k := range m.NamespaceRoleMap {
			keysForNamespaceRoleMap = append(keysForNamespaceRoleMap, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForNamespaceRoleMap)
		for iNdEx := len(keysForNamespaceRoleMap) - 1; iNdEx >= 0; iNdEx-- {
			v := m.NamespaceRoleMap[string(keysForNamespaceRoleMap[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTypes(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForNamespaceRoleMap[iNdEx])
			copy(dAtA[i:], keysForNamespaceRoleMap[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForNamespaceRoleMap[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SiteInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Annotations) > 0 {
		for iNdEx := len(m.Annotations) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Annotations[iNdEx])
			copy(dAtA[i:], m.Annotations[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Annotations[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Site) > 0 {
		for iNdEx := len(m.Site) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Site[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SiteReferenceListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteReferenceListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteReferenceListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Refs) > 0 {
		for iNdEx := len(m.Refs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Refs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *HeaderTransformationType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeaderTransformationType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderTransformationType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HeaderTransformationChoice != nil {
		{
			size := m.HeaderTransformationChoice.Size()
			i -= size
			if _, err := m.HeaderTransformationChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *HeaderTransformationType_DefaultHeaderTransformation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderTransformationType_DefaultHeaderTransformation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultHeaderTransformation != nil {
		{
			size, err := m.DefaultHeaderTransformation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *HeaderTransformationType_ProperCaseHeaderTransformation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderTransformationType_ProperCaseHeaderTransformation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProperCaseHeaderTransformation != nil {
		{
			size, err := m.ProperCaseHeaderTransformation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *HeaderTransformationType_PreserveCaseHeaderTransformation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderTransformationType_PreserveCaseHeaderTransformation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PreserveCaseHeaderTransformation != nil {
		{
			size, err := m.PreserveCaseHeaderTransformation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *HeaderTransformationType_LegacyHeaderTransformation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderTransformationType_LegacyHeaderTransformation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LegacyHeaderTransformation != nil {
		{
			size, err := m.LegacyHeaderTransformation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelCategoriesChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BotDefenseFlowLabelCategoriesChoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelCategoriesChoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FlowLabelChoice != nil {
		{
			size := m.FlowLabelChoice.Size()
			i -= size
			if _, err := m.FlowLabelChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *BotDefenseFlowLabelCategoriesChoiceType_Authentication) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelCategoriesChoiceType_Authentication) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Authentication != nil {
		{
			size, err := m.Authentication.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelCategoriesChoiceType_AccountManagement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelCategoriesChoiceType_AccountManagement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AccountManagement != nil {
		{
			size, err := m.AccountManagement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelCategoriesChoiceType_ProfileManagement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelCategoriesChoiceType_ProfileManagement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProfileManagement != nil {
		{
			size, err := m.ProfileManagement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelCategoriesChoiceType_ShoppingGiftCards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelCategoriesChoiceType_ShoppingGiftCards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ShoppingGiftCards != nil {
		{
			size, err := m.ShoppingGiftCards.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelCategoriesChoiceType_FinancialServices) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelCategoriesChoiceType_FinancialServices) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FinancialServices != nil {
		{
			size, err := m.FinancialServices.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelCategoriesChoiceType_Search) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelCategoriesChoiceType_Search) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Search != nil {
		{
			size, err := m.Search.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelCategoriesChoiceType_Flight) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelCategoriesChoiceType_Flight) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Flight != nil {
		{
			size, err := m.Flight.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelAuthenticationChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BotDefenseFlowLabelAuthenticationChoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelAuthenticationChoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LabelChoice != nil {
		{
			size := m.LabelChoice.Size()
			i -= size
			if _, err := m.LabelChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *BotDefenseFlowLabelAuthenticationChoiceType_Login) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelAuthenticationChoiceType_Login) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Login != nil {
		{
			size, err := m.Login.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelAuthenticationChoiceType_LoginMfa) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelAuthenticationChoiceType_LoginMfa) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LoginMfa != nil {
		{
			size, err := m.LoginMfa.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelAuthenticationChoiceType_LoginPartner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelAuthenticationChoiceType_LoginPartner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LoginPartner != nil {
		{
			size, err := m.LoginPartner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelAuthenticationChoiceType_Logout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelAuthenticationChoiceType_Logout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Logout != nil {
		{
			size, err := m.Logout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelAuthenticationChoiceType_TokenRefresh) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelAuthenticationChoiceType_TokenRefresh) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TokenRefresh != nil {
		{
			size, err := m.TokenRefresh.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseTransactionResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BotDefenseTransactionResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseTransactionResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransactionResultChoice != nil {
		{
			size := m.TransactionResultChoice.Size()
			i -= size
			if _, err := m.TransactionResultChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *BotDefenseTransactionResult_DisableTransactionResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseTransactionResult_DisableTransactionResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableTransactionResult != nil {
		{
			size, err := m.DisableTransactionResult.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseTransactionResult_TransactionResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseTransactionResult_TransactionResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TransactionResult != nil {
		{
			size, err := m.TransactionResult.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseTransactionResultType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BotDefenseTransactionResultType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseTransactionResultType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FailureConditions) > 0 {
		for iNdEx := len(m.FailureConditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FailureConditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.SuccessConditions) > 0 {
		for iNdEx := len(m.SuccessConditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SuccessConditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	return len(dAtA) - i, nil
}

func (m *BotDefenseTransactionResultCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BotDefenseTransactionResultCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseTransactionResultCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RegexValues) > 0 {
		for iNdEx := len(m.RegexValues) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RegexValues[iNdEx])
			copy(dAtA[i:], m.RegexValues[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RegexValues[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BotDefenseFlowLabelAccountManagementChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BotDefenseFlowLabelAccountManagementChoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelAccountManagementChoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LabelChoice != nil {
		{
			size := m.LabelChoice.Size()
			i -= size
			if _, err := m.LabelChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *BotDefenseFlowLabelAccountManagementChoiceType_Create) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelAccountManagementChoiceType_Create) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Create != nil {
		{
			size, err := m.Create.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelAccountManagementChoiceType_PasswordReset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelAccountManagementChoiceType_PasswordReset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PasswordReset != nil {
		{
			size, err := m.PasswordReset.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelProfileManagementChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BotDefenseFlowLabelProfileManagementChoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelProfileManagementChoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LabelChoice != nil {
		{
			size := m.LabelChoice.Size()
			i -= size
			if _, err := m.LabelChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *BotDefenseFlowLabelProfileManagementChoiceType_Create) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelProfileManagementChoiceType_Create) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Create != nil {
		{
			size, err := m.Create.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelProfileManagementChoiceType_Update) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelProfileManagementChoiceType_Update) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Update != nil {
		{
			size, err := m.Update.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelProfileManagementChoiceType_View) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelProfileManagementChoiceType_View) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.View != nil {
		{
			size, err := m.View.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LabelChoice != nil {
		{
			size := m.LabelChoice.Size()
			i -= size
			if _, err := m.LabelChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopAddToCart) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopAddToCart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ShopAddToCart != nil {
		{
			size, err := m.ShopAddToCart.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPromoCodeValidation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPromoCodeValidation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ShopPromoCodeValidation != nil {
		{
			size, err := m.ShopPromoCodeValidation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopCheckout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopCheckout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ShopCheckout != nil {
		{
			size, err := m.ShopCheckout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopMakePayment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopMakePayment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ShopMakePayment != nil {
		{
			size, err := m.ShopMakePayment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ShopOrder != nil {
		{
			size, err := m.ShopOrder.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPriceInquiry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPriceInquiry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ShopPriceInquiry != nil {
		{
			size, err := m.ShopPriceInquiry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPurchaseGiftCard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPurchaseGiftCard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ShopPurchaseGiftCard != nil {
		{
			size, err := m.ShopPurchaseGiftCard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopUpdateQuantity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopUpdateQuantity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ShopUpdateQuantity != nil {
		{
			size, err := m.ShopUpdateQuantity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopChooseSeat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopChooseSeat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ShopChooseSeat != nil {
		{
			size, err := m.ShopChooseSeat.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopEnterDrawingSubmission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopEnterDrawingSubmission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ShopEnterDrawingSubmission != nil {
		{
			size, err := m.ShopEnterDrawingSubmission.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardValidation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardValidation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GiftCardValidation != nil {
		{
			size, err := m.GiftCardValidation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardMakePurchaseWithGiftCard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardMakePurchaseWithGiftCard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GiftCardMakePurchaseWithGiftCard != nil {
		{
			size, err := m.GiftCardMakePurchaseWithGiftCard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelFinancialServicesChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BotDefenseFlowLabelFinancialServicesChoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelFinancialServicesChoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LabelChoice != nil {
		{
			size := m.LabelChoice.Size()
			i -= size
			if _, err := m.LabelChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *BotDefenseFlowLabelFinancialServicesChoiceType_Apply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelFinancialServicesChoiceType_Apply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Apply != nil {
		{
			size, err := m.Apply.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelFinancialServicesChoiceType_MoneyTransfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelFinancialServicesChoiceType_MoneyTransfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MoneyTransfer != nil {
		{
			size, err := m.MoneyTransfer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelSearchChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BotDefenseFlowLabelSearchChoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelSearchChoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LabelChoice != nil {
		{
			size := m.LabelChoice.Size()
			i -= size
			if _, err := m.LabelChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *BotDefenseFlowLabelSearchChoiceType_FlightSearch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelSearchChoiceType_FlightSearch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FlightSearch != nil {
		{
			size, err := m.FlightSearch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelSearchChoiceType_ProductSearch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelSearchChoiceType_ProductSearch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProductSearch != nil {
		{
			size, err := m.ProductSearch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelSearchChoiceType_RoomSearch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelSearchChoiceType_RoomSearch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RoomSearch != nil {
		{
			size, err := m.RoomSearch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelSearchChoiceType_ReservationSearch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelSearchChoiceType_ReservationSearch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ReservationSearch != nil {
		{
			size, err := m.ReservationSearch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *BotDefenseFlowLabelFlightChoiceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BotDefenseFlowLabelFlightChoiceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelFlightChoiceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LabelChoice != nil {
		{
			size := m.LabelChoice.Size()
			i -= size
			if _, err := m.LabelChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *BotDefenseFlowLabelFlightChoiceType_Checkin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BotDefenseFlowLabelFlightChoiceType_Checkin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Checkin != nil {
		{
			size, err := m.Checkin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *NetworkingStackType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkingStackType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkingStackType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *NetworkingStackType_Ipv4) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkingStackType_Ipv4) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ipv4 != nil {
		{
			size, err := m.Ipv4.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *NetworkingStackType_Ipv6) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkingStackType_Ipv6) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ipv6 != nil {
		{
			size, err := m.Ipv6.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *NetworkingStackType_Dual) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkingStackType_Dual) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Dual != nil {
		{
			size, err := m.Dual.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DateRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DateRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DateRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndDate != nil {
		{
			size, err := m.EndDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.StartDate != nil {
		{
			size, err := m.StartDate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *File) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *File) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *File) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StorageProvider != nil {
		{
			size := m.StorageProvider.Size()
			i -= size
			if _, err := m.StorageProvider.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.FileId) > 0 {
		i -= len(m.FileId)
		copy(dAtA[i:], m.FileId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FileId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *File_AwsS3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *File_AwsS3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AwsS3 != nil {
		{
			size, err := m.AwsS3.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ResponseMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DisplayMessage) > 0 {
		i -= len(m.DisplayMessage)
		copy(dAtA[i:], m.DisplayMessage)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DisplayMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.ErrorCode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Action) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Action) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActionChoice != nil {
		{
			size := m.ActionChoice.Size()
			i -= size
			if _, err := m.ActionChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Action_Block) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_Block) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Action_Report) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Action_Report) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Report != nil {
		{
			size, err := m.Report.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CRMInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CRMInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CRMInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CustomerIdentifier) > 0 {
		i -= len(m.CustomerIdentifier)
		copy(dAtA[i:], m.CustomerIdentifier)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CustomerIdentifier)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.EntitledSkus) > 0 {
		for iNdEx := len(m.EntitledSkus) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EntitledSkus[iNdEx])
			copy(dAtA[i:], m.EntitledSkus[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.EntitledSkus[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.OrderType) > 0 {
		i -= len(m.OrderType)
		copy(dAtA[i:], m.OrderType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OrderType)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SubscriptionId) > 0 {
		i -= len(m.SubscriptionId)
		copy(dAtA[i:], m.SubscriptionId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubscriptionId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EntitlementId) > 0 {
		i -= len(m.EntitlementId)
		copy(dAtA[i:], m.EntitlementId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EntitlementId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccountId) > 0 {
		i -= len(m.AccountId)
		copy(dAtA[i:], m.AccountId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccountId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegexMatchRewrite) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegexMatchRewrite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegexMatchRewrite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Substitution) > 0 {
		i -= len(m.Substitution)
		copy(dAtA[i:], m.Substitution)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Substitution)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Pattern) > 0 {
		i -= len(m.Pattern)
		copy(dAtA[i:], m.Pattern)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Pattern)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ObjectRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *LabelSelectorType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Expressions) > 0 {
		for _, s := range m.Expressions {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *LabelMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ConditionType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LastUpdateTime != nil {
		l = m.LastUpdateTime.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovTypes(uint64(m.Code))
	}
	return n
}

func (m *InitializerType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *InitializersType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Pending) > 0 {
		for _, e := range m.Pending {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StatusMetaType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CreatorClass)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CreatorId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.StatusId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreationTimestamp != nil {
		l = m.CreationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Publish != 0 {
		n += 1 + sovTypes(uint64(m.Publish))
	}
	l = len(m.VtrpId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.VtrpStale {
		n += 2
	}
	return n
}

func (m *ObjectMetaType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Disable {
		n += 2
	}
	return n
}

func (m *ListMetaType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.NextPage)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ObjectGetMetaType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Disable {
		n += 2
	}
	return n
}

func (m *ObjectCreateMetaType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Disable {
		n += 2
	}
	return n
}

func (m *ObjectReplaceMetaType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Disable {
		n += 2
	}
	return n
}

func (m *MessageMetaType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Disable {
		n += 2
	}
	return n
}

func (m *ViewRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *KubeRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SystemObjectMetaType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreationTimestamp != nil {
		l = m.CreationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DeletionTimestamp != nil {
		l = m.DeletionTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ModificationTimestamp != nil {
		l = m.ModificationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Initializers != nil {
		l = m.Initializers.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Finalizers) > 0 {
		for _, s := range m.Finalizers {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CreatorClass)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CreatorId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TraceInfo)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ObjectIndex != 0 {
		n += 1 + sovTypes(uint64(m.ObjectIndex))
	}
	if len(m.Namespace) > 0 {
		for _, e := range m.Namespace {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.CreatorCookie)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OwnerView != nil {
		l = m.OwnerView.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SreDisable {
		n += 3
	}
	l = len(m.VtrpId)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.VtrpStale {
		n += 3
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SystemObjectGetMetaType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreationTimestamp != nil {
		l = m.CreationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DeletionTimestamp != nil {
		l = m.DeletionTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ModificationTimestamp != nil {
		l = m.ModificationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Initializers != nil {
		l = m.Initializers.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Finalizers) > 0 {
		for _, s := range m.Finalizers {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CreatorClass)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CreatorId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ObjectIndex != 0 {
		n += 1 + sovTypes(uint64(m.ObjectIndex))
	}
	if m.OwnerView != nil {
		l = m.OwnerView.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AuthnTypeBasicAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Password != nil {
		l = m.Password.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AuthnTypeHeaders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Headers) > 0 {
		for k, v := range m.Headers {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AuthnTypeQueryParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.QueryParams) > 0 {
		for k, v := range m.QueryParams {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *BlindfoldSecretInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DecryptionProvider)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.StoreProvider)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *VaultSecretInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovTypes(uint64(m.Version))
	}
	if m.SecretEncoding != 0 {
		n += 1 + sovTypes(uint64(m.SecretEncoding))
	}
	return n
}

func (m *ClearSecretInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *WingmanSecretInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SecretType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SecretInfoOneof != nil {
		n += m.SecretInfoOneof.Size()
	}
	if m.SecretEncodingType != 0 {
		n += 1 + sovTypes(uint64(m.SecretEncodingType))
	}
	if m.BlindfoldSecretInfoInternal != nil {
		l = m.BlindfoldSecretInfoInternal.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SecretType_BlindfoldSecretInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlindfoldSecretInfo != nil {
		l = m.BlindfoldSecretInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SecretType_VaultSecretInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VaultSecretInfo != nil {
		l = m.VaultSecretInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SecretType_ClearSecretInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClearSecretInfo != nil {
		l = m.ClearSecretInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SecretType_WingmanSecretInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WingmanSecretInfo != nil {
		l = m.WingmanSecretInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, e := range m.Ref {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *SiteRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, e := range m.Ref {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.NetworkType != 0 {
		n += 1 + sovTypes(uint64(m.NetworkType))
	}
	if m.InternetVipChoice != nil {
		n += m.InternetVipChoice.Size()
	}
	if len(m.Refs) > 0 {
		for _, e := range m.Refs {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *SiteRefType_EnableInternetVip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableInternetVip != nil {
		l = m.EnableInternetVip.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SiteRefType_DisableInternetVip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableInternetVip != nil {
		l = m.DisableInternetVip.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *IpPrefixSetRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, e := range m.Ref {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *VSiteRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, e := range m.Ref {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.NetworkType != 0 {
		n += 1 + sovTypes(uint64(m.NetworkType))
	}
	if m.InternetVipChoice != nil {
		n += m.InternetVipChoice.Size()
	}
	if len(m.Refs) > 0 {
		for _, e := range m.Refs {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *VSiteRefType_EnableInternetVip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableInternetVip != nil {
		l = m.EnableInternetVip.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VSiteRefType_DisableInternetVip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableInternetVip != nil {
		l = m.DisableInternetVip.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PolicerRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, e := range m.Ref {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ProtocolPolicerRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, e := range m.Ref {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *NetworkSiteRefSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RefOrSelector != nil {
		n += m.RefOrSelector.Size()
	}
	return n
}

func (m *NetworkSiteRefSelector_VirtualNetwork) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VirtualNetwork != nil {
		l = m.VirtualNetwork.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkSiteRefSelector_Site) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Site != nil {
		l = m.Site.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkSiteRefSelector_VirtualSite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VirtualSite != nil {
		l = m.VirtualSite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SiteVirtualSiteRefSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RefOrSelector != nil {
		n += m.RefOrSelector.Size()
	}
	return n
}

func (m *SiteVirtualSiteRefSelector_Site) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Site != nil {
		l = m.Site.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SiteVirtualSiteRefSelector_VirtualSite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VirtualSite != nil {
		l = m.VirtualSite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HeaderManipulationOptionType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ValueChoice != nil {
		n += m.ValueChoice.Size()
	}
	if m.Append {
		n += 2
	}
	return n
}

func (m *HeaderManipulationOptionType_Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *HeaderManipulationOptionType_SecretValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SecretValue != nil {
		l = m.SecretValue.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieManipulationOptionType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Samesite != nil {
		n += m.Samesite.Size()
	}
	if m.Secure != nil {
		n += m.Secure.Size()
	}
	if m.Httponly != nil {
		n += m.Httponly.Size()
	}
	if m.MaxAge != nil {
		n += m.MaxAge.Size()
	}
	if m.CookieTampering != nil {
		n += m.CookieTampering.Size()
	}
	return n
}

func (m *CookieManipulationOptionType_SamesiteStrict) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SamesiteStrict != nil {
		l = m.SamesiteStrict.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieManipulationOptionType_SamesiteLax) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SamesiteLax != nil {
		l = m.SamesiteLax.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieManipulationOptionType_SamesiteNone) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SamesiteNone != nil {
		l = m.SamesiteNone.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieManipulationOptionType_IgnoreSecure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IgnoreSecure != nil {
		l = m.IgnoreSecure.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieManipulationOptionType_AddSecure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddSecure != nil {
		l = m.AddSecure.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieManipulationOptionType_IgnoreHttponly) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IgnoreHttponly != nil {
		l = m.IgnoreHttponly.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieManipulationOptionType_AddHttponly) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddHttponly != nil {
		l = m.AddHttponly.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieManipulationOptionType_IgnoreMaxAge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IgnoreMaxAge != nil {
		l = m.IgnoreMaxAge.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieManipulationOptionType_MaxAgeValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.MaxAgeValue))
	return n
}
func (m *CookieManipulationOptionType_IgnoreSamesite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IgnoreSamesite != nil {
		l = m.IgnoreSamesite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieManipulationOptionType_DisableTamperingProtection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableTamperingProtection != nil {
		l = m.DisableTamperingProtection.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CookieManipulationOptionType_EnableTamperingProtection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableTamperingProtection != nil {
		l = m.EnableTamperingProtection.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TrustedCAList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TrustedCaList) > 0 {
		for _, e := range m.TrustedCaList {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *TlsValidationParamsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TrustedCaChoice != nil {
		n += m.TrustedCaChoice.Size()
	}
	if m.SkipHostnameVerification {
		n += 2
	}
	if len(m.VerifySubjectAltNames) > 0 {
		for _, s := range m.VerifySubjectAltNames {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.UseVolterraTrustedCaUrl {
		n += 2
	}
	return n
}

func (m *TlsValidationParamsType_TrustedCaUrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TrustedCaUrl)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *TlsValidationParamsType_TrustedCa) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TrustedCa != nil {
		l = m.TrustedCa.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HashAlgorithms) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.HashAlgorithms) > 0 {
		l = 0
		for _, e := range m.HashAlgorithms {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *TlsCertificateType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CertificateUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PrivateKey != nil {
		l = m.PrivateKey.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OcspStaplingChoice != nil {
		n += m.OcspStaplingChoice.Size()
	}
	return n
}

func (m *TlsCertificateType_UseSystemDefaults) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseSystemDefaults != nil {
		l = m.UseSystemDefaults.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TlsCertificateType_DisableOcspStapling) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableOcspStapling != nil {
		l = m.DisableOcspStapling.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TlsCertificateType_CustomHashAlgorithms) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CustomHashAlgorithms != nil {
		l = m.CustomHashAlgorithms.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DomainType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DomainChoice != nil {
		n += m.DomainChoice.Size()
	}
	return n
}

func (m *DomainType_ExactValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExactValue)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *DomainType_SuffixValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SuffixValue)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *DomainType_RegexValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RegexValue)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *L4DestType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Prefixes) > 0 {
		for _, s := range m.Prefixes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.PortRanges)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *TlsInterceptionRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DomainMatch != nil {
		l = m.DomainMatch.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EnableDisableChoice != nil {
		n += m.EnableDisableChoice.Size()
	}
	return n
}

func (m *TlsInterceptionRule_DisableInterception) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableInterception != nil {
		l = m.DisableInterception.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TlsInterceptionRule_EnableInterception) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableInterception != nil {
		l = m.EnableInterception.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TlsInterceptionPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.InterceptionRules) > 0 {
		for _, e := range m.InterceptionRules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *TlsInterceptionType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InterceptionPolicyChoice != nil {
		n += m.InterceptionPolicyChoice.Size()
	}
	if m.SigningCertChoice != nil {
		n += m.SigningCertChoice.Size()
	}
	if m.TrustedCaChoice != nil {
		n += m.TrustedCaChoice.Size()
	}
	return n
}

func (m *TlsInterceptionType_Policy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TlsInterceptionType_CustomCertificate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CustomCertificate != nil {
		l = m.CustomCertificate.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TlsInterceptionType_VolterraCertificate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VolterraCertificate != nil {
		l = m.VolterraCertificate.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TlsInterceptionType_TrustedCaUrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TrustedCaUrl)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *TlsInterceptionType_VolterraTrustedCa) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VolterraTrustedCa != nil {
		l = m.VolterraTrustedCa.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TlsInterceptionType_EnableForAllDomains) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableForAllDomains != nil {
		l = m.EnableForAllDomains.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FractionalPercent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Numerator != 0 {
		n += 1 + sovTypes(uint64(m.Numerator))
	}
	if m.Denominator != 0 {
		n += 1 + sovTypes(uint64(m.Denominator))
	}
	return n
}

func (m *BufferConfigType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Disabled {
		n += 2
	}
	if m.MaxRequestBytes != 0 {
		n += 1 + sovTypes(uint64(m.MaxRequestBytes))
	}
	if m.MaxRequestTime != 0 {
		n += 1 + sovTypes(uint64(m.MaxRequestTime))
	}
	return n
}

func (m *CorsPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Disabled {
		n += 2
	}
	if len(m.AllowOrigin) > 0 {
		for _, s := range m.AllowOrigin {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AllowOriginRegex) > 0 {
		for _, s := range m.AllowOriginRegex {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.AllowMethods)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AllowHeaders)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ExposeHeaders)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.MaxAge)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AllowCredentials {
		n += 2
	}
	if m.MaximumAge != 0 {
		n += 1 + sovTypes(uint64(m.MaximumAge))
	}
	return n
}

func (m *CsrfPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowedDomains != nil {
		n += m.AllowedDomains.Size()
	}
	return n
}

func (m *CsrfPolicy_AllLoadBalancerDomains) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllLoadBalancerDomains != nil {
		l = m.AllLoadBalancerDomains.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CsrfPolicy_CustomDomainList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CustomDomainList != nil {
		l = m.CustomDomainList.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CsrfPolicy_Disabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Disabled != nil {
		l = m.Disabled.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PathMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PathMatch != nil {
		n += m.PathMatch.Size()
	}
	return n
}

func (m *PathMatcherType_Prefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Prefix)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *PathMatcherType_Path) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *PathMatcherType_Regex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Regex)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *PortMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortMatch != nil {
		n += m.PortMatch.Size()
	}
	return n
}

func (m *PortMatcherType_Port) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.Port))
	return n
}
func (m *PortMatcherType_PortRanges) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortRanges)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *PortMatcherType_NoPortMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoPortMatch != nil {
		l = m.NoPortMatch.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HeaderMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ValueMatch != nil {
		n += m.ValueMatch.Size()
	}
	if m.InvertMatch {
		n += 2
	}
	return n
}

func (m *HeaderMatcherType_Exact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Exact)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *HeaderMatcherType_Regex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Regex)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *HeaderMatcherType_Presence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *QueryParameterMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ValueMatch != nil {
		n += m.ValueMatch.Size()
	}
	return n
}

func (m *QueryParameterMatcherType_Exact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Exact)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *QueryParameterMatcherType_Regex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Regex)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *RouteMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.QueryParams) > 0 {
		for _, e := range m.QueryParams {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.HttpMethod != 0 {
		n += 1 + sovTypes(uint64(m.HttpMethod))
	}
	if m.IncomingPort != nil {
		l = m.IncomingPort.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AppFirewallRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AppFirewall) > 0 {
		for _, e := range m.AppFirewall {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *WafType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RefType != nil {
		n += m.RefType.Size()
	}
	return n
}

func (m *WafType_AppFirewall) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppFirewall != nil {
		l = m.AppFirewall.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WafType_DisableWaf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableWaf != nil {
		l = m.DisableWaf.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WafType_InheritWaf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InheritWaf != nil {
		l = m.InheritWaf.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AppRoleAuthInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RoleId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SecretId != nil {
		l = m.SecretId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *VaultAuthInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthParams != nil {
		n += m.AuthParams.Size()
	}
	return n
}

func (m *VaultAuthInfoType_AppRoleAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppRoleAuth != nil {
		l = m.AppRoleAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VaultAuthInfoType_Token) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RestAuthInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthParams != nil {
		n += m.AuthParams.Size()
	}
	return n
}

func (m *RestAuthInfoType_BasicAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BasicAuth != nil {
		l = m.BasicAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RestAuthInfoType_HeadersAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HeadersAuth != nil {
		l = m.HeadersAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RestAuthInfoType_QueryParamsAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryParamsAuth != nil {
		l = m.QueryParamsAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VaultAccessInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VaultAddr)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VaultCaUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AuthnChoice != nil {
		n += m.AuthnChoice.Size()
	}
	return n
}

func (m *VaultAccessInfoType_AppRoleAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppRoleAuth != nil {
		l = m.AppRoleAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VaultAccessInfoType_Token) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VaultSecretType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccessChoice != nil {
		n += m.AccessChoice.Size()
	}
	l = len(m.SecretPath)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SecretSubPath)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SecretVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *VaultSecretType_VaultAccessInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VaultAccessInfo != nil {
		l = m.VaultAccessInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VaultSecretType_ProviderName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProviderName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *VolterraSecretType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SecretTypeChoice != nil {
		n += m.SecretTypeChoice.Size()
	}
	return n
}

func (m *VolterraSecretType_BlindfoldSecretInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlindfoldSecretInfo != nil {
		l = m.BlindfoldSecretInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VolterraSecretType_VaultSecretInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VaultSecretInfo != nil {
		l = m.VaultSecretInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PortValueType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortValueTypeChoice != nil {
		n += m.PortValueTypeChoice.Size()
	}
	return n
}

func (m *PortValueType_All) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.All != nil {
		l = m.All.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PortValueType_UserDefined) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.UserDefined))
	return n
}
func (m *PortValueType_Dns) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dns != nil {
		l = m.Dns.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VirtualNetworkReferenceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Refs) > 0 {
		for _, e := range m.Refs {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *VirtualNetworkSelectorType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VnTypeChoice != nil {
		n += m.VnTypeChoice.Size()
	}
	return n
}

func (m *VirtualNetworkSelectorType_SiteLocal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteLocal != nil {
		l = m.SiteLocal.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VirtualNetworkSelectorType_SiteLocalInside) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteLocalInside != nil {
		l = m.SiteLocalInside.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VirtualNetworkSelectorType_Public) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Public != nil {
		l = m.Public.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RetryBackOff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BaseInterval != 0 {
		n += 1 + sovTypes(uint64(m.BaseInterval))
	}
	if m.MaxInterval != 0 {
		n += 1 + sovTypes(uint64(m.MaxInterval))
	}
	return n
}

func (m *RetryPolicyType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RetryOn)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NumRetries != 0 {
		n += 1 + sovTypes(uint64(m.NumRetries))
	}
	if m.PerTryTimeout != 0 {
		n += 1 + sovTypes(uint64(m.PerTryTimeout))
	}
	if len(m.RetriableStatusCodes) > 0 {
		l = 0
		for _, e := range m.RetriableStatusCodes {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.BackOff != nil {
		l = m.BackOff.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.RetryCondition) > 0 {
		for _, s := range m.RetryCondition {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *MetricValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 9
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TrendValue != nil {
		l = m.TrendValue.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *MetricTypeData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *TrendValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Sentiment != 0 {
		n += 1 + sovTypes(uint64(m.Sentiment))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PreviousValue)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *NextHopType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.NexthopAddress != nil {
		l = m.NexthopAddress.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Interface) > 0 {
		for _, e := range m.Interface {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *StaticRouteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attrs) > 0 {
		l = 0
		for _, e := range m.Attrs {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.Subnets) > 0 {
		for _, e := range m.Subnets {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Nexthop != nil {
		l = m.Nexthop.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ForwardProxyConfigType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.WhiteListedPrefixes) > 0 {
		for _, s := range m.WhiteListedPrefixes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.WhiteListedPorts) > 0 {
		l = 0
		for _, e := range m.WhiteListedPorts {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.MaxConnectAttempts != 0 {
		n += 1 + sovTypes(uint64(m.MaxConnectAttempts))
	}
	if m.ConnectionTimeout != 0 {
		n += 1 + sovTypes(uint64(m.ConnectionTimeout))
	}
	if m.TlsInterceptionChoice != nil {
		n += m.TlsInterceptionChoice.Size()
	}
	return n
}

func (m *ForwardProxyConfigType_NoInterception) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoInterception != nil {
		l = m.NoInterception.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ForwardProxyConfigType_TlsIntercept) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TlsIntercept != nil {
		l = m.TlsIntercept.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HostIdentifier) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HostnameOrIp != nil {
		n += m.HostnameOrIp.Size()
	}
	return n
}

func (m *HostIdentifier_Ip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ip)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *HostIdentifier_Hostname) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hostname)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *InterfaceIdentifier) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InterfaceChoice != nil {
		n += m.InterfaceChoice.Size()
	}
	return n
}

func (m *InterfaceIdentifier_AnyIntf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyIntf != nil {
		l = m.AnyIntf.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *InterfaceIdentifier_Intf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Intf)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *InterfaceOrNetwork) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InterfaceChoice != nil {
		n += m.InterfaceChoice.Size()
	}
	return n
}

func (m *InterfaceOrNetwork_Intf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Intf)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *InterfaceOrNetwork_Pod) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Pod)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *InterfaceOrNetwork_VnType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.VnType))
	return n
}
func (m *InterfaceOrNetwork_Vn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Vn)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *RouteTarget2ByteAsn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AsNumber != 0 {
		n += 1 + sovTypes(uint64(m.AsNumber))
	}
	if m.Value != 0 {
		n += 1 + sovTypes(uint64(m.Value))
	}
	return n
}

func (m *RouteTarget4ByteAsn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AsNumber != 0 {
		n += 1 + sovTypes(uint64(m.AsNumber))
	}
	if m.Value != 0 {
		n += 1 + sovTypes(uint64(m.Value))
	}
	return n
}

func (m *RouteTargetIPv4Addr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovTypes(uint64(m.Value))
	}
	return n
}

func (m *RouteTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RtargetChoice != nil {
		n += m.RtargetChoice.Size()
	}
	return n
}

func (m *RouteTarget_Asn2ByteRtarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Asn2ByteRtarget != nil {
		l = m.Asn2ByteRtarget.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteTarget_Ipv4AddrRtarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ipv4AddrRtarget != nil {
		l = m.Ipv4AddrRtarget.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteTarget_Asn4ByteRtarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Asn4ByteRtarget != nil {
		l = m.Asn4ByteRtarget.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PortRangesType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, s := range m.Ports {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *DomainNameList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *NamespaceRoleType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RoleListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *NamespaceAccessType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NamespaceRoleMap) > 0 {
		for k, v := range m.NamespaceRoleMap {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SiteInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Site) > 0 {
		for _, e := range m.Site {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Annotations) > 0 {
		for _, s := range m.Annotations {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *SiteReferenceListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Refs) > 0 {
		for _, e := range m.Refs {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *HeaderTransformationType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HeaderTransformationChoice != nil {
		n += m.HeaderTransformationChoice.Size()
	}
	return n
}

func (m *HeaderTransformationType_DefaultHeaderTransformation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultHeaderTransformation != nil {
		l = m.DefaultHeaderTransformation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HeaderTransformationType_ProperCaseHeaderTransformation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProperCaseHeaderTransformation != nil {
		l = m.ProperCaseHeaderTransformation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HeaderTransformationType_PreserveCaseHeaderTransformation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PreserveCaseHeaderTransformation != nil {
		l = m.PreserveCaseHeaderTransformation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HeaderTransformationType_LegacyHeaderTransformation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LegacyHeaderTransformation != nil {
		l = m.LegacyHeaderTransformation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelCategoriesChoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FlowLabelChoice != nil {
		n += m.FlowLabelChoice.Size()
	}
	return n
}

func (m *BotDefenseFlowLabelCategoriesChoiceType_Authentication) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Authentication != nil {
		l = m.Authentication.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelCategoriesChoiceType_AccountManagement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccountManagement != nil {
		l = m.AccountManagement.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelCategoriesChoiceType_ProfileManagement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProfileManagement != nil {
		l = m.ProfileManagement.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelCategoriesChoiceType_ShoppingGiftCards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShoppingGiftCards != nil {
		l = m.ShoppingGiftCards.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelCategoriesChoiceType_FinancialServices) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FinancialServices != nil {
		l = m.FinancialServices.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelCategoriesChoiceType_Search) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Search != nil {
		l = m.Search.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelCategoriesChoiceType_Flight) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flight != nil {
		l = m.Flight.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelAuthenticationChoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LabelChoice != nil {
		n += m.LabelChoice.Size()
	}
	return n
}

func (m *BotDefenseFlowLabelAuthenticationChoiceType_Login) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Login != nil {
		l = m.Login.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelAuthenticationChoiceType_LoginMfa) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LoginMfa != nil {
		l = m.LoginMfa.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelAuthenticationChoiceType_LoginPartner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LoginPartner != nil {
		l = m.LoginPartner.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelAuthenticationChoiceType_Logout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Logout != nil {
		l = m.Logout.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelAuthenticationChoiceType_TokenRefresh) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TokenRefresh != nil {
		l = m.TokenRefresh.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseTransactionResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TransactionResultChoice != nil {
		n += m.TransactionResultChoice.Size()
	}
	return n
}

func (m *BotDefenseTransactionResult_DisableTransactionResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableTransactionResult != nil {
		l = m.DisableTransactionResult.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseTransactionResult_TransactionResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TransactionResult != nil {
		l = m.TransactionResult.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseTransactionResultType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SuccessConditions) > 0 {
		for _, e := range m.SuccessConditions {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.FailureConditions) > 0 {
		for _, e := range m.FailureConditions {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *BotDefenseTransactionResultCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.RegexValues) > 0 {
		for _, s := range m.RegexValues {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	return n
}

func (m *BotDefenseFlowLabelAccountManagementChoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LabelChoice != nil {
		n += m.LabelChoice.Size()
	}
	return n
}

func (m *BotDefenseFlowLabelAccountManagementChoiceType_Create) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Create != nil {
		l = m.Create.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelAccountManagementChoiceType_PasswordReset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PasswordReset != nil {
		l = m.PasswordReset.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelProfileManagementChoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LabelChoice != nil {
		n += m.LabelChoice.Size()
	}
	return n
}

func (m *BotDefenseFlowLabelProfileManagementChoiceType_Create) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Create != nil {
		l = m.Create.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelProfileManagementChoiceType_Update) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Update != nil {
		l = m.Update.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelProfileManagementChoiceType_View) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.View != nil {
		l = m.View.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LabelChoice != nil {
		n += m.LabelChoice.Size()
	}
	return n
}

func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopAddToCart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShopAddToCart != nil {
		l = m.ShopAddToCart.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPromoCodeValidation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShopPromoCodeValidation != nil {
		l = m.ShopPromoCodeValidation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopCheckout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShopCheckout != nil {
		l = m.ShopCheckout.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopMakePayment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShopMakePayment != nil {
		l = m.ShopMakePayment.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShopOrder != nil {
		l = m.ShopOrder.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPriceInquiry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShopPriceInquiry != nil {
		l = m.ShopPriceInquiry.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPurchaseGiftCard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShopPurchaseGiftCard != nil {
		l = m.ShopPurchaseGiftCard.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopUpdateQuantity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShopUpdateQuantity != nil {
		l = m.ShopUpdateQuantity.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopChooseSeat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShopChooseSeat != nil {
		l = m.ShopChooseSeat.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopEnterDrawingSubmission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShopEnterDrawingSubmission != nil {
		l = m.ShopEnterDrawingSubmission.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardValidation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GiftCardValidation != nil {
		l = m.GiftCardValidation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardMakePurchaseWithGiftCard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GiftCardMakePurchaseWithGiftCard != nil {
		l = m.GiftCardMakePurchaseWithGiftCard.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelFinancialServicesChoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LabelChoice != nil {
		n += m.LabelChoice.Size()
	}
	return n
}

func (m *BotDefenseFlowLabelFinancialServicesChoiceType_Apply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Apply != nil {
		l = m.Apply.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelFinancialServicesChoiceType_MoneyTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MoneyTransfer != nil {
		l = m.MoneyTransfer.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelSearchChoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LabelChoice != nil {
		n += m.LabelChoice.Size()
	}
	return n
}

func (m *BotDefenseFlowLabelSearchChoiceType_FlightSearch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FlightSearch != nil {
		l = m.FlightSearch.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelSearchChoiceType_ProductSearch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProductSearch != nil {
		l = m.ProductSearch.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelSearchChoiceType_RoomSearch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomSearch != nil {
		l = m.RoomSearch.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelSearchChoiceType_ReservationSearch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReservationSearch != nil {
		l = m.ReservationSearch.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *BotDefenseFlowLabelFlightChoiceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LabelChoice != nil {
		n += m.LabelChoice.Size()
	}
	return n
}

func (m *BotDefenseFlowLabelFlightChoiceType_Checkin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Checkin != nil {
		l = m.Checkin.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkingStackType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *NetworkingStackType_Ipv4) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ipv4 != nil {
		l = m.Ipv4.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkingStackType_Ipv6) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ipv6 != nil {
		l = m.Ipv6.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkingStackType_Dual) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dual != nil {
		l = m.Dual.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DateRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartDate != nil {
		l = m.StartDate.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EndDate != nil {
		l = m.EndDate.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *File) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.FileId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.StorageProvider != nil {
		n += m.StorageProvider.Size()
	}
	return n
}

func (m *File_AwsS3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AwsS3 != nil {
		l = m.AwsS3.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ResponseMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovTypes(uint64(m.ErrorCode))
	}
	l = len(m.DisplayMessage)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Action) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActionChoice != nil {
		n += m.ActionChoice.Size()
	}
	return n
}

func (m *Action_Block) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Action_Report) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Report != nil {
		l = m.Report.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CRMInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EntitlementId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubscriptionId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.OrderType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.EntitledSkus) > 0 {
		for _, s := range m.EntitledSkus {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.CustomerIdentifier)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RegexMatchRewrite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Pattern)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Substitution)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Empty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Empty{`,
		`}`,
	}, "")
	return s
}
func (this *ObjectRefType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ObjectRefType{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`Tenant:` + fmt.Sprintf("%v", this.Tenant) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LabelSelectorType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LabelSelectorType{`,
		`Expressions:` + fmt.Sprintf("%v", this.Expressions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LabelMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LabelMatcherType{`,
		`Keys:` + fmt.Sprintf("%v", this.Keys) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConditionType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConditionType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`LastUpdateTime:` + strings.Replace(fmt.Sprintf("%v", this.LastUpdateTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`Hostname:` + fmt.Sprintf("%v", this.Hostname) + `,`,
		`ServiceName:` + fmt.Sprintf("%v", this.ServiceName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StatusType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StatusType{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InitializerType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InitializerType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InitializersType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPending := "[]*InitializerType{"
	for _, f := range this.Pending {
		repeatedStringForPending += strings.Replace(f.String(), "InitializerType", "InitializerType", 1) + ","
	}
	repeatedStringForPending += "}"
	s := strings.Join([]string{`&InitializersType{`,
		`Pending:` + repeatedStringForPending + `,`,
		`Result:` + strings.Replace(this.Result.String(), "StatusType", "StatusType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StatusMetaType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StatusMetaType{`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`CreatorClass:` + fmt.Sprintf("%v", this.CreatorClass) + `,`,
		`CreatorId:` + fmt.Sprintf("%v", this.CreatorId) + `,`,
		`StatusId:` + fmt.Sprintf("%v", this.StatusId) + `,`,
		`CreationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.CreationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`Publish:` + fmt.Sprintf("%v", this.Publish) + `,`,
		`VtrpId:` + fmt.Sprintf("%v", this.VtrpId) + `,`,
		`VtrpStale:` + fmt.Sprintf("%v", this.VtrpStale) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ObjectMetaType) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%v: %v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	s := strings.Join([]string{`&ObjectMetaType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Annotations:` + mapStringForAnnotations + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Disable:` + fmt.Sprintf("%v", this.Disable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListMetaType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListMetaType{`,
		`ResourceVersion:` + fmt.Sprintf("%v", this.ResourceVersion) + `,`,
		`NextPage:` + fmt.Sprintf("%v", this.NextPage) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ObjectGetMetaType) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%v: %v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	s := strings.Join([]string{`&ObjectGetMetaType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Annotations:` + mapStringForAnnotations + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Disable:` + fmt.Sprintf("%v", this.Disable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ObjectCreateMetaType) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%v: %v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	s := strings.Join([]string{`&ObjectCreateMetaType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Annotations:` + mapStringForAnnotations + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Disable:` + fmt.Sprintf("%v", this.Disable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ObjectReplaceMetaType) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%v: %v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	s := strings.Join([]string{`&ObjectReplaceMetaType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Annotations:` + mapStringForAnnotations + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Disable:` + fmt.Sprintf("%v", this.Disable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MessageMetaType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MessageMetaType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Disable:` + fmt.Sprintf("%v", this.Disable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ViewRefType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ViewRefType{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *KubeRefType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&KubeRefType{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SystemObjectMetaType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNamespace := "[]*ObjectRefType{"
	for _, f := range this.Namespace {
		repeatedStringForNamespace += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForNamespace += "}"
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&SystemObjectMetaType{`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`CreationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.CreationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`DeletionTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.DeletionTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`ModificationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ModificationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`Initializers:` + strings.Replace(this.Initializers.String(), "InitializersType", "InitializersType", 1) + `,`,
		`Finalizers:` + fmt.Sprintf("%v", this.Finalizers) + `,`,
		`Tenant:` + fmt.Sprintf("%v", this.Tenant) + `,`,
		`CreatorClass:` + fmt.Sprintf("%v", this.CreatorClass) + `,`,
		`CreatorId:` + fmt.Sprintf("%v", this.CreatorId) + `,`,
		`TraceInfo:` + fmt.Sprintf("%v", this.TraceInfo) + `,`,
		`ObjectIndex:` + fmt.Sprintf("%v", this.ObjectIndex) + `,`,
		`Namespace:` + repeatedStringForNamespace + `,`,
		`CreatorCookie:` + fmt.Sprintf("%v", this.CreatorCookie) + `,`,
		`OwnerView:` + strings.Replace(this.OwnerView.String(), "ViewRefType", "ViewRefType", 1) + `,`,
		`SreDisable:` + fmt.Sprintf("%v", this.SreDisable) + `,`,
		`VtrpId:` + fmt.Sprintf("%v", this.VtrpId) + `,`,
		`VtrpStale:` + fmt.Sprintf("%v", this.VtrpStale) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`}`,
	}, "")
	return s
}
func (this *SystemObjectGetMetaType) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&SystemObjectGetMetaType{`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`CreationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.CreationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`DeletionTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.DeletionTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`ModificationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ModificationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`Initializers:` + strings.Replace(this.Initializers.String(), "InitializersType", "InitializersType", 1) + `,`,
		`Finalizers:` + fmt.Sprintf("%v", this.Finalizers) + `,`,
		`Tenant:` + fmt.Sprintf("%v", this.Tenant) + `,`,
		`CreatorClass:` + fmt.Sprintf("%v", this.CreatorClass) + `,`,
		`CreatorId:` + fmt.Sprintf("%v", this.CreatorId) + `,`,
		`ObjectIndex:` + fmt.Sprintf("%v", this.ObjectIndex) + `,`,
		`OwnerView:` + strings.Replace(this.OwnerView.String(), "ViewRefType", "ViewRefType", 1) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthnTypeBasicAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthnTypeBasicAuth{`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`Password:` + strings.Replace(fmt.Sprintf("%v", this.Password), "SecretType", "SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthnTypeHeaders) String() string {
	if this == nil {
		return "nil"
	}
	keysForHeaders := make([]string, 0, len(this.Headers))
	for k, _ := range this.Headers {
		keysForHeaders = append(keysForHeaders, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHeaders)
	mapStringForHeaders := "map[string]*SecretType{"
	for _, k := range keysForHeaders {
		mapStringForHeaders += fmt.Sprintf("%v: %v,", k, this.Headers[k])
	}
	mapStringForHeaders += "}"
	s := strings.Join([]string{`&AuthnTypeHeaders{`,
		`Headers:` + mapStringForHeaders + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthnTypeQueryParams) String() string {
	if this == nil {
		return "nil"
	}
	keysForQueryParams := make([]string, 0, len(this.QueryParams))
	for k, _ := range this.QueryParams {
		keysForQueryParams = append(keysForQueryParams, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForQueryParams)
	mapStringForQueryParams := "map[string]*SecretType{"
	for _, k := range keysForQueryParams {
		mapStringForQueryParams += fmt.Sprintf("%v: %v,", k, this.QueryParams[k])
	}
	mapStringForQueryParams += "}"
	s := strings.Join([]string{`&AuthnTypeQueryParams{`,
		`QueryParams:` + mapStringForQueryParams + `,`,
		`}`,
	}, "")
	return s
}
func (this *BlindfoldSecretInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BlindfoldSecretInfoType{`,
		`DecryptionProvider:` + fmt.Sprintf("%v", this.DecryptionProvider) + `,`,
		`StoreProvider:` + fmt.Sprintf("%v", this.StoreProvider) + `,`,
		`Location:` + fmt.Sprintf("%v", this.Location) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultSecretInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultSecretInfoType{`,
		`Provider:` + fmt.Sprintf("%v", this.Provider) + `,`,
		`Location:` + fmt.Sprintf("%v", this.Location) + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`SecretEncoding:` + fmt.Sprintf("%v", this.SecretEncoding) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClearSecretInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClearSecretInfoType{`,
		`Provider:` + fmt.Sprintf("%v", this.Provider) + `,`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WingmanSecretInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WingmanSecretInfoType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkRefType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRef := "[]*ObjectRefType{"
	for _, f := range this.Ref {
		repeatedStringForRef += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForRef += "}"
	s := strings.Join([]string{`&NetworkRefType{`,
		`Ref:` + repeatedStringForRef + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteRefType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRef := "[]*ObjectRefType{"
	for _, f := range this.Ref {
		repeatedStringForRef += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForRef += "}"
	repeatedStringForRefs := "[]*ObjectRefType{"
	for _, f := range this.Refs {
		repeatedStringForRefs += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForRefs += "}"
	s := strings.Join([]string{`&SiteRefType{`,
		`Ref:` + repeatedStringForRef + `,`,
		`NetworkType:` + fmt.Sprintf("%v", this.NetworkType) + `,`,
		`InternetVipChoice:` + fmt.Sprintf("%v", this.InternetVipChoice) + `,`,
		`Refs:` + repeatedStringForRefs + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteRefType_EnableInternetVip) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteRefType_EnableInternetVip{`,
		`EnableInternetVip:` + strings.Replace(fmt.Sprintf("%v", this.EnableInternetVip), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteRefType_DisableInternetVip) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteRefType_DisableInternetVip{`,
		`DisableInternetVip:` + strings.Replace(fmt.Sprintf("%v", this.DisableInternetVip), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpPrefixSetRefType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRef := "[]*ObjectRefType{"
	for _, f := range this.Ref {
		repeatedStringForRef += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForRef += "}"
	s := strings.Join([]string{`&IpPrefixSetRefType{`,
		`Ref:` + repeatedStringForRef + `,`,
		`}`,
	}, "")
	return s
}
func (this *VSiteRefType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRef := "[]*ObjectRefType{"
	for _, f := range this.Ref {
		repeatedStringForRef += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForRef += "}"
	repeatedStringForRefs := "[]*ObjectRefType{"
	for _, f := range this.Refs {
		repeatedStringForRefs += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForRefs += "}"
	s := strings.Join([]string{`&VSiteRefType{`,
		`Ref:` + repeatedStringForRef + `,`,
		`NetworkType:` + fmt.Sprintf("%v", this.NetworkType) + `,`,
		`InternetVipChoice:` + fmt.Sprintf("%v", this.InternetVipChoice) + `,`,
		`Refs:` + repeatedStringForRefs + `,`,
		`}`,
	}, "")
	return s
}
func (this *VSiteRefType_EnableInternetVip) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VSiteRefType_EnableInternetVip{`,
		`EnableInternetVip:` + strings.Replace(fmt.Sprintf("%v", this.EnableInternetVip), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VSiteRefType_DisableInternetVip) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VSiteRefType_DisableInternetVip{`,
		`DisableInternetVip:` + strings.Replace(fmt.Sprintf("%v", this.DisableInternetVip), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PolicerRefType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRef := "[]*ObjectRefType{"
	for _, f := range this.Ref {
		repeatedStringForRef += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForRef += "}"
	s := strings.Join([]string{`&PolicerRefType{`,
		`Ref:` + repeatedStringForRef + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtocolPolicerRefType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRef := "[]*ObjectRefType{"
	for _, f := range this.Ref {
		repeatedStringForRef += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForRef += "}"
	s := strings.Join([]string{`&ProtocolPolicerRefType{`,
		`Ref:` + repeatedStringForRef + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkSiteRefSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkSiteRefSelector{`,
		`RefOrSelector:` + fmt.Sprintf("%v", this.RefOrSelector) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkSiteRefSelector_VirtualNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkSiteRefSelector_VirtualNetwork{`,
		`VirtualNetwork:` + strings.Replace(fmt.Sprintf("%v", this.VirtualNetwork), "NetworkRefType", "NetworkRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkSiteRefSelector_Site) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkSiteRefSelector_Site{`,
		`Site:` + strings.Replace(fmt.Sprintf("%v", this.Site), "SiteRefType", "SiteRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkSiteRefSelector_VirtualSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkSiteRefSelector_VirtualSite{`,
		`VirtualSite:` + strings.Replace(fmt.Sprintf("%v", this.VirtualSite), "VSiteRefType", "VSiteRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteVirtualSiteRefSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteVirtualSiteRefSelector{`,
		`RefOrSelector:` + fmt.Sprintf("%v", this.RefOrSelector) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteVirtualSiteRefSelector_Site) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteVirtualSiteRefSelector_Site{`,
		`Site:` + strings.Replace(fmt.Sprintf("%v", this.Site), "SiteRefType", "SiteRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteVirtualSiteRefSelector_VirtualSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteVirtualSiteRefSelector_VirtualSite{`,
		`VirtualSite:` + strings.Replace(fmt.Sprintf("%v", this.VirtualSite), "VSiteRefType", "VSiteRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderManipulationOptionType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderManipulationOptionType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`ValueChoice:` + fmt.Sprintf("%v", this.ValueChoice) + `,`,
		`Append:` + fmt.Sprintf("%v", this.Append) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderManipulationOptionType_Value) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderManipulationOptionType_Value{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderManipulationOptionType_SecretValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderManipulationOptionType_SecretValue{`,
		`SecretValue:` + strings.Replace(fmt.Sprintf("%v", this.SecretValue), "SecretType", "SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieManipulationOptionType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieManipulationOptionType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Samesite:` + fmt.Sprintf("%v", this.Samesite) + `,`,
		`Secure:` + fmt.Sprintf("%v", this.Secure) + `,`,
		`Httponly:` + fmt.Sprintf("%v", this.Httponly) + `,`,
		`MaxAge:` + fmt.Sprintf("%v", this.MaxAge) + `,`,
		`CookieTampering:` + fmt.Sprintf("%v", this.CookieTampering) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieManipulationOptionType_SamesiteStrict) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieManipulationOptionType_SamesiteStrict{`,
		`SamesiteStrict:` + strings.Replace(fmt.Sprintf("%v", this.SamesiteStrict), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieManipulationOptionType_SamesiteLax) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieManipulationOptionType_SamesiteLax{`,
		`SamesiteLax:` + strings.Replace(fmt.Sprintf("%v", this.SamesiteLax), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieManipulationOptionType_SamesiteNone) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieManipulationOptionType_SamesiteNone{`,
		`SamesiteNone:` + strings.Replace(fmt.Sprintf("%v", this.SamesiteNone), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieManipulationOptionType_IgnoreSecure) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieManipulationOptionType_IgnoreSecure{`,
		`IgnoreSecure:` + strings.Replace(fmt.Sprintf("%v", this.IgnoreSecure), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieManipulationOptionType_AddSecure) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieManipulationOptionType_AddSecure{`,
		`AddSecure:` + strings.Replace(fmt.Sprintf("%v", this.AddSecure), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieManipulationOptionType_IgnoreHttponly) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieManipulationOptionType_IgnoreHttponly{`,
		`IgnoreHttponly:` + strings.Replace(fmt.Sprintf("%v", this.IgnoreHttponly), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieManipulationOptionType_AddHttponly) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieManipulationOptionType_AddHttponly{`,
		`AddHttponly:` + strings.Replace(fmt.Sprintf("%v", this.AddHttponly), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieManipulationOptionType_IgnoreMaxAge) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieManipulationOptionType_IgnoreMaxAge{`,
		`IgnoreMaxAge:` + strings.Replace(fmt.Sprintf("%v", this.IgnoreMaxAge), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieManipulationOptionType_MaxAgeValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieManipulationOptionType_MaxAgeValue{`,
		`MaxAgeValue:` + fmt.Sprintf("%v", this.MaxAgeValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieManipulationOptionType_IgnoreSamesite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieManipulationOptionType_IgnoreSamesite{`,
		`IgnoreSamesite:` + strings.Replace(fmt.Sprintf("%v", this.IgnoreSamesite), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieManipulationOptionType_DisableTamperingProtection) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieManipulationOptionType_DisableTamperingProtection{`,
		`DisableTamperingProtection:` + strings.Replace(fmt.Sprintf("%v", this.DisableTamperingProtection), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CookieManipulationOptionType_EnableTamperingProtection) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CookieManipulationOptionType_EnableTamperingProtection{`,
		`EnableTamperingProtection:` + strings.Replace(fmt.Sprintf("%v", this.EnableTamperingProtection), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TrustedCAList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTrustedCaList := "[]*ObjectRefType{"
	for _, f := range this.TrustedCaList {
		repeatedStringForTrustedCaList += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForTrustedCaList += "}"
	s := strings.Join([]string{`&TrustedCAList{`,
		`TrustedCaList:` + repeatedStringForTrustedCaList + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsValidationParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsValidationParamsType{`,
		`TrustedCaChoice:` + fmt.Sprintf("%v", this.TrustedCaChoice) + `,`,
		`SkipHostnameVerification:` + fmt.Sprintf("%v", this.SkipHostnameVerification) + `,`,
		`VerifySubjectAltNames:` + fmt.Sprintf("%v", this.VerifySubjectAltNames) + `,`,
		`UseVolterraTrustedCaUrl:` + fmt.Sprintf("%v", this.UseVolterraTrustedCaUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsValidationParamsType_TrustedCaUrl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsValidationParamsType_TrustedCaUrl{`,
		`TrustedCaUrl:` + fmt.Sprintf("%v", this.TrustedCaUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsValidationParamsType_TrustedCa) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsValidationParamsType_TrustedCa{`,
		`TrustedCa:` + strings.Replace(fmt.Sprintf("%v", this.TrustedCa), "TrustedCAList", "TrustedCAList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HashAlgorithms) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HashAlgorithms{`,
		`HashAlgorithms:` + fmt.Sprintf("%v", this.HashAlgorithms) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsCertificateType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsCertificateType{`,
		`CertificateUrl:` + fmt.Sprintf("%v", this.CertificateUrl) + `,`,
		`PrivateKey:` + strings.Replace(fmt.Sprintf("%v", this.PrivateKey), "SecretType", "SecretType", 1) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`OcspStaplingChoice:` + fmt.Sprintf("%v", this.OcspStaplingChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsCertificateType_UseSystemDefaults) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsCertificateType_UseSystemDefaults{`,
		`UseSystemDefaults:` + strings.Replace(fmt.Sprintf("%v", this.UseSystemDefaults), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsCertificateType_DisableOcspStapling) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsCertificateType_DisableOcspStapling{`,
		`DisableOcspStapling:` + strings.Replace(fmt.Sprintf("%v", this.DisableOcspStapling), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsCertificateType_CustomHashAlgorithms) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsCertificateType_CustomHashAlgorithms{`,
		`CustomHashAlgorithms:` + strings.Replace(fmt.Sprintf("%v", this.CustomHashAlgorithms), "HashAlgorithms", "HashAlgorithms", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DomainType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DomainType{`,
		`DomainChoice:` + fmt.Sprintf("%v", this.DomainChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DomainType_ExactValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DomainType_ExactValue{`,
		`ExactValue:` + fmt.Sprintf("%v", this.ExactValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DomainType_SuffixValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DomainType_SuffixValue{`,
		`SuffixValue:` + fmt.Sprintf("%v", this.SuffixValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DomainType_RegexValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DomainType_RegexValue{`,
		`RegexValue:` + fmt.Sprintf("%v", this.RegexValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *L4DestType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&L4DestType{`,
		`Prefixes:` + fmt.Sprintf("%v", this.Prefixes) + `,`,
		`PortRanges:` + fmt.Sprintf("%v", this.PortRanges) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionRule) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionRule{`,
		`DomainMatch:` + strings.Replace(this.DomainMatch.String(), "DomainType", "DomainType", 1) + `,`,
		`EnableDisableChoice:` + fmt.Sprintf("%v", this.EnableDisableChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionRule_DisableInterception) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionRule_DisableInterception{`,
		`DisableInterception:` + strings.Replace(fmt.Sprintf("%v", this.DisableInterception), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionRule_EnableInterception) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionRule_EnableInterception{`,
		`EnableInterception:` + strings.Replace(fmt.Sprintf("%v", this.EnableInterception), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionPolicy) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForInterceptionRules := "[]*TlsInterceptionRule{"
	for _, f := range this.InterceptionRules {
		repeatedStringForInterceptionRules += strings.Replace(f.String(), "TlsInterceptionRule", "TlsInterceptionRule", 1) + ","
	}
	repeatedStringForInterceptionRules += "}"
	s := strings.Join([]string{`&TlsInterceptionPolicy{`,
		`InterceptionRules:` + repeatedStringForInterceptionRules + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionType{`,
		`InterceptionPolicyChoice:` + fmt.Sprintf("%v", this.InterceptionPolicyChoice) + `,`,
		`SigningCertChoice:` + fmt.Sprintf("%v", this.SigningCertChoice) + `,`,
		`TrustedCaChoice:` + fmt.Sprintf("%v", this.TrustedCaChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionType_Policy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionType_Policy{`,
		`Policy:` + strings.Replace(fmt.Sprintf("%v", this.Policy), "TlsInterceptionPolicy", "TlsInterceptionPolicy", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionType_CustomCertificate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionType_CustomCertificate{`,
		`CustomCertificate:` + strings.Replace(fmt.Sprintf("%v", this.CustomCertificate), "TlsCertificateType", "TlsCertificateType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionType_VolterraCertificate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionType_VolterraCertificate{`,
		`VolterraCertificate:` + strings.Replace(fmt.Sprintf("%v", this.VolterraCertificate), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionType_TrustedCaUrl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionType_TrustedCaUrl{`,
		`TrustedCaUrl:` + fmt.Sprintf("%v", this.TrustedCaUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionType_VolterraTrustedCa) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionType_VolterraTrustedCa{`,
		`VolterraTrustedCa:` + strings.Replace(fmt.Sprintf("%v", this.VolterraTrustedCa), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionType_EnableForAllDomains) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionType_EnableForAllDomains{`,
		`EnableForAllDomains:` + strings.Replace(fmt.Sprintf("%v", this.EnableForAllDomains), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FractionalPercent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FractionalPercent{`,
		`Numerator:` + fmt.Sprintf("%v", this.Numerator) + `,`,
		`Denominator:` + fmt.Sprintf("%v", this.Denominator) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BufferConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BufferConfigType{`,
		`Disabled:` + fmt.Sprintf("%v", this.Disabled) + `,`,
		`MaxRequestBytes:` + fmt.Sprintf("%v", this.MaxRequestBytes) + `,`,
		`MaxRequestTime:` + fmt.Sprintf("%v", this.MaxRequestTime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CorsPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CorsPolicy{`,
		`Disabled:` + fmt.Sprintf("%v", this.Disabled) + `,`,
		`AllowOrigin:` + fmt.Sprintf("%v", this.AllowOrigin) + `,`,
		`AllowOriginRegex:` + fmt.Sprintf("%v", this.AllowOriginRegex) + `,`,
		`AllowMethods:` + fmt.Sprintf("%v", this.AllowMethods) + `,`,
		`AllowHeaders:` + fmt.Sprintf("%v", this.AllowHeaders) + `,`,
		`ExposeHeaders:` + fmt.Sprintf("%v", this.ExposeHeaders) + `,`,
		`MaxAge:` + fmt.Sprintf("%v", this.MaxAge) + `,`,
		`AllowCredentials:` + fmt.Sprintf("%v", this.AllowCredentials) + `,`,
		`MaximumAge:` + fmt.Sprintf("%v", this.MaximumAge) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CsrfPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CsrfPolicy{`,
		`AllowedDomains:` + fmt.Sprintf("%v", this.AllowedDomains) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CsrfPolicy_AllLoadBalancerDomains) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CsrfPolicy_AllLoadBalancerDomains{`,
		`AllLoadBalancerDomains:` + strings.Replace(fmt.Sprintf("%v", this.AllLoadBalancerDomains), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CsrfPolicy_CustomDomainList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CsrfPolicy_CustomDomainList{`,
		`CustomDomainList:` + strings.Replace(fmt.Sprintf("%v", this.CustomDomainList), "DomainNameList", "DomainNameList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CsrfPolicy_Disabled) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CsrfPolicy_Disabled{`,
		`Disabled:` + strings.Replace(fmt.Sprintf("%v", this.Disabled), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PathMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PathMatcherType{`,
		`PathMatch:` + fmt.Sprintf("%v", this.PathMatch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PathMatcherType_Prefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PathMatcherType_Prefix{`,
		`Prefix:` + fmt.Sprintf("%v", this.Prefix) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PathMatcherType_Path) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PathMatcherType_Path{`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PathMatcherType_Regex) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PathMatcherType_Regex{`,
		`Regex:` + fmt.Sprintf("%v", this.Regex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortMatcherType{`,
		`PortMatch:` + fmt.Sprintf("%v", this.PortMatch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortMatcherType_Port) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortMatcherType_Port{`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortMatcherType_PortRanges) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortMatcherType_PortRanges{`,
		`PortRanges:` + fmt.Sprintf("%v", this.PortRanges) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortMatcherType_NoPortMatch) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortMatcherType_NoPortMatch{`,
		`NoPortMatch:` + strings.Replace(fmt.Sprintf("%v", this.NoPortMatch), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`ValueMatch:` + fmt.Sprintf("%v", this.ValueMatch) + `,`,
		`InvertMatch:` + fmt.Sprintf("%v", this.InvertMatch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType_Exact) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType_Exact{`,
		`Exact:` + fmt.Sprintf("%v", this.Exact) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType_Regex) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType_Regex{`,
		`Regex:` + fmt.Sprintf("%v", this.Regex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType_Presence) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType_Presence{`,
		`Presence:` + fmt.Sprintf("%v", this.Presence) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryParameterMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryParameterMatcherType{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`ValueMatch:` + fmt.Sprintf("%v", this.ValueMatch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryParameterMatcherType_Exact) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryParameterMatcherType_Exact{`,
		`Exact:` + fmt.Sprintf("%v", this.Exact) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryParameterMatcherType_Regex) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryParameterMatcherType_Regex{`,
		`Regex:` + fmt.Sprintf("%v", this.Regex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteMatch) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHeaders := "[]*HeaderMatcherType{"
	for _, f := range this.Headers {
		repeatedStringForHeaders += strings.Replace(f.String(), "HeaderMatcherType", "HeaderMatcherType", 1) + ","
	}
	repeatedStringForHeaders += "}"
	repeatedStringForQueryParams := "[]*QueryParameterMatcherType{"
	for _, f := range this.QueryParams {
		repeatedStringForQueryParams += strings.Replace(f.String(), "QueryParameterMatcherType", "QueryParameterMatcherType", 1) + ","
	}
	repeatedStringForQueryParams += "}"
	s := strings.Join([]string{`&RouteMatch{`,
		`Path:` + strings.Replace(this.Path.String(), "PathMatcherType", "PathMatcherType", 1) + `,`,
		`Headers:` + repeatedStringForHeaders + `,`,
		`QueryParams:` + repeatedStringForQueryParams + `,`,
		`HttpMethod:` + fmt.Sprintf("%v", this.HttpMethod) + `,`,
		`IncomingPort:` + strings.Replace(this.IncomingPort.String(), "PortMatcherType", "PortMatcherType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AppFirewallRefType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAppFirewall := "[]*ObjectRefType{"
	for _, f := range this.AppFirewall {
		repeatedStringForAppFirewall += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForAppFirewall += "}"
	s := strings.Join([]string{`&AppFirewallRefType{`,
		`AppFirewall:` + repeatedStringForAppFirewall + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafType{`,
		`RefType:` + fmt.Sprintf("%v", this.RefType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafType_AppFirewall) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafType_AppFirewall{`,
		`AppFirewall:` + strings.Replace(fmt.Sprintf("%v", this.AppFirewall), "AppFirewallRefType", "AppFirewallRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafType_DisableWaf) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafType_DisableWaf{`,
		`DisableWaf:` + strings.Replace(fmt.Sprintf("%v", this.DisableWaf), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafType_InheritWaf) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafType_InheritWaf{`,
		`InheritWaf:` + strings.Replace(fmt.Sprintf("%v", this.InheritWaf), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AppRoleAuthInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AppRoleAuthInfoType{`,
		`RoleId:` + fmt.Sprintf("%v", this.RoleId) + `,`,
		`SecretId:` + strings.Replace(fmt.Sprintf("%v", this.SecretId), "SecretType", "SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultAuthInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultAuthInfoType{`,
		`AuthParams:` + fmt.Sprintf("%v", this.AuthParams) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultAuthInfoType_AppRoleAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultAuthInfoType_AppRoleAuth{`,
		`AppRoleAuth:` + strings.Replace(fmt.Sprintf("%v", this.AppRoleAuth), "AppRoleAuthInfoType", "AppRoleAuthInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultAuthInfoType_Token) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultAuthInfoType_Token{`,
		`Token:` + strings.Replace(fmt.Sprintf("%v", this.Token), "SecretType", "SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RestAuthInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RestAuthInfoType{`,
		`AuthParams:` + fmt.Sprintf("%v", this.AuthParams) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RestAuthInfoType_BasicAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RestAuthInfoType_BasicAuth{`,
		`BasicAuth:` + strings.Replace(fmt.Sprintf("%v", this.BasicAuth), "AuthnTypeBasicAuth", "AuthnTypeBasicAuth", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RestAuthInfoType_HeadersAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RestAuthInfoType_HeadersAuth{`,
		`HeadersAuth:` + strings.Replace(fmt.Sprintf("%v", this.HeadersAuth), "AuthnTypeHeaders", "AuthnTypeHeaders", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RestAuthInfoType_QueryParamsAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RestAuthInfoType_QueryParamsAuth{`,
		`QueryParamsAuth:` + strings.Replace(fmt.Sprintf("%v", this.QueryParamsAuth), "AuthnTypeQueryParams", "AuthnTypeQueryParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultAccessInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultAccessInfoType{`,
		`VaultAddr:` + fmt.Sprintf("%v", this.VaultAddr) + `,`,
		`VaultCaUrl:` + fmt.Sprintf("%v", this.VaultCaUrl) + `,`,
		`AuthnChoice:` + fmt.Sprintf("%v", this.AuthnChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultAccessInfoType_AppRoleAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultAccessInfoType_AppRoleAuth{`,
		`AppRoleAuth:` + strings.Replace(fmt.Sprintf("%v", this.AppRoleAuth), "AppRoleAuthInfoType", "AppRoleAuthInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultAccessInfoType_Token) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultAccessInfoType_Token{`,
		`Token:` + strings.Replace(fmt.Sprintf("%v", this.Token), "SecretType", "SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultSecretType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultSecretType{`,
		`AccessChoice:` + fmt.Sprintf("%v", this.AccessChoice) + `,`,
		`SecretPath:` + fmt.Sprintf("%v", this.SecretPath) + `,`,
		`SecretSubPath:` + fmt.Sprintf("%v", this.SecretSubPath) + `,`,
		`SecretVersion:` + fmt.Sprintf("%v", this.SecretVersion) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultSecretType_VaultAccessInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultSecretType_VaultAccessInfo{`,
		`VaultAccessInfo:` + strings.Replace(fmt.Sprintf("%v", this.VaultAccessInfo), "VaultAccessInfoType", "VaultAccessInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultSecretType_ProviderName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultSecretType_ProviderName{`,
		`ProviderName:` + fmt.Sprintf("%v", this.ProviderName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VolterraSecretType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VolterraSecretType{`,
		`SecretTypeChoice:` + fmt.Sprintf("%v", this.SecretTypeChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VolterraSecretType_BlindfoldSecretInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VolterraSecretType_BlindfoldSecretInfo{`,
		`BlindfoldSecretInfo:` + strings.Replace(fmt.Sprintf("%v", this.BlindfoldSecretInfo), "BlindfoldSecretInfoType", "BlindfoldSecretInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VolterraSecretType_VaultSecretInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VolterraSecretType_VaultSecretInfo{`,
		`VaultSecretInfo:` + strings.Replace(fmt.Sprintf("%v", this.VaultSecretInfo), "VaultAccessInfoType", "VaultAccessInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortValueType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortValueType{`,
		`PortValueTypeChoice:` + fmt.Sprintf("%v", this.PortValueTypeChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortValueType_All) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortValueType_All{`,
		`All:` + strings.Replace(fmt.Sprintf("%v", this.All), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortValueType_UserDefined) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortValueType_UserDefined{`,
		`UserDefined:` + fmt.Sprintf("%v", this.UserDefined) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortValueType_Dns) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortValueType_Dns{`,
		`Dns:` + strings.Replace(fmt.Sprintf("%v", this.Dns), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VirtualNetworkReferenceType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRefs := "[]*ObjectRefType{"
	for _, f := range this.Refs {
		repeatedStringForRefs += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForRefs += "}"
	s := strings.Join([]string{`&VirtualNetworkReferenceType{`,
		`Refs:` + repeatedStringForRefs + `,`,
		`}`,
	}, "")
	return s
}
func (this *VirtualNetworkSelectorType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VirtualNetworkSelectorType{`,
		`VnTypeChoice:` + fmt.Sprintf("%v", this.VnTypeChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VirtualNetworkSelectorType_SiteLocal) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VirtualNetworkSelectorType_SiteLocal{`,
		`SiteLocal:` + strings.Replace(fmt.Sprintf("%v", this.SiteLocal), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VirtualNetworkSelectorType_SiteLocalInside) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VirtualNetworkSelectorType_SiteLocalInside{`,
		`SiteLocalInside:` + strings.Replace(fmt.Sprintf("%v", this.SiteLocalInside), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VirtualNetworkSelectorType_Public) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VirtualNetworkSelectorType_Public{`,
		`Public:` + strings.Replace(fmt.Sprintf("%v", this.Public), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RetryBackOff) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RetryBackOff{`,
		`BaseInterval:` + fmt.Sprintf("%v", this.BaseInterval) + `,`,
		`MaxInterval:` + fmt.Sprintf("%v", this.MaxInterval) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RetryPolicyType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RetryPolicyType{`,
		`RetryOn:` + fmt.Sprintf("%v", this.RetryOn) + `,`,
		`NumRetries:` + fmt.Sprintf("%v", this.NumRetries) + `,`,
		`PerTryTimeout:` + fmt.Sprintf("%v", this.PerTryTimeout) + `,`,
		`RetriableStatusCodes:` + fmt.Sprintf("%v", this.RetriableStatusCodes) + `,`,
		`BackOff:` + strings.Replace(this.BackOff.String(), "RetryBackOff", "RetryBackOff", 1) + `,`,
		`RetryCondition:` + fmt.Sprintf("%v", this.RetryCondition) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MetricValue{`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`TrendValue:` + strings.Replace(this.TrendValue.String(), "TrendValue", "TrendValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricTypeData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForValues := "[]*MetricValue{"
	for _, f := range this.Values {
		repeatedStringForValues += strings.Replace(f.String(), "MetricValue", "MetricValue", 1) + ","
	}
	repeatedStringForValues += "}"
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&MetricTypeData{`,
		`Labels:` + mapStringForLabels + `,`,
		`Values:` + repeatedStringForValues + `,`,
		`}`,
	}, "")
	return s
}
func (this *TrendValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TrendValue{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Sentiment:` + fmt.Sprintf("%v", this.Sentiment) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`PreviousValue:` + fmt.Sprintf("%v", this.PreviousValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NextHopType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForInterface := "[]*ObjectRefType{"
	for _, f := range this.Interface {
		repeatedStringForInterface += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForInterface += "}"
	s := strings.Join([]string{`&NextHopType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`NexthopAddress:` + strings.Replace(fmt.Sprintf("%v", this.NexthopAddress), "IpAddressType", "IpAddressType", 1) + `,`,
		`Interface:` + repeatedStringForInterface + `,`,
		`}`,
	}, "")
	return s
}
func (this *StaticRouteType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSubnets := "[]*IpSubnetType{"
	for _, f := range this.Subnets {
		repeatedStringForSubnets += strings.Replace(fmt.Sprintf("%v", f), "IpSubnetType", "IpSubnetType", 1) + ","
	}
	repeatedStringForSubnets += "}"
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&StaticRouteType{`,
		`Attrs:` + fmt.Sprintf("%v", this.Attrs) + `,`,
		`Subnets:` + repeatedStringForSubnets + `,`,
		`Nexthop:` + strings.Replace(this.Nexthop.String(), "NextHopType", "NextHopType", 1) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`}`,
	}, "")
	return s
}
func (this *ForwardProxyConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ForwardProxyConfigType{`,
		`WhiteListedPrefixes:` + fmt.Sprintf("%v", this.WhiteListedPrefixes) + `,`,
		`WhiteListedPorts:` + fmt.Sprintf("%v", this.WhiteListedPorts) + `,`,
		`MaxConnectAttempts:` + fmt.Sprintf("%v", this.MaxConnectAttempts) + `,`,
		`ConnectionTimeout:` + fmt.Sprintf("%v", this.ConnectionTimeout) + `,`,
		`TlsInterceptionChoice:` + fmt.Sprintf("%v", this.TlsInterceptionChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ForwardProxyConfigType_NoInterception) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ForwardProxyConfigType_NoInterception{`,
		`NoInterception:` + strings.Replace(fmt.Sprintf("%v", this.NoInterception), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ForwardProxyConfigType_TlsIntercept) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ForwardProxyConfigType_TlsIntercept{`,
		`TlsIntercept:` + strings.Replace(fmt.Sprintf("%v", this.TlsIntercept), "TlsInterceptionType", "TlsInterceptionType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HostIdentifier) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HostIdentifier{`,
		`HostnameOrIp:` + fmt.Sprintf("%v", this.HostnameOrIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HostIdentifier_Ip) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HostIdentifier_Ip{`,
		`Ip:` + fmt.Sprintf("%v", this.Ip) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HostIdentifier_Hostname) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HostIdentifier_Hostname{`,
		`Hostname:` + fmt.Sprintf("%v", this.Hostname) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceIdentifier) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceIdentifier{`,
		`InterfaceChoice:` + fmt.Sprintf("%v", this.InterfaceChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceIdentifier_AnyIntf) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceIdentifier_AnyIntf{`,
		`AnyIntf:` + strings.Replace(fmt.Sprintf("%v", this.AnyIntf), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceIdentifier_Intf) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceIdentifier_Intf{`,
		`Intf:` + fmt.Sprintf("%v", this.Intf) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceOrNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceOrNetwork{`,
		`InterfaceChoice:` + fmt.Sprintf("%v", this.InterfaceChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceOrNetwork_Intf) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceOrNetwork_Intf{`,
		`Intf:` + fmt.Sprintf("%v", this.Intf) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceOrNetwork_Pod) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceOrNetwork_Pod{`,
		`Pod:` + fmt.Sprintf("%v", this.Pod) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceOrNetwork_VnType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceOrNetwork_VnType{`,
		`VnType:` + fmt.Sprintf("%v", this.VnType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceOrNetwork_Vn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceOrNetwork_Vn{`,
		`Vn:` + fmt.Sprintf("%v", this.Vn) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteTarget2ByteAsn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteTarget2ByteAsn{`,
		`AsNumber:` + fmt.Sprintf("%v", this.AsNumber) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteTarget4ByteAsn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteTarget4ByteAsn{`,
		`AsNumber:` + fmt.Sprintf("%v", this.AsNumber) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteTargetIPv4Addr) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteTargetIPv4Addr{`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteTarget) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteTarget{`,
		`RtargetChoice:` + fmt.Sprintf("%v", this.RtargetChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteTarget_Asn2ByteRtarget) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteTarget_Asn2ByteRtarget{`,
		`Asn2ByteRtarget:` + strings.Replace(fmt.Sprintf("%v", this.Asn2ByteRtarget), "RouteTarget2ByteAsn", "RouteTarget2ByteAsn", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteTarget_Ipv4AddrRtarget) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteTarget_Ipv4AddrRtarget{`,
		`Ipv4AddrRtarget:` + strings.Replace(fmt.Sprintf("%v", this.Ipv4AddrRtarget), "RouteTargetIPv4Addr", "RouteTargetIPv4Addr", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteTarget_Asn4ByteRtarget) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteTarget_Asn4ByteRtarget{`,
		`Asn4ByteRtarget:` + strings.Replace(fmt.Sprintf("%v", this.Asn4ByteRtarget), "RouteTarget4ByteAsn", "RouteTarget4ByteAsn", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortRangesType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortRangesType{`,
		`Ports:` + fmt.Sprintf("%v", this.Ports) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DomainNameList) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DomainNameList{`,
		`Domains:` + fmt.Sprintf("%v", this.Domains) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamespaceRoleType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NamespaceRoleType{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Role:` + fmt.Sprintf("%v", this.Role) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RoleListType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RoleListType{`,
		`Names:` + fmt.Sprintf("%v", this.Names) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamespaceAccessType) String() string {
	if this == nil {
		return "nil"
	}
	keysForNamespaceRoleMap := make([]string, 0, len(this.NamespaceRoleMap))
	for k, _ := range this.NamespaceRoleMap {
		keysForNamespaceRoleMap = append(keysForNamespaceRoleMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForNamespaceRoleMap)
	mapStringForNamespaceRoleMap := "map[string]*RoleListType{"
	for _, k := range keysForNamespaceRoleMap {
		mapStringForNamespaceRoleMap += fmt.Sprintf("%v: %v,", k, this.NamespaceRoleMap[k])
	}
	mapStringForNamespaceRoleMap += "}"
	s := strings.Join([]string{`&NamespaceAccessType{`,
		`NamespaceRoleMap:` + mapStringForNamespaceRoleMap + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteInfo) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSite := "[]*ObjectRefType{"
	for _, f := range this.Site {
		repeatedStringForSite += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForSite += "}"
	s := strings.Join([]string{`&SiteInfo{`,
		`Site:` + repeatedStringForSite + `,`,
		`Annotations:` + fmt.Sprintf("%v", this.Annotations) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteReferenceListType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRefs := "[]*ObjectRefType{"
	for _, f := range this.Refs {
		repeatedStringForRefs += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForRefs += "}"
	s := strings.Join([]string{`&SiteReferenceListType{`,
		`Refs:` + repeatedStringForRefs + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderTransformationType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderTransformationType{`,
		`HeaderTransformationChoice:` + fmt.Sprintf("%v", this.HeaderTransformationChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderTransformationType_DefaultHeaderTransformation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderTransformationType_DefaultHeaderTransformation{`,
		`DefaultHeaderTransformation:` + strings.Replace(fmt.Sprintf("%v", this.DefaultHeaderTransformation), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderTransformationType_ProperCaseHeaderTransformation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderTransformationType_ProperCaseHeaderTransformation{`,
		`ProperCaseHeaderTransformation:` + strings.Replace(fmt.Sprintf("%v", this.ProperCaseHeaderTransformation), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderTransformationType_PreserveCaseHeaderTransformation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderTransformationType_PreserveCaseHeaderTransformation{`,
		`PreserveCaseHeaderTransformation:` + strings.Replace(fmt.Sprintf("%v", this.PreserveCaseHeaderTransformation), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderTransformationType_LegacyHeaderTransformation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderTransformationType_LegacyHeaderTransformation{`,
		`LegacyHeaderTransformation:` + strings.Replace(fmt.Sprintf("%v", this.LegacyHeaderTransformation), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelCategoriesChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelCategoriesChoiceType{`,
		`FlowLabelChoice:` + fmt.Sprintf("%v", this.FlowLabelChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelCategoriesChoiceType_Authentication) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelCategoriesChoiceType_Authentication{`,
		`Authentication:` + strings.Replace(fmt.Sprintf("%v", this.Authentication), "BotDefenseFlowLabelAuthenticationChoiceType", "BotDefenseFlowLabelAuthenticationChoiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelCategoriesChoiceType_AccountManagement) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelCategoriesChoiceType_AccountManagement{`,
		`AccountManagement:` + strings.Replace(fmt.Sprintf("%v", this.AccountManagement), "BotDefenseFlowLabelAccountManagementChoiceType", "BotDefenseFlowLabelAccountManagementChoiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelCategoriesChoiceType_ProfileManagement) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelCategoriesChoiceType_ProfileManagement{`,
		`ProfileManagement:` + strings.Replace(fmt.Sprintf("%v", this.ProfileManagement), "BotDefenseFlowLabelProfileManagementChoiceType", "BotDefenseFlowLabelProfileManagementChoiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelCategoriesChoiceType_ShoppingGiftCards) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelCategoriesChoiceType_ShoppingGiftCards{`,
		`ShoppingGiftCards:` + strings.Replace(fmt.Sprintf("%v", this.ShoppingGiftCards), "BotDefenseFlowLabelShoppingGiftCardsChoiceType", "BotDefenseFlowLabelShoppingGiftCardsChoiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelCategoriesChoiceType_FinancialServices) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelCategoriesChoiceType_FinancialServices{`,
		`FinancialServices:` + strings.Replace(fmt.Sprintf("%v", this.FinancialServices), "BotDefenseFlowLabelFinancialServicesChoiceType", "BotDefenseFlowLabelFinancialServicesChoiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelCategoriesChoiceType_Search) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelCategoriesChoiceType_Search{`,
		`Search:` + strings.Replace(fmt.Sprintf("%v", this.Search), "BotDefenseFlowLabelSearchChoiceType", "BotDefenseFlowLabelSearchChoiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelCategoriesChoiceType_Flight) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelCategoriesChoiceType_Flight{`,
		`Flight:` + strings.Replace(fmt.Sprintf("%v", this.Flight), "BotDefenseFlowLabelFlightChoiceType", "BotDefenseFlowLabelFlightChoiceType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelAuthenticationChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelAuthenticationChoiceType{`,
		`LabelChoice:` + fmt.Sprintf("%v", this.LabelChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelAuthenticationChoiceType_Login) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelAuthenticationChoiceType_Login{`,
		`Login:` + strings.Replace(fmt.Sprintf("%v", this.Login), "BotDefenseTransactionResult", "BotDefenseTransactionResult", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelAuthenticationChoiceType_LoginMfa) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelAuthenticationChoiceType_LoginMfa{`,
		`LoginMfa:` + strings.Replace(fmt.Sprintf("%v", this.LoginMfa), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelAuthenticationChoiceType_LoginPartner) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelAuthenticationChoiceType_LoginPartner{`,
		`LoginPartner:` + strings.Replace(fmt.Sprintf("%v", this.LoginPartner), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelAuthenticationChoiceType_Logout) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelAuthenticationChoiceType_Logout{`,
		`Logout:` + strings.Replace(fmt.Sprintf("%v", this.Logout), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelAuthenticationChoiceType_TokenRefresh) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelAuthenticationChoiceType_TokenRefresh{`,
		`TokenRefresh:` + strings.Replace(fmt.Sprintf("%v", this.TokenRefresh), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseTransactionResult) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseTransactionResult{`,
		`TransactionResultChoice:` + fmt.Sprintf("%v", this.TransactionResultChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseTransactionResult_DisableTransactionResult) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseTransactionResult_DisableTransactionResult{`,
		`DisableTransactionResult:` + strings.Replace(fmt.Sprintf("%v", this.DisableTransactionResult), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseTransactionResult_TransactionResult) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseTransactionResult_TransactionResult{`,
		`TransactionResult:` + strings.Replace(fmt.Sprintf("%v", this.TransactionResult), "BotDefenseTransactionResultType", "BotDefenseTransactionResultType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseTransactionResultType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSuccessConditions := "[]*BotDefenseTransactionResultCondition{"
	for _, f := range this.SuccessConditions {
		repeatedStringForSuccessConditions += strings.Replace(f.String(), "BotDefenseTransactionResultCondition", "BotDefenseTransactionResultCondition", 1) + ","
	}
	repeatedStringForSuccessConditions += "}"
	repeatedStringForFailureConditions := "[]*BotDefenseTransactionResultCondition{"
	for _, f := range this.FailureConditions {
		repeatedStringForFailureConditions += strings.Replace(f.String(), "BotDefenseTransactionResultCondition", "BotDefenseTransactionResultCondition", 1) + ","
	}
	repeatedStringForFailureConditions += "}"
	s := strings.Join([]string{`&BotDefenseTransactionResultType{`,
		`SuccessConditions:` + repeatedStringForSuccessConditions + `,`,
		`FailureConditions:` + repeatedStringForFailureConditions + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseTransactionResultCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseTransactionResultCondition{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`RegexValues:` + fmt.Sprintf("%v", this.RegexValues) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelAccountManagementChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelAccountManagementChoiceType{`,
		`LabelChoice:` + fmt.Sprintf("%v", this.LabelChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelAccountManagementChoiceType_Create) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelAccountManagementChoiceType_Create{`,
		`Create:` + strings.Replace(fmt.Sprintf("%v", this.Create), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelAccountManagementChoiceType_PasswordReset) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelAccountManagementChoiceType_PasswordReset{`,
		`PasswordReset:` + strings.Replace(fmt.Sprintf("%v", this.PasswordReset), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelProfileManagementChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelProfileManagementChoiceType{`,
		`LabelChoice:` + fmt.Sprintf("%v", this.LabelChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelProfileManagementChoiceType_Create) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelProfileManagementChoiceType_Create{`,
		`Create:` + strings.Replace(fmt.Sprintf("%v", this.Create), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelProfileManagementChoiceType_Update) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelProfileManagementChoiceType_Update{`,
		`Update:` + strings.Replace(fmt.Sprintf("%v", this.Update), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelProfileManagementChoiceType_View) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelProfileManagementChoiceType_View{`,
		`View:` + strings.Replace(fmt.Sprintf("%v", this.View), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelShoppingGiftCardsChoiceType{`,
		`LabelChoice:` + fmt.Sprintf("%v", this.LabelChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopAddToCart) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopAddToCart{`,
		`ShopAddToCart:` + strings.Replace(fmt.Sprintf("%v", this.ShopAddToCart), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPromoCodeValidation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPromoCodeValidation{`,
		`ShopPromoCodeValidation:` + strings.Replace(fmt.Sprintf("%v", this.ShopPromoCodeValidation), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopCheckout) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopCheckout{`,
		`ShopCheckout:` + strings.Replace(fmt.Sprintf("%v", this.ShopCheckout), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopMakePayment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopMakePayment{`,
		`ShopMakePayment:` + strings.Replace(fmt.Sprintf("%v", this.ShopMakePayment), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopOrder) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopOrder{`,
		`ShopOrder:` + strings.Replace(fmt.Sprintf("%v", this.ShopOrder), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPriceInquiry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPriceInquiry{`,
		`ShopPriceInquiry:` + strings.Replace(fmt.Sprintf("%v", this.ShopPriceInquiry), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPurchaseGiftCard) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPurchaseGiftCard{`,
		`ShopPurchaseGiftCard:` + strings.Replace(fmt.Sprintf("%v", this.ShopPurchaseGiftCard), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopUpdateQuantity) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopUpdateQuantity{`,
		`ShopUpdateQuantity:` + strings.Replace(fmt.Sprintf("%v", this.ShopUpdateQuantity), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopChooseSeat) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopChooseSeat{`,
		`ShopChooseSeat:` + strings.Replace(fmt.Sprintf("%v", this.ShopChooseSeat), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopEnterDrawingSubmission) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopEnterDrawingSubmission{`,
		`ShopEnterDrawingSubmission:` + strings.Replace(fmt.Sprintf("%v", this.ShopEnterDrawingSubmission), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardValidation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardValidation{`,
		`GiftCardValidation:` + strings.Replace(fmt.Sprintf("%v", this.GiftCardValidation), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardMakePurchaseWithGiftCard) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardMakePurchaseWithGiftCard{`,
		`GiftCardMakePurchaseWithGiftCard:` + strings.Replace(fmt.Sprintf("%v", this.GiftCardMakePurchaseWithGiftCard), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelFinancialServicesChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelFinancialServicesChoiceType{`,
		`LabelChoice:` + fmt.Sprintf("%v", this.LabelChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelFinancialServicesChoiceType_Apply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelFinancialServicesChoiceType_Apply{`,
		`Apply:` + strings.Replace(fmt.Sprintf("%v", this.Apply), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelFinancialServicesChoiceType_MoneyTransfer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelFinancialServicesChoiceType_MoneyTransfer{`,
		`MoneyTransfer:` + strings.Replace(fmt.Sprintf("%v", this.MoneyTransfer), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelSearchChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelSearchChoiceType{`,
		`LabelChoice:` + fmt.Sprintf("%v", this.LabelChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelSearchChoiceType_FlightSearch) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelSearchChoiceType_FlightSearch{`,
		`FlightSearch:` + strings.Replace(fmt.Sprintf("%v", this.FlightSearch), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelSearchChoiceType_ProductSearch) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelSearchChoiceType_ProductSearch{`,
		`ProductSearch:` + strings.Replace(fmt.Sprintf("%v", this.ProductSearch), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelSearchChoiceType_RoomSearch) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelSearchChoiceType_RoomSearch{`,
		`RoomSearch:` + strings.Replace(fmt.Sprintf("%v", this.RoomSearch), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelSearchChoiceType_ReservationSearch) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelSearchChoiceType_ReservationSearch{`,
		`ReservationSearch:` + strings.Replace(fmt.Sprintf("%v", this.ReservationSearch), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelFlightChoiceType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelFlightChoiceType{`,
		`LabelChoice:` + fmt.Sprintf("%v", this.LabelChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BotDefenseFlowLabelFlightChoiceType_Checkin) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BotDefenseFlowLabelFlightChoiceType_Checkin{`,
		`Checkin:` + strings.Replace(fmt.Sprintf("%v", this.Checkin), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkingStackType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkingStackType{`,
		`Choice:` + fmt.Sprintf("%v", this.Choice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkingStackType_Ipv4) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkingStackType_Ipv4{`,
		`Ipv4:` + strings.Replace(fmt.Sprintf("%v", this.Ipv4), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkingStackType_Ipv6) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkingStackType_Ipv6{`,
		`Ipv6:` + strings.Replace(fmt.Sprintf("%v", this.Ipv6), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkingStackType_Dual) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkingStackType_Dual{`,
		`Dual:` + strings.Replace(fmt.Sprintf("%v", this.Dual), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DateRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DateRange{`,
		`StartDate:` + strings.Replace(fmt.Sprintf("%v", this.StartDate), "Timestamp", "types.Timestamp", 1) + `,`,
		`EndDate:` + strings.Replace(fmt.Sprintf("%v", this.EndDate), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *File) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&File{`,
		`ContentType:` + fmt.Sprintf("%v", this.ContentType) + `,`,
		`Content:` + fmt.Sprintf("%v", this.Content) + `,`,
		`FileId:` + fmt.Sprintf("%v", this.FileId) + `,`,
		`StorageProvider:` + fmt.Sprintf("%v", this.StorageProvider) + `,`,
		`}`,
	}, "")
	return s
}
func (this *File_AwsS3) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&File_AwsS3{`,
		`AwsS3:` + strings.Replace(fmt.Sprintf("%v", this.AwsS3), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseMeta) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResponseMeta{`,
		`ErrorCode:` + fmt.Sprintf("%v", this.ErrorCode) + `,`,
		`DisplayMessage:` + fmt.Sprintf("%v", this.DisplayMessage) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Action) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Action{`,
		`ActionChoice:` + fmt.Sprintf("%v", this.ActionChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Action_Block) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Action_Block{`,
		`Block:` + strings.Replace(fmt.Sprintf("%v", this.Block), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Action_Report) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Action_Report{`,
		`Report:` + strings.Replace(fmt.Sprintf("%v", this.Report), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CRMInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CRMInfo{`,
		`AccountId:` + fmt.Sprintf("%v", this.AccountId) + `,`,
		`EntitlementId:` + fmt.Sprintf("%v", this.EntitlementId) + `,`,
		`SubscriptionId:` + fmt.Sprintf("%v", this.SubscriptionId) + `,`,
		`OrderType:` + fmt.Sprintf("%v", this.OrderType) + `,`,
		`EntitledSkus:` + fmt.Sprintf("%v", this.EntitledSkus) + `,`,
		`CustomerIdentifier:` + fmt.Sprintf("%v", this.CustomerIdentifier) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RegexMatchRewrite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RegexMatchRewrite{`,
		`Pattern:` + fmt.Sprintf("%v", this.Pattern) + `,`,
		`Substitution:` + fmt.Sprintf("%v", this.Substitution) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelSelectorType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelSelectorType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelSelectorType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expressions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expressions = append(m.Expressions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConditionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConditionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConditionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastUpdateTime == nil {
				m.LastUpdateTime = &types.Timestamp{}
			}
			if err := m.LastUpdateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitializerType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitializerType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitializerType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitializersType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitializersType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitializersType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pending", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pending = append(m.Pending, &InitializerType{})
			if err := m.Pending[len(m.Pending)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &StatusType{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTimestamp == nil {
				m.CreationTimestamp = &types.Timestamp{}
			}
			if err := m.CreationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publish", wireType)
			}
			m.Publish = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Publish |= StatusPublishType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VtrpId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VtrpId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VtrpStale", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VtrpStale = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectGetMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectGetMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectGetMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectCreateMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectCreateMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectCreateMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectReplaceMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectReplaceMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectReplaceMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubeRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubeRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubeRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemObjectMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SystemObjectMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SystemObjectMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTimestamp == nil {
				m.CreationTimestamp = &types.Timestamp{}
			}
			if err := m.CreationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeletionTimestamp == nil {
				m.DeletionTimestamp = &types.Timestamp{}
			}
			if err := m.DeletionTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModificationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModificationTimestamp == nil {
				m.ModificationTimestamp = &types.Timestamp{}
			}
			if err := m.ModificationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Initializers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Initializers == nil {
				m.Initializers = &InitializersType{}
			}
			if err := m.Initializers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finalizers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Finalizers = append(m.Finalizers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraceInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectIndex", wireType)
			}
			m.ObjectIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = append(m.Namespace, &ObjectRefType{})
			if err := m.Namespace[len(m.Namespace)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerView", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnerView == nil {
				m.OwnerView = &ViewRefType{}
			}
			if err := m.OwnerView.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SreDisable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SreDisable = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VtrpId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VtrpId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VtrpStale", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VtrpStale = bool(v != 0)
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemObjectGetMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SystemObjectGetMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SystemObjectGetMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTimestamp == nil {
				m.CreationTimestamp = &types.Timestamp{}
			}
			if err := m.CreationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeletionTimestamp == nil {
				m.DeletionTimestamp = &types.Timestamp{}
			}
			if err := m.DeletionTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModificationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModificationTimestamp == nil {
				m.ModificationTimestamp = &types.Timestamp{}
			}
			if err := m.ModificationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Initializers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Initializers == nil {
				m.Initializers = &InitializersType{}
			}
			if err := m.Initializers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finalizers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Finalizers = append(m.Finalizers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectIndex", wireType)
			}
			m.ObjectIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerView", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnerView == nil {
				m.OwnerView = &ViewRefType{}
			}
			if err := m.OwnerView.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthnTypeBasicAuth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthnTypeBasicAuth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthnTypeBasicAuth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Password == nil {
				m.Password = &SecretType{}
			}
			if err := m.Password.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthnTypeHeaders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthnTypeHeaders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthnTypeHeaders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Headers == nil {
				m.Headers = make(map[string]*SecretType)
			}
			var mapkey string
			var mapvalue *SecretType
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SecretType{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Headers[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthnTypeQueryParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthnTypeQueryParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthnTypeQueryParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QueryParams == nil {
				m.QueryParams = make(map[string]*SecretType)
			}
			var mapkey string
			var mapvalue *SecretType
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SecretType{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.QueryParams[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlindfoldSecretInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlindfoldSecretInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlindfoldSecretInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecryptionProvider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DecryptionProvider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreProvider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreProvider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VaultSecretInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VaultSecretInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VaultSecretInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretEncoding", wireType)
			}
			m.SecretEncoding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecretEncoding |= SecretEncodingType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearSecretInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearSecretInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearSecretInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WingmanSecretInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WingmanSecretInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WingmanSecretInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlindfoldSecretInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlindfoldSecretInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SecretInfoOneof = &SecretType_BlindfoldSecretInfo{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultSecretInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VaultSecretInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SecretInfoOneof = &SecretType_VaultSecretInfo{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearSecretInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClearSecretInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SecretInfoOneof = &SecretType_ClearSecretInfo{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WingmanSecretInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WingmanSecretInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SecretInfoOneof = &SecretType_WingmanSecretInfo{v}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretEncodingType", wireType)
			}
			m.SecretEncodingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecretEncodingType |= SecretEncodingType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlindfoldSecretInfoInternal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlindfoldSecretInfoInternal == nil {
				m.BlindfoldSecretInfoInternal = &BlindfoldSecretInfoType{}
			}
			if err := m.BlindfoldSecretInfoInternal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = append(m.Ref, &ObjectRefType{})
			if err := m.Ref[len(m.Ref)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = append(m.Ref, &ObjectRefType{})
			if err := m.Ref[len(m.Ref)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkType", wireType)
			}
			m.NetworkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkType |= VirtualNetworkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableInternetVip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InternetVipChoice = &SiteRefType_EnableInternetVip{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableInternetVip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InternetVipChoice = &SiteRefType_DisableInternetVip{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Refs = append(m.Refs, &ObjectRefType{})
			if err := m.Refs[len(m.Refs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpPrefixSetRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpPrefixSetRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpPrefixSetRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = append(m.Ref, &ObjectRefType{})
			if err := m.Ref[len(m.Ref)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSiteRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSiteRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSiteRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = append(m.Ref, &ObjectRefType{})
			if err := m.Ref[len(m.Ref)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkType", wireType)
			}
			m.NetworkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkType |= VirtualNetworkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableInternetVip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InternetVipChoice = &VSiteRefType_EnableInternetVip{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableInternetVip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InternetVipChoice = &VSiteRefType_DisableInternetVip{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Refs = append(m.Refs, &ObjectRefType{})
			if err := m.Refs[len(m.Refs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = append(m.Ref, &ObjectRefType{})
			if err := m.Ref[len(m.Ref)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolPolicerRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolPolicerRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolPolicerRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = append(m.Ref, &ObjectRefType{})
			if err := m.Ref[len(m.Ref)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkSiteRefSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkSiteRefSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkSiteRefSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NetworkRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RefOrSelector = &NetworkSiteRefSelector_VirtualNetwork{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SiteRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RefOrSelector = &NetworkSiteRefSelector_Site{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VSiteRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RefOrSelector = &NetworkSiteRefSelector_VirtualSite{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteVirtualSiteRefSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteVirtualSiteRefSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteVirtualSiteRefSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SiteRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RefOrSelector = &SiteVirtualSiteRefSelector_Site{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VSiteRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RefOrSelector = &SiteVirtualSiteRefSelector_VirtualSite{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderManipulationOptionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderManipulationOptionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderManipulationOptionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueChoice = &HeaderManipulationOptionType_Value{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Append", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Append = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SecretType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ValueChoice = &HeaderManipulationOptionType_SecretValue{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CookieManipulationOptionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CookieManipulationOptionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CookieManipulationOptionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SamesiteStrict", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Samesite = &CookieManipulationOptionType_SamesiteStrict{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SamesiteLax", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Samesite = &CookieManipulationOptionType_SamesiteLax{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SamesiteNone", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Samesite = &CookieManipulationOptionType_SamesiteNone{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreSecure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Secure = &CookieManipulationOptionType_IgnoreSecure{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddSecure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Secure = &CookieManipulationOptionType_AddSecure{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreHttponly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Httponly = &CookieManipulationOptionType_IgnoreHttponly{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddHttponly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Httponly = &CookieManipulationOptionType_AddHttponly{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreMaxAge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.MaxAge = &CookieManipulationOptionType_IgnoreMaxAge{v}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAgeValue", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxAge = &CookieManipulationOptionType_MaxAgeValue{v}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreSamesite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Samesite = &CookieManipulationOptionType_IgnoreSamesite{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableTamperingProtection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CookieTampering = &CookieManipulationOptionType_DisableTamperingProtection{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableTamperingProtection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CookieTampering = &CookieManipulationOptionType_EnableTamperingProtection{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrustedCAList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrustedCAList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrustedCAList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCaList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedCaList = append(m.TrustedCaList, &ObjectRefType{})
			if err := m.TrustedCaList[len(m.TrustedCaList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsValidationParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsValidationParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsValidationParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedCaChoice = &TlsValidationParamsType_TrustedCaUrl{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipHostnameVerification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipHostnameVerification = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifySubjectAltNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifySubjectAltNames = append(m.VerifySubjectAltNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseVolterraTrustedCaUrl", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseVolterraTrustedCaUrl = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCa", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TrustedCAList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TrustedCaChoice = &TlsValidationParamsType_TrustedCa{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HashAlgorithms) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HashAlgorithms: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HashAlgorithms: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v HashAlgorithm
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= HashAlgorithm(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.HashAlgorithms = append(m.HashAlgorithms, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.HashAlgorithms) == 0 {
					m.HashAlgorithms = make([]HashAlgorithm, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v HashAlgorithm
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= HashAlgorithm(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.HashAlgorithms = append(m.HashAlgorithms, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field HashAlgorithms", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsCertificateType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsCertificateType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsCertificateType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertificateUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrivateKey == nil {
				m.PrivateKey = &SecretType{}
			}
			if err := m.PrivateKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseSystemDefaults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OcspStaplingChoice = &TlsCertificateType_UseSystemDefaults{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableOcspStapling", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OcspStaplingChoice = &TlsCertificateType_DisableOcspStapling{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomHashAlgorithms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HashAlgorithms{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.OcspStaplingChoice = &TlsCertificateType_CustomHashAlgorithms{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DomainType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DomainType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DomainType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainChoice = &DomainType_ExactValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuffixValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainChoice = &DomainType_SuffixValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegexValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainChoice = &DomainType_RegexValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4DestType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4DestType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4DestType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefixes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefixes = append(m.Prefixes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortRanges = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsInterceptionRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsInterceptionRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsInterceptionRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DomainMatch == nil {
				m.DomainMatch = &DomainType{}
			}
			if err := m.DomainMatch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableInterception", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EnableDisableChoice = &TlsInterceptionRule_DisableInterception{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableInterception", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EnableDisableChoice = &TlsInterceptionRule_EnableInterception{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsInterceptionPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsInterceptionPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsInterceptionPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterceptionRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterceptionRules = append(m.InterceptionRules, &TlsInterceptionRule{})
			if err := m.InterceptionRules[len(m.InterceptionRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsInterceptionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsInterceptionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsInterceptionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TlsInterceptionPolicy{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterceptionPolicyChoice = &TlsInterceptionType_Policy{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomCertificate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TlsCertificateType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SigningCertChoice = &TlsInterceptionType_CustomCertificate{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraCertificate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SigningCertChoice = &TlsInterceptionType_VolterraCertificate{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedCaChoice = &TlsInterceptionType_TrustedCaUrl{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraTrustedCa", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TrustedCaChoice = &TlsInterceptionType_VolterraTrustedCa{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableForAllDomains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterceptionPolicyChoice = &TlsInterceptionType_EnableForAllDomains{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FractionalPercent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FractionalPercent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FractionalPercent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Numerator", wireType)
			}
			m.Numerator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Numerator |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denominator", wireType)
			}
			m.Denominator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Denominator |= DenominatorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufferConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufferConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufferConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestBytes", wireType)
			}
			m.MaxRequestBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRequestBytes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestTime", wireType)
			}
			m.MaxRequestTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRequestTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CorsPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CorsPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CorsPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOrigin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowOrigin = append(m.AllowOrigin, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOriginRegex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowOriginRegex = append(m.AllowOriginRegex, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowMethods", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowMethods = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowHeaders", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowHeaders = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExposeHeaders", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExposeHeaders = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxAge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowCredentials", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowCredentials = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumAge", wireType)
			}
			m.MaximumAge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumAge |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CsrfPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CsrfPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CsrfPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllLoadBalancerDomains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AllowedDomains = &CsrfPolicy_AllLoadBalancerDomains{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomDomainList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DomainNameList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AllowedDomains = &CsrfPolicy_CustomDomainList{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AllowedDomains = &CsrfPolicy_Disabled{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathMatch = &PathMatcherType_Prefix{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathMatch = &PathMatcherType_Path{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathMatch = &PathMatcherType_Regex{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PortMatch = &PortMatcherType_Port{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortMatch = &PortMatcherType_PortRanges{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoPortMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PortMatch = &PortMatcherType_NoPortMatch{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exact", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueMatch = &HeaderMatcherType_Exact{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueMatch = &HeaderMatcherType_Regex{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Presence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ValueMatch = &HeaderMatcherType_Presence{b}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatch = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryParameterMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParameterMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParameterMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exact", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueMatch = &QueryParameterMatcherType_Exact{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueMatch = &QueryParameterMatcherType_Regex{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &PathMatcherType{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &HeaderMatcherType{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParams = append(m.QueryParams, &QueryParameterMatcherType{})
			if err := m.QueryParams[len(m.QueryParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpMethod", wireType)
			}
			m.HttpMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HttpMethod |= HttpMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncomingPort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IncomingPort == nil {
				m.IncomingPort = &PortMatcherType{}
			}
			if err := m.IncomingPort.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppFirewallRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppFirewallRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppFirewallRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppFirewall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppFirewall = append(m.AppFirewall, &ObjectRefType{})
			if err := m.AppFirewall[len(m.AppFirewall)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WafType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WafType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WafType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppFirewall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppFirewallRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RefType = &WafType_AppFirewall{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableWaf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RefType = &WafType_DisableWaf{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InheritWaf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RefType = &WafType_InheritWaf{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppRoleAuthInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppRoleAuthInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppRoleAuthInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecretId == nil {
				m.SecretId = &SecretType{}
			}
			if err := m.SecretId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VaultAuthInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VaultAuthInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VaultAuthInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppRoleAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppRoleAuthInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthParams = &VaultAuthInfoType_AppRoleAuth{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SecretType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthParams = &VaultAuthInfoType_Token{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestAuthInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestAuthInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestAuthInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasicAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AuthnTypeBasicAuth{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthParams = &RestAuthInfoType_BasicAuth{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadersAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AuthnTypeHeaders{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthParams = &RestAuthInfoType_HeadersAuth{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParamsAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AuthnTypeQueryParams{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthParams = &RestAuthInfoType_QueryParamsAuth{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VaultAccessInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VaultAccessInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VaultAccessInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultCaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultCaUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppRoleAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppRoleAuthInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthnChoice = &VaultAccessInfoType_AppRoleAuth{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SecretType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthnChoice = &VaultAccessInfoType_Token{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VaultSecretType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VaultSecretType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VaultSecretType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAccessInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VaultAccessInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AccessChoice = &VaultSecretType_VaultAccessInfo{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessChoice = &VaultSecretType_ProviderName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretSubPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretSubPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolterraSecretType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolterraSecretType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolterraSecretType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlindfoldSecretInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlindfoldSecretInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SecretTypeChoice = &VolterraSecretType_BlindfoldSecretInfo{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultSecretInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VaultAccessInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SecretTypeChoice = &VolterraSecretType_VaultSecretInfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortValueType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortValueType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortValueType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PortValueTypeChoice = &PortValueType_All{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserDefined", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PortValueTypeChoice = &PortValueType_UserDefined{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PortValueTypeChoice = &PortValueType_Dns{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualNetworkReferenceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualNetworkReferenceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualNetworkReferenceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Refs = append(m.Refs, &ObjectRefType{})
			if err := m.Refs[len(m.Refs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualNetworkSelectorType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualNetworkSelectorType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualNetworkSelectorType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteLocal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VnTypeChoice = &VirtualNetworkSelectorType_SiteLocal{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteLocalInside", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VnTypeChoice = &VirtualNetworkSelectorType_SiteLocalInside{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Public", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VnTypeChoice = &VirtualNetworkSelectorType_Public{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetryBackOff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetryBackOff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetryBackOff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseInterval", wireType)
			}
			m.BaseInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseInterval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxInterval", wireType)
			}
			m.MaxInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxInterval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetryPolicyType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetryPolicyType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetryPolicyType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryOn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetryOn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRetries", wireType)
			}
			m.NumRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRetries |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerTryTimeout", wireType)
			}
			m.PerTryTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerTryTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RetriableStatusCodes = append(m.RetriableStatusCodes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RetriableStatusCodes) == 0 {
					m.RetriableStatusCodes = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RetriableStatusCodes = append(m.RetriableStatusCodes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RetriableStatusCodes", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackOff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BackOff == nil {
				m.BackOff = &RetryBackOff{}
			}
			if err := m.BackOff.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryCondition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetryCondition = append(m.RetryCondition, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Timestamp = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrendValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrendValue == nil {
				m.TrendValue = &TrendValue{}
			}
			if err := m.TrendValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricTypeData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricTypeData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricTypeData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &MetricValue{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrendValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrendValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrendValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sentiment", wireType)
			}
			m.Sentiment = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sentiment |= TrendSentiment(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NextHopType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NextHopType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NextHopType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NextHopTypes(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NexthopAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NexthopAddress == nil {
				m.NexthopAddress = &IpAddressType{}
			}
			if err := m.NexthopAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interface = append(m.Interface, &ObjectRefType{})
			if err := m.Interface[len(m.Interface)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaticRouteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaticRouteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaticRouteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v RouteAttrType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= RouteAttrType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Attrs = append(m.Attrs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Attrs) == 0 {
					m.Attrs = make([]RouteAttrType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v RouteAttrType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= RouteAttrType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Attrs = append(m.Attrs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnets = append(m.Subnets, &IpSubnetType{})
			if err := m.Subnets[len(m.Subnets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nexthop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nexthop == nil {
				m.Nexthop = &NextHopType{}
			}
			if err := m.Nexthop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForwardProxyConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForwardProxyConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForwardProxyConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WhiteListedPrefixes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WhiteListedPrefixes = append(m.WhiteListedPrefixes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WhiteListedPorts = append(m.WhiteListedPorts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.WhiteListedPorts) == 0 {
					m.WhiteListedPorts = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WhiteListedPorts = append(m.WhiteListedPorts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WhiteListedPorts", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxConnectAttempts", wireType)
			}
			m.MaxConnectAttempts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxConnectAttempts |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionTimeout", wireType)
			}
			m.ConnectionTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectionTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoInterception", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TlsInterceptionChoice = &ForwardProxyConfigType_NoInterception{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsIntercept", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TlsInterceptionType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TlsInterceptionChoice = &ForwardProxyConfigType_TlsIntercept{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostIdentifier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostIdentifier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostIdentifier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostnameOrIp = &HostIdentifier_Ip{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostnameOrIp = &HostIdentifier_Hostname{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceIdentifier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceIdentifier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceIdentifier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyIntf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &InterfaceIdentifier_AnyIntf{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceChoice = &InterfaceIdentifier_Intf{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceOrNetwork) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceOrNetwork: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceOrNetwork: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceChoice = &InterfaceOrNetwork_Intf{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceChoice = &InterfaceOrNetwork_Pod{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnType", wireType)
			}
			var v VirtualNetworkType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= VirtualNetworkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InterfaceChoice = &InterfaceOrNetwork_VnType{v}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceChoice = &InterfaceOrNetwork_Vn{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTarget2ByteAsn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTarget2ByteAsn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTarget2ByteAsn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsNumber", wireType)
			}
			m.AsNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AsNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTarget4ByteAsn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTarget4ByteAsn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTarget4ByteAsn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsNumber", wireType)
			}
			m.AsNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AsNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTargetIPv4Addr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTargetIPv4Addr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTargetIPv4Addr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asn2ByteRtarget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteTarget2ByteAsn{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RtargetChoice = &RouteTarget_Asn2ByteRtarget{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4AddrRtarget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteTargetIPv4Addr{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RtargetChoice = &RouteTarget_Ipv4AddrRtarget{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asn4ByteRtarget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteTarget4ByteAsn{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RtargetChoice = &RouteTarget_Asn4ByteRtarget{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortRangesType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortRangesType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortRangesType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DomainNameList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DomainNameList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DomainNameList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespaceRoleType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespaceRoleType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespaceRoleType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespaceAccessType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespaceAccessType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespaceAccessType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceRoleMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NamespaceRoleMap == nil {
				m.NamespaceRoleMap = make(map[string]*RoleListType)
			}
			var mapkey string
			var mapvalue *RoleListType
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RoleListType{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NamespaceRoleMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = append(m.Site, &ObjectRefType{})
			if err := m.Site[len(m.Site)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Annotations = append(m.Annotations, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteReferenceListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteReferenceListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteReferenceListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Refs = append(m.Refs, &ObjectRefType{})
			if err := m.Refs[len(m.Refs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderTransformationType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderTransformationType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderTransformationType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultHeaderTransformation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HeaderTransformationChoice = &HeaderTransformationType_DefaultHeaderTransformation{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProperCaseHeaderTransformation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HeaderTransformationChoice = &HeaderTransformationType_ProperCaseHeaderTransformation{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreserveCaseHeaderTransformation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HeaderTransformationChoice = &HeaderTransformationType_PreserveCaseHeaderTransformation{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LegacyHeaderTransformation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.HeaderTransformationChoice = &HeaderTransformationType_LegacyHeaderTransformation{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BotDefenseFlowLabelCategoriesChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BotDefenseFlowLabelCategoriesChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BotDefenseFlowLabelCategoriesChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authentication", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BotDefenseFlowLabelAuthenticationChoiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FlowLabelChoice = &BotDefenseFlowLabelCategoriesChoiceType_Authentication{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountManagement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BotDefenseFlowLabelAccountManagementChoiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FlowLabelChoice = &BotDefenseFlowLabelCategoriesChoiceType_AccountManagement{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileManagement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BotDefenseFlowLabelProfileManagementChoiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FlowLabelChoice = &BotDefenseFlowLabelCategoriesChoiceType_ProfileManagement{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShoppingGiftCards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BotDefenseFlowLabelShoppingGiftCardsChoiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FlowLabelChoice = &BotDefenseFlowLabelCategoriesChoiceType_ShoppingGiftCards{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinancialServices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BotDefenseFlowLabelFinancialServicesChoiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FlowLabelChoice = &BotDefenseFlowLabelCategoriesChoiceType_FinancialServices{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Search", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BotDefenseFlowLabelSearchChoiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FlowLabelChoice = &BotDefenseFlowLabelCategoriesChoiceType_Search{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BotDefenseFlowLabelFlightChoiceType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FlowLabelChoice = &BotDefenseFlowLabelCategoriesChoiceType_Flight{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BotDefenseFlowLabelAuthenticationChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BotDefenseFlowLabelAuthenticationChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BotDefenseFlowLabelAuthenticationChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BotDefenseTransactionResult{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelAuthenticationChoiceType_Login{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginMfa", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelAuthenticationChoiceType_LoginMfa{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginPartner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelAuthenticationChoiceType_LoginPartner{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelAuthenticationChoiceType_Logout{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenRefresh", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelAuthenticationChoiceType_TokenRefresh{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BotDefenseTransactionResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BotDefenseTransactionResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BotDefenseTransactionResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableTransactionResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TransactionResultChoice = &BotDefenseTransactionResult_DisableTransactionResult{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BotDefenseTransactionResultType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TransactionResultChoice = &BotDefenseTransactionResult_TransactionResult{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BotDefenseTransactionResultType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BotDefenseTransactionResultType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BotDefenseTransactionResultType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessConditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SuccessConditions = append(m.SuccessConditions, &BotDefenseTransactionResultCondition{})
			if err := m.SuccessConditions[len(m.SuccessConditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureConditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailureConditions = append(m.FailureConditions, &BotDefenseTransactionResultCondition{})
			if err := m.FailureConditions[len(m.FailureConditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BotDefenseTransactionResultCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BotDefenseTransactionResultCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BotDefenseTransactionResultCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegexValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegexValues = append(m.RegexValues, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= HttpStatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BotDefenseFlowLabelAccountManagementChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BotDefenseFlowLabelAccountManagementChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BotDefenseFlowLabelAccountManagementChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Create", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelAccountManagementChoiceType_Create{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PasswordReset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelAccountManagementChoiceType_PasswordReset{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BotDefenseFlowLabelProfileManagementChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BotDefenseFlowLabelProfileManagementChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BotDefenseFlowLabelProfileManagementChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Create", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelProfileManagementChoiceType_Create{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelProfileManagementChoiceType_Update{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelProfileManagementChoiceType_View{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BotDefenseFlowLabelShoppingGiftCardsChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BotDefenseFlowLabelShoppingGiftCardsChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BotDefenseFlowLabelShoppingGiftCardsChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopAddToCart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopAddToCart{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopPromoCodeValidation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPromoCodeValidation{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopCheckout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopCheckout{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopMakePayment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopMakePayment{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopOrder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopOrder{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopPriceInquiry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPriceInquiry{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopPurchaseGiftCard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopPurchaseGiftCard{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopUpdateQuantity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopUpdateQuantity{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopChooseSeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopChooseSeat{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopEnterDrawingSubmission", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelShoppingGiftCardsChoiceType_ShopEnterDrawingSubmission{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftCardValidation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardValidation{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftCardMakePurchaseWithGiftCard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelShoppingGiftCardsChoiceType_GiftCardMakePurchaseWithGiftCard{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BotDefenseFlowLabelFinancialServicesChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BotDefenseFlowLabelFinancialServicesChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BotDefenseFlowLabelFinancialServicesChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Apply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelFinancialServicesChoiceType_Apply{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoneyTransfer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelFinancialServicesChoiceType_MoneyTransfer{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BotDefenseFlowLabelSearchChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BotDefenseFlowLabelSearchChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BotDefenseFlowLabelSearchChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlightSearch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelSearchChoiceType_FlightSearch{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductSearch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelSearchChoiceType_ProductSearch{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomSearch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelSearchChoiceType_RoomSearch{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservationSearch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelSearchChoiceType_ReservationSearch{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BotDefenseFlowLabelFlightChoiceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BotDefenseFlowLabelFlightChoiceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BotDefenseFlowLabelFlightChoiceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checkin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.LabelChoice = &BotDefenseFlowLabelFlightChoiceType_Checkin{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkingStackType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkingStackType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkingStackType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &NetworkingStackType_Ipv4{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &NetworkingStackType_Ipv6{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dual", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &NetworkingStackType_Dual{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DateRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DateRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DateRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartDate == nil {
				m.StartDate = &types.Timestamp{}
			}
			if err := m.StartDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndDate == nil {
				m.EndDate = &types.Timestamp{}
			}
			if err := m.EndDate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *File) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsS3", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.StorageProvider = &File_AwsS3{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= ErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Action) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Action: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Action: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionChoice = &Action_Block{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Report", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ActionChoice = &Action_Report{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CRMInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CRMInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CRMInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntitlementId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntitlementId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubscriptionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntitledSkus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntitledSkus = append(m.EntitledSkus, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerIdentifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerIdentifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegexMatchRewrite) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegexMatchRewrite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegexMatchRewrite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Substitution", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Substitution = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
