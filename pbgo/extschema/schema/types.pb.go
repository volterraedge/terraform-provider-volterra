// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/types.proto

package schema

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// HttpMethod
//
// x-displayName: "HTTP Method"
// Specifies the HTTP method used to acess a resource.
type HttpMethod int32

const (
	// x-displayName: "ANY"
	// Any HTTP Method
	ANY HttpMethod = 0
	// x-displayName: "GET"
	// GET method
	GET HttpMethod = 1
	// x-displayName: "HEAD"
	// HEAD method
	HEAD HttpMethod = 2
	// x-displayName: "POST"
	// POST method
	POST HttpMethod = 3
	// x-displayName: "PUT"
	// PUT method
	PUT HttpMethod = 4
	// x-displayName: "DELETE"
	// DELETE method
	DELETE HttpMethod = 5
	// x-displayName: "CONNECT"
	// CONNECT method
	CONNECT HttpMethod = 6
	// x-displayName: "OPTIONS"
	// OPTIONS method
	OPTIONS HttpMethod = 7
	// x-displayName: "TRACE"
	// TRACE method
	TRACE HttpMethod = 8
	// x-displayName: "PATCH"
	// PATCH method
	PATCH HttpMethod = 9
)

var HttpMethod_name = map[int32]string{
	0: "ANY",
	1: "GET",
	2: "HEAD",
	3: "POST",
	4: "PUT",
	5: "DELETE",
	6: "CONNECT",
	7: "OPTIONS",
	8: "TRACE",
	9: "PATCH",
}

var HttpMethod_value = map[string]int32{
	"ANY":     0,
	"GET":     1,
	"HEAD":    2,
	"POST":    3,
	"PUT":     4,
	"DELETE":  5,
	"CONNECT": 6,
	"OPTIONS": 7,
	"TRACE":   8,
	"PATCH":   9,
}

func (HttpMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{0}
}

// HttpStatusCode
//
// x-displayName: "HTTP Status Code"
// HTTP response status codes
type HttpStatusCode int32

const (
	// x-displayName: "EmptyStatusCode"
	// EmptyStatusCode response codes means it is not specified
	EmptyStatusCode HttpStatusCode = 0
	// x-displayName: "Continue"
	// CONTINUE code
	Continue HttpStatusCode = 100
	// x-displayName: "OK"
	// OK code
	OK HttpStatusCode = 200
	// x-displayName: "Created"
	// Created status code
	Created HttpStatusCode = 201
	// x-displayName: "Accepted"
	// Accepted status code
	Accepted HttpStatusCode = 202
	// x-displayName: "NonAuthoritativeInformation"
	// NonAuthoritativeInformation status code
	NonAuthoritativeInformation HttpStatusCode = 203
	// x-displayName: "NoContent"
	// NoContent status code
	NoContent HttpStatusCode = 204
	// x-displayName: "ResetContent"
	// ResetContent status code
	ResetContent HttpStatusCode = 205
	// x-displayName: "PartialContent"
	// PartialContent status code
	PartialContent HttpStatusCode = 206
	// x-displayName: "MultiStatus"
	// MultiStatus status code
	MultiStatus HttpStatusCode = 207
	// x-displayName: "AlreadyReported"
	// AlreadyReported status code
	AlreadyReported HttpStatusCode = 208
	// x-displayName: "IMUsed"
	// IMUsed status code
	IMUsed HttpStatusCode = 226
	// x-displayName: "MultipleChoices"
	// MultipleChoices status code
	MultipleChoices HttpStatusCode = 300
	// x-displayName: "MovedPermanently"
	// MovedPermanently status code
	MovedPermanently HttpStatusCode = 301
	// x-displayName: "Found"
	// Found status code
	Found HttpStatusCode = 302
	// x-displayName: "SeeOther"
	// SeeOther status code
	SeeOther HttpStatusCode = 303
	// x-displayName: "NotModified"
	// NotModified status code
	NotModified HttpStatusCode = 304
	// x-displayName: "UseProxy"
	// UseProxy status code
	UseProxy HttpStatusCode = 305
	// x-displayName: "TemporaryRedirect"
	// TemporaryRedirect status code
	TemporaryRedirect HttpStatusCode = 307
	// x-displayName: "PermanentRedirect"
	// PermanentRedirect status code
	PermanentRedirect HttpStatusCode = 308
	// x-displayName: "BadRequest"
	// BadRequest status code
	BadRequest HttpStatusCode = 400
	// x-displayName: "Unauthorized"
	// Unauthorized status code
	Unauthorized HttpStatusCode = 401
	// x-displayName: "PaymentRequired"
	// PaymentRequired status code
	PaymentRequired HttpStatusCode = 402
	// x-displayName: "Forbidden"
	// Forbidden status code
	Forbidden HttpStatusCode = 403
	// x-displayName: "NotFound"
	// NotFound status code
	NotFound HttpStatusCode = 404
	// x-displayName: "MethodNotAllowed"
	// MethodNotAllowed status code
	MethodNotAllowed HttpStatusCode = 405
	// x-displayName: "NotAcceptable"
	// NotAcceptable status code
	NotAcceptable HttpStatusCode = 406
	// x-displayName: "ProxyAuthenticationRequired"
	// ProxyAuthenticationRequired status code
	ProxyAuthenticationRequired HttpStatusCode = 407
	// x-displayName: "RequestTimeout"
	// RequestTimeout status code
	RequestTimeout HttpStatusCode = 408
	// x-displayName: "Conflict"
	// Conflict status code
	Conflict HttpStatusCode = 409
	// x-displayName: "Gone"
	// Gone status code
	Gone HttpStatusCode = 410
	// x-displayName: "LengthRequired"
	// LengthRequired status code
	LengthRequired HttpStatusCode = 411
	// x-displayName: "PreconditionFailed"
	// PreconditionFailed status code
	PreconditionFailed HttpStatusCode = 412
	// x-displayName: "PayloadTooLarge"
	// PayloadTooLarge status code
	PayloadTooLarge HttpStatusCode = 413
	// x-displayName: "URITooLong"
	// URITooLong status code
	URITooLong HttpStatusCode = 414
	// x-displayName: "UnsupportedMediaType"
	// UnsupportedMediaType status code
	UnsupportedMediaType HttpStatusCode = 415
	// x-displayName: "RangeNotSatisfiable"
	// RangeNotSatisfiable status code
	RangeNotSatisfiable HttpStatusCode = 416
	// x-displayName: "ExpectationFailed"
	// ExpectationFailed status code
	ExpectationFailed HttpStatusCode = 417
	// x-displayName: "MisdirectedRequest"
	// MisdirectedRequest status code
	MisdirectedRequest HttpStatusCode = 421
	// x-displayName: "UnprocessableEntity"
	// UnprocessableEntity status code
	UnprocessableEntity HttpStatusCode = 422
	// x-displayName: "Locked"
	// Locked status code
	Locked HttpStatusCode = 423
	// x-displayName: "FailedDependency"
	// FailedDependency status code
	FailedDependency HttpStatusCode = 424
	// x-displayName: "UpgradeRequired"
	// UpgradeRequired status code
	UpgradeRequired HttpStatusCode = 426
	// x-displayName: "PreconditionRequired"
	// PreconditionRequired status code
	PreconditionRequired HttpStatusCode = 428
	// x-displayName: "TooManyRequests"
	// TooManyRequests status code
	TooManyRequests HttpStatusCode = 429
	// x-displayName: "RequestHeaderFieldsTooLarge"
	// RequestHeaderFieldsTooLarge status code
	RequestHeaderFieldsTooLarge HttpStatusCode = 431
	// x-displayName: "InternalServerError"
	// InternalServerError status code
	InternalServerError HttpStatusCode = 500
	// x-displayName: "NotImplemented"
	// NotImplemented status code
	NotImplemented HttpStatusCode = 501
	// x-displayName: "BadGateway"
	// BadGateway status code
	BadGateway HttpStatusCode = 502
	// x-displayName: "ServiceUnavailable"
	// ServiceUnavailable status code
	ServiceUnavailable HttpStatusCode = 503
	// x-displayName: "GatewayTimeout"
	// GatewayTimeout status code
	GatewayTimeout HttpStatusCode = 504
	// x-displayName: "HTTPVersionNotSupported"
	// HTTPVersionNotSupported status code
	HTTPVersionNotSupported HttpStatusCode = 505
	// x-displayName: "VariantAlsoNegotiates"
	// VariantAlsoNegotiates status code
	VariantAlsoNegotiates HttpStatusCode = 506
	// x-displayName: "InsufficientStorage"
	// InsufficientStorage status code
	InsufficientStorage HttpStatusCode = 507
	// x-displayName: "LoopDetected"
	// LoopDetected status code
	LoopDetected HttpStatusCode = 508
	// x-displayName: "NotExtended"
	// NotExtended status code
	NotExtended HttpStatusCode = 510
	// x-displayName: "NetworkAuthenticationRequired"
	// NetworkAuthenticationRequired status code
	NetworkAuthenticationRequired HttpStatusCode = 511
)

var HttpStatusCode_name = map[int32]string{
	0:   "EmptyStatusCode",
	100: "Continue",
	200: "OK",
	201: "Created",
	202: "Accepted",
	203: "NonAuthoritativeInformation",
	204: "NoContent",
	205: "ResetContent",
	206: "PartialContent",
	207: "MultiStatus",
	208: "AlreadyReported",
	226: "IMUsed",
	300: "MultipleChoices",
	301: "MovedPermanently",
	302: "Found",
	303: "SeeOther",
	304: "NotModified",
	305: "UseProxy",
	307: "TemporaryRedirect",
	308: "PermanentRedirect",
	400: "BadRequest",
	401: "Unauthorized",
	402: "PaymentRequired",
	403: "Forbidden",
	404: "NotFound",
	405: "MethodNotAllowed",
	406: "NotAcceptable",
	407: "ProxyAuthenticationRequired",
	408: "RequestTimeout",
	409: "Conflict",
	410: "Gone",
	411: "LengthRequired",
	412: "PreconditionFailed",
	413: "PayloadTooLarge",
	414: "URITooLong",
	415: "UnsupportedMediaType",
	416: "RangeNotSatisfiable",
	417: "ExpectationFailed",
	421: "MisdirectedRequest",
	422: "UnprocessableEntity",
	423: "Locked",
	424: "FailedDependency",
	426: "UpgradeRequired",
	428: "PreconditionRequired",
	429: "TooManyRequests",
	431: "RequestHeaderFieldsTooLarge",
	500: "InternalServerError",
	501: "NotImplemented",
	502: "BadGateway",
	503: "ServiceUnavailable",
	504: "GatewayTimeout",
	505: "HTTPVersionNotSupported",
	506: "VariantAlsoNegotiates",
	507: "InsufficientStorage",
	508: "LoopDetected",
	510: "NotExtended",
	511: "NetworkAuthenticationRequired",
}

var HttpStatusCode_value = map[string]int32{
	"EmptyStatusCode":               0,
	"Continue":                      100,
	"OK":                            200,
	"Created":                       201,
	"Accepted":                      202,
	"NonAuthoritativeInformation":   203,
	"NoContent":                     204,
	"ResetContent":                  205,
	"PartialContent":                206,
	"MultiStatus":                   207,
	"AlreadyReported":               208,
	"IMUsed":                        226,
	"MultipleChoices":               300,
	"MovedPermanently":              301,
	"Found":                         302,
	"SeeOther":                      303,
	"NotModified":                   304,
	"UseProxy":                      305,
	"TemporaryRedirect":             307,
	"PermanentRedirect":             308,
	"BadRequest":                    400,
	"Unauthorized":                  401,
	"PaymentRequired":               402,
	"Forbidden":                     403,
	"NotFound":                      404,
	"MethodNotAllowed":              405,
	"NotAcceptable":                 406,
	"ProxyAuthenticationRequired":   407,
	"RequestTimeout":                408,
	"Conflict":                      409,
	"Gone":                          410,
	"LengthRequired":                411,
	"PreconditionFailed":            412,
	"PayloadTooLarge":               413,
	"URITooLong":                    414,
	"UnsupportedMediaType":          415,
	"RangeNotSatisfiable":           416,
	"ExpectationFailed":             417,
	"MisdirectedRequest":            421,
	"UnprocessableEntity":           422,
	"Locked":                        423,
	"FailedDependency":              424,
	"UpgradeRequired":               426,
	"PreconditionRequired":          428,
	"TooManyRequests":               429,
	"RequestHeaderFieldsTooLarge":   431,
	"InternalServerError":           500,
	"NotImplemented":                501,
	"BadGateway":                    502,
	"ServiceUnavailable":            503,
	"GatewayTimeout":                504,
	"HTTPVersionNotSupported":       505,
	"VariantAlsoNegotiates":         506,
	"InsufficientStorage":           507,
	"LoopDetected":                  508,
	"NotExtended":                   510,
	"NetworkAuthenticationRequired": 511,
}

func (HttpStatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{1}
}

// StatusPublishType
//
// x-displayName: "Publish"
// StatusPublishType is all possible publish operations on a StatusObject
type StatusPublishType int32

const (
	// Do not propagate this status to user. This could be because status is only informational
	STATUS_DO_NOT_PUBLISH StatusPublishType = 0
	// Propagate this status up to user as it might be actionable
	STATUS_PUBLISH StatusPublishType = 1
)

var StatusPublishType_name = map[int32]string{
	0: "STATUS_DO_NOT_PUBLISH",
	1: "STATUS_PUBLISH",
}

var StatusPublishType_value = map[string]int32{
	"STATUS_DO_NOT_PUBLISH": 0,
	"STATUS_PUBLISH":        1,
}

func (StatusPublishType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{2}
}

// SecretEncodingType
//
// x-displayName: "Secret Encoding"
// SecretEncodingType defines the encoding type of the secret before handled by the Secret Management Service.
type SecretEncodingType int32

const (
	// x-displayName: "None"
	// No Encoding
	EncodingNone SecretEncodingType = 0
	// Base64
	//
	// x-displayName: "Base64"
	// Base64 encoding
	EncodingBase64 SecretEncodingType = 1
)

var SecretEncodingType_name = map[int32]string{
	0: "EncodingNone",
	1: "EncodingBase64",
}

var SecretEncodingType_value = map[string]int32{
	"EncodingNone":   0,
	"EncodingBase64": 1,
}

func (SecretEncodingType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{3}
}

// URLSchemeType
//
// x-displayName: "URL Scheme"
// SchemeType is used to indicate URL scheme
type URLSchemeType int32

const (
	// x-displayName: "HTTP"
	// http:// scheme
	HTTP URLSchemeType = 0
	// x-displayName: "HTTPS"
	// https:// scheme
	HTTPS URLSchemeType = 1
)

var URLSchemeType_name = map[int32]string{
	0: "HTTP",
	1: "HTTPS",
}

var URLSchemeType_value = map[string]int32{
	"HTTP":  0,
	"HTTPS": 1,
}

func (URLSchemeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{4}
}

// TlsProtocol
//
// x-displayName: "TLS Protocol"
// TlsProtocol is enumeration of supported TLS versions
type TlsProtocol int32

const (
	// x-displayName: "Automatic"
	// Volterra will choose the optimal TLS version.
	TLS_AUTO TlsProtocol = 0
	// x-displayName: "TLSv1.0"
	// TLS 1.0
	TLSv1_0 TlsProtocol = 1
	// x-displayName: "TLSv1.1"
	// TLS 1.1
	TLSv1_1 TlsProtocol = 2
	// x-displayName: "TLSv1.2"
	// TLS 1.2
	TLSv1_2 TlsProtocol = 3
	// x-displayName: "TLSv1.3"
	// TLS 1.3
	TLSv1_3 TlsProtocol = 4
)

var TlsProtocol_name = map[int32]string{
	0: "TLS_AUTO",
	1: "TLSv1_0",
	2: "TLSv1_1",
	3: "TLSv1_2",
	4: "TLSv1_3",
}

var TlsProtocol_value = map[string]int32{
	"TLS_AUTO": 0,
	"TLSv1_0":  1,
	"TLSv1_1":  2,
	"TLSv1_2":  3,
	"TLSv1_3":  4,
}

func (TlsProtocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{5}
}

// RoutingPriority
//
// x-displayName: "Routing Priority"
// Priority routing for each request.
// Different connection pools are used based on the priority selected for the request.
// Also, circuit-breaker configuration at destination cluster is chosen based on selected priority.
type RoutingPriority int32

const (
	// x-displayName: "Default"
	// Default routing mechanism
	DEFAULT RoutingPriority = 0
	// x-displayName: "High-Priority"
	// High-Priority routing mechanism
	HIGH RoutingPriority = 1
)

var RoutingPriority_name = map[int32]string{
	0: "DEFAULT",
	1: "HIGH",
}

var RoutingPriority_value = map[string]int32{
	"DEFAULT": 0,
	"HIGH":    1,
}

func (RoutingPriority) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{6}
}

// DenominatorType
//
// x-displayName: "Denominator"
// Denominator used in fraction where sampling percentages are needed. example sampled requests
type DenominatorType int32

const (
	// x-displayName: "100"
	// Use hundred as denominator
	HUNDRED DenominatorType = 0
	// x-displayName: "10000"
	// Use ten thousand as denominator
	TEN_THOUSAND DenominatorType = 1
	// x-displayName: "1000000"
	// Use million as denominator
	MILLION DenominatorType = 2
)

var DenominatorType_name = map[int32]string{
	0: "HUNDRED",
	1: "TEN_THOUSAND",
	2: "MILLION",
}

var DenominatorType_value = map[string]int32{
	"HUNDRED":      0,
	"TEN_THOUSAND": 1,
	"MILLION":      2,
}

func (DenominatorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{7}
}

// DiscoveryType
//
// x-displayName: "Discovery Type"
// Specifies whether the discovery is from Kubernetes or Consul cluster
type DiscoveryType int32

const (
	// x-displayName: "INVALID"
	// Invalid Discovery mechanism
	INVALID_DISCOVERY DiscoveryType = 0
	// x-displayName: "Kubernetes"
	// Discover from Kubernetes cluster
	K8S DiscoveryType = 1
	// x-displayName: "HashiCorp Consul"
	// Discover from Consul service
	CONSUL DiscoveryType = 2
)

var DiscoveryType_name = map[int32]string{
	0: "INVALID_DISCOVERY",
	1: "K8S",
	2: "CONSUL",
}

var DiscoveryType_value = map[string]int32{
	"INVALID_DISCOVERY": 0,
	"K8S":               1,
	"CONSUL":            2,
}

func (DiscoveryType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{8}
}

// WafModeType
//
// x-displayName: "WAF Mode"
// The mode of operation for Web Application Firewall
type WafModeType int32

const (
	// x-displayName: "Block"
	// Block on detection
	BLOCK WafModeType = 0
	// x-displayName: "Alert"
	// Only raise alert on detection
	ALERT_ONLY WafModeType = 1
)

var WafModeType_name = map[int32]string{
	0: "BLOCK",
	1: "ALERT_ONLY",
}

var WafModeType_value = map[string]int32{
	"BLOCK":      0,
	"ALERT_ONLY": 1,
}

func (WafModeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{9}
}

// VipVrrpType
//
// x-displayName: "VRRP Virtual-IP"
// VRRP advertisement mode for VIP
type VipVrrpType int32

const (
	// x-displayName: "INVALID"
	// Invalid VRRP mode
	VIP_VRRP_INVALID VipVrrpType = 0
	// x-displayName: "Enable VRRP for VIP(s)"
	// VRRP advertisement enabled for virtual-ip
	VIP_VRRP_ENABLE VipVrrpType = 1
	// x-displayName: "Disable VRRP for VIP(s)"
	// VRRP advertisement disabled for virtual-ip
	VIP_VRRP_DISABLE VipVrrpType = 2
)

var VipVrrpType_name = map[int32]string{
	0: "VIP_VRRP_INVALID",
	1: "VIP_VRRP_ENABLE",
	2: "VIP_VRRP_DISABLE",
}

var VipVrrpType_value = map[string]int32{
	"VIP_VRRP_INVALID": 0,
	"VIP_VRRP_ENABLE":  1,
	"VIP_VRRP_DISABLE": 2,
}

func (VipVrrpType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{10}
}

// Site to site tunnel type
//
// x-displayName: "Tunnel type"
// Tunnel encapsulation to be used between sites
type SiteToSiteTunnelType int32

const (
	// x-displayName: "IPSEC or SSL"
	// Site to site tunnel can operate in both ipsec and ssl
	// ipsec takes precedence over ssl
	SITE_TO_SITE_TUNNEL_IPSEC_OR_SSL SiteToSiteTunnelType = 0
	// x-displayName: "IPSEC"
	// Site to site tunnel is of type ipsec
	SITE_TO_SITE_TUNNEL_IPSEC SiteToSiteTunnelType = 1
	// x-displayName: "SSL"
	// Site to site tunnel is of type ssl
	SITE_TO_SITE_TUNNEL_SSL SiteToSiteTunnelType = 2
)

var SiteToSiteTunnelType_name = map[int32]string{
	0: "SITE_TO_SITE_TUNNEL_IPSEC_OR_SSL",
	1: "SITE_TO_SITE_TUNNEL_IPSEC",
	2: "SITE_TO_SITE_TUNNEL_SSL",
}

var SiteToSiteTunnelType_value = map[string]int32{
	"SITE_TO_SITE_TUNNEL_IPSEC_OR_SSL": 0,
	"SITE_TO_SITE_TUNNEL_IPSEC":        1,
	"SITE_TO_SITE_TUNNEL_SSL":          2,
}

func (SiteToSiteTunnelType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{11}
}

// SortOrder
//
// x-displayName: "Sort Order"
// Sort algorithm
type SortOrder int32

const (
	// x-displayName: "Descending Order"
	// Sort in descending order
	DESCENDING SortOrder = 0
	// x-displayName: "Ascending Order"
	// Sort in ascending order
	ASCENDING SortOrder = 1
)

var SortOrder_name = map[int32]string{
	0: "DESCENDING",
	1: "ASCENDING",
}

var SortOrder_value = map[string]int32{
	"DESCENDING": 0,
	"ASCENDING":  1,
}

func (SortOrder) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{12}
}

// TunnelEncapsulationType
//
// x-displayName: "Tunnel Encapsulation Type"
// Type of tunnel encapsulation
type TunnelEncapsulationType int32

const (
	// x-displayName: "IPSEC PKI"
	// IPSEC using public key infrastructure
	IPSEC_PKI TunnelEncapsulationType = 0
	// x-displayName: "IPSEC PSK"
	// IPSEC using pre shared key
	IPSEC_PSK TunnelEncapsulationType = 1
	// x-displayName: "SSL"
	// SSL encapsulation
	SSL TunnelEncapsulationType = 2
	// x-displayName: "GRE"
	// GRE encapsulation
	GRE TunnelEncapsulationType = 3
)

var TunnelEncapsulationType_name = map[int32]string{
	0: "IPSEC_PKI",
	1: "IPSEC_PSK",
	2: "SSL",
	3: "GRE",
}

var TunnelEncapsulationType_value = map[string]int32{
	"IPSEC_PKI": 0,
	"IPSEC_PSK": 1,
	"SSL":       2,
	"GRE":       3,
}

func (TunnelEncapsulationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{13}
}

// App Firewall Violation Type
//
// x-displayName: "App Firewall Violation Type"
// List of all Violation Types
type AppFirewallViolationType int32

const (
	// x-displayName: "no violation"
	VIOL_NONE AppFirewallViolationType = 0
	// x-displayName: "Illegal file type"
	VIOL_FILETYPE AppFirewallViolationType = 1
	// x-displayName: "Illegal method"
	VIOL_METHOD AppFirewallViolationType = 2
	// x-displayName: "Mandatory HTTP header is missing"
	VIOL_MANDATORY_HEADER AppFirewallViolationType = 3
	// x-displayName: "Illegal HTTP status in response"
	VIOL_HTTP_RESPONSE_STATUS AppFirewallViolationType = 4
	// x-displayName: "Request length exceeds defined buffer size"
	VIOL_REQUEST_MAX_LENGTH AppFirewallViolationType = 5
	// x-displayName: "Disallowed file upload content detected"
	VIOL_FILE_UPLOAD AppFirewallViolationType = 6
	// x-displayName: "Disallowed file upload content detected in body"
	VIOL_FILE_UPLOAD_IN_BODY AppFirewallViolationType = 7
	// x-displayName: "Malformed XML data"
	VIOL_XML_MALFORMED AppFirewallViolationType = 8
	// x-displayName: "Malformed JSON data"
	VIOL_JSON_MALFORMED AppFirewallViolationType = 9
	// x-displayName: "Modified ASM cookie"
	VIOL_ASM_COOKIE_MODIFIED AppFirewallViolationType = 10
	// x-displayName: "Multiple Host Headers"
	VIOL_HTTP_PROTOCOL_MULTIPLE_HOST_HEADERS AppFirewallViolationType = 11
	// x-displayName: "Check maximum number of parameters"
	VIOL_HTTP_PROTOCOL_CHECK_MAXIMUM_NUMBER_OF_PARAMETERS AppFirewallViolationType = 12
	// x-displayName: "Bad host header value"
	VIOL_HTTP_PROTOCOL_BAD_HOST_HEADER_VALUE AppFirewallViolationType = 13
	// x-displayName: "Check maximum number of headers"
	VIOL_HTTP_PROTOCOL_CHECK_MAXIMUM_NUMBER_OF_HEADERS AppFirewallViolationType = 14
	// x-displayName: "Unparsable request content"
	VIOL_HTTP_PROTOCOL_UNPARSABLE_REQUEST_CONTENT AppFirewallViolationType = 15
	// x-displayName: "High ASCII characters in headers"
	VIOL_HTTP_PROTOCOL_HIGH_ASCII_CHARACTERS_IN_HEADERS AppFirewallViolationType = 16
	// x-displayName: "Null in request"
	VIOL_HTTP_PROTOCOL_NULL_IN_REQUEST AppFirewallViolationType = 17
	// x-displayName: "Bad HTTP version"
	VIOL_HTTP_PROTOCOL_BAD_HTTP_VERSION AppFirewallViolationType = 18
	// x-displayName: "Content length should be a positive number"
	VIOL_HTTP_PROTOCOL_CONTENT_LENGTH_SHOULD_BE_A_POSITIVE_NUMBER AppFirewallViolationType = 19
	// x-displayName: "Host header contains IP address"
	VIOL_HTTP_PROTOCOL_HOST_HEADER_CONTAINS_IP_ADDRESS AppFirewallViolationType = 20
	// x-displayName: "CRLF characters before request start"
	VIOL_HTTP_PROTOCOL_CRLF_CHARACTERS_BEFORE_REQUEST_START AppFirewallViolationType = 21
	// x-displayName: "No Host header in HTTP/1.1 request"
	VIOL_HTTP_PROTOCOL_NO_HOST_HEADER_IN_HTTP_1_1_REQUEST AppFirewallViolationType = 22
	// x-displayName: "Bad multipart parameters parsing"
	VIOL_HTTP_PROTOCOL_BAD_MULTIPART_PARAMETERS_PARSING AppFirewallViolationType = 23
	// x-displayName: "Bad multipart/form-data request parsing"
	VIOL_HTTP_PROTOCOL_BAD_MULTIPART_FORM_DATA_REQUEST_PARSING AppFirewallViolationType = 24
	// x-displayName: "Body in GET or HEAD requests"
	VIOL_HTTP_PROTOCOL_BODY_IN_GET_OR_HEAD_REQUESTS AppFirewallViolationType = 25
	// x-displayName: "Chunked request with Content-Length header"
	VIOL_HTTP_PROTOCOL_CHUNKED_REQUEST_WITH_CONTENT_LENGTH_HEADER AppFirewallViolationType = 26
	// x-displayName: "Several Content-Length headers"
	VIOL_HTTP_PROTOCOL_SEVERAL_CONTENT_LENGTH_HEADERS AppFirewallViolationType = 27
	// x-displayName: "Header name with no header value"
	VIOL_HTTP_PROTOCOL_HEADER_NAME_WITH_NO_HEADER_VALUE AppFirewallViolationType = 28
	// x-displayName: "POST request with Content-Length: 0"
	VIOL_HTTP_PROTOCOL_POST_REQUEST_WITH_CONTENT_LENGTH_0 AppFirewallViolationType = 29
	// x-displayName: "Bad unescape"
	VIOL_EVASION_BAD_UNESCAPE AppFirewallViolationType = 30
	// x-displayName: "Apache whitespace"
	VIOL_EVASION_APACHE_WHITESPACE AppFirewallViolationType = 31
	// x-displayName: "Bare byte decoding"
	VIOL_EVASION_BARE_BYTE_DECODING AppFirewallViolationType = 32
	// x-displayName: "IIS Unicode codepoints"
	VIOL_EVASION_IIS_UNICODE_CODEPOINTS AppFirewallViolationType = 33
	// x-displayName: "IIS backslashes"
	VIOL_EVASION_IIS_BACKSLASHES AppFirewallViolationType = 34
	// x-displayName: "%u decoding"
	VIOL_EVASION_U_DECODING AppFirewallViolationType = 35
	// x-displayName: "Multiple decoding"
	VIOL_EVASION_MULTIPLE_DECODING AppFirewallViolationType = 36
	// x-displayName: "Directory traversal"
	VIOL_EVASION_DIRECTORY_TRAVERSALS AppFirewallViolationType = 37
)

var AppFirewallViolationType_name = map[int32]string{
	0:  "VIOL_NONE",
	1:  "VIOL_FILETYPE",
	2:  "VIOL_METHOD",
	3:  "VIOL_MANDATORY_HEADER",
	4:  "VIOL_HTTP_RESPONSE_STATUS",
	5:  "VIOL_REQUEST_MAX_LENGTH",
	6:  "VIOL_FILE_UPLOAD",
	7:  "VIOL_FILE_UPLOAD_IN_BODY",
	8:  "VIOL_XML_MALFORMED",
	9:  "VIOL_JSON_MALFORMED",
	10: "VIOL_ASM_COOKIE_MODIFIED",
	11: "VIOL_HTTP_PROTOCOL_MULTIPLE_HOST_HEADERS",
	12: "VIOL_HTTP_PROTOCOL_CHECK_MAXIMUM_NUMBER_OF_PARAMETERS",
	13: "VIOL_HTTP_PROTOCOL_BAD_HOST_HEADER_VALUE",
	14: "VIOL_HTTP_PROTOCOL_CHECK_MAXIMUM_NUMBER_OF_HEADERS",
	15: "VIOL_HTTP_PROTOCOL_UNPARSABLE_REQUEST_CONTENT",
	16: "VIOL_HTTP_PROTOCOL_HIGH_ASCII_CHARACTERS_IN_HEADERS",
	17: "VIOL_HTTP_PROTOCOL_NULL_IN_REQUEST",
	18: "VIOL_HTTP_PROTOCOL_BAD_HTTP_VERSION",
	19: "VIOL_HTTP_PROTOCOL_CONTENT_LENGTH_SHOULD_BE_A_POSITIVE_NUMBER",
	20: "VIOL_HTTP_PROTOCOL_HOST_HEADER_CONTAINS_IP_ADDRESS",
	21: "VIOL_HTTP_PROTOCOL_CRLF_CHARACTERS_BEFORE_REQUEST_START",
	22: "VIOL_HTTP_PROTOCOL_NO_HOST_HEADER_IN_HTTP_1_1_REQUEST",
	23: "VIOL_HTTP_PROTOCOL_BAD_MULTIPART_PARAMETERS_PARSING",
	24: "VIOL_HTTP_PROTOCOL_BAD_MULTIPART_FORM_DATA_REQUEST_PARSING",
	25: "VIOL_HTTP_PROTOCOL_BODY_IN_GET_OR_HEAD_REQUESTS",
	26: "VIOL_HTTP_PROTOCOL_CHUNKED_REQUEST_WITH_CONTENT_LENGTH_HEADER",
	27: "VIOL_HTTP_PROTOCOL_SEVERAL_CONTENT_LENGTH_HEADERS",
	28: "VIOL_HTTP_PROTOCOL_HEADER_NAME_WITH_NO_HEADER_VALUE",
	29: "VIOL_HTTP_PROTOCOL_POST_REQUEST_WITH_CONTENT_LENGTH_0",
	30: "VIOL_EVASION_BAD_UNESCAPE",
	31: "VIOL_EVASION_APACHE_WHITESPACE",
	32: "VIOL_EVASION_BARE_BYTE_DECODING",
	33: "VIOL_EVASION_IIS_UNICODE_CODEPOINTS",
	34: "VIOL_EVASION_IIS_BACKSLASHES",
	35: "VIOL_EVASION_U_DECODING",
	36: "VIOL_EVASION_MULTIPLE_DECODING",
	37: "VIOL_EVASION_DIRECTORY_TRAVERSALS",
}

var AppFirewallViolationType_value = map[string]int32{
	"VIOL_NONE":                                0,
	"VIOL_FILETYPE":                            1,
	"VIOL_METHOD":                              2,
	"VIOL_MANDATORY_HEADER":                    3,
	"VIOL_HTTP_RESPONSE_STATUS":                4,
	"VIOL_REQUEST_MAX_LENGTH":                  5,
	"VIOL_FILE_UPLOAD":                         6,
	"VIOL_FILE_UPLOAD_IN_BODY":                 7,
	"VIOL_XML_MALFORMED":                       8,
	"VIOL_JSON_MALFORMED":                      9,
	"VIOL_ASM_COOKIE_MODIFIED":                 10,
	"VIOL_HTTP_PROTOCOL_MULTIPLE_HOST_HEADERS": 11,
	"VIOL_HTTP_PROTOCOL_CHECK_MAXIMUM_NUMBER_OF_PARAMETERS":         12,
	"VIOL_HTTP_PROTOCOL_BAD_HOST_HEADER_VALUE":                      13,
	"VIOL_HTTP_PROTOCOL_CHECK_MAXIMUM_NUMBER_OF_HEADERS":            14,
	"VIOL_HTTP_PROTOCOL_UNPARSABLE_REQUEST_CONTENT":                 15,
	"VIOL_HTTP_PROTOCOL_HIGH_ASCII_CHARACTERS_IN_HEADERS":           16,
	"VIOL_HTTP_PROTOCOL_NULL_IN_REQUEST":                            17,
	"VIOL_HTTP_PROTOCOL_BAD_HTTP_VERSION":                           18,
	"VIOL_HTTP_PROTOCOL_CONTENT_LENGTH_SHOULD_BE_A_POSITIVE_NUMBER": 19,
	"VIOL_HTTP_PROTOCOL_HOST_HEADER_CONTAINS_IP_ADDRESS":            20,
	"VIOL_HTTP_PROTOCOL_CRLF_CHARACTERS_BEFORE_REQUEST_START":       21,
	"VIOL_HTTP_PROTOCOL_NO_HOST_HEADER_IN_HTTP_1_1_REQUEST":         22,
	"VIOL_HTTP_PROTOCOL_BAD_MULTIPART_PARAMETERS_PARSING":           23,
	"VIOL_HTTP_PROTOCOL_BAD_MULTIPART_FORM_DATA_REQUEST_PARSING":    24,
	"VIOL_HTTP_PROTOCOL_BODY_IN_GET_OR_HEAD_REQUESTS":               25,
	"VIOL_HTTP_PROTOCOL_CHUNKED_REQUEST_WITH_CONTENT_LENGTH_HEADER": 26,
	"VIOL_HTTP_PROTOCOL_SEVERAL_CONTENT_LENGTH_HEADERS":             27,
	"VIOL_HTTP_PROTOCOL_HEADER_NAME_WITH_NO_HEADER_VALUE":           28,
	"VIOL_HTTP_PROTOCOL_POST_REQUEST_WITH_CONTENT_LENGTH_0":         29,
	"VIOL_EVASION_BAD_UNESCAPE":                                     30,
	"VIOL_EVASION_APACHE_WHITESPACE":                                31,
	"VIOL_EVASION_BARE_BYTE_DECODING":                               32,
	"VIOL_EVASION_IIS_UNICODE_CODEPOINTS":                           33,
	"VIOL_EVASION_IIS_BACKSLASHES":                                  34,
	"VIOL_EVASION_U_DECODING":                                       35,
	"VIOL_EVASION_MULTIPLE_DECODING":                                36,
	"VIOL_EVASION_DIRECTORY_TRAVERSALS":                             37,
}

func (AppFirewallViolationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{14}
}

// TenantType
//
// x-displayName: "Tenant type"
// TenantType is the type of the customer
type TenantType int32

const (
	// x-displayName: "Unknown"
	// UNKNOWN indicates the field not being set
	UNKNOWN TenantType = 0
	// x-displayName: "Freemium"
	// FREEMIUM are customer that don't have their domain
	FREEMIUM TenantType = 1
	// x-displayName: "Enterprise"
	// ENTERPRiISE customer have their domain
	ENTERPRISE TenantType = 2
)

var TenantType_name = map[int32]string{
	0: "UNKNOWN",
	1: "FREEMIUM",
	2: "ENTERPRISE",
}

var TenantType_value = map[string]int32{
	"UNKNOWN":    0,
	"FREEMIUM":   1,
	"ENTERPRISE": 2,
}

func (TenantType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{15}
}

// TaxExemptionType
//
// x-displayName: "Tax Exemption"
// TaxExemptionType holds possible tax exemption option.
type TaxExemptionType int32

const (
	// x-displayName: "Unknown"
	// UNKNOWN indicates the field not being set
	TAX_UNKNOWN TaxExemptionType = 0
	// x-displayName: "Regular"
	// TAX_REGULAR indicates customers that are required to pay taxes
	TAX_REGULAR TaxExemptionType = 1
	// x-displayName: "Unverified"
	// TAX_EXEMPT indicates customers exempt from paying taxes - their status needs to be verified once signup is completed.
	TAX_EXEMPT_UNVERIFIED TaxExemptionType = 2
	// x-displayName: "Verified"
	// TAX_EXEMPT indicates customers exempt from paying taxes - their status has been verified and the customer is not being taxed by us.
	TAX_EXEMPT_VERIFIED TaxExemptionType = 3
	// x-displayName: "Verification Failed"
	// TAX_EXEMPT_VERIFICATION_FAILED indicates customers that the tax exempt verification process failed - they can contact Volterra to get more details
	TAX_EXEMPT_VERIFICATION_FAILED TaxExemptionType = 4
	// x-displayName: "Verification Pending"
	// TAX_EXEMPT_VERIFICATION_PENDING indicates customers that the tax exempt verification process is ongoing
	TAX_EXEMPT_VERIFICATION_PENDING TaxExemptionType = 5
)

var TaxExemptionType_name = map[int32]string{
	0: "TAX_UNKNOWN",
	1: "TAX_REGULAR",
	2: "TAX_EXEMPT_UNVERIFIED",
	3: "TAX_EXEMPT_VERIFIED",
	4: "TAX_EXEMPT_VERIFICATION_FAILED",
	5: "TAX_EXEMPT_VERIFICATION_PENDING",
}

var TaxExemptionType_value = map[string]int32{
	"TAX_UNKNOWN":                     0,
	"TAX_REGULAR":                     1,
	"TAX_EXEMPT_UNVERIFIED":           2,
	"TAX_EXEMPT_VERIFIED":             3,
	"TAX_EXEMPT_VERIFICATION_FAILED":  4,
	"TAX_EXEMPT_VERIFICATION_PENDING": 5,
}

func (TaxExemptionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{16}
}

// PlanType
//
// x-displayName: "Plan Type"
// PlanType is the type of billing plan for the customer
type PlanType int32

const (
	// x-displayName: "Free"
	FREE PlanType = 0
	// x-displayName: "Individual"
	INDIVIDUAL PlanType = 1
	// x-displayName: "Team"
	TEAM PlanType = 2
	// x-displayName: "Organization"
	ORGANIZATION PlanType = 3
	// x-displayName: "Unspecified"
	PLAN_TYPE_UNSPECIFIED PlanType = 4
)

var PlanType_name = map[int32]string{
	0: "FREE",
	1: "INDIVIDUAL",
	2: "TEAM",
	3: "ORGANIZATION",
	4: "PLAN_TYPE_UNSPECIFIED",
}

var PlanType_value = map[string]int32{
	"FREE":                  0,
	"INDIVIDUAL":            1,
	"TEAM":                  2,
	"ORGANIZATION":          3,
	"PLAN_TYPE_UNSPECIFIED": 4,
}

func (PlanType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{17}
}

// Metric Label Operator
//
// x-displayName: "Metric Label Operator"
// The operator to use when filtering metrics based on label values.
type MetricLabelOp int32

const (
	// x-displayName: "Equal To"
	EQ MetricLabelOp = 0
	// x-displayName: "Not Equal To"
	NEQ MetricLabelOp = 1
)

var MetricLabelOp_name = map[int32]string{
	0: "EQ",
	1: "NEQ",
}

var MetricLabelOp_value = map[string]int32{
	"EQ":  0,
	"NEQ": 1,
}

func (MetricLabelOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{18}
}

// Route Attribute
//
// x-displayName: "Route Attribute"
// Defines attributes associated with route
type RouteAttrType int32

const (
	// x-displayName: "None"
	// Ignore attribute
	ROUTE_ATTR_NO_OP RouteAttrType = 0
	// x-displayName: "Advertise"
	// Advertise route in all supported routing protocols
	ROUTE_ATTR_ADVERTISE RouteAttrType = 1
	// x-displayName: "Install Host OS"
	// Add route into host OS - route in host OS will point to interface corresponding to the
	// virtual network. Host OS must have an interface in the virtual network.
	ROUTE_ATTR_INSTALL_HOST RouteAttrType = 2
	// x-displayName: "Install Forwarding"
	// Use the route for forwarding decision - adds route into data plane
	// modules with configured next-hop
	ROUTE_ATTR_INSTALL_FORWARDING RouteAttrType = 3
	// x-displayName: "Merge Route"
	// Merge Route if they already exist
	ROUTE_ATTR_MERGE_ONLY RouteAttrType = 4
)

var RouteAttrType_name = map[int32]string{
	0: "ROUTE_ATTR_NO_OP",
	1: "ROUTE_ATTR_ADVERTISE",
	2: "ROUTE_ATTR_INSTALL_HOST",
	3: "ROUTE_ATTR_INSTALL_FORWARDING",
	4: "ROUTE_ATTR_MERGE_ONLY",
}

var RouteAttrType_value = map[string]int32{
	"ROUTE_ATTR_NO_OP":              0,
	"ROUTE_ATTR_ADVERTISE":          1,
	"ROUTE_ATTR_INSTALL_HOST":       2,
	"ROUTE_ATTR_INSTALL_FORWARDING": 3,
	"ROUTE_ATTR_MERGE_ONLY":         4,
}

func (RouteAttrType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{19}
}

// Nexthop Types
//
// x-displayName: "Nexthop Types"
// Defines types of next-hop
type NextHopTypes int32

const (
	// x-displayName: "Default Gateway"
	// Use default gateway on the local interface as gateway for route.
	// Assumes there is only one local interface on the virtual network.
	NEXT_HOP_DEFAULT_GATEWAY NextHopTypes = 0
	// x-displayName: "User Configured"
	// Use the specified address as nexthop
	NEXT_HOP_USE_CONFIGURED NextHopTypes = 1
	// x-displayName: "Network Interface"
	// Use the network interface as nexthop
	NEXT_HOP_NETWORK_INTERFACE NextHopTypes = 2
	// x-displayName: "Discard"
	// Discard nexthop, used when attr type is Advertise
	NEXT_HOP_DISCARD NextHopTypes = 3
	// x-displayName: "SNAT to Public"
	// Used in VoltADN private virtual network.
	NEXT_HOP_SNAT_TO_PUBLIC NextHopTypes = 4
)

var NextHopTypes_name = map[int32]string{
	0: "NEXT_HOP_DEFAULT_GATEWAY",
	1: "NEXT_HOP_USE_CONFIGURED",
	2: "NEXT_HOP_NETWORK_INTERFACE",
	3: "NEXT_HOP_DISCARD",
	4: "NEXT_HOP_SNAT_TO_PUBLIC",
}

var NextHopTypes_value = map[string]int32{
	"NEXT_HOP_DEFAULT_GATEWAY":   0,
	"NEXT_HOP_USE_CONFIGURED":    1,
	"NEXT_HOP_NETWORK_INTERFACE": 2,
	"NEXT_HOP_DISCARD":           3,
	"NEXT_HOP_SNAT_TO_PUBLIC":    4,
}

func (NextHopTypes) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{20}
}

// Empty
//
// x-displayName: "Empty"
// This can be used for messages where no values are needed
type Empty struct {
}

func (m *Empty) Reset()      { *m = Empty{} }
func (*Empty) ProtoMessage() {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{0}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

// ObjectRefType
//
// x-displayName: "Object reference"
// This type establishes a 'direct reference' from one object(the referrer) to another(the referred).
// Such a reference is in form of tenant/namespace/name for public API and Uid for private API
// This type of reference is called direct because the relation is explicit and concrete (as opposed
// to selector reference which builds a group based on labels of selectee objects)
type ObjectRefType struct {
	// kind
	//
	// x-displayName: "Kind"
	// x-example: "virtual_site"
	// When a configuration object(e.g. virtual_host) refers to another(e.g route)
	// then kind will hold the referred object's kind (e.g. "route")
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// uid
	//
	// x-displayName: "UID"
	// x-example: "d15f1fad-4d37-48c0-8706-df1824d76d31"
	// When a configuration object(e.g. virtual_host) refers to another(e.g route)
	// then uid will hold the referred object's(e.g. route's) uid.
	Uid string `protobuf:"bytes,2,opt,name=uid,proto3" json:"uid,omitempty"`
	// tenant
	//
	// x-displayName: "Tenant"
	// x-example: "acmecorp"
	// When a configuration object(e.g. virtual_host) refers to another(e.g route)
	// then tenant will hold the referred object's(e.g. route's) tenant.
	Tenant string `protobuf:"bytes,3,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "ns1"
	// When a configuration object(e.g. virtual_host) refers to another(e.g route)
	// then namespace will hold the referred object's(e.g. route's) namespace.
	Namespace string `protobuf:"bytes,4,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// name
	//
	// x-displayName: "Name"
	// x-example: "contactus-route"
	// When a configuration object(e.g. virtual_host) refers to another(e.g route)
	// then name will hold the referred object's(e.g. route's) name.
	Name string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ObjectRefType) Reset()      { *m = ObjectRefType{} }
func (*ObjectRefType) ProtoMessage() {}
func (*ObjectRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{1}
}
func (m *ObjectRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ObjectRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectRefType.Merge(m, src)
}
func (m *ObjectRefType) XXX_Size() int {
	return m.Size()
}
func (m *ObjectRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectRefType.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectRefType proto.InternalMessageInfo

func (m *ObjectRefType) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *ObjectRefType) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *ObjectRefType) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *ObjectRefType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ObjectRefType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// LabelSelectorType
//
// x-displayName: "Label Selector"
// This type can be used to establish a 'selector reference' from one object(called selector) to
// a set of other objects(called selectees) based on the value of expresssions.
// A label selector is a label query over a set of resources. An empty label selector matches all objects.
// A null label selector matches no objects. Label selector is immutable.
// expressions is a list of strings of label selection expression.
// Each string has "," separated values which are "AND" and all strings are logically "OR".
// BNF for expression string
// <selector-syntax>         ::= <requirement> | <requirement> "," <selector-syntax>
// <requirement>             ::= [!] KEY [ <set-based-restriction> | <exact-match-restriction> ]
// <set-based-restriction>   ::= "" | <inclusion-exclusion> <value-set>
// <inclusion-exclusion>     ::= <inclusion> | <exclusion>
// <exclusion>               ::= "notin"
// <inclusion>               ::= "in"
// <value-set>               ::= "(" <values> ")"
// <values>                  ::= VALUE | VALUE "," <values>
// <exact-match-restriction> ::= ["="|"=="|"!="] VALUE
type LabelSelectorType struct {
	// expressions
	//
	// x-displayName: "Selector Expression"
	// x-required
	// x-example: "region in (us-west1, us-west2),tier in (staging)"
	// expressions contains the kubernetes style label expression for selections.
	Expressions []string `protobuf:"bytes,1,rep,name=expressions,proto3" json:"expressions,omitempty"`
}

func (m *LabelSelectorType) Reset()      { *m = LabelSelectorType{} }
func (*LabelSelectorType) ProtoMessage() {}
func (*LabelSelectorType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{2}
}
func (m *LabelSelectorType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabelSelectorType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LabelSelectorType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabelSelectorType.Merge(m, src)
}
func (m *LabelSelectorType) XXX_Size() int {
	return m.Size()
}
func (m *LabelSelectorType) XXX_DiscardUnknown() {
	xxx_messageInfo_LabelSelectorType.DiscardUnknown(m)
}

var xxx_messageInfo_LabelSelectorType proto.InternalMessageInfo

func (m *LabelSelectorType) GetExpressions() []string {
	if m != nil {
		return m.Expressions
	}
	return nil
}

// LabelMatcherType
//
// x-displayName: "Label Matcher"
// A label matcher specifies a list of label keys whose values need to match for
// source/client and destination/server. Note that the actual label values are not
// specified and do not matter. This allows an ability to scope grouping by the
// label key name.
type LabelMatcherType struct {
	// keys
	//
	// x-displayName: "Keys"
	// x-example: "['environment', 'location', 'deployment']"
	// The list of label key names that have to match
	Keys []string `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
}

func (m *LabelMatcherType) Reset()      { *m = LabelMatcherType{} }
func (*LabelMatcherType) ProtoMessage() {}
func (*LabelMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{3}
}
func (m *LabelMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabelMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *LabelMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabelMatcherType.Merge(m, src)
}
func (m *LabelMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *LabelMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_LabelMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_LabelMatcherType proto.InternalMessageInfo

func (m *LabelMatcherType) GetKeys() []string {
	if m != nil {
		return m.Keys
	}
	return nil
}

// ConditionType
//
// x-displayName: "Status Condition"
// Conditions are used in the object status to describe the current state of the
// object, e.g. Ready, Succeeded, etc.
type ConditionType struct {
	// type
	//
	// x-displayName: "Type"
	// x-example: "Operational"
	// Type of the condition
	// "Validation" represents validation user given configuration object
	// "Operational" represents operational status of a given configuration object
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// status
	//
	// x-displayName: "Status"
	// x-example: "Failed"
	// Status of the condition
	// "Success" Validtion has succeded. Requested operation was successful.
	// "Failed"  Validation has failed.
	// "Incomplete" Validation of configuration has failed due to missing configuration.
	// "Installed" Validation has passed and configuration has been installed in data path or K8s
	// "Down" Configuration is operationally down. e.g. down interface
	// "Disabled" Configuration is administratively disabled i.e. ObjectMetaType.Disable = true.
	// "NotApplicable" Configuration is not applicable e.g. tenant service_policy_set(s) in system namespace are not applicable on REs
	Status string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	// reason
	//
	// x-displayName: "Reason"
	// x-example: "value"
	// x-reason: "Insufficient memory in data plane"
	// A human readable string explaining the reason for reaching this condition
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	// last_update_time
	//
	// x-displayName: "Last Updated"
	// Last time the condition was updated
	LastUpdateTime *types.Timestamp `protobuf:"bytes,5,opt,name=last_update_time,json=lastUpdateTime,proto3" json:"last_update_time,omitempty"`
	// hostname
	//
	// x-displayName: "Hostname"
	// Hostname of the instance of the site that sent the status
	Hostname string `protobuf:"bytes,6,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// service name
	//
	// x-displayName: "Service Name"
	// Name of the service that sent the status
	ServiceName string `protobuf:"bytes,7,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
}

func (m *ConditionType) Reset()      { *m = ConditionType{} }
func (*ConditionType) ProtoMessage() {}
func (*ConditionType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{4}
}
func (m *ConditionType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConditionType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ConditionType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConditionType.Merge(m, src)
}
func (m *ConditionType) XXX_Size() int {
	return m.Size()
}
func (m *ConditionType) XXX_DiscardUnknown() {
	xxx_messageInfo_ConditionType.DiscardUnknown(m)
}

var xxx_messageInfo_ConditionType proto.InternalMessageInfo

func (m *ConditionType) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ConditionType) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ConditionType) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *ConditionType) GetLastUpdateTime() *types.Timestamp {
	if m != nil {
		return m.LastUpdateTime
	}
	return nil
}

func (m *ConditionType) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *ConditionType) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

// StatusType
//
// x-displayName: "Status"
// Status is a return value for calls that don't return other objects.
type StatusType struct {
	// status
	//
	// x-displayName: "Status"
	// x-example: "value"
	// Status of the operation.
	// One of: "Success" or "Failure".
	Status string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// reason
	//
	// x-displayName: "Reason"
	// x-example: "value"
	// A human-readable description of why this operation is in the
	// "Failure" status. If this value is empty there
	// is no information available.
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	// code
	//
	// x-displayName: "Code"
	// x-example: "0"
	// Suggested HTTP return code for this status, 0 if not set.
	Code int32 `protobuf:"varint,4,opt,name=code,proto3" json:"code,omitempty"`
}

func (m *StatusType) Reset()      { *m = StatusType{} }
func (*StatusType) ProtoMessage() {}
func (*StatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{5}
}
func (m *StatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusType.Merge(m, src)
}
func (m *StatusType) XXX_Size() int {
	return m.Size()
}
func (m *StatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusType.DiscardUnknown(m)
}

var xxx_messageInfo_StatusType proto.InternalMessageInfo

func (m *StatusType) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *StatusType) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *StatusType) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

// InitializerType
//
// x-displayName: "Initializer"
// Initializer is information about an initializer that has not yet completed.
type InitializerType struct {
	// name
	//
	// x-displayName: "Name"
	// name of the service that is responsible for initializing this object.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *InitializerType) Reset()      { *m = InitializerType{} }
func (*InitializerType) ProtoMessage() {}
func (*InitializerType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{6}
}
func (m *InitializerType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InitializerType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InitializerType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitializerType.Merge(m, src)
}
func (m *InitializerType) XXX_Size() int {
	return m.Size()
}
func (m *InitializerType) XXX_DiscardUnknown() {
	xxx_messageInfo_InitializerType.DiscardUnknown(m)
}

var xxx_messageInfo_InitializerType proto.InternalMessageInfo

func (m *InitializerType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// InitializersType
//
// x-displayName: "Initializers"
// Initializers tracks the progress of initialization of a configuration object
type InitializersType struct {
	// pending
	//
	// x-displayName: "Pending"
	// Pending is a list of initializers that must execute in order before this object is initialized.
	// When the last pending initializer is removed, and no failing result is set, the initializers
	// struct will be set to nil and the object is considered as initialized and visible to all
	// clients.
	Pending []*InitializerType `protobuf:"bytes,1,rep,name=pending,proto3" json:"pending,omitempty"`
	// result
	//
	// x-displayName: "Result"
	// If result is set with the Failure field, the object will be persisted to storage and then deleted,
	// ensuring that other clients can observe the deletion.
	Result *StatusType `protobuf:"bytes,2,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *InitializersType) Reset()      { *m = InitializersType{} }
func (*InitializersType) ProtoMessage() {}
func (*InitializersType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{7}
}
func (m *InitializersType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InitializersType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InitializersType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitializersType.Merge(m, src)
}
func (m *InitializersType) XXX_Size() int {
	return m.Size()
}
func (m *InitializersType) XXX_DiscardUnknown() {
	xxx_messageInfo_InitializersType.DiscardUnknown(m)
}

var xxx_messageInfo_InitializersType proto.InternalMessageInfo

func (m *InitializersType) GetPending() []*InitializerType {
	if m != nil {
		return m.Pending
	}
	return nil
}

func (m *InitializersType) GetResult() *StatusType {
	if m != nil {
		return m.Result
	}
	return nil
}

// StatusMetaType
//
// x-displayName: "Metadata"
// StatusMetaType is metadata that all status must have.
type StatusMetaType struct {
	// uid
	//
	// x-displayName: "UID"
	// x-example: "d15f1fad-4d37-48c0-8706-df1824d76d31"
	// uid is the unique in time and space value for a StatusObject.
	Uid string `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// creator_class
	//
	// x-displayName: "Creator Class"
	// x-example: "ver.re1.int.ves.io"
	// Class of creator which created this StatusObject. This will be service's DNS FQDN.
	// This will be set by the system based on client certificate information.
	CreatorClass string `protobuf:"bytes,2,opt,name=creator_class,json=creatorClass,proto3" json:"creator_class,omitempty"`
	// creator_id
	//
	// x-displayName: "Creator ID"
	// x-example: "ver-instance-1"
	// ID of creator which created this StatusObject. This will be a concrete identifier for service (e.g.
	// identifying the environment also). This will be set by the system based on client certificate
	// information
	CreatorId string `protobuf:"bytes,3,opt,name=creator_id,json=creatorId,proto3" json:"creator_id,omitempty"`
	// status_id
	//
	// x-displayName: "Status ID"
	// status_id is a field used by the generator to distinguish (if necessary) between two status
	// objects for the same config object from the same site and same service and potentially same
	// daemon(creator-id)
	StatusId string `protobuf:"bytes,4,opt,name=status_id,json=statusId,proto3" json:"status_id,omitempty"`
	// creation_timestamp
	//
	// x-displayName: "Creation Timestamp"
	// creation_timestamp is when the status object was created. It is used to find/tie-break
	// for latest status object from same origin
	CreationTimestamp *types.Timestamp `protobuf:"bytes,5,opt,name=creation_timestamp,json=creationTimestamp,proto3" json:"creation_timestamp,omitempty"`
	// publish
	//
	// x-displayName: "Publish"
	// Decides wether this status object will be propagated to user.
	Publish StatusPublishType `protobuf:"varint,6,opt,name=publish,proto3,enum=ves.io.schema.StatusPublishType" json:"publish,omitempty"`
	// vtrp_id
	//
	// x-displayName: "VTRP ID"
	// Oriong of this status exchanged by VTRP.
	VtrpId string `protobuf:"bytes,7,opt,name=vtrp_id,json=vtrpId,proto3" json:"vtrp_id,omitempty"`
}

func (m *StatusMetaType) Reset()      { *m = StatusMetaType{} }
func (*StatusMetaType) ProtoMessage() {}
func (*StatusMetaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{8}
}
func (m *StatusMetaType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusMetaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StatusMetaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusMetaType.Merge(m, src)
}
func (m *StatusMetaType) XXX_Size() int {
	return m.Size()
}
func (m *StatusMetaType) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusMetaType.DiscardUnknown(m)
}

var xxx_messageInfo_StatusMetaType proto.InternalMessageInfo

func (m *StatusMetaType) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *StatusMetaType) GetCreatorClass() string {
	if m != nil {
		return m.CreatorClass
	}
	return ""
}

func (m *StatusMetaType) GetCreatorId() string {
	if m != nil {
		return m.CreatorId
	}
	return ""
}

func (m *StatusMetaType) GetStatusId() string {
	if m != nil {
		return m.StatusId
	}
	return ""
}

func (m *StatusMetaType) GetCreationTimestamp() *types.Timestamp {
	if m != nil {
		return m.CreationTimestamp
	}
	return nil
}

func (m *StatusMetaType) GetPublish() StatusPublishType {
	if m != nil {
		return m.Publish
	}
	return STATUS_DO_NOT_PUBLISH
}

func (m *StatusMetaType) GetVtrpId() string {
	if m != nil {
		return m.VtrpId
	}
	return ""
}

// ObjectMetaType
//
// x-displayName: "Metadata"
// ObjectMetaType is metadata(common attributes) of an object that all configuration objects will have.
// The information in this type can be specified by user during create and replace APIs.
type ObjectMetaType struct {
	// name
	//
	// x-displayName: "Name"
	// x-example: "acmecorp-web"
	// x-required
	// This is the name of configuration object. It has to be unique within the namespace.
	// It can only be specified during create API and cannot be changed during replace API.
	// The value of name has to follow DNS-1035 format.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "staging"
	// This defines the workspace within which each the configuration object is to be created.
	// Must be a DNS_LABEL format. For a namespace object itself, namespace value will be ""
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// uid
	//
	// x-displayName: "UID"
	// x-example: "d15f1fad-4d37-48c0-8706-df1824d76d31"
	// uid is the unique in time and space value for this object. Object create will fail if
	// provided by the client and the value exists in the system. Typically generated by the
	// server on successful creation of an object and is not allowed to change once populated.
	// Shadowed by SystemObjectMeta's uid field.
	Uid string `protobuf:"bytes,3,opt,name=uid,proto3" json:"uid,omitempty"`
	// labels
	//
	// x-displayName: "Labels"
	// x-example: "value"
	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects as chosen by the user. Values specified here will be used
	// by selector expression
	Labels map[string]string `protobuf:"bytes,4,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// annotations
	//
	// x-displayName: "Annotations"
	// x-example: "value"
	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	Annotations map[string]string `protobuf:"bytes,5,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// description
	//
	// x-displayName: "Description"
	// x-example: "Virtual Host for acmecorp website"
	// Human readable description for the object
	Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	// disable
	//
	// x-displayName: "Disable"
	// x-example: "true"
	// A value of true will administratively disable the object
	Disable bool `protobuf:"varint,7,opt,name=disable,proto3" json:"disable,omitempty"`
}

func (m *ObjectMetaType) Reset()      { *m = ObjectMetaType{} }
func (*ObjectMetaType) ProtoMessage() {}
func (*ObjectMetaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{9}
}
func (m *ObjectMetaType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectMetaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ObjectMetaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectMetaType.Merge(m, src)
}
func (m *ObjectMetaType) XXX_Size() int {
	return m.Size()
}
func (m *ObjectMetaType) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectMetaType.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectMetaType proto.InternalMessageInfo

func (m *ObjectMetaType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ObjectMetaType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ObjectMetaType) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *ObjectMetaType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ObjectMetaType) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ObjectMetaType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ObjectMetaType) GetDisable() bool {
	if m != nil {
		return m.Disable
	}
	return false
}

// ListMetaType
//
// x-displayName: "List Metadata"
// ListMetaType is metadata that all lists must have.
type ListMetaType struct {
	// resource_version
	//
	// x-displayName: "Resource Version"
	// x-example: "181255"
	// An opaque value that represents the revision of the store at the time the list API is
	// performed. It can be used in subsequent watch API to receive all changes after the list
	// API, or in a replace API to make the replace conditional on the object still being at
	// that revision
	ResourceVersion string `protobuf:"bytes,1,opt,name=resource_version,json=resourceVersion,proto3" json:"resource_version,omitempty"`
}

func (m *ListMetaType) Reset()      { *m = ListMetaType{} }
func (*ListMetaType) ProtoMessage() {}
func (*ListMetaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{10}
}
func (m *ListMetaType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListMetaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ListMetaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListMetaType.Merge(m, src)
}
func (m *ListMetaType) XXX_Size() int {
	return m.Size()
}
func (m *ListMetaType) XXX_DiscardUnknown() {
	xxx_messageInfo_ListMetaType.DiscardUnknown(m)
}

var xxx_messageInfo_ListMetaType proto.InternalMessageInfo

func (m *ListMetaType) GetResourceVersion() string {
	if m != nil {
		return m.ResourceVersion
	}
	return ""
}

// ObjectGetMetaType
//
// x-displayName: "Get Metadata"
// ObjectGetMetaType is metadata that can be specified in Get/Create response of an object.
type ObjectGetMetaType struct {
	// name
	//
	// x-displayName: "Name"
	// x-example: "acmecorp-web"
	// x-required
	// The configuration object will be created with name. It has to be unique within the namespace.
	// The value of name has to follow DNS-1035 format.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "staging"
	// This defines the workspace within which each the configuration object is to be created.
	// Must be a DNS_LABEL format. For a namespace object itself, namespace value will be ""
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// labels
	//
	// x-displayName: "Labels"
	// x-example: "value"
	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects as chosen by the user. Values specified here will be used
	// by selector expression
	Labels map[string]string `protobuf:"bytes,4,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// annotations
	//
	// x-displayName: "Annotation"
	// x-example: "value"
	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	Annotations map[string]string `protobuf:"bytes,5,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// description
	//
	// x-displayName: "Description"
	// x-example: "Virtual Host for acmecorp website"
	// Human readable description for the object
	Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	// disable
	//
	// x-displayName: "Disable"
	// x-example: "true"
	// A value of true will administratively disable the object
	Disable bool `protobuf:"varint,7,opt,name=disable,proto3" json:"disable,omitempty"`
}

func (m *ObjectGetMetaType) Reset()      { *m = ObjectGetMetaType{} }
func (*ObjectGetMetaType) ProtoMessage() {}
func (*ObjectGetMetaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{11}
}
func (m *ObjectGetMetaType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectGetMetaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ObjectGetMetaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectGetMetaType.Merge(m, src)
}
func (m *ObjectGetMetaType) XXX_Size() int {
	return m.Size()
}
func (m *ObjectGetMetaType) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectGetMetaType.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectGetMetaType proto.InternalMessageInfo

func (m *ObjectGetMetaType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ObjectGetMetaType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ObjectGetMetaType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ObjectGetMetaType) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ObjectGetMetaType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ObjectGetMetaType) GetDisable() bool {
	if m != nil {
		return m.Disable
	}
	return false
}

// ObjectCreateMetaType
//
// x-displayName: "Create Metadata"
// ObjectCreateMetaType is metadata that can be specified in Create request of an object.
type ObjectCreateMetaType struct {
	// name
	//
	// x-displayName: "Name"
	// x-example: "acmecorp-web"
	// x-required
	// The configuration object will be created with name. It has to be unique within the namespace.
	// The value of name has to follow DNS-1035 format.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "staging"
	// This defines the workspace within which each the configuration object is to be created.
	// Must be a DNS_LABEL format. For a namespace object itself, namespace value will be ""
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// labels
	//
	// x-displayName: "Labels"
	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects as chosen by the user. Values specified here will be used
	// by selector expression
	Labels map[string]string `protobuf:"bytes,4,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// annotations
	//
	// x-displayName: "Annotation"
	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	Annotations map[string]string `protobuf:"bytes,5,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// description
	//
	// x-displayName: "Description"
	// x-example: "Virtual Host for acmecorp website"
	// Human readable description for the object
	Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	// disable
	//
	// x-displayName: "Disable"
	// A value of true will administratively disable the object
	Disable bool `protobuf:"varint,7,opt,name=disable,proto3" json:"disable,omitempty"`
}

func (m *ObjectCreateMetaType) Reset()      { *m = ObjectCreateMetaType{} }
func (*ObjectCreateMetaType) ProtoMessage() {}
func (*ObjectCreateMetaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{12}
}
func (m *ObjectCreateMetaType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectCreateMetaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ObjectCreateMetaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectCreateMetaType.Merge(m, src)
}
func (m *ObjectCreateMetaType) XXX_Size() int {
	return m.Size()
}
func (m *ObjectCreateMetaType) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectCreateMetaType.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectCreateMetaType proto.InternalMessageInfo

func (m *ObjectCreateMetaType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ObjectCreateMetaType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ObjectCreateMetaType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ObjectCreateMetaType) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ObjectCreateMetaType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ObjectCreateMetaType) GetDisable() bool {
	if m != nil {
		return m.Disable
	}
	return false
}

// ObjectReplaceMetaType
//
// x-displayName: "Replace Metadata"
// ObjectReplaceMetaType is metadata that can be specified in Replace request of an object.
type ObjectReplaceMetaType struct {
	// name
	//
	// x-displayName: "Name"
	// x-example: "acmecorp-web"
	// The configuration object to be replaced will be looked up by name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "staging"
	// This defines the workspace within which each the configuration object is to be created.
	// Must be a DNS_LABEL format. For a namespace object itself, namespace value will be ""
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// labels
	//
	// x-displayName: "Labels"
	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects as chosen by the user. Values specified here will be used
	// by selector expression
	Labels map[string]string `protobuf:"bytes,3,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// annotations
	//
	// x-displayName: "Annotations"
	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	Annotations map[string]string `protobuf:"bytes,4,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// description
	//
	// x-displayName: "Description"
	// x-example: "Virtual Host for acmecorp website"
	// Human readable description for the object
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	// disable
	//
	// x-displayName: "Disable"
	// A value of true will administratively disable the object
	Disable bool `protobuf:"varint,6,opt,name=disable,proto3" json:"disable,omitempty"`
}

func (m *ObjectReplaceMetaType) Reset()      { *m = ObjectReplaceMetaType{} }
func (*ObjectReplaceMetaType) ProtoMessage() {}
func (*ObjectReplaceMetaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{13}
}
func (m *ObjectReplaceMetaType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectReplaceMetaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ObjectReplaceMetaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectReplaceMetaType.Merge(m, src)
}
func (m *ObjectReplaceMetaType) XXX_Size() int {
	return m.Size()
}
func (m *ObjectReplaceMetaType) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectReplaceMetaType.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectReplaceMetaType proto.InternalMessageInfo

func (m *ObjectReplaceMetaType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ObjectReplaceMetaType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ObjectReplaceMetaType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ObjectReplaceMetaType) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *ObjectReplaceMetaType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ObjectReplaceMetaType) GetDisable() bool {
	if m != nil {
		return m.Disable
	}
	return false
}

// MessageMetaType
//
// x-displayName: "Message Metadata"
// MessageMetaType is metadata (common attributes) of a message that only certain messages
// have. This information is propagated to the metadata of a child object that gets created
// from the containing message during view processing.
// The information in this type can be specified by user during create and replace APIs.
type MessageMetaType struct {
	// name
	//
	// x-displayName: "Name"
	// x-example: "acmecorp-web"
	// x-required
	// This is the name of the message.
	// The value of name has to follow DNS-1035 format.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// description
	//
	// x-displayName: "Description"
	// x-example: "Virtual Host for acmecorp website"
	// Human readable description.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// disable
	//
	// x-displayName: "Disable"
	// x-example: "true"
	// A value of true will administratively disable the object that corresponds to the containing message.
	Disable bool `protobuf:"varint,3,opt,name=disable,proto3" json:"disable,omitempty"`
}

func (m *MessageMetaType) Reset()      { *m = MessageMetaType{} }
func (*MessageMetaType) ProtoMessage() {}
func (*MessageMetaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{14}
}
func (m *MessageMetaType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageMetaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MessageMetaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageMetaType.Merge(m, src)
}
func (m *MessageMetaType) XXX_Size() int {
	return m.Size()
}
func (m *MessageMetaType) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageMetaType.DiscardUnknown(m)
}

var xxx_messageInfo_MessageMetaType proto.InternalMessageInfo

func (m *MessageMetaType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MessageMetaType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MessageMetaType) GetDisable() bool {
	if m != nil {
		return m.Disable
	}
	return false
}

// ViewRefType
//
// x-displayName: "View Reference"
// ViewRefType represents a reference to a view
type ViewRefType struct {
	// kind
	//
	// x-displayName: "Kind"
	// x-example: "http_proxy"
	// Kind of the view object
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// uid
	//
	// x-displayName: "UID"
	// x-example: "f3744323-1adf-4aaa-a5dc-0707c1d1bd82"
	// UID of the view object
	Uid string `protobuf:"bytes,2,opt,name=uid,proto3" json:"uid,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "ns1"
	// When a configuration object(e.g. virtual_host) refers to another(e.g route)
	// then namespace will hold the referred object's(e.g. route's) namespace.
	Namespace string `protobuf:"bytes,4,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// name
	//
	// x-displayName: "Name"
	// x-example: "contactus-route"
	// When a configuration object(e.g. virtual_host) refers to another(e.g route)
	// then name will hold the referred object's(e.g. route's) name.
	Name string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ViewRefType) Reset()      { *m = ViewRefType{} }
func (*ViewRefType) ProtoMessage() {}
func (*ViewRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{15}
}
func (m *ViewRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ViewRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewRefType.Merge(m, src)
}
func (m *ViewRefType) XXX_Size() int {
	return m.Size()
}
func (m *ViewRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewRefType.DiscardUnknown(m)
}

var xxx_messageInfo_ViewRefType proto.InternalMessageInfo

func (m *ViewRefType) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *ViewRefType) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *ViewRefType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ViewRefType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// KubeRefType
//
// x-displayName: "Kubernetes Reference"
// KubeRefType represents a reference to a Kubernetes (K8s) object
type KubeRefType struct {
	// kind
	//
	// x-displayName: "Kind"
	// x-example: "Deployment"
	// Kind of the kubernetes object
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace"
	// x-example: "ns1"
	// Namespace of the kubernetes object
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// name
	//
	// x-displayName: "Name"
	// x-example: "adservice"
	// Name of the kubernetes object
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *KubeRefType) Reset()      { *m = KubeRefType{} }
func (*KubeRefType) ProtoMessage() {}
func (*KubeRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{16}
}
func (m *KubeRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubeRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *KubeRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubeRefType.Merge(m, src)
}
func (m *KubeRefType) XXX_Size() int {
	return m.Size()
}
func (m *KubeRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_KubeRefType.DiscardUnknown(m)
}

var xxx_messageInfo_KubeRefType proto.InternalMessageInfo

func (m *KubeRefType) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *KubeRefType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *KubeRefType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// SystemObjectMetaType
//
// x-displayName: "System Metadata"
// SystemObjectMetaType is metadata generated or populated by the system for all persisted objects and
// cannot be updated directly by users.
type SystemObjectMetaType struct {
	// uid
	//
	// x-displayName: "UID"
	// x-example: "d15f1fad-4d37-48c0-8706-df1824d76d31"
	// uid is the unique in time and space value for this object. It is generated by
	// the server on successful creation of an object and is not allowed to change on Replace
	// API. The value of is taken from uid field of ObjectMetaType, if provided.
	Uid string `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// creation_timestamp
	//
	// x-displayName: "Creation Timestamp"
	// CreationTimestamp is a timestamp representing the server time when this object was
	// created. It is not guaranteed to be set in happens-before order across separate operations.
	// Clients may not set this value. It is represented in RFC3339 form and is in UTC.
	CreationTimestamp *types.Timestamp `protobuf:"bytes,3,opt,name=creation_timestamp,json=creationTimestamp,proto3" json:"creation_timestamp,omitempty"`
	// deletion_timestamp
	//
	// x-displayName: "Deletion Timestamp"
	// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
	// field is set by the server when a graceful deletion is requested by the user, and is not
	// directly settable by a client. The resource is expected to be deleted (no longer visible
	// from resource lists, and not reachable by name) after the time in this field, once the
	// finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
	// Once the deletionTimestamp is set, this value may not be unset or be set further into the
	// future, although it may be shortened or the resource may be deleted prior to this time.
	// For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
	// by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
	// the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
	// remove the pod from the API. In the presence of network partitions, this object may still
	// exist after this timestamp, until an administrator or automated process can determine the
	// resource is fully terminated.
	// If not set, graceful deletion of the object has not been requested.
	//
	// Populated by the system when a graceful deletion is requested.
	// Read-only.
	DeletionTimestamp *types.Timestamp `protobuf:"bytes,4,opt,name=deletion_timestamp,json=deletionTimestamp,proto3" json:"deletion_timestamp,omitempty"`
	// modification_timestamp
	//
	// x-displayName: "Modification Timestamp"
	// ModificationTimestamp is a timestamp representing the server time when this object was
	// last modified.
	ModificationTimestamp *types.Timestamp `protobuf:"bytes,5,opt,name=modification_timestamp,json=modificationTimestamp,proto3" json:"modification_timestamp,omitempty"`
	// initializers
	//
	// x-displayName: "Initializers"
	// An initializer is a controller which enforces some system invariant at object creation time.
	// This field is a list of initializers that have not yet acted on this object. If nil or empty,
	// this object has been completely initialized. Otherwise, the object is considered uninitialized
	// and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to
	// observe uninitialized objects.
	//
	// When an object is created, the system will populate this list with the current set of initializers.
	// Only privileged users may set or modify this list. Once it is empty, it may not be modified further
	// by any user.
	Initializers *InitializersType `protobuf:"bytes,6,opt,name=initializers,proto3" json:"initializers,omitempty"`
	// finalizers
	//
	// x-displayName: "Finalizers"
	// x-example: "value"
	// Must be empty before the object is deleted from the registry. Each entry
	// is an identifier for the responsible component that will remove the entry
	// from the list. If the deletionTimestamp of the object is non-nil, entries
	// in this list can only be removed.
	Finalizers []string `protobuf:"bytes,7,rep,name=finalizers,proto3" json:"finalizers,omitempty"`
	// tenant
	//
	// x-displayName: "Tenant"
	// x-example: "acmecorp"
	// Tenant to which this configuration object belongs to. The value for this is found from
	// presented credentials.
	Tenant string `protobuf:"bytes,8,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// creator_class
	//
	// x-displayName: "Creator Class"
	// x-example: "value"
	// A value identifying the class of the user or service which created this configuration object.
	CreatorClass string `protobuf:"bytes,9,opt,name=creator_class,json=creatorClass,proto3" json:"creator_class,omitempty"`
	// creator_id
	//
	// x-displayName: "Creator ID"
	// x-example: "value"
	// A value identifying the exact user or service that created this configuration object
	CreatorId string `protobuf:"bytes,10,opt,name=creator_id,json=creatorId,proto3" json:"creator_id,omitempty"`
	// creator_cookie
	//
	// x-displayName: "Creator Cookie"
	// x-example: "value"
	// This can used by the creator of the object for later audit for e.g. by storing the
	// version identifying information of the object so at future it can be determined if
	// version present at remote end is current or stale.
	CreatorCookie string `protobuf:"bytes,14,opt,name=creator_cookie,json=creatorCookie,proto3" json:"creator_cookie,omitempty"`
	// trace_info
	//
	// x-displayName: "Trace Info"
	// x-example: "value"
	// trace_info holds information(<trace-id>:<span-id>:<parent-span-id>) of the request doing
	// the object modification. This can be used on the watch side to create subsequent spans.
	// This information can be used to co-relate activities across services (modulo state compression)
	// for a synchronous API.
	TraceInfo string `protobuf:"bytes,11,opt,name=trace_info,json=traceInfo,proto3" json:"trace_info,omitempty"`
	// object_index
	//
	// x-displayName: "Object Index"
	// x-example: "0"
	// Unique index for the object. Some objects need a unique integer index to be allocated
	// for each object type. This field will be populated for all objects that need it and will
	// be zero otherwise.
	ObjectIndex uint32 `protobuf:"varint,12,opt,name=object_index,json=objectIndex,proto3" json:"object_index,omitempty"`
	// namespace
	//
	// x-displayName: "Namespace Reference"
	// The namespace this object belongs to. This is populated by the service based on the
	// metadata.namespace field when an object is created.
	Namespace []*ObjectRefType `protobuf:"bytes,13,rep,name=namespace,proto3" json:"namespace,omitempty"`
	// owner_view
	//
	// x-displayName: "Owner View"
	// Reference to the view object that owns this object.
	// If there is no view owner, this field will be nil.
	// If not nil, this object can only be edited/deleted through the view
	OwnerView *ViewRefType `protobuf:"bytes,15,opt,name=owner_view,json=ownerView,proto3" json:"owner_view,omitempty"`
	// sre_disable
	//
	// x-displayName: "SRE Disable"
	// x-example: "true"
	// This should be set to true If VES/SRE operator wants to suppress an object from being
	// presented to business-logic of a daemon(e.g. due to bad-form/issue-causing Object).
	// This is meant only to be used in temporary situations for operational continuity till
	// a fix is rolled out in business-logic.
	SreDisable bool `protobuf:"varint,16,opt,name=sre_disable,json=sreDisable,proto3" json:"sre_disable,omitempty"`
	// vtrp_id
	//
	// x-displayName: "VTRP ID"
	// Indicate origin of this object.
	VtrpId string `protobuf:"bytes,17,opt,name=vtrp_id,json=vtrpId,proto3" json:"vtrp_id,omitempty"`
}

func (m *SystemObjectMetaType) Reset()      { *m = SystemObjectMetaType{} }
func (*SystemObjectMetaType) ProtoMessage() {}
func (*SystemObjectMetaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{17}
}
func (m *SystemObjectMetaType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SystemObjectMetaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SystemObjectMetaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SystemObjectMetaType.Merge(m, src)
}
func (m *SystemObjectMetaType) XXX_Size() int {
	return m.Size()
}
func (m *SystemObjectMetaType) XXX_DiscardUnknown() {
	xxx_messageInfo_SystemObjectMetaType.DiscardUnknown(m)
}

var xxx_messageInfo_SystemObjectMetaType proto.InternalMessageInfo

func (m *SystemObjectMetaType) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *SystemObjectMetaType) GetCreationTimestamp() *types.Timestamp {
	if m != nil {
		return m.CreationTimestamp
	}
	return nil
}

func (m *SystemObjectMetaType) GetDeletionTimestamp() *types.Timestamp {
	if m != nil {
		return m.DeletionTimestamp
	}
	return nil
}

func (m *SystemObjectMetaType) GetModificationTimestamp() *types.Timestamp {
	if m != nil {
		return m.ModificationTimestamp
	}
	return nil
}

func (m *SystemObjectMetaType) GetInitializers() *InitializersType {
	if m != nil {
		return m.Initializers
	}
	return nil
}

func (m *SystemObjectMetaType) GetFinalizers() []string {
	if m != nil {
		return m.Finalizers
	}
	return nil
}

func (m *SystemObjectMetaType) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *SystemObjectMetaType) GetCreatorClass() string {
	if m != nil {
		return m.CreatorClass
	}
	return ""
}

func (m *SystemObjectMetaType) GetCreatorId() string {
	if m != nil {
		return m.CreatorId
	}
	return ""
}

func (m *SystemObjectMetaType) GetCreatorCookie() string {
	if m != nil {
		return m.CreatorCookie
	}
	return ""
}

func (m *SystemObjectMetaType) GetTraceInfo() string {
	if m != nil {
		return m.TraceInfo
	}
	return ""
}

func (m *SystemObjectMetaType) GetObjectIndex() uint32 {
	if m != nil {
		return m.ObjectIndex
	}
	return 0
}

func (m *SystemObjectMetaType) GetNamespace() []*ObjectRefType {
	if m != nil {
		return m.Namespace
	}
	return nil
}

func (m *SystemObjectMetaType) GetOwnerView() *ViewRefType {
	if m != nil {
		return m.OwnerView
	}
	return nil
}

func (m *SystemObjectMetaType) GetSreDisable() bool {
	if m != nil {
		return m.SreDisable
	}
	return false
}

func (m *SystemObjectMetaType) GetVtrpId() string {
	if m != nil {
		return m.VtrpId
	}
	return ""
}

// SystemObjectGetMetaType
//
// x-displayName: "System Metadata"
// SystemObjectGetMetaType is metadata generated or populated by the system for all persisted objects and
// cannot be updated directly by users.
type SystemObjectGetMetaType struct {
	// uid
	//
	// x-displayName: "UID"
	// x-example: "d15f1fad-4d37-48c0-8706-df1824d76d31"
	// uid is the unique in time and space value for this object. It is generated by
	// the server on successful creation of an object and is not allowed to change on Replace
	// API. The value of is taken from uid field of ObjectMetaType, if provided.
	Uid string `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// creation_timestamp
	//
	// x-displayName: "Creation Timestamp"
	// CreationTimestamp is a timestamp representing the server time when this object was
	// created. It is not guaranteed to be set in happens-before order across separate operations.
	// Clients may not set this value. It is represented in RFC3339 form and is in UTC.
	CreationTimestamp *types.Timestamp `protobuf:"bytes,3,opt,name=creation_timestamp,json=creationTimestamp,proto3" json:"creation_timestamp,omitempty"`
	// deletion_timestamp
	//
	// x-displayName: "Deletion Timestamp"
	// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
	// field is set by the server when a graceful deletion is requested by the user, and is not
	// directly settable by a client. The resource is expected to be deleted (no longer visible
	// from resource lists, and not reachable by name) after the time in this field, once the
	// finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
	// Once the deletionTimestamp is set, this value may not be unset or be set further into the
	// future, although it may be shortened or the resource may be deleted prior to this time.
	// For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
	// by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
	// the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
	// remove the pod from the API. In the presence of network partitions, this object may still
	// exist after this timestamp, until an administrator or automated process can determine the
	// resource is fully terminated.
	// If not set, graceful deletion of the object has not been requested.
	//
	// Populated by the system when a graceful deletion is requested.
	// Read-only.
	DeletionTimestamp *types.Timestamp `protobuf:"bytes,4,opt,name=deletion_timestamp,json=deletionTimestamp,proto3" json:"deletion_timestamp,omitempty"`
	// modification_timestamp
	//
	// x-displayName: "Modification Timestamp"
	// ModificationTimestamp is a timestamp representing the server time when this object was
	// last modified.
	ModificationTimestamp *types.Timestamp `protobuf:"bytes,5,opt,name=modification_timestamp,json=modificationTimestamp,proto3" json:"modification_timestamp,omitempty"`
	// initializers
	//
	// x-displayName: "Initializers"
	// An initializer is a controller which enforces some system invariant at object creation time.
	// This field is a list of initializers that have not yet acted on this object. If nil or empty,
	// this object has been completely initialized. Otherwise, the object is considered uninitialized
	// and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to
	// observe uninitialized objects.
	//
	// When an object is created, the system will populate this list with the current set of initializers.
	// Only privileged users may set or modify this list. Once it is empty, it may not be modified further
	// by any user.
	Initializers *InitializersType `protobuf:"bytes,6,opt,name=initializers,proto3" json:"initializers,omitempty"`
	// finalizers
	//
	// x-displayName: "Finalizers"
	// x-example: "value"
	// Must be empty before the object is deleted from the registry. Each entry
	// is an identifier for the responsible component that will remove the entry
	// from the list. If the deletionTimestamp of the object is non-nil, entries
	// in this list can only be removed.
	Finalizers []string `protobuf:"bytes,7,rep,name=finalizers,proto3" json:"finalizers,omitempty"`
	// tenant
	//
	// x-displayName: "Tenant"
	// x-example: "acmecorp"
	// Tenant to which this configuration object belongs to. The value for this is found from
	// presented credentials.
	Tenant string `protobuf:"bytes,8,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// creator_class
	//
	// x-displayName: "Creator Class"
	// x-example: "prism"
	// A value identifying the class of the user or service which created this configuration object.
	CreatorClass string `protobuf:"bytes,9,opt,name=creator_class,json=creatorClass,proto3" json:"creator_class,omitempty"`
	// creator_id
	//
	// x-displayName: "Creator ID"
	// x-example: "admin@acmecorp.com"
	// A value identifying the exact user or service that created this configuration object
	CreatorId string `protobuf:"bytes,10,opt,name=creator_id,json=creatorId,proto3" json:"creator_id,omitempty"`
	// object_index
	//
	// x-displayName: "Object Index"
	// x-example: "0"
	// Unique index for the object. Some objects need a unique integer index to be allocated
	// for each object type. This field will be populated for all objects that need it and will
	// be zero otherwise.
	ObjectIndex uint32 `protobuf:"varint,12,opt,name=object_index,json=objectIndex,proto3" json:"object_index,omitempty"`
	// owner_view
	//
	// x-displayName: "Owner View"
	// Reference to the view object that owns this object.
	// If there is no view owner, this field will be nil.
	// If not nil, this object can only be edited/deleted through the view
	OwnerView *ViewRefType `protobuf:"bytes,15,opt,name=owner_view,json=ownerView,proto3" json:"owner_view,omitempty"`
}

func (m *SystemObjectGetMetaType) Reset()      { *m = SystemObjectGetMetaType{} }
func (*SystemObjectGetMetaType) ProtoMessage() {}
func (*SystemObjectGetMetaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{18}
}
func (m *SystemObjectGetMetaType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SystemObjectGetMetaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SystemObjectGetMetaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SystemObjectGetMetaType.Merge(m, src)
}
func (m *SystemObjectGetMetaType) XXX_Size() int {
	return m.Size()
}
func (m *SystemObjectGetMetaType) XXX_DiscardUnknown() {
	xxx_messageInfo_SystemObjectGetMetaType.DiscardUnknown(m)
}

var xxx_messageInfo_SystemObjectGetMetaType proto.InternalMessageInfo

func (m *SystemObjectGetMetaType) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *SystemObjectGetMetaType) GetCreationTimestamp() *types.Timestamp {
	if m != nil {
		return m.CreationTimestamp
	}
	return nil
}

func (m *SystemObjectGetMetaType) GetDeletionTimestamp() *types.Timestamp {
	if m != nil {
		return m.DeletionTimestamp
	}
	return nil
}

func (m *SystemObjectGetMetaType) GetModificationTimestamp() *types.Timestamp {
	if m != nil {
		return m.ModificationTimestamp
	}
	return nil
}

func (m *SystemObjectGetMetaType) GetInitializers() *InitializersType {
	if m != nil {
		return m.Initializers
	}
	return nil
}

func (m *SystemObjectGetMetaType) GetFinalizers() []string {
	if m != nil {
		return m.Finalizers
	}
	return nil
}

func (m *SystemObjectGetMetaType) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *SystemObjectGetMetaType) GetCreatorClass() string {
	if m != nil {
		return m.CreatorClass
	}
	return ""
}

func (m *SystemObjectGetMetaType) GetCreatorId() string {
	if m != nil {
		return m.CreatorId
	}
	return ""
}

func (m *SystemObjectGetMetaType) GetObjectIndex() uint32 {
	if m != nil {
		return m.ObjectIndex
	}
	return 0
}

func (m *SystemObjectGetMetaType) GetOwnerView() *ViewRefType {
	if m != nil {
		return m.OwnerView
	}
	return nil
}

// AuthnTypeBasicAuth
//
// x-displayName: "BasicAuth Authentication Parameters"
// AuthnTypeBasicAuth is used for using basic_auth mode of HTTP authentication
type AuthnTypeBasicAuth struct {
	// username
	//
	// x-displayName: "Username"
	// The username to encode in Basic Auth scheme
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	// password
	//
	// x-displayName: "Password"
	// Volterra Secret. The password to encode in Basic Auth scheme
	Password *SecretType `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
}

func (m *AuthnTypeBasicAuth) Reset()      { *m = AuthnTypeBasicAuth{} }
func (*AuthnTypeBasicAuth) ProtoMessage() {}
func (*AuthnTypeBasicAuth) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{19}
}
func (m *AuthnTypeBasicAuth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthnTypeBasicAuth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AuthnTypeBasicAuth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthnTypeBasicAuth.Merge(m, src)
}
func (m *AuthnTypeBasicAuth) XXX_Size() int {
	return m.Size()
}
func (m *AuthnTypeBasicAuth) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthnTypeBasicAuth.DiscardUnknown(m)
}

var xxx_messageInfo_AuthnTypeBasicAuth proto.InternalMessageInfo

func (m *AuthnTypeBasicAuth) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *AuthnTypeBasicAuth) GetPassword() *SecretType {
	if m != nil {
		return m.Password
	}
	return nil
}

// AuthnTypeHeaders
//
// x-displayName: "Authentication Headers"
// AuthnTypeHeaders is used for setting headers for authentication
type AuthnTypeHeaders struct {
	// headers
	//
	// x-displayName: "Headers"
	// The set of authentication headers to pass in HTTP request
	Headers map[string]*SecretType `protobuf:"bytes,1,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *AuthnTypeHeaders) Reset()      { *m = AuthnTypeHeaders{} }
func (*AuthnTypeHeaders) ProtoMessage() {}
func (*AuthnTypeHeaders) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{20}
}
func (m *AuthnTypeHeaders) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthnTypeHeaders) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AuthnTypeHeaders) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthnTypeHeaders.Merge(m, src)
}
func (m *AuthnTypeHeaders) XXX_Size() int {
	return m.Size()
}
func (m *AuthnTypeHeaders) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthnTypeHeaders.DiscardUnknown(m)
}

var xxx_messageInfo_AuthnTypeHeaders proto.InternalMessageInfo

func (m *AuthnTypeHeaders) GetHeaders() map[string]*SecretType {
	if m != nil {
		return m.Headers
	}
	return nil
}

// AuthnTypeQueryParams
//
// x-displayName: "Authentication QueryParams"
// AuthnTypeQueryParams is used for setting query_params for authentication
type AuthnTypeQueryParams struct {
	// query_params
	//
	// x-displayName: "Query Parameters"
	// The set of authentication parameters to be passed as query parameters
	QueryParams map[string]*SecretType `protobuf:"bytes,1,rep,name=query_params,json=queryParams,proto3" json:"query_params,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *AuthnTypeQueryParams) Reset()      { *m = AuthnTypeQueryParams{} }
func (*AuthnTypeQueryParams) ProtoMessage() {}
func (*AuthnTypeQueryParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{21}
}
func (m *AuthnTypeQueryParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthnTypeQueryParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AuthnTypeQueryParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthnTypeQueryParams.Merge(m, src)
}
func (m *AuthnTypeQueryParams) XXX_Size() int {
	return m.Size()
}
func (m *AuthnTypeQueryParams) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthnTypeQueryParams.DiscardUnknown(m)
}

var xxx_messageInfo_AuthnTypeQueryParams proto.InternalMessageInfo

func (m *AuthnTypeQueryParams) GetQueryParams() map[string]*SecretType {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

// BlindfoldSecretInfoType
//
// x-displayName: "Blindfold Secret"
// BlindfoldSecretInfoType specifies information about the Secret managed by Volterra Secret Management
type BlindfoldSecretInfoType struct {
	// Decryption Provider
	//
	// x-displayName: "Decryption Provider"
	// Name of the Secret Management Access object that contains information about the backend Secret Management service.
	DecryptionProvider string `protobuf:"bytes,1,opt,name=decryption_provider,json=decryptionProvider,proto3" json:"decryption_provider,omitempty"`
	// Store Provider
	//
	// x-displayName: "Store Provider"
	// Name of the Secret Management Access object that contains information about the store to get encrypted bytes
	// This field needs to be provided only if the url scheme is not string:///
	StoreProvider string `protobuf:"bytes,2,opt,name=store_provider,json=storeProvider,proto3" json:"store_provider,omitempty"`
	// Location
	//
	// x-displayName: "Location"
	// x-required
	// x-example: "string:///U2VjcmV0SW5mb3JtYXRpb24="
	// Location is the uri_ref. It could be in url format for string:///
	// Or it could be a path if the store provider is an http/https location
	Location string `protobuf:"bytes,3,opt,name=location,proto3" json:"location,omitempty"`
}

func (m *BlindfoldSecretInfoType) Reset()      { *m = BlindfoldSecretInfoType{} }
func (*BlindfoldSecretInfoType) ProtoMessage() {}
func (*BlindfoldSecretInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{22}
}
func (m *BlindfoldSecretInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlindfoldSecretInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BlindfoldSecretInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlindfoldSecretInfoType.Merge(m, src)
}
func (m *BlindfoldSecretInfoType) XXX_Size() int {
	return m.Size()
}
func (m *BlindfoldSecretInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_BlindfoldSecretInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_BlindfoldSecretInfoType proto.InternalMessageInfo

func (m *BlindfoldSecretInfoType) GetDecryptionProvider() string {
	if m != nil {
		return m.DecryptionProvider
	}
	return ""
}

func (m *BlindfoldSecretInfoType) GetStoreProvider() string {
	if m != nil {
		return m.StoreProvider
	}
	return ""
}

func (m *BlindfoldSecretInfoType) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

// VaultSecretInfoType
//
// x-displayName: "Vault Secret"
// VaultSecretInfoType specifies information about the Secret managed by Hashicorp Vault.
type VaultSecretInfoType struct {
	// Provider
	//
	// x-displayName: "Provider"
	// x-required
	// x-example: "vault-vh-provider"
	// Name of the Secret Management Access object that contains information about the backend Vault.
	Provider string `protobuf:"bytes,1,opt,name=provider,proto3" json:"provider,omitempty"`
	// Location
	//
	// x-displayName: "Location"
	// x-required
	// x-example: "v1/data/vhost_key"
	// Path to secret in Vault.
	Location string `protobuf:"bytes,2,opt,name=location,proto3" json:"location,omitempty"`
	// Key
	//
	// x-displayName: "Key"
	// x-example: "key_pem"
	// Key of the individual secret. Vault Secrets are stored as key-value pair.
	// If user is only interested in one value from the map, this field should be set to the corresponding key.
	// If not provided entire secret will be returned.
	Key string `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	// Version
	//
	// x-displayName: "Version"
	// x-example: "1"
	// Version of the secret to be fetched. As vault secrets are versioned, user can specify this field to fetch specific version.
	// If not provided latest version will be returned.
	Version uint32 `protobuf:"varint,4,opt,name=version,proto3" json:"version,omitempty"`
	// secret_encoding
	//
	// x-displayName: "Secret Encoding"
	// This field defines the encoding type of the secret BEFORE the secret is put into Hashicorp Vault.
	SecretEncoding SecretEncodingType `protobuf:"varint,5,opt,name=secret_encoding,json=secretEncoding,proto3,enum=ves.io.schema.SecretEncodingType" json:"secret_encoding,omitempty"`
}

func (m *VaultSecretInfoType) Reset()      { *m = VaultSecretInfoType{} }
func (*VaultSecretInfoType) ProtoMessage() {}
func (*VaultSecretInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{23}
}
func (m *VaultSecretInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VaultSecretInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VaultSecretInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VaultSecretInfoType.Merge(m, src)
}
func (m *VaultSecretInfoType) XXX_Size() int {
	return m.Size()
}
func (m *VaultSecretInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_VaultSecretInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_VaultSecretInfoType proto.InternalMessageInfo

func (m *VaultSecretInfoType) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *VaultSecretInfoType) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *VaultSecretInfoType) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *VaultSecretInfoType) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *VaultSecretInfoType) GetSecretEncoding() SecretEncodingType {
	if m != nil {
		return m.SecretEncoding
	}
	return EncodingNone
}

// ClearSecretInfoType
//
// x-displayName: "In-Clear Secret"
// ClearSecretInfoType specifies information about the Secret that is not encrypted.
type ClearSecretInfoType struct {
	// Provider
	//
	// x-displayName: "Provider"
	// x-example: "box-provider"
	// Name of the Secret Management Access object that contains information about the store to get encrypted bytes
	// This field needs to be provided only if the url scheme is not string:///
	Provider string `protobuf:"bytes,1,opt,name=provider,proto3" json:"provider,omitempty"`
	// URL
	//
	// x-displayName: "URL"
	// x-required
	// x-example: "string:///U2VjcmV0SW5mb3JtYXRpb24="
	// URL of the secret. Currently supported URL schemes is string:///.
	// For string:/// scheme, Secret needs to be encoded Base64 format.
	// When asked for this secret, caller will get Secret bytes after Base64 decoding.
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *ClearSecretInfoType) Reset()      { *m = ClearSecretInfoType{} }
func (*ClearSecretInfoType) ProtoMessage() {}
func (*ClearSecretInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{24}
}
func (m *ClearSecretInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearSecretInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ClearSecretInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearSecretInfoType.Merge(m, src)
}
func (m *ClearSecretInfoType) XXX_Size() int {
	return m.Size()
}
func (m *ClearSecretInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearSecretInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_ClearSecretInfoType proto.InternalMessageInfo

func (m *ClearSecretInfoType) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *ClearSecretInfoType) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// WingmanSecretInfoType
//
// x-displayName: "Wingman Secret"
// WingmanSecretInfoType specifies the handle to the wingman secret
type WingmanSecretInfoType struct {
	// Name
	//
	// x-displayName: "Name"
	// x-required
	// x-example: "ChargeBack-API-Key"
	// Name of the secret.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *WingmanSecretInfoType) Reset()      { *m = WingmanSecretInfoType{} }
func (*WingmanSecretInfoType) ProtoMessage() {}
func (*WingmanSecretInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{25}
}
func (m *WingmanSecretInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WingmanSecretInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WingmanSecretInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WingmanSecretInfoType.Merge(m, src)
}
func (m *WingmanSecretInfoType) XXX_Size() int {
	return m.Size()
}
func (m *WingmanSecretInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_WingmanSecretInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_WingmanSecretInfoType proto.InternalMessageInfo

func (m *WingmanSecretInfoType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// SecretType
//
// x-displayName: "Secret"
// SecretType is used in an object to indicate a sensitive/confidential field
type SecretType struct {
	// SecretInfoOneof
	//
	// x-displayName: "Secret Info"
	// x-required
	// Secret can be one of the following types -
	// * Blindfold Secret - Secret is managed by Volterra Secret Management System
	// * Clear Secret - Secret is not encrypted
	//
	// Types that are valid to be assigned to SecretInfoOneof:
	//	*SecretType_BlindfoldSecretInfo
	//	*SecretType_VaultSecretInfo
	//	*SecretType_ClearSecretInfo
	//	*SecretType_WingmanSecretInfo
	SecretInfoOneof isSecretType_SecretInfoOneof `protobuf_oneof:"secret_info_oneof"`
	// Blindfold Secret Internal
	//
	// x-displayName: "Blindfold Secret Internal"
	// Blindfold Secret Internal is used for the putting re-encrypted blindfold secret
	BlindfoldSecretInfoInternal *BlindfoldSecretInfoType `protobuf:"bytes,10,opt,name=blindfold_secret_info_internal,json=blindfoldSecretInfoInternal,proto3" json:"blindfold_secret_info_internal,omitempty"`
	// secret_encoding_type
	//
	// x-displayName: "Secret Encoding"
	// This field defines the encoding type of the secret BEFORE the secret is given to any Secret Management System.
	// this will be set if the secret is encoded and not plaintext BEFORE it is encrypted and put it in SecretType.
	// Note - Do NOT set this field for Clear Secret with string:/// scheme.
	// e.g. if a secret is base64 encoded and then put into vault.
	SecretEncodingType SecretEncodingType `protobuf:"varint,8,opt,name=secret_encoding_type,json=secretEncodingType,proto3,enum=ves.io.schema.SecretEncodingType" json:"secret_encoding_type,omitempty"` // Deprecated: Do not use.
}

func (m *SecretType) Reset()      { *m = SecretType{} }
func (*SecretType) ProtoMessage() {}
func (*SecretType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{26}
}
func (m *SecretType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecretType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SecretType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecretType.Merge(m, src)
}
func (m *SecretType) XXX_Size() int {
	return m.Size()
}
func (m *SecretType) XXX_DiscardUnknown() {
	xxx_messageInfo_SecretType.DiscardUnknown(m)
}

var xxx_messageInfo_SecretType proto.InternalMessageInfo

type isSecretType_SecretInfoOneof interface {
	isSecretType_SecretInfoOneof()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SecretType_BlindfoldSecretInfo struct {
	BlindfoldSecretInfo *BlindfoldSecretInfoType `protobuf:"bytes,4,opt,name=blindfold_secret_info,json=blindfoldSecretInfo,proto3,oneof" json:"blindfold_secret_info,omitempty"`
}
type SecretType_VaultSecretInfo struct {
	VaultSecretInfo *VaultSecretInfoType `protobuf:"bytes,5,opt,name=vault_secret_info,json=vaultSecretInfo,proto3,oneof" json:"vault_secret_info,omitempty"`
}
type SecretType_ClearSecretInfo struct {
	ClearSecretInfo *ClearSecretInfoType `protobuf:"bytes,6,opt,name=clear_secret_info,json=clearSecretInfo,proto3,oneof" json:"clear_secret_info,omitempty"`
}
type SecretType_WingmanSecretInfo struct {
	WingmanSecretInfo *WingmanSecretInfoType `protobuf:"bytes,7,opt,name=wingman_secret_info,json=wingmanSecretInfo,proto3,oneof" json:"wingman_secret_info,omitempty"`
}

func (*SecretType_BlindfoldSecretInfo) isSecretType_SecretInfoOneof() {}
func (*SecretType_VaultSecretInfo) isSecretType_SecretInfoOneof()     {}
func (*SecretType_ClearSecretInfo) isSecretType_SecretInfoOneof()     {}
func (*SecretType_WingmanSecretInfo) isSecretType_SecretInfoOneof()   {}

func (m *SecretType) GetSecretInfoOneof() isSecretType_SecretInfoOneof {
	if m != nil {
		return m.SecretInfoOneof
	}
	return nil
}

func (m *SecretType) GetBlindfoldSecretInfo() *BlindfoldSecretInfoType {
	if x, ok := m.GetSecretInfoOneof().(*SecretType_BlindfoldSecretInfo); ok {
		return x.BlindfoldSecretInfo
	}
	return nil
}

// Deprecated: Do not use.
func (m *SecretType) GetVaultSecretInfo() *VaultSecretInfoType {
	if x, ok := m.GetSecretInfoOneof().(*SecretType_VaultSecretInfo); ok {
		return x.VaultSecretInfo
	}
	return nil
}

func (m *SecretType) GetClearSecretInfo() *ClearSecretInfoType {
	if x, ok := m.GetSecretInfoOneof().(*SecretType_ClearSecretInfo); ok {
		return x.ClearSecretInfo
	}
	return nil
}

func (m *SecretType) GetWingmanSecretInfo() *WingmanSecretInfoType {
	if x, ok := m.GetSecretInfoOneof().(*SecretType_WingmanSecretInfo); ok {
		return x.WingmanSecretInfo
	}
	return nil
}

func (m *SecretType) GetBlindfoldSecretInfoInternal() *BlindfoldSecretInfoType {
	if m != nil {
		return m.BlindfoldSecretInfoInternal
	}
	return nil
}

// Deprecated: Do not use.
func (m *SecretType) GetSecretEncodingType() SecretEncodingType {
	if m != nil {
		return m.SecretEncodingType
	}
	return EncodingNone
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SecretType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SecretType_BlindfoldSecretInfo)(nil),
		(*SecretType_VaultSecretInfo)(nil),
		(*SecretType_ClearSecretInfo)(nil),
		(*SecretType_WingmanSecretInfo)(nil),
	}
}

// NetworkRefType
//
// x-displayName: "Network Reference"
// This specifies a direct reference to a network configuration object
type NetworkRefType struct {
	// ref
	//
	// x-displayName: "Reference"
	// A virtual network direct reference
	Ref []*ObjectRefType `protobuf:"bytes,1,rep,name=ref,proto3" json:"ref,omitempty"`
}

func (m *NetworkRefType) Reset()      { *m = NetworkRefType{} }
func (*NetworkRefType) ProtoMessage() {}
func (*NetworkRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{27}
}
func (m *NetworkRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NetworkRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkRefType.Merge(m, src)
}
func (m *NetworkRefType) XXX_Size() int {
	return m.Size()
}
func (m *NetworkRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkRefType.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkRefType proto.InternalMessageInfo

func (m *NetworkRefType) GetRef() []*ObjectRefType {
	if m != nil {
		return m.Ref
	}
	return nil
}

// SiteRefType
//
// x-displayName: "Site Reference"
// This specifies a direct reference to a site configuration object
type SiteRefType struct {
	// ref
	//
	// x-displayName: "Reference"
	// A site direct reference
	Ref []*ObjectRefType `protobuf:"bytes,1,rep,name=ref,proto3" json:"ref,omitempty"`
	// network_type
	//
	// x-displayName: "Network Type"
	// The type of network on the referred site
	NetworkType VirtualNetworkType `protobuf:"varint,2,opt,name=network_type,json=networkType,proto3,enum=ves.io.schema.VirtualNetworkType" json:"network_type,omitempty"`
}

func (m *SiteRefType) Reset()      { *m = SiteRefType{} }
func (*SiteRefType) ProtoMessage() {}
func (*SiteRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{28}
}
func (m *SiteRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SiteRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SiteRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SiteRefType.Merge(m, src)
}
func (m *SiteRefType) XXX_Size() int {
	return m.Size()
}
func (m *SiteRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_SiteRefType.DiscardUnknown(m)
}

var xxx_messageInfo_SiteRefType proto.InternalMessageInfo

func (m *SiteRefType) GetRef() []*ObjectRefType {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *SiteRefType) GetNetworkType() VirtualNetworkType {
	if m != nil {
		return m.NetworkType
	}
	return VIRTUAL_NETWORK_SITE_LOCAL
}

// IpPrefixSetRefType
//
// x-displayName: "IP Prefix Set Reference"
// A list of references to ip_prefix_set objects.
type IpPrefixSetRefType struct {
	// ref
	//
	// x-displayName: "Reference"
	// A list of references to ip_prefix_set objects.
	Ref []*ObjectRefType `protobuf:"bytes,1,rep,name=ref,proto3" json:"ref,omitempty"`
}

func (m *IpPrefixSetRefType) Reset()      { *m = IpPrefixSetRefType{} }
func (*IpPrefixSetRefType) ProtoMessage() {}
func (*IpPrefixSetRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{29}
}
func (m *IpPrefixSetRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpPrefixSetRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IpPrefixSetRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpPrefixSetRefType.Merge(m, src)
}
func (m *IpPrefixSetRefType) XXX_Size() int {
	return m.Size()
}
func (m *IpPrefixSetRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_IpPrefixSetRefType.DiscardUnknown(m)
}

var xxx_messageInfo_IpPrefixSetRefType proto.InternalMessageInfo

func (m *IpPrefixSetRefType) GetRef() []*ObjectRefType {
	if m != nil {
		return m.Ref
	}
	return nil
}

// VSiteRefType
//
// x-displayName: "Virtual Site"
// A reference to virtual_site object
type VSiteRefType struct {
	// ref
	//
	// x-displayName: "Reference"
	// A virtual_site direct reference
	Ref []*ObjectRefType `protobuf:"bytes,1,rep,name=ref,proto3" json:"ref,omitempty"`
	// network_type
	//
	// x-displayName: "Network Type"
	// The type of network on the referred virtual_site
	NetworkType VirtualNetworkType `protobuf:"varint,2,opt,name=network_type,json=networkType,proto3,enum=ves.io.schema.VirtualNetworkType" json:"network_type,omitempty"`
}

func (m *VSiteRefType) Reset()      { *m = VSiteRefType{} }
func (*VSiteRefType) ProtoMessage() {}
func (*VSiteRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{30}
}
func (m *VSiteRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VSiteRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VSiteRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VSiteRefType.Merge(m, src)
}
func (m *VSiteRefType) XXX_Size() int {
	return m.Size()
}
func (m *VSiteRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_VSiteRefType.DiscardUnknown(m)
}

var xxx_messageInfo_VSiteRefType proto.InternalMessageInfo

func (m *VSiteRefType) GetRef() []*ObjectRefType {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *VSiteRefType) GetNetworkType() VirtualNetworkType {
	if m != nil {
		return m.NetworkType
	}
	return VIRTUAL_NETWORK_SITE_LOCAL
}

// PolicerRefType
//
// x-displayName: "Policer Reference"
// Reference to policer object
type PolicerRefType struct {
	// ref
	//
	// x-displayName: "Reference"
	// A policer direct reference
	Ref []*ObjectRefType `protobuf:"bytes,1,rep,name=ref,proto3" json:"ref,omitempty"`
}

func (m *PolicerRefType) Reset()      { *m = PolicerRefType{} }
func (*PolicerRefType) ProtoMessage() {}
func (*PolicerRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{31}
}
func (m *PolicerRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicerRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PolicerRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicerRefType.Merge(m, src)
}
func (m *PolicerRefType) XXX_Size() int {
	return m.Size()
}
func (m *PolicerRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicerRefType.DiscardUnknown(m)
}

var xxx_messageInfo_PolicerRefType proto.InternalMessageInfo

func (m *PolicerRefType) GetRef() []*ObjectRefType {
	if m != nil {
		return m.Ref
	}
	return nil
}

// ProtocolPolicerRefType
//
// x-displayName: "Protocol Policer Reference"
// Reference to policer object
type ProtocolPolicerRefType struct {
	// ref
	//
	// x-displayName: "Protocol policer Reference"
	// Reference to protocol policer object
	Ref []*ObjectRefType `protobuf:"bytes,1,rep,name=ref,proto3" json:"ref,omitempty"`
}

func (m *ProtocolPolicerRefType) Reset()      { *m = ProtocolPolicerRefType{} }
func (*ProtocolPolicerRefType) ProtoMessage() {}
func (*ProtocolPolicerRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{32}
}
func (m *ProtocolPolicerRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtocolPolicerRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ProtocolPolicerRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtocolPolicerRefType.Merge(m, src)
}
func (m *ProtocolPolicerRefType) XXX_Size() int {
	return m.Size()
}
func (m *ProtocolPolicerRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtocolPolicerRefType.DiscardUnknown(m)
}

var xxx_messageInfo_ProtocolPolicerRefType proto.InternalMessageInfo

func (m *ProtocolPolicerRefType) GetRef() []*ObjectRefType {
	if m != nil {
		return m.Ref
	}
	return nil
}

// NetworkSiteRefSelector
//
// x-displayName: "Network or Site Reference"
// NetworkSiteRefSelector defines a union of reference to site or reference to virtual_network  or reference to virtual_site
// It is used to determine virtual network using following rules
//  * Direct reference to virtual_network object
//  * Site local network when refering to site object
//  * All site local networks for sites selected by refering to virtual_site object
type NetworkSiteRefSelector struct {
	// ref_or_selector
	//
	// x-displayName: "Virtual-Site or Site or Network"
	// One of following
	//
	// Types that are valid to be assigned to RefOrSelector:
	//	*NetworkSiteRefSelector_VirtualNetwork
	//	*NetworkSiteRefSelector_Site
	//	*NetworkSiteRefSelector_VirtualSite
	RefOrSelector isNetworkSiteRefSelector_RefOrSelector `protobuf_oneof:"ref_or_selector"`
}

func (m *NetworkSiteRefSelector) Reset()      { *m = NetworkSiteRefSelector{} }
func (*NetworkSiteRefSelector) ProtoMessage() {}
func (*NetworkSiteRefSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{33}
}
func (m *NetworkSiteRefSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkSiteRefSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NetworkSiteRefSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkSiteRefSelector.Merge(m, src)
}
func (m *NetworkSiteRefSelector) XXX_Size() int {
	return m.Size()
}
func (m *NetworkSiteRefSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkSiteRefSelector.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkSiteRefSelector proto.InternalMessageInfo

type isNetworkSiteRefSelector_RefOrSelector interface {
	isNetworkSiteRefSelector_RefOrSelector()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type NetworkSiteRefSelector_VirtualNetwork struct {
	VirtualNetwork *NetworkRefType `protobuf:"bytes,1,opt,name=virtual_network,json=virtualNetwork,proto3,oneof" json:"virtual_network,omitempty"`
}
type NetworkSiteRefSelector_Site struct {
	Site *SiteRefType `protobuf:"bytes,2,opt,name=site,proto3,oneof" json:"site,omitempty"`
}
type NetworkSiteRefSelector_VirtualSite struct {
	VirtualSite *VSiteRefType `protobuf:"bytes,3,opt,name=virtual_site,json=virtualSite,proto3,oneof" json:"virtual_site,omitempty"`
}

func (*NetworkSiteRefSelector_VirtualNetwork) isNetworkSiteRefSelector_RefOrSelector() {}
func (*NetworkSiteRefSelector_Site) isNetworkSiteRefSelector_RefOrSelector()           {}
func (*NetworkSiteRefSelector_VirtualSite) isNetworkSiteRefSelector_RefOrSelector()    {}

func (m *NetworkSiteRefSelector) GetRefOrSelector() isNetworkSiteRefSelector_RefOrSelector {
	if m != nil {
		return m.RefOrSelector
	}
	return nil
}

func (m *NetworkSiteRefSelector) GetVirtualNetwork() *NetworkRefType {
	if x, ok := m.GetRefOrSelector().(*NetworkSiteRefSelector_VirtualNetwork); ok {
		return x.VirtualNetwork
	}
	return nil
}

func (m *NetworkSiteRefSelector) GetSite() *SiteRefType {
	if x, ok := m.GetRefOrSelector().(*NetworkSiteRefSelector_Site); ok {
		return x.Site
	}
	return nil
}

func (m *NetworkSiteRefSelector) GetVirtualSite() *VSiteRefType {
	if x, ok := m.GetRefOrSelector().(*NetworkSiteRefSelector_VirtualSite); ok {
		return x.VirtualSite
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*NetworkSiteRefSelector) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*NetworkSiteRefSelector_VirtualNetwork)(nil),
		(*NetworkSiteRefSelector_Site)(nil),
		(*NetworkSiteRefSelector_VirtualSite)(nil),
	}
}

// SiteVirtualSiteRefSelector
//
// x-displayName: "Site or Virtual Site Reference"
// VirtualSiteSiteRefSelector defines a union of reference to site  or reference to virtual_site
// It used to refer site or a group of sites indicated by virtual site.
type SiteVirtualSiteRefSelector struct {
	// ref_or_selector
	//
	// x-displayName: "Direct/Selector Reference"
	// One of following
	//
	// Types that are valid to be assigned to RefOrSelector:
	//	*SiteVirtualSiteRefSelector_Site
	//	*SiteVirtualSiteRefSelector_VirtualSite
	RefOrSelector isSiteVirtualSiteRefSelector_RefOrSelector `protobuf_oneof:"ref_or_selector"`
}

func (m *SiteVirtualSiteRefSelector) Reset()      { *m = SiteVirtualSiteRefSelector{} }
func (*SiteVirtualSiteRefSelector) ProtoMessage() {}
func (*SiteVirtualSiteRefSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{34}
}
func (m *SiteVirtualSiteRefSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SiteVirtualSiteRefSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SiteVirtualSiteRefSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SiteVirtualSiteRefSelector.Merge(m, src)
}
func (m *SiteVirtualSiteRefSelector) XXX_Size() int {
	return m.Size()
}
func (m *SiteVirtualSiteRefSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_SiteVirtualSiteRefSelector.DiscardUnknown(m)
}

var xxx_messageInfo_SiteVirtualSiteRefSelector proto.InternalMessageInfo

type isSiteVirtualSiteRefSelector_RefOrSelector interface {
	isSiteVirtualSiteRefSelector_RefOrSelector()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SiteVirtualSiteRefSelector_Site struct {
	Site *SiteRefType `protobuf:"bytes,2,opt,name=site,proto3,oneof" json:"site,omitempty"`
}
type SiteVirtualSiteRefSelector_VirtualSite struct {
	VirtualSite *VSiteRefType `protobuf:"bytes,3,opt,name=virtual_site,json=virtualSite,proto3,oneof" json:"virtual_site,omitempty"`
}

func (*SiteVirtualSiteRefSelector_Site) isSiteVirtualSiteRefSelector_RefOrSelector()        {}
func (*SiteVirtualSiteRefSelector_VirtualSite) isSiteVirtualSiteRefSelector_RefOrSelector() {}

func (m *SiteVirtualSiteRefSelector) GetRefOrSelector() isSiteVirtualSiteRefSelector_RefOrSelector {
	if m != nil {
		return m.RefOrSelector
	}
	return nil
}

func (m *SiteVirtualSiteRefSelector) GetSite() *SiteRefType {
	if x, ok := m.GetRefOrSelector().(*SiteVirtualSiteRefSelector_Site); ok {
		return x.Site
	}
	return nil
}

func (m *SiteVirtualSiteRefSelector) GetVirtualSite() *VSiteRefType {
	if x, ok := m.GetRefOrSelector().(*SiteVirtualSiteRefSelector_VirtualSite); ok {
		return x.VirtualSite
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SiteVirtualSiteRefSelector) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SiteVirtualSiteRefSelector_Site)(nil),
		(*SiteVirtualSiteRefSelector_VirtualSite)(nil),
	}
}

// HeaderManipulationOptionType
//
// x-displayName: "Header Manipulation Option"
// HTTP header is a key-value pair.
// The name acts as key of HTTP header
// The value acts as the data/value of HTTP header
// Example HTTP header
//     Host: user.volterra.com
// In the above example, Host is the name or key of HTTP header
// In the above example, user.volterra.com is the value of HTTP header
type HeaderManipulationOptionType struct {
	// name
	//
	// x-displayName: "Name"
	// x-required
	// Name of the HTTP header.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// value
	//
	// x-displayName: "Value"
	// x-required
	// Value of the HTTP header.
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// append
	//
	// x-displayName: "Append"
	// Should the value be appended? If true, the value is appended to existing values.
	// Default value is do not append
	Append bool `protobuf:"varint,3,opt,name=append,proto3" json:"append,omitempty"`
}

func (m *HeaderManipulationOptionType) Reset()      { *m = HeaderManipulationOptionType{} }
func (*HeaderManipulationOptionType) ProtoMessage() {}
func (*HeaderManipulationOptionType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{35}
}
func (m *HeaderManipulationOptionType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeaderManipulationOptionType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HeaderManipulationOptionType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeaderManipulationOptionType.Merge(m, src)
}
func (m *HeaderManipulationOptionType) XXX_Size() int {
	return m.Size()
}
func (m *HeaderManipulationOptionType) XXX_DiscardUnknown() {
	xxx_messageInfo_HeaderManipulationOptionType.DiscardUnknown(m)
}

var xxx_messageInfo_HeaderManipulationOptionType proto.InternalMessageInfo

func (m *HeaderManipulationOptionType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HeaderManipulationOptionType) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *HeaderManipulationOptionType) GetAppend() bool {
	if m != nil {
		return m.Append
	}
	return false
}

// TlsValidationParamsType
//
// x-displayName: "TLS Certificate Validation Parameters"
// This includes URL for a trust store, whether SAN verification is required
// and list of Subject Alt Names for verification
type TlsValidationParamsType struct {
	// trusted_ca_url
	//
	// x-displayName: "Trusted CA"
	// The URL for a trust store
	TrustedCaUrl string `protobuf:"bytes,1,opt,name=trusted_ca_url,json=trustedCaUrl,proto3" json:"trusted_ca_url,omitempty"`
	// skip_hostname_verification
	//
	// x-displayName: "Skip verification of hostname"
	// When True, skip verification of hostname i.e. CN/Subject Alt Name of certificate
	// is not matched to the connecting hostname
	SkipHostnameVerification bool `protobuf:"varint,2,opt,name=skip_hostname_verification,json=skipHostnameVerification,proto3" json:"skip_hostname_verification,omitempty"`
	// verify_subject_alt_names
	//
	// x-displayName: "List of SANs for matching"
	// List of acceptable Subject Alt Names/CN in the peer's certificate.
	// When skip_hostname_verification is false and verify_subject_alt_names is empty,
	// the hostname of the peer will be used for matching against SAN/CN of peer's certificate
	VerifySubjectAltNames []string `protobuf:"bytes,3,rep,name=verify_subject_alt_names,json=verifySubjectAltNames,proto3" json:"verify_subject_alt_names,omitempty"`
	// use_volterra_trusted_ca_url
	//
	// x-displayName: "Use Volterra trusted CA list for verification of hostname"
	// Ignore the trusted CA URL and use the volterra trusted CA URL from the global config for verification.
	UseVolterraTrustedCaUrl bool `protobuf:"varint,4,opt,name=use_volterra_trusted_ca_url,json=useVolterraTrustedCaUrl,proto3" json:"use_volterra_trusted_ca_url,omitempty"`
}

func (m *TlsValidationParamsType) Reset()      { *m = TlsValidationParamsType{} }
func (*TlsValidationParamsType) ProtoMessage() {}
func (*TlsValidationParamsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{36}
}
func (m *TlsValidationParamsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TlsValidationParamsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TlsValidationParamsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TlsValidationParamsType.Merge(m, src)
}
func (m *TlsValidationParamsType) XXX_Size() int {
	return m.Size()
}
func (m *TlsValidationParamsType) XXX_DiscardUnknown() {
	xxx_messageInfo_TlsValidationParamsType.DiscardUnknown(m)
}

var xxx_messageInfo_TlsValidationParamsType proto.InternalMessageInfo

func (m *TlsValidationParamsType) GetTrustedCaUrl() string {
	if m != nil {
		return m.TrustedCaUrl
	}
	return ""
}

func (m *TlsValidationParamsType) GetSkipHostnameVerification() bool {
	if m != nil {
		return m.SkipHostnameVerification
	}
	return false
}

func (m *TlsValidationParamsType) GetVerifySubjectAltNames() []string {
	if m != nil {
		return m.VerifySubjectAltNames
	}
	return nil
}

func (m *TlsValidationParamsType) GetUseVolterraTrustedCaUrl() bool {
	if m != nil {
		return m.UseVolterraTrustedCaUrl
	}
	return false
}

// TlsCertificateType
//
// x-displayName: "TLS Certificate"
// Handle to fetch certificate and key
type TlsCertificateType struct {
	// certificate_url
	//
	// x-displayName: "Certificate URL"
	// x-required
	// TLS certificate.
	// Certificate or certificate chain in PEM format including the PEM headers.
	CertificateUrl string `protobuf:"bytes,1,opt,name=certificate_url,json=certificateUrl,proto3" json:"certificate_url,omitempty"`
	// private_key
	//
	// x-displayName: "Private Key"
	// x-required
	// TLS Private Key data in unencrypted PEM format including the PEM headers. The data may be optionally secured using BlindFold. TLS key has to match the accompanying certificate.
	PrivateKey *SecretType `protobuf:"bytes,4,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	// description
	//
	// x-displayName: "Description"
	// Description for the certificate
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *TlsCertificateType) Reset()      { *m = TlsCertificateType{} }
func (*TlsCertificateType) ProtoMessage() {}
func (*TlsCertificateType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{37}
}
func (m *TlsCertificateType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TlsCertificateType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TlsCertificateType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TlsCertificateType.Merge(m, src)
}
func (m *TlsCertificateType) XXX_Size() int {
	return m.Size()
}
func (m *TlsCertificateType) XXX_DiscardUnknown() {
	xxx_messageInfo_TlsCertificateType.DiscardUnknown(m)
}

var xxx_messageInfo_TlsCertificateType proto.InternalMessageInfo

func (m *TlsCertificateType) GetCertificateUrl() string {
	if m != nil {
		return m.CertificateUrl
	}
	return ""
}

func (m *TlsCertificateType) GetPrivateKey() *SecretType {
	if m != nil {
		return m.PrivateKey
	}
	return nil
}

func (m *TlsCertificateType) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// TlsParamsType
//
// x-displayName: "TLS Parameters"
// Information of different aspects for TLS authentication related to ciphers,
// certificates and trust store
type TlsParamsType struct {
	// minimum_protocol_version
	//
	// x-displayName: "Minimum TLS Version"
	// Minimum TLS protocol version.
	MinimumProtocolVersion TlsProtocol `protobuf:"varint,1,opt,name=minimum_protocol_version,json=minimumProtocolVersion,proto3,enum=ves.io.schema.TlsProtocol" json:"minimum_protocol_version,omitempty"`
	// maximum_protocol_version
	//
	// x-displayName: "Maximum TLS Version"
	// Maximum TLS protocol version.
	MaximumProtocolVersion TlsProtocol `protobuf:"varint,2,opt,name=maximum_protocol_version,json=maximumProtocolVersion,proto3,enum=ves.io.schema.TlsProtocol" json:"maximum_protocol_version,omitempty"`
	// cipher_suites
	//
	// x-displayName: "Cipher Suites"
	// The following list specifies the supported cipher suite
	//   TLS_AES_128_GCM_SHA256
	//   TLS_AES_256_GCM_SHA384
	//   TLS_CHACHA20_POLY1305_SHA256
	//   TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
	//   TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
	//   TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
	//   TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
	//   TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
	//   TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
	//   TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
	//   TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
	//   TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
	//   TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
	//   TLS_RSA_WITH_AES_128_CBC_SHA
	//   TLS_RSA_WITH_AES_128_GCM_SHA256
	//   TLS_RSA_WITH_AES_256_CBC_SHA
	//   TLS_RSA_WITH_AES_256_GCM_SHA384
	//
	// If not specified, the default list:
	//   TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
	//   TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
	//   TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
	//   TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
	//   TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
	//   TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
	// will be used.
	CipherSuites []string `protobuf:"bytes,3,rep,name=cipher_suites,json=cipherSuites,proto3" json:"cipher_suites,omitempty"`
	// tls_certificates
	//
	// x-displayName: "TLS Certificates"
	// Set of TLS certificates
	TlsCertificates []*TlsCertificateType `protobuf:"bytes,4,rep,name=tls_certificates,json=tlsCertificates,proto3" json:"tls_certificates,omitempty"`
	// trusted_ca_url
	//
	// x-displayName: "Trusted CA"
	// The URL or value for trusted CA certificates
	// Certificates in PEM format including the PEM headers.
	TrustedCaUrl string `protobuf:"bytes,5,opt,name=trusted_ca_url,json=trustedCaUrl,proto3" json:"trusted_ca_url,omitempty"` // Deprecated: Do not use.
	// validation_params
	//
	// x-displayName: "Trusted CA Validation params"
	// This includes URL for a trust store, whether SAN verification is required
	// and list of Subject Alt Names for verification
	ValidationParams *TlsValidationParamsType `protobuf:"bytes,7,opt,name=validation_params,json=validationParams,proto3" json:"validation_params,omitempty"`
}

func (m *TlsParamsType) Reset()      { *m = TlsParamsType{} }
func (*TlsParamsType) ProtoMessage() {}
func (*TlsParamsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{38}
}
func (m *TlsParamsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TlsParamsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TlsParamsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TlsParamsType.Merge(m, src)
}
func (m *TlsParamsType) XXX_Size() int {
	return m.Size()
}
func (m *TlsParamsType) XXX_DiscardUnknown() {
	xxx_messageInfo_TlsParamsType.DiscardUnknown(m)
}

var xxx_messageInfo_TlsParamsType proto.InternalMessageInfo

func (m *TlsParamsType) GetMinimumProtocolVersion() TlsProtocol {
	if m != nil {
		return m.MinimumProtocolVersion
	}
	return TLS_AUTO
}

func (m *TlsParamsType) GetMaximumProtocolVersion() TlsProtocol {
	if m != nil {
		return m.MaximumProtocolVersion
	}
	return TLS_AUTO
}

func (m *TlsParamsType) GetCipherSuites() []string {
	if m != nil {
		return m.CipherSuites
	}
	return nil
}

func (m *TlsParamsType) GetTlsCertificates() []*TlsCertificateType {
	if m != nil {
		return m.TlsCertificates
	}
	return nil
}

// Deprecated: Do not use.
func (m *TlsParamsType) GetTrustedCaUrl() string {
	if m != nil {
		return m.TrustedCaUrl
	}
	return ""
}

func (m *TlsParamsType) GetValidationParams() *TlsValidationParamsType {
	if m != nil {
		return m.ValidationParams
	}
	return nil
}

// UpstreamTlsParamsType
//
// x-displayName: "Upstream TLS Parameters"
// TLS configuration for upstream connections
type UpstreamTlsParamsType struct {
	// common_params
	//
	// x-displayName: "Common Parameters"
	// Common TLS parameters used in both upstream and downstream connections
	CommonParams *TlsParamsType `protobuf:"bytes,1,opt,name=common_params,json=commonParams,proto3" json:"common_params,omitempty"`
	// sni choice
	//
	// x-displayName: "SNI Selection"
	// x-required
	// SNI to be used while connecting to upstream service.
	//
	// Types that are valid to be assigned to SniChoice:
	//	*UpstreamTlsParamsType_Sni
	//	*UpstreamTlsParamsType_UseHostHeaderAsSni
	//	*UpstreamTlsParamsType_DisableSni
	SniChoice isUpstreamTlsParamsType_SniChoice `protobuf_oneof:"sni_choice"`
}

func (m *UpstreamTlsParamsType) Reset()      { *m = UpstreamTlsParamsType{} }
func (*UpstreamTlsParamsType) ProtoMessage() {}
func (*UpstreamTlsParamsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{39}
}
func (m *UpstreamTlsParamsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpstreamTlsParamsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UpstreamTlsParamsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpstreamTlsParamsType.Merge(m, src)
}
func (m *UpstreamTlsParamsType) XXX_Size() int {
	return m.Size()
}
func (m *UpstreamTlsParamsType) XXX_DiscardUnknown() {
	xxx_messageInfo_UpstreamTlsParamsType.DiscardUnknown(m)
}

var xxx_messageInfo_UpstreamTlsParamsType proto.InternalMessageInfo

type isUpstreamTlsParamsType_SniChoice interface {
	isUpstreamTlsParamsType_SniChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type UpstreamTlsParamsType_Sni struct {
	Sni string `protobuf:"bytes,2,opt,name=sni,proto3,oneof" json:"sni,omitempty"`
}
type UpstreamTlsParamsType_UseHostHeaderAsSni struct {
	UseHostHeaderAsSni *Empty `protobuf:"bytes,3,opt,name=use_host_header_as_sni,json=useHostHeaderAsSni,proto3,oneof" json:"use_host_header_as_sni,omitempty"`
}
type UpstreamTlsParamsType_DisableSni struct {
	DisableSni *Empty `protobuf:"bytes,4,opt,name=disable_sni,json=disableSni,proto3,oneof" json:"disable_sni,omitempty"`
}

func (*UpstreamTlsParamsType_Sni) isUpstreamTlsParamsType_SniChoice()                {}
func (*UpstreamTlsParamsType_UseHostHeaderAsSni) isUpstreamTlsParamsType_SniChoice() {}
func (*UpstreamTlsParamsType_DisableSni) isUpstreamTlsParamsType_SniChoice()         {}

func (m *UpstreamTlsParamsType) GetSniChoice() isUpstreamTlsParamsType_SniChoice {
	if m != nil {
		return m.SniChoice
	}
	return nil
}

func (m *UpstreamTlsParamsType) GetCommonParams() *TlsParamsType {
	if m != nil {
		return m.CommonParams
	}
	return nil
}

func (m *UpstreamTlsParamsType) GetSni() string {
	if x, ok := m.GetSniChoice().(*UpstreamTlsParamsType_Sni); ok {
		return x.Sni
	}
	return ""
}

func (m *UpstreamTlsParamsType) GetUseHostHeaderAsSni() *Empty {
	if x, ok := m.GetSniChoice().(*UpstreamTlsParamsType_UseHostHeaderAsSni); ok {
		return x.UseHostHeaderAsSni
	}
	return nil
}

func (m *UpstreamTlsParamsType) GetDisableSni() *Empty {
	if x, ok := m.GetSniChoice().(*UpstreamTlsParamsType_DisableSni); ok {
		return x.DisableSni
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*UpstreamTlsParamsType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*UpstreamTlsParamsType_Sni)(nil),
		(*UpstreamTlsParamsType_UseHostHeaderAsSni)(nil),
		(*UpstreamTlsParamsType_DisableSni)(nil),
	}
}

// DownstreamTlsParamsType
//
// x-displayName: "Downstream TLS Parameters"
// TLS configuration for downstream connections
type DownstreamTlsParamsType struct {
	// common_params
	//
	// x-displayName: "Common Parameters"
	// Common TLS parameters used in both upstream and downstream connections
	CommonParams *TlsParamsType `protobuf:"bytes,1,opt,name=common_params,json=commonParams,proto3" json:"common_params,omitempty"`
	// require_client_certificate
	//
	// x-displayName: "Require Client Certificate(enable mTLS)"
	// If true, Volterra will reject connections without a valid client
	// certificate.
	RequireClientCertificate bool `protobuf:"varint,4,opt,name=require_client_certificate,json=requireClientCertificate,proto3" json:"require_client_certificate,omitempty"`
}

func (m *DownstreamTlsParamsType) Reset()      { *m = DownstreamTlsParamsType{} }
func (*DownstreamTlsParamsType) ProtoMessage() {}
func (*DownstreamTlsParamsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{40}
}
func (m *DownstreamTlsParamsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownstreamTlsParamsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DownstreamTlsParamsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownstreamTlsParamsType.Merge(m, src)
}
func (m *DownstreamTlsParamsType) XXX_Size() int {
	return m.Size()
}
func (m *DownstreamTlsParamsType) XXX_DiscardUnknown() {
	xxx_messageInfo_DownstreamTlsParamsType.DiscardUnknown(m)
}

var xxx_messageInfo_DownstreamTlsParamsType proto.InternalMessageInfo

func (m *DownstreamTlsParamsType) GetCommonParams() *TlsParamsType {
	if m != nil {
		return m.CommonParams
	}
	return nil
}

func (m *DownstreamTlsParamsType) GetRequireClientCertificate() bool {
	if m != nil {
		return m.RequireClientCertificate
	}
	return false
}

// Domains
//
// x-displayName: "Domains"
// Domains names
type DomainType struct {
	//  Domain choice
	//
	// x-displayName: "Enter Domain"
	// x-required
	// Method to specify domain part in SNI for TLS connections
	//
	// Types that are valid to be assigned to DomainChoice:
	//	*DomainType_ExactValue
	//	*DomainType_SuffixValue
	//	*DomainType_RegexValue
	DomainChoice isDomainType_DomainChoice `protobuf_oneof:"domain_choice"`
}

func (m *DomainType) Reset()      { *m = DomainType{} }
func (*DomainType) ProtoMessage() {}
func (*DomainType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{41}
}
func (m *DomainType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DomainType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DomainType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DomainType.Merge(m, src)
}
func (m *DomainType) XXX_Size() int {
	return m.Size()
}
func (m *DomainType) XXX_DiscardUnknown() {
	xxx_messageInfo_DomainType.DiscardUnknown(m)
}

var xxx_messageInfo_DomainType proto.InternalMessageInfo

type isDomainType_DomainChoice interface {
	isDomainType_DomainChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DomainType_ExactValue struct {
	ExactValue string `protobuf:"bytes,1,opt,name=exact_value,json=exactValue,proto3,oneof" json:"exact_value,omitempty"`
}
type DomainType_SuffixValue struct {
	SuffixValue string `protobuf:"bytes,2,opt,name=suffix_value,json=suffixValue,proto3,oneof" json:"suffix_value,omitempty"`
}
type DomainType_RegexValue struct {
	RegexValue string `protobuf:"bytes,3,opt,name=regex_value,json=regexValue,proto3,oneof" json:"regex_value,omitempty"`
}

func (*DomainType_ExactValue) isDomainType_DomainChoice()  {}
func (*DomainType_SuffixValue) isDomainType_DomainChoice() {}
func (*DomainType_RegexValue) isDomainType_DomainChoice()  {}

func (m *DomainType) GetDomainChoice() isDomainType_DomainChoice {
	if m != nil {
		return m.DomainChoice
	}
	return nil
}

func (m *DomainType) GetExactValue() string {
	if x, ok := m.GetDomainChoice().(*DomainType_ExactValue); ok {
		return x.ExactValue
	}
	return ""
}

func (m *DomainType) GetSuffixValue() string {
	if x, ok := m.GetDomainChoice().(*DomainType_SuffixValue); ok {
		return x.SuffixValue
	}
	return ""
}

func (m *DomainType) GetRegexValue() string {
	if x, ok := m.GetDomainChoice().(*DomainType_RegexValue); ok {
		return x.RegexValue
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DomainType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DomainType_ExactValue)(nil),
		(*DomainType_SuffixValue)(nil),
		(*DomainType_RegexValue)(nil),
	}
}

// L4 Dest Type
//
// x-displayName: "L4 Destination"
// L4 Destination consisting of IPv4 Prefixes and TCP Port Range
type L4DestType struct {
	// prefixes
	//
	// x-displayName: "IPv4 Prefixes"
	// x-required
	// Destination IPv4 prefixes.
	Prefixes []string `protobuf:"bytes,1,rep,name=prefixes,proto3" json:"prefixes,omitempty"`
	// port_ranges
	//
	// x-displayName: "Port Ranges"
	// x-example: "80,443,8080-8191,9080"
	// A string containing a comma separated list of port ranges.
	// Each port range consists of a single port or two ports separated by "-".
	PortRanges string `protobuf:"bytes,2,opt,name=port_ranges,json=portRanges,proto3" json:"port_ranges,omitempty"`
}

func (m *L4DestType) Reset()      { *m = L4DestType{} }
func (*L4DestType) ProtoMessage() {}
func (*L4DestType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{42}
}
func (m *L4DestType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L4DestType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *L4DestType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L4DestType.Merge(m, src)
}
func (m *L4DestType) XXX_Size() int {
	return m.Size()
}
func (m *L4DestType) XXX_DiscardUnknown() {
	xxx_messageInfo_L4DestType.DiscardUnknown(m)
}

var xxx_messageInfo_L4DestType proto.InternalMessageInfo

func (m *L4DestType) GetPrefixes() []string {
	if m != nil {
		return m.Prefixes
	}
	return nil
}

func (m *L4DestType) GetPortRanges() string {
	if m != nil {
		return m.PortRanges
	}
	return ""
}

// TlsInterceptionRule
//
// x-displayName: "TLS Interception Rule"
// x-required
// Rule to enable or disable TLS interception based on domain match
type TlsInterceptionRule struct {
	// Domain Match
	//
	// x-displayName: "Match Domain"
	// x-required
	// Domain value or regular expression to match
	DomainMatch *DomainType `protobuf:"bytes,1,opt,name=domain_match,json=domainMatch,proto3" json:"domain_match,omitempty"`
	// Enable/Disable Interception
	//
	// x-displayName: "Enable/Disable Interception"
	// x-required
	// Enable or disable interception for the domain
	//
	// Types that are valid to be assigned to EnableDisableChoice:
	//	*TlsInterceptionRule_DisableInterception
	//	*TlsInterceptionRule_EnableInterception
	EnableDisableChoice isTlsInterceptionRule_EnableDisableChoice `protobuf_oneof:"enable_disable_choice"`
}

func (m *TlsInterceptionRule) Reset()      { *m = TlsInterceptionRule{} }
func (*TlsInterceptionRule) ProtoMessage() {}
func (*TlsInterceptionRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{43}
}
func (m *TlsInterceptionRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TlsInterceptionRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TlsInterceptionRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TlsInterceptionRule.Merge(m, src)
}
func (m *TlsInterceptionRule) XXX_Size() int {
	return m.Size()
}
func (m *TlsInterceptionRule) XXX_DiscardUnknown() {
	xxx_messageInfo_TlsInterceptionRule.DiscardUnknown(m)
}

var xxx_messageInfo_TlsInterceptionRule proto.InternalMessageInfo

type isTlsInterceptionRule_EnableDisableChoice interface {
	isTlsInterceptionRule_EnableDisableChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type TlsInterceptionRule_DisableInterception struct {
	DisableInterception *Empty `protobuf:"bytes,3,opt,name=disable_interception,json=disableInterception,proto3,oneof" json:"disable_interception,omitempty"`
}
type TlsInterceptionRule_EnableInterception struct {
	EnableInterception *Empty `protobuf:"bytes,4,opt,name=enable_interception,json=enableInterception,proto3,oneof" json:"enable_interception,omitempty"`
}

func (*TlsInterceptionRule_DisableInterception) isTlsInterceptionRule_EnableDisableChoice() {}
func (*TlsInterceptionRule_EnableInterception) isTlsInterceptionRule_EnableDisableChoice()  {}

func (m *TlsInterceptionRule) GetEnableDisableChoice() isTlsInterceptionRule_EnableDisableChoice {
	if m != nil {
		return m.EnableDisableChoice
	}
	return nil
}

func (m *TlsInterceptionRule) GetDomainMatch() *DomainType {
	if m != nil {
		return m.DomainMatch
	}
	return nil
}

func (m *TlsInterceptionRule) GetDisableInterception() *Empty {
	if x, ok := m.GetEnableDisableChoice().(*TlsInterceptionRule_DisableInterception); ok {
		return x.DisableInterception
	}
	return nil
}

func (m *TlsInterceptionRule) GetEnableInterception() *Empty {
	if x, ok := m.GetEnableDisableChoice().(*TlsInterceptionRule_EnableInterception); ok {
		return x.EnableInterception
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TlsInterceptionRule) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TlsInterceptionRule_DisableInterception)(nil),
		(*TlsInterceptionRule_EnableInterception)(nil),
	}
}

// TlsInterceptionPolicy
//
// x-displayName: "TLS Interception Policy"
// Policy to enable or disable TLS interception.
type TlsInterceptionPolicy struct {
	// Interception Rules
	//
	// x-displayName: "TLS Interception Rules"
	// x-required
	// List of ordered rules to enable or disable for TLS interception
	InterceptionRules []*TlsInterceptionRule `protobuf:"bytes,1,rep,name=interception_rules,json=interceptionRules,proto3" json:"interception_rules,omitempty"`
}

func (m *TlsInterceptionPolicy) Reset()      { *m = TlsInterceptionPolicy{} }
func (*TlsInterceptionPolicy) ProtoMessage() {}
func (*TlsInterceptionPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{44}
}
func (m *TlsInterceptionPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TlsInterceptionPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TlsInterceptionPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TlsInterceptionPolicy.Merge(m, src)
}
func (m *TlsInterceptionPolicy) XXX_Size() int {
	return m.Size()
}
func (m *TlsInterceptionPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_TlsInterceptionPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_TlsInterceptionPolicy proto.InternalMessageInfo

func (m *TlsInterceptionPolicy) GetInterceptionRules() []*TlsInterceptionRule {
	if m != nil {
		return m.InterceptionRules
	}
	return nil
}

// TlsInterceptionType
//
// x-displayName: "Configuration for TLS interception"
// Configuration to enable TLS interception
type TlsInterceptionType struct {
	// Interception Policy
	//
	// x-displayName: "Interception Policy"
	// x-required
	// Interception policy choice - enable for all domains or custom policies
	//
	// Types that are valid to be assigned to InterceptionPolicyChoice:
	//	*TlsInterceptionType_EnableForAllDomains
	//	*TlsInterceptionType_Policy
	InterceptionPolicyChoice isTlsInterceptionType_InterceptionPolicyChoice `protobuf_oneof:"interception_policy_choice"`
	// Signing Certificate
	//
	// x-displayName: "Select Signing Certificate"
	// x-required
	// Certificate used to generate intermediate certificate for interception
	//
	// Types that are valid to be assigned to SigningCertChoice:
	//	*TlsInterceptionType_CustomCertificate
	//	*TlsInterceptionType_VolterraCertificate
	SigningCertChoice isTlsInterceptionType_SigningCertChoice `protobuf_oneof:"signing_cert_choice"`
	// Trusted CA List
	//
	// x-displayName: "Select Trusted CA List"
	// x-required
	// Select Trusted CA list for upstream connection
	//
	// Types that are valid to be assigned to TrustedCaChoice:
	//	*TlsInterceptionType_TrustedCaUrl
	//	*TlsInterceptionType_VolterraTrustedCa
	TrustedCaChoice isTlsInterceptionType_TrustedCaChoice `protobuf_oneof:"trusted_ca_choice"`
}

func (m *TlsInterceptionType) Reset()      { *m = TlsInterceptionType{} }
func (*TlsInterceptionType) ProtoMessage() {}
func (*TlsInterceptionType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{45}
}
func (m *TlsInterceptionType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TlsInterceptionType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TlsInterceptionType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TlsInterceptionType.Merge(m, src)
}
func (m *TlsInterceptionType) XXX_Size() int {
	return m.Size()
}
func (m *TlsInterceptionType) XXX_DiscardUnknown() {
	xxx_messageInfo_TlsInterceptionType.DiscardUnknown(m)
}

var xxx_messageInfo_TlsInterceptionType proto.InternalMessageInfo

type isTlsInterceptionType_InterceptionPolicyChoice interface {
	isTlsInterceptionType_InterceptionPolicyChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isTlsInterceptionType_SigningCertChoice interface {
	isTlsInterceptionType_SigningCertChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isTlsInterceptionType_TrustedCaChoice interface {
	isTlsInterceptionType_TrustedCaChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type TlsInterceptionType_EnableForAllDomains struct {
	EnableForAllDomains *Empty `protobuf:"bytes,9,opt,name=enable_for_all_domains,json=enableForAllDomains,proto3,oneof" json:"enable_for_all_domains,omitempty"`
}
type TlsInterceptionType_Policy struct {
	Policy *TlsInterceptionPolicy `protobuf:"bytes,1,opt,name=policy,proto3,oneof" json:"policy,omitempty"`
}
type TlsInterceptionType_CustomCertificate struct {
	CustomCertificate *TlsCertificateType `protobuf:"bytes,3,opt,name=custom_certificate,json=customCertificate,proto3,oneof" json:"custom_certificate,omitempty"`
}
type TlsInterceptionType_VolterraCertificate struct {
	VolterraCertificate *Empty `protobuf:"bytes,4,opt,name=volterra_certificate,json=volterraCertificate,proto3,oneof" json:"volterra_certificate,omitempty"`
}
type TlsInterceptionType_TrustedCaUrl struct {
	TrustedCaUrl string `protobuf:"bytes,6,opt,name=trusted_ca_url,json=trustedCaUrl,proto3,oneof" json:"trusted_ca_url,omitempty"`
}
type TlsInterceptionType_VolterraTrustedCa struct {
	VolterraTrustedCa *Empty `protobuf:"bytes,7,opt,name=volterra_trusted_ca,json=volterraTrustedCa,proto3,oneof" json:"volterra_trusted_ca,omitempty"`
}

func (*TlsInterceptionType_EnableForAllDomains) isTlsInterceptionType_InterceptionPolicyChoice() {}
func (*TlsInterceptionType_Policy) isTlsInterceptionType_InterceptionPolicyChoice()              {}
func (*TlsInterceptionType_CustomCertificate) isTlsInterceptionType_SigningCertChoice()          {}
func (*TlsInterceptionType_VolterraCertificate) isTlsInterceptionType_SigningCertChoice()        {}
func (*TlsInterceptionType_TrustedCaUrl) isTlsInterceptionType_TrustedCaChoice()                 {}
func (*TlsInterceptionType_VolterraTrustedCa) isTlsInterceptionType_TrustedCaChoice()            {}

func (m *TlsInterceptionType) GetInterceptionPolicyChoice() isTlsInterceptionType_InterceptionPolicyChoice {
	if m != nil {
		return m.InterceptionPolicyChoice
	}
	return nil
}
func (m *TlsInterceptionType) GetSigningCertChoice() isTlsInterceptionType_SigningCertChoice {
	if m != nil {
		return m.SigningCertChoice
	}
	return nil
}
func (m *TlsInterceptionType) GetTrustedCaChoice() isTlsInterceptionType_TrustedCaChoice {
	if m != nil {
		return m.TrustedCaChoice
	}
	return nil
}

func (m *TlsInterceptionType) GetEnableForAllDomains() *Empty {
	if x, ok := m.GetInterceptionPolicyChoice().(*TlsInterceptionType_EnableForAllDomains); ok {
		return x.EnableForAllDomains
	}
	return nil
}

func (m *TlsInterceptionType) GetPolicy() *TlsInterceptionPolicy {
	if x, ok := m.GetInterceptionPolicyChoice().(*TlsInterceptionType_Policy); ok {
		return x.Policy
	}
	return nil
}

func (m *TlsInterceptionType) GetCustomCertificate() *TlsCertificateType {
	if x, ok := m.GetSigningCertChoice().(*TlsInterceptionType_CustomCertificate); ok {
		return x.CustomCertificate
	}
	return nil
}

func (m *TlsInterceptionType) GetVolterraCertificate() *Empty {
	if x, ok := m.GetSigningCertChoice().(*TlsInterceptionType_VolterraCertificate); ok {
		return x.VolterraCertificate
	}
	return nil
}

func (m *TlsInterceptionType) GetTrustedCaUrl() string {
	if x, ok := m.GetTrustedCaChoice().(*TlsInterceptionType_TrustedCaUrl); ok {
		return x.TrustedCaUrl
	}
	return ""
}

func (m *TlsInterceptionType) GetVolterraTrustedCa() *Empty {
	if x, ok := m.GetTrustedCaChoice().(*TlsInterceptionType_VolterraTrustedCa); ok {
		return x.VolterraTrustedCa
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TlsInterceptionType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TlsInterceptionType_EnableForAllDomains)(nil),
		(*TlsInterceptionType_Policy)(nil),
		(*TlsInterceptionType_CustomCertificate)(nil),
		(*TlsInterceptionType_VolterraCertificate)(nil),
		(*TlsInterceptionType_TrustedCaUrl)(nil),
		(*TlsInterceptionType_VolterraTrustedCa)(nil),
	}
}

// FractionalPercent
//
// x-displayName: "Fractional Percent"
// Fraction used where sampling percentages are needed. example sampled requests
type FractionalPercent struct {
	// numerator
	//
	// x-displayName: "Numerator"
	// x-required
	// x-example: "5"
	// sampled parts per denominator. If denominator was 10000, then value of 5 will be 5 in 10000
	Numerator uint32 `protobuf:"varint,1,opt,name=numerator,proto3" json:"numerator,omitempty"`
	// denominator
	//
	// x-displayName: "Denominator"
	// x-required
	// Samples per denominator. numerator part per 100 or 10000 ro 1000000
	Denominator DenominatorType `protobuf:"varint,2,opt,name=denominator,proto3,enum=ves.io.schema.DenominatorType" json:"denominator,omitempty"`
}

func (m *FractionalPercent) Reset()      { *m = FractionalPercent{} }
func (*FractionalPercent) ProtoMessage() {}
func (*FractionalPercent) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{46}
}
func (m *FractionalPercent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FractionalPercent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FractionalPercent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FractionalPercent.Merge(m, src)
}
func (m *FractionalPercent) XXX_Size() int {
	return m.Size()
}
func (m *FractionalPercent) XXX_DiscardUnknown() {
	xxx_messageInfo_FractionalPercent.DiscardUnknown(m)
}

var xxx_messageInfo_FractionalPercent proto.InternalMessageInfo

func (m *FractionalPercent) GetNumerator() uint32 {
	if m != nil {
		return m.Numerator
	}
	return 0
}

func (m *FractionalPercent) GetDenominator() DenominatorType {
	if m != nil {
		return m.Denominator
	}
	return HUNDRED
}

// BufferConfigType
//
// x-displayName: "Buffer Configuration"
// Some upstream applications are not capable of handling streamed data. This config
// enables buffering the entire request before sending to upstream application. We can
// specify the maximum buffer size and buffer interval with this config.
//
// Buffering can be enabled and disabled at VirtualHost and Route levels
// Route level buffer configuration takes precedence.
type BufferConfigType struct {
	// disable
	//
	// x-displayName: "Disable"
	// Disable buffering for a particular route. This is useful when virtual-host
	// has buffering, but we need to disable it on a specific route.
	// The value of this field is ignored for virtual-host
	Disabled bool `protobuf:"varint,1,opt,name=disabled,proto3" json:"disabled,omitempty"`
	// max_request_bytes
	//
	// x-displayName: "Max Request Bytes"
	// x-example: "2048"
	// The maximum request size that the filter will buffer before the connection
	// manager will stop buffering and return a RequestEntityTooLarge (413) response.
	MaxRequestBytes uint32 `protobuf:"varint,2,opt,name=max_request_bytes,json=maxRequestBytes,proto3" json:"max_request_bytes,omitempty"`
	// max_request_time
	//
	// x-displayName: "Max Request Time"
	// x-example: "30"
	// The maximum number of seconds that the filter will wait for a complete
	// request before returning a RequestTimeout (408) response
	MaxRequestTime uint32 `protobuf:"varint,3,opt,name=max_request_time,json=maxRequestTime,proto3" json:"max_request_time,omitempty"` // Deprecated: Do not use.
}

func (m *BufferConfigType) Reset()      { *m = BufferConfigType{} }
func (*BufferConfigType) ProtoMessage() {}
func (*BufferConfigType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{47}
}
func (m *BufferConfigType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BufferConfigType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BufferConfigType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BufferConfigType.Merge(m, src)
}
func (m *BufferConfigType) XXX_Size() int {
	return m.Size()
}
func (m *BufferConfigType) XXX_DiscardUnknown() {
	xxx_messageInfo_BufferConfigType.DiscardUnknown(m)
}

var xxx_messageInfo_BufferConfigType proto.InternalMessageInfo

func (m *BufferConfigType) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func (m *BufferConfigType) GetMaxRequestBytes() uint32 {
	if m != nil {
		return m.MaxRequestBytes
	}
	return 0
}

// Deprecated: Do not use.
func (m *BufferConfigType) GetMaxRequestTime() uint32 {
	if m != nil {
		return m.MaxRequestTime
	}
	return 0
}

// CorsPolicy
//
// x-displayName: "CORS Policy"
// Cross-Origin Resource Sharing requests configuration specified at Virtual-host or
// Route level. Route level configuration takes precedence.
//
// An example of an Cross origin HTTP request
//     GET /resources/public-data/ HTTP/1.1
//     Host: bar.other
//     User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
//     Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
//     Accept-Language: en-us,en;q=0.5
//     Accept-Encoding: gzip,deflate
//     Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
//     Connection: keep-alive
//     Referrer: http://foo.example/examples/access-control/simpleXSInvocation.html
//     Origin: http://foo.example
//
//
//     HTTP/1.1 200 OK
//     Date: Mon, 01 Dec 2008 00:23:53 GMT
//     Server: Apache/2.0.61
//     Access-Control-Allow-Origin: *
//     Keep-Alive: timeout=2, max=100
//     Connection: Keep-Alive
//     Transfer-Encoding: chunked
//     Content-Type: application/xml
//
// An example for cross origin HTTP OPTIONS request with Access-Control-Request-* header
//
//     OPTIONS /resources/post-here/ HTTP/1.1
//     Host: bar.other
//     User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
//     Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
//     Accept-Language: en-us,en;q=0.5
//     Accept-Encoding: gzip,deflate
//     Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
//     Connection: keep-alive
//     Origin: http://foo.example
//     Access-Control-Request-Method: POST
//     Access-Control-Request-Headers: X-PINGOTHER, Content-Type
//
//
//     HTTP/1.1 204 No Content
//     Date: Mon, 01 Dec 2008 01:15:39 GMT
//     Server: Apache/2.0.61 (Unix)
//     Access-Control-Allow-Origin: http://foo.example
//     Access-Control-Allow-Methods: POST, GET, OPTIONS
//     Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
//     Access-Control-Max-Age: 86400
//     Vary: Accept-Encoding, Origin
//     Keep-Alive: timeout=2, max=100
//     Connection: Keep-Alive
type CorsPolicy struct {
	// disabled
	//
	// x-displayName: "Disabled"
	// Disable the CorsPolicy for a particular route. This is useful when
	// virtual-host has CorsPolicy, but we need to disable it on a specific route.
	// The value of this field is ignored for virtual-host
	Disabled bool `protobuf:"varint,1,opt,name=disabled,proto3" json:"disabled,omitempty"`
	// allow_origin
	//
	// x-displayName: "Allow Origin"
	// Specifies the origins that will be allowed to do CORS requests.
	// An origin is allowed if either allow_origin or allow_origin_regex match
	AllowOrigin []string `protobuf:"bytes,2,rep,name=allow_origin,json=allowOrigin,proto3" json:"allow_origin,omitempty"`
	// allow_origin_regex
	//
	// x-displayName: "Allow Origin Regex"
	// Specifies regex patterns that match allowed origins.
	// An origin is allowed if either allow_origin or allow_origin_regex match
	AllowOriginRegex []string `protobuf:"bytes,3,rep,name=allow_origin_regex,json=allowOriginRegex,proto3" json:"allow_origin_regex,omitempty"`
	// allow_methods
	//
	// x-displayName: "Allow Methods"
	// Specifies the content for the access-control-allow-methods header
	AllowMethods string `protobuf:"bytes,4,opt,name=allow_methods,json=allowMethods,proto3" json:"allow_methods,omitempty"`
	// allow_headers
	//
	// x-displayName: "Allow Headers"
	// Specifies the content for the access-control-allow-headers header
	AllowHeaders string `protobuf:"bytes,5,opt,name=allow_headers,json=allowHeaders,proto3" json:"allow_headers,omitempty"`
	// expose_headers
	//
	// x-displayName: "Expose Headers"
	// Specifies the content for the access-control-expose-headers header
	ExposeHeaders string `protobuf:"bytes,6,opt,name=expose_headers,json=exposeHeaders,proto3" json:"expose_headers,omitempty"`
	// max_age
	//
	// x-displayName: "Max Age"
	// Specifies the content for the access-control-max-age header
	MaxAge string `protobuf:"bytes,7,opt,name=max_age,json=maxAge,proto3" json:"max_age,omitempty"` // Deprecated: Do not use.
	// maximum_age
	//
	// x-displayName: "Maximum Age"
	// Specifies the content for the access-control-max-age header in seconds.
	// This indicates the maximum number of seconds the results can be cached
	// A value of -1 will disable caching.
	// Maximum permitted value is 86400 seconds (24 hours)
	MaximumAge int32 `protobuf:"varint,9,opt,name=maximum_age,json=maximumAge,proto3" json:"maximum_age,omitempty"`
	// allow_credentials
	//
	// x-displayName: "Allow Credentials"
	// Specifies whether the resource allows credentials
	AllowCredentials bool `protobuf:"varint,8,opt,name=allow_credentials,json=allowCredentials,proto3" json:"allow_credentials,omitempty"`
}

func (m *CorsPolicy) Reset()      { *m = CorsPolicy{} }
func (*CorsPolicy) ProtoMessage() {}
func (*CorsPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{48}
}
func (m *CorsPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CorsPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CorsPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CorsPolicy.Merge(m, src)
}
func (m *CorsPolicy) XXX_Size() int {
	return m.Size()
}
func (m *CorsPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_CorsPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_CorsPolicy proto.InternalMessageInfo

func (m *CorsPolicy) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func (m *CorsPolicy) GetAllowOrigin() []string {
	if m != nil {
		return m.AllowOrigin
	}
	return nil
}

func (m *CorsPolicy) GetAllowOriginRegex() []string {
	if m != nil {
		return m.AllowOriginRegex
	}
	return nil
}

func (m *CorsPolicy) GetAllowMethods() string {
	if m != nil {
		return m.AllowMethods
	}
	return ""
}

func (m *CorsPolicy) GetAllowHeaders() string {
	if m != nil {
		return m.AllowHeaders
	}
	return ""
}

func (m *CorsPolicy) GetExposeHeaders() string {
	if m != nil {
		return m.ExposeHeaders
	}
	return ""
}

// Deprecated: Do not use.
func (m *CorsPolicy) GetMaxAge() string {
	if m != nil {
		return m.MaxAge
	}
	return ""
}

func (m *CorsPolicy) GetMaximumAge() int32 {
	if m != nil {
		return m.MaximumAge
	}
	return 0
}

func (m *CorsPolicy) GetAllowCredentials() bool {
	if m != nil {
		return m.AllowCredentials
	}
	return false
}

// PathMatcherType
//
// x-displayName: "Path to Match"
// Path match of the URI can be either be, Prefix match or exact match or regular expression match
type PathMatcherType struct {
	// path_match
	//
	// x-displayName: "Path Match"
	// x-required
	// A specification of path match
	//
	// Types that are valid to be assigned to PathMatch:
	//	*PathMatcherType_Prefix
	//	*PathMatcherType_Path
	//	*PathMatcherType_Regex
	PathMatch isPathMatcherType_PathMatch `protobuf_oneof:"path_match"`
}

func (m *PathMatcherType) Reset()      { *m = PathMatcherType{} }
func (*PathMatcherType) ProtoMessage() {}
func (*PathMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{49}
}
func (m *PathMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PathMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PathMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PathMatcherType.Merge(m, src)
}
func (m *PathMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *PathMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_PathMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_PathMatcherType proto.InternalMessageInfo

type isPathMatcherType_PathMatch interface {
	isPathMatcherType_PathMatch()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PathMatcherType_Prefix struct {
	Prefix string `protobuf:"bytes,1,opt,name=prefix,proto3,oneof" json:"prefix,omitempty"`
}
type PathMatcherType_Path struct {
	Path string `protobuf:"bytes,2,opt,name=path,proto3,oneof" json:"path,omitempty"`
}
type PathMatcherType_Regex struct {
	Regex string `protobuf:"bytes,3,opt,name=regex,proto3,oneof" json:"regex,omitempty"`
}

func (*PathMatcherType_Prefix) isPathMatcherType_PathMatch() {}
func (*PathMatcherType_Path) isPathMatcherType_PathMatch()   {}
func (*PathMatcherType_Regex) isPathMatcherType_PathMatch()  {}

func (m *PathMatcherType) GetPathMatch() isPathMatcherType_PathMatch {
	if m != nil {
		return m.PathMatch
	}
	return nil
}

func (m *PathMatcherType) GetPrefix() string {
	if x, ok := m.GetPathMatch().(*PathMatcherType_Prefix); ok {
		return x.Prefix
	}
	return ""
}

func (m *PathMatcherType) GetPath() string {
	if x, ok := m.GetPathMatch().(*PathMatcherType_Path); ok {
		return x.Path
	}
	return ""
}

func (m *PathMatcherType) GetRegex() string {
	if x, ok := m.GetPathMatch().(*PathMatcherType_Regex); ok {
		return x.Regex
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PathMatcherType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PathMatcherType_Prefix)(nil),
		(*PathMatcherType_Path)(nil),
		(*PathMatcherType_Regex)(nil),
	}
}

// HeaderMatcherType
//
// x-displayName: "Header to Match"
// Header match is done using the name of the header and its value.
// The value match is done using one of the following
//     regex match on value
//     exact match of value
//     presence of header
//
// Header Match can also be inverse of above, which be used to check
//     missing header or
//     non-matching value
type HeaderMatcherType struct {
	// name
	//
	// x-displayName: "Name"
	// x-example: "Content-Type"
	// Name of the header
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// value_match
	//
	// x-displayName: "Value"
	// The variants of matching a header value
	//
	// Types that are valid to be assigned to ValueMatch:
	//	*HeaderMatcherType_Exact
	//	*HeaderMatcherType_Regex
	//	*HeaderMatcherType_Presence
	ValueMatch isHeaderMatcherType_ValueMatch `protobuf_oneof:"value_match"`
	// invert_match
	//
	// x-displayName: "NOT of match"
	// Invert the result of the match to detect missing header or non-matching value
	InvertMatch bool `protobuf:"varint,5,opt,name=invert_match,json=invertMatch,proto3" json:"invert_match,omitempty"`
}

func (m *HeaderMatcherType) Reset()      { *m = HeaderMatcherType{} }
func (*HeaderMatcherType) ProtoMessage() {}
func (*HeaderMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{50}
}
func (m *HeaderMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeaderMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HeaderMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeaderMatcherType.Merge(m, src)
}
func (m *HeaderMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *HeaderMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_HeaderMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_HeaderMatcherType proto.InternalMessageInfo

type isHeaderMatcherType_ValueMatch interface {
	isHeaderMatcherType_ValueMatch()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type HeaderMatcherType_Exact struct {
	Exact string `protobuf:"bytes,2,opt,name=exact,proto3,oneof" json:"exact,omitempty"`
}
type HeaderMatcherType_Regex struct {
	Regex string `protobuf:"bytes,3,opt,name=regex,proto3,oneof" json:"regex,omitempty"`
}
type HeaderMatcherType_Presence struct {
	Presence bool `protobuf:"varint,4,opt,name=presence,proto3,oneof" json:"presence,omitempty"`
}

func (*HeaderMatcherType_Exact) isHeaderMatcherType_ValueMatch()    {}
func (*HeaderMatcherType_Regex) isHeaderMatcherType_ValueMatch()    {}
func (*HeaderMatcherType_Presence) isHeaderMatcherType_ValueMatch() {}

func (m *HeaderMatcherType) GetValueMatch() isHeaderMatcherType_ValueMatch {
	if m != nil {
		return m.ValueMatch
	}
	return nil
}

func (m *HeaderMatcherType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HeaderMatcherType) GetExact() string {
	if x, ok := m.GetValueMatch().(*HeaderMatcherType_Exact); ok {
		return x.Exact
	}
	return ""
}

func (m *HeaderMatcherType) GetRegex() string {
	if x, ok := m.GetValueMatch().(*HeaderMatcherType_Regex); ok {
		return x.Regex
	}
	return ""
}

func (m *HeaderMatcherType) GetPresence() bool {
	if x, ok := m.GetValueMatch().(*HeaderMatcherType_Presence); ok {
		return x.Presence
	}
	return false
}

func (m *HeaderMatcherType) GetInvertMatch() bool {
	if m != nil {
		return m.InvertMatch
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HeaderMatcherType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HeaderMatcherType_Exact)(nil),
		(*HeaderMatcherType_Regex)(nil),
		(*HeaderMatcherType_Presence)(nil),
	}
}

// QueryParameterMatcherType
//
// x-displayName: "Query Parameter to Match"
// Query parameter match can be either regex match on value or exact match of value for given key
// An example for HTTP request with query parameter https://gitlab.com/dashboard/issues?assignee_username=xxyyxx
type QueryParameterMatcherType struct {
	// key
	//
	// x-displayName: "Key"
	// x-example: "assignee_username"
	// Query parameter key
	// In the above example, assignee_username is the key
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// value_match
	//
	// x-displayName: "Value"
	// Query parameter value regex match or exact match
	// In the above example, xxyyxx is the value for the matching key
	//
	// Types that are valid to be assigned to ValueMatch:
	//	*QueryParameterMatcherType_Exact
	//	*QueryParameterMatcherType_Regex
	ValueMatch isQueryParameterMatcherType_ValueMatch `protobuf_oneof:"value_match"`
}

func (m *QueryParameterMatcherType) Reset()      { *m = QueryParameterMatcherType{} }
func (*QueryParameterMatcherType) ProtoMessage() {}
func (*QueryParameterMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{51}
}
func (m *QueryParameterMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryParameterMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *QueryParameterMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryParameterMatcherType.Merge(m, src)
}
func (m *QueryParameterMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *QueryParameterMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryParameterMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_QueryParameterMatcherType proto.InternalMessageInfo

type isQueryParameterMatcherType_ValueMatch interface {
	isQueryParameterMatcherType_ValueMatch()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type QueryParameterMatcherType_Exact struct {
	Exact string `protobuf:"bytes,2,opt,name=exact,proto3,oneof" json:"exact,omitempty"`
}
type QueryParameterMatcherType_Regex struct {
	Regex string `protobuf:"bytes,3,opt,name=regex,proto3,oneof" json:"regex,omitempty"`
}

func (*QueryParameterMatcherType_Exact) isQueryParameterMatcherType_ValueMatch() {}
func (*QueryParameterMatcherType_Regex) isQueryParameterMatcherType_ValueMatch() {}

func (m *QueryParameterMatcherType) GetValueMatch() isQueryParameterMatcherType_ValueMatch {
	if m != nil {
		return m.ValueMatch
	}
	return nil
}

func (m *QueryParameterMatcherType) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *QueryParameterMatcherType) GetExact() string {
	if x, ok := m.GetValueMatch().(*QueryParameterMatcherType_Exact); ok {
		return x.Exact
	}
	return ""
}

func (m *QueryParameterMatcherType) GetRegex() string {
	if x, ok := m.GetValueMatch().(*QueryParameterMatcherType_Regex); ok {
		return x.Regex
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*QueryParameterMatcherType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*QueryParameterMatcherType_Exact)(nil),
		(*QueryParameterMatcherType_Regex)(nil),
	}
}

// RouteMatch
//
// x-displayName: "Match"
// Route Match can be specified to match four things
// 1. In case of HTTP "path" specifies URI part URL (path excluding hostname) in request.
// 2. List of headers  to match in incoming request.
// 3. Query parameters (key, value) in the request. (Not the Query expression)
// 4. HTTP method
type RouteMatch struct {
	// path
	//
	// x-displayName: "Path"
	// URI path of route
	Path *PathMatcherType `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// headers
	//
	// x-displayName: "Headers"
	// List of (key, value) headers
	Headers []*HeaderMatcherType `protobuf:"bytes,2,rep,name=headers,proto3" json:"headers,omitempty"`
	// query_params
	//
	// x-displayName: "Query Parameters"
	// List of (key, value) query parameters
	QueryParams []*QueryParameterMatcherType `protobuf:"bytes,3,rep,name=query_params,json=queryParams,proto3" json:"query_params,omitempty"`
	// http_method
	//
	// x-displayName: "HTTP Method"
	// The name of the HTTP Method (GET, PUT, POST, etc)
	HttpMethod HttpMethod `protobuf:"varint,4,opt,name=http_method,json=httpMethod,proto3,enum=ves.io.schema.HttpMethod" json:"http_method,omitempty"`
}

func (m *RouteMatch) Reset()      { *m = RouteMatch{} }
func (*RouteMatch) ProtoMessage() {}
func (*RouteMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{52}
}
func (m *RouteMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteMatch.Merge(m, src)
}
func (m *RouteMatch) XXX_Size() int {
	return m.Size()
}
func (m *RouteMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteMatch.DiscardUnknown(m)
}

var xxx_messageInfo_RouteMatch proto.InternalMessageInfo

func (m *RouteMatch) GetPath() *PathMatcherType {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *RouteMatch) GetHeaders() []*HeaderMatcherType {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *RouteMatch) GetQueryParams() []*QueryParameterMatcherType {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

func (m *RouteMatch) GetHttpMethod() HttpMethod {
	if m != nil {
		return m.HttpMethod
	}
	return ANY
}

// WafRefType
//
// x-displayName: "WAF Reference"
// A reference to the WAF configuration object
type WafRefType struct {
	// waf
	//
	// x-displayName: "WAF"
	// A direct reference to web application firewall configuration object
	Waf []*ObjectRefType `protobuf:"bytes,1,rep,name=waf,proto3" json:"waf,omitempty"`
}

func (m *WafRefType) Reset()      { *m = WafRefType{} }
func (*WafRefType) ProtoMessage() {}
func (*WafRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{53}
}
func (m *WafRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WafRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WafRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WafRefType.Merge(m, src)
}
func (m *WafRefType) XXX_Size() int {
	return m.Size()
}
func (m *WafRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_WafRefType.DiscardUnknown(m)
}

var xxx_messageInfo_WafRefType proto.InternalMessageInfo

func (m *WafRefType) GetWaf() []*ObjectRefType {
	if m != nil {
		return m.Waf
	}
	return nil
}

// WafRulesRefType
//
// x-displayName: "WAF Rules Reference"
// A list of references to the waf_rules configuration objects
type WafRulesRefType struct {
	// waf_rules
	//
	// x-displayName: "WAF Rules"
	// References to a set of WAF Rules configuration object
	WafRules []*ObjectRefType `protobuf:"bytes,1,rep,name=waf_rules,json=wafRules,proto3" json:"waf_rules,omitempty"`
}

func (m *WafRulesRefType) Reset()      { *m = WafRulesRefType{} }
func (*WafRulesRefType) ProtoMessage() {}
func (*WafRulesRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{54}
}
func (m *WafRulesRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WafRulesRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WafRulesRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WafRulesRefType.Merge(m, src)
}
func (m *WafRulesRefType) XXX_Size() int {
	return m.Size()
}
func (m *WafRulesRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_WafRulesRefType.DiscardUnknown(m)
}

var xxx_messageInfo_WafRulesRefType proto.InternalMessageInfo

func (m *WafRulesRefType) GetWafRules() []*ObjectRefType {
	if m != nil {
		return m.WafRules
	}
	return nil
}

// AppFirewallRefType
//
// x-displayName: "WAF Rules Reference"
// A list of references to the app_firewall configuration objects
type AppFirewallRefType struct {
	// app_firewall
	//
	// x-displayName: "Application Firewall"
	// References to an Application Firewall configuration object
	AppFirewall []*ObjectRefType `protobuf:"bytes,1,rep,name=app_firewall,json=appFirewall,proto3" json:"app_firewall,omitempty"`
}

func (m *AppFirewallRefType) Reset()      { *m = AppFirewallRefType{} }
func (*AppFirewallRefType) ProtoMessage() {}
func (*AppFirewallRefType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{55}
}
func (m *AppFirewallRefType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppFirewallRefType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AppFirewallRefType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppFirewallRefType.Merge(m, src)
}
func (m *AppFirewallRefType) XXX_Size() int {
	return m.Size()
}
func (m *AppFirewallRefType) XXX_DiscardUnknown() {
	xxx_messageInfo_AppFirewallRefType.DiscardUnknown(m)
}

var xxx_messageInfo_AppFirewallRefType proto.InternalMessageInfo

func (m *AppFirewallRefType) GetAppFirewall() []*ObjectRefType {
	if m != nil {
		return m.AppFirewall
	}
	return nil
}

// WafType
//
// x-displayName: "WAF Instance"
// WAF instance will be pointing to either Waf object (high level) or waf_rules Object
type WafType struct {
	// WAF config
	//
	// x-displayName: "WAF Config"
	// The variants of direct reference of WAF
	//
	// Types that are valid to be assigned to RefType:
	//	*WafType_Waf
	//	*WafType_WafRules
	//	*WafType_AppFirewall
	RefType isWafType_RefType `protobuf_oneof:"ref_type"`
}

func (m *WafType) Reset()      { *m = WafType{} }
func (*WafType) ProtoMessage() {}
func (*WafType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{56}
}
func (m *WafType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WafType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *WafType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WafType.Merge(m, src)
}
func (m *WafType) XXX_Size() int {
	return m.Size()
}
func (m *WafType) XXX_DiscardUnknown() {
	xxx_messageInfo_WafType.DiscardUnknown(m)
}

var xxx_messageInfo_WafType proto.InternalMessageInfo

type isWafType_RefType interface {
	isWafType_RefType()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type WafType_Waf struct {
	Waf *WafRefType `protobuf:"bytes,1,opt,name=waf,proto3,oneof" json:"waf,omitempty"`
}
type WafType_WafRules struct {
	WafRules *WafRulesRefType `protobuf:"bytes,2,opt,name=waf_rules,json=wafRules,proto3,oneof" json:"waf_rules,omitempty"`
}
type WafType_AppFirewall struct {
	AppFirewall *AppFirewallRefType `protobuf:"bytes,4,opt,name=app_firewall,json=appFirewall,proto3,oneof" json:"app_firewall,omitempty"`
}

func (*WafType_Waf) isWafType_RefType()         {}
func (*WafType_WafRules) isWafType_RefType()    {}
func (*WafType_AppFirewall) isWafType_RefType() {}

func (m *WafType) GetRefType() isWafType_RefType {
	if m != nil {
		return m.RefType
	}
	return nil
}

func (m *WafType) GetWaf() *WafRefType {
	if x, ok := m.GetRefType().(*WafType_Waf); ok {
		return x.Waf
	}
	return nil
}

func (m *WafType) GetWafRules() *WafRulesRefType {
	if x, ok := m.GetRefType().(*WafType_WafRules); ok {
		return x.WafRules
	}
	return nil
}

func (m *WafType) GetAppFirewall() *AppFirewallRefType {
	if x, ok := m.GetRefType().(*WafType_AppFirewall); ok {
		return x.AppFirewall
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*WafType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*WafType_Waf)(nil),
		(*WafType_WafRules)(nil),
		(*WafType_AppFirewall)(nil),
	}
}

// AppRoleAuthInfoType
//
// x-displayName: "Vault AppRole Authentication Parameters"
// AppRoleAuthInfoType contains parameters for AppRole authentication in Hashicorp Vault
type AppRoleAuthInfoType struct {
	// role-id
	//
	// x-displayName: "Role ID"
	// role-id to be used for authentication
	RoleId string `protobuf:"bytes,1,opt,name=role_id,json=roleId,proto3" json:"role_id,omitempty"`
	// secret-id
	//
	// x-displayName: "Secret ID"
	// Volterra Secret. Secret-id to be used for authentication. secret-id has to be long lived.
	SecretId *SecretType `protobuf:"bytes,2,opt,name=secret_id,json=secretId,proto3" json:"secret_id,omitempty"`
}

func (m *AppRoleAuthInfoType) Reset()      { *m = AppRoleAuthInfoType{} }
func (*AppRoleAuthInfoType) ProtoMessage() {}
func (*AppRoleAuthInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{57}
}
func (m *AppRoleAuthInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppRoleAuthInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AppRoleAuthInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppRoleAuthInfoType.Merge(m, src)
}
func (m *AppRoleAuthInfoType) XXX_Size() int {
	return m.Size()
}
func (m *AppRoleAuthInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_AppRoleAuthInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_AppRoleAuthInfoType proto.InternalMessageInfo

func (m *AppRoleAuthInfoType) GetRoleId() string {
	if m != nil {
		return m.RoleId
	}
	return ""
}

func (m *AppRoleAuthInfoType) GetSecretId() *SecretType {
	if m != nil {
		return m.SecretId
	}
	return nil
}

// VaultAuthTypeInfo
//
// x-displayName: "Vault Authentication Parameters"
// Authentication parameters for Hashicorp Vault hosts
type VaultAuthInfoType struct {
	// Authentication Parameters
	//
	// x-displayName: "Authentication Parameters"
	// Different authentication parameters for authentication to Hashicorp Vault backend. Currently supported methods are -
	// * AppRole authentication - Authentication using AppRole method
	// * Token authentication - Authentication using Token
	//
	// Types that are valid to be assigned to AuthParams:
	//	*VaultAuthInfoType_AppRoleAuth
	//	*VaultAuthInfoType_Token
	AuthParams isVaultAuthInfoType_AuthParams `protobuf_oneof:"auth_params"`
}

func (m *VaultAuthInfoType) Reset()      { *m = VaultAuthInfoType{} }
func (*VaultAuthInfoType) ProtoMessage() {}
func (*VaultAuthInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{58}
}
func (m *VaultAuthInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VaultAuthInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VaultAuthInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VaultAuthInfoType.Merge(m, src)
}
func (m *VaultAuthInfoType) XXX_Size() int {
	return m.Size()
}
func (m *VaultAuthInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_VaultAuthInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_VaultAuthInfoType proto.InternalMessageInfo

type isVaultAuthInfoType_AuthParams interface {
	isVaultAuthInfoType_AuthParams()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type VaultAuthInfoType_AppRoleAuth struct {
	AppRoleAuth *AppRoleAuthInfoType `protobuf:"bytes,1,opt,name=app_role_auth,json=appRoleAuth,proto3,oneof" json:"app_role_auth,omitempty"`
}
type VaultAuthInfoType_Token struct {
	Token *SecretType `protobuf:"bytes,2,opt,name=token,proto3,oneof" json:"token,omitempty"`
}

func (*VaultAuthInfoType_AppRoleAuth) isVaultAuthInfoType_AuthParams() {}
func (*VaultAuthInfoType_Token) isVaultAuthInfoType_AuthParams()       {}

func (m *VaultAuthInfoType) GetAuthParams() isVaultAuthInfoType_AuthParams {
	if m != nil {
		return m.AuthParams
	}
	return nil
}

func (m *VaultAuthInfoType) GetAppRoleAuth() *AppRoleAuthInfoType {
	if x, ok := m.GetAuthParams().(*VaultAuthInfoType_AppRoleAuth); ok {
		return x.AppRoleAuth
	}
	return nil
}

func (m *VaultAuthInfoType) GetToken() *SecretType {
	if x, ok := m.GetAuthParams().(*VaultAuthInfoType_Token); ok {
		return x.Token
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VaultAuthInfoType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VaultAuthInfoType_AppRoleAuth)(nil),
		(*VaultAuthInfoType_Token)(nil),
	}
}

// RestAuthInfoType
//
// x-displayName: "Rest Authentication Parameters"
// Authentication parameters for REST based hosts
type RestAuthInfoType struct {
	// Authentication Parameters
	//
	// x-displayName: "Authentication Parameters"
	// Different authentication parameters for authenticating to REST backend, Currently supported are -
	// BasicAuth - Authentication using basic auth
	// Authentication Headers - Authentication using Headers
	// Authentication QueryParams - Authentication using QueryParams
	//
	// Types that are valid to be assigned to AuthParams:
	//	*RestAuthInfoType_BasicAuth
	//	*RestAuthInfoType_HeadersAuth
	//	*RestAuthInfoType_QueryParamsAuth
	AuthParams isRestAuthInfoType_AuthParams `protobuf_oneof:"auth_params"`
}

func (m *RestAuthInfoType) Reset()      { *m = RestAuthInfoType{} }
func (*RestAuthInfoType) ProtoMessage() {}
func (*RestAuthInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{59}
}
func (m *RestAuthInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestAuthInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RestAuthInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestAuthInfoType.Merge(m, src)
}
func (m *RestAuthInfoType) XXX_Size() int {
	return m.Size()
}
func (m *RestAuthInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_RestAuthInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_RestAuthInfoType proto.InternalMessageInfo

type isRestAuthInfoType_AuthParams interface {
	isRestAuthInfoType_AuthParams()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type RestAuthInfoType_BasicAuth struct {
	BasicAuth *AuthnTypeBasicAuth `protobuf:"bytes,1,opt,name=basic_auth,json=basicAuth,proto3,oneof" json:"basic_auth,omitempty"`
}
type RestAuthInfoType_HeadersAuth struct {
	HeadersAuth *AuthnTypeHeaders `protobuf:"bytes,2,opt,name=headers_auth,json=headersAuth,proto3,oneof" json:"headers_auth,omitempty"`
}
type RestAuthInfoType_QueryParamsAuth struct {
	QueryParamsAuth *AuthnTypeQueryParams `protobuf:"bytes,3,opt,name=query_params_auth,json=queryParamsAuth,proto3,oneof" json:"query_params_auth,omitempty"`
}

func (*RestAuthInfoType_BasicAuth) isRestAuthInfoType_AuthParams()       {}
func (*RestAuthInfoType_HeadersAuth) isRestAuthInfoType_AuthParams()     {}
func (*RestAuthInfoType_QueryParamsAuth) isRestAuthInfoType_AuthParams() {}

func (m *RestAuthInfoType) GetAuthParams() isRestAuthInfoType_AuthParams {
	if m != nil {
		return m.AuthParams
	}
	return nil
}

func (m *RestAuthInfoType) GetBasicAuth() *AuthnTypeBasicAuth {
	if x, ok := m.GetAuthParams().(*RestAuthInfoType_BasicAuth); ok {
		return x.BasicAuth
	}
	return nil
}

func (m *RestAuthInfoType) GetHeadersAuth() *AuthnTypeHeaders {
	if x, ok := m.GetAuthParams().(*RestAuthInfoType_HeadersAuth); ok {
		return x.HeadersAuth
	}
	return nil
}

func (m *RestAuthInfoType) GetQueryParamsAuth() *AuthnTypeQueryParams {
	if x, ok := m.GetAuthParams().(*RestAuthInfoType_QueryParamsAuth); ok {
		return x.QueryParamsAuth
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RestAuthInfoType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RestAuthInfoType_BasicAuth)(nil),
		(*RestAuthInfoType_HeadersAuth)(nil),
		(*RestAuthInfoType_QueryParamsAuth)(nil),
	}
}

// HostAccessInfoType
//
// x-displayName: "Host Access Information"
// HostAccessInfoType contains the information about how to connect to the remote host.
type HostAccessInfoType struct {
	// scheme
	//
	// x-displayName: "URL Scheme"
	// URL scheme to use for connection
	Scheme URLSchemeType `protobuf:"varint,1,opt,name=scheme,proto3,enum=ves.io.schema.URLSchemeType" json:"scheme,omitempty"`
	// server_endpoint
	//
	// x-displayName: "Server Endpoint and Port"
	// x-required
	// x-example: "webserver:443"
	// endpoint to connect to, in host:port format
	ServerEndpoint string `protobuf:"bytes,2,opt,name=server_endpoint,json=serverEndpoint,proto3" json:"server_endpoint,omitempty"`
	// tls_config
	//
	// x-displayName: "TLS Configuration"
	// TLS configuration for the connection
	TlsConfig *UpstreamTlsParamsType `protobuf:"bytes,4,opt,name=tls_config,json=tlsConfig,proto3" json:"tls_config,omitempty"`
	// Authentication Parameters
	//
	// x-displayName: "Authentication Parameters"
	// Different Methods for Authenticating to the remote host. Currently supported are -
	// * Rest Authentication - This is used if the remote host is REST server
	// * Vault Authentication - This is used if the remote host is a Hashicorp Vault server
	//
	// Types that are valid to be assigned to AuthParams:
	//	*HostAccessInfoType_RestAuthInfo
	//	*HostAccessInfoType_VaultAuthInfo
	AuthParams isHostAccessInfoType_AuthParams `protobuf_oneof:"auth_params"`
}

func (m *HostAccessInfoType) Reset()      { *m = HostAccessInfoType{} }
func (*HostAccessInfoType) ProtoMessage() {}
func (*HostAccessInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{60}
}
func (m *HostAccessInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HostAccessInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HostAccessInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostAccessInfoType.Merge(m, src)
}
func (m *HostAccessInfoType) XXX_Size() int {
	return m.Size()
}
func (m *HostAccessInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_HostAccessInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_HostAccessInfoType proto.InternalMessageInfo

type isHostAccessInfoType_AuthParams interface {
	isHostAccessInfoType_AuthParams()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type HostAccessInfoType_RestAuthInfo struct {
	RestAuthInfo *RestAuthInfoType `protobuf:"bytes,5,opt,name=rest_auth_info,json=restAuthInfo,proto3,oneof" json:"rest_auth_info,omitempty"`
}
type HostAccessInfoType_VaultAuthInfo struct {
	VaultAuthInfo *VaultAuthInfoType `protobuf:"bytes,6,opt,name=vault_auth_info,json=vaultAuthInfo,proto3,oneof" json:"vault_auth_info,omitempty"`
}

func (*HostAccessInfoType_RestAuthInfo) isHostAccessInfoType_AuthParams()  {}
func (*HostAccessInfoType_VaultAuthInfo) isHostAccessInfoType_AuthParams() {}

func (m *HostAccessInfoType) GetAuthParams() isHostAccessInfoType_AuthParams {
	if m != nil {
		return m.AuthParams
	}
	return nil
}

func (m *HostAccessInfoType) GetScheme() URLSchemeType {
	if m != nil {
		return m.Scheme
	}
	return HTTP
}

func (m *HostAccessInfoType) GetServerEndpoint() string {
	if m != nil {
		return m.ServerEndpoint
	}
	return ""
}

func (m *HostAccessInfoType) GetTlsConfig() *UpstreamTlsParamsType {
	if m != nil {
		return m.TlsConfig
	}
	return nil
}

func (m *HostAccessInfoType) GetRestAuthInfo() *RestAuthInfoType {
	if x, ok := m.GetAuthParams().(*HostAccessInfoType_RestAuthInfo); ok {
		return x.RestAuthInfo
	}
	return nil
}

func (m *HostAccessInfoType) GetVaultAuthInfo() *VaultAuthInfoType {
	if x, ok := m.GetAuthParams().(*HostAccessInfoType_VaultAuthInfo); ok {
		return x.VaultAuthInfo
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HostAccessInfoType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HostAccessInfoType_RestAuthInfo)(nil),
		(*HostAccessInfoType_VaultAuthInfo)(nil),
	}
}

// VaultAccessInfoType
//
// x-displayName: "Vault Access Information"
// VaultAccessInfoType contains information about how to connect to Hashicorp vault.
type VaultAccessInfoType struct {
	// vault_addr
	//
	// x-displayName: "Vault Address"
	// vault_address defines the address of the vault in <host:port> format
	VaultAddr string `protobuf:"bytes,1,opt,name=vault_addr,json=vaultAddr,proto3" json:"vault_addr,omitempty"`
	// vault_ca_url
	//
	// x-displayName: "Vault CA URL"
	// vault_ca_url contains the CA to trust for remote vault
	VaultCaUrl string `protobuf:"bytes,2,opt,name=vault_ca_url,json=vaultCaUrl,proto3" json:"vault_ca_url,omitempty"`
	// Types that are valid to be assigned to AuthnChoice:
	//	*VaultAccessInfoType_AppRoleAuth
	//	*VaultAccessInfoType_Token
	AuthnChoice isVaultAccessInfoType_AuthnChoice `protobuf_oneof:"authn_choice"`
}

func (m *VaultAccessInfoType) Reset()      { *m = VaultAccessInfoType{} }
func (*VaultAccessInfoType) ProtoMessage() {}
func (*VaultAccessInfoType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{61}
}
func (m *VaultAccessInfoType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VaultAccessInfoType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VaultAccessInfoType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VaultAccessInfoType.Merge(m, src)
}
func (m *VaultAccessInfoType) XXX_Size() int {
	return m.Size()
}
func (m *VaultAccessInfoType) XXX_DiscardUnknown() {
	xxx_messageInfo_VaultAccessInfoType.DiscardUnknown(m)
}

var xxx_messageInfo_VaultAccessInfoType proto.InternalMessageInfo

type isVaultAccessInfoType_AuthnChoice interface {
	isVaultAccessInfoType_AuthnChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type VaultAccessInfoType_AppRoleAuth struct {
	AppRoleAuth *AppRoleAuthInfoType `protobuf:"bytes,3,opt,name=app_role_auth,json=appRoleAuth,proto3,oneof" json:"app_role_auth,omitempty"`
}
type VaultAccessInfoType_Token struct {
	Token *SecretType `protobuf:"bytes,4,opt,name=token,proto3,oneof" json:"token,omitempty"`
}

func (*VaultAccessInfoType_AppRoleAuth) isVaultAccessInfoType_AuthnChoice() {}
func (*VaultAccessInfoType_Token) isVaultAccessInfoType_AuthnChoice()       {}

func (m *VaultAccessInfoType) GetAuthnChoice() isVaultAccessInfoType_AuthnChoice {
	if m != nil {
		return m.AuthnChoice
	}
	return nil
}

func (m *VaultAccessInfoType) GetVaultAddr() string {
	if m != nil {
		return m.VaultAddr
	}
	return ""
}

func (m *VaultAccessInfoType) GetVaultCaUrl() string {
	if m != nil {
		return m.VaultCaUrl
	}
	return ""
}

func (m *VaultAccessInfoType) GetAppRoleAuth() *AppRoleAuthInfoType {
	if x, ok := m.GetAuthnChoice().(*VaultAccessInfoType_AppRoleAuth); ok {
		return x.AppRoleAuth
	}
	return nil
}

func (m *VaultAccessInfoType) GetToken() *SecretType {
	if x, ok := m.GetAuthnChoice().(*VaultAccessInfoType_Token); ok {
		return x.Token
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VaultAccessInfoType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VaultAccessInfoType_AppRoleAuth)(nil),
		(*VaultAccessInfoType_Token)(nil),
	}
}

// VaultSecretType
//
// x-displayName: "Vault Secret"
// VaultSecretType contains the information about a secret stored in Hashicorp vault
type VaultSecretType struct {
	// Types that are valid to be assigned to AccessChoice:
	//	*VaultSecretType_VaultAccessInfo
	//	*VaultSecretType_ProviderName
	AccessChoice isVaultSecretType_AccessChoice `protobuf_oneof:"access_choice"`
	// secret_path
	//
	// x-displayName: "Secret Path"
	// secret_path provider, or can give access information inline.
	SecretPath string `protobuf:"bytes,3,opt,name=secret_path,json=secretPath,proto3" json:"secret_path,omitempty"`
	// secret_sub_path
	//
	// x-displayName: "Secret SubPath"
	// secret_sub_path contains the subPath of the secret in Hashicorp vault.
	SecretSubPath string `protobuf:"bytes,4,opt,name=secret_sub_path,json=secretSubPath,proto3" json:"secret_sub_path,omitempty"`
	// secret_version
	//
	// x-displayName: "Secret Version"
	// secret_version contains the version of the secret to be fetched from Hashicorp vault.
	SecretVersion string `protobuf:"bytes,5,opt,name=secret_version,json=secretVersion,proto3" json:"secret_version,omitempty"`
}

func (m *VaultSecretType) Reset()      { *m = VaultSecretType{} }
func (*VaultSecretType) ProtoMessage() {}
func (*VaultSecretType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{62}
}
func (m *VaultSecretType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VaultSecretType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VaultSecretType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VaultSecretType.Merge(m, src)
}
func (m *VaultSecretType) XXX_Size() int {
	return m.Size()
}
func (m *VaultSecretType) XXX_DiscardUnknown() {
	xxx_messageInfo_VaultSecretType.DiscardUnknown(m)
}

var xxx_messageInfo_VaultSecretType proto.InternalMessageInfo

type isVaultSecretType_AccessChoice interface {
	isVaultSecretType_AccessChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type VaultSecretType_VaultAccessInfo struct {
	VaultAccessInfo *VaultAccessInfoType `protobuf:"bytes,1,opt,name=vault_access_info,json=vaultAccessInfo,proto3,oneof" json:"vault_access_info,omitempty"`
}
type VaultSecretType_ProviderName struct {
	ProviderName string `protobuf:"bytes,2,opt,name=provider_name,json=providerName,proto3,oneof" json:"provider_name,omitempty"`
}

func (*VaultSecretType_VaultAccessInfo) isVaultSecretType_AccessChoice() {}
func (*VaultSecretType_ProviderName) isVaultSecretType_AccessChoice()    {}

func (m *VaultSecretType) GetAccessChoice() isVaultSecretType_AccessChoice {
	if m != nil {
		return m.AccessChoice
	}
	return nil
}

func (m *VaultSecretType) GetVaultAccessInfo() *VaultAccessInfoType {
	if x, ok := m.GetAccessChoice().(*VaultSecretType_VaultAccessInfo); ok {
		return x.VaultAccessInfo
	}
	return nil
}

func (m *VaultSecretType) GetProviderName() string {
	if x, ok := m.GetAccessChoice().(*VaultSecretType_ProviderName); ok {
		return x.ProviderName
	}
	return ""
}

func (m *VaultSecretType) GetSecretPath() string {
	if m != nil {
		return m.SecretPath
	}
	return ""
}

func (m *VaultSecretType) GetSecretSubPath() string {
	if m != nil {
		return m.SecretSubPath
	}
	return ""
}

func (m *VaultSecretType) GetSecretVersion() string {
	if m != nil {
		return m.SecretVersion
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VaultSecretType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VaultSecretType_VaultAccessInfo)(nil),
		(*VaultSecretType_ProviderName)(nil),
	}
}

// VolterraSecretType
//
// x-displayName: "Volterra Secret"
// VolterraSecretType contains the information about secret distributed by volterra.
type VolterraSecretType struct {
	// Types that are valid to be assigned to SecretTypeChoice:
	//	*VolterraSecretType_BlindfoldSecretInfo
	//	*VolterraSecretType_VaultSecretInfo
	SecretTypeChoice isVolterraSecretType_SecretTypeChoice `protobuf_oneof:"secret_type_choice"`
}

func (m *VolterraSecretType) Reset()      { *m = VolterraSecretType{} }
func (*VolterraSecretType) ProtoMessage() {}
func (*VolterraSecretType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{63}
}
func (m *VolterraSecretType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VolterraSecretType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VolterraSecretType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolterraSecretType.Merge(m, src)
}
func (m *VolterraSecretType) XXX_Size() int {
	return m.Size()
}
func (m *VolterraSecretType) XXX_DiscardUnknown() {
	xxx_messageInfo_VolterraSecretType.DiscardUnknown(m)
}

var xxx_messageInfo_VolterraSecretType proto.InternalMessageInfo

type isVolterraSecretType_SecretTypeChoice interface {
	isVolterraSecretType_SecretTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type VolterraSecretType_BlindfoldSecretInfo struct {
	BlindfoldSecretInfo *BlindfoldSecretInfoType `protobuf:"bytes,1,opt,name=blindfold_secret_info,json=blindfoldSecretInfo,proto3,oneof" json:"blindfold_secret_info,omitempty"`
}
type VolterraSecretType_VaultSecretInfo struct {
	VaultSecretInfo *VaultAccessInfoType `protobuf:"bytes,2,opt,name=vault_secret_info,json=vaultSecretInfo,proto3,oneof" json:"vault_secret_info,omitempty"`
}

func (*VolterraSecretType_BlindfoldSecretInfo) isVolterraSecretType_SecretTypeChoice() {}
func (*VolterraSecretType_VaultSecretInfo) isVolterraSecretType_SecretTypeChoice()     {}

func (m *VolterraSecretType) GetSecretTypeChoice() isVolterraSecretType_SecretTypeChoice {
	if m != nil {
		return m.SecretTypeChoice
	}
	return nil
}

func (m *VolterraSecretType) GetBlindfoldSecretInfo() *BlindfoldSecretInfoType {
	if x, ok := m.GetSecretTypeChoice().(*VolterraSecretType_BlindfoldSecretInfo); ok {
		return x.BlindfoldSecretInfo
	}
	return nil
}

func (m *VolterraSecretType) GetVaultSecretInfo() *VaultAccessInfoType {
	if x, ok := m.GetSecretTypeChoice().(*VolterraSecretType_VaultSecretInfo); ok {
		return x.VaultSecretInfo
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VolterraSecretType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VolterraSecretType_BlindfoldSecretInfo)(nil),
		(*VolterraSecretType_VaultSecretInfo)(nil),
	}
}

// PortValueType
//
// x-displayName: "Port Value Type"
// PortValueType specifies the port value
// Can be any or a specified port
type PortValueType struct {
	// port_value_type_choice
	//
	// x-displayName: "Port Value Type"
	// Match criteria for port
	//
	// Types that are valid to be assigned to PortValueTypeChoice:
	//	*PortValueType_All
	//	*PortValueType_UserDefined
	//	*PortValueType_Dns
	PortValueTypeChoice isPortValueType_PortValueTypeChoice `protobuf_oneof:"port_value_type_choice"`
}

func (m *PortValueType) Reset()      { *m = PortValueType{} }
func (*PortValueType) ProtoMessage() {}
func (*PortValueType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{64}
}
func (m *PortValueType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortValueType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PortValueType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortValueType.Merge(m, src)
}
func (m *PortValueType) XXX_Size() int {
	return m.Size()
}
func (m *PortValueType) XXX_DiscardUnknown() {
	xxx_messageInfo_PortValueType.DiscardUnknown(m)
}

var xxx_messageInfo_PortValueType proto.InternalMessageInfo

type isPortValueType_PortValueTypeChoice interface {
	isPortValueType_PortValueTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PortValueType_All struct {
	All *Empty `protobuf:"bytes,1,opt,name=all,proto3,oneof" json:"all,omitempty"`
}
type PortValueType_UserDefined struct {
	UserDefined uint32 `protobuf:"varint,2,opt,name=user_defined,json=userDefined,proto3,oneof" json:"user_defined,omitempty"`
}
type PortValueType_Dns struct {
	Dns *Empty `protobuf:"bytes,3,opt,name=dns,proto3,oneof" json:"dns,omitempty"`
}

func (*PortValueType_All) isPortValueType_PortValueTypeChoice()         {}
func (*PortValueType_UserDefined) isPortValueType_PortValueTypeChoice() {}
func (*PortValueType_Dns) isPortValueType_PortValueTypeChoice()         {}

func (m *PortValueType) GetPortValueTypeChoice() isPortValueType_PortValueTypeChoice {
	if m != nil {
		return m.PortValueTypeChoice
	}
	return nil
}

func (m *PortValueType) GetAll() *Empty {
	if x, ok := m.GetPortValueTypeChoice().(*PortValueType_All); ok {
		return x.All
	}
	return nil
}

func (m *PortValueType) GetUserDefined() uint32 {
	if x, ok := m.GetPortValueTypeChoice().(*PortValueType_UserDefined); ok {
		return x.UserDefined
	}
	return 0
}

func (m *PortValueType) GetDns() *Empty {
	if x, ok := m.GetPortValueTypeChoice().(*PortValueType_Dns); ok {
		return x.Dns
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PortValueType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PortValueType_All)(nil),
		(*PortValueType_UserDefined)(nil),
		(*PortValueType_Dns)(nil),
	}
}

// VirtualNetworkReferenceType
//
// x-displayName: "Virtual Network Reference Type"
// Carries the reference to virtual network
type VirtualNetworkReferenceType struct {
	// Virtual Network Reference
	//
	// x-displayName: "Virtual Network Reference"
	// Reference to virtual network
	Refs []*ObjectRefType `protobuf:"bytes,1,rep,name=refs,proto3" json:"refs,omitempty"`
}

func (m *VirtualNetworkReferenceType) Reset()      { *m = VirtualNetworkReferenceType{} }
func (*VirtualNetworkReferenceType) ProtoMessage() {}
func (*VirtualNetworkReferenceType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{65}
}
func (m *VirtualNetworkReferenceType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VirtualNetworkReferenceType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VirtualNetworkReferenceType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualNetworkReferenceType.Merge(m, src)
}
func (m *VirtualNetworkReferenceType) XXX_Size() int {
	return m.Size()
}
func (m *VirtualNetworkReferenceType) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualNetworkReferenceType.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualNetworkReferenceType proto.InternalMessageInfo

func (m *VirtualNetworkReferenceType) GetRefs() []*ObjectRefType {
	if m != nil {
		return m.Refs
	}
	return nil
}

// VirtualNetworkSelectorType
//
// x-displayName: "Virtual Network Type"
// Different types of virtual networks understood by the system
type VirtualNetworkSelectorType struct {
	// vn_type_choice
	//
	// x-displayName: "Virtual Network"
	// Different types of virtual networks understood by the system
	//
	// Types that are valid to be assigned to VnTypeChoice:
	//	*VirtualNetworkSelectorType_SiteLocal
	//	*VirtualNetworkSelectorType_SiteLocalInside
	//	*VirtualNetworkSelectorType_Public
	VnTypeChoice isVirtualNetworkSelectorType_VnTypeChoice `protobuf_oneof:"vn_type_choice"`
}

func (m *VirtualNetworkSelectorType) Reset()      { *m = VirtualNetworkSelectorType{} }
func (*VirtualNetworkSelectorType) ProtoMessage() {}
func (*VirtualNetworkSelectorType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{66}
}
func (m *VirtualNetworkSelectorType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VirtualNetworkSelectorType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VirtualNetworkSelectorType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VirtualNetworkSelectorType.Merge(m, src)
}
func (m *VirtualNetworkSelectorType) XXX_Size() int {
	return m.Size()
}
func (m *VirtualNetworkSelectorType) XXX_DiscardUnknown() {
	xxx_messageInfo_VirtualNetworkSelectorType.DiscardUnknown(m)
}

var xxx_messageInfo_VirtualNetworkSelectorType proto.InternalMessageInfo

type isVirtualNetworkSelectorType_VnTypeChoice interface {
	isVirtualNetworkSelectorType_VnTypeChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type VirtualNetworkSelectorType_SiteLocal struct {
	SiteLocal *Empty `protobuf:"bytes,1,opt,name=site_local,json=siteLocal,proto3,oneof" json:"site_local,omitempty"`
}
type VirtualNetworkSelectorType_SiteLocalInside struct {
	SiteLocalInside *Empty `protobuf:"bytes,2,opt,name=site_local_inside,json=siteLocalInside,proto3,oneof" json:"site_local_inside,omitempty"`
}
type VirtualNetworkSelectorType_Public struct {
	Public *Empty `protobuf:"bytes,4,opt,name=public,proto3,oneof" json:"public,omitempty"`
}

func (*VirtualNetworkSelectorType_SiteLocal) isVirtualNetworkSelectorType_VnTypeChoice()       {}
func (*VirtualNetworkSelectorType_SiteLocalInside) isVirtualNetworkSelectorType_VnTypeChoice() {}
func (*VirtualNetworkSelectorType_Public) isVirtualNetworkSelectorType_VnTypeChoice()          {}

func (m *VirtualNetworkSelectorType) GetVnTypeChoice() isVirtualNetworkSelectorType_VnTypeChoice {
	if m != nil {
		return m.VnTypeChoice
	}
	return nil
}

func (m *VirtualNetworkSelectorType) GetSiteLocal() *Empty {
	if x, ok := m.GetVnTypeChoice().(*VirtualNetworkSelectorType_SiteLocal); ok {
		return x.SiteLocal
	}
	return nil
}

func (m *VirtualNetworkSelectorType) GetSiteLocalInside() *Empty {
	if x, ok := m.GetVnTypeChoice().(*VirtualNetworkSelectorType_SiteLocalInside); ok {
		return x.SiteLocalInside
	}
	return nil
}

func (m *VirtualNetworkSelectorType) GetPublic() *Empty {
	if x, ok := m.GetVnTypeChoice().(*VirtualNetworkSelectorType_Public); ok {
		return x.Public
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VirtualNetworkSelectorType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VirtualNetworkSelectorType_SiteLocal)(nil),
		(*VirtualNetworkSelectorType_SiteLocalInside)(nil),
		(*VirtualNetworkSelectorType_Public)(nil),
	}
}

// RetryBackOff
//
// x-displayName: "Retry BackOff Interval"
// Specifies parameters that control retry back off.
type RetryBackOff struct {
	// base_interval
	//
	// x-displayName: "Base Retry Interval"
	// x-example: 5
	// Specifies the base interval between retries in milliseconds
	BaseInterval uint32 `protobuf:"varint,1,opt,name=base_interval,json=baseInterval,proto3" json:"base_interval,omitempty"`
	// max_interval
	//
	// x-displayName: "Maximum Retry Interval"
	// x-example: 60
	// Specifies the maximum interval between retries in milliseconds.
	// This parameter is optional, but must be greater than or equal
	// to the base_interval if set. The default is 10 times the base_interval.
	MaxInterval uint32 `protobuf:"varint,2,opt,name=max_interval,json=maxInterval,proto3" json:"max_interval,omitempty"`
}

func (m *RetryBackOff) Reset()      { *m = RetryBackOff{} }
func (*RetryBackOff) ProtoMessage() {}
func (*RetryBackOff) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{67}
}
func (m *RetryBackOff) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RetryBackOff) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RetryBackOff) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetryBackOff.Merge(m, src)
}
func (m *RetryBackOff) XXX_Size() int {
	return m.Size()
}
func (m *RetryBackOff) XXX_DiscardUnknown() {
	xxx_messageInfo_RetryBackOff.DiscardUnknown(m)
}

var xxx_messageInfo_RetryBackOff proto.InternalMessageInfo

func (m *RetryBackOff) GetBaseInterval() uint32 {
	if m != nil {
		return m.BaseInterval
	}
	return 0
}

func (m *RetryBackOff) GetMaxInterval() uint32 {
	if m != nil {
		return m.MaxInterval
	}
	return 0
}

// RetryPolicyType
//
// x-displayName: "Retry Policy"
// Retry policy configuration for route destination.
type RetryPolicyType struct {
	// retry_on
	//
	// x-displayName: "Retry On"
	// x-example: "5xx"
	// Specifies the conditions under which retry takes place.
	// Retries can be on different types of condition depending on application requirements.
	// For example, network failure, all 5xx response codes, idempotent 4xx response codes, etc
	//
	// The possible values are
	//
	// "5xx"             : Retry will be done if the upstream server responds with any 5xx response code,
	//                     or does not respond at all (disconnect/reset/read timeout).
	//
	// "gateway-error"   : Retry will be done only if the upstream server responds with 502, 503 or
	//                     504 responses (Included in 5xx)
	//
	// "connect-failure" : Retry will be done if the request fails because of a connection failure to the
	//                     upstream server (connect timeout, etc.). (Included in 5xx)
	//
	// "refused-stream"  : Retry is done if the upstream server resets the stream with a REFUSED_STREAM
	//                     error code (Included in 5xx)
	//
	// "retriable-4xx"   : Retry is done if the upstream server responds with a retriable 4xx response code.
	//                     The only response code in this category is HTTP CONFLICT (409)
	//
	// "retriable-status-codes" :  Retry is done if the upstream server responds with any response code
	//                             matching one defined in retriable_status_codes field
	RetryOn string `protobuf:"bytes,1,opt,name=retry_on,json=retryOn,proto3" json:"retry_on,omitempty"` // Deprecated: Do not use.
	// retry_condition
	//
	// x-displayName: "Retry Condition"
	// x-example: "5xx"
	// Specifies the conditions under which retry takes place.
	// Retries can be on different types of condition depending on application requirements.
	// For example, network failure, all 5xx response codes, idempotent 4xx response codes, etc
	//
	// The possible values are
	//
	// "5xx"             : Retry will be done if the upstream server responds with any 5xx response code,
	//                     or does not respond at all (disconnect/reset/read timeout).
	//
	// "gateway-error"   : Retry will be done only if the upstream server responds with 502, 503 or
	//                     504 responses (Included in 5xx)
	//
	// "connect-failure" : Retry will be done if the request fails because of a connection failure to the
	//                     upstream server (connect timeout, etc.). (Included in 5xx)
	//
	// "refused-stream"  : Retry is done if the upstream server resets the stream with a REFUSED_STREAM
	//                     error code (Included in 5xx)
	//
	// "retriable-4xx"   : Retry is done if the upstream server responds with a retriable 4xx response code.
	//                     The only response code in this category is HTTP CONFLICT (409)
	//
	// "retriable-status-codes" :  Retry is done if the upstream server responds with any response code
	//                             matching one defined in retriable_status_codes field
	RetryCondition []string `protobuf:"bytes,6,rep,name=retry_condition,json=retryCondition,proto3" json:"retry_condition,omitempty"`
	// num_retries
	//
	// x-displayName: "Number of Retries"
	// x-example: 3
	// Specifies the allowed number of retries. Defaults to 1.
	// Retries can be done any number of times. An exponential back-off algorithm
	// is used between each retry
	NumRetries uint32 `protobuf:"varint,2,opt,name=num_retries,json=numRetries,proto3" json:"num_retries,omitempty"`
	// per_try_timeout
	//
	// x-displayName: "Per Try Timeout"
	// x-example: 1000
	// Specifies a non-zero timeout per retry attempt. In milliseconds
	PerTryTimeout uint32 `protobuf:"varint,3,opt,name=per_try_timeout,json=perTryTimeout,proto3" json:"per_try_timeout,omitempty"`
	// Retriable status Code
	//
	// x-displayName: "Status Code to Retry"
	// x-example: 403
	// HTTP status codes that should trigger a retry in addition to those specified by retry_on.
	RetriableStatusCodes []uint32 `protobuf:"varint,4,rep,packed,name=retriable_status_codes,json=retriableStatusCodes,proto3" json:"retriable_status_codes,omitempty"`
	// Retry BackOff
	//
	// x-displayName: "Retry BackOff interval"
	// Specifies parameters that control retry back off.
	// This parameter is optional, in which case the default base
	// interval is 25 milliseconds. The default maximum interval is
	// 10 times the base interval
	BackOff *RetryBackOff `protobuf:"bytes,5,opt,name=back_off,json=backOff,proto3" json:"back_off,omitempty"`
}

func (m *RetryPolicyType) Reset()      { *m = RetryPolicyType{} }
func (*RetryPolicyType) ProtoMessage() {}
func (*RetryPolicyType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{68}
}
func (m *RetryPolicyType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RetryPolicyType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RetryPolicyType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RetryPolicyType.Merge(m, src)
}
func (m *RetryPolicyType) XXX_Size() int {
	return m.Size()
}
func (m *RetryPolicyType) XXX_DiscardUnknown() {
	xxx_messageInfo_RetryPolicyType.DiscardUnknown(m)
}

var xxx_messageInfo_RetryPolicyType proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *RetryPolicyType) GetRetryOn() string {
	if m != nil {
		return m.RetryOn
	}
	return ""
}

func (m *RetryPolicyType) GetRetryCondition() []string {
	if m != nil {
		return m.RetryCondition
	}
	return nil
}

func (m *RetryPolicyType) GetNumRetries() uint32 {
	if m != nil {
		return m.NumRetries
	}
	return 0
}

func (m *RetryPolicyType) GetPerTryTimeout() uint32 {
	if m != nil {
		return m.PerTryTimeout
	}
	return 0
}

func (m *RetryPolicyType) GetRetriableStatusCodes() []uint32 {
	if m != nil {
		return m.RetriableStatusCodes
	}
	return nil
}

func (m *RetryPolicyType) GetBackOff() *RetryBackOff {
	if m != nil {
		return m.BackOff
	}
	return nil
}

// Metric Value
//
// x-displayName: "Metric Value"
// Metric data contains timestamp and the value.
type MetricValue struct {
	// Timestamp
	//
	// x-displayName: "Timestamp"
	// x-example: "1570007981"
	// timestamp
	Timestamp float64 `protobuf:"fixed64,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Value
	//
	// x-displayName: "Value"
	// x-example: "15"
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *MetricValue) Reset()      { *m = MetricValue{} }
func (*MetricValue) ProtoMessage() {}
func (*MetricValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{69}
}
func (m *MetricValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MetricValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricValue.Merge(m, src)
}
func (m *MetricValue) XXX_Size() int {
	return m.Size()
}
func (m *MetricValue) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricValue.DiscardUnknown(m)
}

var xxx_messageInfo_MetricValue proto.InternalMessageInfo

func (m *MetricValue) GetTimestamp() float64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *MetricValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Nexthop
//
// x-displayName: "Nexthop"
// Identifies the next-hop for a route
type NextHopType struct {
	// Type
	//
	// x-displayName: "Type"
	// Identifies the type of next-hop
	Type NextHopTypes `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.NextHopTypes" json:"type,omitempty"`
	// Nexthop Address
	//
	// x-displayName: "Address"
	// Nexthop address when type is "Use-Configured"
	NexthopAddress *IpAddressType `protobuf:"bytes,2,opt,name=nexthop_address,json=nexthopAddress,proto3" json:"nexthop_address,omitempty"`
	// Network Interface
	//
	// x-displayName: "Network Interface"
	// Nexthop is network interface when type is "Network-Interface"
	Interface []*ObjectRefType `protobuf:"bytes,3,rep,name=interface,proto3" json:"interface,omitempty"`
}

func (m *NextHopType) Reset()      { *m = NextHopType{} }
func (*NextHopType) ProtoMessage() {}
func (*NextHopType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{70}
}
func (m *NextHopType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NextHopType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NextHopType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NextHopType.Merge(m, src)
}
func (m *NextHopType) XXX_Size() int {
	return m.Size()
}
func (m *NextHopType) XXX_DiscardUnknown() {
	xxx_messageInfo_NextHopType.DiscardUnknown(m)
}

var xxx_messageInfo_NextHopType proto.InternalMessageInfo

func (m *NextHopType) GetType() NextHopTypes {
	if m != nil {
		return m.Type
	}
	return NEXT_HOP_DEFAULT_GATEWAY
}

func (m *NextHopType) GetNexthopAddress() *IpAddressType {
	if m != nil {
		return m.NexthopAddress
	}
	return nil
}

func (m *NextHopType) GetInterface() []*ObjectRefType {
	if m != nil {
		return m.Interface
	}
	return nil
}

// Static Route
//
// x-displayName: "Static Route"
// Defines a static route, configuring a list of prefixes and a next-hop to be used for them
type StaticRouteType struct {
	// Attributes
	//
	// x-displayName: "Attributes"
	// List of route attributes associated with the static route
	Attrs []RouteAttrType `protobuf:"varint,1,rep,packed,name=attrs,proto3,enum=ves.io.schema.RouteAttrType" json:"attrs,omitempty"`
	// Subnets
	//
	// x-displayName: "Subnets"
	// List of route prefixes
	Subnets []*IpSubnetType `protobuf:"bytes,2,rep,name=subnets,proto3" json:"subnets,omitempty"`
	// Nexthop
	//
	// x-displayName: "Nexthop"
	// Nexthop for the route
	Nexthop *NextHopType `protobuf:"bytes,10,opt,name=nexthop,proto3" json:"nexthop,omitempty"`
	// Static Route labels
	//
	// x-displayName: "Static Route Labels"
	// Add Labels for this Static Route, these labels can be used in network policy
	Labels map[string]string `protobuf:"bytes,11,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *StaticRouteType) Reset()      { *m = StaticRouteType{} }
func (*StaticRouteType) ProtoMessage() {}
func (*StaticRouteType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{71}
}
func (m *StaticRouteType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StaticRouteType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StaticRouteType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StaticRouteType.Merge(m, src)
}
func (m *StaticRouteType) XXX_Size() int {
	return m.Size()
}
func (m *StaticRouteType) XXX_DiscardUnknown() {
	xxx_messageInfo_StaticRouteType.DiscardUnknown(m)
}

var xxx_messageInfo_StaticRouteType proto.InternalMessageInfo

func (m *StaticRouteType) GetAttrs() []RouteAttrType {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *StaticRouteType) GetSubnets() []*IpSubnetType {
	if m != nil {
		return m.Subnets
	}
	return nil
}

func (m *StaticRouteType) GetNexthop() *NextHopType {
	if m != nil {
		return m.Nexthop
	}
	return nil
}

func (m *StaticRouteType) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

// ForwardProxyConfigType
//
// x-displayName: "Forward Proxy Configuration"
// Fine tune forward proxy behavior
//
// Few configurations allowed are
//
//   White listed ports and ip prefixes:
//     Forward proxy does application protocol detection and server name(SNI) detection by peeking into
//     the traffic on the incoming downstream connection. Few protocols doesn't have client sending
//     the first data. In such cases, protocol and SNI detection fails. This configuration allows,
//     skipping protocol and SNI detection for whitelisted ip-prefix-list and ports
//   connection_timeout:
//     The timeout for new network connections to upstream server.
//   max_connect_attempts:
//     Maximum number of attempts made to make new network connection to upstream server.
//
type ForwardProxyConfigType struct {
	// IP prefix list
	//
	// x-displayName: "IP Prefixes to Skip Protocol Parsing"
	// x-example: "['10.2.1.0/24', '192.168.8.0/29', '10.7.64.160/27']"
	// Traffic to these destination ip prefixes is not subjected to protocol parsing
	// Example "tmate" server ip
	WhiteListedPrefixes []string `protobuf:"bytes,1,rep,name=white_listed_prefixes,json=whiteListedPrefixes,proto3" json:"white_listed_prefixes,omitempty"`
	// Port list
	//
	// x-displayName: "TCP Ports to Skip Protocol Parsing"
	// x-example: [22, 9400]
	// Traffic to these destination TCP ports is not subjected to protocol parsing
	// Example "tmate" server port
	WhiteListedPorts []uint32 `protobuf:"varint,2,rep,packed,name=white_listed_ports,json=whiteListedPorts,proto3" json:"white_listed_ports,omitempty"`
	// max_connect_attempts
	//
	// x-displayName: "Number of connect attempts"
	// x-example: 3
	// Specifies the allowed number of retries on connect failure to upstream server. Defaults to 1.
	MaxConnectAttempts uint32 `protobuf:"varint,3,opt,name=max_connect_attempts,json=maxConnectAttempts,proto3" json:"max_connect_attempts,omitempty"`
	// connection_timeout
	//
	// x-displayName: "Connection Timeout"
	// x-example: "4000"
	// The timeout for new network connections to upstream server.
	// This is specified in milliseconds. The default value is 2000 (2 seconds)
	ConnectionTimeout uint32 `protobuf:"varint,4,opt,name=connection_timeout,json=connectionTimeout,proto3" json:"connection_timeout,omitempty"`
	// TLS Interception choice
	//
	// x-displayName: "Enable TLS Interception"
	// TLS interception is enabled for HTTPS connections
	// This configuration is applicable only when ForwardProxy and DynamicReverseProxy is enabled on the network connector
	//
	// Types that are valid to be assigned to TlsInterceptionChoice:
	//	*ForwardProxyConfigType_NoInterception
	//	*ForwardProxyConfigType_TlsIntercept
	TlsInterceptionChoice isForwardProxyConfigType_TlsInterceptionChoice `protobuf_oneof:"tls_interception_choice"`
}

func (m *ForwardProxyConfigType) Reset()      { *m = ForwardProxyConfigType{} }
func (*ForwardProxyConfigType) ProtoMessage() {}
func (*ForwardProxyConfigType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{72}
}
func (m *ForwardProxyConfigType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForwardProxyConfigType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ForwardProxyConfigType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForwardProxyConfigType.Merge(m, src)
}
func (m *ForwardProxyConfigType) XXX_Size() int {
	return m.Size()
}
func (m *ForwardProxyConfigType) XXX_DiscardUnknown() {
	xxx_messageInfo_ForwardProxyConfigType.DiscardUnknown(m)
}

var xxx_messageInfo_ForwardProxyConfigType proto.InternalMessageInfo

type isForwardProxyConfigType_TlsInterceptionChoice interface {
	isForwardProxyConfigType_TlsInterceptionChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ForwardProxyConfigType_NoInterception struct {
	NoInterception *Empty `protobuf:"bytes,6,opt,name=no_interception,json=noInterception,proto3,oneof" json:"no_interception,omitempty"`
}
type ForwardProxyConfigType_TlsIntercept struct {
	TlsIntercept *TlsInterceptionType `protobuf:"bytes,7,opt,name=tls_intercept,json=tlsIntercept,proto3,oneof" json:"tls_intercept,omitempty"`
}

func (*ForwardProxyConfigType_NoInterception) isForwardProxyConfigType_TlsInterceptionChoice() {}
func (*ForwardProxyConfigType_TlsIntercept) isForwardProxyConfigType_TlsInterceptionChoice()   {}

func (m *ForwardProxyConfigType) GetTlsInterceptionChoice() isForwardProxyConfigType_TlsInterceptionChoice {
	if m != nil {
		return m.TlsInterceptionChoice
	}
	return nil
}

func (m *ForwardProxyConfigType) GetWhiteListedPrefixes() []string {
	if m != nil {
		return m.WhiteListedPrefixes
	}
	return nil
}

func (m *ForwardProxyConfigType) GetWhiteListedPorts() []uint32 {
	if m != nil {
		return m.WhiteListedPorts
	}
	return nil
}

func (m *ForwardProxyConfigType) GetMaxConnectAttempts() uint32 {
	if m != nil {
		return m.MaxConnectAttempts
	}
	return 0
}

func (m *ForwardProxyConfigType) GetConnectionTimeout() uint32 {
	if m != nil {
		return m.ConnectionTimeout
	}
	return 0
}

func (m *ForwardProxyConfigType) GetNoInterception() *Empty {
	if x, ok := m.GetTlsInterceptionChoice().(*ForwardProxyConfigType_NoInterception); ok {
		return x.NoInterception
	}
	return nil
}

func (m *ForwardProxyConfigType) GetTlsIntercept() *TlsInterceptionType {
	if x, ok := m.GetTlsInterceptionChoice().(*ForwardProxyConfigType_TlsIntercept); ok {
		return x.TlsIntercept
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ForwardProxyConfigType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ForwardProxyConfigType_NoInterception)(nil),
		(*ForwardProxyConfigType_TlsIntercept)(nil),
	}
}

// Host Identifier
//
// x-displayName: "Host Identifier"
// Host Identifier identifies a host, either by its DNS name (hostname) or by its IP address.
type HostIdentifier struct {
	// hostname_or_ip
	//
	// x-displayName: "Hostname/IP"
	// One of following
	//
	// Types that are valid to be assigned to HostnameOrIp:
	//	*HostIdentifier_Ip
	//	*HostIdentifier_Hostname
	HostnameOrIp isHostIdentifier_HostnameOrIp `protobuf_oneof:"hostname_or_ip"`
}

func (m *HostIdentifier) Reset()      { *m = HostIdentifier{} }
func (*HostIdentifier) ProtoMessage() {}
func (*HostIdentifier) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{73}
}
func (m *HostIdentifier) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HostIdentifier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HostIdentifier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostIdentifier.Merge(m, src)
}
func (m *HostIdentifier) XXX_Size() int {
	return m.Size()
}
func (m *HostIdentifier) XXX_DiscardUnknown() {
	xxx_messageInfo_HostIdentifier.DiscardUnknown(m)
}

var xxx_messageInfo_HostIdentifier proto.InternalMessageInfo

type isHostIdentifier_HostnameOrIp interface {
	isHostIdentifier_HostnameOrIp()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type HostIdentifier_Ip struct {
	Ip string `protobuf:"bytes,1,opt,name=ip,proto3,oneof" json:"ip,omitempty"`
}
type HostIdentifier_Hostname struct {
	Hostname string `protobuf:"bytes,2,opt,name=hostname,proto3,oneof" json:"hostname,omitempty"`
}

func (*HostIdentifier_Ip) isHostIdentifier_HostnameOrIp()       {}
func (*HostIdentifier_Hostname) isHostIdentifier_HostnameOrIp() {}

func (m *HostIdentifier) GetHostnameOrIp() isHostIdentifier_HostnameOrIp {
	if m != nil {
		return m.HostnameOrIp
	}
	return nil
}

func (m *HostIdentifier) GetIp() string {
	if x, ok := m.GetHostnameOrIp().(*HostIdentifier_Ip); ok {
		return x.Ip
	}
	return ""
}

func (m *HostIdentifier) GetHostname() string {
	if x, ok := m.GetHostnameOrIp().(*HostIdentifier_Hostname); ok {
		return x.Hostname
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HostIdentifier) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HostIdentifier_Ip)(nil),
		(*HostIdentifier_Hostname)(nil),
	}
}

// Interface Identifier
//
// x-displayName: "Interface Identifier"
// Interface Identifier identifies one or all interfaces on a node
type InterfaceIdentifier struct {
	// Interface Choice
	//
	// x-displayName: "Interface Choice"
	// One of following
	//
	// Types that are valid to be assigned to InterfaceChoice:
	//	*InterfaceIdentifier_AnyIntf
	//	*InterfaceIdentifier_Intf
	InterfaceChoice isInterfaceIdentifier_InterfaceChoice `protobuf_oneof:"interface_choice"`
}

func (m *InterfaceIdentifier) Reset()      { *m = InterfaceIdentifier{} }
func (*InterfaceIdentifier) ProtoMessage() {}
func (*InterfaceIdentifier) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{74}
}
func (m *InterfaceIdentifier) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceIdentifier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InterfaceIdentifier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceIdentifier.Merge(m, src)
}
func (m *InterfaceIdentifier) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceIdentifier) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceIdentifier.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceIdentifier proto.InternalMessageInfo

type isInterfaceIdentifier_InterfaceChoice interface {
	isInterfaceIdentifier_InterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type InterfaceIdentifier_AnyIntf struct {
	AnyIntf *Empty `protobuf:"bytes,1,opt,name=any_intf,json=anyIntf,proto3,oneof" json:"any_intf,omitempty"`
}
type InterfaceIdentifier_Intf struct {
	Intf string `protobuf:"bytes,2,opt,name=intf,proto3,oneof" json:"intf,omitempty"`
}

func (*InterfaceIdentifier_AnyIntf) isInterfaceIdentifier_InterfaceChoice() {}
func (*InterfaceIdentifier_Intf) isInterfaceIdentifier_InterfaceChoice()    {}

func (m *InterfaceIdentifier) GetInterfaceChoice() isInterfaceIdentifier_InterfaceChoice {
	if m != nil {
		return m.InterfaceChoice
	}
	return nil
}

func (m *InterfaceIdentifier) GetAnyIntf() *Empty {
	if x, ok := m.GetInterfaceChoice().(*InterfaceIdentifier_AnyIntf); ok {
		return x.AnyIntf
	}
	return nil
}

func (m *InterfaceIdentifier) GetIntf() string {
	if x, ok := m.GetInterfaceChoice().(*InterfaceIdentifier_Intf); ok {
		return x.Intf
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*InterfaceIdentifier) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*InterfaceIdentifier_AnyIntf)(nil),
		(*InterfaceIdentifier_Intf)(nil),
	}
}

// Interface Or Network
//
// x-displayName: "Interface Or Network"
// Selects an interface on a node
type InterfaceOrNetwork struct {
	// Interface Choice
	//
	// x-displayName: "Interface Choice"
	// One of following
	//
	// Types that are valid to be assigned to InterfaceChoice:
	//	*InterfaceOrNetwork_Intf
	//	*InterfaceOrNetwork_Pod
	//	*InterfaceOrNetwork_VnType
	//	*InterfaceOrNetwork_Vn
	InterfaceChoice isInterfaceOrNetwork_InterfaceChoice `protobuf_oneof:"interface_choice"`
}

func (m *InterfaceOrNetwork) Reset()      { *m = InterfaceOrNetwork{} }
func (*InterfaceOrNetwork) ProtoMessage() {}
func (*InterfaceOrNetwork) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{75}
}
func (m *InterfaceOrNetwork) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceOrNetwork) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InterfaceOrNetwork) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceOrNetwork.Merge(m, src)
}
func (m *InterfaceOrNetwork) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceOrNetwork) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceOrNetwork.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceOrNetwork proto.InternalMessageInfo

type isInterfaceOrNetwork_InterfaceChoice interface {
	isInterfaceOrNetwork_InterfaceChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type InterfaceOrNetwork_Intf struct {
	Intf string `protobuf:"bytes,1,opt,name=intf,proto3,oneof" json:"intf,omitempty"`
}
type InterfaceOrNetwork_Pod struct {
	Pod string `protobuf:"bytes,2,opt,name=pod,proto3,oneof" json:"pod,omitempty"`
}
type InterfaceOrNetwork_VnType struct {
	VnType VirtualNetworkType `protobuf:"varint,3,opt,name=vn_type,json=vnType,proto3,enum=ves.io.schema.VirtualNetworkType,oneof" json:"vn_type,omitempty"`
}
type InterfaceOrNetwork_Vn struct {
	Vn string `protobuf:"bytes,4,opt,name=vn,proto3,oneof" json:"vn,omitempty"`
}

func (*InterfaceOrNetwork_Intf) isInterfaceOrNetwork_InterfaceChoice()   {}
func (*InterfaceOrNetwork_Pod) isInterfaceOrNetwork_InterfaceChoice()    {}
func (*InterfaceOrNetwork_VnType) isInterfaceOrNetwork_InterfaceChoice() {}
func (*InterfaceOrNetwork_Vn) isInterfaceOrNetwork_InterfaceChoice()     {}

func (m *InterfaceOrNetwork) GetInterfaceChoice() isInterfaceOrNetwork_InterfaceChoice {
	if m != nil {
		return m.InterfaceChoice
	}
	return nil
}

func (m *InterfaceOrNetwork) GetIntf() string {
	if x, ok := m.GetInterfaceChoice().(*InterfaceOrNetwork_Intf); ok {
		return x.Intf
	}
	return ""
}

func (m *InterfaceOrNetwork) GetPod() string {
	if x, ok := m.GetInterfaceChoice().(*InterfaceOrNetwork_Pod); ok {
		return x.Pod
	}
	return ""
}

func (m *InterfaceOrNetwork) GetVnType() VirtualNetworkType {
	if x, ok := m.GetInterfaceChoice().(*InterfaceOrNetwork_VnType); ok {
		return x.VnType
	}
	return VIRTUAL_NETWORK_SITE_LOCAL
}

func (m *InterfaceOrNetwork) GetVn() string {
	if x, ok := m.GetInterfaceChoice().(*InterfaceOrNetwork_Vn); ok {
		return x.Vn
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*InterfaceOrNetwork) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*InterfaceOrNetwork_Intf)(nil),
		(*InterfaceOrNetwork_Pod)(nil),
		(*InterfaceOrNetwork_VnType)(nil),
		(*InterfaceOrNetwork_Vn)(nil),
	}
}

// RouteTarget2ByteAsn
//
// x-displayName: "Route Target"
// BGP Two-Octet AS Specific Route Target as per RFC 4360.
type RouteTarget2ByteAsn struct {
	// as_number
	//
	// x-displayName: "AS Number"
	// x-required
	// Two-Octet AS Number.
	AsNumber uint32 `protobuf:"varint,3,opt,name=as_number,json=asNumber,proto3" json:"as_number,omitempty"`
	// value
	//
	// x-displayName: "Local Administrator Field"
	// x-required
	// A 4-byte value that is unique in the scope of the ASN.
	Value uint32 `protobuf:"varint,4,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *RouteTarget2ByteAsn) Reset()      { *m = RouteTarget2ByteAsn{} }
func (*RouteTarget2ByteAsn) ProtoMessage() {}
func (*RouteTarget2ByteAsn) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{76}
}
func (m *RouteTarget2ByteAsn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteTarget2ByteAsn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteTarget2ByteAsn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteTarget2ByteAsn.Merge(m, src)
}
func (m *RouteTarget2ByteAsn) XXX_Size() int {
	return m.Size()
}
func (m *RouteTarget2ByteAsn) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteTarget2ByteAsn.DiscardUnknown(m)
}

var xxx_messageInfo_RouteTarget2ByteAsn proto.InternalMessageInfo

func (m *RouteTarget2ByteAsn) GetAsNumber() uint32 {
	if m != nil {
		return m.AsNumber
	}
	return 0
}

func (m *RouteTarget2ByteAsn) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

// RouteTarget4ByteAsn
//
// x-displayName: "Four-Octet AS Specific Route Target"
// BGP Four-Octet AS Specific Route Target as per RFC 5668.
type RouteTarget4ByteAsn struct {
	// as_number
	//
	// x-displayName: "AS Number"
	// x-required
	// Four-Octet AS Number.
	AsNumber uint32 `protobuf:"varint,3,opt,name=as_number,json=asNumber,proto3" json:"as_number,omitempty"`
	// value
	//
	// x-displayName: "Local Administrator Field"
	// x-required
	// A 2-byte value that is unique in the scope of the ASN.
	Value uint32 `protobuf:"varint,4,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *RouteTarget4ByteAsn) Reset()      { *m = RouteTarget4ByteAsn{} }
func (*RouteTarget4ByteAsn) ProtoMessage() {}
func (*RouteTarget4ByteAsn) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{77}
}
func (m *RouteTarget4ByteAsn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteTarget4ByteAsn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteTarget4ByteAsn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteTarget4ByteAsn.Merge(m, src)
}
func (m *RouteTarget4ByteAsn) XXX_Size() int {
	return m.Size()
}
func (m *RouteTarget4ByteAsn) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteTarget4ByteAsn.DiscardUnknown(m)
}

var xxx_messageInfo_RouteTarget4ByteAsn proto.InternalMessageInfo

func (m *RouteTarget4ByteAsn) GetAsNumber() uint32 {
	if m != nil {
		return m.AsNumber
	}
	return 0
}

func (m *RouteTarget4ByteAsn) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

// RouteTargetIPv4Addr
//
// x-displayName: "IPv4 Address Specific Route Target"
// BGP IPv4 Address Specific Route Target as per RFC 4360.
type RouteTargetIPv4Addr struct {
	// address
	//
	// x-displayName: "IPv4 Address"
	// x-required
	// IPv4 Address
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// value
	//
	// x-displayName: "Local Administrator Field"
	// x-required
	// A 4-byte value that is unique in the scope of the IPv4 address.
	Value uint32 `protobuf:"varint,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *RouteTargetIPv4Addr) Reset()      { *m = RouteTargetIPv4Addr{} }
func (*RouteTargetIPv4Addr) ProtoMessage() {}
func (*RouteTargetIPv4Addr) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{78}
}
func (m *RouteTargetIPv4Addr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteTargetIPv4Addr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteTargetIPv4Addr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteTargetIPv4Addr.Merge(m, src)
}
func (m *RouteTargetIPv4Addr) XXX_Size() int {
	return m.Size()
}
func (m *RouteTargetIPv4Addr) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteTargetIPv4Addr.DiscardUnknown(m)
}

var xxx_messageInfo_RouteTargetIPv4Addr proto.InternalMessageInfo

func (m *RouteTargetIPv4Addr) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RouteTargetIPv4Addr) GetValue() uint32 {
	if m != nil {
		return m.Value
	}
	return 0
}

// RouteTarget
//
// x-displayName: "Route Target"
// BGP Route Target extended community as per RFC 4360.
type RouteTarget struct {
	// rtarget_choice
	//
	// x-displayName: "Route Target Type"
	// x-required
	// Select type of Route Target.
	//
	// Types that are valid to be assigned to RtargetChoice:
	//	*RouteTarget_Asn2ByteRtarget
	//	*RouteTarget_Ipv4AddrRtarget
	//	*RouteTarget_Asn4ByteRtarget
	RtargetChoice isRouteTarget_RtargetChoice `protobuf_oneof:"rtarget_choice"`
}

func (m *RouteTarget) Reset()      { *m = RouteTarget{} }
func (*RouteTarget) ProtoMessage() {}
func (*RouteTarget) Descriptor() ([]byte, []int) {
	return fileDescriptor_f21334e98d27f9ba, []int{79}
}
func (m *RouteTarget) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteTarget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RouteTarget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteTarget.Merge(m, src)
}
func (m *RouteTarget) XXX_Size() int {
	return m.Size()
}
func (m *RouteTarget) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteTarget.DiscardUnknown(m)
}

var xxx_messageInfo_RouteTarget proto.InternalMessageInfo

type isRouteTarget_RtargetChoice interface {
	isRouteTarget_RtargetChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type RouteTarget_Asn2ByteRtarget struct {
	Asn2ByteRtarget *RouteTarget2ByteAsn `protobuf:"bytes,2,opt,name=asn2byte_rtarget,json=asn2byteRtarget,proto3,oneof" json:"asn2byte_rtarget,omitempty"`
}
type RouteTarget_Ipv4AddrRtarget struct {
	Ipv4AddrRtarget *RouteTargetIPv4Addr `protobuf:"bytes,3,opt,name=ipv4_addr_rtarget,json=ipv4AddrRtarget,proto3,oneof" json:"ipv4_addr_rtarget,omitempty"`
}
type RouteTarget_Asn4ByteRtarget struct {
	Asn4ByteRtarget *RouteTarget4ByteAsn `protobuf:"bytes,4,opt,name=asn4byte_rtarget,json=asn4byteRtarget,proto3,oneof" json:"asn4byte_rtarget,omitempty"`
}

func (*RouteTarget_Asn2ByteRtarget) isRouteTarget_RtargetChoice() {}
func (*RouteTarget_Ipv4AddrRtarget) isRouteTarget_RtargetChoice() {}
func (*RouteTarget_Asn4ByteRtarget) isRouteTarget_RtargetChoice() {}

func (m *RouteTarget) GetRtargetChoice() isRouteTarget_RtargetChoice {
	if m != nil {
		return m.RtargetChoice
	}
	return nil
}

func (m *RouteTarget) GetAsn2ByteRtarget() *RouteTarget2ByteAsn {
	if x, ok := m.GetRtargetChoice().(*RouteTarget_Asn2ByteRtarget); ok {
		return x.Asn2ByteRtarget
	}
	return nil
}

func (m *RouteTarget) GetIpv4AddrRtarget() *RouteTargetIPv4Addr {
	if x, ok := m.GetRtargetChoice().(*RouteTarget_Ipv4AddrRtarget); ok {
		return x.Ipv4AddrRtarget
	}
	return nil
}

func (m *RouteTarget) GetAsn4ByteRtarget() *RouteTarget4ByteAsn {
	if x, ok := m.GetRtargetChoice().(*RouteTarget_Asn4ByteRtarget); ok {
		return x.Asn4ByteRtarget
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RouteTarget) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RouteTarget_Asn2ByteRtarget)(nil),
		(*RouteTarget_Ipv4AddrRtarget)(nil),
		(*RouteTarget_Asn4ByteRtarget)(nil),
	}
}

func init() {
	proto.RegisterEnum("ves.io.schema.HttpMethod", HttpMethod_name, HttpMethod_value)
	golang_proto.RegisterEnum("ves.io.schema.HttpMethod", HttpMethod_name, HttpMethod_value)
	proto.RegisterEnum("ves.io.schema.HttpStatusCode", HttpStatusCode_name, HttpStatusCode_value)
	golang_proto.RegisterEnum("ves.io.schema.HttpStatusCode", HttpStatusCode_name, HttpStatusCode_value)
	proto.RegisterEnum("ves.io.schema.StatusPublishType", StatusPublishType_name, StatusPublishType_value)
	golang_proto.RegisterEnum("ves.io.schema.StatusPublishType", StatusPublishType_name, StatusPublishType_value)
	proto.RegisterEnum("ves.io.schema.SecretEncodingType", SecretEncodingType_name, SecretEncodingType_value)
	golang_proto.RegisterEnum("ves.io.schema.SecretEncodingType", SecretEncodingType_name, SecretEncodingType_value)
	proto.RegisterEnum("ves.io.schema.URLSchemeType", URLSchemeType_name, URLSchemeType_value)
	golang_proto.RegisterEnum("ves.io.schema.URLSchemeType", URLSchemeType_name, URLSchemeType_value)
	proto.RegisterEnum("ves.io.schema.TlsProtocol", TlsProtocol_name, TlsProtocol_value)
	golang_proto.RegisterEnum("ves.io.schema.TlsProtocol", TlsProtocol_name, TlsProtocol_value)
	proto.RegisterEnum("ves.io.schema.RoutingPriority", RoutingPriority_name, RoutingPriority_value)
	golang_proto.RegisterEnum("ves.io.schema.RoutingPriority", RoutingPriority_name, RoutingPriority_value)
	proto.RegisterEnum("ves.io.schema.DenominatorType", DenominatorType_name, DenominatorType_value)
	golang_proto.RegisterEnum("ves.io.schema.DenominatorType", DenominatorType_name, DenominatorType_value)
	proto.RegisterEnum("ves.io.schema.DiscoveryType", DiscoveryType_name, DiscoveryType_value)
	golang_proto.RegisterEnum("ves.io.schema.DiscoveryType", DiscoveryType_name, DiscoveryType_value)
	proto.RegisterEnum("ves.io.schema.WafModeType", WafModeType_name, WafModeType_value)
	golang_proto.RegisterEnum("ves.io.schema.WafModeType", WafModeType_name, WafModeType_value)
	proto.RegisterEnum("ves.io.schema.VipVrrpType", VipVrrpType_name, VipVrrpType_value)
	golang_proto.RegisterEnum("ves.io.schema.VipVrrpType", VipVrrpType_name, VipVrrpType_value)
	proto.RegisterEnum("ves.io.schema.SiteToSiteTunnelType", SiteToSiteTunnelType_name, SiteToSiteTunnelType_value)
	golang_proto.RegisterEnum("ves.io.schema.SiteToSiteTunnelType", SiteToSiteTunnelType_name, SiteToSiteTunnelType_value)
	proto.RegisterEnum("ves.io.schema.SortOrder", SortOrder_name, SortOrder_value)
	golang_proto.RegisterEnum("ves.io.schema.SortOrder", SortOrder_name, SortOrder_value)
	proto.RegisterEnum("ves.io.schema.TunnelEncapsulationType", TunnelEncapsulationType_name, TunnelEncapsulationType_value)
	golang_proto.RegisterEnum("ves.io.schema.TunnelEncapsulationType", TunnelEncapsulationType_name, TunnelEncapsulationType_value)
	proto.RegisterEnum("ves.io.schema.AppFirewallViolationType", AppFirewallViolationType_name, AppFirewallViolationType_value)
	golang_proto.RegisterEnum("ves.io.schema.AppFirewallViolationType", AppFirewallViolationType_name, AppFirewallViolationType_value)
	proto.RegisterEnum("ves.io.schema.TenantType", TenantType_name, TenantType_value)
	golang_proto.RegisterEnum("ves.io.schema.TenantType", TenantType_name, TenantType_value)
	proto.RegisterEnum("ves.io.schema.TaxExemptionType", TaxExemptionType_name, TaxExemptionType_value)
	golang_proto.RegisterEnum("ves.io.schema.TaxExemptionType", TaxExemptionType_name, TaxExemptionType_value)
	proto.RegisterEnum("ves.io.schema.PlanType", PlanType_name, PlanType_value)
	golang_proto.RegisterEnum("ves.io.schema.PlanType", PlanType_name, PlanType_value)
	proto.RegisterEnum("ves.io.schema.MetricLabelOp", MetricLabelOp_name, MetricLabelOp_value)
	golang_proto.RegisterEnum("ves.io.schema.MetricLabelOp", MetricLabelOp_name, MetricLabelOp_value)
	proto.RegisterEnum("ves.io.schema.RouteAttrType", RouteAttrType_name, RouteAttrType_value)
	golang_proto.RegisterEnum("ves.io.schema.RouteAttrType", RouteAttrType_name, RouteAttrType_value)
	proto.RegisterEnum("ves.io.schema.NextHopTypes", NextHopTypes_name, NextHopTypes_value)
	golang_proto.RegisterEnum("ves.io.schema.NextHopTypes", NextHopTypes_name, NextHopTypes_value)
	proto.RegisterType((*Empty)(nil), "ves.io.schema.Empty")
	golang_proto.RegisterType((*Empty)(nil), "ves.io.schema.Empty")
	proto.RegisterType((*ObjectRefType)(nil), "ves.io.schema.ObjectRefType")
	golang_proto.RegisterType((*ObjectRefType)(nil), "ves.io.schema.ObjectRefType")
	proto.RegisterType((*LabelSelectorType)(nil), "ves.io.schema.LabelSelectorType")
	golang_proto.RegisterType((*LabelSelectorType)(nil), "ves.io.schema.LabelSelectorType")
	proto.RegisterType((*LabelMatcherType)(nil), "ves.io.schema.LabelMatcherType")
	golang_proto.RegisterType((*LabelMatcherType)(nil), "ves.io.schema.LabelMatcherType")
	proto.RegisterType((*ConditionType)(nil), "ves.io.schema.ConditionType")
	golang_proto.RegisterType((*ConditionType)(nil), "ves.io.schema.ConditionType")
	proto.RegisterType((*StatusType)(nil), "ves.io.schema.StatusType")
	golang_proto.RegisterType((*StatusType)(nil), "ves.io.schema.StatusType")
	proto.RegisterType((*InitializerType)(nil), "ves.io.schema.InitializerType")
	golang_proto.RegisterType((*InitializerType)(nil), "ves.io.schema.InitializerType")
	proto.RegisterType((*InitializersType)(nil), "ves.io.schema.InitializersType")
	golang_proto.RegisterType((*InitializersType)(nil), "ves.io.schema.InitializersType")
	proto.RegisterType((*StatusMetaType)(nil), "ves.io.schema.StatusMetaType")
	golang_proto.RegisterType((*StatusMetaType)(nil), "ves.io.schema.StatusMetaType")
	proto.RegisterType((*ObjectMetaType)(nil), "ves.io.schema.ObjectMetaType")
	golang_proto.RegisterType((*ObjectMetaType)(nil), "ves.io.schema.ObjectMetaType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectMetaType.AnnotationsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectMetaType.AnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectMetaType.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectMetaType.LabelsEntry")
	proto.RegisterType((*ListMetaType)(nil), "ves.io.schema.ListMetaType")
	golang_proto.RegisterType((*ListMetaType)(nil), "ves.io.schema.ListMetaType")
	proto.RegisterType((*ObjectGetMetaType)(nil), "ves.io.schema.ObjectGetMetaType")
	golang_proto.RegisterType((*ObjectGetMetaType)(nil), "ves.io.schema.ObjectGetMetaType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectGetMetaType.AnnotationsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectGetMetaType.AnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectGetMetaType.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectGetMetaType.LabelsEntry")
	proto.RegisterType((*ObjectCreateMetaType)(nil), "ves.io.schema.ObjectCreateMetaType")
	golang_proto.RegisterType((*ObjectCreateMetaType)(nil), "ves.io.schema.ObjectCreateMetaType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectCreateMetaType.AnnotationsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectCreateMetaType.AnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectCreateMetaType.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectCreateMetaType.LabelsEntry")
	proto.RegisterType((*ObjectReplaceMetaType)(nil), "ves.io.schema.ObjectReplaceMetaType")
	golang_proto.RegisterType((*ObjectReplaceMetaType)(nil), "ves.io.schema.ObjectReplaceMetaType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectReplaceMetaType.AnnotationsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectReplaceMetaType.AnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectReplaceMetaType.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.ObjectReplaceMetaType.LabelsEntry")
	proto.RegisterType((*MessageMetaType)(nil), "ves.io.schema.MessageMetaType")
	golang_proto.RegisterType((*MessageMetaType)(nil), "ves.io.schema.MessageMetaType")
	proto.RegisterType((*ViewRefType)(nil), "ves.io.schema.ViewRefType")
	golang_proto.RegisterType((*ViewRefType)(nil), "ves.io.schema.ViewRefType")
	proto.RegisterType((*KubeRefType)(nil), "ves.io.schema.KubeRefType")
	golang_proto.RegisterType((*KubeRefType)(nil), "ves.io.schema.KubeRefType")
	proto.RegisterType((*SystemObjectMetaType)(nil), "ves.io.schema.SystemObjectMetaType")
	golang_proto.RegisterType((*SystemObjectMetaType)(nil), "ves.io.schema.SystemObjectMetaType")
	proto.RegisterType((*SystemObjectGetMetaType)(nil), "ves.io.schema.SystemObjectGetMetaType")
	golang_proto.RegisterType((*SystemObjectGetMetaType)(nil), "ves.io.schema.SystemObjectGetMetaType")
	proto.RegisterType((*AuthnTypeBasicAuth)(nil), "ves.io.schema.AuthnTypeBasicAuth")
	golang_proto.RegisterType((*AuthnTypeBasicAuth)(nil), "ves.io.schema.AuthnTypeBasicAuth")
	proto.RegisterType((*AuthnTypeHeaders)(nil), "ves.io.schema.AuthnTypeHeaders")
	golang_proto.RegisterType((*AuthnTypeHeaders)(nil), "ves.io.schema.AuthnTypeHeaders")
	proto.RegisterMapType((map[string]*SecretType)(nil), "ves.io.schema.AuthnTypeHeaders.HeadersEntry")
	golang_proto.RegisterMapType((map[string]*SecretType)(nil), "ves.io.schema.AuthnTypeHeaders.HeadersEntry")
	proto.RegisterType((*AuthnTypeQueryParams)(nil), "ves.io.schema.AuthnTypeQueryParams")
	golang_proto.RegisterType((*AuthnTypeQueryParams)(nil), "ves.io.schema.AuthnTypeQueryParams")
	proto.RegisterMapType((map[string]*SecretType)(nil), "ves.io.schema.AuthnTypeQueryParams.QueryParamsEntry")
	golang_proto.RegisterMapType((map[string]*SecretType)(nil), "ves.io.schema.AuthnTypeQueryParams.QueryParamsEntry")
	proto.RegisterType((*BlindfoldSecretInfoType)(nil), "ves.io.schema.BlindfoldSecretInfoType")
	golang_proto.RegisterType((*BlindfoldSecretInfoType)(nil), "ves.io.schema.BlindfoldSecretInfoType")
	proto.RegisterType((*VaultSecretInfoType)(nil), "ves.io.schema.VaultSecretInfoType")
	golang_proto.RegisterType((*VaultSecretInfoType)(nil), "ves.io.schema.VaultSecretInfoType")
	proto.RegisterType((*ClearSecretInfoType)(nil), "ves.io.schema.ClearSecretInfoType")
	golang_proto.RegisterType((*ClearSecretInfoType)(nil), "ves.io.schema.ClearSecretInfoType")
	proto.RegisterType((*WingmanSecretInfoType)(nil), "ves.io.schema.WingmanSecretInfoType")
	golang_proto.RegisterType((*WingmanSecretInfoType)(nil), "ves.io.schema.WingmanSecretInfoType")
	proto.RegisterType((*SecretType)(nil), "ves.io.schema.SecretType")
	golang_proto.RegisterType((*SecretType)(nil), "ves.io.schema.SecretType")
	proto.RegisterType((*NetworkRefType)(nil), "ves.io.schema.NetworkRefType")
	golang_proto.RegisterType((*NetworkRefType)(nil), "ves.io.schema.NetworkRefType")
	proto.RegisterType((*SiteRefType)(nil), "ves.io.schema.SiteRefType")
	golang_proto.RegisterType((*SiteRefType)(nil), "ves.io.schema.SiteRefType")
	proto.RegisterType((*IpPrefixSetRefType)(nil), "ves.io.schema.IpPrefixSetRefType")
	golang_proto.RegisterType((*IpPrefixSetRefType)(nil), "ves.io.schema.IpPrefixSetRefType")
	proto.RegisterType((*VSiteRefType)(nil), "ves.io.schema.VSiteRefType")
	golang_proto.RegisterType((*VSiteRefType)(nil), "ves.io.schema.VSiteRefType")
	proto.RegisterType((*PolicerRefType)(nil), "ves.io.schema.PolicerRefType")
	golang_proto.RegisterType((*PolicerRefType)(nil), "ves.io.schema.PolicerRefType")
	proto.RegisterType((*ProtocolPolicerRefType)(nil), "ves.io.schema.ProtocolPolicerRefType")
	golang_proto.RegisterType((*ProtocolPolicerRefType)(nil), "ves.io.schema.ProtocolPolicerRefType")
	proto.RegisterType((*NetworkSiteRefSelector)(nil), "ves.io.schema.NetworkSiteRefSelector")
	golang_proto.RegisterType((*NetworkSiteRefSelector)(nil), "ves.io.schema.NetworkSiteRefSelector")
	proto.RegisterType((*SiteVirtualSiteRefSelector)(nil), "ves.io.schema.SiteVirtualSiteRefSelector")
	golang_proto.RegisterType((*SiteVirtualSiteRefSelector)(nil), "ves.io.schema.SiteVirtualSiteRefSelector")
	proto.RegisterType((*HeaderManipulationOptionType)(nil), "ves.io.schema.HeaderManipulationOptionType")
	golang_proto.RegisterType((*HeaderManipulationOptionType)(nil), "ves.io.schema.HeaderManipulationOptionType")
	proto.RegisterType((*TlsValidationParamsType)(nil), "ves.io.schema.TlsValidationParamsType")
	golang_proto.RegisterType((*TlsValidationParamsType)(nil), "ves.io.schema.TlsValidationParamsType")
	proto.RegisterType((*TlsCertificateType)(nil), "ves.io.schema.TlsCertificateType")
	golang_proto.RegisterType((*TlsCertificateType)(nil), "ves.io.schema.TlsCertificateType")
	proto.RegisterType((*TlsParamsType)(nil), "ves.io.schema.TlsParamsType")
	golang_proto.RegisterType((*TlsParamsType)(nil), "ves.io.schema.TlsParamsType")
	proto.RegisterType((*UpstreamTlsParamsType)(nil), "ves.io.schema.UpstreamTlsParamsType")
	golang_proto.RegisterType((*UpstreamTlsParamsType)(nil), "ves.io.schema.UpstreamTlsParamsType")
	proto.RegisterType((*DownstreamTlsParamsType)(nil), "ves.io.schema.DownstreamTlsParamsType")
	golang_proto.RegisterType((*DownstreamTlsParamsType)(nil), "ves.io.schema.DownstreamTlsParamsType")
	proto.RegisterType((*DomainType)(nil), "ves.io.schema.DomainType")
	golang_proto.RegisterType((*DomainType)(nil), "ves.io.schema.DomainType")
	proto.RegisterType((*L4DestType)(nil), "ves.io.schema.L4DestType")
	golang_proto.RegisterType((*L4DestType)(nil), "ves.io.schema.L4DestType")
	proto.RegisterType((*TlsInterceptionRule)(nil), "ves.io.schema.TlsInterceptionRule")
	golang_proto.RegisterType((*TlsInterceptionRule)(nil), "ves.io.schema.TlsInterceptionRule")
	proto.RegisterType((*TlsInterceptionPolicy)(nil), "ves.io.schema.TlsInterceptionPolicy")
	golang_proto.RegisterType((*TlsInterceptionPolicy)(nil), "ves.io.schema.TlsInterceptionPolicy")
	proto.RegisterType((*TlsInterceptionType)(nil), "ves.io.schema.TlsInterceptionType")
	golang_proto.RegisterType((*TlsInterceptionType)(nil), "ves.io.schema.TlsInterceptionType")
	proto.RegisterType((*FractionalPercent)(nil), "ves.io.schema.FractionalPercent")
	golang_proto.RegisterType((*FractionalPercent)(nil), "ves.io.schema.FractionalPercent")
	proto.RegisterType((*BufferConfigType)(nil), "ves.io.schema.BufferConfigType")
	golang_proto.RegisterType((*BufferConfigType)(nil), "ves.io.schema.BufferConfigType")
	proto.RegisterType((*CorsPolicy)(nil), "ves.io.schema.CorsPolicy")
	golang_proto.RegisterType((*CorsPolicy)(nil), "ves.io.schema.CorsPolicy")
	proto.RegisterType((*PathMatcherType)(nil), "ves.io.schema.PathMatcherType")
	golang_proto.RegisterType((*PathMatcherType)(nil), "ves.io.schema.PathMatcherType")
	proto.RegisterType((*HeaderMatcherType)(nil), "ves.io.schema.HeaderMatcherType")
	golang_proto.RegisterType((*HeaderMatcherType)(nil), "ves.io.schema.HeaderMatcherType")
	proto.RegisterType((*QueryParameterMatcherType)(nil), "ves.io.schema.QueryParameterMatcherType")
	golang_proto.RegisterType((*QueryParameterMatcherType)(nil), "ves.io.schema.QueryParameterMatcherType")
	proto.RegisterType((*RouteMatch)(nil), "ves.io.schema.RouteMatch")
	golang_proto.RegisterType((*RouteMatch)(nil), "ves.io.schema.RouteMatch")
	proto.RegisterType((*WafRefType)(nil), "ves.io.schema.WafRefType")
	golang_proto.RegisterType((*WafRefType)(nil), "ves.io.schema.WafRefType")
	proto.RegisterType((*WafRulesRefType)(nil), "ves.io.schema.WafRulesRefType")
	golang_proto.RegisterType((*WafRulesRefType)(nil), "ves.io.schema.WafRulesRefType")
	proto.RegisterType((*AppFirewallRefType)(nil), "ves.io.schema.AppFirewallRefType")
	golang_proto.RegisterType((*AppFirewallRefType)(nil), "ves.io.schema.AppFirewallRefType")
	proto.RegisterType((*WafType)(nil), "ves.io.schema.WafType")
	golang_proto.RegisterType((*WafType)(nil), "ves.io.schema.WafType")
	proto.RegisterType((*AppRoleAuthInfoType)(nil), "ves.io.schema.AppRoleAuthInfoType")
	golang_proto.RegisterType((*AppRoleAuthInfoType)(nil), "ves.io.schema.AppRoleAuthInfoType")
	proto.RegisterType((*VaultAuthInfoType)(nil), "ves.io.schema.VaultAuthInfoType")
	golang_proto.RegisterType((*VaultAuthInfoType)(nil), "ves.io.schema.VaultAuthInfoType")
	proto.RegisterType((*RestAuthInfoType)(nil), "ves.io.schema.RestAuthInfoType")
	golang_proto.RegisterType((*RestAuthInfoType)(nil), "ves.io.schema.RestAuthInfoType")
	proto.RegisterType((*HostAccessInfoType)(nil), "ves.io.schema.HostAccessInfoType")
	golang_proto.RegisterType((*HostAccessInfoType)(nil), "ves.io.schema.HostAccessInfoType")
	proto.RegisterType((*VaultAccessInfoType)(nil), "ves.io.schema.VaultAccessInfoType")
	golang_proto.RegisterType((*VaultAccessInfoType)(nil), "ves.io.schema.VaultAccessInfoType")
	proto.RegisterType((*VaultSecretType)(nil), "ves.io.schema.VaultSecretType")
	golang_proto.RegisterType((*VaultSecretType)(nil), "ves.io.schema.VaultSecretType")
	proto.RegisterType((*VolterraSecretType)(nil), "ves.io.schema.VolterraSecretType")
	golang_proto.RegisterType((*VolterraSecretType)(nil), "ves.io.schema.VolterraSecretType")
	proto.RegisterType((*PortValueType)(nil), "ves.io.schema.PortValueType")
	golang_proto.RegisterType((*PortValueType)(nil), "ves.io.schema.PortValueType")
	proto.RegisterType((*VirtualNetworkReferenceType)(nil), "ves.io.schema.VirtualNetworkReferenceType")
	golang_proto.RegisterType((*VirtualNetworkReferenceType)(nil), "ves.io.schema.VirtualNetworkReferenceType")
	proto.RegisterType((*VirtualNetworkSelectorType)(nil), "ves.io.schema.VirtualNetworkSelectorType")
	golang_proto.RegisterType((*VirtualNetworkSelectorType)(nil), "ves.io.schema.VirtualNetworkSelectorType")
	proto.RegisterType((*RetryBackOff)(nil), "ves.io.schema.RetryBackOff")
	golang_proto.RegisterType((*RetryBackOff)(nil), "ves.io.schema.RetryBackOff")
	proto.RegisterType((*RetryPolicyType)(nil), "ves.io.schema.RetryPolicyType")
	golang_proto.RegisterType((*RetryPolicyType)(nil), "ves.io.schema.RetryPolicyType")
	proto.RegisterType((*MetricValue)(nil), "ves.io.schema.MetricValue")
	golang_proto.RegisterType((*MetricValue)(nil), "ves.io.schema.MetricValue")
	proto.RegisterType((*NextHopType)(nil), "ves.io.schema.NextHopType")
	golang_proto.RegisterType((*NextHopType)(nil), "ves.io.schema.NextHopType")
	proto.RegisterType((*StaticRouteType)(nil), "ves.io.schema.StaticRouteType")
	golang_proto.RegisterType((*StaticRouteType)(nil), "ves.io.schema.StaticRouteType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.StaticRouteType.LabelsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.StaticRouteType.LabelsEntry")
	proto.RegisterType((*ForwardProxyConfigType)(nil), "ves.io.schema.ForwardProxyConfigType")
	golang_proto.RegisterType((*ForwardProxyConfigType)(nil), "ves.io.schema.ForwardProxyConfigType")
	proto.RegisterType((*HostIdentifier)(nil), "ves.io.schema.HostIdentifier")
	golang_proto.RegisterType((*HostIdentifier)(nil), "ves.io.schema.HostIdentifier")
	proto.RegisterType((*InterfaceIdentifier)(nil), "ves.io.schema.InterfaceIdentifier")
	golang_proto.RegisterType((*InterfaceIdentifier)(nil), "ves.io.schema.InterfaceIdentifier")
	proto.RegisterType((*InterfaceOrNetwork)(nil), "ves.io.schema.InterfaceOrNetwork")
	golang_proto.RegisterType((*InterfaceOrNetwork)(nil), "ves.io.schema.InterfaceOrNetwork")
	proto.RegisterType((*RouteTarget2ByteAsn)(nil), "ves.io.schema.RouteTarget2ByteAsn")
	golang_proto.RegisterType((*RouteTarget2ByteAsn)(nil), "ves.io.schema.RouteTarget2ByteAsn")
	proto.RegisterType((*RouteTarget4ByteAsn)(nil), "ves.io.schema.RouteTarget4ByteAsn")
	golang_proto.RegisterType((*RouteTarget4ByteAsn)(nil), "ves.io.schema.RouteTarget4ByteAsn")
	proto.RegisterType((*RouteTargetIPv4Addr)(nil), "ves.io.schema.RouteTargetIPv4Addr")
	golang_proto.RegisterType((*RouteTargetIPv4Addr)(nil), "ves.io.schema.RouteTargetIPv4Addr")
	proto.RegisterType((*RouteTarget)(nil), "ves.io.schema.RouteTarget")
	golang_proto.RegisterType((*RouteTarget)(nil), "ves.io.schema.RouteTarget")
}

func init() { proto.RegisterFile("ves.io/schema/types.proto", fileDescriptor_f21334e98d27f9ba) }
func init() { golang_proto.RegisterFile("ves.io/schema/types.proto", fileDescriptor_f21334e98d27f9ba) }

var fileDescriptor_f21334e98d27f9ba = []byte{
	// 9298 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x7d, 0x6d, 0x70, 0x1b, 0xd9,
	0x91, 0x18, 0x07, 0x00, 0x49, 0xb0, 0x41, 0x12, 0xc3, 0x47, 0x49, 0xa4, 0x28, 0x89, 0x82, 0x20,
	0xed, 0xae, 0xcc, 0xa5, 0x3e, 0x48, 0x51, 0xd2, 0x2e, 0x6f, 0x2d, 0xef, 0x00, 0x18, 0x0a, 0x90,
	0x40, 0x00, 0x3b, 0x03, 0x50, 0x96, 0xef, 0xea, 0x26, 0x43, 0xe0, 0x81, 0x9c, 0x08, 0x98, 0x81,
	0x67, 0x06, 0xfc, 0xb8, 0x94, 0x12, 0x5d, 0xea, 0x7e, 0xa4, 0xd6, 0xa9, 0x94, 0x6f, 0xe3, 0xe4,
	0x9c, 0xcd, 0x25, 0xd9, 0xe4, 0x7c, 0x67, 0x97, 0xca, 0x97, 0xbb, 0xab, 0x4b, 0xf2, 0x23, 0x54,
	0xea, 0x14, 0x39, 0xa9, 0x72, 0x1c, 0x27, 0xde, 0x9f, 0x2e, 0xe7, 0x52, 0x67, 0xcb, 0x57, 0x57,
	0x3e, 0x57, 0x7e, 0xb8, 0xb6, 0x92, 0x3b, 0xe7, 0xa3, 0xb2, 0xa9, 0xf7, 0x31, 0x83, 0x01, 0x08,
	0x92, 0xf2, 0xda, 0x8e, 0xef, 0xc7, 0xed, 0x0f, 0x6a, 0xe6, 0xbd, 0xee, 0x7e, 0xfd, 0xba, 0xfb,
	0xf5, 0xeb, 0x7e, 0xaf, 0x07, 0x0b, 0x27, 0xb7, 0xb0, 0x73, 0xd9, 0xb0, 0xae, 0x38, 0xd5, 0x4d,
	0xdc, 0xd4, 0xaf, 0xb8, 0xbb, 0x2d, 0xec, 0x5c, 0x6e, 0xd9, 0x96, 0x6b, 0xa1, 0x31, 0xd6, 0x75,
	0x99, 0x75, 0xcd, 0x5c, 0xda, 0x30, 0xdc, 0xcd, 0xf6, 0xfa, 0xe5, 0xaa, 0xd5, 0xbc, 0xb2, 0x61,
	0x6d, 0x58, 0x57, 0x28, 0xd4, 0x7a, 0xbb, 0x4e, 0xdf, 0xe8, 0x0b, 0x7d, 0x62, 0xd8, 0x33, 0x67,
	0x37, 0x2c, 0x6b, 0xa3, 0x81, 0x3b, 0x50, 0xae, 0xd1, 0xc4, 0x8e, 0xab, 0x37, 0x5b, 0x1c, 0x60,
	0xaa, 0x7b, 0x64, 0x13, 0xbb, 0xbc, 0xe3, 0x54, 0x77, 0x87, 0xd5, 0x72, 0x0d, 0xcb, 0xe4, 0x4c,
	0xcd, 0x9c, 0xee, 0xee, 0xdc, 0xd2, 0x1b, 0x46, 0x4d, 0x77, 0x31, 0xef, 0x4d, 0xf4, 0xf4, 0x1a,
	0x78, 0x5b, 0xeb, 0xc2, 0x4f, 0x0e, 0xc3, 0xa0, 0xdc, 0x6c, 0xb9, 0xbb, 0xc9, 0xcf, 0x0b, 0x30,
	0x56, 0x5c, 0xff, 0xab, 0xb8, 0xea, 0x2a, 0xb8, 0x5e, 0xde, 0x6d, 0x61, 0x34, 0x05, 0x91, 0x07,
	0x86, 0x59, 0x9b, 0x16, 0x12, 0xc2, 0xc5, 0x91, 0x54, 0xf8, 0xfd, 0x87, 0x82, 0x42, 0x1b, 0xd0,
	0x71, 0x08, 0xb7, 0x8d, 0xda, 0x74, 0xa8, 0xd3, 0x4e, 0xde, 0xd1, 0x29, 0x18, 0x72, 0xb1, 0xa9,
	0x9b, 0xee, 0x74, 0xb8, 0xd3, 0xc3, 0x9b, 0xd0, 0x39, 0x18, 0x31, 0xf5, 0x26, 0x76, 0x5a, 0x7a,
	0x15, 0x4f, 0x47, 0x3a, 0xfd, 0x9d, 0x56, 0x32, 0x1e, 0x79, 0x99, 0x1e, 0x0c, 0x8c, 0x47, 0x1a,
	0x92, 0x65, 0x98, 0xc8, 0xeb, 0xeb, 0xb8, 0xa1, 0xe2, 0x06, 0xae, 0xba, 0x96, 0x4d, 0xb9, 0xfb,
	0x04, 0xc4, 0xf0, 0x4e, 0xcb, 0xc6, 0x8e, 0x43, 0x66, 0x33, 0x2d, 0x24, 0xc2, 0x17, 0x47, 0x52,
	0x67, 0x7e, 0xb8, 0x27, 0x84, 0xfe, 0xf5, 0x9f, 0x3e, 0x0d, 0x0f, 0xbe, 0x23, 0x84, 0x44, 0x81,
	0x3c, 0x81, 0x1d, 0x15, 0x85, 0xe9, 0x47, 0x89, 0x6f, 0x87, 0x04, 0x25, 0x88, 0x91, 0x7c, 0x03,
	0x44, 0x4a, 0x75, 0x55, 0x77, 0xab, 0x9b, 0x98, 0x11, 0xbd, 0x08, 0x91, 0x07, 0x78, 0xd7, 0xa3,
	0x76, 0xcc, 0xa7, 0x24, 0x7a, 0x4f, 0xd3, 0x44, 0x06, 0x78, 0xd7, 0x49, 0x7e, 0x2d, 0x04, 0x63,
	0x69, 0xcb, 0xac, 0x19, 0x44, 0x98, 0x14, 0x77, 0x09, 0x22, 0xc4, 0x5a, 0xb8, 0xb8, 0x12, 0x04,
	0xe3, 0x94, 0x7d, 0x52, 0x81, 0x35, 0xa6, 0x12, 0xc3, 0x32, 0x95, 0x58, 0xb1, 0x85, 0x6d, 0xfa,
	0xa8, 0x37, 0x14, 0x0a, 0x8d, 0xea, 0x30, 0xe4, 0xb8, 0xba, 0xdb, 0x76, 0xb8, 0x38, 0x0b, 0x04,
	0x2f, 0x67, 0xdf, 0x56, 0x86, 0xd5, 0x76, 0xb5, 0x8a, 0x1d, 0x47, 0x19, 0x5a, 0xd1, 0x8d, 0x06,
	0xae, 0x29, 0x90, 0x33, 0xab, 0x56, 0xb3, 0xd5, 0xc0, 0x2e, 0x56, 0x46, 0x72, 0xa6, 0xe3, 0xea,
	0x0d, 0xd2, 0x1c, 0xc9, 0x58, 0xdb, 0xa6, 0x12, 0xcd, 0x18, 0x8e, 0xbe, 0x4e, 0xde, 0xc7, 0x0a,
	0x96, 0x2b, 0xb5, 0x5a, 0x0d, 0xa3, 0x4a, 0xde, 0x15, 0x4e, 0x1d, 0x9d, 0x80, 0x21, 0x1b, 0xeb,
	0x8e, 0x65, 0x32, 0xe5, 0x28, 0xfc, 0x0d, 0x65, 0x40, 0x6c, 0xe8, 0x8e, 0xab, 0xb5, 0x5b, 0xc4,
	0x6c, 0x34, 0x62, 0x94, 0x54, 0x01, 0xb1, 0xc5, 0x99, 0xcb, 0xcc, 0x62, 0x2f, 0x7b, 0x16, 0x7b,
	0xb9, 0xec, 0x59, 0xac, 0x32, 0x4e, 0x70, 0x2a, 0x14, 0x85, 0x34, 0xa2, 0x19, 0x88, 0x6e, 0x5a,
	0x8e, 0x4b, 0xd5, 0x37, 0x44, 0xe9, 0xfb, 0xef, 0xe8, 0x1c, 0x8c, 0x3a, 0xd8, 0xde, 0x32, 0xaa,
	0x58, 0xa3, 0xfd, 0xc3, 0xb4, 0x3f, 0xc6, 0xdb, 0x0a, 0x44, 0xc1, 0x25, 0x00, 0x95, 0xb2, 0x49,
	0x05, 0x79, 0xc2, 0x17, 0x89, 0xc0, 0x58, 0x3d, 0x62, 0x0a, 0x08, 0x22, 0x55, 0xab, 0xc6, 0xac,
	0x6a, 0x50, 0xa1, 0xcf, 0xc9, 0x97, 0x20, 0x9e, 0x33, 0x0d, 0xd7, 0xd0, 0x1b, 0xc6, 0x2f, 0x71,
	0xdd, 0x22, 0x6e, 0x5e, 0x8c, 0x28, 0xb3, 0xac, 0xbf, 0x01, 0x62, 0x00, 0x8c, 0x0d, 0xff, 0x1a,
	0x0c, 0xb7, 0xb0, 0x59, 0x33, 0xcc, 0x0d, 0x6a, 0x06, 0xb1, 0xc5, 0xd9, 0xcb, 0x5d, 0x0b, 0xff,
	0x72, 0x0f, 0x61, 0xc5, 0x03, 0x47, 0x0b, 0x84, 0x41, 0xa7, 0xdd, 0x70, 0xa9, 0x2e, 0x63, 0x8b,
	0x27, 0x7b, 0x10, 0x3b, 0x73, 0x54, 0x38, 0x60, 0xf2, 0xdf, 0x86, 0x60, 0x9c, 0x35, 0xaf, 0x62,
	0x57, 0xa7, 0xe3, 0xf3, 0xd5, 0x25, 0xf4, 0xac, 0xae, 0x8b, 0x30, 0x56, 0xb5, 0xb1, 0xee, 0x5a,
	0xb6, 0x56, 0x6d, 0xe8, 0x8e, 0x13, 0x5c, 0x7e, 0xa3, 0xbc, 0x27, 0x4d, 0x3a, 0x50, 0x12, 0xc0,
	0x83, 0x34, 0x6a, 0xc1, 0xb5, 0x38, 0xc2, 0x9b, 0x73, 0x35, 0x94, 0x80, 0x11, 0x26, 0x55, 0x02,
	0x12, 0x58, 0x8e, 0x51, 0xd6, 0x9a, 0xab, 0xa1, 0x02, 0x20, 0x0a, 0x6e, 0x58, 0xa6, 0xe6, 0xbb,
	0xaa, 0xa3, 0x4d, 0x83, 0x91, 0x99, 0xf0, 0x50, 0xfd, 0x76, 0xb4, 0x0c, 0xc3, 0xad, 0xf6, 0x7a,
	0xc3, 0x70, 0x36, 0xa9, 0x85, 0x8c, 0x2f, 0x26, 0xfa, 0x4a, 0xa7, 0xc4, 0x60, 0xb8, 0x60, 0xd9,
	0x0b, 0x3a, 0x0d, 0xc3, 0x5b, 0xae, 0xdd, 0x22, 0xbc, 0x0e, 0x07, 0x5c, 0x0b, 0x69, 0xcb, 0xd5,
	0x92, 0x7f, 0x2b, 0x02, 0xe3, 0xcc, 0x73, 0xf9, 0x32, 0x9c, 0x0a, 0xea, 0x3a, 0xe0, 0x4a, 0xd0,
	0xe9, 0xa0, 0x1b, 0xa2, 0x12, 0x0c, 0x7a, 0x20, 0x2e, 0xfa, 0x70, 0x8f, 0xe8, 0x0b, 0x30, 0xd4,
	0x20, 0x9e, 0xc2, 0x99, 0x8e, 0x50, 0x83, 0xf8, 0x58, 0x0f, 0xe7, 0xdd, 0x83, 0x5f, 0xa6, 0x5e,
	0xc5, 0x91, 0x4d, 0xd7, 0xde, 0x4d, 0xc5, 0x9e, 0x7f, 0xfb, 0xdf, 0x87, 0x87, 0xde, 0x7e, 0x22,
	0x84, 0xa2, 0x03, 0x0a, 0xa7, 0x82, 0xde, 0x13, 0x20, 0xa6, 0x9b, 0xa6, 0xe5, 0x52, 0x11, 0x39,
	0xd3, 0x83, 0x94, 0xea, 0xe5, 0xc3, 0xa9, 0x4a, 0x1d, 0x04, 0x46, 0xba, 0xf0, 0xfe, 0x9e, 0x40,
	0x3d, 0x5c, 0xec, 0x5d, 0x21, 0x9a, 0x1c, 0xb2, 0x23, 0xa2, 0x30, 0xfd, 0x26, 0x79, 0x1f, 0x7d,
	0x57, 0x18, 0x99, 0x1b, 0xb6, 0x07, 0x89, 0xdb, 0x8b, 0x92, 0xf1, 0xe1, 0xed, 0x27, 0xc2, 0x10,
	0x8a, 0x7c, 0x75, 0x4f, 0x18, 0xe8, 0xb0, 0x23, 0xf8, 0x3d, 0x33, 0xa4, 0x27, 0xac, 0x04, 0x59,
	0x42, 0x09, 0x88, 0xd5, 0xb0, 0x53, 0xb5, 0x0d, 0xba, 0x59, 0xf0, 0x35, 0x1d, 0x6c, 0x42, 0xd3,
	0x30, 0x5c, 0x63, 0x3e, 0x87, 0xea, 0x24, 0xaa, 0x78, 0xaf, 0x33, 0xaf, 0x43, 0x2c, 0x20, 0x02,
	0x24, 0x42, 0xf8, 0x01, 0xde, 0xe5, 0xcb, 0x8e, 0x3c, 0xa2, 0x63, 0x30, 0xb8, 0xa5, 0x37, 0xda,
	0x9e, 0x02, 0xd8, 0xcb, 0x72, 0xe8, 0x35, 0x61, 0xe6, 0x16, 0x88, 0xbd, 0xf3, 0xfc, 0x51, 0xf0,
	0x93, 0x9f, 0x80, 0xd1, 0xbc, 0xe1, 0x74, 0xec, 0xe0, 0x0a, 0x88, 0x36, 0x76, 0xac, 0xb6, 0x5d,
	0xc5, 0xda, 0x16, 0xb6, 0x89, 0xe3, 0xe7, 0x36, 0x11, 0xf9, 0xde, 0x9e, 0x20, 0x28, 0x71, 0xaf,
	0x77, 0x8d, 0x75, 0x12, 0x5b, 0x9a, 0x60, 0x82, 0xbf, 0x8d, 0x3b, 0x64, 0xfa, 0xb8, 0x8e, 0x23,
	0x2c, 0xe9, 0xad, 0x1e, 0x93, 0x99, 0xef, 0xab, 0xdc, 0xc0, 0x18, 0x47, 0x5b, 0xcd, 0x6f, 0xf4,
	0xb5, 0x9a, 0x85, 0x23, 0x09, 0xff, 0xa5, 0xe1, 0x1c, 0x8d, 0xbf, 0x3c, 0xf1, 0xb5, 0x5b, 0x3d,
	0x3e, 0x24, 0xf9, 0xab, 0x11, 0x38, 0xc6, 0x9a, 0xd2, 0xc4, 0x99, 0xe1, 0x1f, 0xc3, 0x1a, 0xca,
	0x3d, 0xd6, 0x70, 0xa5, 0xaf, 0xd2, 0xba, 0x87, 0x39, 0xda, 0x20, 0x7e, 0xab, 0xaf, 0x41, 0x2c,
	0xbd, 0x08, 0xed, 0xbf, 0xb4, 0x89, 0x8f, 0x66, 0x13, 0x9f, 0x8b, 0xc0, 0x71, 0x2f, 0x48, 0x6e,
	0x35, 0xf4, 0xea, 0x8f, 0x63, 0x14, 0x15, 0xdf, 0x28, 0xc2, 0x54, 0x71, 0x57, 0xfb, 0x2a, 0xae,
	0x67, 0x9c, 0xa3, 0xad, 0xe2, 0x8b, 0x3d, 0x56, 0xc1, 0x2c, 0xee, 0xfa, 0x0b, 0x11, 0xff, 0x99,
	0x9a, 0xc5, 0xe0, 0xa1, 0x66, 0x31, 0xf4, 0x17, 0xd9, 0x2c, 0x3e, 0x23, 0x40, 0x7c, 0x15, 0x3b,
	0x8e, 0xbe, 0xd1, 0x31, 0x88, 0x57, 0xba, 0x42, 0x90, 0x49, 0x22, 0xb4, 0x88, 0xcd, 0x73, 0x92,
	0x41, 0x3b, 0xfc, 0x5e, 0xc8, 0x0b, 0x49, 0xe6, 0xbb, 0xc5, 0xc0, 0xc2, 0x3a, 0xe0, 0x60, 0xd3,
	0x8f, 0x42, 0xdd, 0x22, 0x39, 0xd7, 0x11, 0x09, 0x09, 0x53, 0xa2, 0xa9, 0xe1, 0x6f, 0x3e, 0x14,
	0xe8, 0x5e, 0xe6, 0xb5, 0x27, 0x31, 0xc4, 0xd6, 0x0c, 0xbc, 0xed, 0xa5, 0x71, 0x28, 0x98, 0xc6,
	0xf1, 0x0c, 0x4e, 0x0c, 0x64, 0x70, 0x2c, 0xc6, 0x39, 0xbd, 0x2f, 0x3f, 0x0b, 0xda, 0x2a, 0x0a,
	0xa6, 0x66, 0x3c, 0x76, 0x56, 0x21, 0x76, 0xb7, 0xbd, 0x8e, 0x0f, 0x1b, 0xe6, 0xf0, 0x05, 0xe0,
	0x11, 0x0d, 0x07, 0x88, 0xee, 0x0d, 0xc1, 0x31, 0x75, 0xd7, 0x71, 0x71, 0xb3, 0x27, 0xa2, 0x3b,
	0x20, 0x2a, 0xee, 0x1f, 0xa5, 0x86, 0x3f, 0x72, 0x94, 0x9a, 0x03, 0x54, 0xc3, 0x0d, 0xdc, 0x43,
	0x2f, 0x72, 0x64, 0x42, 0x34, 0xe1, 0x61, 0x75, 0x48, 0xad, 0xc1, 0x89, 0xa6, 0x55, 0x33, 0xea,
	0x46, 0xf5, 0x23, 0x06, 0xd1, 0xc7, 0x83, 0xe8, 0x1d, 0xba, 0x69, 0x18, 0x35, 0x02, 0x39, 0x0b,
	0x5d, 0x19, 0xb1, 0xc5, 0xb3, 0x07, 0x27, 0x29, 0x2c, 0xe3, 0xe8, 0x42, 0x42, 0xb3, 0x00, 0x75,
	0xc3, 0xf4, 0x48, 0x0c, 0x93, 0x74, 0x57, 0x09, 0xb4, 0x04, 0x72, 0xf9, 0xe8, 0xfe, 0x5c, 0x7e,
	0x5f, 0x2a, 0x32, 0xf2, 0x62, 0xa9, 0x08, 0xf4, 0x4d, 0x45, 0xe6, 0x60, 0xdc, 0xa7, 0x66, 0x59,
	0x0f, 0x0c, 0x3c, 0x3d, 0xde, 0x81, 0xf3, 0x06, 0x4a, 0xd3, 0x1e, 0x42, 0xcf, 0xb5, 0xf5, 0x2a,
	0xd6, 0x0c, 0xb3, 0x6e, 0x4d, 0xc7, 0x02, 0xf4, 0x68, 0x73, 0xce, 0xac, 0x5b, 0xe8, 0x65, 0x18,
	0xb5, 0xa8, 0xed, 0x68, 0x86, 0x59, 0xc3, 0x3b, 0xd3, 0xa3, 0x09, 0xe1, 0xe2, 0x18, 0x83, 0x8a,
	0xb1, 0x8e, 0x1c, 0x69, 0x47, 0x4a, 0xd0, 0x38, 0xc7, 0xa8, 0x97, 0x3c, 0x7d, 0x80, 0x97, 0xa4,
	0x16, 0x9e, 0x3a, 0xf1, 0xf8, 0x61, 0x07, 0xa3, 0x73, 0xc8, 0x10, 0x34, 0xe9, 0xd7, 0x01, 0xac,
	0x6d, 0x13, 0xdb, 0xda, 0x96, 0x81, 0xb7, 0xa7, 0xe3, 0x5c, 0xcf, 0xdd, 0x44, 0x03, 0x6b, 0x53,
	0x19, 0xa1, 0xd0, 0xa4, 0x05, 0x5d, 0x80, 0x98, 0x63, 0x63, 0xcd, 0x5b, 0xdc, 0x22, 0x5d, 0xdc,
	0x94, 0x6b, 0x70, 0x6c, 0xcc, 0xd3, 0xfb, 0x60, 0x26, 0x34, 0xb1, 0x3f, 0x13, 0xfa, 0x7a, 0x04,
	0xa6, 0x82, 0xab, 0x27, 0x18, 0xc3, 0x8a, 0x81, 0x05, 0xc4, 0xd6, 0x4e, 0xee, 0xa3, 0xad, 0x9d,
	0x9f, 0xf2, 0xb2, 0x79, 0xeb, 0xa3, 0x2f, 0x9b, 0x9f, 0xe9, 0x8a, 0x39, 0xd1, 0xbd, 0x62, 0xfc,
	0xc5, 0x72, 0xbe, 0xef, 0x62, 0xe9, 0x59, 0x27, 0x67, 0xf6, 0xaf, 0x93, 0xe0, 0x12, 0x39, 0xd7,
	0xcf, 0xa4, 0xbb, 0xad, 0xf9, 0xa3, 0x5b, 0xde, 0xf2, 0xd4, 0xd7, 0x6e, 0xf5, 0xf5, 0xb9, 0xc9,
	0x26, 0x20, 0xa9, 0xed, 0x6e, 0xd2, 0xe3, 0xad, 0x94, 0xee, 0x18, 0x55, 0xf2, 0x86, 0x66, 0x20,
	0xda, 0x76, 0xb0, 0x1d, 0x88, 0x76, 0xfc, 0x77, 0xf4, 0x73, 0x10, 0x6d, 0xe9, 0x8e, 0xb3, 0x6d,
	0xd9, 0xb5, 0x83, 0xce, 0x40, 0x70, 0xd5, 0xc6, 0x2e, 0xa5, 0x18, 0x21, 0xc1, 0x85, 0xe2, 0x23,
	0x24, 0xf7, 0xc2, 0x20, 0xfa, 0xe3, 0x65, 0xb1, 0x5e, 0x23, 0x62, 0xfd, 0x42, 0x08, 0x86, 0x37,
	0xd9, 0x33, 0x3f, 0x8e, 0xe9, 0x4d, 0xa5, 0x7a, 0x51, 0x2e, 0xf3, 0x7f, 0x59, 0x04, 0xf3, 0x5f,
	0x04, 0x2f, 0x5c, 0x49, 0xf2, 0x70, 0x85, 0x9d, 0x0f, 0xbe, 0x2b, 0x84, 0x44, 0x91, 0x84, 0x27,
	0xa7, 0xdf, 0x7e, 0x22, 0x4c, 0xa3, 0x13, 0xdf, 0xdf, 0x13, 0x50, 0xb6, 0x5c, 0x2e, 0x25, 0xd8,
	0x60, 0x09, 0xc7, 0xb5, 0x0d, 0x73, 0x83, 0x00, 0x1c, 0x7f, 0xfb, 0x89, 0x30, 0x81, 0xe2, 0xcf,
	0xf7, 0x84, 0x18, 0x05, 0x60, 0xe4, 0x0f, 0x8f, 0x79, 0x52, 0x6f, 0x3f, 0x11, 0x6e, 0xcd, 0xbc,
	0xf1, 0xfd, 0x3d, 0xe1, 0xb5, 0x54, 0xc3, 0x30, 0x6b, 0x75, 0xab, 0x51, 0x4b, 0x58, 0x76, 0xa2,
	0xda, 0xc0, 0xba, 0x9d, 0x70, 0xa8, 0x0c, 0x12, 0x34, 0xa4, 0x48, 0xd4, 0x2d, 0x3b, 0xe1, 0x6e,
	0x1a, 0x4e, 0x62, 0xd3, 0x75, 0x5b, 0xde, 0xe8, 0x0f, 0xf0, 0x2e, 0x21, 0x23, 0xbe, 0xfd, 0x44,
	0x18, 0x9d, 0x81, 0xe7, 0x7b, 0xc2, 0x10, 0x93, 0x5b, 0x20, 0x9e, 0x7a, 0x4a, 0xf7, 0x7c, 0x2e,
	0x9a, 0x99, 0x0a, 0x8c, 0x06, 0xa7, 0xdd, 0x27, 0xa0, 0xb9, 0x12, 0x0c, 0x68, 0x0e, 0xd3, 0x4b,
	0x30, 0xd6, 0xf9, 0xd8, 0xb3, 0x3d, 0xe1, 0x25, 0x38, 0x0f, 0xb3, 0x24, 0xab, 0x4e, 0x58, 0xf5,
	0x04, 0x11, 0x36, 0x36, 0x5d, 0xbe, 0xc4, 0x12, 0x9e, 0x96, 0x84, 0x85, 0xe4, 0x1f, 0x87, 0xe1,
	0x98, 0xaf, 0x8a, 0xb7, 0xda, 0xd8, 0xde, 0x2d, 0xe9, 0xb6, 0xde, 0x74, 0xd0, 0xbf, 0x09, 0xc1,
	0xe8, 0xa7, 0xc9, 0xbb, 0xd6, 0xa2, 0x0d, 0x5c, 0x8d, 0x4b, 0x07, 0xa9, 0x31, 0x80, 0x7b, 0x39,
	0xf0, 0xcc, 0xd4, 0xf9, 0xdd, 0xa3, 0xd4, 0x99, 0x78, 0xfb, 0x89, 0x70, 0x1a, 0xcd, 0x7c, 0x7f,
	0x4f, 0x38, 0x41, 0x91, 0x13, 0x14, 0x1b, 0xbb, 0x5d, 0x2a, 0x3d, 0xf9, 0xf6, 0x13, 0xe1, 0x38,
	0x9a, 0x7c, 0xbe, 0x27, 0xc4, 0x7b, 0x80, 0x7e, 0xf2, 0x6a, 0xa5, 0x53, 0x4f, 0xb4, 0x82, 0x03,
	0x1c, 0xa9, 0xd6, 0xd8, 0xa7, 0x3b, 0xf3, 0x9e, 0xb9, 0x0f, 0x62, 0xaf, 0x18, 0x7e, 0x52, 0xea,
	0x5d, 0x78, 0xb6, 0x27, 0x5c, 0x82, 0x57, 0xe1, 0x65, 0x15, 0xf7, 0xd3, 0x6e, 0x8f, 0x6c, 0xa8,
	0x9a, 0xbf, 0x28, 0xc0, 0x94, 0x3f, 0x77, 0x46, 0x95, 0xec, 0xba, 0xfc, 0xb4, 0x65, 0xb2, 0x86,
	0xab, 0xf6, 0x2e, 0x8d, 0x54, 0xb5, 0x96, 0x6d, 0x6d, 0x19, 0x35, 0x6c, 0x73, 0x2e, 0x51, 0xa7,
	0xab, 0xc4, 0x7b, 0xd0, 0x4b, 0x30, 0xee, 0xb8, 0x96, 0x8d, 0x3b, 0xb0, 0x2c, 0x48, 0x1c, 0xa3,
	0xad, 0x3e, 0xd8, 0x1c, 0x44, 0x1b, 0x16, 0xe3, 0x89, 0x9f, 0xcd, 0x8d, 0xff, 0x70, 0x4f, 0x08,
	0xf3, 0x10, 0xf9, 0xb3, 0xc4, 0x89, 0x78, 0xfd, 0xcb, 0xd1, 0x0f, 0x6e, 0x0d, 0x5e, 0x9b, 0x5f,
	0x98, 0x5f, 0x4c, 0xfe, 0x89, 0x00, 0x93, 0x6b, 0x7a, 0xbb, 0xe1, 0xf6, 0x70, 0x79, 0x09, 0xa2,
	0xdd, 0xac, 0xa5, 0x26, 0xbe, 0xb5, 0x27, 0x8c, 0xd5, 0x70, 0x9d, 0x00, 0x5f, 0xda, 0x22, 0x7f,
	0x15, 0x1f, 0x84, 0xb8, 0x3b, 0x7f, 0x70, 0xc6, 0x9d, 0xff, 0xee, 0xa9, 0x21, 0xdc, 0x51, 0xc3,
	0x34, 0x0c, 0x7b, 0xe7, 0x4c, 0x11, 0xea, 0xa4, 0xbd, 0x57, 0x74, 0x07, 0xe2, 0xcc, 0x40, 0x34,
	0x6c, 0x56, 0x2d, 0x7a, 0xbc, 0x3c, 0x48, 0xcf, 0x41, 0xcf, 0xf5, 0x55, 0x95, 0xcc, 0x81, 0xa8,
	0xca, 0xc6, 0x9d, 0xae, 0xb6, 0xe5, 0xd1, 0x0f, 0x6e, 0x8d, 0x2c, 0xcc, 0x2f, 0xce, 0x5f, 0x9b,
	0x5f, 0x9a, 0xbf, 0x9e, 0xb4, 0x60, 0x32, 0x4d, 0x0c, 0xb0, 0x67, 0x9e, 0x33, 0xbd, 0xf3, 0x0c,
	0x4c, 0x6a, 0x09, 0xc2, 0x6d, 0xbb, 0xc1, 0x73, 0x8d, 0xe4, 0x0f, 0xf7, 0x84, 0xc8, 0x3f, 0x7b,
	0x22, 0x8c, 0xba, 0x78, 0xc7, 0x9d, 0x4f, 0xac, 0xeb, 0x0e, 0xbe, 0xb1, 0x44, 0x84, 0x3b, 0x62,
	0x0f, 0x5f, 0x7c, 0xf4, 0x28, 0x4a, 0x04, 0x4c, 0xc0, 0x97, 0x87, 0x3e, 0xb8, 0x15, 0x5e, 0x9c,
	0x5f, 0x48, 0xbe, 0x0a, 0xc7, 0xef, 0x19, 0xe6, 0x46, 0x53, 0x37, 0x7b, 0x86, 0xec, 0x77, 0xc4,
	0xfe, 0xaf, 0x06, 0x01, 0x3a, 0xd6, 0x87, 0x7e, 0x01, 0x8e, 0xaf, 0x7b, 0xe6, 0xa3, 0x71, 0x81,
	0xd0, 0x60, 0x8e, 0x05, 0x0b, 0x2f, 0xf7, 0x08, 0xe3, 0x00, 0x53, 0xcb, 0x0e, 0x28, 0x93, 0xeb,
	0xfb, 0xbb, 0xd0, 0xcf, 0xc3, 0x04, 0xd5, 0x5f, 0x17, 0x65, 0x16, 0x37, 0x24, 0x7b, 0x37, 0xc3,
	0xfd, 0xa6, 0x91, 0x1a, 0xe1, 0xb9, 0xd4, 0xb4, 0x90, 0x1d, 0x50, 0xe2, 0x5b, 0xdd, 0x10, 0xa8,
	0x04, 0x13, 0x74, 0xa1, 0x77, 0x11, 0x1f, 0xea, 0x4b, 0xbc, 0x8f, 0x3e, 0x08, 0xc5, 0x6a, 0x77,
	0x33, 0xd2, 0x60, 0x72, 0x9b, 0x09, 0xb2, 0x8b, 0xe6, 0x30, 0xa5, 0x79, 0xa1, 0x87, 0x66, 0x5f,
	0x91, 0xfb, 0xe9, 0x5f, 0x76, 0x40, 0x99, 0xd8, 0xee, 0x85, 0x40, 0x2e, 0xcc, 0xf6, 0x95, 0xb6,
	0x66, 0x98, 0x2e, 0xd9, 0xb2, 0x1b, 0x34, 0xd6, 0x78, 0x61, 0xb1, 0x77, 0x92, 0xcd, 0x53, 0x7d,
	0xa4, 0x9f, 0xe3, 0x34, 0xd1, 0x2f, 0xc2, 0xb1, 0x1e, 0x53, 0xd7, 0xe8, 0xcd, 0x58, 0xf4, 0x05,
	0xed, 0x3d, 0xa0, 0x07, 0x05, 0x39, 0xfb, 0xba, 0x97, 0x93, 0xdf, 0xbe, 0x25, 0x3c, 0xdb, 0x13,
	0xe2, 0x30, 0x06, 0xdc, 0x81, 0xa2, 0xf0, 0xeb, 0xf3, 0xaf, 0x7d, 0xfe, 0xbd, 0xb3, 0x03, 0xbf,
	0xfb, 0xde, 0xd9, 0x81, 0x47, 0x7f, 0x98, 0x18, 0x48, 0x5d, 0x84, 0x89, 0xe0, 0x7c, 0x2d, 0x13,
	0x5b, 0x75, 0x34, 0xf9, 0x74, 0x4f, 0x20, 0x51, 0xc7, 0xc8, 0xf3, 0x3d, 0x61, 0x78, 0x69, 0xfe,
	0xfa, 0xfc, 0x8d, 0xf9, 0x9b, 0x77, 0x22, 0x51, 0x41, 0x0c, 0xdd, 0x89, 0x44, 0x43, 0x62, 0xf8,
	0x4e, 0x24, 0x1a, 0x16, 0x23, 0x77, 0x22, 0xd1, 0x11, 0x11, 0x92, 0xeb, 0x30, 0x5e, 0xc0, 0xee,
	0xb6, 0x65, 0x3f, 0xf0, 0x52, 0xdc, 0x12, 0x84, 0x6d, 0x5c, 0xe7, 0xfb, 0xd7, 0xe1, 0xb9, 0x42,
	0xe2, 0xf1, 0xc3, 0xf8, 0x96, 0x61, 0xbb, 0x6d, 0xbd, 0xa1, 0x99, 0x8c, 0xca, 0xa3, 0x27, 0xec,
	0x28, 0x85, 0x67, 0x0d, 0x84, 0x54, 0xf2, 0x37, 0x05, 0x88, 0xa9, 0x86, 0xeb, 0x27, 0xd1, 0xf2,
	0x8b, 0x8f, 0x70, 0xfc, 0xf1, 0xc3, 0x88, 0x63, 0xb8, 0xb8, 0x0f, 0x59, 0x54, 0x84, 0x51, 0x3e,
	0x28, 0x13, 0x7c, 0xa8, 0xaf, 0xe0, 0xd7, 0x18, 0x7f, 0x7c, 0x92, 0x4c, 0xf0, 0x8f, 0x9f, 0x08,
	0x83, 0x10, 0x5e, 0xdf, 0x68, 0x29, 0x31, 0xb3, 0xd3, 0x9e, 0xfc, 0x2b, 0x80, 0x72, 0xad, 0x92,
	0x8d, 0xeb, 0xc6, 0x8e, 0x8a, 0xfd, 0x0b, 0xe2, 0x3b, 0x2f, 0xce, 0xed, 0xcc, 0xe3, 0x87, 0x63,
	0x46, 0x4b, 0x6b, 0x51, 0x12, 0x9a, 0x83, 0xdd, 0x5e, 0x49, 0x3c, 0x16, 0x60, 0x74, 0x2d, 0x28,
	0x8a, 0xdc, 0x8b, 0x13, 0x3f, 0xf9, 0xf8, 0xe1, 0xa8, 0x27, 0x6c, 0x22, 0x92, 0x9f, 0xba, 0x38,
	0xd6, 0x60, 0xbc, 0x64, 0x35, 0x8c, 0x2a, 0xb6, 0x3d, 0x6e, 0x33, 0x2f, 0xce, 0xed, 0xb1, 0xc7,
	0x0f, 0x87, 0x5b, 0x0c, 0xbb, 0x57, 0x08, 0x1b, 0x70, 0xa2, 0x44, 0xb2, 0x9a, 0xaa, 0xd5, 0xe8,
	0xa1, 0xbf, 0xfa, 0xe2, 0xf4, 0xcf, 0x3c, 0x7e, 0x28, 0xb6, 0x38, 0x15, 0xed, 0x80, 0x81, 0xfe,
	0x4e, 0x08, 0x4e, 0xf0, 0x89, 0x72, 0x99, 0x7b, 0x77, 0xeb, 0xa8, 0x00, 0xbd, 0x86, 0x4b, 0xdd,
	0x79, 0x6c, 0xf1, 0x4c, 0xcf, 0xa8, 0xdd, 0x8b, 0x23, 0x45, 0x23, 0x97, 0xec, 0x80, 0x32, 0xbe,
	0xd5, 0x25, 0x47, 0x74, 0x15, 0xa8, 0x99, 0xf2, 0xb8, 0xa4, 0x37, 0x25, 0x09, 0x68, 0x3c, 0x3b,
	0xa0, 0x50, 0x48, 0xf4, 0x26, 0x74, 0x69, 0x93, 0x67, 0xa4, 0xa7, 0x7a, 0xd5, 0xd5, 0x8d, 0x1a,
	0xe3, 0x28, 0xa4, 0x35, 0x75, 0x01, 0xe2, 0x36, 0xae, 0x6b, 0x16, 0x71, 0xd5, 0x7c, 0x5a, 0x13,
	0x4f, 0xf7, 0x84, 0xf0, 0xfb, 0x7b, 0xc2, 0xe0, 0xf3, 0x3d, 0x61, 0xf0, 0xda, 0xfc, 0xe2, 0xfc,
	0xc2, 0x9d, 0x48, 0x34, 0x22, 0x0e, 0xde, 0x89, 0x44, 0x07, 0xc5, 0xa1, 0xe4, 0xef, 0x0b, 0x30,
	0x43, 0x50, 0xd7, 0x3a, 0x54, 0x82, 0x42, 0xf9, 0x59, 0x4c, 0xe2, 0xd4, 0xfe, 0x49, 0x44, 0x9f,
	0xee, 0x09, 0xa1, 0xf7, 0xf7, 0x84, 0x08, 0xe3, 0x9d, 0xb8, 0x8f, 0xd3, 0x2c, 0x04, 0x5f, 0xd5,
	0x4d, 0xa3, 0xd5, 0x6e, 0xd0, 0xb0, 0xa4, 0xd8, 0xf2, 0x6b, 0x12, 0x92, 0x5d, 0x87, 0x90, 0x24,
	0x6a, 0x1a, 0x08, 0x1c, 0x2c, 0xb2, 0xf3, 0xc7, 0x0b, 0x5d, 0x27, 0x9d, 0xdd, 0x40, 0xef, 0x7d,
	0x82, 0x87, 0x8b, 0xe8, 0x34, 0x0c, 0xe9, 0xad, 0x16, 0x36, 0x6b, 0xfc, 0xd8, 0x31, 0x42, 0xc0,
	0x14, 0xde, 0xb6, 0x7c, 0xe6, 0xd9, 0x9e, 0x70, 0x12, 0xa6, 0x60, 0x9c, 0x27, 0x04, 0x09, 0xd7,
	0x4a, 0x48, 0xb5, 0x1a, 0x1a, 0xa4, 0x51, 0x4a, 0xf2, 0x8b, 0x21, 0x98, 0x2a, 0x37, 0x9c, 0x4e,
	0x25, 0x04, 0x8b, 0x65, 0x29, 0x8b, 0x05, 0x18, 0x77, 0xed, 0xb6, 0xe3, 0xe2, 0x9a, 0x56, 0xd5,
	0x35, 0x12, 0x95, 0x30, 0x66, 0x2f, 0xf2, 0xa8, 0x24, 0xd6, 0xc2, 0xcd, 0x60, 0x50, 0x32, 0x64,
	0x47, 0x48, 0x50, 0x12, 0x08, 0xfe, 0x46, 0x39, 0x7e, 0x5a, 0xaf, 0xd8, 0x0d, 0xf4, 0x06, 0xcc,
	0x38, 0x0f, 0x8c, 0x96, 0xe6, 0xd5, 0x1f, 0x68, 0x5b, 0xd8, 0xf6, 0xcf, 0x04, 0xe8, 0x1c, 0xa3,
	0xca, 0x34, 0x81, 0xc8, 0x72, 0x80, 0xb5, 0x40, 0x3f, 0xba, 0x09, 0xd3, 0x14, 0x7e, 0x57, 0x73,
	0xda, 0x2c, 0xe3, 0xd6, 0x1b, 0x2e, 0xad, 0x5b, 0x60, 0xc7, 0xf4, 0x23, 0xca, 0x71, 0xd6, 0xaf,
	0xb2, 0x6e, 0xa9, 0xe1, 0x16, 0x48, 0x27, 0x92, 0xe1, 0x54, 0xdb, 0xc1, 0xda, 0x96, 0xd5, 0x70,
	0xb1, 0x6d, 0xeb, 0x5a, 0xcf, 0x9c, 0x22, 0xdd, 0x67, 0xb5, 0x53, 0x6d, 0x07, 0xaf, 0x71, 0xd0,
	0x72, 0x80, 0xfb, 0xe4, 0x2f, 0x87, 0x00, 0x95, 0x1b, 0x4e, 0x1a, 0xdb, 0x2e, 0x63, 0x0a, 0x53,
	0x21, 0xa9, 0x10, 0xaf, 0x76, 0x9a, 0x02, 0x52, 0x9a, 0x3b, 0x40, 0x4a, 0x51, 0x9b, 0x04, 0x26,
	0xdd, 0x72, 0x1a, 0x0f, 0x90, 0x20, 0x92, 0x7a, 0x13, 0x62, 0x2d, 0xdb, 0xd8, 0x22, 0x04, 0x49,
	0x14, 0x1b, 0x79, 0xb1, 0x7c, 0x1d, 0x38, 0xce, 0x5d, 0xbc, 0x7b, 0xf4, 0x09, 0xfe, 0xf2, 0xcb,
	0x1f, 0xdc, 0x1a, 0x5c, 0x20, 0x51, 0xea, 0xb3, 0x3d, 0x61, 0x06, 0xa6, 0x21, 0x5e, 0xce, 0xab,
	0x89, 0xc0, 0xec, 0x10, 0xeb, 0xf5, 0x37, 0xde, 0x90, 0x18, 0x4e, 0x3e, 0x8b, 0xc2, 0x58, 0xb9,
	0xe1, 0x04, 0x6c, 0xa4, 0x0c, 0xd3, 0x4d, 0xc3, 0x34, 0x9a, 0xed, 0xa6, 0xe6, 0x7b, 0xb6, 0xe0,
	0x75, 0xee, 0xf8, 0xbe, 0x25, 0x49, 0xf0, 0x39, 0xa4, 0x72, 0x82, 0xe3, 0x7a, 0x0d, 0xfc, 0xae,
	0x97, 0x52, 0xd5, 0x77, 0xfa, 0x53, 0x0d, 0xbd, 0x00, 0x55, 0x86, 0xdb, 0x4b, 0xf5, 0xd7, 0x07,
	0x61, 0xac, 0x6a, 0xb4, 0x36, 0xb1, 0xad, 0x39, 0x6d, 0xc3, 0xf5, 0xec, 0x26, 0xf5, 0x67, 0x11,
	0xa2, 0x8a, 0x3f, 0x89, 0xbc, 0x23, 0x3c, 0x8f, 0x24, 0xff, 0x28, 0x62, 0xff, 0x61, 0x44, 0x39,
	0x51, 0xce, 0xab, 0x9a, 0x24, 0xab, 0xda, 0xc2, 0xe2, 0x6b, 0xda, 0xed, 0xf4, 0xaa, 0xa6, 0x66,
	0xa5, 0xc5, 0xeb, 0x37, 0x3a, 0xed, 0x8b, 0xd7, 0x6f, 0x78, 0xed, 0xd7, 0x5e, 0x5b, 0x52, 0x4e,
	0x93, 0xf6, 0x74, 0x56, 0x4a, 0x67, 0xa5, 0xc5, 0xab, 0x5a, 0xa9, 0x98, 0xbf, 0xbf, 0x70, 0xed,
	0xea, 0x75, 0x0f, 0xeb, 0x15, 0xd2, 0x2b, 0xa7, 0x33, 0x59, 0x99, 0xfc, 0x55, 0x25, 0xed, 0x5e,
	0xae, 0x9c, 0xed, 0x47, 0xfe, 0x60, 0xc0, 0x9e, 0xf1, 0x2e, 0xf5, 0x05, 0x3c, 0x90, 0x81, 0x97,
	0x3a, 0xe0, 0xca, 0x21, 0xc3, 0x1f, 0x04, 0xd6, 0x33, 0xf8, 0xab, 0x7d, 0xc0, 0x0e, 0x1c, 0xfa,
	0xc2, 0xa1, 0x73, 0x4f, 0xa7, 0xd2, 0x04, 0xf0, 0x10, 0x28, 0x32, 0xb6, 0x07, 0x95, 0x3c, 0x64,
	0x1a, 0x47, 0xc1, 0x04, 0xe9, 0x50, 0x6d, 0x1d, 0x48, 0xe1, 0x6c, 0xdf, 0xde, 0x80, 0x98, 0xf6,
	0xa3, 0x07, 0x89, 0x9f, 0xed, 0xdb, 0xdb, 0x11, 0x5f, 0xa0, 0x5e, 0x6d, 0x94, 0x59, 0xa3, 0x4a,
	0x8d, 0x11, 0xe5, 0x41, 0x74, 0x1b, 0x8e, 0x16, 0x70, 0x05, 0xde, 0x15, 0xe1, 0xb9, 0xfd, 0xc6,
	0xde, 0xe3, 0x86, 0x94, 0xb8, 0xdb, 0xd5, 0xe6, 0xa0, 0x2b, 0xfb, 0x9c, 0x37, 0x2b, 0xde, 0x0b,
	0x04, 0xf0, 0xdd, 0xde, 0x59, 0x25, 0x09, 0x9a, 0xb7, 0x0b, 0x78, 0x07, 0x42, 0xc3, 0x7d, 0x73,
	0x90, 0x03, 0x36, 0x0c, 0x45, 0xdc, 0xea, 0x69, 0xa5, 0xe9, 0x30, 0x89, 0xe6, 0xe9, 0x66, 0x73,
	0x27, 0x12, 0x1d, 0x12, 0x87, 0x93, 0x7f, 0x14, 0x82, 0xe3, 0x95, 0x96, 0xe3, 0xda, 0x58, 0x6f,
	0x76, 0x3b, 0x13, 0x09, 0xc6, 0xaa, 0x56, 0xb3, 0xd9, 0x19, 0x9e, 0x85, 0x37, 0xa7, 0xfb, 0xac,
	0xf5, 0xce, 0xa0, 0xa3, 0x0c, 0x85, 0x1f, 0x69, 0xbd, 0x0a, 0x61, 0xc7, 0x34, 0xf8, 0x86, 0x39,
	0xe5, 0x6d, 0x98, 0x11, 0x3b, 0xb4, 0x29, 0x74, 0xb6, 0xd7, 0xec, 0x80, 0x42, 0xa0, 0xd0, 0x1d,
	0x38, 0x41, 0x76, 0x06, 0xb2, 0x1f, 0x69, 0xec, 0xb8, 0x4e, 0xd3, 0x1d, 0x8d, 0xe0, 0xb3, 0x98,
	0xe0, 0x58, 0xcf, 0xc0, 0xb4, 0x1c, 0x33, 0x3b, 0xa0, 0xa0, 0xb6, 0x83, 0xc9, 0x1e, 0xc5, 0xb6,
	0x54, 0xc9, 0x51, 0x4d, 0x03, 0xdd, 0x84, 0x18, 0xbf, 0x20, 0xa0, 0x04, 0x22, 0x87, 0x12, 0x00,
	0x0e, 0xaa, 0x9a, 0xc6, 0xf2, 0xdc, 0x07, 0xb7, 0xc2, 0xd7, 0xe7, 0x17, 0x9e, 0xed, 0x09, 0x09,
	0x98, 0x85, 0x29, 0x4f, 0x32, 0x09, 0xe2, 0x8e, 0x03, 0x07, 0x3c, 0x04, 0x26, 0x75, 0x16, 0xc0,
	0x31, 0x0d, 0xad, 0xba, 0x69, 0x19, 0x55, 0x4c, 0x03, 0xa7, 0x90, 0x17, 0x38, 0xd1, 0x23, 0x07,
	0x1e, 0x32, 0xbd, 0x2b, 0xc0, 0x54, 0xc6, 0xda, 0x36, 0x7f, 0x4a, 0x32, 0x7e, 0x03, 0x66, 0x6c,
	0xfc, 0xe9, 0xb6, 0x61, 0x63, 0xad, 0xda, 0x30, 0xb0, 0xe9, 0x06, 0x6d, 0x96, 0xed, 0xa7, 0xca,
	0x34, 0x87, 0x48, 0x53, 0x80, 0x80, 0x65, 0x26, 0x3f, 0x10, 0x00, 0x32, 0x56, 0x53, 0x37, 0x58,
	0x1c, 0x74, 0x1d, 0x62, 0x78, 0x47, 0xaf, 0xba, 0x1a, 0x8b, 0x74, 0xd8, 0xde, 0x89, 0x3c, 0xc5,
	0x8d, 0xd8, 0xc3, 0xf4, 0x24, 0x71, 0x93, 0xc4, 0xaf, 0x40, 0x01, 0xd7, 0x68, 0xd0, 0x73, 0x13,
	0x46, 0x9d, 0x76, 0x9d, 0x64, 0x2c, 0xc1, 0x08, 0xa9, 0x3f, 0x5e, 0x8c, 0x41, 0x32, 0xc4, 0x1b,
	0x10, 0xb3, 0xf1, 0x06, 0xf6, 0xf0, 0xd8, 0xa1, 0xd5, 0xa4, 0x87, 0xc7, 0x4b, 0x52, 0x43, 0x4f,
	0x69, 0xc0, 0x0c, 0x14, 0x92, 0xe2, 0x2d, 0xa3, 0x67, 0x7b, 0xc2, 0x38, 0x8c, 0xc2, 0x30, 0xe3,
	0xdd, 0x41, 0xc2, 0x52, 0x2a, 0x09, 0x63, 0x35, 0xfa, 0x16, 0xd4, 0x88, 0x40, 0xa2, 0x40, 0xa2,
	0x11, 0xcf, 0xe6, 0x49, 0x38, 0xf8, 0x2b, 0x02, 0x40, 0x7e, 0x29, 0x83, 0x1d, 0x97, 0x67, 0x50,
	0x51, 0x96, 0x6f, 0x61, 0xaf, 0xa0, 0xf5, 0x12, 0x1d, 0xfd, 0x1d, 0x61, 0x38, 0x39, 0x68, 0x87,
	0x7f, 0x18, 0xc8, 0x1b, 0x13, 0xde, 0x53, 0x54, 0x08, 0x78, 0x0e, 0x1f, 0x1d, 0xbd, 0x0a, 0xb1,
	0x96, 0x65, 0xbb, 0x9a, 0xad, 0x9b, 0x1b, 0xd8, 0xe9, 0xb9, 0xa3, 0xfe, 0x6a, 0x88, 0x44, 0x05,
	0x96, 0xed, 0x2a, 0xb4, 0x37, 0xf9, 0x6b, 0x21, 0x98, 0x2c, 0x37, 0x1c, 0x7a, 0x1c, 0x50, 0xc5,
	0x34, 0x0e, 0x50, 0xda, 0x0d, 0x8c, 0xde, 0x80, 0x51, 0x3e, 0x91, 0xa6, 0xee, 0x56, 0x37, 0xb9,
	0x4d, 0xf4, 0x06, 0x1c, 0x1d, 0xad, 0x29, 0x31, 0x06, 0x4e, 0x0b, 0x74, 0x51, 0x0e, 0x8e, 0x79,
	0xa6, 0x6f, 0x04, 0x28, 0x1f, 0xb1, 0x88, 0x26, 0x39, 0x4e, 0x90, 0x19, 0x74, 0x1b, 0x26, 0xb1,
	0xb9, 0x9f, 0xd2, 0xe1, 0xab, 0x09, 0x31, 0x94, 0x20, 0xa1, 0xd4, 0x45, 0x38, 0xce, 0x09, 0x79,
	0xac, 0x71, 0x15, 0xc5, 0x79, 0xb6, 0x11, 0x7a, 0xbe, 0x27, 0x84, 0xd9, 0x92, 0x21, 0x91, 0xcd,
	0xdb, 0x02, 0x1c, 0xef, 0x91, 0x0c, 0xcd, 0xf3, 0x76, 0xd1, 0xa7, 0x01, 0x05, 0x79, 0xd1, 0xec,
	0x76, 0x03, 0x7b, 0x27, 0xe5, 0xc9, 0xfd, 0xab, 0xa6, 0x57, 0xb6, 0xa9, 0xd9, 0x23, 0x54, 0x39,
	0x61, 0xf4, 0x60, 0x38, 0xc9, 0x6f, 0x0c, 0xee, 0x53, 0x13, 0x35, 0x9b, 0xbb, 0x70, 0x82, 0x4f,
	0xaa, 0x6e, 0xd9, 0x9a, 0xde, 0x68, 0x68, 0x4c, 0x0d, 0xec, 0xe6, 0xea, 0x10, 0x51, 0x33, 0xac,
	0x15, 0xcb, 0x96, 0x1a, 0x0d, 0xcf, 0x7e, 0x6f, 0xc1, 0x10, 0x4d, 0x41, 0x77, 0xb9, 0xb6, 0x2f,
	0x1c, 0x3e, 0x17, 0x26, 0x8d, 0xec, 0x80, 0xc2, 0xb1, 0x90, 0x02, 0xa8, 0xda, 0x76, 0x5c, 0xab,
	0xd9, 0xb5, 0xfa, 0x99, 0xce, 0x8f, 0xde, 0xb0, 0xb2, 0x82, 0x32, 0xc1, 0xd0, 0x83, 0x21, 0x67,
	0x0e, 0x8e, 0xf9, 0x61, 0x7a, 0xaf, 0x4f, 0x39, 0x68, 0x7a, 0x82, 0x32, 0xe9, 0xe1, 0x04, 0x49,
	0x95, 0xf6, 0xed, 0x7f, 0x43, 0x3f, 0x5a, 0xf2, 0x92, 0x0d, 0xf5, 0x6c, 0x90, 0x2b, 0x30, 0xd9,
	0x27, 0x87, 0xe0, 0x5b, 0x64, 0x7f, 0xde, 0x42, 0xca, 0xc4, 0x56, 0x6f, 0x2e, 0xb1, 0x5c, 0x7d,
	0xb6, 0x27, 0x68, 0xf0, 0x31, 0xb8, 0xd0, 0x71, 0xd1, 0xc1, 0xb8, 0x3b, 0x91, 0xb6, 0xcc, 0xba,
	0xb1, 0xd1, 0x66, 0xd5, 0xe8, 0x48, 0x58, 0x84, 0x69, 0x98, 0xec, 0xec, 0x0a, 0x8c, 0x4c, 0x22,
	0x2d, 0x21, 0xe1, 0x3a, 0xe9, 0x09, 0xea, 0x28, 0xc1, 0x4d, 0x56, 0x78, 0x2d, 0x75, 0x09, 0x66,
	0xba, 0xac, 0x96, 0x29, 0x2d, 0xb8, 0x08, 0x46, 0xde, 0xdf, 0x13, 0xa2, 0x64, 0x11, 0xbc, 0x3e,
	0xbf, 0x90, 0x7a, 0x19, 0x26, 0x1d, 0x63, 0xc3, 0x34, 0xcc, 0x0d, 0x2a, 0xf7, 0x83, 0x16, 0x4b,
	0xea, 0x02, 0x4c, 0x04, 0xa4, 0x1a, 0x80, 0x1a, 0xe6, 0xfb, 0x50, 0xf8, 0xe6, 0xfc, 0x8d, 0x3b,
	0x91, 0x68, 0x54, 0x1c, 0xf1, 0xcf, 0xed, 0xc8, 0x8e, 0xf4, 0xb7, 0x05, 0x98, 0x58, 0xb1, 0xf5,
	0x2a, 0x2b, 0xb0, 0x2f, 0x11, 0xbe, 0x4c, 0x17, 0xbd, 0x02, 0x23, 0x66, 0xbb, 0x89, 0x6d, 0xdd,
	0xb5, 0xd8, 0x41, 0xf8, 0x58, 0x6a, 0xe4, 0x5b, 0x7b, 0x82, 0x70, 0x9d, 0x66, 0xb0, 0x9d, 0x3e,
	0xb4, 0x42, 0xb2, 0x19, 0xd3, 0x6a, 0x1a, 0x26, 0x05, 0x65, 0x29, 0x40, 0x6f, 0xf1, 0x77, 0xa6,
	0x03, 0xc1, 0x92, 0x22, 0x4a, 0x25, 0x88, 0x48, 0x8f, 0xc9, 0x17, 0xe6, 0x17, 0x93, 0x7f, 0x20,
	0x80, 0x98, 0x6a, 0xd7, 0xeb, 0xd8, 0x66, 0xc2, 0xa6, 0xab, 0x2b, 0x01, 0x51, 0xee, 0x2b, 0xd8,
	0x5d, 0xbc, 0x97, 0x49, 0xfb, 0xad, 0xe8, 0x0d, 0x98, 0x68, 0xea, 0x3b, 0x1a, 0xd9, 0xda, 0xb0,
	0xe3, 0x6a, 0xeb, 0xbb, 0x2e, 0xf7, 0xb8, 0x63, 0x29, 0xd1, 0xdb, 0x41, 0x86, 0xe7, 0x06, 0xa7,
	0x1f, 0x3d, 0x7a, 0x34, 0xa8, 0xc4, 0x9b, 0xfa, 0x8e, 0xc2, 0x20, 0x53, 0x04, 0x10, 0x49, 0x20,
	0x06, 0xb1, 0x69, 0x3d, 0x7f, 0x98, 0x22, 0x4f, 0xf1, 0x98, 0xcc, 0xcf, 0xef, 0xe7, 0xc2, 0xd3,
	0xdf, 0x8c, 0x4c, 0x0b, 0xca, 0x78, 0x87, 0x46, 0xd9, 0x68, 0x62, 0x7a, 0x85, 0x42, 0x36, 0xfa,
	0x85, 0xe4, 0x17, 0x22, 0x00, 0x69, 0xcb, 0x76, 0xb8, 0xc6, 0x67, 0x7a, 0x79, 0x0f, 0x70, 0x9d,
	0x83, 0x51, 0xbd, 0xd1, 0xb0, 0xb6, 0x35, 0xcb, 0x36, 0x36, 0x0c, 0x92, 0x40, 0x91, 0x0d, 0xe7,
	0x65, 0x7a, 0x5b, 0xf7, 0x4e, 0xcf, 0x6d, 0xdd, 0xd0, 0x3b, 0x42, 0x58, 0x7c, 0x14, 0x74, 0x4f,
	0x31, 0x8a, 0x5b, 0xa4, 0xa8, 0xc8, 0x04, 0x14, 0x24, 0xa5, 0xd1, 0xfd, 0x91, 0x67, 0x51, 0x6f,
	0x06, 0x77, 0xb0, 0x8b, 0x8c, 0xdc, 0xc8, 0x3b, 0xc2, 0x50, 0x32, 0x62, 0x87, 0x12, 0x42, 0xb0,
	0xf3, 0x69, 0x60, 0x7b, 0x0b, 0x7e, 0xbe, 0x21, 0x06, 0x86, 0x52, 0x08, 0x65, 0x74, 0x1e, 0xc6,
	0xd8, 0x78, 0x4d, 0xec, 0x6e, 0x5a, 0x35, 0x87, 0x97, 0x3f, 0xb1, 0xf9, 0xac, 0xb2, 0xb6, 0x0e,
	0x90, 0x77, 0x19, 0x3d, 0x18, 0x00, 0xf2, 0xae, 0x41, 0x5f, 0x82, 0x71, 0xbc, 0xd3, 0xb2, 0x48,
	0xb4, 0xc7, 0xa1, 0x58, 0xad, 0xe3, 0x18, 0x6b, 0xf5, 0xc0, 0x92, 0x30, 0x4c, 0x74, 0xa4, 0x6f,
	0xf0, 0x8f, 0x21, 0x82, 0xe1, 0xf2, 0x50, 0x53, 0xdf, 0x91, 0x36, 0x48, 0xe8, 0x11, 0xf3, 0x92,
	0x53, 0x02, 0x47, 0x5c, 0xef, 0x60, 0xea, 0x04, 0x99, 0xc7, 0xc4, 0x4c, 0x7c, 0xfa, 0xd1, 0x6f,
	0x0c, 0x5e, 0xfc, 0xd0, 0xfb, 0x4f, 0x50, 0x80, 0x83, 0x12, 0xc4, 0x57, 0x61, 0x82, 0x31, 0x5a,
	0xb5, 0x71, 0x0d, 0x9b, 0xae, 0xa1, 0x37, 0x1c, 0x7a, 0xf2, 0x1e, 0xe5, 0x53, 0x4f, 0x77, 0xda,
	0x97, 0x33, 0x1f, 0xdc, 0x8a, 0xf3, 0x6b, 0xa4, 0xf9, 0x1b, 0xf3, 0xaf, 0xcf, 0xbf, 0x46, 0x43,
	0xc4, 0xcb, 0x30, 0x0f, 0x27, 0xd3, 0x45, 0x45, 0xe5, 0x4b, 0xbd, 0xc7, 0x59, 0xf4, 0x62, 0x24,
	0xbf, 0x22, 0x40, 0xbc, 0xa4, 0xbb, 0x9b, 0xc1, 0x2f, 0x69, 0x5e, 0x81, 0x21, 0x16, 0x3d, 0xf0,
	0x60, 0x6b, 0x8c, 0x9f, 0x4a, 0x4c, 0x3f, 0x0a, 0x7d, 0x2f, 0x24, 0x50, 0x0f, 0x4f, 0xbb, 0xd1,
	0x79, 0x88, 0xb4, 0x74, 0x77, 0x93, 0xc7, 0x14, 0xfb, 0xc0, 0x68, 0x27, 0xba, 0x0e, 0x83, 0x9e,
	0x15, 0x10, 0xa8, 0x33, 0xdc, 0x81, 0x72, 0x03, 0xf0, 0x75, 0xcf, 0xd4, 0x9e, 0x1d, 0x50, 0x18,
	0xf4, 0x72, 0xe4, 0x83, 0x5b, 0xc2, 0x12, 0x89, 0x67, 0x09, 0x11, 0x16, 0x75, 0x1c, 0x1c, 0x3d,
	0x7d, 0x28, 0xc0, 0x84, 0x77, 0x98, 0xd6, 0x99, 0x47, 0xbf, 0xba, 0xce, 0x13, 0x30, 0x48, 0x83,
	0x44, 0xc6, 0x33, 0x19, 0x8e, 0xbe, 0x7e, 0x44, 0x2e, 0xd1, 0x69, 0x1a, 0xa7, 0x39, 0xd8, 0xe4,
	0x95, 0x77, 0xd1, 0xec, 0x80, 0xe2, 0xb7, 0xa0, 0x73, 0x30, 0x6a, 0x98, 0x5b, 0xc4, 0x5d, 0xb2,
	0xa8, 0x69, 0x90, 0xaa, 0x32, 0xc6, 0xda, 0x28, 0xa7, 0xcb, 0xb3, 0xde, 0xe1, 0x0a, 0x63, 0x3f,
	0xe1, 0x5a, 0x09, 0x16, 0x33, 0x0d, 0x2e, 0xcc, 0xdf, 0x98, 0xbf, 0x9e, 0x4a, 0x40, 0x8c, 0xc6,
	0xa1, 0x01, 0x09, 0x90, 0x88, 0x7e, 0x28, 0x18, 0xd1, 0x93, 0x9c, 0xe9, 0xdf, 0x09, 0x70, 0xb2,
	0x73, 0xd5, 0x4c, 0x32, 0x82, 0xa0, 0x24, 0xf6, 0xdf, 0x39, 0xff, 0x64, 0xe5, 0xb0, 0x9c, 0x78,
	0xb6, 0x27, 0x9c, 0x86, 0x19, 0x98, 0x54, 0x0d, 0x17, 0x27, 0xc8, 0x98, 0x09, 0x76, 0x00, 0x4b,
	0x8c, 0x2e, 0xbc, 0x30, 0xbf, 0x94, 0x9a, 0xed, 0x9e, 0x48, 0xdc, 0x3b, 0x0e, 0x25, 0x5b, 0x42,
	0x47, 0x91, 0x5f, 0x09, 0x01, 0x28, 0x56, 0xdb, 0xc5, 0x4c, 0x08, 0xaf, 0x71, 0x03, 0x63, 0x01,
	0x48, 0xaf, 0x3f, 0xef, 0xb1, 0xdb, 0x54, 0xe4, 0x07, 0x7b, 0x82, 0xc0, 0xad, 0xee, 0xcd, 0x4e,
	0xe9, 0x49, 0x88, 0x46, 0x62, 0xbd, 0x9f, 0xac, 0xec, 0x33, 0x17, 0x7e, 0x46, 0xe6, 0xa1, 0xa1,
	0xb7, 0x7a, 0x4a, 0x1f, 0x58, 0xa5, 0xef, 0xc5, 0x1e, 0x32, 0x07, 0xca, 0x9c, 0x93, 0x0b, 0x96,
	0x03, 0xa0, 0x65, 0x88, 0x6d, 0xba, 0x6e, 0x8b, 0x3b, 0x2b, 0x6a, 0x30, 0xe3, 0xfb, 0x82, 0xe8,
	0xac, 0xeb, 0xb6, 0x98, 0xe7, 0x52, 0x60, 0xd3, 0x7f, 0x26, 0x59, 0xe0, 0xf0, 0xd2, 0xfc, 0xc2,
	0xfc, 0xb5, 0xf9, 0x45, 0x2e, 0xeb, 0x38, 0x1d, 0x2d, 0xe1, 0x7f, 0xc9, 0x86, 0xbc, 0xfe, 0x64,
	0x01, 0xe0, 0x9e, 0x5e, 0xf7, 0xee, 0x1f, 0xde, 0x84, 0xf0, 0xb6, 0xfe, 0x62, 0xf7, 0x0f, 0xe2,
	0xe3, 0x87, 0x04, 0x36, 0x78, 0xe5, 0xb0, 0xad, 0xd7, 0x93, 0x35, 0x88, 0x13, 0x7a, 0x24, 0xf4,
	0xf4, 0x88, 0xbe, 0x05, 0x23, 0xdb, 0x7a, 0xbd, 0x2b, 0xd6, 0x3d, 0xba, 0x02, 0xcf, 0xc7, 0x08,
	0x0c, 0x10, 0xdd, 0xe6, 0x94, 0x93, 0x2d, 0x40, 0x52, 0xab, 0xb5, 0x62, 0xd8, 0x78, 0x5b, 0x6f,
	0x34, 0xbc, 0x81, 0x3e, 0x05, 0xa3, 0x7a, 0xab, 0xa5, 0xd5, 0x79, 0xf3, 0x0b, 0x5f, 0x2a, 0x05,
	0x91, 0x02, 0xc3, 0xc5, 0xf4, 0xce, 0x10, 0xc9, 0x3f, 0x16, 0x60, 0xf8, 0x9e, 0x5e, 0xe7, 0xa5,
	0x05, 0x5c, 0x4a, 0xfd, 0x12, 0x9b, 0x8e, 0x34, 0xb3, 0x03, 0x54, 0x24, 0xe8, 0xe3, 0xc1, 0xf9,
	0x87, 0xfa, 0x9a, 0x67, 0x8f, 0xc8, 0x88, 0x67, 0xf0, 0xe6, 0x8a, 0x8a, 0x3d, 0xb3, 0x8a, 0xf4,
	0x8d, 0x8a, 0xf7, 0x8b, 0x23, 0x78, 0x67, 0x1c, 0x9c, 0x4a, 0xea, 0x18, 0x44, 0x6d, 0x5c, 0xa7,
	0x77, 0x64, 0xf4, 0xaa, 0x81, 0xb8, 0x49, 0x7e, 0x27, 0x9a, 0x6c, 0xc0, 0xa4, 0xd4, 0x6a, 0x29,
	0x56, 0x03, 0x4b, 0x6d, 0x77, 0xd3, 0xbf, 0xf1, 0x9f, 0x82, 0x61, 0xdb, 0x22, 0x89, 0x94, 0x57,
	0x59, 0x38, 0x44, 0x5e, 0x73, 0x24, 0x8a, 0x19, 0xf1, 0xee, 0x5f, 0x5f, 0xbc, 0x14, 0x8c, 0x61,
	0xe4, 0x6a, 0xc9, 0x7f, 0x29, 0xc0, 0x04, 0xbd, 0xa0, 0xef, 0x1a, 0x2c, 0x0b, 0x63, 0x64, 0xc2,
	0x74, 0x40, 0xbd, 0xed, 0x2f, 0xe9, 0xe4, 0xfe, 0x19, 0xf7, 0xf2, 0xc9, 0x67, 0xea, 0x35, 0xa3,
	0x9b, 0x30, 0xe8, 0x5a, 0x0f, 0xb0, 0xf9, 0x82, 0x9c, 0x11, 0x1f, 0x45, 0xe1, 0x53, 0x53, 0x10,
	0x23, 0x23, 0xf3, 0xf5, 0xbc, 0x4f, 0x4a, 0xef, 0x86, 0x40, 0x54, 0xb0, 0xd3, 0xcd, 0x76, 0x0a,
	0x60, 0x5d, 0x77, 0x8c, 0x6a, 0x90, 0xe7, 0x73, 0x07, 0x55, 0x3f, 0xf9, 0x75, 0x76, 0xd9, 0x01,
	0x65, 0x64, 0xdd, 0x2f, 0xba, 0xbb, 0x03, 0xa3, 0xdc, 0xa7, 0x30, 0x2a, 0xa1, 0xbe, 0x25, 0x8c,
	0xbd, 0xa5, 0x70, 0x3e, 0xf7, 0x31, 0x8e, 0x4c, 0x69, 0xdd, 0x83, 0x89, 0xa0, 0x53, 0x62, 0x04,
	0x59, 0x4a, 0x75, 0xfe, 0x05, 0x8a, 0xb2, 0x7c, 0xa2, 0xf1, 0x80, 0x5b, 0x22, 0x80, 0x07, 0x09,
	0xc7, 0xbb, 0xad, 0xfa, 0x95, 0x30, 0xa0, 0xac, 0xe5, 0xb8, 0x12, 0xfd, 0xae, 0xd5, 0x17, 0xcf,
	0x12, 0x0c, 0xd1, 0xd1, 0x30, 0x3f, 0xca, 0xef, 0x5d, 0x96, 0x15, 0x25, 0xaf, 0xd2, 0x7e, 0xf6,
	0xe1, 0x24, 0x83, 0x45, 0xaf, 0x43, 0xdc, 0xc1, 0xf6, 0x16, 0xb6, 0x35, 0x6c, 0xd6, 0x5a, 0x96,
	0x61, 0xf2, 0x5d, 0x28, 0x10, 0x23, 0xf3, 0x88, 0x53, 0x19, 0x67, 0x80, 0x32, 0x87, 0x43, 0x39,
	0x00, 0x7a, 0x04, 0x4a, 0x83, 0x1a, 0xbe, 0x6a, 0x7a, 0xf3, 0xd2, 0xbe, 0x47, 0x87, 0xdc, 0x4c,
	0x47, 0xdc, 0x86, 0xc3, 0x22, 0x22, 0x74, 0x1b, 0xc6, 0x6d, 0x12, 0x66, 0xd3, 0x69, 0x07, 0x8a,
	0x4d, 0x7a, 0x15, 0xd3, 0x6b, 0x13, 0xd9, 0x01, 0x65, 0xd4, 0x0e, 0xb4, 0xa1, 0x3b, 0xc0, 0xca,
	0x4d, 0x02, 0x94, 0x58, 0x65, 0x49, 0xa2, 0x5f, 0xd9, 0x4a, 0x0f, 0xa9, 0xb1, 0xad, 0x60, 0x63,
	0x3f, 0x35, 0x0c, 0xbe, 0xbf, 0x27, 0x0c, 0xdf, 0x89, 0x44, 0x87, 0xc5, 0x68, 0xf2, 0x4f, 0xbd,
	0xba, 0xa8, 0x1e, 0x3d, 0x9c, 0x01, 0xe0, 0x2c, 0xd4, 0x6a, 0x5e, 0xc5, 0xd0, 0x08, 0xa3, 0x5c,
	0xab, 0xd9, 0x28, 0x01, 0xa3, 0xac, 0x9b, 0x27, 0xba, 0xac, 0x16, 0x8a, 0xa1, 0xb0, 0xd4, 0x75,
	0xdf, 0xf2, 0x0c, 0xff, 0xd8, 0xcb, 0x33, 0xf2, 0x23, 0x2e, 0xcf, 0x71, 0x18, 0x25, 0x23, 0x7b,
	0x47, 0x65, 0xc9, 0xcf, 0x84, 0x20, 0x1e, 0x28, 0xf4, 0xe1, 0x55, 0x1c, 0xbc, 0x46, 0x48, 0xa7,
	0xf3, 0x67, 0xc2, 0x16, 0x0e, 0xae, 0x11, 0xea, 0x16, 0x93, 0x5f, 0x18, 0xd4, 0x69, 0x46, 0x2f,
	0xc1, 0x98, 0x57, 0x59, 0xc5, 0x3e, 0x71, 0xf6, 0xe2, 0xa1, 0x51, 0xaf, 0xb9, 0x40, 0xc2, 0xc6,
	0xb3, 0x10, 0xe3, 0x2e, 0x91, 0xc6, 0x23, 0xac, 0x6a, 0x0c, 0x58, 0x13, 0x09, 0x43, 0xd0, 0xcb,
	0x7e, 0x89, 0x98, 0xd3, 0x5e, 0x67, 0x40, 0x11, 0x5e, 0x0f, 0x47, 0x9b, 0xd5, 0xf6, 0x3a, 0x85,
	0x7b, 0x09, 0x78, 0x41, 0x98, 0x7f, 0x5d, 0x35, 0x18, 0x04, 0xe3, 0x37, 0x51, 0xa9, 0x38, 0x8c,
	0xf1, 0x29, 0x72, 0x69, 0x7c, 0x4b, 0x00, 0xe4, 0xdd, 0x3a, 0xbe, 0x48, 0x49, 0x96, 0xf0, 0x93,
	0x28, 0xc9, 0x2a, 0xf5, 0x2b, 0xc9, 0x0a, 0xfd, 0xc8, 0xe2, 0xee, 0x50, 0x4c, 0x1d, 0x03, 0x5e,
	0x14, 0x44, 0x77, 0x2a, 0x6f, 0x72, 0x7f, 0x20, 0xc0, 0x58, 0xc9, 0xb2, 0xd9, 0xc9, 0x2d, 0xff,
	0x98, 0x3f, 0xcc, 0x36, 0xfb, 0xc3, 0x4e, 0xad, 0x08, 0x08, 0xba, 0x0a, 0xa3, 0x6d, 0x07, 0xdb,
	0x5a, 0x0d, 0xd7, 0x0d, 0x13, 0xd7, 0x78, 0xb6, 0x1d, 0xa3, 0xb9, 0xea, 0x5c, 0x64, 0xfa, 0xc3,
	0x0f, 0xc3, 0xc4, 0x42, 0x09, 0x48, 0x86, 0x41, 0x10, 0xda, 0x35, 0xd3, 0x39, 0xe2, 0xf0, 0x91,
	0x80, 0xa4, 0x92, 0x70, 0x82, 0x1e, 0x9d, 0xb2, 0xc0, 0x35, 0xc0, 0xf1, 0x3e, 0xff, 0xf8, 0x69,
	0x38, 0xd5, 0x5d, 0x83, 0xa2, 0xe0, 0x3a, 0xb6, 0x49, 0x12, 0x40, 0xa7, 0xa3, 0x40, 0xc4, 0xc6,
	0x75, 0xe7, 0x27, 0x54, 0x7e, 0x44, 0x69, 0x11, 0x5f, 0x30, 0xd3, 0x3d, 0x66, 0xd7, 0x6f, 0x2c,
	0x5c, 0x07, 0x70, 0x0c, 0x17, 0x6b, 0x0d, 0xab, 0xaa, 0x1f, 0x25, 0xc8, 0x11, 0x02, 0x99, 0x27,
	0x80, 0x28, 0x05, 0x13, 0x1d, 0x34, 0xcd, 0x30, 0x1d, 0xa3, 0xe6, 0x95, 0x4e, 0x1c, 0x84, 0x1d,
	0xf7, 0xb1, 0x73, 0x14, 0x1c, 0x5d, 0x86, 0x21, 0xfa, 0xf5, 0x77, 0xf5, 0x88, 0x63, 0x59, 0x0e,
	0x95, 0x9a, 0x81, 0xf1, 0x2d, 0xb3, 0xaf, 0x78, 0xbd, 0x12, 0x8f, 0x6d, 0x18, 0x55, 0xb0, 0x6b,
	0xef, 0xa6, 0xf4, 0xea, 0x83, 0x62, 0xbd, 0x8e, 0x6e, 0xc0, 0xd8, 0xba, 0xee, 0xf0, 0x33, 0xe0,
	0x2d, 0x3e, 0xbf, 0x31, 0x5a, 0x0c, 0x1a, 0x5a, 0xbc, 0xee, 0xed, 0x22, 0xa1, 0xb9, 0x01, 0x65,
	0x94, 0xc0, 0xe5, 0x38, 0x18, 0x7a, 0x05, 0x46, 0x49, 0xf6, 0xee, 0xa3, 0x31, 0x63, 0xe1, 0xe7,
	0x40, 0x4d, 0x7d, 0xc7, 0x03, 0xf4, 0xcf, 0x81, 0xbe, 0x1e, 0x81, 0x38, 0x1d, 0x99, 0x65, 0xd3,
	0x54, 0xb2, 0x9f, 0x11, 0x48, 0xac, 0xe5, 0xda, 0xbb, 0x9a, 0xff, 0x45, 0x72, 0xab, 0xe7, 0x7c,
	0xe6, 0x17, 0xed, 0x5f, 0x50, 0xc2, 0xd7, 0x77, 0x76, 0x94, 0xb1, 0x0d, 0xdd, 0xc5, 0xdb, 0xfa,
	0xee, 0x25, 0x6c, 0xdb, 0x96, 0xad, 0xc4, 0xab, 0x96, 0x69, 0xe2, 0xaa, 0x7b, 0xa9, 0xae, 0x1b,
	0x8d, 0xb6, 0x8d, 0x95, 0x71, 0x1b, 0xd7, 0xdb, 0x0e, 0xae, 0x5d, 0x62, 0x5b, 0x96, 0x32, 0x46,
	0x08, 0x1b, 0xfa, 0x7a, 0x03, 0x5f, 0x5a, 0xda, 0xd9, 0x51, 0x4e, 0x74, 0x5e, 0xd9, 0xc7, 0xfd,
	0x97, 0xaa, 0x56, 0x8d, 0x04, 0xdc, 0xca, 0x30, 0xe5, 0xa0, 0x68, 0xa2, 0x2f, 0x08, 0x10, 0x67,
	0xdc, 0x54, 0xbd, 0x44, 0x60, 0x7a, 0x88, 0x9e, 0xb7, 0xfc, 0x35, 0xff, 0xb4, 0x88, 0x98, 0xcd,
	0x50, 0xe7, 0x1c, 0xe5, 0xff, 0x03, 0x87, 0x04, 0xcd, 0xb5, 0x77, 0x3b, 0xb9, 0xc9, 0x35, 0x88,
	0x99, 0xed, 0xa6, 0x46, 0xa1, 0xfd, 0x33, 0x31, 0xf4, 0xad, 0x3d, 0x41, 0x58, 0xf0, 0xef, 0xe0,
	0xe6, 0x42, 0xd3, 0x51, 0x05, 0xcc, 0x76, 0x53, 0x61, 0x50, 0xe8, 0x26, 0xc4, 0x5b, 0xd8, 0xd6,
	0xc8, 0xe4, 0x5c, 0xa3, 0x89, 0xad, 0xb6, 0xcb, 0xcf, 0xc3, 0xe2, 0x1e, 0x0e, 0x59, 0xe2, 0x4f,
	0xbf, 0x71, 0x41, 0x19, 0x6b, 0x61, 0xbb, 0x6c, 0xef, 0x96, 0x19, 0x14, 0x2a, 0x40, 0x87, 0x2f,
	0x8d, 0xff, 0x58, 0x02, 0x93, 0x5c, 0x24, 0x11, 0xbe, 0x38, 0x96, 0x9a, 0xee, 0x12, 0x4d, 0xf0,
	0x88, 0xe9, 0x98, 0x8f, 0xc7, 0x7e, 0xd3, 0x20, 0x4d, 0xb0, 0xd0, 0x0d, 0x88, 0xae, 0xeb, 0xd5,
	0x07, 0x9a, 0x55, 0xaf, 0xf3, 0x28, 0xe1, 0xd4, 0xbe, 0x28, 0xa1, 0x63, 0x9e, 0xca, 0xf0, 0x3a,
	0x7b, 0x58, 0x1e, 0xff, 0xe0, 0x56, 0x8c, 0xe4, 0xf1, 0x5e, 0xb9, 0xaf, 0x04, 0xb1, 0x55, 0x42,
	0xbf, 0xba, 0xc6, 0x0b, 0x73, 0x46, 0x3a, 0x9f, 0xc8, 0x10, 0x4b, 0x22, 0x01, 0x8a, 0xff, 0xe9,
	0x4b, 0xdf, 0xcf, 0x18, 0x93, 0xdf, 0x11, 0x20, 0x56, 0xc0, 0x3b, 0x6e, 0xd6, 0x6a, 0xf1, 0xc2,
	0xed, 0xce, 0x4f, 0x97, 0x8c, 0xef, 0x63, 0x2b, 0x00, 0xe9, 0xf0, 0x5f, 0x2d, 0x91, 0x21, 0x6e,
	0xe2, 0x1d, 0x77, 0xd3, 0x6a, 0xd1, 0x68, 0x01, 0x3b, 0x5e, 0xfe, 0xd2, 0xeb, 0x96, 0x72, 0x2d,
	0x89, 0xf5, 0xb3, 0x3a, 0x66, 0x8e, 0xc4, 0xdb, 0xd0, 0xa7, 0x60, 0x84, 0x2e, 0xa3, 0xba, 0x5e,
	0xc5, 0x3c, 0x37, 0x3e, 0xdc, 0xaf, 0xcd, 0x3e, 0x7e, 0x38, 0xe1, 0x95, 0xf2, 0xf9, 0x98, 0xc1,
	0x4f, 0xb1, 0xfc, 0xc6, 0xe4, 0x7f, 0x0b, 0x41, 0x9c, 0x88, 0xdf, 0xa8, 0xd2, 0xb3, 0x00, 0x3a,
	0xcf, 0x5b, 0x30, 0xa8, 0xbb, 0x2e, 0xff, 0x92, 0x64, 0x7f, 0xa4, 0x49, 0x01, 0x25, 0xd7, 0x65,
	0xb9, 0x37, 0xf8, 0x74, 0x23, 0x0a, 0x43, 0x43, 0x29, 0x18, 0x76, 0xda, 0xeb, 0x26, 0x76, 0xbd,
	0x03, 0x81, 0x53, 0xfb, 0xa6, 0xab, 0xd2, 0x7e, 0x4a, 0x20, 0xd6, 0x39, 0xeb, 0x0c, 0x29, 0x1e,
	0x22, 0x5a, 0x82, 0x61, 0x2e, 0x05, 0x5e, 0x7b, 0x3b, 0x73, 0xb0, 0xb8, 0x15, 0x0f, 0x14, 0xad,
	0xf9, 0x1f, 0x0b, 0xc7, 0xe8, 0xc0, 0x73, 0x7d, 0x7e, 0x3c, 0x23, 0x30, 0xd3, 0xae, 0xcf, 0x84,
	0xd1, 0xbb, 0x4f, 0x84, 0x30, 0x08, 0x42, 0x9f, 0xaf, 0x85, 0x7f, 0x8c, 0xef, 0x68, 0xe9, 0xad,
	0xfb, 0xe2, 0xfc, 0xc2, 0xd5, 0xf9, 0x85, 0x85, 0xf9, 0x85, 0xe4, 0x07, 0x11, 0x38, 0xb1, 0x62,
	0xd9, 0xdb, 0xba, 0x5d, 0x2b, 0xd9, 0xd6, 0xce, 0x6e, 0xe0, 0xc8, 0x5b, 0x83, 0xe3, 0xdb, 0x9b,
	0x74, 0x3f, 0x30, 0xe8, 0x99, 0x7e, 0xcf, 0xa5, 0xe4, 0xab, 0x4f, 0x03, 0x4e, 0xaf, 0xdf, 0xe5,
	0xe4, 0x9b, 0x81, 0xa5, 0x35, 0x49, 0x29, 0xe5, 0x29, 0xa1, 0x92, 0x77, 0x3b, 0x99, 0x07, 0xd4,
	0x3d, 0x80, 0x65, 0x73, 0x0d, 0x8d, 0xa5, 0x66, 0x9f, 0x7a, 0x5f, 0x30, 0xbf, 0x23, 0x44, 0x93,
	0x7c, 0x37, 0xef, 0x90, 0x56, 0xc4, 0x20, 0x41, 0x82, 0x87, 0x32, 0x70, 0x8c, 0xf8, 0x77, 0xee,
	0xc3, 0x34, 0xdd, 0x75, 0x71, 0xb3, 0xe5, 0x3a, 0xdc, 0x6b, 0x20, 0x42, 0x8f, 0xba, 0x9c, 0x8e,
	0xbb, 0x41, 0x4d, 0x7d, 0x27, 0xcd, 0xc0, 0x25, 0x0e, 0x8d, 0x56, 0x00, 0x71, 0x0a, 0xde, 0x47,
	0x6c, 0xc4, 0xf3, 0x44, 0xd8, 0x49, 0x3c, 0xa7, 0x11, 0x59, 0xbc, 0x7a, 0xf5, 0x6a, 0xd0, 0x03,
	0x4d, 0x74, 0x50, 0x3c, 0x2f, 0xf4, 0x09, 0x88, 0x9b, 0x56, 0xf7, 0x3d, 0xe5, 0xd0, 0xa1, 0x1b,
	0xe2, 0xb8, 0x69, 0x75, 0x5d, 0x76, 0x16, 0x61, 0x8c, 0x64, 0x3b, 0x3e, 0x05, 0x7e, 0x95, 0x74,
	0xc4, 0xa5, 0x62, 0x57, 0x70, 0x3d, 0xea, 0x06, 0x3a, 0x97, 0xd5, 0x67, 0x7b, 0x42, 0x11, 0x4e,
	0xc3, 0x71, 0xf5, 0x81, 0xd1, 0x4a, 0x78, 0xe5, 0x4f, 0x89, 0x96, 0x6e, 0x3b, 0x86, 0xb9, 0x81,
	0xc8, 0x96, 0x07, 0x57, 0xe0, 0xe2, 0x0a, 0xf3, 0xfd, 0x89, 0x4d, 0xdd, 0xac, 0x35, 0x0c, 0x73,
	0x83, 0x7e, 0x11, 0xd3, 0xf6, 0x6e, 0x98, 0x3a, 0x13, 0x45, 0xf4, 0xca, 0xe7, 0x32, 0x4c, 0x75,
	0x71, 0x49, 0x84, 0xc6, 0xf7, 0xf1, 0xc9, 0xa7, 0x7b, 0xc2, 0x90, 0x77, 0xf1, 0x73, 0x63, 0xfe,
	0xe6, 0x0f, 0xf6, 0x04, 0x81, 0x6f, 0xe9, 0x6f, 0x0b, 0x30, 0x4e, 0x32, 0xca, 0x1c, 0x3d, 0xd0,
	0xae, 0x1b, 0xd8, 0x46, 0x67, 0x21, 0x64, 0xb4, 0xbc, 0x33, 0xe7, 0x40, 0x65, 0x46, 0x8b, 0x4c,
	0x24, 0x64, 0xb4, 0xd0, 0xf5, 0xc0, 0x4f, 0x15, 0xf5, 0x14, 0x70, 0xb0, 0xba, 0x0d, 0xbf, 0x94,
	0x23, 0x3b, 0xd0, 0xf9, 0x15, 0x23, 0x12, 0x5f, 0xf8, 0x15, 0x85, 0x96, 0xad, 0x19, 0xad, 0x7d,
	0xe1, 0xdb, 0xe7, 0x04, 0x7e, 0x4f, 0x46, 0xdc, 0x4f, 0x80, 0xa3, 0x05, 0x88, 0xea, 0xe6, 0x2e,
	0x99, 0x5a, 0xfd, 0x88, 0x10, 0x6a, 0x58, 0x37, 0x77, 0x73, 0xa6, 0x5b, 0x47, 0x2f, 0x43, 0x84,
	0x82, 0x1f, 0x90, 0xd1, 0x66, 0x07, 0x14, 0xda, 0x9f, 0x3a, 0x0d, 0xa2, 0xef, 0xf0, 0x0e, 0x8a,
	0x2a, 0xff, 0x5c, 0x00, 0xe4, 0xb3, 0x55, 0xb4, 0xbd, 0xb2, 0x5c, 0x6f, 0x08, 0xe1, 0xf0, 0x21,
	0xd0, 0x05, 0x08, 0xb7, 0xac, 0xda, 0x21, 0x9c, 0x90, 0x6e, 0x74, 0x17, 0x86, 0x79, 0xf4, 0x45,
	0x97, 0xc9, 0x0b, 0x15, 0x57, 0xb3, 0xa3, 0xfe, 0xbf, 0x29, 0x0c, 0xce, 0x84, 0x07, 0x04, 0x12,
	0x60, 0x0f, 0x6d, 0x79, 0x45, 0xab, 0xa1, 0x2d, 0x93, 0xff, 0x28, 0x51, 0xbf, 0x11, 0x43, 0x5b,
	0xe6, 0xa1, 0x33, 0xf7, 0x02, 0x3e, 0x1b, 0x26, 0x99, 0x43, 0xd4, 0xed, 0x0d, 0xec, 0x2e, 0xa6,
	0x76, 0x5d, 0x2c, 0x39, 0x26, 0x9a, 0x83, 0x11, 0xdd, 0xd1, 0xcc, 0x76, 0x73, 0x1d, 0xdb, 0x7c,
	0x51, 0x33, 0x56, 0xe6, 0x86, 0x88, 0x6f, 0xb8, 0x28, 0x28, 0x51, 0xdd, 0x29, 0xd0, 0x6e, 0x74,
	0xde, 0xf3, 0x7e, 0x91, 0x5e, 0xb8, 0x0f, 0x3f, 0x8c, 0x73, 0x67, 0x18, 0xfc, 0x80, 0x20, 0xe9,
	0x76, 0x8d, 0xb9, 0xe4, 0x8d, 0x79, 0x79, 0xff, 0x98, 0x13, 0xf4, 0x6a, 0x6c, 0x0e, 0x18, 0xad,
	0x8b, 0x8f, 0x1e, 0x45, 0x02, 0xe3, 0x9e, 0xeb, 0x1e, 0x37, 0x98, 0x89, 0xf4, 0x1b, 0xb5, 0xda,
	0x35, 0x6a, 0xae, 0xb4, 0xb5, 0x44, 0x53, 0xf6, 0xf3, 0x30, 0xec, 0xed, 0xce, 0x4c, 0xcd, 0x23,
	0xdc, 0xb6, 0x77, 0x04, 0xc5, 0xeb, 0xe9, 0x0c, 0x15, 0x3e, 0x64, 0x28, 0x32, 0xc8, 0x97, 0x43,
	0x10, 0x0b, 0x8c, 0x82, 0x8a, 0x20, 0xea, 0x8e, 0xb9, 0xb8, 0xbe, 0xeb, 0x62, 0xcd, 0x76, 0x69,
	0xdb, 0x01, 0x79, 0x5d, 0x1f, 0x2d, 0x90, 0x90, 0xdf, 0xc3, 0x56, 0x18, 0x32, 0xc9, 0x14, 0x8d,
	0xd6, 0xd6, 0x12, 0x8d, 0x28, 0x7c, 0x8a, 0xe1, 0xa3, 0x28, 0x7a, 0xb3, 0x25, 0x14, 0x09, 0x3a,
	0x79, 0xf6, 0x28, 0x32, 0x16, 0x97, 0xba, 0x58, 0x8c, 0x1c, 0x45, 0x70, 0xa9, 0x9b, 0xc5, 0xa5,
	0x00, 0x8b, 0xa9, 0xf3, 0x30, 0xce, 0xe9, 0xf4, 0x96, 0x47, 0x09, 0xc1, 0xcb, 0x14, 0x41, 0x0c,
	0xcd, 0x6d, 0x03, 0x74, 0x4e, 0xe1, 0xd1, 0x30, 0x84, 0xa5, 0xc2, 0x7d, 0x71, 0x80, 0x3c, 0xdc,
	0x96, 0xcb, 0xa2, 0x80, 0xa2, 0x10, 0xc9, 0xca, 0x52, 0x46, 0x0c, 0x91, 0xa7, 0x52, 0x51, 0x2d,
	0x8b, 0x61, 0xd2, 0x59, 0xaa, 0x94, 0xc5, 0x08, 0x02, 0x18, 0xca, 0xc8, 0x79, 0xb9, 0x2c, 0x8b,
	0x83, 0x28, 0x06, 0xc3, 0xe9, 0x62, 0xa1, 0x20, 0xa7, 0xcb, 0xe2, 0x10, 0x79, 0x29, 0x96, 0xca,
	0xb9, 0x62, 0x41, 0x15, 0x87, 0xd1, 0x08, 0x0c, 0x96, 0x15, 0x29, 0x2d, 0x8b, 0x51, 0xf2, 0x58,
	0x92, 0xca, 0xe9, 0xac, 0x38, 0x32, 0xf7, 0x95, 0x11, 0x18, 0x27, 0x23, 0x77, 0x62, 0x4f, 0x34,
	0x09, 0x71, 0xea, 0x63, 0x3a, 0x4d, 0xe2, 0x00, 0x1a, 0x85, 0x68, 0xda, 0x32, 0x5d, 0xc3, 0x6c,
	0x63, 0x91, 0x30, 0x18, 0x2a, 0xde, 0x15, 0xbf, 0x2a, 0xa0, 0x51, 0x18, 0x66, 0x3f, 0x16, 0x53,
	0x13, 0xff, 0x83, 0x80, 0xc6, 0x20, 0x4a, 0x12, 0xf2, 0x16, 0x79, 0xfd, 0x9a, 0x80, 0x12, 0x70,
	0xaa, 0x60, 0x99, 0x52, 0xdb, 0xdd, 0xb4, 0x6c, 0x83, 0x84, 0x1c, 0x5b, 0xf4, 0x9b, 0x7b, 0xbb,
	0x49, 0x6f, 0x06, 0xc5, 0xff, 0x28, 0xa0, 0x71, 0x18, 0x29, 0x58, 0x84, 0x2e, 0x36, 0x5d, 0xf1,
	0xeb, 0x02, 0x9a, 0x20, 0x59, 0x97, 0x83, 0x5d, 0xaf, 0xe9, 0x3f, 0x09, 0x68, 0x12, 0xc6, 0x4b,
	0xba, 0xed, 0x1a, 0x7a, 0xc3, 0x6b, 0xfc, 0xcf, 0x02, 0x12, 0x21, 0xb6, 0xda, 0x6e, 0xb8, 0x06,
	0x63, 0x51, 0xfc, 0x86, 0x80, 0x8e, 0x41, 0x5c, 0x6a, 0xd8, 0x58, 0xaf, 0xed, 0x2a, 0x98, 0xec,
	0xe8, 0xb8, 0x26, 0xbe, 0x2f, 0xa0, 0x18, 0x0c, 0xe5, 0x56, 0x2b, 0x0e, 0xae, 0x89, 0xcf, 0x29,
	0x08, 0x45, 0x6a, 0x35, 0x70, 0x9a, 0xaa, 0xc3, 0x11, 0xbf, 0x1c, 0x42, 0xc7, 0x41, 0x5c, 0xb5,
	0xb6, 0x70, 0xad, 0x84, 0xed, 0xa6, 0x6e, 0x62, 0xd3, 0x6d, 0xec, 0x8a, 0xbf, 0x1d, 0x42, 0x00,
	0x83, 0x2b, 0x56, 0xdb, 0xac, 0x89, 0xff, 0x3c, 0x44, 0xa6, 0xa5, 0x62, 0x5c, 0x74, 0x37, 0xb1,
	0x2d, 0xfe, 0x4e, 0x88, 0x0c, 0x5e, 0xb0, 0xdc, 0x55, 0xfa, 0xf1, 0x38, 0xae, 0x89, 0xbf, 0x4b,
	0x01, 0x2a, 0x0e, 0xa6, 0x91, 0x8c, 0xf8, 0x7b, 0x21, 0x74, 0x02, 0x26, 0xca, 0xb8, 0xd9, 0xb2,
	0x6c, 0xdd, 0xde, 0x55, 0x70, 0xcd, 0xb0, 0x71, 0xd5, 0x15, 0x7f, 0x9f, 0xb6, 0xfb, 0xa3, 0xf8,
	0xed, 0xff, 0x22, 0x84, 0xe2, 0x00, 0x29, 0xbd, 0xc6, 0x2f, 0xd5, 0xc5, 0xcf, 0x86, 0x89, 0x18,
	0x2a, 0xa6, 0xce, 0xe4, 0xf6, 0x4b, 0xb8, 0x26, 0xfe, 0x6a, 0x98, 0x30, 0x5f, 0xd2, 0x77, 0x9b,
	0x14, 0x93, 0x56, 0xb1, 0xd5, 0xc4, 0x77, 0xc2, 0x44, 0x7e, 0x2b, 0x96, 0xbd, 0x6e, 0xd4, 0x6a,
	0xd8, 0x14, 0xff, 0x6e, 0x98, 0x30, 0x52, 0xb0, 0x5c, 0xc6, 0xf8, 0xe7, 0xc2, 0x74, 0x6e, 0xd4,
	0xa2, 0x0a, 0x96, 0x2b, 0x35, 0x1a, 0xd6, 0x36, 0xae, 0x89, 0x7f, 0x2f, 0x8c, 0x10, 0xd0, 0x9f,
	0xfd, 0xa3, 0x9a, 0x22, 0x79, 0x87, 0xf8, 0xf7, 0xc3, 0x44, 0x57, 0x94, 0xff, 0xee, 0x8f, 0x3a,
	0xfd, 0xb1, 0x7e, 0x2d, 0x4c, 0x14, 0x11, 0xb8, 0xf7, 0xb7, 0xda, 0xae, 0xf8, 0x79, 0x3a, 0x20,
	0x89, 0xdd, 0x1a, 0x46, 0xd5, 0x15, 0xff, 0x41, 0x18, 0x8d, 0x40, 0xe4, 0xb6, 0x65, 0x62, 0xf1,
	0x5d, 0x0a, 0x9e, 0xc7, 0xe6, 0x86, 0xbb, 0xe9, 0xd3, 0xf8, 0x87, 0x61, 0x34, 0x05, 0xa8, 0x64,
	0x63, 0x3f, 0x6d, 0x64, 0xbf, 0x55, 0x28, 0xfe, 0xba, 0x37, 0xbd, 0x86, 0xa5, 0xd7, 0xca, 0x96,
	0x95, 0x27, 0x6b, 0x46, 0xfc, 0x47, 0x61, 0x22, 0x98, 0x8a, 0x92, 0x23, 0x2d, 0x96, 0xb9, 0x21,
	0xfe, 0xe3, 0x30, 0x3a, 0x09, 0xc7, 0x2a, 0xa6, 0xd3, 0x6e, 0x31, 0x0d, 0xaf, 0xe2, 0x9a, 0x41,
	0xbf, 0x3d, 0x17, 0xff, 0x49, 0x18, 0x4d, 0xc3, 0x24, 0xad, 0x28, 0x2b, 0x58, 0xae, 0xaa, 0xbb,
	0x86, 0x53, 0xa7, 0x29, 0x95, 0xf8, 0x5e, 0x98, 0x88, 0x5d, 0xde, 0x69, 0xe1, 0x2a, 0xfb, 0x0d,
	0x17, 0x3e, 0xe6, 0x3f, 0xa5, 0xcc, 0xac, 0x1a, 0x0e, 0x53, 0x03, 0xf6, 0xc5, 0xff, 0x9b, 0x94,
	0x54, 0xc5, 0x6c, 0xd9, 0x56, 0x15, 0x3b, 0xb4, 0x5e, 0x41, 0x36, 0x5d, 0xc3, 0xdd, 0x15, 0x7f,
	0x2b, 0x4c, 0xec, 0x29, 0x6f, 0x55, 0x1f, 0xe0, 0x9a, 0xf8, 0x45, 0x2a, 0x5d, 0x46, 0x2c, 0x83,
	0x5b, 0xd8, 0xac, 0x61, 0xb3, 0xba, 0x2b, 0x7e, 0x89, 0x4e, 0xa5, 0xd2, 0xda, 0xb0, 0xf5, 0x1a,
	0xf6, 0x67, 0xfe, 0x98, 0x72, 0x1e, 0x9c, 0xb9, 0xdf, 0xf5, 0x65, 0x8a, 0x50, 0xb6, 0xac, 0x55,
	0xdd, 0xdc, 0xe5, 0x3c, 0x38, 0xe2, 0x6f, 0x53, 0x85, 0xf0, 0x57, 0x76, 0x3c, 0xbf, 0x62, 0xe0,
	0x46, 0xcd, 0xf1, 0xa5, 0xf3, 0x3b, 0x94, 0x4d, 0xef, 0x23, 0x3a, 0x95, 0x9d, 0x59, 0x93, 0x7c,
	0x5a, 0xfc, 0xef, 0x54, 0xf6, 0x05, 0xcb, 0xcd, 0x35, 0x5b, 0x0d, 0x4c, 0x2c, 0x06, 0xd7, 0xc4,
	0xff, 0x11, 0xe6, 0x56, 0x76, 0x9b, 0xe5, 0xde, 0xe2, 0x9f, 0xd1, 0xf9, 0xab, 0xec, 0x67, 0x15,
	0x2b, 0xa6, 0xbe, 0xa5, 0x1b, 0x0d, 0x2a, 0xb0, 0x3f, 0xa7, 0xe8, 0x1c, 0xcc, 0xd3, 0xf4, 0x0f,
	0xc3, 0xe8, 0x34, 0x4c, 0x65, 0xcb, 0xe5, 0x12, 0x3f, 0x2e, 0x24, 0x52, 0xf6, 0xd4, 0x20, 0xfe,
	0xcf, 0x30, 0x9a, 0x81, 0xe3, 0x6b, 0xba, 0x6d, 0xe8, 0xa6, 0x2b, 0x35, 0x1c, 0xab, 0x80, 0x37,
	0x2c, 0xd7, 0xd0, 0x5d, 0xec, 0x88, 0xff, 0x8b, 0xf3, 0x49, 0xeb, 0x1d, 0xab, 0x06, 0x36, 0x5d,
	0xd5, 0xb5, 0x6c, 0x7d, 0x03, 0x8b, 0xff, 0x9b, 0xda, 0x79, 0xde, 0xb2, 0x5a, 0x19, 0xec, 0x52,
	0x15, 0x88, 0xff, 0x27, 0xcc, 0x17, 0x97, 0xbc, 0xe3, 0x12, 0x89, 0xd6, 0xc4, 0xff, 0x1b, 0x46,
	0x49, 0x38, 0xc3, 0x03, 0x81, 0x03, 0x6c, 0xf3, 0xc3, 0xf0, 0x5c, 0x0a, 0x26, 0xf6, 0xfd, 0x20,
	0x20, 0x3a, 0x09, 0xc7, 0xd5, 0xb2, 0x54, 0xae, 0xa8, 0x5a, 0xa6, 0xa8, 0x15, 0x8a, 0x65, 0xad,
	0x54, 0x49, 0xe5, 0x73, 0x6a, 0x56, 0x1c, 0x40, 0x08, 0xc6, 0x79, 0x97, 0xd7, 0x26, 0xcc, 0x2d,
	0x13, 0x71, 0xf4, 0x7e, 0x3d, 0x88, 0x44, 0x18, 0xf5, 0xde, 0x0b, 0xc4, 0xb2, 0x29, 0xae, 0xd7,
	0x92, 0xa2, 0xa5, 0x5a, 0xa2, 0x30, 0x77, 0x01, 0xc6, 0xba, 0x2e, 0x1e, 0xa8, 0xbf, 0x2e, 0x97,
	0x4b, 0xe2, 0x00, 0xf1, 0xb5, 0xe4, 0x49, 0x15, 0x85, 0xb9, 0x22, 0xc4, 0x02, 0xdf, 0x04, 0x10,
	0x97, 0x4a, 0x4b, 0xf7, 0x2b, 0xe5, 0xa2, 0x38, 0x40, 0x7c, 0x75, 0x39, 0xaf, 0x6e, 0x2d, 0x68,
	0x57, 0x45, 0xa1, 0xf3, 0xb2, 0x20, 0x86, 0x3a, 0x2f, 0x8b, 0x62, 0xb8, 0xf3, 0x72, 0x4d, 0x8c,
	0xcc, 0x5d, 0x84, 0x38, 0xd9, 0x8a, 0x0c, 0x73, 0xa3, 0x64, 0x1b, 0xc4, 0xc7, 0xee, 0x92, 0xfe,
	0x8c, 0xbc, 0x22, 0x55, 0xf2, 0x65, 0x71, 0x80, 0x72, 0x91, 0xbb, 0x4d, 0x26, 0xf7, 0x71, 0x88,
	0xf7, 0xd4, 0x22, 0x11, 0xc8, 0x6c, 0xa5, 0x90, 0x51, 0xe4, 0x8c, 0x38, 0x40, 0xa6, 0x59, 0x96,
	0x0b, 0x5a, 0x39, 0x5b, 0xac, 0xa8, 0x52, 0x21, 0xc3, 0x58, 0x58, 0xcd, 0xe5, 0xf3, 0xb9, 0x62,
	0x41, 0x0c, 0xcd, 0xbd, 0x09, 0x63, 0x19, 0xc3, 0xa9, 0x5a, 0x5b, 0xd8, 0xde, 0xe5, 0x9f, 0x0b,
	0x4f, 0xe4, 0x0a, 0x6b, 0x52, 0x3e, 0x97, 0xd1, 0x32, 0x39, 0x35, 0x5d, 0x5c, 0x93, 0x95, 0xfb,
	0xe2, 0xc0, 0x4c, 0xf8, 0xd1, 0x43, 0x81, 0xec, 0x4b, 0x77, 0x5f, 0x53, 0x45, 0x81, 0xec, 0x4b,
	0xe9, 0x62, 0x41, 0xad, 0xe4, 0xc5, 0xd0, 0xdc, 0x45, 0x88, 0xdd, 0xd3, 0xeb, 0xab, 0x56, 0x8d,
	0xc9, 0x67, 0x04, 0x06, 0x53, 0xf9, 0x62, 0xfa, 0xae, 0x38, 0x80, 0xc6, 0x01, 0xa4, 0xbc, 0xac,
	0x94, 0xb5, 0x62, 0x21, 0x7f, 0x5f, 0x14, 0xe6, 0x54, 0x88, 0xad, 0x19, 0xad, 0x35, 0xdb, 0x6e,
	0x71, 0x2d, 0x8a, 0x6b, 0xb9, 0x92, 0xb6, 0xa6, 0x28, 0x25, 0x8d, 0x0f, 0xe9, 0x0d, 0x34, 0x09,
	0x71, 0xbf, 0x4b, 0x2e, 0x48, 0xa9, 0xbc, 0x2c, 0x12, 0x2f, 0xdf, 0x81, 0xcf, 0xe4, 0x54, 0xda,
	0x1a, 0x9a, 0xfb, 0xeb, 0x70, 0x4c, 0x35, 0x5c, 0x5c, 0xb6, 0xe8, 0xdf, 0xb6, 0x69, 0xe2, 0x06,
	0xa5, 0x7e, 0x01, 0x12, 0x6a, 0xae, 0x2c, 0x6b, 0xe5, 0xa2, 0xc6, 0xfe, 0xad, 0x14, 0x0a, 0x72,
	0x5e, 0xcb, 0x95, 0x54, 0x39, 0xad, 0x15, 0x15, 0x4d, 0x55, 0xf3, 0xe2, 0x00, 0x3a, 0x03, 0x27,
	0x0f, 0x84, 0x12, 0x05, 0x74, 0x0a, 0xa6, 0xfa, 0x75, 0x13, 0xdc, 0x50, 0x32, 0x12, 0x0d, 0x8b,
	0xe1, 0xb9, 0x39, 0x18, 0x51, 0x2d, 0xdb, 0x2d, 0xda, 0x35, 0x6c, 0x93, 0x19, 0x67, 0x64, 0x35,
	0x2d, 0x17, 0x32, 0xb9, 0xc2, 0x6d, 0x71, 0x00, 0x8d, 0xc1, 0x88, 0xe4, 0xbf, 0x0a, 0x73, 0x39,
	0x98, 0x62, 0x1c, 0xca, 0x66, 0x55, 0x6f, 0x39, 0xfc, 0x3b, 0x2d, 0xca, 0xee, 0x18, 0x8c, 0x30,
	0xd6, 0x4a, 0x77, 0x73, 0x0c, 0x91, 0xbf, 0xaa, 0x77, 0x45, 0x2a, 0x78, 0x3a, 0x26, 0x0d, 0x1b,
	0x14, 0x59, 0x0c, 0xcf, 0xfd, 0xd7, 0x51, 0x98, 0x0e, 0x5c, 0xe9, 0xae, 0x19, 0x56, 0x37, 0xb1,
	0xb5, 0x5c, 0x31, 0xaf, 0x15, 0x8a, 0x05, 0x59, 0x1c, 0x40, 0x13, 0x30, 0x46, 0x5f, 0x57, 0x72,
	0x79, 0xb9, 0x7c, 0xbf, 0x44, 0x64, 0x19, 0x87, 0x18, 0x6d, 0x5a, 0x95, 0xcb, 0xd9, 0x22, 0x09,
	0x3e, 0x4e, 0xc2, 0x71, 0xd6, 0x20, 0x15, 0x32, 0x52, 0xb9, 0xa8, 0xdc, 0xd7, 0x48, 0x54, 0x22,
	0x2b, 0x62, 0x98, 0xc8, 0x88, 0x76, 0x11, 0x63, 0xd7, 0x14, 0x59, 0x2d, 0x15, 0x0b, 0xaa, 0xac,
	0xb1, 0x55, 0x26, 0x46, 0x88, 0x8c, 0x68, 0xb7, 0x22, 0xbf, 0x55, 0x91, 0xd5, 0xb2, 0xb6, 0x2a,
	0x7d, 0x52, 0xcb, 0xcb, 0x85, 0xdb, 0xe5, 0xac, 0x38, 0xc8, 0x74, 0xc6, 0x87, 0xd6, 0x2a, 0xa5,
	0x7c, 0x51, 0xca, 0x88, 0x43, 0xe8, 0x34, 0x4c, 0xf7, 0xb6, 0x6a, 0xb9, 0x82, 0x96, 0x2a, 0x66,
	0xee, 0x8b, 0xc3, 0xe8, 0x04, 0x20, 0xda, 0xfb, 0xc9, 0x55, 0xc2, 0x4e, 0x7e, 0xa5, 0xa8, 0xac,
	0xca, 0x19, 0x31, 0x8a, 0xa6, 0x60, 0x92, 0xb6, 0xdf, 0x51, 0x8b, 0x85, 0x40, 0xc7, 0x88, 0x4f,
	0x4e, 0x52, 0x57, 0xb5, 0x74, 0xb1, 0x78, 0x37, 0x27, 0x6b, 0xab, 0xc5, 0x4c, 0x6e, 0x25, 0x27,
	0x67, 0x44, 0x40, 0xf3, 0x70, 0xb1, 0xc3, 0x7e, 0x49, 0x29, 0x96, 0x8b, 0x69, 0x32, 0xcf, 0x4a,
	0xbe, 0x9c, 0x2b, 0xe5, 0x65, 0x2d, 0x5b, 0x54, 0xcb, 0x7c, 0xae, 0xaa, 0x18, 0x43, 0xaf, 0xc3,
	0xf5, 0x3e, 0xd0, 0xe9, 0xac, 0x9c, 0xbe, 0x4b, 0x66, 0x96, 0x5b, 0xad, 0xac, 0x6a, 0x85, 0xca,
	0x6a, 0x4a, 0x56, 0xb4, 0xe2, 0x8a, 0x56, 0x92, 0x14, 0x69, 0x55, 0x2e, 0x13, 0xd4, 0xd1, 0x03,
	0x06, 0x4a, 0x49, 0x99, 0xe0, 0x18, 0xda, 0x9a, 0x94, 0xaf, 0xc8, 0xe2, 0x18, 0xba, 0x01, 0x8b,
	0x3f, 0xc2, 0x40, 0x1e, 0x83, 0xe3, 0x68, 0x01, 0x2e, 0xf5, 0xc1, 0xab, 0x14, 0x4a, 0x92, 0x42,
	0x97, 0x84, 0xaf, 0x87, 0x74, 0xb1, 0x50, 0x96, 0x0b, 0x65, 0x31, 0x8e, 0x6e, 0xc2, 0xb5, 0x3e,
	0x28, 0xc4, 0x7f, 0x68, 0x92, 0x9a, 0xce, 0xe5, 0xb4, 0x74, 0x56, 0x52, 0xa4, 0x34, 0x99, 0x06,
	0x51, 0x83, 0x37, 0x96, 0x88, 0x5e, 0x86, 0x64, 0x1f, 0xc4, 0x42, 0x25, 0x9f, 0x27, 0x70, 0x7c,
	0x20, 0x71, 0x02, 0xbd, 0x02, 0xe7, 0x0f, 0x9a, 0x39, 0x69, 0x59, 0x93, 0x15, 0x95, 0x78, 0x1b,
	0x84, 0x24, 0xf8, 0x78, 0xbf, 0x49, 0x33, 0x4e, 0xb9, 0xd5, 0x68, 0x6a, 0xb6, 0x58, 0xc9, 0x67,
	0xb4, 0x94, 0xac, 0x49, 0x5a, 0xa9, 0xa8, 0xe6, 0xca, 0xb9, 0x35, 0x99, 0x8b, 0x42, 0x9c, 0x3c,
	0x40, 0x6e, 0x41, 0x09, 0x13, 0x72, 0x52, 0xae, 0xa0, 0x6a, 0xb9, 0x92, 0x26, 0x65, 0x32, 0x8a,
	0xac, 0xaa, 0xe2, 0x31, 0xf4, 0x73, 0x70, 0xb3, 0xdf, 0xd0, 0x4a, 0x7e, 0x25, 0x38, 0xfd, 0x94,
	0xbc, 0x52, 0x54, 0x3a, 0x32, 0x54, 0xcb, 0x92, 0x52, 0x16, 0x8f, 0x1f, 0x60, 0x15, 0x85, 0x62,
	0xd7, 0xb8, 0x44, 0x74, 0xa4, 0x7f, 0x41, 0x5b, 0xf0, 0x65, 0x73, 0xe2, 0x00, 0xe1, 0x13, 0xd9,
	0x30, 0x13, 0x94, 0x94, 0x72, 0xc0, 0x8c, 0xc8, 0xa3, 0x4a, 0x9c, 0xc5, 0x14, 0xba, 0x05, 0xcb,
	0x47, 0x22, 0x92, 0x25, 0xa0, 0x65, 0xa4, 0xb2, 0xe4, 0x73, 0xec, 0xe1, 0x4f, 0xa3, 0x6b, 0x70,
	0xa5, 0x1f, 0x7e, 0x31, 0x73, 0x9f, 0x70, 0x7a, 0x5b, 0x2e, 0x13, 0x2f, 0x48, 0x58, 0xf7, 0x70,
	0x55, 0xf1, 0xe4, 0x41, 0x0a, 0xca, 0x56, 0x0a, 0x77, 0x65, 0x1f, 0x90, 0x7f, 0x84, 0xd5, 0xad,
	0x35, 0xee, 0x2e, 0x66, 0xd0, 0x75, 0x58, 0xe8, 0x43, 0x42, 0x95, 0xd7, 0x64, 0x45, 0xca, 0xf7,
	0xc7, 0x52, 0xc5, 0x53, 0x07, 0x19, 0x29, 0x13, 0x6d, 0x41, 0x5a, 0x95, 0xd9, 0xa8, 0x44, 0xe6,
	0xc1, 0x85, 0x74, 0xfa, 0x00, 0xdd, 0x90, 0x4c, 0xea, 0x50, 0x7e, 0xaf, 0x8a, 0x67, 0x7c, 0xcf,
	0x26, 0xaf, 0x49, 0xc4, 0x40, 0xa9, 0x70, 0x2b, 0x05, 0x59, 0x4d, 0x4b, 0x25, 0x59, 0x9c, 0x45,
	0x49, 0x98, 0xed, 0xea, 0x96, 0x4a, 0x52, 0x3a, 0x2b, 0x6b, 0xf7, 0xb2, 0xb9, 0xb2, 0xac, 0x96,
	0x48, 0xc2, 0x75, 0x16, 0x9d, 0x87, 0xb3, 0x3d, 0x24, 0x14, 0x59, 0x4b, 0xdd, 0x2f, 0xcb, 0x5a,
	0x46, 0x4e, 0x17, 0xa9, 0xdf, 0x4f, 0xf8, 0xeb, 0xc3, 0x03, 0xca, 0xe5, 0x54, 0xad, 0x52, 0xc8,
	0xa5, 0x8b, 0x19, 0x59, 0x23, 0x7f, 0x4a, 0xc5, 0x5c, 0xa1, 0xac, 0x8a, 0xe7, 0x50, 0x02, 0x4e,
	0xef, 0x03, 0x4c, 0x49, 0xe9, 0xbb, 0x6a, 0x5e, 0x52, 0xb3, 0xb2, 0x2a, 0x26, 0x7d, 0x6f, 0xeb,
	0x41, 0x54, 0x3a, 0xe3, 0x9c, 0xdf, 0xc7, 0xb0, 0xef, 0xe4, 0x7c, 0x98, 0x0b, 0xe8, 0x25, 0x38,
	0xd7, 0x05, 0x93, 0xc9, 0x29, 0x72, 0x9a, 0x3a, 0xfc, 0xb2, 0x22, 0x91, 0x95, 0x2a, 0xe5, 0x55,
	0xf1, 0xa5, 0xb9, 0x9b, 0x00, 0x65, 0xfa, 0xc3, 0x55, 0x5e, 0x44, 0x51, 0x29, 0xdc, 0x2d, 0x14,
	0xef, 0x15, 0x58, 0xc2, 0xb8, 0xa2, 0xc8, 0xf2, 0x6a, 0xae, 0xb2, 0x2a, 0x92, 0x44, 0x0f, 0xe4,
	0x42, 0x59, 0x56, 0x4a, 0x4a, 0x4e, 0x25, 0xfb, 0xf1, 0xef, 0x09, 0x20, 0x96, 0xf5, 0x1d, 0x79,
	0x07, 0x37, 0x3b, 0xdf, 0x12, 0xc4, 0x21, 0x56, 0x96, 0x3e, 0xa9, 0x75, 0x68, 0xf0, 0x06, 0x45,
	0xbe, 0x5d, 0xc9, 0x4b, 0x8a, 0x28, 0x90, 0xfd, 0x87, 0x34, 0xc8, 0x9f, 0x94, 0x57, 0x4b, 0x65,
	0xad, 0x52, 0x58, 0x93, 0x15, 0xe6, 0xc0, 0x43, 0xc4, 0xef, 0x07, 0xba, 0xfc, 0x0e, 0x12, 0x3f,
	0xce, 0xee, 0xeb, 0x48, 0x4b, 0x24, 0x2b, 0xd6, 0x56, 0xa4, 0x5c, 0x5e, 0xce, 0x88, 0x11, 0xa2,
	0x9f, 0x83, 0x60, 0x4a, 0x7c, 0x5f, 0x1e, 0x9c, 0xfb, 0x79, 0x88, 0x96, 0x1a, 0xba, 0xe9, 0xc5,
	0x77, 0x64, 0x76, 0x2c, 0x7c, 0xc9, 0x15, 0x32, 0xb9, 0xb5, 0x5c, 0xa6, 0x22, 0xe5, 0x59, 0xa6,
	0x5e, 0x96, 0xa5, 0x55, 0x91, 0xe4, 0x89, 0xa3, 0x45, 0xe5, 0xb6, 0x54, 0xc8, 0x7d, 0x8a, 0x52,
	0x12, 0x49, 0x12, 0x70, 0xbc, 0x94, 0x97, 0x0a, 0x1a, 0xd9, 0x5e, 0xb5, 0x4a, 0x41, 0x2d, 0xc9,
	0x69, 0xc6, 0x65, 0x64, 0x2e, 0x01, 0x63, 0xec, 0x9e, 0x86, 0x1e, 0xb0, 0x17, 0x5b, 0x68, 0x08,
	0x42, 0xf2, 0x5b, 0xec, 0x08, 0xa0, 0x20, 0xbf, 0x25, 0x0a, 0x73, 0xef, 0x0a, 0x30, 0xd6, 0x75,
	0xe7, 0x40, 0xb6, 0x4d, 0xa5, 0x58, 0x29, 0xcb, 0x9a, 0x54, 0x2e, 0x2b, 0xc4, 0xe6, 0x8b, 0x24,
	0xe0, 0x9c, 0x86, 0x63, 0x81, 0x56, 0x29, 0xb3, 0x26, 0x2b, 0x65, 0x22, 0x74, 0x1a, 0xa7, 0x04,
	0x7a, 0x72, 0x05, 0xb5, 0x2c, 0xe5, 0x99, 0x53, 0x14, 0x43, 0xe8, 0x1c, 0x9c, 0xe9, 0xd3, 0xb9,
	0x52, 0x54, 0xee, 0x49, 0x0a, 0x15, 0x00, 0x65, 0x3f, 0x00, 0xb2, 0x2a, 0x2b, 0xb7, 0x65, 0x16,
	0xb4, 0x45, 0xe6, 0xbe, 0x24, 0xc0, 0x68, 0xf0, 0xe6, 0x87, 0xec, 0xb6, 0x05, 0xf9, 0x93, 0x65,
	0x2d, 0x5b, 0x2c, 0x69, 0x3c, 0x20, 0xd5, 0x6e, 0x4b, 0x65, 0xf9, 0x9e, 0x74, 0x5f, 0x1c, 0x20,
	0x9c, 0xf8, 0xbd, 0x15, 0x95, 0x98, 0x77, 0x61, 0x25, 0x77, 0xbb, 0x42, 0x62, 0x51, 0x01, 0xcd,
	0xc2, 0x8c, 0xdf, 0x59, 0x90, 0xcb, 0xf7, 0x8a, 0xca, 0x5d, 0x2d, 0x47, 0x8c, 0x67, 0x85, 0x2c,
	0xa6, 0x10, 0x9a, 0x01, 0xb1, 0x43, 0x3a, 0xa7, 0xa6, 0x25, 0x25, 0x23, 0x86, 0xd9, 0x6f, 0x21,
	0xa1, 0x73, 0x01, 0xc2, 0x6a, 0x41, 0x2a, 0x93, 0x98, 0x8c, 0x86, 0xf8, 0x69, 0x31, 0xc2, 0x40,
	0x52, 0xbf, 0x2c, 0xbc, 0xff, 0x9d, 0xd9, 0x81, 0x6f, 0x7e, 0x67, 0x76, 0xe0, 0x07, 0xdf, 0x99,
	0x15, 0x1e, 0x3d, 0x9f, 0x15, 0xbe, 0xf4, 0x7c, 0x56, 0xf8, 0xea, 0xf3, 0x59, 0xe1, 0xfd, 0xe7,
	0xb3, 0xc2, 0x37, 0x9f, 0xcf, 0x0a, 0xdf, 0x7e, 0x3e, 0x2b, 0x7c, 0xef, 0xf9, 0xec, 0xc0, 0x0f,
	0x9e, 0xcf, 0x0a, 0x9f, 0xfd, 0xee, 0xec, 0xc0, 0xd3, 0xef, 0xce, 0x0a, 0xef, 0x7f, 0x77, 0x76,
	0xe0, 0x9b, 0xdf, 0x9d, 0x1d, 0xf8, 0x54, 0x7a, 0xc3, 0x6a, 0x3d, 0xd8, 0xb8, 0xec, 0x7d, 0x43,
	0x71, 0xb9, 0xed, 0x5c, 0xa1, 0x0f, 0x75, 0xcb, 0x6e, 0x5e, 0xf2, 0x2a, 0x38, 0x2e, 0x79, 0xdd,
	0x57, 0x5a, 0xeb, 0x1b, 0xd6, 0x15, 0xbc, 0xe3, 0xf2, 0xff, 0xa7, 0x02, 0xfb, 0x67, 0x7d, 0x88,
	0x7e, 0x42, 0x7c, 0xed, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0xcf, 0xee, 0x65, 0x5d, 0x40, 0x62,
	0x00, 0x00,
}

func (x HttpMethod) String() string {
	s, ok := HttpMethod_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x HttpStatusCode) String() string {
	s, ok := HttpStatusCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x StatusPublishType) String() string {
	s, ok := StatusPublishType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SecretEncodingType) String() string {
	s, ok := SecretEncodingType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x URLSchemeType) String() string {
	s, ok := URLSchemeType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TlsProtocol) String() string {
	s, ok := TlsProtocol_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RoutingPriority) String() string {
	s, ok := RoutingPriority_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DenominatorType) String() string {
	s, ok := DenominatorType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DiscoveryType) String() string {
	s, ok := DiscoveryType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x WafModeType) String() string {
	s, ok := WafModeType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x VipVrrpType) String() string {
	s, ok := VipVrrpType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SiteToSiteTunnelType) String() string {
	s, ok := SiteToSiteTunnelType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SortOrder) String() string {
	s, ok := SortOrder_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TunnelEncapsulationType) String() string {
	s, ok := TunnelEncapsulationType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x AppFirewallViolationType) String() string {
	s, ok := AppFirewallViolationType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TenantType) String() string {
	s, ok := TenantType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TaxExemptionType) String() string {
	s, ok := TaxExemptionType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PlanType) String() string {
	s, ok := PlanType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MetricLabelOp) String() string {
	s, ok := MetricLabelOp_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RouteAttrType) String() string {
	s, ok := RouteAttrType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NextHopTypes) String() string {
	s, ok := NextHopTypes_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Empty) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Empty)
	if !ok {
		that2, ok := that.(Empty)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ObjectRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ObjectRefType)
	if !ok {
		that2, ok := that.(ObjectRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if this.Tenant != that1.Tenant {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *LabelSelectorType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LabelSelectorType)
	if !ok {
		that2, ok := that.(LabelSelectorType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Expressions) != len(that1.Expressions) {
		return false
	}
	for i := range this.Expressions {
		if this.Expressions[i] != that1.Expressions[i] {
			return false
		}
	}
	return true
}
func (this *LabelMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LabelMatcherType)
	if !ok {
		that2, ok := that.(LabelMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Keys) != len(that1.Keys) {
		return false
	}
	for i := range this.Keys {
		if this.Keys[i] != that1.Keys[i] {
			return false
		}
	}
	return true
}
func (this *ConditionType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConditionType)
	if !ok {
		that2, ok := that.(ConditionType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	if !this.LastUpdateTime.Equal(that1.LastUpdateTime) {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if this.ServiceName != that1.ServiceName {
		return false
	}
	return true
}
func (this *StatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StatusType)
	if !ok {
		that2, ok := that.(StatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	return true
}
func (this *InitializerType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InitializerType)
	if !ok {
		that2, ok := that.(InitializerType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *InitializersType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InitializersType)
	if !ok {
		that2, ok := that.(InitializersType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Pending) != len(that1.Pending) {
		return false
	}
	for i := range this.Pending {
		if !this.Pending[i].Equal(that1.Pending[i]) {
			return false
		}
	}
	if !this.Result.Equal(that1.Result) {
		return false
	}
	return true
}
func (this *StatusMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StatusMetaType)
	if !ok {
		that2, ok := that.(StatusMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if this.CreatorClass != that1.CreatorClass {
		return false
	}
	if this.CreatorId != that1.CreatorId {
		return false
	}
	if this.StatusId != that1.StatusId {
		return false
	}
	if !this.CreationTimestamp.Equal(that1.CreationTimestamp) {
		return false
	}
	if this.Publish != that1.Publish {
		return false
	}
	if this.VtrpId != that1.VtrpId {
		return false
	}
	return true
}
func (this *ObjectMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ObjectMetaType)
	if !ok {
		that2, ok := that.(ObjectMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Annotations) != len(that1.Annotations) {
		return false
	}
	for i := range this.Annotations {
		if this.Annotations[i] != that1.Annotations[i] {
			return false
		}
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Disable != that1.Disable {
		return false
	}
	return true
}
func (this *ListMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListMetaType)
	if !ok {
		that2, ok := that.(ListMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ResourceVersion != that1.ResourceVersion {
		return false
	}
	return true
}
func (this *ObjectGetMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ObjectGetMetaType)
	if !ok {
		that2, ok := that.(ObjectGetMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Annotations) != len(that1.Annotations) {
		return false
	}
	for i := range this.Annotations {
		if this.Annotations[i] != that1.Annotations[i] {
			return false
		}
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Disable != that1.Disable {
		return false
	}
	return true
}
func (this *ObjectCreateMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ObjectCreateMetaType)
	if !ok {
		that2, ok := that.(ObjectCreateMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Annotations) != len(that1.Annotations) {
		return false
	}
	for i := range this.Annotations {
		if this.Annotations[i] != that1.Annotations[i] {
			return false
		}
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Disable != that1.Disable {
		return false
	}
	return true
}
func (this *ObjectReplaceMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ObjectReplaceMetaType)
	if !ok {
		that2, ok := that.(ObjectReplaceMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	if len(this.Annotations) != len(that1.Annotations) {
		return false
	}
	for i := range this.Annotations {
		if this.Annotations[i] != that1.Annotations[i] {
			return false
		}
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Disable != that1.Disable {
		return false
	}
	return true
}
func (this *MessageMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MessageMetaType)
	if !ok {
		that2, ok := that.(MessageMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.Disable != that1.Disable {
		return false
	}
	return true
}
func (this *ViewRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ViewRefType)
	if !ok {
		that2, ok := that.(ViewRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *KubeRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*KubeRefType)
	if !ok {
		that2, ok := that.(KubeRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *SystemObjectMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SystemObjectMetaType)
	if !ok {
		that2, ok := that.(SystemObjectMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if !this.CreationTimestamp.Equal(that1.CreationTimestamp) {
		return false
	}
	if !this.DeletionTimestamp.Equal(that1.DeletionTimestamp) {
		return false
	}
	if !this.ModificationTimestamp.Equal(that1.ModificationTimestamp) {
		return false
	}
	if !this.Initializers.Equal(that1.Initializers) {
		return false
	}
	if len(this.Finalizers) != len(that1.Finalizers) {
		return false
	}
	for i := range this.Finalizers {
		if this.Finalizers[i] != that1.Finalizers[i] {
			return false
		}
	}
	if this.Tenant != that1.Tenant {
		return false
	}
	if this.CreatorClass != that1.CreatorClass {
		return false
	}
	if this.CreatorId != that1.CreatorId {
		return false
	}
	if this.CreatorCookie != that1.CreatorCookie {
		return false
	}
	if this.TraceInfo != that1.TraceInfo {
		return false
	}
	if this.ObjectIndex != that1.ObjectIndex {
		return false
	}
	if len(this.Namespace) != len(that1.Namespace) {
		return false
	}
	for i := range this.Namespace {
		if !this.Namespace[i].Equal(that1.Namespace[i]) {
			return false
		}
	}
	if !this.OwnerView.Equal(that1.OwnerView) {
		return false
	}
	if this.SreDisable != that1.SreDisable {
		return false
	}
	if this.VtrpId != that1.VtrpId {
		return false
	}
	return true
}
func (this *SystemObjectGetMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SystemObjectGetMetaType)
	if !ok {
		that2, ok := that.(SystemObjectGetMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if !this.CreationTimestamp.Equal(that1.CreationTimestamp) {
		return false
	}
	if !this.DeletionTimestamp.Equal(that1.DeletionTimestamp) {
		return false
	}
	if !this.ModificationTimestamp.Equal(that1.ModificationTimestamp) {
		return false
	}
	if !this.Initializers.Equal(that1.Initializers) {
		return false
	}
	if len(this.Finalizers) != len(that1.Finalizers) {
		return false
	}
	for i := range this.Finalizers {
		if this.Finalizers[i] != that1.Finalizers[i] {
			return false
		}
	}
	if this.Tenant != that1.Tenant {
		return false
	}
	if this.CreatorClass != that1.CreatorClass {
		return false
	}
	if this.CreatorId != that1.CreatorId {
		return false
	}
	if this.ObjectIndex != that1.ObjectIndex {
		return false
	}
	if !this.OwnerView.Equal(that1.OwnerView) {
		return false
	}
	return true
}
func (this *AuthnTypeBasicAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthnTypeBasicAuth)
	if !ok {
		that2, ok := that.(AuthnTypeBasicAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if !this.Password.Equal(that1.Password) {
		return false
	}
	return true
}
func (this *AuthnTypeHeaders) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthnTypeHeaders)
	if !ok {
		that2, ok := that.(AuthnTypeHeaders)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	return true
}
func (this *AuthnTypeQueryParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthnTypeQueryParams)
	if !ok {
		that2, ok := that.(AuthnTypeQueryParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.QueryParams) != len(that1.QueryParams) {
		return false
	}
	for i := range this.QueryParams {
		if !this.QueryParams[i].Equal(that1.QueryParams[i]) {
			return false
		}
	}
	return true
}
func (this *BlindfoldSecretInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BlindfoldSecretInfoType)
	if !ok {
		that2, ok := that.(BlindfoldSecretInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DecryptionProvider != that1.DecryptionProvider {
		return false
	}
	if this.StoreProvider != that1.StoreProvider {
		return false
	}
	if this.Location != that1.Location {
		return false
	}
	return true
}
func (this *VaultSecretInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultSecretInfoType)
	if !ok {
		that2, ok := that.(VaultSecretInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Provider != that1.Provider {
		return false
	}
	if this.Location != that1.Location {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.SecretEncoding != that1.SecretEncoding {
		return false
	}
	return true
}
func (this *ClearSecretInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClearSecretInfoType)
	if !ok {
		that2, ok := that.(ClearSecretInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Provider != that1.Provider {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	return true
}
func (this *WingmanSecretInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WingmanSecretInfoType)
	if !ok {
		that2, ok := that.(WingmanSecretInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *SecretType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecretType)
	if !ok {
		that2, ok := that.(SecretType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.SecretInfoOneof == nil {
		if this.SecretInfoOneof != nil {
			return false
		}
	} else if this.SecretInfoOneof == nil {
		return false
	} else if !this.SecretInfoOneof.Equal(that1.SecretInfoOneof) {
		return false
	}
	if !this.BlindfoldSecretInfoInternal.Equal(that1.BlindfoldSecretInfoInternal) {
		return false
	}
	if this.SecretEncodingType != that1.SecretEncodingType {
		return false
	}
	return true
}
func (this *SecretType_BlindfoldSecretInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecretType_BlindfoldSecretInfo)
	if !ok {
		that2, ok := that.(SecretType_BlindfoldSecretInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BlindfoldSecretInfo.Equal(that1.BlindfoldSecretInfo) {
		return false
	}
	return true
}
func (this *SecretType_VaultSecretInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecretType_VaultSecretInfo)
	if !ok {
		that2, ok := that.(SecretType_VaultSecretInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VaultSecretInfo.Equal(that1.VaultSecretInfo) {
		return false
	}
	return true
}
func (this *SecretType_ClearSecretInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecretType_ClearSecretInfo)
	if !ok {
		that2, ok := that.(SecretType_ClearSecretInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ClearSecretInfo.Equal(that1.ClearSecretInfo) {
		return false
	}
	return true
}
func (this *SecretType_WingmanSecretInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecretType_WingmanSecretInfo)
	if !ok {
		that2, ok := that.(SecretType_WingmanSecretInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.WingmanSecretInfo.Equal(that1.WingmanSecretInfo) {
		return false
	}
	return true
}
func (this *NetworkRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkRefType)
	if !ok {
		that2, ok := that.(NetworkRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ref) != len(that1.Ref) {
		return false
	}
	for i := range this.Ref {
		if !this.Ref[i].Equal(that1.Ref[i]) {
			return false
		}
	}
	return true
}
func (this *SiteRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteRefType)
	if !ok {
		that2, ok := that.(SiteRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ref) != len(that1.Ref) {
		return false
	}
	for i := range this.Ref {
		if !this.Ref[i].Equal(that1.Ref[i]) {
			return false
		}
	}
	if this.NetworkType != that1.NetworkType {
		return false
	}
	return true
}
func (this *IpPrefixSetRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpPrefixSetRefType)
	if !ok {
		that2, ok := that.(IpPrefixSetRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ref) != len(that1.Ref) {
		return false
	}
	for i := range this.Ref {
		if !this.Ref[i].Equal(that1.Ref[i]) {
			return false
		}
	}
	return true
}
func (this *VSiteRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VSiteRefType)
	if !ok {
		that2, ok := that.(VSiteRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ref) != len(that1.Ref) {
		return false
	}
	for i := range this.Ref {
		if !this.Ref[i].Equal(that1.Ref[i]) {
			return false
		}
	}
	if this.NetworkType != that1.NetworkType {
		return false
	}
	return true
}
func (this *PolicerRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PolicerRefType)
	if !ok {
		that2, ok := that.(PolicerRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ref) != len(that1.Ref) {
		return false
	}
	for i := range this.Ref {
		if !this.Ref[i].Equal(that1.Ref[i]) {
			return false
		}
	}
	return true
}
func (this *ProtocolPolicerRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProtocolPolicerRefType)
	if !ok {
		that2, ok := that.(ProtocolPolicerRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Ref) != len(that1.Ref) {
		return false
	}
	for i := range this.Ref {
		if !this.Ref[i].Equal(that1.Ref[i]) {
			return false
		}
	}
	return true
}
func (this *NetworkSiteRefSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkSiteRefSelector)
	if !ok {
		that2, ok := that.(NetworkSiteRefSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.RefOrSelector == nil {
		if this.RefOrSelector != nil {
			return false
		}
	} else if this.RefOrSelector == nil {
		return false
	} else if !this.RefOrSelector.Equal(that1.RefOrSelector) {
		return false
	}
	return true
}
func (this *NetworkSiteRefSelector_VirtualNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkSiteRefSelector_VirtualNetwork)
	if !ok {
		that2, ok := that.(NetworkSiteRefSelector_VirtualNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VirtualNetwork.Equal(that1.VirtualNetwork) {
		return false
	}
	return true
}
func (this *NetworkSiteRefSelector_Site) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkSiteRefSelector_Site)
	if !ok {
		that2, ok := that.(NetworkSiteRefSelector_Site)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Site.Equal(that1.Site) {
		return false
	}
	return true
}
func (this *NetworkSiteRefSelector_VirtualSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkSiteRefSelector_VirtualSite)
	if !ok {
		that2, ok := that.(NetworkSiteRefSelector_VirtualSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VirtualSite.Equal(that1.VirtualSite) {
		return false
	}
	return true
}
func (this *SiteVirtualSiteRefSelector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteVirtualSiteRefSelector)
	if !ok {
		that2, ok := that.(SiteVirtualSiteRefSelector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.RefOrSelector == nil {
		if this.RefOrSelector != nil {
			return false
		}
	} else if this.RefOrSelector == nil {
		return false
	} else if !this.RefOrSelector.Equal(that1.RefOrSelector) {
		return false
	}
	return true
}
func (this *SiteVirtualSiteRefSelector_Site) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteVirtualSiteRefSelector_Site)
	if !ok {
		that2, ok := that.(SiteVirtualSiteRefSelector_Site)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Site.Equal(that1.Site) {
		return false
	}
	return true
}
func (this *SiteVirtualSiteRefSelector_VirtualSite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteVirtualSiteRefSelector_VirtualSite)
	if !ok {
		that2, ok := that.(SiteVirtualSiteRefSelector_VirtualSite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VirtualSite.Equal(that1.VirtualSite) {
		return false
	}
	return true
}
func (this *HeaderManipulationOptionType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderManipulationOptionType)
	if !ok {
		that2, ok := that.(HeaderManipulationOptionType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Append != that1.Append {
		return false
	}
	return true
}
func (this *TlsValidationParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsValidationParamsType)
	if !ok {
		that2, ok := that.(TlsValidationParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TrustedCaUrl != that1.TrustedCaUrl {
		return false
	}
	if this.SkipHostnameVerification != that1.SkipHostnameVerification {
		return false
	}
	if len(this.VerifySubjectAltNames) != len(that1.VerifySubjectAltNames) {
		return false
	}
	for i := range this.VerifySubjectAltNames {
		if this.VerifySubjectAltNames[i] != that1.VerifySubjectAltNames[i] {
			return false
		}
	}
	if this.UseVolterraTrustedCaUrl != that1.UseVolterraTrustedCaUrl {
		return false
	}
	return true
}
func (this *TlsCertificateType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsCertificateType)
	if !ok {
		that2, ok := that.(TlsCertificateType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CertificateUrl != that1.CertificateUrl {
		return false
	}
	if !this.PrivateKey.Equal(that1.PrivateKey) {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	return true
}
func (this *TlsParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsParamsType)
	if !ok {
		that2, ok := that.(TlsParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MinimumProtocolVersion != that1.MinimumProtocolVersion {
		return false
	}
	if this.MaximumProtocolVersion != that1.MaximumProtocolVersion {
		return false
	}
	if len(this.CipherSuites) != len(that1.CipherSuites) {
		return false
	}
	for i := range this.CipherSuites {
		if this.CipherSuites[i] != that1.CipherSuites[i] {
			return false
		}
	}
	if len(this.TlsCertificates) != len(that1.TlsCertificates) {
		return false
	}
	for i := range this.TlsCertificates {
		if !this.TlsCertificates[i].Equal(that1.TlsCertificates[i]) {
			return false
		}
	}
	if this.TrustedCaUrl != that1.TrustedCaUrl {
		return false
	}
	if !this.ValidationParams.Equal(that1.ValidationParams) {
		return false
	}
	return true
}
func (this *UpstreamTlsParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpstreamTlsParamsType)
	if !ok {
		that2, ok := that.(UpstreamTlsParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CommonParams.Equal(that1.CommonParams) {
		return false
	}
	if that1.SniChoice == nil {
		if this.SniChoice != nil {
			return false
		}
	} else if this.SniChoice == nil {
		return false
	} else if !this.SniChoice.Equal(that1.SniChoice) {
		return false
	}
	return true
}
func (this *UpstreamTlsParamsType_Sni) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpstreamTlsParamsType_Sni)
	if !ok {
		that2, ok := that.(UpstreamTlsParamsType_Sni)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Sni != that1.Sni {
		return false
	}
	return true
}
func (this *UpstreamTlsParamsType_UseHostHeaderAsSni) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpstreamTlsParamsType_UseHostHeaderAsSni)
	if !ok {
		that2, ok := that.(UpstreamTlsParamsType_UseHostHeaderAsSni)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UseHostHeaderAsSni.Equal(that1.UseHostHeaderAsSni) {
		return false
	}
	return true
}
func (this *UpstreamTlsParamsType_DisableSni) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpstreamTlsParamsType_DisableSni)
	if !ok {
		that2, ok := that.(UpstreamTlsParamsType_DisableSni)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableSni.Equal(that1.DisableSni) {
		return false
	}
	return true
}
func (this *DownstreamTlsParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DownstreamTlsParamsType)
	if !ok {
		that2, ok := that.(DownstreamTlsParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CommonParams.Equal(that1.CommonParams) {
		return false
	}
	if this.RequireClientCertificate != that1.RequireClientCertificate {
		return false
	}
	return true
}
func (this *DomainType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DomainType)
	if !ok {
		that2, ok := that.(DomainType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.DomainChoice == nil {
		if this.DomainChoice != nil {
			return false
		}
	} else if this.DomainChoice == nil {
		return false
	} else if !this.DomainChoice.Equal(that1.DomainChoice) {
		return false
	}
	return true
}
func (this *DomainType_ExactValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DomainType_ExactValue)
	if !ok {
		that2, ok := that.(DomainType_ExactValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExactValue != that1.ExactValue {
		return false
	}
	return true
}
func (this *DomainType_SuffixValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DomainType_SuffixValue)
	if !ok {
		that2, ok := that.(DomainType_SuffixValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SuffixValue != that1.SuffixValue {
		return false
	}
	return true
}
func (this *DomainType_RegexValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DomainType_RegexValue)
	if !ok {
		that2, ok := that.(DomainType_RegexValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RegexValue != that1.RegexValue {
		return false
	}
	return true
}
func (this *L4DestType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*L4DestType)
	if !ok {
		that2, ok := that.(L4DestType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Prefixes) != len(that1.Prefixes) {
		return false
	}
	for i := range this.Prefixes {
		if this.Prefixes[i] != that1.Prefixes[i] {
			return false
		}
	}
	if this.PortRanges != that1.PortRanges {
		return false
	}
	return true
}
func (this *TlsInterceptionRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionRule)
	if !ok {
		that2, ok := that.(TlsInterceptionRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DomainMatch.Equal(that1.DomainMatch) {
		return false
	}
	if that1.EnableDisableChoice == nil {
		if this.EnableDisableChoice != nil {
			return false
		}
	} else if this.EnableDisableChoice == nil {
		return false
	} else if !this.EnableDisableChoice.Equal(that1.EnableDisableChoice) {
		return false
	}
	return true
}
func (this *TlsInterceptionRule_DisableInterception) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionRule_DisableInterception)
	if !ok {
		that2, ok := that.(TlsInterceptionRule_DisableInterception)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DisableInterception.Equal(that1.DisableInterception) {
		return false
	}
	return true
}
func (this *TlsInterceptionRule_EnableInterception) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionRule_EnableInterception)
	if !ok {
		that2, ok := that.(TlsInterceptionRule_EnableInterception)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableInterception.Equal(that1.EnableInterception) {
		return false
	}
	return true
}
func (this *TlsInterceptionPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionPolicy)
	if !ok {
		that2, ok := that.(TlsInterceptionPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.InterceptionRules) != len(that1.InterceptionRules) {
		return false
	}
	for i := range this.InterceptionRules {
		if !this.InterceptionRules[i].Equal(that1.InterceptionRules[i]) {
			return false
		}
	}
	return true
}
func (this *TlsInterceptionType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionType)
	if !ok {
		that2, ok := that.(TlsInterceptionType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.InterceptionPolicyChoice == nil {
		if this.InterceptionPolicyChoice != nil {
			return false
		}
	} else if this.InterceptionPolicyChoice == nil {
		return false
	} else if !this.InterceptionPolicyChoice.Equal(that1.InterceptionPolicyChoice) {
		return false
	}
	if that1.SigningCertChoice == nil {
		if this.SigningCertChoice != nil {
			return false
		}
	} else if this.SigningCertChoice == nil {
		return false
	} else if !this.SigningCertChoice.Equal(that1.SigningCertChoice) {
		return false
	}
	if that1.TrustedCaChoice == nil {
		if this.TrustedCaChoice != nil {
			return false
		}
	} else if this.TrustedCaChoice == nil {
		return false
	} else if !this.TrustedCaChoice.Equal(that1.TrustedCaChoice) {
		return false
	}
	return true
}
func (this *TlsInterceptionType_EnableForAllDomains) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionType_EnableForAllDomains)
	if !ok {
		that2, ok := that.(TlsInterceptionType_EnableForAllDomains)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnableForAllDomains.Equal(that1.EnableForAllDomains) {
		return false
	}
	return true
}
func (this *TlsInterceptionType_Policy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionType_Policy)
	if !ok {
		that2, ok := that.(TlsInterceptionType_Policy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Policy.Equal(that1.Policy) {
		return false
	}
	return true
}
func (this *TlsInterceptionType_CustomCertificate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionType_CustomCertificate)
	if !ok {
		that2, ok := that.(TlsInterceptionType_CustomCertificate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CustomCertificate.Equal(that1.CustomCertificate) {
		return false
	}
	return true
}
func (this *TlsInterceptionType_VolterraCertificate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionType_VolterraCertificate)
	if !ok {
		that2, ok := that.(TlsInterceptionType_VolterraCertificate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VolterraCertificate.Equal(that1.VolterraCertificate) {
		return false
	}
	return true
}
func (this *TlsInterceptionType_TrustedCaUrl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionType_TrustedCaUrl)
	if !ok {
		that2, ok := that.(TlsInterceptionType_TrustedCaUrl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TrustedCaUrl != that1.TrustedCaUrl {
		return false
	}
	return true
}
func (this *TlsInterceptionType_VolterraTrustedCa) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TlsInterceptionType_VolterraTrustedCa)
	if !ok {
		that2, ok := that.(TlsInterceptionType_VolterraTrustedCa)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VolterraTrustedCa.Equal(that1.VolterraTrustedCa) {
		return false
	}
	return true
}
func (this *FractionalPercent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FractionalPercent)
	if !ok {
		that2, ok := that.(FractionalPercent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Numerator != that1.Numerator {
		return false
	}
	if this.Denominator != that1.Denominator {
		return false
	}
	return true
}
func (this *BufferConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BufferConfigType)
	if !ok {
		that2, ok := that.(BufferConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Disabled != that1.Disabled {
		return false
	}
	if this.MaxRequestBytes != that1.MaxRequestBytes {
		return false
	}
	if this.MaxRequestTime != that1.MaxRequestTime {
		return false
	}
	return true
}
func (this *CorsPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CorsPolicy)
	if !ok {
		that2, ok := that.(CorsPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Disabled != that1.Disabled {
		return false
	}
	if len(this.AllowOrigin) != len(that1.AllowOrigin) {
		return false
	}
	for i := range this.AllowOrigin {
		if this.AllowOrigin[i] != that1.AllowOrigin[i] {
			return false
		}
	}
	if len(this.AllowOriginRegex) != len(that1.AllowOriginRegex) {
		return false
	}
	for i := range this.AllowOriginRegex {
		if this.AllowOriginRegex[i] != that1.AllowOriginRegex[i] {
			return false
		}
	}
	if this.AllowMethods != that1.AllowMethods {
		return false
	}
	if this.AllowHeaders != that1.AllowHeaders {
		return false
	}
	if this.ExposeHeaders != that1.ExposeHeaders {
		return false
	}
	if this.MaxAge != that1.MaxAge {
		return false
	}
	if this.MaximumAge != that1.MaximumAge {
		return false
	}
	if this.AllowCredentials != that1.AllowCredentials {
		return false
	}
	return true
}
func (this *PathMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PathMatcherType)
	if !ok {
		that2, ok := that.(PathMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PathMatch == nil {
		if this.PathMatch != nil {
			return false
		}
	} else if this.PathMatch == nil {
		return false
	} else if !this.PathMatch.Equal(that1.PathMatch) {
		return false
	}
	return true
}
func (this *PathMatcherType_Prefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PathMatcherType_Prefix)
	if !ok {
		that2, ok := that.(PathMatcherType_Prefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Prefix != that1.Prefix {
		return false
	}
	return true
}
func (this *PathMatcherType_Path) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PathMatcherType_Path)
	if !ok {
		that2, ok := that.(PathMatcherType_Path)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	return true
}
func (this *PathMatcherType_Regex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PathMatcherType_Regex)
	if !ok {
		that2, ok := that.(PathMatcherType_Regex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Regex != that1.Regex {
		return false
	}
	return true
}
func (this *HeaderMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType)
	if !ok {
		that2, ok := that.(HeaderMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if that1.ValueMatch == nil {
		if this.ValueMatch != nil {
			return false
		}
	} else if this.ValueMatch == nil {
		return false
	} else if !this.ValueMatch.Equal(that1.ValueMatch) {
		return false
	}
	if this.InvertMatch != that1.InvertMatch {
		return false
	}
	return true
}
func (this *HeaderMatcherType_Exact) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType_Exact)
	if !ok {
		that2, ok := that.(HeaderMatcherType_Exact)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Exact != that1.Exact {
		return false
	}
	return true
}
func (this *HeaderMatcherType_Regex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType_Regex)
	if !ok {
		that2, ok := that.(HeaderMatcherType_Regex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Regex != that1.Regex {
		return false
	}
	return true
}
func (this *HeaderMatcherType_Presence) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcherType_Presence)
	if !ok {
		that2, ok := that.(HeaderMatcherType_Presence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Presence != that1.Presence {
		return false
	}
	return true
}
func (this *QueryParameterMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcherType)
	if !ok {
		that2, ok := that.(QueryParameterMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if that1.ValueMatch == nil {
		if this.ValueMatch != nil {
			return false
		}
	} else if this.ValueMatch == nil {
		return false
	} else if !this.ValueMatch.Equal(that1.ValueMatch) {
		return false
	}
	return true
}
func (this *QueryParameterMatcherType_Exact) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcherType_Exact)
	if !ok {
		that2, ok := that.(QueryParameterMatcherType_Exact)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Exact != that1.Exact {
		return false
	}
	return true
}
func (this *QueryParameterMatcherType_Regex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcherType_Regex)
	if !ok {
		that2, ok := that.(QueryParameterMatcherType_Regex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Regex != that1.Regex {
		return false
	}
	return true
}
func (this *RouteMatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteMatch)
	if !ok {
		that2, ok := that.(RouteMatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Path.Equal(that1.Path) {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if len(this.QueryParams) != len(that1.QueryParams) {
		return false
	}
	for i := range this.QueryParams {
		if !this.QueryParams[i].Equal(that1.QueryParams[i]) {
			return false
		}
	}
	if this.HttpMethod != that1.HttpMethod {
		return false
	}
	return true
}
func (this *WafRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafRefType)
	if !ok {
		that2, ok := that.(WafRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Waf) != len(that1.Waf) {
		return false
	}
	for i := range this.Waf {
		if !this.Waf[i].Equal(that1.Waf[i]) {
			return false
		}
	}
	return true
}
func (this *WafRulesRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafRulesRefType)
	if !ok {
		that2, ok := that.(WafRulesRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.WafRules) != len(that1.WafRules) {
		return false
	}
	for i := range this.WafRules {
		if !this.WafRules[i].Equal(that1.WafRules[i]) {
			return false
		}
	}
	return true
}
func (this *AppFirewallRefType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AppFirewallRefType)
	if !ok {
		that2, ok := that.(AppFirewallRefType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.AppFirewall) != len(that1.AppFirewall) {
		return false
	}
	for i := range this.AppFirewall {
		if !this.AppFirewall[i].Equal(that1.AppFirewall[i]) {
			return false
		}
	}
	return true
}
func (this *WafType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafType)
	if !ok {
		that2, ok := that.(WafType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.RefType == nil {
		if this.RefType != nil {
			return false
		}
	} else if this.RefType == nil {
		return false
	} else if !this.RefType.Equal(that1.RefType) {
		return false
	}
	return true
}
func (this *WafType_Waf) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafType_Waf)
	if !ok {
		that2, ok := that.(WafType_Waf)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Waf.Equal(that1.Waf) {
		return false
	}
	return true
}
func (this *WafType_WafRules) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafType_WafRules)
	if !ok {
		that2, ok := that.(WafType_WafRules)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.WafRules.Equal(that1.WafRules) {
		return false
	}
	return true
}
func (this *WafType_AppFirewall) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WafType_AppFirewall)
	if !ok {
		that2, ok := that.(WafType_AppFirewall)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AppFirewall.Equal(that1.AppFirewall) {
		return false
	}
	return true
}
func (this *AppRoleAuthInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AppRoleAuthInfoType)
	if !ok {
		that2, ok := that.(AppRoleAuthInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RoleId != that1.RoleId {
		return false
	}
	if !this.SecretId.Equal(that1.SecretId) {
		return false
	}
	return true
}
func (this *VaultAuthInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultAuthInfoType)
	if !ok {
		that2, ok := that.(VaultAuthInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AuthParams == nil {
		if this.AuthParams != nil {
			return false
		}
	} else if this.AuthParams == nil {
		return false
	} else if !this.AuthParams.Equal(that1.AuthParams) {
		return false
	}
	return true
}
func (this *VaultAuthInfoType_AppRoleAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultAuthInfoType_AppRoleAuth)
	if !ok {
		that2, ok := that.(VaultAuthInfoType_AppRoleAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AppRoleAuth.Equal(that1.AppRoleAuth) {
		return false
	}
	return true
}
func (this *VaultAuthInfoType_Token) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultAuthInfoType_Token)
	if !ok {
		that2, ok := that.(VaultAuthInfoType_Token)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Token.Equal(that1.Token) {
		return false
	}
	return true
}
func (this *RestAuthInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RestAuthInfoType)
	if !ok {
		that2, ok := that.(RestAuthInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AuthParams == nil {
		if this.AuthParams != nil {
			return false
		}
	} else if this.AuthParams == nil {
		return false
	} else if !this.AuthParams.Equal(that1.AuthParams) {
		return false
	}
	return true
}
func (this *RestAuthInfoType_BasicAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RestAuthInfoType_BasicAuth)
	if !ok {
		that2, ok := that.(RestAuthInfoType_BasicAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BasicAuth.Equal(that1.BasicAuth) {
		return false
	}
	return true
}
func (this *RestAuthInfoType_HeadersAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RestAuthInfoType_HeadersAuth)
	if !ok {
		that2, ok := that.(RestAuthInfoType_HeadersAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HeadersAuth.Equal(that1.HeadersAuth) {
		return false
	}
	return true
}
func (this *RestAuthInfoType_QueryParamsAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RestAuthInfoType_QueryParamsAuth)
	if !ok {
		that2, ok := that.(RestAuthInfoType_QueryParamsAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.QueryParamsAuth.Equal(that1.QueryParamsAuth) {
		return false
	}
	return true
}
func (this *HostAccessInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HostAccessInfoType)
	if !ok {
		that2, ok := that.(HostAccessInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Scheme != that1.Scheme {
		return false
	}
	if this.ServerEndpoint != that1.ServerEndpoint {
		return false
	}
	if !this.TlsConfig.Equal(that1.TlsConfig) {
		return false
	}
	if that1.AuthParams == nil {
		if this.AuthParams != nil {
			return false
		}
	} else if this.AuthParams == nil {
		return false
	} else if !this.AuthParams.Equal(that1.AuthParams) {
		return false
	}
	return true
}
func (this *HostAccessInfoType_RestAuthInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HostAccessInfoType_RestAuthInfo)
	if !ok {
		that2, ok := that.(HostAccessInfoType_RestAuthInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RestAuthInfo.Equal(that1.RestAuthInfo) {
		return false
	}
	return true
}
func (this *HostAccessInfoType_VaultAuthInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HostAccessInfoType_VaultAuthInfo)
	if !ok {
		that2, ok := that.(HostAccessInfoType_VaultAuthInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VaultAuthInfo.Equal(that1.VaultAuthInfo) {
		return false
	}
	return true
}
func (this *VaultAccessInfoType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultAccessInfoType)
	if !ok {
		that2, ok := that.(VaultAccessInfoType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VaultAddr != that1.VaultAddr {
		return false
	}
	if this.VaultCaUrl != that1.VaultCaUrl {
		return false
	}
	if that1.AuthnChoice == nil {
		if this.AuthnChoice != nil {
			return false
		}
	} else if this.AuthnChoice == nil {
		return false
	} else if !this.AuthnChoice.Equal(that1.AuthnChoice) {
		return false
	}
	return true
}
func (this *VaultAccessInfoType_AppRoleAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultAccessInfoType_AppRoleAuth)
	if !ok {
		that2, ok := that.(VaultAccessInfoType_AppRoleAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AppRoleAuth.Equal(that1.AppRoleAuth) {
		return false
	}
	return true
}
func (this *VaultAccessInfoType_Token) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultAccessInfoType_Token)
	if !ok {
		that2, ok := that.(VaultAccessInfoType_Token)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Token.Equal(that1.Token) {
		return false
	}
	return true
}
func (this *VaultSecretType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultSecretType)
	if !ok {
		that2, ok := that.(VaultSecretType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.AccessChoice == nil {
		if this.AccessChoice != nil {
			return false
		}
	} else if this.AccessChoice == nil {
		return false
	} else if !this.AccessChoice.Equal(that1.AccessChoice) {
		return false
	}
	if this.SecretPath != that1.SecretPath {
		return false
	}
	if this.SecretSubPath != that1.SecretSubPath {
		return false
	}
	if this.SecretVersion != that1.SecretVersion {
		return false
	}
	return true
}
func (this *VaultSecretType_VaultAccessInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultSecretType_VaultAccessInfo)
	if !ok {
		that2, ok := that.(VaultSecretType_VaultAccessInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VaultAccessInfo.Equal(that1.VaultAccessInfo) {
		return false
	}
	return true
}
func (this *VaultSecretType_ProviderName) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VaultSecretType_ProviderName)
	if !ok {
		that2, ok := that.(VaultSecretType_ProviderName)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProviderName != that1.ProviderName {
		return false
	}
	return true
}
func (this *VolterraSecretType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VolterraSecretType)
	if !ok {
		that2, ok := that.(VolterraSecretType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.SecretTypeChoice == nil {
		if this.SecretTypeChoice != nil {
			return false
		}
	} else if this.SecretTypeChoice == nil {
		return false
	} else if !this.SecretTypeChoice.Equal(that1.SecretTypeChoice) {
		return false
	}
	return true
}
func (this *VolterraSecretType_BlindfoldSecretInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VolterraSecretType_BlindfoldSecretInfo)
	if !ok {
		that2, ok := that.(VolterraSecretType_BlindfoldSecretInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BlindfoldSecretInfo.Equal(that1.BlindfoldSecretInfo) {
		return false
	}
	return true
}
func (this *VolterraSecretType_VaultSecretInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VolterraSecretType_VaultSecretInfo)
	if !ok {
		that2, ok := that.(VolterraSecretType_VaultSecretInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VaultSecretInfo.Equal(that1.VaultSecretInfo) {
		return false
	}
	return true
}
func (this *PortValueType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortValueType)
	if !ok {
		that2, ok := that.(PortValueType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PortValueTypeChoice == nil {
		if this.PortValueTypeChoice != nil {
			return false
		}
	} else if this.PortValueTypeChoice == nil {
		return false
	} else if !this.PortValueTypeChoice.Equal(that1.PortValueTypeChoice) {
		return false
	}
	return true
}
func (this *PortValueType_All) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortValueType_All)
	if !ok {
		that2, ok := that.(PortValueType_All)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.All.Equal(that1.All) {
		return false
	}
	return true
}
func (this *PortValueType_UserDefined) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortValueType_UserDefined)
	if !ok {
		that2, ok := that.(PortValueType_UserDefined)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserDefined != that1.UserDefined {
		return false
	}
	return true
}
func (this *PortValueType_Dns) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortValueType_Dns)
	if !ok {
		that2, ok := that.(PortValueType_Dns)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Dns.Equal(that1.Dns) {
		return false
	}
	return true
}
func (this *VirtualNetworkReferenceType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualNetworkReferenceType)
	if !ok {
		that2, ok := that.(VirtualNetworkReferenceType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Refs) != len(that1.Refs) {
		return false
	}
	for i := range this.Refs {
		if !this.Refs[i].Equal(that1.Refs[i]) {
			return false
		}
	}
	return true
}
func (this *VirtualNetworkSelectorType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualNetworkSelectorType)
	if !ok {
		that2, ok := that.(VirtualNetworkSelectorType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.VnTypeChoice == nil {
		if this.VnTypeChoice != nil {
			return false
		}
	} else if this.VnTypeChoice == nil {
		return false
	} else if !this.VnTypeChoice.Equal(that1.VnTypeChoice) {
		return false
	}
	return true
}
func (this *VirtualNetworkSelectorType_SiteLocal) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualNetworkSelectorType_SiteLocal)
	if !ok {
		that2, ok := that.(VirtualNetworkSelectorType_SiteLocal)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteLocal.Equal(that1.SiteLocal) {
		return false
	}
	return true
}
func (this *VirtualNetworkSelectorType_SiteLocalInside) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualNetworkSelectorType_SiteLocalInside)
	if !ok {
		that2, ok := that.(VirtualNetworkSelectorType_SiteLocalInside)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteLocalInside.Equal(that1.SiteLocalInside) {
		return false
	}
	return true
}
func (this *VirtualNetworkSelectorType_Public) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualNetworkSelectorType_Public)
	if !ok {
		that2, ok := that.(VirtualNetworkSelectorType_Public)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Public.Equal(that1.Public) {
		return false
	}
	return true
}
func (this *RetryBackOff) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RetryBackOff)
	if !ok {
		that2, ok := that.(RetryBackOff)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BaseInterval != that1.BaseInterval {
		return false
	}
	if this.MaxInterval != that1.MaxInterval {
		return false
	}
	return true
}
func (this *RetryPolicyType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RetryPolicyType)
	if !ok {
		that2, ok := that.(RetryPolicyType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RetryOn != that1.RetryOn {
		return false
	}
	if len(this.RetryCondition) != len(that1.RetryCondition) {
		return false
	}
	for i := range this.RetryCondition {
		if this.RetryCondition[i] != that1.RetryCondition[i] {
			return false
		}
	}
	if this.NumRetries != that1.NumRetries {
		return false
	}
	if this.PerTryTimeout != that1.PerTryTimeout {
		return false
	}
	if len(this.RetriableStatusCodes) != len(that1.RetriableStatusCodes) {
		return false
	}
	for i := range this.RetriableStatusCodes {
		if this.RetriableStatusCodes[i] != that1.RetriableStatusCodes[i] {
			return false
		}
	}
	if !this.BackOff.Equal(that1.BackOff) {
		return false
	}
	return true
}
func (this *MetricValue) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetricValue)
	if !ok {
		that2, ok := that.(MetricValue)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *NextHopType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NextHopType)
	if !ok {
		that2, ok := that.(NextHopType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.NexthopAddress.Equal(that1.NexthopAddress) {
		return false
	}
	if len(this.Interface) != len(that1.Interface) {
		return false
	}
	for i := range this.Interface {
		if !this.Interface[i].Equal(that1.Interface[i]) {
			return false
		}
	}
	return true
}
func (this *StaticRouteType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StaticRouteType)
	if !ok {
		that2, ok := that.(StaticRouteType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Attrs) != len(that1.Attrs) {
		return false
	}
	for i := range this.Attrs {
		if this.Attrs[i] != that1.Attrs[i] {
			return false
		}
	}
	if len(this.Subnets) != len(that1.Subnets) {
		return false
	}
	for i := range this.Subnets {
		if !this.Subnets[i].Equal(that1.Subnets[i]) {
			return false
		}
	}
	if !this.Nexthop.Equal(that1.Nexthop) {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if this.Labels[i] != that1.Labels[i] {
			return false
		}
	}
	return true
}
func (this *ForwardProxyConfigType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ForwardProxyConfigType)
	if !ok {
		that2, ok := that.(ForwardProxyConfigType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.WhiteListedPrefixes) != len(that1.WhiteListedPrefixes) {
		return false
	}
	for i := range this.WhiteListedPrefixes {
		if this.WhiteListedPrefixes[i] != that1.WhiteListedPrefixes[i] {
			return false
		}
	}
	if len(this.WhiteListedPorts) != len(that1.WhiteListedPorts) {
		return false
	}
	for i := range this.WhiteListedPorts {
		if this.WhiteListedPorts[i] != that1.WhiteListedPorts[i] {
			return false
		}
	}
	if this.MaxConnectAttempts != that1.MaxConnectAttempts {
		return false
	}
	if this.ConnectionTimeout != that1.ConnectionTimeout {
		return false
	}
	if that1.TlsInterceptionChoice == nil {
		if this.TlsInterceptionChoice != nil {
			return false
		}
	} else if this.TlsInterceptionChoice == nil {
		return false
	} else if !this.TlsInterceptionChoice.Equal(that1.TlsInterceptionChoice) {
		return false
	}
	return true
}
func (this *ForwardProxyConfigType_NoInterception) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ForwardProxyConfigType_NoInterception)
	if !ok {
		that2, ok := that.(ForwardProxyConfigType_NoInterception)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoInterception.Equal(that1.NoInterception) {
		return false
	}
	return true
}
func (this *ForwardProxyConfigType_TlsIntercept) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ForwardProxyConfigType_TlsIntercept)
	if !ok {
		that2, ok := that.(ForwardProxyConfigType_TlsIntercept)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TlsIntercept.Equal(that1.TlsIntercept) {
		return false
	}
	return true
}
func (this *HostIdentifier) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HostIdentifier)
	if !ok {
		that2, ok := that.(HostIdentifier)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.HostnameOrIp == nil {
		if this.HostnameOrIp != nil {
			return false
		}
	} else if this.HostnameOrIp == nil {
		return false
	} else if !this.HostnameOrIp.Equal(that1.HostnameOrIp) {
		return false
	}
	return true
}
func (this *HostIdentifier_Ip) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HostIdentifier_Ip)
	if !ok {
		that2, ok := that.(HostIdentifier_Ip)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Ip != that1.Ip {
		return false
	}
	return true
}
func (this *HostIdentifier_Hostname) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HostIdentifier_Hostname)
	if !ok {
		that2, ok := that.(HostIdentifier_Hostname)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	return true
}
func (this *InterfaceIdentifier) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceIdentifier)
	if !ok {
		that2, ok := that.(InterfaceIdentifier)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.InterfaceChoice == nil {
		if this.InterfaceChoice != nil {
			return false
		}
	} else if this.InterfaceChoice == nil {
		return false
	} else if !this.InterfaceChoice.Equal(that1.InterfaceChoice) {
		return false
	}
	return true
}
func (this *InterfaceIdentifier_AnyIntf) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceIdentifier_AnyIntf)
	if !ok {
		that2, ok := that.(InterfaceIdentifier_AnyIntf)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AnyIntf.Equal(that1.AnyIntf) {
		return false
	}
	return true
}
func (this *InterfaceIdentifier_Intf) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceIdentifier_Intf)
	if !ok {
		that2, ok := that.(InterfaceIdentifier_Intf)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Intf != that1.Intf {
		return false
	}
	return true
}
func (this *InterfaceOrNetwork) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceOrNetwork)
	if !ok {
		that2, ok := that.(InterfaceOrNetwork)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.InterfaceChoice == nil {
		if this.InterfaceChoice != nil {
			return false
		}
	} else if this.InterfaceChoice == nil {
		return false
	} else if !this.InterfaceChoice.Equal(that1.InterfaceChoice) {
		return false
	}
	return true
}
func (this *InterfaceOrNetwork_Intf) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceOrNetwork_Intf)
	if !ok {
		that2, ok := that.(InterfaceOrNetwork_Intf)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Intf != that1.Intf {
		return false
	}
	return true
}
func (this *InterfaceOrNetwork_Pod) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceOrNetwork_Pod)
	if !ok {
		that2, ok := that.(InterfaceOrNetwork_Pod)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Pod != that1.Pod {
		return false
	}
	return true
}
func (this *InterfaceOrNetwork_VnType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceOrNetwork_VnType)
	if !ok {
		that2, ok := that.(InterfaceOrNetwork_VnType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VnType != that1.VnType {
		return false
	}
	return true
}
func (this *InterfaceOrNetwork_Vn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceOrNetwork_Vn)
	if !ok {
		that2, ok := that.(InterfaceOrNetwork_Vn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Vn != that1.Vn {
		return false
	}
	return true
}
func (this *RouteTarget2ByteAsn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteTarget2ByteAsn)
	if !ok {
		that2, ok := that.(RouteTarget2ByteAsn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AsNumber != that1.AsNumber {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *RouteTarget4ByteAsn) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteTarget4ByteAsn)
	if !ok {
		that2, ok := that.(RouteTarget4ByteAsn)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AsNumber != that1.AsNumber {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *RouteTargetIPv4Addr) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteTargetIPv4Addr)
	if !ok {
		that2, ok := that.(RouteTargetIPv4Addr)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *RouteTarget) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteTarget)
	if !ok {
		that2, ok := that.(RouteTarget)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.RtargetChoice == nil {
		if this.RtargetChoice != nil {
			return false
		}
	} else if this.RtargetChoice == nil {
		return false
	} else if !this.RtargetChoice.Equal(that1.RtargetChoice) {
		return false
	}
	return true
}
func (this *RouteTarget_Asn2ByteRtarget) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteTarget_Asn2ByteRtarget)
	if !ok {
		that2, ok := that.(RouteTarget_Asn2ByteRtarget)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Asn2ByteRtarget.Equal(that1.Asn2ByteRtarget) {
		return false
	}
	return true
}
func (this *RouteTarget_Ipv4AddrRtarget) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteTarget_Ipv4AddrRtarget)
	if !ok {
		that2, ok := that.(RouteTarget_Ipv4AddrRtarget)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ipv4AddrRtarget.Equal(that1.Ipv4AddrRtarget) {
		return false
	}
	return true
}
func (this *RouteTarget_Asn4ByteRtarget) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteTarget_Asn4ByteRtarget)
	if !ok {
		that2, ok := that.(RouteTarget_Asn4ByteRtarget)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Asn4ByteRtarget.Equal(that1.Asn4ByteRtarget) {
		return false
	}
	return true
}
func (this *Empty) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&schema.Empty{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ObjectRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.ObjectRefType{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	s = append(s, "Tenant: "+fmt.Sprintf("%#v", this.Tenant)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LabelSelectorType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.LabelSelectorType{")
	s = append(s, "Expressions: "+fmt.Sprintf("%#v", this.Expressions)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LabelMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.LabelMatcherType{")
	s = append(s, "Keys: "+fmt.Sprintf("%#v", this.Keys)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConditionType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.ConditionType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Reason: "+fmt.Sprintf("%#v", this.Reason)+",\n")
	if this.LastUpdateTime != nil {
		s = append(s, "LastUpdateTime: "+fmt.Sprintf("%#v", this.LastUpdateTime)+",\n")
	}
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	s = append(s, "ServiceName: "+fmt.Sprintf("%#v", this.ServiceName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.StatusType{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Reason: "+fmt.Sprintf("%#v", this.Reason)+",\n")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InitializerType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.InitializerType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InitializersType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.InitializersType{")
	if this.Pending != nil {
		s = append(s, "Pending: "+fmt.Sprintf("%#v", this.Pending)+",\n")
	}
	if this.Result != nil {
		s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StatusMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&schema.StatusMetaType{")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	s = append(s, "CreatorClass: "+fmt.Sprintf("%#v", this.CreatorClass)+",\n")
	s = append(s, "CreatorId: "+fmt.Sprintf("%#v", this.CreatorId)+",\n")
	s = append(s, "StatusId: "+fmt.Sprintf("%#v", this.StatusId)+",\n")
	if this.CreationTimestamp != nil {
		s = append(s, "CreationTimestamp: "+fmt.Sprintf("%#v", this.CreationTimestamp)+",\n")
	}
	s = append(s, "Publish: "+fmt.Sprintf("%#v", this.Publish)+",\n")
	s = append(s, "VtrpId: "+fmt.Sprintf("%#v", this.VtrpId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ObjectMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&schema.ObjectMetaType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%#v: %#v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	if this.Annotations != nil {
		s = append(s, "Annotations: "+mapStringForAnnotations+",\n")
	}
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Disable: "+fmt.Sprintf("%#v", this.Disable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.ListMetaType{")
	s = append(s, "ResourceVersion: "+fmt.Sprintf("%#v", this.ResourceVersion)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ObjectGetMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.ObjectGetMetaType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%#v: %#v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	if this.Annotations != nil {
		s = append(s, "Annotations: "+mapStringForAnnotations+",\n")
	}
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Disable: "+fmt.Sprintf("%#v", this.Disable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ObjectCreateMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.ObjectCreateMetaType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%#v: %#v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	if this.Annotations != nil {
		s = append(s, "Annotations: "+mapStringForAnnotations+",\n")
	}
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Disable: "+fmt.Sprintf("%#v", this.Disable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ObjectReplaceMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.ObjectReplaceMetaType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%#v: %#v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	if this.Annotations != nil {
		s = append(s, "Annotations: "+mapStringForAnnotations+",\n")
	}
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Disable: "+fmt.Sprintf("%#v", this.Disable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MessageMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.MessageMetaType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "Disable: "+fmt.Sprintf("%#v", this.Disable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ViewRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.ViewRefType{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *KubeRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.KubeRefType{")
	s = append(s, "Kind: "+fmt.Sprintf("%#v", this.Kind)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SystemObjectMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 20)
	s = append(s, "&schema.SystemObjectMetaType{")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	if this.CreationTimestamp != nil {
		s = append(s, "CreationTimestamp: "+fmt.Sprintf("%#v", this.CreationTimestamp)+",\n")
	}
	if this.DeletionTimestamp != nil {
		s = append(s, "DeletionTimestamp: "+fmt.Sprintf("%#v", this.DeletionTimestamp)+",\n")
	}
	if this.ModificationTimestamp != nil {
		s = append(s, "ModificationTimestamp: "+fmt.Sprintf("%#v", this.ModificationTimestamp)+",\n")
	}
	if this.Initializers != nil {
		s = append(s, "Initializers: "+fmt.Sprintf("%#v", this.Initializers)+",\n")
	}
	s = append(s, "Finalizers: "+fmt.Sprintf("%#v", this.Finalizers)+",\n")
	s = append(s, "Tenant: "+fmt.Sprintf("%#v", this.Tenant)+",\n")
	s = append(s, "CreatorClass: "+fmt.Sprintf("%#v", this.CreatorClass)+",\n")
	s = append(s, "CreatorId: "+fmt.Sprintf("%#v", this.CreatorId)+",\n")
	s = append(s, "CreatorCookie: "+fmt.Sprintf("%#v", this.CreatorCookie)+",\n")
	s = append(s, "TraceInfo: "+fmt.Sprintf("%#v", this.TraceInfo)+",\n")
	s = append(s, "ObjectIndex: "+fmt.Sprintf("%#v", this.ObjectIndex)+",\n")
	if this.Namespace != nil {
		s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	}
	if this.OwnerView != nil {
		s = append(s, "OwnerView: "+fmt.Sprintf("%#v", this.OwnerView)+",\n")
	}
	s = append(s, "SreDisable: "+fmt.Sprintf("%#v", this.SreDisable)+",\n")
	s = append(s, "VtrpId: "+fmt.Sprintf("%#v", this.VtrpId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SystemObjectGetMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&schema.SystemObjectGetMetaType{")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	if this.CreationTimestamp != nil {
		s = append(s, "CreationTimestamp: "+fmt.Sprintf("%#v", this.CreationTimestamp)+",\n")
	}
	if this.DeletionTimestamp != nil {
		s = append(s, "DeletionTimestamp: "+fmt.Sprintf("%#v", this.DeletionTimestamp)+",\n")
	}
	if this.ModificationTimestamp != nil {
		s = append(s, "ModificationTimestamp: "+fmt.Sprintf("%#v", this.ModificationTimestamp)+",\n")
	}
	if this.Initializers != nil {
		s = append(s, "Initializers: "+fmt.Sprintf("%#v", this.Initializers)+",\n")
	}
	s = append(s, "Finalizers: "+fmt.Sprintf("%#v", this.Finalizers)+",\n")
	s = append(s, "Tenant: "+fmt.Sprintf("%#v", this.Tenant)+",\n")
	s = append(s, "CreatorClass: "+fmt.Sprintf("%#v", this.CreatorClass)+",\n")
	s = append(s, "CreatorId: "+fmt.Sprintf("%#v", this.CreatorId)+",\n")
	s = append(s, "ObjectIndex: "+fmt.Sprintf("%#v", this.ObjectIndex)+",\n")
	if this.OwnerView != nil {
		s = append(s, "OwnerView: "+fmt.Sprintf("%#v", this.OwnerView)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthnTypeBasicAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.AuthnTypeBasicAuth{")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	if this.Password != nil {
		s = append(s, "Password: "+fmt.Sprintf("%#v", this.Password)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthnTypeHeaders) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.AuthnTypeHeaders{")
	keysForHeaders := make([]string, 0, len(this.Headers))
	for k, _ := range this.Headers {
		keysForHeaders = append(keysForHeaders, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHeaders)
	mapStringForHeaders := "map[string]*SecretType{"
	for _, k := range keysForHeaders {
		mapStringForHeaders += fmt.Sprintf("%#v: %#v,", k, this.Headers[k])
	}
	mapStringForHeaders += "}"
	if this.Headers != nil {
		s = append(s, "Headers: "+mapStringForHeaders+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthnTypeQueryParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.AuthnTypeQueryParams{")
	keysForQueryParams := make([]string, 0, len(this.QueryParams))
	for k, _ := range this.QueryParams {
		keysForQueryParams = append(keysForQueryParams, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForQueryParams)
	mapStringForQueryParams := "map[string]*SecretType{"
	for _, k := range keysForQueryParams {
		mapStringForQueryParams += fmt.Sprintf("%#v: %#v,", k, this.QueryParams[k])
	}
	mapStringForQueryParams += "}"
	if this.QueryParams != nil {
		s = append(s, "QueryParams: "+mapStringForQueryParams+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BlindfoldSecretInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.BlindfoldSecretInfoType{")
	s = append(s, "DecryptionProvider: "+fmt.Sprintf("%#v", this.DecryptionProvider)+",\n")
	s = append(s, "StoreProvider: "+fmt.Sprintf("%#v", this.StoreProvider)+",\n")
	s = append(s, "Location: "+fmt.Sprintf("%#v", this.Location)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VaultSecretInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.VaultSecretInfoType{")
	s = append(s, "Provider: "+fmt.Sprintf("%#v", this.Provider)+",\n")
	s = append(s, "Location: "+fmt.Sprintf("%#v", this.Location)+",\n")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "SecretEncoding: "+fmt.Sprintf("%#v", this.SecretEncoding)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ClearSecretInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.ClearSecretInfoType{")
	s = append(s, "Provider: "+fmt.Sprintf("%#v", this.Provider)+",\n")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WingmanSecretInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.WingmanSecretInfoType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.NetworkRefType{")
	if this.Ref != nil {
		s = append(s, "Ref: "+fmt.Sprintf("%#v", this.Ref)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.SiteRefType{")
	if this.Ref != nil {
		s = append(s, "Ref: "+fmt.Sprintf("%#v", this.Ref)+",\n")
	}
	s = append(s, "NetworkType: "+fmt.Sprintf("%#v", this.NetworkType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IpPrefixSetRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.IpPrefixSetRefType{")
	if this.Ref != nil {
		s = append(s, "Ref: "+fmt.Sprintf("%#v", this.Ref)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VSiteRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.VSiteRefType{")
	if this.Ref != nil {
		s = append(s, "Ref: "+fmt.Sprintf("%#v", this.Ref)+",\n")
	}
	s = append(s, "NetworkType: "+fmt.Sprintf("%#v", this.NetworkType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PolicerRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.PolicerRefType{")
	if this.Ref != nil {
		s = append(s, "Ref: "+fmt.Sprintf("%#v", this.Ref)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProtocolPolicerRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.ProtocolPolicerRefType{")
	if this.Ref != nil {
		s = append(s, "Ref: "+fmt.Sprintf("%#v", this.Ref)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkSiteRefSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.NetworkSiteRefSelector{")
	if this.RefOrSelector != nil {
		s = append(s, "RefOrSelector: "+fmt.Sprintf("%#v", this.RefOrSelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkSiteRefSelector_VirtualNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.NetworkSiteRefSelector_VirtualNetwork{` +
		`VirtualNetwork:` + fmt.Sprintf("%#v", this.VirtualNetwork) + `}`}, ", ")
	return s
}
func (this *NetworkSiteRefSelector_Site) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.NetworkSiteRefSelector_Site{` +
		`Site:` + fmt.Sprintf("%#v", this.Site) + `}`}, ", ")
	return s
}
func (this *NetworkSiteRefSelector_VirtualSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.NetworkSiteRefSelector_VirtualSite{` +
		`VirtualSite:` + fmt.Sprintf("%#v", this.VirtualSite) + `}`}, ", ")
	return s
}
func (this *SiteVirtualSiteRefSelector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.SiteVirtualSiteRefSelector{")
	if this.RefOrSelector != nil {
		s = append(s, "RefOrSelector: "+fmt.Sprintf("%#v", this.RefOrSelector)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteVirtualSiteRefSelector_Site) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.SiteVirtualSiteRefSelector_Site{` +
		`Site:` + fmt.Sprintf("%#v", this.Site) + `}`}, ", ")
	return s
}
func (this *SiteVirtualSiteRefSelector_VirtualSite) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.SiteVirtualSiteRefSelector_VirtualSite{` +
		`VirtualSite:` + fmt.Sprintf("%#v", this.VirtualSite) + `}`}, ", ")
	return s
}
func (this *HeaderManipulationOptionType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.HeaderManipulationOptionType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "Append: "+fmt.Sprintf("%#v", this.Append)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TlsValidationParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.TlsValidationParamsType{")
	s = append(s, "TrustedCaUrl: "+fmt.Sprintf("%#v", this.TrustedCaUrl)+",\n")
	s = append(s, "SkipHostnameVerification: "+fmt.Sprintf("%#v", this.SkipHostnameVerification)+",\n")
	s = append(s, "VerifySubjectAltNames: "+fmt.Sprintf("%#v", this.VerifySubjectAltNames)+",\n")
	s = append(s, "UseVolterraTrustedCaUrl: "+fmt.Sprintf("%#v", this.UseVolterraTrustedCaUrl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TlsCertificateType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.TlsCertificateType{")
	s = append(s, "CertificateUrl: "+fmt.Sprintf("%#v", this.CertificateUrl)+",\n")
	if this.PrivateKey != nil {
		s = append(s, "PrivateKey: "+fmt.Sprintf("%#v", this.PrivateKey)+",\n")
	}
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TlsParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.TlsParamsType{")
	s = append(s, "MinimumProtocolVersion: "+fmt.Sprintf("%#v", this.MinimumProtocolVersion)+",\n")
	s = append(s, "MaximumProtocolVersion: "+fmt.Sprintf("%#v", this.MaximumProtocolVersion)+",\n")
	s = append(s, "CipherSuites: "+fmt.Sprintf("%#v", this.CipherSuites)+",\n")
	if this.TlsCertificates != nil {
		s = append(s, "TlsCertificates: "+fmt.Sprintf("%#v", this.TlsCertificates)+",\n")
	}
	s = append(s, "TrustedCaUrl: "+fmt.Sprintf("%#v", this.TrustedCaUrl)+",\n")
	if this.ValidationParams != nil {
		s = append(s, "ValidationParams: "+fmt.Sprintf("%#v", this.ValidationParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpstreamTlsParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.UpstreamTlsParamsType{")
	if this.CommonParams != nil {
		s = append(s, "CommonParams: "+fmt.Sprintf("%#v", this.CommonParams)+",\n")
	}
	if this.SniChoice != nil {
		s = append(s, "SniChoice: "+fmt.Sprintf("%#v", this.SniChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpstreamTlsParamsType_Sni) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.UpstreamTlsParamsType_Sni{` +
		`Sni:` + fmt.Sprintf("%#v", this.Sni) + `}`}, ", ")
	return s
}
func (this *UpstreamTlsParamsType_UseHostHeaderAsSni) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.UpstreamTlsParamsType_UseHostHeaderAsSni{` +
		`UseHostHeaderAsSni:` + fmt.Sprintf("%#v", this.UseHostHeaderAsSni) + `}`}, ", ")
	return s
}
func (this *UpstreamTlsParamsType_DisableSni) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.UpstreamTlsParamsType_DisableSni{` +
		`DisableSni:` + fmt.Sprintf("%#v", this.DisableSni) + `}`}, ", ")
	return s
}
func (this *DownstreamTlsParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.DownstreamTlsParamsType{")
	if this.CommonParams != nil {
		s = append(s, "CommonParams: "+fmt.Sprintf("%#v", this.CommonParams)+",\n")
	}
	s = append(s, "RequireClientCertificate: "+fmt.Sprintf("%#v", this.RequireClientCertificate)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DomainType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.DomainType{")
	if this.DomainChoice != nil {
		s = append(s, "DomainChoice: "+fmt.Sprintf("%#v", this.DomainChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DomainType_ExactValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.DomainType_ExactValue{` +
		`ExactValue:` + fmt.Sprintf("%#v", this.ExactValue) + `}`}, ", ")
	return s
}
func (this *DomainType_SuffixValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.DomainType_SuffixValue{` +
		`SuffixValue:` + fmt.Sprintf("%#v", this.SuffixValue) + `}`}, ", ")
	return s
}
func (this *DomainType_RegexValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.DomainType_RegexValue{` +
		`RegexValue:` + fmt.Sprintf("%#v", this.RegexValue) + `}`}, ", ")
	return s
}
func (this *L4DestType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.L4DestType{")
	s = append(s, "Prefixes: "+fmt.Sprintf("%#v", this.Prefixes)+",\n")
	s = append(s, "PortRanges: "+fmt.Sprintf("%#v", this.PortRanges)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TlsInterceptionRule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.TlsInterceptionRule{")
	if this.DomainMatch != nil {
		s = append(s, "DomainMatch: "+fmt.Sprintf("%#v", this.DomainMatch)+",\n")
	}
	if this.EnableDisableChoice != nil {
		s = append(s, "EnableDisableChoice: "+fmt.Sprintf("%#v", this.EnableDisableChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TlsInterceptionRule_DisableInterception) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsInterceptionRule_DisableInterception{` +
		`DisableInterception:` + fmt.Sprintf("%#v", this.DisableInterception) + `}`}, ", ")
	return s
}
func (this *TlsInterceptionRule_EnableInterception) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsInterceptionRule_EnableInterception{` +
		`EnableInterception:` + fmt.Sprintf("%#v", this.EnableInterception) + `}`}, ", ")
	return s
}
func (this *TlsInterceptionPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.TlsInterceptionPolicy{")
	if this.InterceptionRules != nil {
		s = append(s, "InterceptionRules: "+fmt.Sprintf("%#v", this.InterceptionRules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TlsInterceptionType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.TlsInterceptionType{")
	if this.InterceptionPolicyChoice != nil {
		s = append(s, "InterceptionPolicyChoice: "+fmt.Sprintf("%#v", this.InterceptionPolicyChoice)+",\n")
	}
	if this.SigningCertChoice != nil {
		s = append(s, "SigningCertChoice: "+fmt.Sprintf("%#v", this.SigningCertChoice)+",\n")
	}
	if this.TrustedCaChoice != nil {
		s = append(s, "TrustedCaChoice: "+fmt.Sprintf("%#v", this.TrustedCaChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TlsInterceptionType_EnableForAllDomains) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsInterceptionType_EnableForAllDomains{` +
		`EnableForAllDomains:` + fmt.Sprintf("%#v", this.EnableForAllDomains) + `}`}, ", ")
	return s
}
func (this *TlsInterceptionType_Policy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsInterceptionType_Policy{` +
		`Policy:` + fmt.Sprintf("%#v", this.Policy) + `}`}, ", ")
	return s
}
func (this *TlsInterceptionType_CustomCertificate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsInterceptionType_CustomCertificate{` +
		`CustomCertificate:` + fmt.Sprintf("%#v", this.CustomCertificate) + `}`}, ", ")
	return s
}
func (this *TlsInterceptionType_VolterraCertificate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsInterceptionType_VolterraCertificate{` +
		`VolterraCertificate:` + fmt.Sprintf("%#v", this.VolterraCertificate) + `}`}, ", ")
	return s
}
func (this *TlsInterceptionType_TrustedCaUrl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsInterceptionType_TrustedCaUrl{` +
		`TrustedCaUrl:` + fmt.Sprintf("%#v", this.TrustedCaUrl) + `}`}, ", ")
	return s
}
func (this *TlsInterceptionType_VolterraTrustedCa) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.TlsInterceptionType_VolterraTrustedCa{` +
		`VolterraTrustedCa:` + fmt.Sprintf("%#v", this.VolterraTrustedCa) + `}`}, ", ")
	return s
}
func (this *FractionalPercent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.FractionalPercent{")
	s = append(s, "Numerator: "+fmt.Sprintf("%#v", this.Numerator)+",\n")
	s = append(s, "Denominator: "+fmt.Sprintf("%#v", this.Denominator)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BufferConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.BufferConfigType{")
	s = append(s, "Disabled: "+fmt.Sprintf("%#v", this.Disabled)+",\n")
	s = append(s, "MaxRequestBytes: "+fmt.Sprintf("%#v", this.MaxRequestBytes)+",\n")
	s = append(s, "MaxRequestTime: "+fmt.Sprintf("%#v", this.MaxRequestTime)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CorsPolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&schema.CorsPolicy{")
	s = append(s, "Disabled: "+fmt.Sprintf("%#v", this.Disabled)+",\n")
	s = append(s, "AllowOrigin: "+fmt.Sprintf("%#v", this.AllowOrigin)+",\n")
	s = append(s, "AllowOriginRegex: "+fmt.Sprintf("%#v", this.AllowOriginRegex)+",\n")
	s = append(s, "AllowMethods: "+fmt.Sprintf("%#v", this.AllowMethods)+",\n")
	s = append(s, "AllowHeaders: "+fmt.Sprintf("%#v", this.AllowHeaders)+",\n")
	s = append(s, "ExposeHeaders: "+fmt.Sprintf("%#v", this.ExposeHeaders)+",\n")
	s = append(s, "MaxAge: "+fmt.Sprintf("%#v", this.MaxAge)+",\n")
	s = append(s, "MaximumAge: "+fmt.Sprintf("%#v", this.MaximumAge)+",\n")
	s = append(s, "AllowCredentials: "+fmt.Sprintf("%#v", this.AllowCredentials)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PathMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.PathMatcherType{")
	if this.PathMatch != nil {
		s = append(s, "PathMatch: "+fmt.Sprintf("%#v", this.PathMatch)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PathMatcherType_Prefix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.PathMatcherType_Prefix{` +
		`Prefix:` + fmt.Sprintf("%#v", this.Prefix) + `}`}, ", ")
	return s
}
func (this *PathMatcherType_Path) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.PathMatcherType_Path{` +
		`Path:` + fmt.Sprintf("%#v", this.Path) + `}`}, ", ")
	return s
}
func (this *PathMatcherType_Regex) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.PathMatcherType_Regex{` +
		`Regex:` + fmt.Sprintf("%#v", this.Regex) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.HeaderMatcherType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.ValueMatch != nil {
		s = append(s, "ValueMatch: "+fmt.Sprintf("%#v", this.ValueMatch)+",\n")
	}
	s = append(s, "InvertMatch: "+fmt.Sprintf("%#v", this.InvertMatch)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HeaderMatcherType_Exact) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HeaderMatcherType_Exact{` +
		`Exact:` + fmt.Sprintf("%#v", this.Exact) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherType_Regex) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HeaderMatcherType_Regex{` +
		`Regex:` + fmt.Sprintf("%#v", this.Regex) + `}`}, ", ")
	return s
}
func (this *HeaderMatcherType_Presence) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HeaderMatcherType_Presence{` +
		`Presence:` + fmt.Sprintf("%#v", this.Presence) + `}`}, ", ")
	return s
}
func (this *QueryParameterMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.QueryParameterMatcherType{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	if this.ValueMatch != nil {
		s = append(s, "ValueMatch: "+fmt.Sprintf("%#v", this.ValueMatch)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueryParameterMatcherType_Exact) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.QueryParameterMatcherType_Exact{` +
		`Exact:` + fmt.Sprintf("%#v", this.Exact) + `}`}, ", ")
	return s
}
func (this *QueryParameterMatcherType_Regex) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.QueryParameterMatcherType_Regex{` +
		`Regex:` + fmt.Sprintf("%#v", this.Regex) + `}`}, ", ")
	return s
}
func (this *RouteMatch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.RouteMatch{")
	if this.Path != nil {
		s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	}
	if this.Headers != nil {
		s = append(s, "Headers: "+fmt.Sprintf("%#v", this.Headers)+",\n")
	}
	if this.QueryParams != nil {
		s = append(s, "QueryParams: "+fmt.Sprintf("%#v", this.QueryParams)+",\n")
	}
	s = append(s, "HttpMethod: "+fmt.Sprintf("%#v", this.HttpMethod)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WafRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.WafRefType{")
	if this.Waf != nil {
		s = append(s, "Waf: "+fmt.Sprintf("%#v", this.Waf)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WafRulesRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.WafRulesRefType{")
	if this.WafRules != nil {
		s = append(s, "WafRules: "+fmt.Sprintf("%#v", this.WafRules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AppFirewallRefType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.AppFirewallRefType{")
	if this.AppFirewall != nil {
		s = append(s, "AppFirewall: "+fmt.Sprintf("%#v", this.AppFirewall)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WafType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.WafType{")
	if this.RefType != nil {
		s = append(s, "RefType: "+fmt.Sprintf("%#v", this.RefType)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WafType_Waf) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.WafType_Waf{` +
		`Waf:` + fmt.Sprintf("%#v", this.Waf) + `}`}, ", ")
	return s
}
func (this *WafType_WafRules) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.WafType_WafRules{` +
		`WafRules:` + fmt.Sprintf("%#v", this.WafRules) + `}`}, ", ")
	return s
}
func (this *WafType_AppFirewall) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.WafType_AppFirewall{` +
		`AppFirewall:` + fmt.Sprintf("%#v", this.AppFirewall) + `}`}, ", ")
	return s
}
func (this *AppRoleAuthInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.AppRoleAuthInfoType{")
	s = append(s, "RoleId: "+fmt.Sprintf("%#v", this.RoleId)+",\n")
	if this.SecretId != nil {
		s = append(s, "SecretId: "+fmt.Sprintf("%#v", this.SecretId)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VaultAuthInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.VaultAuthInfoType{")
	if this.AuthParams != nil {
		s = append(s, "AuthParams: "+fmt.Sprintf("%#v", this.AuthParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VaultAuthInfoType_AppRoleAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VaultAuthInfoType_AppRoleAuth{` +
		`AppRoleAuth:` + fmt.Sprintf("%#v", this.AppRoleAuth) + `}`}, ", ")
	return s
}
func (this *VaultAuthInfoType_Token) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VaultAuthInfoType_Token{` +
		`Token:` + fmt.Sprintf("%#v", this.Token) + `}`}, ", ")
	return s
}
func (this *RestAuthInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.RestAuthInfoType{")
	if this.AuthParams != nil {
		s = append(s, "AuthParams: "+fmt.Sprintf("%#v", this.AuthParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RestAuthInfoType_BasicAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.RestAuthInfoType_BasicAuth{` +
		`BasicAuth:` + fmt.Sprintf("%#v", this.BasicAuth) + `}`}, ", ")
	return s
}
func (this *RestAuthInfoType_HeadersAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.RestAuthInfoType_HeadersAuth{` +
		`HeadersAuth:` + fmt.Sprintf("%#v", this.HeadersAuth) + `}`}, ", ")
	return s
}
func (this *RestAuthInfoType_QueryParamsAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.RestAuthInfoType_QueryParamsAuth{` +
		`QueryParamsAuth:` + fmt.Sprintf("%#v", this.QueryParamsAuth) + `}`}, ", ")
	return s
}
func (this *HostAccessInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.HostAccessInfoType{")
	s = append(s, "Scheme: "+fmt.Sprintf("%#v", this.Scheme)+",\n")
	s = append(s, "ServerEndpoint: "+fmt.Sprintf("%#v", this.ServerEndpoint)+",\n")
	if this.TlsConfig != nil {
		s = append(s, "TlsConfig: "+fmt.Sprintf("%#v", this.TlsConfig)+",\n")
	}
	if this.AuthParams != nil {
		s = append(s, "AuthParams: "+fmt.Sprintf("%#v", this.AuthParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HostAccessInfoType_RestAuthInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HostAccessInfoType_RestAuthInfo{` +
		`RestAuthInfo:` + fmt.Sprintf("%#v", this.RestAuthInfo) + `}`}, ", ")
	return s
}
func (this *HostAccessInfoType_VaultAuthInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HostAccessInfoType_VaultAuthInfo{` +
		`VaultAuthInfo:` + fmt.Sprintf("%#v", this.VaultAuthInfo) + `}`}, ", ")
	return s
}
func (this *VaultAccessInfoType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.VaultAccessInfoType{")
	s = append(s, "VaultAddr: "+fmt.Sprintf("%#v", this.VaultAddr)+",\n")
	s = append(s, "VaultCaUrl: "+fmt.Sprintf("%#v", this.VaultCaUrl)+",\n")
	if this.AuthnChoice != nil {
		s = append(s, "AuthnChoice: "+fmt.Sprintf("%#v", this.AuthnChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VaultAccessInfoType_AppRoleAuth) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VaultAccessInfoType_AppRoleAuth{` +
		`AppRoleAuth:` + fmt.Sprintf("%#v", this.AppRoleAuth) + `}`}, ", ")
	return s
}
func (this *VaultAccessInfoType_Token) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VaultAccessInfoType_Token{` +
		`Token:` + fmt.Sprintf("%#v", this.Token) + `}`}, ", ")
	return s
}
func (this *VaultSecretType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.VaultSecretType{")
	if this.AccessChoice != nil {
		s = append(s, "AccessChoice: "+fmt.Sprintf("%#v", this.AccessChoice)+",\n")
	}
	s = append(s, "SecretPath: "+fmt.Sprintf("%#v", this.SecretPath)+",\n")
	s = append(s, "SecretSubPath: "+fmt.Sprintf("%#v", this.SecretSubPath)+",\n")
	s = append(s, "SecretVersion: "+fmt.Sprintf("%#v", this.SecretVersion)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VaultSecretType_VaultAccessInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VaultSecretType_VaultAccessInfo{` +
		`VaultAccessInfo:` + fmt.Sprintf("%#v", this.VaultAccessInfo) + `}`}, ", ")
	return s
}
func (this *VaultSecretType_ProviderName) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VaultSecretType_ProviderName{` +
		`ProviderName:` + fmt.Sprintf("%#v", this.ProviderName) + `}`}, ", ")
	return s
}
func (this *VolterraSecretType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.VolterraSecretType{")
	if this.SecretTypeChoice != nil {
		s = append(s, "SecretTypeChoice: "+fmt.Sprintf("%#v", this.SecretTypeChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VolterraSecretType_BlindfoldSecretInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VolterraSecretType_BlindfoldSecretInfo{` +
		`BlindfoldSecretInfo:` + fmt.Sprintf("%#v", this.BlindfoldSecretInfo) + `}`}, ", ")
	return s
}
func (this *VolterraSecretType_VaultSecretInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VolterraSecretType_VaultSecretInfo{` +
		`VaultSecretInfo:` + fmt.Sprintf("%#v", this.VaultSecretInfo) + `}`}, ", ")
	return s
}
func (this *PortValueType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.PortValueType{")
	if this.PortValueTypeChoice != nil {
		s = append(s, "PortValueTypeChoice: "+fmt.Sprintf("%#v", this.PortValueTypeChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PortValueType_All) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.PortValueType_All{` +
		`All:` + fmt.Sprintf("%#v", this.All) + `}`}, ", ")
	return s
}
func (this *PortValueType_UserDefined) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.PortValueType_UserDefined{` +
		`UserDefined:` + fmt.Sprintf("%#v", this.UserDefined) + `}`}, ", ")
	return s
}
func (this *PortValueType_Dns) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.PortValueType_Dns{` +
		`Dns:` + fmt.Sprintf("%#v", this.Dns) + `}`}, ", ")
	return s
}
func (this *VirtualNetworkReferenceType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.VirtualNetworkReferenceType{")
	if this.Refs != nil {
		s = append(s, "Refs: "+fmt.Sprintf("%#v", this.Refs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VirtualNetworkSelectorType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.VirtualNetworkSelectorType{")
	if this.VnTypeChoice != nil {
		s = append(s, "VnTypeChoice: "+fmt.Sprintf("%#v", this.VnTypeChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VirtualNetworkSelectorType_SiteLocal) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VirtualNetworkSelectorType_SiteLocal{` +
		`SiteLocal:` + fmt.Sprintf("%#v", this.SiteLocal) + `}`}, ", ")
	return s
}
func (this *VirtualNetworkSelectorType_SiteLocalInside) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VirtualNetworkSelectorType_SiteLocalInside{` +
		`SiteLocalInside:` + fmt.Sprintf("%#v", this.SiteLocalInside) + `}`}, ", ")
	return s
}
func (this *VirtualNetworkSelectorType_Public) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.VirtualNetworkSelectorType_Public{` +
		`Public:` + fmt.Sprintf("%#v", this.Public) + `}`}, ", ")
	return s
}
func (this *RetryBackOff) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.RetryBackOff{")
	s = append(s, "BaseInterval: "+fmt.Sprintf("%#v", this.BaseInterval)+",\n")
	s = append(s, "MaxInterval: "+fmt.Sprintf("%#v", this.MaxInterval)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RetryPolicyType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.RetryPolicyType{")
	s = append(s, "RetryOn: "+fmt.Sprintf("%#v", this.RetryOn)+",\n")
	s = append(s, "RetryCondition: "+fmt.Sprintf("%#v", this.RetryCondition)+",\n")
	s = append(s, "NumRetries: "+fmt.Sprintf("%#v", this.NumRetries)+",\n")
	s = append(s, "PerTryTimeout: "+fmt.Sprintf("%#v", this.PerTryTimeout)+",\n")
	s = append(s, "RetriableStatusCodes: "+fmt.Sprintf("%#v", this.RetriableStatusCodes)+",\n")
	if this.BackOff != nil {
		s = append(s, "BackOff: "+fmt.Sprintf("%#v", this.BackOff)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MetricValue) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.MetricValue{")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NextHopType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.NextHopType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.NexthopAddress != nil {
		s = append(s, "NexthopAddress: "+fmt.Sprintf("%#v", this.NexthopAddress)+",\n")
	}
	if this.Interface != nil {
		s = append(s, "Interface: "+fmt.Sprintf("%#v", this.Interface)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StaticRouteType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.StaticRouteType{")
	s = append(s, "Attrs: "+fmt.Sprintf("%#v", this.Attrs)+",\n")
	if this.Subnets != nil {
		s = append(s, "Subnets: "+fmt.Sprintf("%#v", this.Subnets)+",\n")
	}
	if this.Nexthop != nil {
		s = append(s, "Nexthop: "+fmt.Sprintf("%#v", this.Nexthop)+",\n")
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%#v: %#v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	if this.Labels != nil {
		s = append(s, "Labels: "+mapStringForLabels+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ForwardProxyConfigType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&schema.ForwardProxyConfigType{")
	s = append(s, "WhiteListedPrefixes: "+fmt.Sprintf("%#v", this.WhiteListedPrefixes)+",\n")
	s = append(s, "WhiteListedPorts: "+fmt.Sprintf("%#v", this.WhiteListedPorts)+",\n")
	s = append(s, "MaxConnectAttempts: "+fmt.Sprintf("%#v", this.MaxConnectAttempts)+",\n")
	s = append(s, "ConnectionTimeout: "+fmt.Sprintf("%#v", this.ConnectionTimeout)+",\n")
	if this.TlsInterceptionChoice != nil {
		s = append(s, "TlsInterceptionChoice: "+fmt.Sprintf("%#v", this.TlsInterceptionChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ForwardProxyConfigType_NoInterception) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.ForwardProxyConfigType_NoInterception{` +
		`NoInterception:` + fmt.Sprintf("%#v", this.NoInterception) + `}`}, ", ")
	return s
}
func (this *ForwardProxyConfigType_TlsIntercept) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.ForwardProxyConfigType_TlsIntercept{` +
		`TlsIntercept:` + fmt.Sprintf("%#v", this.TlsIntercept) + `}`}, ", ")
	return s
}
func (this *HostIdentifier) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.HostIdentifier{")
	if this.HostnameOrIp != nil {
		s = append(s, "HostnameOrIp: "+fmt.Sprintf("%#v", this.HostnameOrIp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HostIdentifier_Ip) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HostIdentifier_Ip{` +
		`Ip:` + fmt.Sprintf("%#v", this.Ip) + `}`}, ", ")
	return s
}
func (this *HostIdentifier_Hostname) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.HostIdentifier_Hostname{` +
		`Hostname:` + fmt.Sprintf("%#v", this.Hostname) + `}`}, ", ")
	return s
}
func (this *InterfaceIdentifier) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.InterfaceIdentifier{")
	if this.InterfaceChoice != nil {
		s = append(s, "InterfaceChoice: "+fmt.Sprintf("%#v", this.InterfaceChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InterfaceIdentifier_AnyIntf) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.InterfaceIdentifier_AnyIntf{` +
		`AnyIntf:` + fmt.Sprintf("%#v", this.AnyIntf) + `}`}, ", ")
	return s
}
func (this *InterfaceIdentifier_Intf) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.InterfaceIdentifier_Intf{` +
		`Intf:` + fmt.Sprintf("%#v", this.Intf) + `}`}, ", ")
	return s
}
func (this *InterfaceOrNetwork) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.InterfaceOrNetwork{")
	if this.InterfaceChoice != nil {
		s = append(s, "InterfaceChoice: "+fmt.Sprintf("%#v", this.InterfaceChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InterfaceOrNetwork_Intf) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.InterfaceOrNetwork_Intf{` +
		`Intf:` + fmt.Sprintf("%#v", this.Intf) + `}`}, ", ")
	return s
}
func (this *InterfaceOrNetwork_Pod) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.InterfaceOrNetwork_Pod{` +
		`Pod:` + fmt.Sprintf("%#v", this.Pod) + `}`}, ", ")
	return s
}
func (this *InterfaceOrNetwork_VnType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.InterfaceOrNetwork_VnType{` +
		`VnType:` + fmt.Sprintf("%#v", this.VnType) + `}`}, ", ")
	return s
}
func (this *InterfaceOrNetwork_Vn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.InterfaceOrNetwork_Vn{` +
		`Vn:` + fmt.Sprintf("%#v", this.Vn) + `}`}, ", ")
	return s
}
func (this *RouteTarget2ByteAsn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.RouteTarget2ByteAsn{")
	s = append(s, "AsNumber: "+fmt.Sprintf("%#v", this.AsNumber)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteTarget4ByteAsn) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.RouteTarget4ByteAsn{")
	s = append(s, "AsNumber: "+fmt.Sprintf("%#v", this.AsNumber)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteTargetIPv4Addr) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.RouteTargetIPv4Addr{")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteTarget) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&schema.RouteTarget{")
	if this.RtargetChoice != nil {
		s = append(s, "RtargetChoice: "+fmt.Sprintf("%#v", this.RtargetChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RouteTarget_Asn2ByteRtarget) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.RouteTarget_Asn2ByteRtarget{` +
		`Asn2ByteRtarget:` + fmt.Sprintf("%#v", this.Asn2ByteRtarget) + `}`}, ", ")
	return s
}
func (this *RouteTarget_Ipv4AddrRtarget) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.RouteTarget_Ipv4AddrRtarget{` +
		`Ipv4AddrRtarget:` + fmt.Sprintf("%#v", this.Ipv4AddrRtarget) + `}`}, ", ")
	return s
}
func (this *RouteTarget_Asn4ByteRtarget) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&schema.RouteTarget_Asn4ByteRtarget{` +
		`Asn4ByteRtarget:` + fmt.Sprintf("%#v", this.Asn4ByteRtarget) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ObjectRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Tenant) > 0 {
		i -= len(m.Tenant)
		copy(dAtA[i:], m.Tenant)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Tenant)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LabelSelectorType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelSelectorType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LabelSelectorType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Expressions) > 0 {
		for iNdEx := len(m.Expressions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Expressions[iNdEx])
			copy(dAtA[i:], m.Expressions[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Expressions[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LabelMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LabelMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ConditionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConditionType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConditionType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ServiceName) > 0 {
		i -= len(m.ServiceName)
		copy(dAtA[i:], m.ServiceName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServiceName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x32
	}
	if m.LastUpdateTime != nil {
		{
			size, err := m.LastUpdateTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InitializerType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitializerType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InitializerType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InitializersType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitializersType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InitializersType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		{
			size, err := m.Result.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Pending) > 0 {
		for iNdEx := len(m.Pending) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pending[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StatusMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusMetaType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusMetaType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VtrpId) > 0 {
		i -= len(m.VtrpId)
		copy(dAtA[i:], m.VtrpId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VtrpId)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Publish != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Publish))
		i--
		dAtA[i] = 0x30
	}
	if m.CreationTimestamp != nil {
		{
			size, err := m.CreationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StatusId) > 0 {
		i -= len(m.StatusId)
		copy(dAtA[i:], m.StatusId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StatusId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CreatorId) > 0 {
		i -= len(m.CreatorId)
		copy(dAtA[i:], m.CreatorId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreatorId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CreatorClass) > 0 {
		i -= len(m.CreatorClass)
		copy(dAtA[i:], m.CreatorClass)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreatorClass)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ObjectMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectMetaType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectMetaType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Disable {
		i--
		if m.Disable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Annotations) > 0 {
		keysForAnnotations := make([]string, 0, len(m.Annotations))
		for k := range m.Annotations {
			keysForAnnotations = append(keysForAnnotations, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
		for iNdEx := len(keysForAnnotations) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Annotations[string(keysForAnnotations[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForAnnotations[iNdEx])
			copy(dAtA[i:], keysForAnnotations[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForAnnotations[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListMetaType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListMetaType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResourceVersion) > 0 {
		i -= len(m.ResourceVersion)
		copy(dAtA[i:], m.ResourceVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResourceVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ObjectGetMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectGetMetaType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectGetMetaType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Disable {
		i--
		if m.Disable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Annotations) > 0 {
		keysForAnnotations := make([]string, 0, len(m.Annotations))
		for k := range m.Annotations {
			keysForAnnotations = append(keysForAnnotations, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
		for iNdEx := len(keysForAnnotations) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Annotations[string(keysForAnnotations[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForAnnotations[iNdEx])
			copy(dAtA[i:], keysForAnnotations[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForAnnotations[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ObjectCreateMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectCreateMetaType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectCreateMetaType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Disable {
		i--
		if m.Disable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Annotations) > 0 {
		keysForAnnotations := make([]string, 0, len(m.Annotations))
		for k := range m.Annotations {
			keysForAnnotations = append(keysForAnnotations, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
		for iNdEx := len(keysForAnnotations) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Annotations[string(keysForAnnotations[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForAnnotations[iNdEx])
			copy(dAtA[i:], keysForAnnotations[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForAnnotations[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ObjectReplaceMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectReplaceMetaType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectReplaceMetaType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Disable {
		i--
		if m.Disable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Annotations) > 0 {
		keysForAnnotations := make([]string, 0, len(m.Annotations))
		for k := range m.Annotations {
			keysForAnnotations = append(keysForAnnotations, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
		for iNdEx := len(keysForAnnotations) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Annotations[string(keysForAnnotations[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForAnnotations[iNdEx])
			copy(dAtA[i:], keysForAnnotations[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForAnnotations[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageMetaType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageMetaType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Disable {
		i--
		if m.Disable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ViewRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ViewRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KubeRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubeRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubeRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SystemObjectMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SystemObjectMetaType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SystemObjectMetaType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VtrpId) > 0 {
		i -= len(m.VtrpId)
		copy(dAtA[i:], m.VtrpId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VtrpId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.SreDisable {
		i--
		if m.SreDisable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.OwnerView != nil {
		{
			size, err := m.OwnerView.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if len(m.CreatorCookie) > 0 {
		i -= len(m.CreatorCookie)
		copy(dAtA[i:], m.CreatorCookie)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreatorCookie)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Namespace) > 0 {
		for iNdEx := len(m.Namespace) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Namespace[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.ObjectIndex != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ObjectIndex))
		i--
		dAtA[i] = 0x60
	}
	if len(m.TraceInfo) > 0 {
		i -= len(m.TraceInfo)
		copy(dAtA[i:], m.TraceInfo)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TraceInfo)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.CreatorId) > 0 {
		i -= len(m.CreatorId)
		copy(dAtA[i:], m.CreatorId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreatorId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.CreatorClass) > 0 {
		i -= len(m.CreatorClass)
		copy(dAtA[i:], m.CreatorClass)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreatorClass)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Tenant) > 0 {
		i -= len(m.Tenant)
		copy(dAtA[i:], m.Tenant)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Tenant)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Finalizers) > 0 {
		for iNdEx := len(m.Finalizers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Finalizers[iNdEx])
			copy(dAtA[i:], m.Finalizers[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Finalizers[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Initializers != nil {
		{
			size, err := m.Initializers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ModificationTimestamp != nil {
		{
			size, err := m.ModificationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DeletionTimestamp != nil {
		{
			size, err := m.DeletionTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CreationTimestamp != nil {
		{
			size, err := m.CreationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SystemObjectGetMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SystemObjectGetMetaType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SystemObjectGetMetaType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OwnerView != nil {
		{
			size, err := m.OwnerView.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.ObjectIndex != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ObjectIndex))
		i--
		dAtA[i] = 0x60
	}
	if len(m.CreatorId) > 0 {
		i -= len(m.CreatorId)
		copy(dAtA[i:], m.CreatorId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreatorId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.CreatorClass) > 0 {
		i -= len(m.CreatorClass)
		copy(dAtA[i:], m.CreatorClass)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreatorClass)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Tenant) > 0 {
		i -= len(m.Tenant)
		copy(dAtA[i:], m.Tenant)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Tenant)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Finalizers) > 0 {
		for iNdEx := len(m.Finalizers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Finalizers[iNdEx])
			copy(dAtA[i:], m.Finalizers[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Finalizers[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Initializers != nil {
		{
			size, err := m.Initializers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ModificationTimestamp != nil {
		{
			size, err := m.ModificationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DeletionTimestamp != nil {
		{
			size, err := m.DeletionTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CreationTimestamp != nil {
		{
			size, err := m.CreationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthnTypeBasicAuth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthnTypeBasicAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthnTypeBasicAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Password != nil {
		{
			size, err := m.Password.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthnTypeHeaders) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthnTypeHeaders) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthnTypeHeaders) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Headers) > 0 {
		keysForHeaders := make([]string, 0, len(m.Headers))
		for k := range m.Headers {
			keysForHeaders = append(keysForHeaders, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForHeaders)
		for iNdEx := len(keysForHeaders) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Headers[string(keysForHeaders[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTypes(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForHeaders[iNdEx])
			copy(dAtA[i:], keysForHeaders[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForHeaders[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AuthnTypeQueryParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthnTypeQueryParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthnTypeQueryParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.QueryParams) > 0 {
		keysForQueryParams := make([]string, 0, len(m.QueryParams))
		for k := range m.QueryParams {
			keysForQueryParams = append(keysForQueryParams, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForQueryParams)
		for iNdEx := len(keysForQueryParams) - 1; iNdEx >= 0; iNdEx-- {
			v := m.QueryParams[string(keysForQueryParams[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTypes(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForQueryParams[iNdEx])
			copy(dAtA[i:], keysForQueryParams[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForQueryParams[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BlindfoldSecretInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlindfoldSecretInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlindfoldSecretInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StoreProvider) > 0 {
		i -= len(m.StoreProvider)
		copy(dAtA[i:], m.StoreProvider)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StoreProvider)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DecryptionProvider) > 0 {
		i -= len(m.DecryptionProvider)
		copy(dAtA[i:], m.DecryptionProvider)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DecryptionProvider)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VaultSecretInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VaultSecretInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultSecretInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SecretEncoding != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SecretEncoding))
		i--
		dAtA[i] = 0x28
	}
	if m.Version != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClearSecretInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearSecretInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearSecretInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WingmanSecretInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WingmanSecretInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WingmanSecretInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecretType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecretType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecretType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlindfoldSecretInfoInternal != nil {
		{
			size, err := m.BlindfoldSecretInfoInternal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.SecretEncodingType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SecretEncodingType))
		i--
		dAtA[i] = 0x40
	}
	if m.SecretInfoOneof != nil {
		{
			size := m.SecretInfoOneof.Size()
			i -= size
			if _, err := m.SecretInfoOneof.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SecretType_BlindfoldSecretInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecretType_BlindfoldSecretInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BlindfoldSecretInfo != nil {
		{
			size, err := m.BlindfoldSecretInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *SecretType_VaultSecretInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecretType_VaultSecretInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VaultSecretInfo != nil {
		{
			size, err := m.VaultSecretInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *SecretType_ClearSecretInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecretType_ClearSecretInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ClearSecretInfo != nil {
		{
			size, err := m.ClearSecretInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *SecretType_WingmanSecretInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecretType_WingmanSecretInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.WingmanSecretInfo != nil {
		{
			size, err := m.WingmanSecretInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *NetworkRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for iNdEx := len(m.Ref) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ref[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SiteRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NetworkType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NetworkType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Ref) > 0 {
		for iNdEx := len(m.Ref) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ref[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *IpPrefixSetRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpPrefixSetRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpPrefixSetRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for iNdEx := len(m.Ref) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ref[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VSiteRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VSiteRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VSiteRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NetworkType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NetworkType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Ref) > 0 {
		for iNdEx := len(m.Ref) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ref[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PolicerRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicerRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicerRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for iNdEx := len(m.Ref) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ref[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProtocolPolicerRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtocolPolicerRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtocolPolicerRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for iNdEx := len(m.Ref) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ref[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NetworkSiteRefSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkSiteRefSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkSiteRefSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RefOrSelector != nil {
		{
			size := m.RefOrSelector.Size()
			i -= size
			if _, err := m.RefOrSelector.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *NetworkSiteRefSelector_VirtualNetwork) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkSiteRefSelector_VirtualNetwork) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VirtualNetwork != nil {
		{
			size, err := m.VirtualNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *NetworkSiteRefSelector_Site) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkSiteRefSelector_Site) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Site != nil {
		{
			size, err := m.Site.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *NetworkSiteRefSelector_VirtualSite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkSiteRefSelector_VirtualSite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VirtualSite != nil {
		{
			size, err := m.VirtualSite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SiteVirtualSiteRefSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteVirtualSiteRefSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteVirtualSiteRefSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RefOrSelector != nil {
		{
			size := m.RefOrSelector.Size()
			i -= size
			if _, err := m.RefOrSelector.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SiteVirtualSiteRefSelector_Site) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteVirtualSiteRefSelector_Site) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Site != nil {
		{
			size, err := m.Site.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SiteVirtualSiteRefSelector_VirtualSite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteVirtualSiteRefSelector_VirtualSite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VirtualSite != nil {
		{
			size, err := m.VirtualSite.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *HeaderManipulationOptionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeaderManipulationOptionType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderManipulationOptionType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Append {
		i--
		if m.Append {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TlsValidationParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsValidationParamsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsValidationParamsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UseVolterraTrustedCaUrl {
		i--
		if m.UseVolterraTrustedCaUrl {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.VerifySubjectAltNames) > 0 {
		for iNdEx := len(m.VerifySubjectAltNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.VerifySubjectAltNames[iNdEx])
			copy(dAtA[i:], m.VerifySubjectAltNames[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.VerifySubjectAltNames[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.SkipHostnameVerification {
		i--
		if m.SkipHostnameVerification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.TrustedCaUrl) > 0 {
		i -= len(m.TrustedCaUrl)
		copy(dAtA[i:], m.TrustedCaUrl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TrustedCaUrl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TlsCertificateType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsCertificateType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsCertificateType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if m.PrivateKey != nil {
		{
			size, err := m.PrivateKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.CertificateUrl) > 0 {
		i -= len(m.CertificateUrl)
		copy(dAtA[i:], m.CertificateUrl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CertificateUrl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TlsParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsParamsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsParamsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValidationParams != nil {
		{
			size, err := m.ValidationParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.TrustedCaUrl) > 0 {
		i -= len(m.TrustedCaUrl)
		copy(dAtA[i:], m.TrustedCaUrl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TrustedCaUrl)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TlsCertificates) > 0 {
		for iNdEx := len(m.TlsCertificates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TlsCertificates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CipherSuites) > 0 {
		for iNdEx := len(m.CipherSuites) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CipherSuites[iNdEx])
			copy(dAtA[i:], m.CipherSuites[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.CipherSuites[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.MaximumProtocolVersion != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaximumProtocolVersion))
		i--
		dAtA[i] = 0x10
	}
	if m.MinimumProtocolVersion != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MinimumProtocolVersion))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpstreamTlsParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpstreamTlsParamsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpstreamTlsParamsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SniChoice != nil {
		{
			size := m.SniChoice.Size()
			i -= size
			if _, err := m.SniChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.CommonParams != nil {
		{
			size, err := m.CommonParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpstreamTlsParamsType_Sni) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpstreamTlsParamsType_Sni) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Sni)
	copy(dAtA[i:], m.Sni)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Sni)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *UpstreamTlsParamsType_UseHostHeaderAsSni) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpstreamTlsParamsType_UseHostHeaderAsSni) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UseHostHeaderAsSni != nil {
		{
			size, err := m.UseHostHeaderAsSni.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *UpstreamTlsParamsType_DisableSni) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpstreamTlsParamsType_DisableSni) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableSni != nil {
		{
			size, err := m.DisableSni.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *DownstreamTlsParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownstreamTlsParamsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownstreamTlsParamsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequireClientCertificate {
		i--
		if m.RequireClientCertificate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.CommonParams != nil {
		{
			size, err := m.CommonParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DomainType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DomainType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DomainType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DomainChoice != nil {
		{
			size := m.DomainChoice.Size()
			i -= size
			if _, err := m.DomainChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DomainType_ExactValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DomainType_ExactValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ExactValue)
	copy(dAtA[i:], m.ExactValue)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ExactValue)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *DomainType_SuffixValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DomainType_SuffixValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.SuffixValue)
	copy(dAtA[i:], m.SuffixValue)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.SuffixValue)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *DomainType_RegexValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DomainType_RegexValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.RegexValue)
	copy(dAtA[i:], m.RegexValue)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.RegexValue)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *L4DestType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L4DestType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L4DestType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PortRanges) > 0 {
		i -= len(m.PortRanges)
		copy(dAtA[i:], m.PortRanges)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PortRanges)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Prefixes) > 0 {
		for iNdEx := len(m.Prefixes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Prefixes[iNdEx])
			copy(dAtA[i:], m.Prefixes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Prefixes[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TlsInterceptionRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsInterceptionRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsInterceptionRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableDisableChoice != nil {
		{
			size := m.EnableDisableChoice.Size()
			i -= size
			if _, err := m.EnableDisableChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DomainMatch != nil {
		{
			size, err := m.DomainMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TlsInterceptionRule_DisableInterception) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsInterceptionRule_DisableInterception) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DisableInterception != nil {
		{
			size, err := m.DisableInterception.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *TlsInterceptionRule_EnableInterception) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsInterceptionRule_EnableInterception) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableInterception != nil {
		{
			size, err := m.EnableInterception.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *TlsInterceptionPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsInterceptionPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsInterceptionPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InterceptionRules) > 0 {
		for iNdEx := len(m.InterceptionRules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InterceptionRules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TlsInterceptionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsInterceptionType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsInterceptionType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InterceptionPolicyChoice != nil {
		{
			size := m.InterceptionPolicyChoice.Size()
			i -= size
			if _, err := m.InterceptionPolicyChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TrustedCaChoice != nil {
		{
			size := m.TrustedCaChoice.Size()
			i -= size
			if _, err := m.TrustedCaChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SigningCertChoice != nil {
		{
			size := m.SigningCertChoice.Size()
			i -= size
			if _, err := m.SigningCertChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *TlsInterceptionType_Policy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsInterceptionType_Policy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Policy != nil {
		{
			size, err := m.Policy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *TlsInterceptionType_CustomCertificate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsInterceptionType_CustomCertificate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CustomCertificate != nil {
		{
			size, err := m.CustomCertificate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *TlsInterceptionType_VolterraCertificate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsInterceptionType_VolterraCertificate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VolterraCertificate != nil {
		{
			size, err := m.VolterraCertificate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *TlsInterceptionType_TrustedCaUrl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsInterceptionType_TrustedCaUrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.TrustedCaUrl)
	copy(dAtA[i:], m.TrustedCaUrl)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.TrustedCaUrl)))
	i--
	dAtA[i] = 0x32
	return len(dAtA) - i, nil
}
func (m *TlsInterceptionType_VolterraTrustedCa) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsInterceptionType_VolterraTrustedCa) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VolterraTrustedCa != nil {
		{
			size, err := m.VolterraTrustedCa.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *TlsInterceptionType_EnableForAllDomains) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsInterceptionType_EnableForAllDomains) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EnableForAllDomains != nil {
		{
			size, err := m.EnableForAllDomains.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *FractionalPercent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FractionalPercent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FractionalPercent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Denominator != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Denominator))
		i--
		dAtA[i] = 0x10
	}
	if m.Numerator != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Numerator))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BufferConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BufferConfigType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BufferConfigType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxRequestTime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxRequestTime))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxRequestBytes != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxRequestBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.Disabled {
		i--
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CorsPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CorsPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CorsPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaximumAge != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaximumAge))
		i--
		dAtA[i] = 0x48
	}
	if m.AllowCredentials {
		i--
		if m.AllowCredentials {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.MaxAge) > 0 {
		i -= len(m.MaxAge)
		copy(dAtA[i:], m.MaxAge)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MaxAge)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ExposeHeaders) > 0 {
		i -= len(m.ExposeHeaders)
		copy(dAtA[i:], m.ExposeHeaders)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ExposeHeaders)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AllowHeaders) > 0 {
		i -= len(m.AllowHeaders)
		copy(dAtA[i:], m.AllowHeaders)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AllowHeaders)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AllowMethods) > 0 {
		i -= len(m.AllowMethods)
		copy(dAtA[i:], m.AllowMethods)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AllowMethods)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AllowOriginRegex) > 0 {
		for iNdEx := len(m.AllowOriginRegex) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowOriginRegex[iNdEx])
			copy(dAtA[i:], m.AllowOriginRegex[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AllowOriginRegex[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.AllowOrigin) > 0 {
		for iNdEx := len(m.AllowOrigin) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowOrigin[iNdEx])
			copy(dAtA[i:], m.AllowOrigin[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AllowOrigin[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Disabled {
		i--
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PathMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PathMatch != nil {
		{
			size := m.PathMatch.Size()
			i -= size
			if _, err := m.PathMatch.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *PathMatcherType_Prefix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathMatcherType_Prefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Prefix)
	copy(dAtA[i:], m.Prefix)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Prefix)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *PathMatcherType_Path) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathMatcherType_Path) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Path)
	copy(dAtA[i:], m.Path)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Path)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *PathMatcherType_Regex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathMatcherType_Regex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Regex)
	copy(dAtA[i:], m.Regex)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Regex)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeaderMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InvertMatch {
		i--
		if m.InvertMatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.ValueMatch != nil {
		{
			size := m.ValueMatch.Size()
			i -= size
			if _, err := m.ValueMatch.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HeaderMatcherType_Exact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherType_Exact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Exact)
	copy(dAtA[i:], m.Exact)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Exact)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherType_Regex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherType_Regex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Regex)
	copy(dAtA[i:], m.Regex)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Regex)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *HeaderMatcherType_Presence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeaderMatcherType_Presence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Presence {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *QueryParameterMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParameterMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParameterMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValueMatch != nil {
		{
			size := m.ValueMatch.Size()
			i -= size
			if _, err := m.ValueMatch.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryParameterMatcherType_Exact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParameterMatcherType_Exact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Exact)
	copy(dAtA[i:], m.Exact)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Exact)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *QueryParameterMatcherType_Regex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParameterMatcherType_Regex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Regex)
	copy(dAtA[i:], m.Regex)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Regex)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *RouteMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HttpMethod != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.HttpMethod))
		i--
		dAtA[i] = 0x20
	}
	if len(m.QueryParams) > 0 {
		for iNdEx := len(m.QueryParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QueryParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Headers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Path != nil {
		{
			size, err := m.Path.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WafRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WafRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Waf) > 0 {
		for iNdEx := len(m.Waf) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Waf[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WafRulesRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WafRulesRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafRulesRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.WafRules) > 0 {
		for iNdEx := len(m.WafRules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WafRules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AppFirewallRefType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppFirewallRefType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppFirewallRefType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AppFirewall) > 0 {
		for iNdEx := len(m.AppFirewall) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AppFirewall[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WafType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WafType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RefType != nil {
		{
			size := m.RefType.Size()
			i -= size
			if _, err := m.RefType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *WafType_Waf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafType_Waf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Waf != nil {
		{
			size, err := m.Waf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *WafType_WafRules) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafType_WafRules) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.WafRules != nil {
		{
			size, err := m.WafRules.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *WafType_AppFirewall) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WafType_AppFirewall) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AppFirewall != nil {
		{
			size, err := m.AppFirewall.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AppRoleAuthInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppRoleAuthInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppRoleAuthInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SecretId != nil {
		{
			size, err := m.SecretId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.RoleId) > 0 {
		i -= len(m.RoleId)
		copy(dAtA[i:], m.RoleId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RoleId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VaultAuthInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VaultAuthInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultAuthInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthParams != nil {
		{
			size := m.AuthParams.Size()
			i -= size
			if _, err := m.AuthParams.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *VaultAuthInfoType_AppRoleAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultAuthInfoType_AppRoleAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AppRoleAuth != nil {
		{
			size, err := m.AppRoleAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *VaultAuthInfoType_Token) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultAuthInfoType_Token) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *RestAuthInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestAuthInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestAuthInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthParams != nil {
		{
			size := m.AuthParams.Size()
			i -= size
			if _, err := m.AuthParams.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RestAuthInfoType_BasicAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestAuthInfoType_BasicAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BasicAuth != nil {
		{
			size, err := m.BasicAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *RestAuthInfoType_HeadersAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestAuthInfoType_HeadersAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HeadersAuth != nil {
		{
			size, err := m.HeadersAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *RestAuthInfoType_QueryParamsAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestAuthInfoType_QueryParamsAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.QueryParamsAuth != nil {
		{
			size, err := m.QueryParamsAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *HostAccessInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostAccessInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HostAccessInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthParams != nil {
		{
			size := m.AuthParams.Size()
			i -= size
			if _, err := m.AuthParams.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.TlsConfig != nil {
		{
			size, err := m.TlsConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ServerEndpoint) > 0 {
		i -= len(m.ServerEndpoint)
		copy(dAtA[i:], m.ServerEndpoint)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ServerEndpoint)))
		i--
		dAtA[i] = 0x12
	}
	if m.Scheme != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Scheme))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HostAccessInfoType_RestAuthInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HostAccessInfoType_RestAuthInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RestAuthInfo != nil {
		{
			size, err := m.RestAuthInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *HostAccessInfoType_VaultAuthInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HostAccessInfoType_VaultAuthInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VaultAuthInfo != nil {
		{
			size, err := m.VaultAuthInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *VaultAccessInfoType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VaultAccessInfoType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultAccessInfoType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthnChoice != nil {
		{
			size := m.AuthnChoice.Size()
			i -= size
			if _, err := m.AuthnChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.VaultCaUrl) > 0 {
		i -= len(m.VaultCaUrl)
		copy(dAtA[i:], m.VaultCaUrl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VaultCaUrl)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VaultAddr) > 0 {
		i -= len(m.VaultAddr)
		copy(dAtA[i:], m.VaultAddr)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VaultAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VaultAccessInfoType_AppRoleAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultAccessInfoType_AppRoleAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AppRoleAuth != nil {
		{
			size, err := m.AppRoleAuth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *VaultAccessInfoType_Token) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultAccessInfoType_Token) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *VaultSecretType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VaultSecretType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultSecretType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SecretVersion) > 0 {
		i -= len(m.SecretVersion)
		copy(dAtA[i:], m.SecretVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SecretVersion)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SecretSubPath) > 0 {
		i -= len(m.SecretSubPath)
		copy(dAtA[i:], m.SecretSubPath)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SecretSubPath)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SecretPath) > 0 {
		i -= len(m.SecretPath)
		copy(dAtA[i:], m.SecretPath)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SecretPath)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AccessChoice != nil {
		{
			size := m.AccessChoice.Size()
			i -= size
			if _, err := m.AccessChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *VaultSecretType_VaultAccessInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultSecretType_VaultAccessInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VaultAccessInfo != nil {
		{
			size, err := m.VaultAccessInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *VaultSecretType_ProviderName) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VaultSecretType_ProviderName) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ProviderName)
	copy(dAtA[i:], m.ProviderName)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.ProviderName)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *VolterraSecretType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolterraSecretType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VolterraSecretType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SecretTypeChoice != nil {
		{
			size := m.SecretTypeChoice.Size()
			i -= size
			if _, err := m.SecretTypeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *VolterraSecretType_BlindfoldSecretInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VolterraSecretType_BlindfoldSecretInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BlindfoldSecretInfo != nil {
		{
			size, err := m.BlindfoldSecretInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *VolterraSecretType_VaultSecretInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VolterraSecretType_VaultSecretInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VaultSecretInfo != nil {
		{
			size, err := m.VaultSecretInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *PortValueType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortValueType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortValueType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PortValueTypeChoice != nil {
		{
			size := m.PortValueTypeChoice.Size()
			i -= size
			if _, err := m.PortValueTypeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *PortValueType_All) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortValueType_All) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.All != nil {
		{
			size, err := m.All.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *PortValueType_UserDefined) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortValueType_UserDefined) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.UserDefined))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *PortValueType_Dns) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PortValueType_Dns) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Dns != nil {
		{
			size, err := m.Dns.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *VirtualNetworkReferenceType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualNetworkReferenceType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VirtualNetworkReferenceType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Refs) > 0 {
		for iNdEx := len(m.Refs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Refs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VirtualNetworkSelectorType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualNetworkSelectorType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VirtualNetworkSelectorType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VnTypeChoice != nil {
		{
			size := m.VnTypeChoice.Size()
			i -= size
			if _, err := m.VnTypeChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *VirtualNetworkSelectorType_SiteLocal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VirtualNetworkSelectorType_SiteLocal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteLocal != nil {
		{
			size, err := m.SiteLocal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *VirtualNetworkSelectorType_SiteLocalInside) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VirtualNetworkSelectorType_SiteLocalInside) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteLocalInside != nil {
		{
			size, err := m.SiteLocalInside.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *VirtualNetworkSelectorType_Public) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VirtualNetworkSelectorType_Public) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Public != nil {
		{
			size, err := m.Public.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *RetryBackOff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetryBackOff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RetryBackOff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxInterval != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxInterval))
		i--
		dAtA[i] = 0x10
	}
	if m.BaseInterval != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BaseInterval))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RetryPolicyType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetryPolicyType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RetryPolicyType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RetryCondition) > 0 {
		for iNdEx := len(m.RetryCondition) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RetryCondition[iNdEx])
			copy(dAtA[i:], m.RetryCondition[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RetryCondition[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.BackOff != nil {
		{
			size, err := m.BackOff.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RetriableStatusCodes) > 0 {
		dAtA66 := make([]byte, len(m.RetriableStatusCodes)*10)
		var j65 int
		for _, num := range m.RetriableStatusCodes {
			for num >= 1<<7 {
				dAtA66[j65] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j65++
			}
			dAtA66[j65] = uint8(num)
			j65++
		}
		i -= j65
		copy(dAtA[i:], dAtA66[:j65])
		i = encodeVarintTypes(dAtA, i, uint64(j65))
		i--
		dAtA[i] = 0x22
	}
	if m.PerTryTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PerTryTimeout))
		i--
		dAtA[i] = 0x18
	}
	if m.NumRetries != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NumRetries))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RetryOn) > 0 {
		i -= len(m.RetryOn)
		copy(dAtA[i:], m.RetryOn)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RetryOn)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetricValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Timestamp))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *NextHopType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NextHopType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NextHopType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Interface) > 0 {
		for iNdEx := len(m.Interface) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Interface[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.NexthopAddress != nil {
		{
			size, err := m.NexthopAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StaticRouteType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaticRouteType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StaticRouteType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		keysForLabels := make([]string, 0, len(m.Labels))
		for k := range m.Labels {
			keysForLabels = append(keysForLabels, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
		for iNdEx := len(keysForLabels) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Labels[string(keysForLabels[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForLabels[iNdEx])
			copy(dAtA[i:], keysForLabels[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForLabels[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.Nexthop != nil {
		{
			size, err := m.Nexthop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Subnets) > 0 {
		for iNdEx := len(m.Subnets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subnets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Attrs) > 0 {
		dAtA70 := make([]byte, len(m.Attrs)*10)
		var j69 int
		for _, num := range m.Attrs {
			for num >= 1<<7 {
				dAtA70[j69] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j69++
			}
			dAtA70[j69] = uint8(num)
			j69++
		}
		i -= j69
		copy(dAtA[i:], dAtA70[:j69])
		i = encodeVarintTypes(dAtA, i, uint64(j69))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ForwardProxyConfigType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForwardProxyConfigType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForwardProxyConfigType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TlsInterceptionChoice != nil {
		{
			size := m.TlsInterceptionChoice.Size()
			i -= size
			if _, err := m.TlsInterceptionChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ConnectionTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ConnectionTimeout))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxConnectAttempts != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxConnectAttempts))
		i--
		dAtA[i] = 0x18
	}
	if len(m.WhiteListedPorts) > 0 {
		dAtA72 := make([]byte, len(m.WhiteListedPorts)*10)
		var j71 int
		for _, num := range m.WhiteListedPorts {
			for num >= 1<<7 {
				dAtA72[j71] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j71++
			}
			dAtA72[j71] = uint8(num)
			j71++
		}
		i -= j71
		copy(dAtA[i:], dAtA72[:j71])
		i = encodeVarintTypes(dAtA, i, uint64(j71))
		i--
		dAtA[i] = 0x12
	}
	if len(m.WhiteListedPrefixes) > 0 {
		for iNdEx := len(m.WhiteListedPrefixes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.WhiteListedPrefixes[iNdEx])
			copy(dAtA[i:], m.WhiteListedPrefixes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.WhiteListedPrefixes[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ForwardProxyConfigType_NoInterception) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForwardProxyConfigType_NoInterception) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoInterception != nil {
		{
			size, err := m.NoInterception.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *ForwardProxyConfigType_TlsIntercept) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForwardProxyConfigType_TlsIntercept) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TlsIntercept != nil {
		{
			size, err := m.TlsIntercept.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *HostIdentifier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostIdentifier) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HostIdentifier) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HostnameOrIp != nil {
		{
			size := m.HostnameOrIp.Size()
			i -= size
			if _, err := m.HostnameOrIp.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *HostIdentifier_Ip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HostIdentifier_Ip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Ip)
	copy(dAtA[i:], m.Ip)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Ip)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *HostIdentifier_Hostname) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HostIdentifier_Hostname) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Hostname)
	copy(dAtA[i:], m.Hostname)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Hostname)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *InterfaceIdentifier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceIdentifier) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceIdentifier) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InterfaceChoice != nil {
		{
			size := m.InterfaceChoice.Size()
			i -= size
			if _, err := m.InterfaceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceIdentifier_AnyIntf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceIdentifier_AnyIntf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AnyIntf != nil {
		{
			size, err := m.AnyIntf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *InterfaceIdentifier_Intf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceIdentifier_Intf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Intf)
	copy(dAtA[i:], m.Intf)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Intf)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *InterfaceOrNetwork) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceOrNetwork) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceOrNetwork) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InterfaceChoice != nil {
		{
			size := m.InterfaceChoice.Size()
			i -= size
			if _, err := m.InterfaceChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceOrNetwork_Intf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceOrNetwork_Intf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Intf)
	copy(dAtA[i:], m.Intf)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Intf)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *InterfaceOrNetwork_Pod) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceOrNetwork_Pod) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Pod)
	copy(dAtA[i:], m.Pod)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Pod)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *InterfaceOrNetwork_VnType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceOrNetwork_VnType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.VnType))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *InterfaceOrNetwork_Vn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceOrNetwork_Vn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Vn)
	copy(dAtA[i:], m.Vn)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Vn)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *RouteTarget2ByteAsn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTarget2ByteAsn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTarget2ByteAsn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x20
	}
	if m.AsNumber != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AsNumber))
		i--
		dAtA[i] = 0x18
	}
	return len(dAtA) - i, nil
}

func (m *RouteTarget4ByteAsn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTarget4ByteAsn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTarget4ByteAsn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x20
	}
	if m.AsNumber != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AsNumber))
		i--
		dAtA[i] = 0x18
	}
	return len(dAtA) - i, nil
}

func (m *RouteTargetIPv4Addr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTargetIPv4Addr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTargetIPv4Addr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RouteTarget) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RtargetChoice != nil {
		{
			size := m.RtargetChoice.Size()
			i -= size
			if _, err := m.RtargetChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RouteTarget_Asn2ByteRtarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTarget_Asn2ByteRtarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Asn2ByteRtarget != nil {
		{
			size, err := m.Asn2ByteRtarget.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *RouteTarget_Ipv4AddrRtarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTarget_Ipv4AddrRtarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ipv4AddrRtarget != nil {
		{
			size, err := m.Ipv4AddrRtarget.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *RouteTarget_Asn4ByteRtarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteTarget_Asn4ByteRtarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Asn4ByteRtarget != nil {
		{
			size, err := m.Asn4ByteRtarget.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ObjectRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *LabelSelectorType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Expressions) > 0 {
		for _, s := range m.Expressions {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *LabelMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ConditionType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LastUpdateTime != nil {
		l = m.LastUpdateTime.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovTypes(uint64(m.Code))
	}
	return n
}

func (m *InitializerType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *InitializersType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Pending) > 0 {
		for _, e := range m.Pending {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Result != nil {
		l = m.Result.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *StatusMetaType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CreatorClass)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CreatorId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.StatusId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreationTimestamp != nil {
		l = m.CreationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Publish != 0 {
		n += 1 + sovTypes(uint64(m.Publish))
	}
	l = len(m.VtrpId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ObjectMetaType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Disable {
		n += 2
	}
	return n
}

func (m *ListMetaType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ObjectGetMetaType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Disable {
		n += 2
	}
	return n
}

func (m *ObjectCreateMetaType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Disable {
		n += 2
	}
	return n
}

func (m *ObjectReplaceMetaType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Disable {
		n += 2
	}
	return n
}

func (m *MessageMetaType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Disable {
		n += 2
	}
	return n
}

func (m *ViewRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *KubeRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SystemObjectMetaType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreationTimestamp != nil {
		l = m.CreationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DeletionTimestamp != nil {
		l = m.DeletionTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ModificationTimestamp != nil {
		l = m.ModificationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Initializers != nil {
		l = m.Initializers.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Finalizers) > 0 {
		for _, s := range m.Finalizers {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CreatorClass)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CreatorId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TraceInfo)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ObjectIndex != 0 {
		n += 1 + sovTypes(uint64(m.ObjectIndex))
	}
	if len(m.Namespace) > 0 {
		for _, e := range m.Namespace {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.CreatorCookie)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OwnerView != nil {
		l = m.OwnerView.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SreDisable {
		n += 3
	}
	l = len(m.VtrpId)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SystemObjectGetMetaType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreationTimestamp != nil {
		l = m.CreationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DeletionTimestamp != nil {
		l = m.DeletionTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ModificationTimestamp != nil {
		l = m.ModificationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Initializers != nil {
		l = m.Initializers.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Finalizers) > 0 {
		for _, s := range m.Finalizers {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CreatorClass)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CreatorId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ObjectIndex != 0 {
		n += 1 + sovTypes(uint64(m.ObjectIndex))
	}
	if m.OwnerView != nil {
		l = m.OwnerView.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AuthnTypeBasicAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Password != nil {
		l = m.Password.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AuthnTypeHeaders) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Headers) > 0 {
		for k, v := range m.Headers {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AuthnTypeQueryParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.QueryParams) > 0 {
		for k, v := range m.QueryParams {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *BlindfoldSecretInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DecryptionProvider)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.StoreProvider)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *VaultSecretInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovTypes(uint64(m.Version))
	}
	if m.SecretEncoding != 0 {
		n += 1 + sovTypes(uint64(m.SecretEncoding))
	}
	return n
}

func (m *ClearSecretInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *WingmanSecretInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SecretType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SecretInfoOneof != nil {
		n += m.SecretInfoOneof.Size()
	}
	if m.SecretEncodingType != 0 {
		n += 1 + sovTypes(uint64(m.SecretEncodingType))
	}
	if m.BlindfoldSecretInfoInternal != nil {
		l = m.BlindfoldSecretInfoInternal.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SecretType_BlindfoldSecretInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlindfoldSecretInfo != nil {
		l = m.BlindfoldSecretInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SecretType_VaultSecretInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VaultSecretInfo != nil {
		l = m.VaultSecretInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SecretType_ClearSecretInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClearSecretInfo != nil {
		l = m.ClearSecretInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SecretType_WingmanSecretInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WingmanSecretInfo != nil {
		l = m.WingmanSecretInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, e := range m.Ref {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *SiteRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, e := range m.Ref {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.NetworkType != 0 {
		n += 1 + sovTypes(uint64(m.NetworkType))
	}
	return n
}

func (m *IpPrefixSetRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, e := range m.Ref {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *VSiteRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, e := range m.Ref {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.NetworkType != 0 {
		n += 1 + sovTypes(uint64(m.NetworkType))
	}
	return n
}

func (m *PolicerRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, e := range m.Ref {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ProtocolPolicerRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ref) > 0 {
		for _, e := range m.Ref {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *NetworkSiteRefSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RefOrSelector != nil {
		n += m.RefOrSelector.Size()
	}
	return n
}

func (m *NetworkSiteRefSelector_VirtualNetwork) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VirtualNetwork != nil {
		l = m.VirtualNetwork.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkSiteRefSelector_Site) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Site != nil {
		l = m.Site.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *NetworkSiteRefSelector_VirtualSite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VirtualSite != nil {
		l = m.VirtualSite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SiteVirtualSiteRefSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RefOrSelector != nil {
		n += m.RefOrSelector.Size()
	}
	return n
}

func (m *SiteVirtualSiteRefSelector_Site) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Site != nil {
		l = m.Site.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SiteVirtualSiteRefSelector_VirtualSite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VirtualSite != nil {
		l = m.VirtualSite.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HeaderManipulationOptionType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Append {
		n += 2
	}
	return n
}

func (m *TlsValidationParamsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TrustedCaUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SkipHostnameVerification {
		n += 2
	}
	if len(m.VerifySubjectAltNames) > 0 {
		for _, s := range m.VerifySubjectAltNames {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.UseVolterraTrustedCaUrl {
		n += 2
	}
	return n
}

func (m *TlsCertificateType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CertificateUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PrivateKey != nil {
		l = m.PrivateKey.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *TlsParamsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinimumProtocolVersion != 0 {
		n += 1 + sovTypes(uint64(m.MinimumProtocolVersion))
	}
	if m.MaximumProtocolVersion != 0 {
		n += 1 + sovTypes(uint64(m.MaximumProtocolVersion))
	}
	if len(m.CipherSuites) > 0 {
		for _, s := range m.CipherSuites {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.TlsCertificates) > 0 {
		for _, e := range m.TlsCertificates {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.TrustedCaUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ValidationParams != nil {
		l = m.ValidationParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *UpstreamTlsParamsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommonParams != nil {
		l = m.CommonParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SniChoice != nil {
		n += m.SniChoice.Size()
	}
	return n
}

func (m *UpstreamTlsParamsType_Sni) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sni)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *UpstreamTlsParamsType_UseHostHeaderAsSni) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UseHostHeaderAsSni != nil {
		l = m.UseHostHeaderAsSni.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *UpstreamTlsParamsType_DisableSni) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableSni != nil {
		l = m.DisableSni.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DownstreamTlsParamsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommonParams != nil {
		l = m.CommonParams.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RequireClientCertificate {
		n += 2
	}
	return n
}

func (m *DomainType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DomainChoice != nil {
		n += m.DomainChoice.Size()
	}
	return n
}

func (m *DomainType_ExactValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExactValue)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *DomainType_SuffixValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SuffixValue)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *DomainType_RegexValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RegexValue)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *L4DestType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Prefixes) > 0 {
		for _, s := range m.Prefixes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.PortRanges)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *TlsInterceptionRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DomainMatch != nil {
		l = m.DomainMatch.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EnableDisableChoice != nil {
		n += m.EnableDisableChoice.Size()
	}
	return n
}

func (m *TlsInterceptionRule_DisableInterception) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisableInterception != nil {
		l = m.DisableInterception.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TlsInterceptionRule_EnableInterception) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableInterception != nil {
		l = m.EnableInterception.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TlsInterceptionPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.InterceptionRules) > 0 {
		for _, e := range m.InterceptionRules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *TlsInterceptionType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InterceptionPolicyChoice != nil {
		n += m.InterceptionPolicyChoice.Size()
	}
	if m.SigningCertChoice != nil {
		n += m.SigningCertChoice.Size()
	}
	if m.TrustedCaChoice != nil {
		n += m.TrustedCaChoice.Size()
	}
	return n
}

func (m *TlsInterceptionType_Policy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TlsInterceptionType_CustomCertificate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CustomCertificate != nil {
		l = m.CustomCertificate.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TlsInterceptionType_VolterraCertificate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VolterraCertificate != nil {
		l = m.VolterraCertificate.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TlsInterceptionType_TrustedCaUrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TrustedCaUrl)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *TlsInterceptionType_VolterraTrustedCa) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VolterraTrustedCa != nil {
		l = m.VolterraTrustedCa.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *TlsInterceptionType_EnableForAllDomains) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnableForAllDomains != nil {
		l = m.EnableForAllDomains.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *FractionalPercent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Numerator != 0 {
		n += 1 + sovTypes(uint64(m.Numerator))
	}
	if m.Denominator != 0 {
		n += 1 + sovTypes(uint64(m.Denominator))
	}
	return n
}

func (m *BufferConfigType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Disabled {
		n += 2
	}
	if m.MaxRequestBytes != 0 {
		n += 1 + sovTypes(uint64(m.MaxRequestBytes))
	}
	if m.MaxRequestTime != 0 {
		n += 1 + sovTypes(uint64(m.MaxRequestTime))
	}
	return n
}

func (m *CorsPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Disabled {
		n += 2
	}
	if len(m.AllowOrigin) > 0 {
		for _, s := range m.AllowOrigin {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AllowOriginRegex) > 0 {
		for _, s := range m.AllowOriginRegex {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.AllowMethods)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AllowHeaders)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ExposeHeaders)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.MaxAge)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AllowCredentials {
		n += 2
	}
	if m.MaximumAge != 0 {
		n += 1 + sovTypes(uint64(m.MaximumAge))
	}
	return n
}

func (m *PathMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PathMatch != nil {
		n += m.PathMatch.Size()
	}
	return n
}

func (m *PathMatcherType_Prefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Prefix)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *PathMatcherType_Path) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *PathMatcherType_Regex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Regex)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *HeaderMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ValueMatch != nil {
		n += m.ValueMatch.Size()
	}
	if m.InvertMatch {
		n += 2
	}
	return n
}

func (m *HeaderMatcherType_Exact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Exact)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *HeaderMatcherType_Regex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Regex)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *HeaderMatcherType_Presence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *QueryParameterMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ValueMatch != nil {
		n += m.ValueMatch.Size()
	}
	return n
}

func (m *QueryParameterMatcherType_Exact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Exact)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *QueryParameterMatcherType_Regex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Regex)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *RouteMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Path != nil {
		l = m.Path.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Headers) > 0 {
		for _, e := range m.Headers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.QueryParams) > 0 {
		for _, e := range m.QueryParams {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.HttpMethod != 0 {
		n += 1 + sovTypes(uint64(m.HttpMethod))
	}
	return n
}

func (m *WafRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Waf) > 0 {
		for _, e := range m.Waf {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *WafRulesRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.WafRules) > 0 {
		for _, e := range m.WafRules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AppFirewallRefType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AppFirewall) > 0 {
		for _, e := range m.AppFirewall {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *WafType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RefType != nil {
		n += m.RefType.Size()
	}
	return n
}

func (m *WafType_Waf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Waf != nil {
		l = m.Waf.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WafType_WafRules) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WafRules != nil {
		l = m.WafRules.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *WafType_AppFirewall) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppFirewall != nil {
		l = m.AppFirewall.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *AppRoleAuthInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RoleId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SecretId != nil {
		l = m.SecretId.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *VaultAuthInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthParams != nil {
		n += m.AuthParams.Size()
	}
	return n
}

func (m *VaultAuthInfoType_AppRoleAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppRoleAuth != nil {
		l = m.AppRoleAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VaultAuthInfoType_Token) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RestAuthInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthParams != nil {
		n += m.AuthParams.Size()
	}
	return n
}

func (m *RestAuthInfoType_BasicAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BasicAuth != nil {
		l = m.BasicAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RestAuthInfoType_HeadersAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HeadersAuth != nil {
		l = m.HeadersAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RestAuthInfoType_QueryParamsAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryParamsAuth != nil {
		l = m.QueryParamsAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HostAccessInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scheme != 0 {
		n += 1 + sovTypes(uint64(m.Scheme))
	}
	l = len(m.ServerEndpoint)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TlsConfig != nil {
		l = m.TlsConfig.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AuthParams != nil {
		n += m.AuthParams.Size()
	}
	return n
}

func (m *HostAccessInfoType_RestAuthInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RestAuthInfo != nil {
		l = m.RestAuthInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HostAccessInfoType_VaultAuthInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VaultAuthInfo != nil {
		l = m.VaultAuthInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VaultAccessInfoType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VaultAddr)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VaultCaUrl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AuthnChoice != nil {
		n += m.AuthnChoice.Size()
	}
	return n
}

func (m *VaultAccessInfoType_AppRoleAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppRoleAuth != nil {
		l = m.AppRoleAuth.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VaultAccessInfoType_Token) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VaultSecretType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccessChoice != nil {
		n += m.AccessChoice.Size()
	}
	l = len(m.SecretPath)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SecretSubPath)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SecretVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *VaultSecretType_VaultAccessInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VaultAccessInfo != nil {
		l = m.VaultAccessInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VaultSecretType_ProviderName) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProviderName)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *VolterraSecretType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SecretTypeChoice != nil {
		n += m.SecretTypeChoice.Size()
	}
	return n
}

func (m *VolterraSecretType_BlindfoldSecretInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlindfoldSecretInfo != nil {
		l = m.BlindfoldSecretInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VolterraSecretType_VaultSecretInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VaultSecretInfo != nil {
		l = m.VaultSecretInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PortValueType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortValueTypeChoice != nil {
		n += m.PortValueTypeChoice.Size()
	}
	return n
}

func (m *PortValueType_All) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.All != nil {
		l = m.All.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PortValueType_UserDefined) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.UserDefined))
	return n
}
func (m *PortValueType_Dns) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dns != nil {
		l = m.Dns.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VirtualNetworkReferenceType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Refs) > 0 {
		for _, e := range m.Refs {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *VirtualNetworkSelectorType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VnTypeChoice != nil {
		n += m.VnTypeChoice.Size()
	}
	return n
}

func (m *VirtualNetworkSelectorType_SiteLocal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteLocal != nil {
		l = m.SiteLocal.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VirtualNetworkSelectorType_SiteLocalInside) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteLocalInside != nil {
		l = m.SiteLocalInside.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *VirtualNetworkSelectorType_Public) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Public != nil {
		l = m.Public.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RetryBackOff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BaseInterval != 0 {
		n += 1 + sovTypes(uint64(m.BaseInterval))
	}
	if m.MaxInterval != 0 {
		n += 1 + sovTypes(uint64(m.MaxInterval))
	}
	return n
}

func (m *RetryPolicyType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RetryOn)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NumRetries != 0 {
		n += 1 + sovTypes(uint64(m.NumRetries))
	}
	if m.PerTryTimeout != 0 {
		n += 1 + sovTypes(uint64(m.PerTryTimeout))
	}
	if len(m.RetriableStatusCodes) > 0 {
		l = 0
		for _, e := range m.RetriableStatusCodes {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.BackOff != nil {
		l = m.BackOff.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.RetryCondition) > 0 {
		for _, s := range m.RetryCondition {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *MetricValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 9
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *NextHopType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.NexthopAddress != nil {
		l = m.NexthopAddress.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Interface) > 0 {
		for _, e := range m.Interface {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *StaticRouteType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attrs) > 0 {
		l = 0
		for _, e := range m.Attrs {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.Subnets) > 0 {
		for _, e := range m.Subnets {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Nexthop != nil {
		l = m.Nexthop.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ForwardProxyConfigType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.WhiteListedPrefixes) > 0 {
		for _, s := range m.WhiteListedPrefixes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.WhiteListedPorts) > 0 {
		l = 0
		for _, e := range m.WhiteListedPorts {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.MaxConnectAttempts != 0 {
		n += 1 + sovTypes(uint64(m.MaxConnectAttempts))
	}
	if m.ConnectionTimeout != 0 {
		n += 1 + sovTypes(uint64(m.ConnectionTimeout))
	}
	if m.TlsInterceptionChoice != nil {
		n += m.TlsInterceptionChoice.Size()
	}
	return n
}

func (m *ForwardProxyConfigType_NoInterception) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoInterception != nil {
		l = m.NoInterception.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ForwardProxyConfigType_TlsIntercept) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TlsIntercept != nil {
		l = m.TlsIntercept.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *HostIdentifier) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HostnameOrIp != nil {
		n += m.HostnameOrIp.Size()
	}
	return n
}

func (m *HostIdentifier_Ip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ip)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *HostIdentifier_Hostname) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hostname)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *InterfaceIdentifier) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InterfaceChoice != nil {
		n += m.InterfaceChoice.Size()
	}
	return n
}

func (m *InterfaceIdentifier_AnyIntf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AnyIntf != nil {
		l = m.AnyIntf.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *InterfaceIdentifier_Intf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Intf)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *InterfaceOrNetwork) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InterfaceChoice != nil {
		n += m.InterfaceChoice.Size()
	}
	return n
}

func (m *InterfaceOrNetwork_Intf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Intf)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *InterfaceOrNetwork_Pod) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Pod)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *InterfaceOrNetwork_VnType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.VnType))
	return n
}
func (m *InterfaceOrNetwork_Vn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Vn)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *RouteTarget2ByteAsn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AsNumber != 0 {
		n += 1 + sovTypes(uint64(m.AsNumber))
	}
	if m.Value != 0 {
		n += 1 + sovTypes(uint64(m.Value))
	}
	return n
}

func (m *RouteTarget4ByteAsn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AsNumber != 0 {
		n += 1 + sovTypes(uint64(m.AsNumber))
	}
	if m.Value != 0 {
		n += 1 + sovTypes(uint64(m.Value))
	}
	return n
}

func (m *RouteTargetIPv4Addr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovTypes(uint64(m.Value))
	}
	return n
}

func (m *RouteTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RtargetChoice != nil {
		n += m.RtargetChoice.Size()
	}
	return n
}

func (m *RouteTarget_Asn2ByteRtarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Asn2ByteRtarget != nil {
		l = m.Asn2ByteRtarget.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteTarget_Ipv4AddrRtarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ipv4AddrRtarget != nil {
		l = m.Ipv4AddrRtarget.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *RouteTarget_Asn4ByteRtarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Asn4ByteRtarget != nil {
		l = m.Asn4ByteRtarget.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Empty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Empty{`,
		`}`,
	}, "")
	return s
}
func (this *ObjectRefType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ObjectRefType{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`Tenant:` + fmt.Sprintf("%v", this.Tenant) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LabelSelectorType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LabelSelectorType{`,
		`Expressions:` + fmt.Sprintf("%v", this.Expressions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LabelMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LabelMatcherType{`,
		`Keys:` + fmt.Sprintf("%v", this.Keys) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConditionType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConditionType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`LastUpdateTime:` + strings.Replace(fmt.Sprintf("%v", this.LastUpdateTime), "Timestamp", "types.Timestamp", 1) + `,`,
		`Hostname:` + fmt.Sprintf("%v", this.Hostname) + `,`,
		`ServiceName:` + fmt.Sprintf("%v", this.ServiceName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StatusType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StatusType{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InitializerType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InitializerType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InitializersType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPending := "[]*InitializerType{"
	for _, f := range this.Pending {
		repeatedStringForPending += strings.Replace(f.String(), "InitializerType", "InitializerType", 1) + ","
	}
	repeatedStringForPending += "}"
	s := strings.Join([]string{`&InitializersType{`,
		`Pending:` + repeatedStringForPending + `,`,
		`Result:` + strings.Replace(this.Result.String(), "StatusType", "StatusType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StatusMetaType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StatusMetaType{`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`CreatorClass:` + fmt.Sprintf("%v", this.CreatorClass) + `,`,
		`CreatorId:` + fmt.Sprintf("%v", this.CreatorId) + `,`,
		`StatusId:` + fmt.Sprintf("%v", this.StatusId) + `,`,
		`CreationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.CreationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`Publish:` + fmt.Sprintf("%v", this.Publish) + `,`,
		`VtrpId:` + fmt.Sprintf("%v", this.VtrpId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ObjectMetaType) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%v: %v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	s := strings.Join([]string{`&ObjectMetaType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Annotations:` + mapStringForAnnotations + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Disable:` + fmt.Sprintf("%v", this.Disable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListMetaType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListMetaType{`,
		`ResourceVersion:` + fmt.Sprintf("%v", this.ResourceVersion) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ObjectGetMetaType) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%v: %v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	s := strings.Join([]string{`&ObjectGetMetaType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Annotations:` + mapStringForAnnotations + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Disable:` + fmt.Sprintf("%v", this.Disable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ObjectCreateMetaType) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%v: %v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	s := strings.Join([]string{`&ObjectCreateMetaType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Annotations:` + mapStringForAnnotations + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Disable:` + fmt.Sprintf("%v", this.Disable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ObjectReplaceMetaType) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%v: %v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	s := strings.Join([]string{`&ObjectReplaceMetaType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Annotations:` + mapStringForAnnotations + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Disable:` + fmt.Sprintf("%v", this.Disable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MessageMetaType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MessageMetaType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`Disable:` + fmt.Sprintf("%v", this.Disable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ViewRefType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ViewRefType{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *KubeRefType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&KubeRefType{`,
		`Kind:` + fmt.Sprintf("%v", this.Kind) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SystemObjectMetaType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForNamespace := "[]*ObjectRefType{"
	for _, f := range this.Namespace {
		repeatedStringForNamespace += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForNamespace += "}"
	s := strings.Join([]string{`&SystemObjectMetaType{`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`CreationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.CreationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`DeletionTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.DeletionTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`ModificationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ModificationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`Initializers:` + strings.Replace(this.Initializers.String(), "InitializersType", "InitializersType", 1) + `,`,
		`Finalizers:` + fmt.Sprintf("%v", this.Finalizers) + `,`,
		`Tenant:` + fmt.Sprintf("%v", this.Tenant) + `,`,
		`CreatorClass:` + fmt.Sprintf("%v", this.CreatorClass) + `,`,
		`CreatorId:` + fmt.Sprintf("%v", this.CreatorId) + `,`,
		`TraceInfo:` + fmt.Sprintf("%v", this.TraceInfo) + `,`,
		`ObjectIndex:` + fmt.Sprintf("%v", this.ObjectIndex) + `,`,
		`Namespace:` + repeatedStringForNamespace + `,`,
		`CreatorCookie:` + fmt.Sprintf("%v", this.CreatorCookie) + `,`,
		`OwnerView:` + strings.Replace(this.OwnerView.String(), "ViewRefType", "ViewRefType", 1) + `,`,
		`SreDisable:` + fmt.Sprintf("%v", this.SreDisable) + `,`,
		`VtrpId:` + fmt.Sprintf("%v", this.VtrpId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SystemObjectGetMetaType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SystemObjectGetMetaType{`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`CreationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.CreationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`DeletionTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.DeletionTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`ModificationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ModificationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`Initializers:` + strings.Replace(this.Initializers.String(), "InitializersType", "InitializersType", 1) + `,`,
		`Finalizers:` + fmt.Sprintf("%v", this.Finalizers) + `,`,
		`Tenant:` + fmt.Sprintf("%v", this.Tenant) + `,`,
		`CreatorClass:` + fmt.Sprintf("%v", this.CreatorClass) + `,`,
		`CreatorId:` + fmt.Sprintf("%v", this.CreatorId) + `,`,
		`ObjectIndex:` + fmt.Sprintf("%v", this.ObjectIndex) + `,`,
		`OwnerView:` + strings.Replace(this.OwnerView.String(), "ViewRefType", "ViewRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthnTypeBasicAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthnTypeBasicAuth{`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`Password:` + strings.Replace(fmt.Sprintf("%v", this.Password), "SecretType", "SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthnTypeHeaders) String() string {
	if this == nil {
		return "nil"
	}
	keysForHeaders := make([]string, 0, len(this.Headers))
	for k, _ := range this.Headers {
		keysForHeaders = append(keysForHeaders, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHeaders)
	mapStringForHeaders := "map[string]*SecretType{"
	for _, k := range keysForHeaders {
		mapStringForHeaders += fmt.Sprintf("%v: %v,", k, this.Headers[k])
	}
	mapStringForHeaders += "}"
	s := strings.Join([]string{`&AuthnTypeHeaders{`,
		`Headers:` + mapStringForHeaders + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthnTypeQueryParams) String() string {
	if this == nil {
		return "nil"
	}
	keysForQueryParams := make([]string, 0, len(this.QueryParams))
	for k, _ := range this.QueryParams {
		keysForQueryParams = append(keysForQueryParams, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForQueryParams)
	mapStringForQueryParams := "map[string]*SecretType{"
	for _, k := range keysForQueryParams {
		mapStringForQueryParams += fmt.Sprintf("%v: %v,", k, this.QueryParams[k])
	}
	mapStringForQueryParams += "}"
	s := strings.Join([]string{`&AuthnTypeQueryParams{`,
		`QueryParams:` + mapStringForQueryParams + `,`,
		`}`,
	}, "")
	return s
}
func (this *BlindfoldSecretInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BlindfoldSecretInfoType{`,
		`DecryptionProvider:` + fmt.Sprintf("%v", this.DecryptionProvider) + `,`,
		`StoreProvider:` + fmt.Sprintf("%v", this.StoreProvider) + `,`,
		`Location:` + fmt.Sprintf("%v", this.Location) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultSecretInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultSecretInfoType{`,
		`Provider:` + fmt.Sprintf("%v", this.Provider) + `,`,
		`Location:` + fmt.Sprintf("%v", this.Location) + `,`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`SecretEncoding:` + fmt.Sprintf("%v", this.SecretEncoding) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ClearSecretInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ClearSecretInfoType{`,
		`Provider:` + fmt.Sprintf("%v", this.Provider) + `,`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WingmanSecretInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WingmanSecretInfoType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkRefType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRef := "[]*ObjectRefType{"
	for _, f := range this.Ref {
		repeatedStringForRef += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForRef += "}"
	s := strings.Join([]string{`&NetworkRefType{`,
		`Ref:` + repeatedStringForRef + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteRefType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRef := "[]*ObjectRefType{"
	for _, f := range this.Ref {
		repeatedStringForRef += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForRef += "}"
	s := strings.Join([]string{`&SiteRefType{`,
		`Ref:` + repeatedStringForRef + `,`,
		`NetworkType:` + fmt.Sprintf("%v", this.NetworkType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpPrefixSetRefType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRef := "[]*ObjectRefType{"
	for _, f := range this.Ref {
		repeatedStringForRef += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForRef += "}"
	s := strings.Join([]string{`&IpPrefixSetRefType{`,
		`Ref:` + repeatedStringForRef + `,`,
		`}`,
	}, "")
	return s
}
func (this *VSiteRefType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRef := "[]*ObjectRefType{"
	for _, f := range this.Ref {
		repeatedStringForRef += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForRef += "}"
	s := strings.Join([]string{`&VSiteRefType{`,
		`Ref:` + repeatedStringForRef + `,`,
		`NetworkType:` + fmt.Sprintf("%v", this.NetworkType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PolicerRefType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRef := "[]*ObjectRefType{"
	for _, f := range this.Ref {
		repeatedStringForRef += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForRef += "}"
	s := strings.Join([]string{`&PolicerRefType{`,
		`Ref:` + repeatedStringForRef + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProtocolPolicerRefType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRef := "[]*ObjectRefType{"
	for _, f := range this.Ref {
		repeatedStringForRef += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForRef += "}"
	s := strings.Join([]string{`&ProtocolPolicerRefType{`,
		`Ref:` + repeatedStringForRef + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkSiteRefSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkSiteRefSelector{`,
		`RefOrSelector:` + fmt.Sprintf("%v", this.RefOrSelector) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkSiteRefSelector_VirtualNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkSiteRefSelector_VirtualNetwork{`,
		`VirtualNetwork:` + strings.Replace(fmt.Sprintf("%v", this.VirtualNetwork), "NetworkRefType", "NetworkRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkSiteRefSelector_Site) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkSiteRefSelector_Site{`,
		`Site:` + strings.Replace(fmt.Sprintf("%v", this.Site), "SiteRefType", "SiteRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkSiteRefSelector_VirtualSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkSiteRefSelector_VirtualSite{`,
		`VirtualSite:` + strings.Replace(fmt.Sprintf("%v", this.VirtualSite), "VSiteRefType", "VSiteRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteVirtualSiteRefSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteVirtualSiteRefSelector{`,
		`RefOrSelector:` + fmt.Sprintf("%v", this.RefOrSelector) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteVirtualSiteRefSelector_Site) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteVirtualSiteRefSelector_Site{`,
		`Site:` + strings.Replace(fmt.Sprintf("%v", this.Site), "SiteRefType", "SiteRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteVirtualSiteRefSelector_VirtualSite) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SiteVirtualSiteRefSelector_VirtualSite{`,
		`VirtualSite:` + strings.Replace(fmt.Sprintf("%v", this.VirtualSite), "VSiteRefType", "VSiteRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderManipulationOptionType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderManipulationOptionType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Append:` + fmt.Sprintf("%v", this.Append) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsValidationParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsValidationParamsType{`,
		`TrustedCaUrl:` + fmt.Sprintf("%v", this.TrustedCaUrl) + `,`,
		`SkipHostnameVerification:` + fmt.Sprintf("%v", this.SkipHostnameVerification) + `,`,
		`VerifySubjectAltNames:` + fmt.Sprintf("%v", this.VerifySubjectAltNames) + `,`,
		`UseVolterraTrustedCaUrl:` + fmt.Sprintf("%v", this.UseVolterraTrustedCaUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsCertificateType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsCertificateType{`,
		`CertificateUrl:` + fmt.Sprintf("%v", this.CertificateUrl) + `,`,
		`PrivateKey:` + strings.Replace(fmt.Sprintf("%v", this.PrivateKey), "SecretType", "SecretType", 1) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsParamsType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTlsCertificates := "[]*TlsCertificateType{"
	for _, f := range this.TlsCertificates {
		repeatedStringForTlsCertificates += strings.Replace(f.String(), "TlsCertificateType", "TlsCertificateType", 1) + ","
	}
	repeatedStringForTlsCertificates += "}"
	s := strings.Join([]string{`&TlsParamsType{`,
		`MinimumProtocolVersion:` + fmt.Sprintf("%v", this.MinimumProtocolVersion) + `,`,
		`MaximumProtocolVersion:` + fmt.Sprintf("%v", this.MaximumProtocolVersion) + `,`,
		`CipherSuites:` + fmt.Sprintf("%v", this.CipherSuites) + `,`,
		`TlsCertificates:` + repeatedStringForTlsCertificates + `,`,
		`TrustedCaUrl:` + fmt.Sprintf("%v", this.TrustedCaUrl) + `,`,
		`ValidationParams:` + strings.Replace(this.ValidationParams.String(), "TlsValidationParamsType", "TlsValidationParamsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpstreamTlsParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpstreamTlsParamsType{`,
		`CommonParams:` + strings.Replace(this.CommonParams.String(), "TlsParamsType", "TlsParamsType", 1) + `,`,
		`SniChoice:` + fmt.Sprintf("%v", this.SniChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpstreamTlsParamsType_Sni) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpstreamTlsParamsType_Sni{`,
		`Sni:` + fmt.Sprintf("%v", this.Sni) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpstreamTlsParamsType_UseHostHeaderAsSni) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpstreamTlsParamsType_UseHostHeaderAsSni{`,
		`UseHostHeaderAsSni:` + strings.Replace(fmt.Sprintf("%v", this.UseHostHeaderAsSni), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpstreamTlsParamsType_DisableSni) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpstreamTlsParamsType_DisableSni{`,
		`DisableSni:` + strings.Replace(fmt.Sprintf("%v", this.DisableSni), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DownstreamTlsParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DownstreamTlsParamsType{`,
		`CommonParams:` + strings.Replace(this.CommonParams.String(), "TlsParamsType", "TlsParamsType", 1) + `,`,
		`RequireClientCertificate:` + fmt.Sprintf("%v", this.RequireClientCertificate) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DomainType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DomainType{`,
		`DomainChoice:` + fmt.Sprintf("%v", this.DomainChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DomainType_ExactValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DomainType_ExactValue{`,
		`ExactValue:` + fmt.Sprintf("%v", this.ExactValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DomainType_SuffixValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DomainType_SuffixValue{`,
		`SuffixValue:` + fmt.Sprintf("%v", this.SuffixValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DomainType_RegexValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DomainType_RegexValue{`,
		`RegexValue:` + fmt.Sprintf("%v", this.RegexValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *L4DestType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&L4DestType{`,
		`Prefixes:` + fmt.Sprintf("%v", this.Prefixes) + `,`,
		`PortRanges:` + fmt.Sprintf("%v", this.PortRanges) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionRule) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionRule{`,
		`DomainMatch:` + strings.Replace(this.DomainMatch.String(), "DomainType", "DomainType", 1) + `,`,
		`EnableDisableChoice:` + fmt.Sprintf("%v", this.EnableDisableChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionRule_DisableInterception) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionRule_DisableInterception{`,
		`DisableInterception:` + strings.Replace(fmt.Sprintf("%v", this.DisableInterception), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionRule_EnableInterception) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionRule_EnableInterception{`,
		`EnableInterception:` + strings.Replace(fmt.Sprintf("%v", this.EnableInterception), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionPolicy) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForInterceptionRules := "[]*TlsInterceptionRule{"
	for _, f := range this.InterceptionRules {
		repeatedStringForInterceptionRules += strings.Replace(f.String(), "TlsInterceptionRule", "TlsInterceptionRule", 1) + ","
	}
	repeatedStringForInterceptionRules += "}"
	s := strings.Join([]string{`&TlsInterceptionPolicy{`,
		`InterceptionRules:` + repeatedStringForInterceptionRules + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionType{`,
		`InterceptionPolicyChoice:` + fmt.Sprintf("%v", this.InterceptionPolicyChoice) + `,`,
		`SigningCertChoice:` + fmt.Sprintf("%v", this.SigningCertChoice) + `,`,
		`TrustedCaChoice:` + fmt.Sprintf("%v", this.TrustedCaChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionType_Policy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionType_Policy{`,
		`Policy:` + strings.Replace(fmt.Sprintf("%v", this.Policy), "TlsInterceptionPolicy", "TlsInterceptionPolicy", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionType_CustomCertificate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionType_CustomCertificate{`,
		`CustomCertificate:` + strings.Replace(fmt.Sprintf("%v", this.CustomCertificate), "TlsCertificateType", "TlsCertificateType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionType_VolterraCertificate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionType_VolterraCertificate{`,
		`VolterraCertificate:` + strings.Replace(fmt.Sprintf("%v", this.VolterraCertificate), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionType_TrustedCaUrl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionType_TrustedCaUrl{`,
		`TrustedCaUrl:` + fmt.Sprintf("%v", this.TrustedCaUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionType_VolterraTrustedCa) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionType_VolterraTrustedCa{`,
		`VolterraTrustedCa:` + strings.Replace(fmt.Sprintf("%v", this.VolterraTrustedCa), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TlsInterceptionType_EnableForAllDomains) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TlsInterceptionType_EnableForAllDomains{`,
		`EnableForAllDomains:` + strings.Replace(fmt.Sprintf("%v", this.EnableForAllDomains), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FractionalPercent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FractionalPercent{`,
		`Numerator:` + fmt.Sprintf("%v", this.Numerator) + `,`,
		`Denominator:` + fmt.Sprintf("%v", this.Denominator) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BufferConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BufferConfigType{`,
		`Disabled:` + fmt.Sprintf("%v", this.Disabled) + `,`,
		`MaxRequestBytes:` + fmt.Sprintf("%v", this.MaxRequestBytes) + `,`,
		`MaxRequestTime:` + fmt.Sprintf("%v", this.MaxRequestTime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CorsPolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CorsPolicy{`,
		`Disabled:` + fmt.Sprintf("%v", this.Disabled) + `,`,
		`AllowOrigin:` + fmt.Sprintf("%v", this.AllowOrigin) + `,`,
		`AllowOriginRegex:` + fmt.Sprintf("%v", this.AllowOriginRegex) + `,`,
		`AllowMethods:` + fmt.Sprintf("%v", this.AllowMethods) + `,`,
		`AllowHeaders:` + fmt.Sprintf("%v", this.AllowHeaders) + `,`,
		`ExposeHeaders:` + fmt.Sprintf("%v", this.ExposeHeaders) + `,`,
		`MaxAge:` + fmt.Sprintf("%v", this.MaxAge) + `,`,
		`AllowCredentials:` + fmt.Sprintf("%v", this.AllowCredentials) + `,`,
		`MaximumAge:` + fmt.Sprintf("%v", this.MaximumAge) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PathMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PathMatcherType{`,
		`PathMatch:` + fmt.Sprintf("%v", this.PathMatch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PathMatcherType_Prefix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PathMatcherType_Prefix{`,
		`Prefix:` + fmt.Sprintf("%v", this.Prefix) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PathMatcherType_Path) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PathMatcherType_Path{`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PathMatcherType_Regex) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PathMatcherType_Regex{`,
		`Regex:` + fmt.Sprintf("%v", this.Regex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`ValueMatch:` + fmt.Sprintf("%v", this.ValueMatch) + `,`,
		`InvertMatch:` + fmt.Sprintf("%v", this.InvertMatch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType_Exact) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType_Exact{`,
		`Exact:` + fmt.Sprintf("%v", this.Exact) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType_Regex) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType_Regex{`,
		`Regex:` + fmt.Sprintf("%v", this.Regex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HeaderMatcherType_Presence) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HeaderMatcherType_Presence{`,
		`Presence:` + fmt.Sprintf("%v", this.Presence) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryParameterMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryParameterMatcherType{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`ValueMatch:` + fmt.Sprintf("%v", this.ValueMatch) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryParameterMatcherType_Exact) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryParameterMatcherType_Exact{`,
		`Exact:` + fmt.Sprintf("%v", this.Exact) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueryParameterMatcherType_Regex) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueryParameterMatcherType_Regex{`,
		`Regex:` + fmt.Sprintf("%v", this.Regex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteMatch) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHeaders := "[]*HeaderMatcherType{"
	for _, f := range this.Headers {
		repeatedStringForHeaders += strings.Replace(f.String(), "HeaderMatcherType", "HeaderMatcherType", 1) + ","
	}
	repeatedStringForHeaders += "}"
	repeatedStringForQueryParams := "[]*QueryParameterMatcherType{"
	for _, f := range this.QueryParams {
		repeatedStringForQueryParams += strings.Replace(f.String(), "QueryParameterMatcherType", "QueryParameterMatcherType", 1) + ","
	}
	repeatedStringForQueryParams += "}"
	s := strings.Join([]string{`&RouteMatch{`,
		`Path:` + strings.Replace(this.Path.String(), "PathMatcherType", "PathMatcherType", 1) + `,`,
		`Headers:` + repeatedStringForHeaders + `,`,
		`QueryParams:` + repeatedStringForQueryParams + `,`,
		`HttpMethod:` + fmt.Sprintf("%v", this.HttpMethod) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafRefType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForWaf := "[]*ObjectRefType{"
	for _, f := range this.Waf {
		repeatedStringForWaf += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForWaf += "}"
	s := strings.Join([]string{`&WafRefType{`,
		`Waf:` + repeatedStringForWaf + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafRulesRefType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForWafRules := "[]*ObjectRefType{"
	for _, f := range this.WafRules {
		repeatedStringForWafRules += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForWafRules += "}"
	s := strings.Join([]string{`&WafRulesRefType{`,
		`WafRules:` + repeatedStringForWafRules + `,`,
		`}`,
	}, "")
	return s
}
func (this *AppFirewallRefType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAppFirewall := "[]*ObjectRefType{"
	for _, f := range this.AppFirewall {
		repeatedStringForAppFirewall += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForAppFirewall += "}"
	s := strings.Join([]string{`&AppFirewallRefType{`,
		`AppFirewall:` + repeatedStringForAppFirewall + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafType{`,
		`RefType:` + fmt.Sprintf("%v", this.RefType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafType_Waf) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafType_Waf{`,
		`Waf:` + strings.Replace(fmt.Sprintf("%v", this.Waf), "WafRefType", "WafRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafType_WafRules) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafType_WafRules{`,
		`WafRules:` + strings.Replace(fmt.Sprintf("%v", this.WafRules), "WafRulesRefType", "WafRulesRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WafType_AppFirewall) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WafType_AppFirewall{`,
		`AppFirewall:` + strings.Replace(fmt.Sprintf("%v", this.AppFirewall), "AppFirewallRefType", "AppFirewallRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AppRoleAuthInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AppRoleAuthInfoType{`,
		`RoleId:` + fmt.Sprintf("%v", this.RoleId) + `,`,
		`SecretId:` + strings.Replace(fmt.Sprintf("%v", this.SecretId), "SecretType", "SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultAuthInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultAuthInfoType{`,
		`AuthParams:` + fmt.Sprintf("%v", this.AuthParams) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultAuthInfoType_AppRoleAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultAuthInfoType_AppRoleAuth{`,
		`AppRoleAuth:` + strings.Replace(fmt.Sprintf("%v", this.AppRoleAuth), "AppRoleAuthInfoType", "AppRoleAuthInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultAuthInfoType_Token) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultAuthInfoType_Token{`,
		`Token:` + strings.Replace(fmt.Sprintf("%v", this.Token), "SecretType", "SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RestAuthInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RestAuthInfoType{`,
		`AuthParams:` + fmt.Sprintf("%v", this.AuthParams) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RestAuthInfoType_BasicAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RestAuthInfoType_BasicAuth{`,
		`BasicAuth:` + strings.Replace(fmt.Sprintf("%v", this.BasicAuth), "AuthnTypeBasicAuth", "AuthnTypeBasicAuth", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RestAuthInfoType_HeadersAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RestAuthInfoType_HeadersAuth{`,
		`HeadersAuth:` + strings.Replace(fmt.Sprintf("%v", this.HeadersAuth), "AuthnTypeHeaders", "AuthnTypeHeaders", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RestAuthInfoType_QueryParamsAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RestAuthInfoType_QueryParamsAuth{`,
		`QueryParamsAuth:` + strings.Replace(fmt.Sprintf("%v", this.QueryParamsAuth), "AuthnTypeQueryParams", "AuthnTypeQueryParams", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HostAccessInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HostAccessInfoType{`,
		`Scheme:` + fmt.Sprintf("%v", this.Scheme) + `,`,
		`ServerEndpoint:` + fmt.Sprintf("%v", this.ServerEndpoint) + `,`,
		`TlsConfig:` + strings.Replace(this.TlsConfig.String(), "UpstreamTlsParamsType", "UpstreamTlsParamsType", 1) + `,`,
		`AuthParams:` + fmt.Sprintf("%v", this.AuthParams) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HostAccessInfoType_RestAuthInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HostAccessInfoType_RestAuthInfo{`,
		`RestAuthInfo:` + strings.Replace(fmt.Sprintf("%v", this.RestAuthInfo), "RestAuthInfoType", "RestAuthInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HostAccessInfoType_VaultAuthInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HostAccessInfoType_VaultAuthInfo{`,
		`VaultAuthInfo:` + strings.Replace(fmt.Sprintf("%v", this.VaultAuthInfo), "VaultAuthInfoType", "VaultAuthInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultAccessInfoType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultAccessInfoType{`,
		`VaultAddr:` + fmt.Sprintf("%v", this.VaultAddr) + `,`,
		`VaultCaUrl:` + fmt.Sprintf("%v", this.VaultCaUrl) + `,`,
		`AuthnChoice:` + fmt.Sprintf("%v", this.AuthnChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultAccessInfoType_AppRoleAuth) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultAccessInfoType_AppRoleAuth{`,
		`AppRoleAuth:` + strings.Replace(fmt.Sprintf("%v", this.AppRoleAuth), "AppRoleAuthInfoType", "AppRoleAuthInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultAccessInfoType_Token) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultAccessInfoType_Token{`,
		`Token:` + strings.Replace(fmt.Sprintf("%v", this.Token), "SecretType", "SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultSecretType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultSecretType{`,
		`AccessChoice:` + fmt.Sprintf("%v", this.AccessChoice) + `,`,
		`SecretPath:` + fmt.Sprintf("%v", this.SecretPath) + `,`,
		`SecretSubPath:` + fmt.Sprintf("%v", this.SecretSubPath) + `,`,
		`SecretVersion:` + fmt.Sprintf("%v", this.SecretVersion) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultSecretType_VaultAccessInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultSecretType_VaultAccessInfo{`,
		`VaultAccessInfo:` + strings.Replace(fmt.Sprintf("%v", this.VaultAccessInfo), "VaultAccessInfoType", "VaultAccessInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VaultSecretType_ProviderName) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VaultSecretType_ProviderName{`,
		`ProviderName:` + fmt.Sprintf("%v", this.ProviderName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VolterraSecretType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VolterraSecretType{`,
		`SecretTypeChoice:` + fmt.Sprintf("%v", this.SecretTypeChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VolterraSecretType_BlindfoldSecretInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VolterraSecretType_BlindfoldSecretInfo{`,
		`BlindfoldSecretInfo:` + strings.Replace(fmt.Sprintf("%v", this.BlindfoldSecretInfo), "BlindfoldSecretInfoType", "BlindfoldSecretInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VolterraSecretType_VaultSecretInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VolterraSecretType_VaultSecretInfo{`,
		`VaultSecretInfo:` + strings.Replace(fmt.Sprintf("%v", this.VaultSecretInfo), "VaultAccessInfoType", "VaultAccessInfoType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortValueType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortValueType{`,
		`PortValueTypeChoice:` + fmt.Sprintf("%v", this.PortValueTypeChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortValueType_All) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortValueType_All{`,
		`All:` + strings.Replace(fmt.Sprintf("%v", this.All), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortValueType_UserDefined) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortValueType_UserDefined{`,
		`UserDefined:` + fmt.Sprintf("%v", this.UserDefined) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortValueType_Dns) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortValueType_Dns{`,
		`Dns:` + strings.Replace(fmt.Sprintf("%v", this.Dns), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VirtualNetworkReferenceType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRefs := "[]*ObjectRefType{"
	for _, f := range this.Refs {
		repeatedStringForRefs += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForRefs += "}"
	s := strings.Join([]string{`&VirtualNetworkReferenceType{`,
		`Refs:` + repeatedStringForRefs + `,`,
		`}`,
	}, "")
	return s
}
func (this *VirtualNetworkSelectorType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VirtualNetworkSelectorType{`,
		`VnTypeChoice:` + fmt.Sprintf("%v", this.VnTypeChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VirtualNetworkSelectorType_SiteLocal) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VirtualNetworkSelectorType_SiteLocal{`,
		`SiteLocal:` + strings.Replace(fmt.Sprintf("%v", this.SiteLocal), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VirtualNetworkSelectorType_SiteLocalInside) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VirtualNetworkSelectorType_SiteLocalInside{`,
		`SiteLocalInside:` + strings.Replace(fmt.Sprintf("%v", this.SiteLocalInside), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VirtualNetworkSelectorType_Public) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VirtualNetworkSelectorType_Public{`,
		`Public:` + strings.Replace(fmt.Sprintf("%v", this.Public), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RetryBackOff) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RetryBackOff{`,
		`BaseInterval:` + fmt.Sprintf("%v", this.BaseInterval) + `,`,
		`MaxInterval:` + fmt.Sprintf("%v", this.MaxInterval) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RetryPolicyType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RetryPolicyType{`,
		`RetryOn:` + fmt.Sprintf("%v", this.RetryOn) + `,`,
		`NumRetries:` + fmt.Sprintf("%v", this.NumRetries) + `,`,
		`PerTryTimeout:` + fmt.Sprintf("%v", this.PerTryTimeout) + `,`,
		`RetriableStatusCodes:` + fmt.Sprintf("%v", this.RetriableStatusCodes) + `,`,
		`BackOff:` + strings.Replace(this.BackOff.String(), "RetryBackOff", "RetryBackOff", 1) + `,`,
		`RetryCondition:` + fmt.Sprintf("%v", this.RetryCondition) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetricValue) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MetricValue{`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NextHopType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForInterface := "[]*ObjectRefType{"
	for _, f := range this.Interface {
		repeatedStringForInterface += strings.Replace(f.String(), "ObjectRefType", "ObjectRefType", 1) + ","
	}
	repeatedStringForInterface += "}"
	s := strings.Join([]string{`&NextHopType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`NexthopAddress:` + strings.Replace(fmt.Sprintf("%v", this.NexthopAddress), "IpAddressType", "IpAddressType", 1) + `,`,
		`Interface:` + repeatedStringForInterface + `,`,
		`}`,
	}, "")
	return s
}
func (this *StaticRouteType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSubnets := "[]*IpSubnetType{"
	for _, f := range this.Subnets {
		repeatedStringForSubnets += strings.Replace(fmt.Sprintf("%v", f), "IpSubnetType", "IpSubnetType", 1) + ","
	}
	repeatedStringForSubnets += "}"
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&StaticRouteType{`,
		`Attrs:` + fmt.Sprintf("%v", this.Attrs) + `,`,
		`Subnets:` + repeatedStringForSubnets + `,`,
		`Nexthop:` + strings.Replace(this.Nexthop.String(), "NextHopType", "NextHopType", 1) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`}`,
	}, "")
	return s
}
func (this *ForwardProxyConfigType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ForwardProxyConfigType{`,
		`WhiteListedPrefixes:` + fmt.Sprintf("%v", this.WhiteListedPrefixes) + `,`,
		`WhiteListedPorts:` + fmt.Sprintf("%v", this.WhiteListedPorts) + `,`,
		`MaxConnectAttempts:` + fmt.Sprintf("%v", this.MaxConnectAttempts) + `,`,
		`ConnectionTimeout:` + fmt.Sprintf("%v", this.ConnectionTimeout) + `,`,
		`TlsInterceptionChoice:` + fmt.Sprintf("%v", this.TlsInterceptionChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ForwardProxyConfigType_NoInterception) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ForwardProxyConfigType_NoInterception{`,
		`NoInterception:` + strings.Replace(fmt.Sprintf("%v", this.NoInterception), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ForwardProxyConfigType_TlsIntercept) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ForwardProxyConfigType_TlsIntercept{`,
		`TlsIntercept:` + strings.Replace(fmt.Sprintf("%v", this.TlsIntercept), "TlsInterceptionType", "TlsInterceptionType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HostIdentifier) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HostIdentifier{`,
		`HostnameOrIp:` + fmt.Sprintf("%v", this.HostnameOrIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HostIdentifier_Ip) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HostIdentifier_Ip{`,
		`Ip:` + fmt.Sprintf("%v", this.Ip) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HostIdentifier_Hostname) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HostIdentifier_Hostname{`,
		`Hostname:` + fmt.Sprintf("%v", this.Hostname) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceIdentifier) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceIdentifier{`,
		`InterfaceChoice:` + fmt.Sprintf("%v", this.InterfaceChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceIdentifier_AnyIntf) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceIdentifier_AnyIntf{`,
		`AnyIntf:` + strings.Replace(fmt.Sprintf("%v", this.AnyIntf), "Empty", "Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceIdentifier_Intf) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceIdentifier_Intf{`,
		`Intf:` + fmt.Sprintf("%v", this.Intf) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceOrNetwork) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceOrNetwork{`,
		`InterfaceChoice:` + fmt.Sprintf("%v", this.InterfaceChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceOrNetwork_Intf) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceOrNetwork_Intf{`,
		`Intf:` + fmt.Sprintf("%v", this.Intf) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceOrNetwork_Pod) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceOrNetwork_Pod{`,
		`Pod:` + fmt.Sprintf("%v", this.Pod) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceOrNetwork_VnType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceOrNetwork_VnType{`,
		`VnType:` + fmt.Sprintf("%v", this.VnType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceOrNetwork_Vn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InterfaceOrNetwork_Vn{`,
		`Vn:` + fmt.Sprintf("%v", this.Vn) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteTarget2ByteAsn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteTarget2ByteAsn{`,
		`AsNumber:` + fmt.Sprintf("%v", this.AsNumber) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteTarget4ByteAsn) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteTarget4ByteAsn{`,
		`AsNumber:` + fmt.Sprintf("%v", this.AsNumber) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteTargetIPv4Addr) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteTargetIPv4Addr{`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteTarget) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteTarget{`,
		`RtargetChoice:` + fmt.Sprintf("%v", this.RtargetChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteTarget_Asn2ByteRtarget) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteTarget_Asn2ByteRtarget{`,
		`Asn2ByteRtarget:` + strings.Replace(fmt.Sprintf("%v", this.Asn2ByteRtarget), "RouteTarget2ByteAsn", "RouteTarget2ByteAsn", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteTarget_Ipv4AddrRtarget) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteTarget_Ipv4AddrRtarget{`,
		`Ipv4AddrRtarget:` + strings.Replace(fmt.Sprintf("%v", this.Ipv4AddrRtarget), "RouteTargetIPv4Addr", "RouteTargetIPv4Addr", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RouteTarget_Asn4ByteRtarget) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RouteTarget_Asn4ByteRtarget{`,
		`Asn4ByteRtarget:` + strings.Replace(fmt.Sprintf("%v", this.Asn4ByteRtarget), "RouteTarget4ByteAsn", "RouteTarget4ByteAsn", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelSelectorType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelSelectorType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelSelectorType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expressions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expressions = append(m.Expressions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConditionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConditionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConditionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastUpdateTime == nil {
				m.LastUpdateTime = &types.Timestamp{}
			}
			if err := m.LastUpdateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitializerType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitializerType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitializerType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitializersType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitializersType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitializersType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pending", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pending = append(m.Pending, &InitializerType{})
			if err := m.Pending[len(m.Pending)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Result == nil {
				m.Result = &StatusType{}
			}
			if err := m.Result.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTimestamp == nil {
				m.CreationTimestamp = &types.Timestamp{}
			}
			if err := m.CreationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publish", wireType)
			}
			m.Publish = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Publish |= StatusPublishType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VtrpId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VtrpId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectGetMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectGetMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectGetMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectCreateMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectCreateMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectCreateMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectReplaceMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectReplaceMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectReplaceMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubeRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubeRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubeRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemObjectMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SystemObjectMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SystemObjectMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTimestamp == nil {
				m.CreationTimestamp = &types.Timestamp{}
			}
			if err := m.CreationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeletionTimestamp == nil {
				m.DeletionTimestamp = &types.Timestamp{}
			}
			if err := m.DeletionTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModificationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModificationTimestamp == nil {
				m.ModificationTimestamp = &types.Timestamp{}
			}
			if err := m.ModificationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Initializers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Initializers == nil {
				m.Initializers = &InitializersType{}
			}
			if err := m.Initializers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finalizers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Finalizers = append(m.Finalizers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraceInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectIndex", wireType)
			}
			m.ObjectIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = append(m.Namespace, &ObjectRefType{})
			if err := m.Namespace[len(m.Namespace)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorCookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorCookie = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerView", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnerView == nil {
				m.OwnerView = &ViewRefType{}
			}
			if err := m.OwnerView.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SreDisable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SreDisable = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VtrpId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VtrpId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemObjectGetMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SystemObjectGetMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SystemObjectGetMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTimestamp == nil {
				m.CreationTimestamp = &types.Timestamp{}
			}
			if err := m.CreationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeletionTimestamp == nil {
				m.DeletionTimestamp = &types.Timestamp{}
			}
			if err := m.DeletionTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModificationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModificationTimestamp == nil {
				m.ModificationTimestamp = &types.Timestamp{}
			}
			if err := m.ModificationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Initializers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Initializers == nil {
				m.Initializers = &InitializersType{}
			}
			if err := m.Initializers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finalizers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Finalizers = append(m.Finalizers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectIndex", wireType)
			}
			m.ObjectIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerView", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OwnerView == nil {
				m.OwnerView = &ViewRefType{}
			}
			if err := m.OwnerView.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthnTypeBasicAuth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthnTypeBasicAuth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthnTypeBasicAuth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Password == nil {
				m.Password = &SecretType{}
			}
			if err := m.Password.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthnTypeHeaders) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthnTypeHeaders: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthnTypeHeaders: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Headers == nil {
				m.Headers = make(map[string]*SecretType)
			}
			var mapkey string
			var mapvalue *SecretType
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SecretType{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Headers[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthnTypeQueryParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthnTypeQueryParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthnTypeQueryParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QueryParams == nil {
				m.QueryParams = make(map[string]*SecretType)
			}
			var mapkey string
			var mapvalue *SecretType
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SecretType{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.QueryParams[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlindfoldSecretInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlindfoldSecretInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlindfoldSecretInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecryptionProvider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DecryptionProvider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreProvider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StoreProvider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VaultSecretInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VaultSecretInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VaultSecretInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretEncoding", wireType)
			}
			m.SecretEncoding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecretEncoding |= SecretEncodingType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearSecretInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearSecretInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearSecretInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WingmanSecretInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WingmanSecretInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WingmanSecretInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlindfoldSecretInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlindfoldSecretInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SecretInfoOneof = &SecretType_BlindfoldSecretInfo{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultSecretInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VaultSecretInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SecretInfoOneof = &SecretType_VaultSecretInfo{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearSecretInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ClearSecretInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SecretInfoOneof = &SecretType_ClearSecretInfo{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WingmanSecretInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WingmanSecretInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SecretInfoOneof = &SecretType_WingmanSecretInfo{v}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretEncodingType", wireType)
			}
			m.SecretEncodingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecretEncodingType |= SecretEncodingType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlindfoldSecretInfoInternal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlindfoldSecretInfoInternal == nil {
				m.BlindfoldSecretInfoInternal = &BlindfoldSecretInfoType{}
			}
			if err := m.BlindfoldSecretInfoInternal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = append(m.Ref, &ObjectRefType{})
			if err := m.Ref[len(m.Ref)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = append(m.Ref, &ObjectRefType{})
			if err := m.Ref[len(m.Ref)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkType", wireType)
			}
			m.NetworkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkType |= VirtualNetworkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpPrefixSetRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpPrefixSetRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpPrefixSetRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = append(m.Ref, &ObjectRefType{})
			if err := m.Ref[len(m.Ref)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VSiteRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VSiteRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VSiteRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = append(m.Ref, &ObjectRefType{})
			if err := m.Ref[len(m.Ref)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkType", wireType)
			}
			m.NetworkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkType |= VirtualNetworkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicerRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicerRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicerRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = append(m.Ref, &ObjectRefType{})
			if err := m.Ref[len(m.Ref)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolPolicerRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolPolicerRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolPolicerRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = append(m.Ref, &ObjectRefType{})
			if err := m.Ref[len(m.Ref)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkSiteRefSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkSiteRefSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkSiteRefSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NetworkRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RefOrSelector = &NetworkSiteRefSelector_VirtualNetwork{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SiteRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RefOrSelector = &NetworkSiteRefSelector_Site{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VSiteRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RefOrSelector = &NetworkSiteRefSelector_VirtualSite{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteVirtualSiteRefSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteVirtualSiteRefSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteVirtualSiteRefSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SiteRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RefOrSelector = &SiteVirtualSiteRefSelector_Site{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VSiteRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RefOrSelector = &SiteVirtualSiteRefSelector_VirtualSite{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderManipulationOptionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderManipulationOptionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderManipulationOptionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Append", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Append = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsValidationParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsValidationParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsValidationParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedCaUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipHostnameVerification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipHostnameVerification = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifySubjectAltNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifySubjectAltNames = append(m.VerifySubjectAltNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseVolterraTrustedCaUrl", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseVolterraTrustedCaUrl = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsCertificateType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsCertificateType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsCertificateType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertificateUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrivateKey == nil {
				m.PrivateKey = &SecretType{}
			}
			if err := m.PrivateKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumProtocolVersion", wireType)
			}
			m.MinimumProtocolVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumProtocolVersion |= TlsProtocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumProtocolVersion", wireType)
			}
			m.MaximumProtocolVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumProtocolVersion |= TlsProtocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherSuites", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CipherSuites = append(m.CipherSuites, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsCertificates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsCertificates = append(m.TlsCertificates, &TlsCertificateType{})
			if err := m.TlsCertificates[len(m.TlsCertificates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedCaUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidationParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidationParams == nil {
				m.ValidationParams = &TlsValidationParamsType{}
			}
			if err := m.ValidationParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpstreamTlsParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpstreamTlsParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpstreamTlsParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommonParams == nil {
				m.CommonParams = &TlsParamsType{}
			}
			if err := m.CommonParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sni", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SniChoice = &UpstreamTlsParamsType_Sni{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseHostHeaderAsSni", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SniChoice = &UpstreamTlsParamsType_UseHostHeaderAsSni{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableSni", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SniChoice = &UpstreamTlsParamsType_DisableSni{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownstreamTlsParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownstreamTlsParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownstreamTlsParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommonParams == nil {
				m.CommonParams = &TlsParamsType{}
			}
			if err := m.CommonParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireClientCertificate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireClientCertificate = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DomainType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DomainType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DomainType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExactValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainChoice = &DomainType_ExactValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuffixValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainChoice = &DomainType_SuffixValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegexValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainChoice = &DomainType_RegexValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L4DestType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L4DestType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L4DestType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefixes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prefixes = append(m.Prefixes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortRanges = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsInterceptionRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsInterceptionRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsInterceptionRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DomainMatch == nil {
				m.DomainMatch = &DomainType{}
			}
			if err := m.DomainMatch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableInterception", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EnableDisableChoice = &TlsInterceptionRule_DisableInterception{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableInterception", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EnableDisableChoice = &TlsInterceptionRule_EnableInterception{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsInterceptionPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsInterceptionPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsInterceptionPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterceptionRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterceptionRules = append(m.InterceptionRules, &TlsInterceptionRule{})
			if err := m.InterceptionRules[len(m.InterceptionRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsInterceptionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsInterceptionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsInterceptionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TlsInterceptionPolicy{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterceptionPolicyChoice = &TlsInterceptionType_Policy{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomCertificate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TlsCertificateType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SigningCertChoice = &TlsInterceptionType_CustomCertificate{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraCertificate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SigningCertChoice = &TlsInterceptionType_VolterraCertificate{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedCaChoice = &TlsInterceptionType_TrustedCaUrl{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraTrustedCa", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TrustedCaChoice = &TlsInterceptionType_VolterraTrustedCa{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableForAllDomains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterceptionPolicyChoice = &TlsInterceptionType_EnableForAllDomains{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FractionalPercent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FractionalPercent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FractionalPercent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Numerator", wireType)
			}
			m.Numerator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Numerator |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denominator", wireType)
			}
			m.Denominator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Denominator |= DenominatorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BufferConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BufferConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BufferConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestBytes", wireType)
			}
			m.MaxRequestBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRequestBytes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRequestTime", wireType)
			}
			m.MaxRequestTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRequestTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CorsPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CorsPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CorsPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOrigin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowOrigin = append(m.AllowOrigin, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowOriginRegex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowOriginRegex = append(m.AllowOriginRegex, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowMethods", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowMethods = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowHeaders", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowHeaders = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExposeHeaders", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExposeHeaders = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxAge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowCredentials", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowCredentials = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumAge", wireType)
			}
			m.MaximumAge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumAge |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathMatch = &PathMatcherType_Prefix{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathMatch = &PathMatcherType_Path{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathMatch = &PathMatcherType_Regex{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeaderMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exact", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueMatch = &HeaderMatcherType_Exact{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueMatch = &HeaderMatcherType_Regex{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Presence", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ValueMatch = &HeaderMatcherType_Presence{b}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvertMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InvertMatch = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryParameterMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParameterMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParameterMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exact", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueMatch = &QueryParameterMatcherType_Exact{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueMatch = &QueryParameterMatcherType_Regex{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Path == nil {
				m.Path = &PathMatcherType{}
			}
			if err := m.Path.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, &HeaderMatcherType{})
			if err := m.Headers[len(m.Headers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParams = append(m.QueryParams, &QueryParameterMatcherType{})
			if err := m.QueryParams[len(m.QueryParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpMethod", wireType)
			}
			m.HttpMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HttpMethod |= HttpMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WafRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WafRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WafRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Waf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Waf = append(m.Waf, &ObjectRefType{})
			if err := m.Waf[len(m.Waf)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WafRulesRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WafRulesRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WafRulesRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WafRules = append(m.WafRules, &ObjectRefType{})
			if err := m.WafRules[len(m.WafRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppFirewallRefType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppFirewallRefType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppFirewallRefType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppFirewall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppFirewall = append(m.AppFirewall, &ObjectRefType{})
			if err := m.AppFirewall[len(m.AppFirewall)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WafType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WafType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WafType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Waf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WafRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RefType = &WafType_Waf{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WafRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WafRulesRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RefType = &WafType_WafRules{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppFirewall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppFirewallRefType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RefType = &WafType_AppFirewall{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppRoleAuthInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppRoleAuthInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppRoleAuthInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecretId == nil {
				m.SecretId = &SecretType{}
			}
			if err := m.SecretId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VaultAuthInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VaultAuthInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VaultAuthInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppRoleAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppRoleAuthInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthParams = &VaultAuthInfoType_AppRoleAuth{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SecretType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthParams = &VaultAuthInfoType_Token{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestAuthInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestAuthInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestAuthInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasicAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AuthnTypeBasicAuth{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthParams = &RestAuthInfoType_BasicAuth{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadersAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AuthnTypeHeaders{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthParams = &RestAuthInfoType_HeadersAuth{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParamsAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AuthnTypeQueryParams{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthParams = &RestAuthInfoType_QueryParamsAuth{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostAccessInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostAccessInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostAccessInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scheme", wireType)
			}
			m.Scheme = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scheme |= URLSchemeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsConfig == nil {
				m.TlsConfig = &UpstreamTlsParamsType{}
			}
			if err := m.TlsConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestAuthInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RestAuthInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthParams = &HostAccessInfoType_RestAuthInfo{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAuthInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VaultAuthInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthParams = &HostAccessInfoType_VaultAuthInfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VaultAccessInfoType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VaultAccessInfoType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VaultAccessInfoType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultCaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VaultCaUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppRoleAuth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppRoleAuthInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthnChoice = &VaultAccessInfoType_AppRoleAuth{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SecretType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthnChoice = &VaultAccessInfoType_Token{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VaultSecretType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VaultSecretType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VaultSecretType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultAccessInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VaultAccessInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AccessChoice = &VaultSecretType_VaultAccessInfo{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessChoice = &VaultSecretType_ProviderName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretSubPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretSubPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolterraSecretType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolterraSecretType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolterraSecretType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlindfoldSecretInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlindfoldSecretInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SecretTypeChoice = &VolterraSecretType_BlindfoldSecretInfo{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VaultSecretInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VaultAccessInfoType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SecretTypeChoice = &VolterraSecretType_VaultSecretInfo{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortValueType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortValueType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortValueType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PortValueTypeChoice = &PortValueType_All{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserDefined", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PortValueTypeChoice = &PortValueType_UserDefined{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PortValueTypeChoice = &PortValueType_Dns{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualNetworkReferenceType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualNetworkReferenceType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualNetworkReferenceType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Refs = append(m.Refs, &ObjectRefType{})
			if err := m.Refs[len(m.Refs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualNetworkSelectorType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualNetworkSelectorType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualNetworkSelectorType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteLocal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VnTypeChoice = &VirtualNetworkSelectorType_SiteLocal{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteLocalInside", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VnTypeChoice = &VirtualNetworkSelectorType_SiteLocalInside{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Public", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.VnTypeChoice = &VirtualNetworkSelectorType_Public{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetryBackOff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetryBackOff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetryBackOff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseInterval", wireType)
			}
			m.BaseInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseInterval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxInterval", wireType)
			}
			m.MaxInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxInterval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetryPolicyType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetryPolicyType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetryPolicyType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryOn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetryOn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumRetries", wireType)
			}
			m.NumRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumRetries |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerTryTimeout", wireType)
			}
			m.PerTryTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerTryTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RetriableStatusCodes = append(m.RetriableStatusCodes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RetriableStatusCodes) == 0 {
					m.RetriableStatusCodes = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RetriableStatusCodes = append(m.RetriableStatusCodes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RetriableStatusCodes", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackOff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BackOff == nil {
				m.BackOff = &RetryBackOff{}
			}
			if err := m.BackOff.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryCondition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetryCondition = append(m.RetryCondition, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Timestamp = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NextHopType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NextHopType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NextHopType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NextHopTypes(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NexthopAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NexthopAddress == nil {
				m.NexthopAddress = &IpAddressType{}
			}
			if err := m.NexthopAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interface", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interface = append(m.Interface, &ObjectRefType{})
			if err := m.Interface[len(m.Interface)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaticRouteType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaticRouteType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaticRouteType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v RouteAttrType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= RouteAttrType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Attrs = append(m.Attrs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Attrs) == 0 {
					m.Attrs = make([]RouteAttrType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v RouteAttrType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= RouteAttrType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Attrs = append(m.Attrs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subnets = append(m.Subnets, &IpSubnetType{})
			if err := m.Subnets[len(m.Subnets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nexthop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nexthop == nil {
				m.Nexthop = &NextHopType{}
			}
			if err := m.Nexthop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForwardProxyConfigType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForwardProxyConfigType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForwardProxyConfigType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WhiteListedPrefixes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WhiteListedPrefixes = append(m.WhiteListedPrefixes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WhiteListedPorts = append(m.WhiteListedPorts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.WhiteListedPorts) == 0 {
					m.WhiteListedPorts = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WhiteListedPorts = append(m.WhiteListedPorts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WhiteListedPorts", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxConnectAttempts", wireType)
			}
			m.MaxConnectAttempts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxConnectAttempts |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionTimeout", wireType)
			}
			m.ConnectionTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectionTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoInterception", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TlsInterceptionChoice = &ForwardProxyConfigType_NoInterception{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsIntercept", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TlsInterceptionType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TlsInterceptionChoice = &ForwardProxyConfigType_TlsIntercept{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostIdentifier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostIdentifier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostIdentifier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostnameOrIp = &HostIdentifier_Ip{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostnameOrIp = &HostIdentifier_Hostname{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceIdentifier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceIdentifier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceIdentifier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyIntf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.InterfaceChoice = &InterfaceIdentifier_AnyIntf{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceChoice = &InterfaceIdentifier_Intf{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceOrNetwork) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceOrNetwork: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceOrNetwork: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceChoice = &InterfaceOrNetwork_Intf{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceChoice = &InterfaceOrNetwork_Pod{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VnType", wireType)
			}
			var v VirtualNetworkType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= VirtualNetworkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InterfaceChoice = &InterfaceOrNetwork_VnType{v}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterfaceChoice = &InterfaceOrNetwork_Vn{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTarget2ByteAsn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTarget2ByteAsn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTarget2ByteAsn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsNumber", wireType)
			}
			m.AsNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AsNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTarget4ByteAsn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTarget4ByteAsn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTarget4ByteAsn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsNumber", wireType)
			}
			m.AsNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AsNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTargetIPv4Addr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTargetIPv4Addr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTargetIPv4Addr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteTarget) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asn2ByteRtarget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteTarget2ByteAsn{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RtargetChoice = &RouteTarget_Asn2ByteRtarget{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4AddrRtarget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteTargetIPv4Addr{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RtargetChoice = &RouteTarget_Ipv4AddrRtarget{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asn4ByteRtarget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteTarget4ByteAsn{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RtargetChoice = &RouteTarget_Asn4ByteRtarget{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
