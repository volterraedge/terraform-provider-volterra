// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/dns_domain/types.proto

package dns_domain

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// DNSSEC Mode
//
// x-displayName: "DNSSEC Mode"
// Enable or disable DNSSEC on the DNS Domain
type DNSSECMode int32

const (
	// x-displayName: "Disable"
	// DNSSEC is disabled
	DNSSEC_DISABLE DNSSECMode = 0
	// x-displayName: "Enable"
	// DNSSEC is enabled
	DNSSEC_ENABLE DNSSECMode = 1
)

var DNSSECMode_name = map[int32]string{
	0: "DNSSEC_DISABLE",
	1: "DNSSEC_ENABLE",
}

var DNSSECMode_value = map[string]int32{
	"DNSSEC_DISABLE": 0,
	"DNSSEC_ENABLE":  1,
}

func (DNSSECMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5a5a8e83bbc2ad91, []int{0}
}

// AWS Route53 Config
//
// x-displayName: "AWS Route53 Config"
// AWS Route53 configuration for domain delegation
type AWSRoute53Type struct {
	// AWS Credentials
	//
	// x-displayName: "AWS Credentials"
	// Reference to AWS credentials to program route53
	Creds *views.ObjectRefType `protobuf:"bytes,1,opt,name=creds,proto3" json:"creds,omitempty"`
}

func (m *AWSRoute53Type) Reset()      { *m = AWSRoute53Type{} }
func (*AWSRoute53Type) ProtoMessage() {}
func (*AWSRoute53Type) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a5a8e83bbc2ad91, []int{0}
}
func (m *AWSRoute53Type) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AWSRoute53Type) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AWSRoute53Type) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AWSRoute53Type.Merge(m, src)
}
func (m *AWSRoute53Type) XXX_Size() int {
	return m.Size()
}
func (m *AWSRoute53Type) XXX_DiscardUnknown() {
	xxx_messageInfo_AWSRoute53Type.DiscardUnknown(m)
}

var xxx_messageInfo_AWSRoute53Type proto.InternalMessageInfo

func (m *AWSRoute53Type) GetCreds() *views.ObjectRefType {
	if m != nil {
		return m.Creds
	}
	return nil
}

// DNS Domain specification
//
// x-displayName: "Specification"
// Desired state of network policy set
type GlobalSpecType struct {
	// Choice to Handle Domain
	//
	// x-displayName: "Domain Method"
	// x-required
	// Select method to handle this domain
	//
	// Types that are valid to be assigned to DomainChoice:
	//	*GlobalSpecType_VolterraManaged
	//	*GlobalSpecType_Route53
	//	*GlobalSpecType_VerificationOnly
	DomainChoice isGlobalSpecType_DomainChoice `protobuf_oneof:"domain_choice"`
	// TXT Record
	//
	// x-displayName: "TXT Record"
	// Value of the TXT record, that is programed in your DNS provided TXT record for this sub domain.
	TxtRecord string `protobuf:"bytes,6,opt,name=txt_record,json=txtRecord,proto3" json:"txt_record,omitempty"`
	// DNSSEC Mode
	//
	// x-displayName: "DNSSEC Mode"
	// Control whether DNSSEC is enabled on the dns domain or not
	DnssecMode DNSSECMode `protobuf:"varint,7,opt,name=dnssec_mode,json=dnssecMode,proto3,enum=ves.io.schema.dns_domain.DNSSECMode" json:"dnssec_mode,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a5a8e83bbc2ad91, []int{1}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_DomainChoice interface {
	isGlobalSpecType_DomainChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_VolterraManaged struct {
	VolterraManaged *schema.Empty `protobuf:"bytes,3,opt,name=volterra_managed,json=volterraManaged,proto3,oneof" json:"volterra_managed,omitempty"`
}
type GlobalSpecType_Route53 struct {
	Route53 *AWSRoute53Type `protobuf:"bytes,4,opt,name=route53,proto3,oneof" json:"route53,omitempty"`
}
type GlobalSpecType_VerificationOnly struct {
	VerificationOnly *schema.Empty `protobuf:"bytes,5,opt,name=verification_only,json=verificationOnly,proto3,oneof" json:"verification_only,omitempty"`
}

func (*GlobalSpecType_VolterraManaged) isGlobalSpecType_DomainChoice()  {}
func (*GlobalSpecType_Route53) isGlobalSpecType_DomainChoice()          {}
func (*GlobalSpecType_VerificationOnly) isGlobalSpecType_DomainChoice() {}

func (m *GlobalSpecType) GetDomainChoice() isGlobalSpecType_DomainChoice {
	if m != nil {
		return m.DomainChoice
	}
	return nil
}

func (m *GlobalSpecType) GetVolterraManaged() *schema.Empty {
	if x, ok := m.GetDomainChoice().(*GlobalSpecType_VolterraManaged); ok {
		return x.VolterraManaged
	}
	return nil
}

func (m *GlobalSpecType) GetRoute53() *AWSRoute53Type {
	if x, ok := m.GetDomainChoice().(*GlobalSpecType_Route53); ok {
		return x.Route53
	}
	return nil
}

func (m *GlobalSpecType) GetVerificationOnly() *schema.Empty {
	if x, ok := m.GetDomainChoice().(*GlobalSpecType_VerificationOnly); ok {
		return x.VerificationOnly
	}
	return nil
}

func (m *GlobalSpecType) GetTxtRecord() string {
	if m != nil {
		return m.TxtRecord
	}
	return ""
}

func (m *GlobalSpecType) GetDnssecMode() DNSSECMode {
	if m != nil {
		return m.DnssecMode
	}
	return DNSSEC_DISABLE
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_VolterraManaged)(nil),
		(*GlobalSpecType_Route53)(nil),
		(*GlobalSpecType_VerificationOnly)(nil),
	}
}

// Create DNS Domain
//
// x-displayName: "Create DNS Domain"
// Create DNS Domain in a given namespace. If one already exist it will give a error.
type CreateSpecType struct {
	// Types that are valid to be assigned to DomainChoice:
	//	*CreateSpecType_VolterraManaged
	//	*CreateSpecType_Route53
	//	*CreateSpecType_VerificationOnly
	DomainChoice isCreateSpecType_DomainChoice `protobuf_oneof:"domain_choice"`
	DnssecMode   DNSSECMode                    `protobuf:"varint,7,opt,name=dnssec_mode,json=dnssecMode,proto3,enum=ves.io.schema.dns_domain.DNSSECMode" json:"dnssec_mode,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a5a8e83bbc2ad91, []int{2}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_DomainChoice interface {
	isCreateSpecType_DomainChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_VolterraManaged struct {
	VolterraManaged *schema.Empty `protobuf:"bytes,3,opt,name=volterra_managed,json=volterraManaged,proto3,oneof" json:"volterra_managed,omitempty"`
}
type CreateSpecType_Route53 struct {
	Route53 *AWSRoute53Type `protobuf:"bytes,4,opt,name=route53,proto3,oneof" json:"route53,omitempty"`
}
type CreateSpecType_VerificationOnly struct {
	VerificationOnly *schema.Empty `protobuf:"bytes,5,opt,name=verification_only,json=verificationOnly,proto3,oneof" json:"verification_only,omitempty"`
}

func (*CreateSpecType_VolterraManaged) isCreateSpecType_DomainChoice()  {}
func (*CreateSpecType_Route53) isCreateSpecType_DomainChoice()          {}
func (*CreateSpecType_VerificationOnly) isCreateSpecType_DomainChoice() {}

func (m *CreateSpecType) GetDomainChoice() isCreateSpecType_DomainChoice {
	if m != nil {
		return m.DomainChoice
	}
	return nil
}

func (m *CreateSpecType) GetVolterraManaged() *schema.Empty {
	if x, ok := m.GetDomainChoice().(*CreateSpecType_VolterraManaged); ok {
		return x.VolterraManaged
	}
	return nil
}

func (m *CreateSpecType) GetRoute53() *AWSRoute53Type {
	if x, ok := m.GetDomainChoice().(*CreateSpecType_Route53); ok {
		return x.Route53
	}
	return nil
}

func (m *CreateSpecType) GetVerificationOnly() *schema.Empty {
	if x, ok := m.GetDomainChoice().(*CreateSpecType_VerificationOnly); ok {
		return x.VerificationOnly
	}
	return nil
}

func (m *CreateSpecType) GetDnssecMode() DNSSECMode {
	if m != nil {
		return m.DnssecMode
	}
	return DNSSEC_DISABLE
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_VolterraManaged)(nil),
		(*CreateSpecType_Route53)(nil),
		(*CreateSpecType_VerificationOnly)(nil),
	}
}

// Replace DNS Domain
//
// x-displayName: "Replace DNS Domain"
// Replace DNS Domain in a given namespace.
type ReplaceSpecType struct {
	// Types that are valid to be assigned to DomainChoice:
	//	*ReplaceSpecType_VolterraManaged
	//	*ReplaceSpecType_Route53
	//	*ReplaceSpecType_VerificationOnly
	DomainChoice isReplaceSpecType_DomainChoice `protobuf_oneof:"domain_choice"`
	DnssecMode   DNSSECMode                     `protobuf:"varint,7,opt,name=dnssec_mode,json=dnssecMode,proto3,enum=ves.io.schema.dns_domain.DNSSECMode" json:"dnssec_mode,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a5a8e83bbc2ad91, []int{3}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_DomainChoice interface {
	isReplaceSpecType_DomainChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_VolterraManaged struct {
	VolterraManaged *schema.Empty `protobuf:"bytes,3,opt,name=volterra_managed,json=volterraManaged,proto3,oneof" json:"volterra_managed,omitempty"`
}
type ReplaceSpecType_Route53 struct {
	Route53 *AWSRoute53Type `protobuf:"bytes,4,opt,name=route53,proto3,oneof" json:"route53,omitempty"`
}
type ReplaceSpecType_VerificationOnly struct {
	VerificationOnly *schema.Empty `protobuf:"bytes,5,opt,name=verification_only,json=verificationOnly,proto3,oneof" json:"verification_only,omitempty"`
}

func (*ReplaceSpecType_VolterraManaged) isReplaceSpecType_DomainChoice()  {}
func (*ReplaceSpecType_Route53) isReplaceSpecType_DomainChoice()          {}
func (*ReplaceSpecType_VerificationOnly) isReplaceSpecType_DomainChoice() {}

func (m *ReplaceSpecType) GetDomainChoice() isReplaceSpecType_DomainChoice {
	if m != nil {
		return m.DomainChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetVolterraManaged() *schema.Empty {
	if x, ok := m.GetDomainChoice().(*ReplaceSpecType_VolterraManaged); ok {
		return x.VolterraManaged
	}
	return nil
}

func (m *ReplaceSpecType) GetRoute53() *AWSRoute53Type {
	if x, ok := m.GetDomainChoice().(*ReplaceSpecType_Route53); ok {
		return x.Route53
	}
	return nil
}

func (m *ReplaceSpecType) GetVerificationOnly() *schema.Empty {
	if x, ok := m.GetDomainChoice().(*ReplaceSpecType_VerificationOnly); ok {
		return x.VerificationOnly
	}
	return nil
}

func (m *ReplaceSpecType) GetDnssecMode() DNSSECMode {
	if m != nil {
		return m.DnssecMode
	}
	return DNSSEC_DISABLE
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_VolterraManaged)(nil),
		(*ReplaceSpecType_Route53)(nil),
		(*ReplaceSpecType_VerificationOnly)(nil),
	}
}

// Get DNS Domain
//
// x-displayName: "Get DNS Domain"
// Get network policy set in a given namespace.
type GetSpecType struct {
	Domain string `protobuf:"bytes,1,opt,name=domain,proto3" json:"domain,omitempty"`
	// Types that are valid to be assigned to DomainChoice:
	//	*GetSpecType_VolterraManaged
	//	*GetSpecType_Route53
	//	*GetSpecType_VerificationOnly
	DomainChoice isGetSpecType_DomainChoice `protobuf_oneof:"domain_choice"`
	TxtRecord    string                     `protobuf:"bytes,6,opt,name=txt_record,json=txtRecord,proto3" json:"txt_record,omitempty"`
	DnssecMode   DNSSECMode                 `protobuf:"varint,7,opt,name=dnssec_mode,json=dnssecMode,proto3,enum=ves.io.schema.dns_domain.DNSSECMode" json:"dnssec_mode,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5a5a8e83bbc2ad91, []int{4}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_DomainChoice interface {
	isGetSpecType_DomainChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_VolterraManaged struct {
	VolterraManaged *schema.Empty `protobuf:"bytes,3,opt,name=volterra_managed,json=volterraManaged,proto3,oneof" json:"volterra_managed,omitempty"`
}
type GetSpecType_Route53 struct {
	Route53 *AWSRoute53Type `protobuf:"bytes,4,opt,name=route53,proto3,oneof" json:"route53,omitempty"`
}
type GetSpecType_VerificationOnly struct {
	VerificationOnly *schema.Empty `protobuf:"bytes,5,opt,name=verification_only,json=verificationOnly,proto3,oneof" json:"verification_only,omitempty"`
}

func (*GetSpecType_VolterraManaged) isGetSpecType_DomainChoice()  {}
func (*GetSpecType_Route53) isGetSpecType_DomainChoice()          {}
func (*GetSpecType_VerificationOnly) isGetSpecType_DomainChoice() {}

func (m *GetSpecType) GetDomainChoice() isGetSpecType_DomainChoice {
	if m != nil {
		return m.DomainChoice
	}
	return nil
}

func (m *GetSpecType) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *GetSpecType) GetVolterraManaged() *schema.Empty {
	if x, ok := m.GetDomainChoice().(*GetSpecType_VolterraManaged); ok {
		return x.VolterraManaged
	}
	return nil
}

func (m *GetSpecType) GetRoute53() *AWSRoute53Type {
	if x, ok := m.GetDomainChoice().(*GetSpecType_Route53); ok {
		return x.Route53
	}
	return nil
}

func (m *GetSpecType) GetVerificationOnly() *schema.Empty {
	if x, ok := m.GetDomainChoice().(*GetSpecType_VerificationOnly); ok {
		return x.VerificationOnly
	}
	return nil
}

func (m *GetSpecType) GetTxtRecord() string {
	if m != nil {
		return m.TxtRecord
	}
	return ""
}

func (m *GetSpecType) GetDnssecMode() DNSSECMode {
	if m != nil {
		return m.DnssecMode
	}
	return DNSSEC_DISABLE
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_VolterraManaged)(nil),
		(*GetSpecType_Route53)(nil),
		(*GetSpecType_VerificationOnly)(nil),
	}
}

func init() {
	proto.RegisterEnum("ves.io.schema.dns_domain.DNSSECMode", DNSSECMode_name, DNSSECMode_value)
	golang_proto.RegisterEnum("ves.io.schema.dns_domain.DNSSECMode", DNSSECMode_name, DNSSECMode_value)
	proto.RegisterType((*AWSRoute53Type)(nil), "ves.io.schema.dns_domain.AWSRoute53Type")
	golang_proto.RegisterType((*AWSRoute53Type)(nil), "ves.io.schema.dns_domain.AWSRoute53Type")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.dns_domain.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.dns_domain.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.dns_domain.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.dns_domain.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.dns_domain.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.dns_domain.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.dns_domain.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.dns_domain.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/dns_domain/types.proto", fileDescriptor_5a5a8e83bbc2ad91)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/dns_domain/types.proto", fileDescriptor_5a5a8e83bbc2ad91)
}

var fileDescriptor_5a5a8e83bbc2ad91 = []byte{
	// 718 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x56, 0xbd, 0x6f, 0xd3, 0x4e,
	0x18, 0xf6, 0x25, 0xfd, 0xbc, 0xa8, 0x69, 0x62, 0x55, 0xbf, 0x9f, 0x9b, 0xc2, 0x35, 0x8a, 0x3a,
	0x44, 0xa8, 0xb5, 0xa5, 0x86, 0x2e, 0x0c, 0x48, 0xcd, 0x87, 0x5a, 0x2a, 0x9a, 0x22, 0x07, 0x09,
	0x89, 0xc5, 0x38, 0xf6, 0xc5, 0x35, 0xd8, 0x3e, 0xcb, 0xbe, 0x84, 0x66, 0xa8, 0x84, 0x98, 0x19,
	0x98, 0xf8, 0x1b, 0x10, 0xfc, 0x09, 0x59, 0x2a, 0x26, 0xc4, 0x94, 0x31, 0x23, 0x75, 0x96, 0xb2,
	0x75, 0x66, 0x42, 0x39, 0x27, 0x34, 0xee, 0xc7, 0x40, 0x55, 0x18, 0x10, 0xdb, 0xbd, 0xef, 0xfb,
	0xbc, 0xcf, 0xfb, 0xfa, 0x79, 0xa2, 0xbb, 0xc0, 0x95, 0x16, 0xf6, 0x45, 0x93, 0x48, 0xbe, 0xb6,
	0x8f, 0x6d, 0x55, 0xd2, 0x1d, 0x5f, 0xd1, 0x89, 0xad, 0x9a, 0x8e, 0x44, 0xdb, 0x2e, 0xf6, 0x45,
	0xd7, 0x23, 0x94, 0xf0, 0x42, 0x88, 0x12, 0x43, 0x94, 0x78, 0x86, 0xca, 0xac, 0x19, 0x26, 0xdd,
	0x6f, 0xd6, 0x45, 0x8d, 0xd8, 0x92, 0x41, 0x0c, 0x22, 0xb1, 0x86, 0x7a, 0xb3, 0xc1, 0x22, 0x16,
	0xb0, 0x53, 0x48, 0x94, 0xf9, 0x3f, 0x3a, 0xce, 0xc1, 0x74, 0x58, 0x58, 0x8a, 0x16, 0x88, 0x4b,
	0x4d, 0xe2, 0x0c, 0xc7, 0x67, 0x16, 0xa3, 0xc5, 0xb1, 0xcd, 0x32, 0xb7, 0xa2, 0xa5, 0x96, 0x6a,
	0x99, 0xba, 0x4a, 0xf1, 0xb0, 0x9a, 0x3d, 0x57, 0x35, 0xf1, 0x4b, 0x25, 0x4a, 0xbd, 0x7c, 0x11,
	0xe1, 0x8f, 0x0f, 0xc8, 0x3d, 0x83, 0xc9, 0xcd, 0x27, 0x35, 0x99, 0x34, 0x29, 0xde, 0x28, 0x3c,
	0x6e, 0xbb, 0x98, 0xaf, 0xc2, 0x49, 0xcd, 0xc3, 0xba, 0x2f, 0x80, 0x2c, 0xc8, 0x27, 0xd6, 0x73,
	0x62, 0x54, 0x1c, 0x46, 0x21, 0xee, 0xd5, 0x9f, 0x63, 0x8d, 0xca, 0xb8, 0x31, 0x68, 0x29, 0x2e,
	0x7c, 0x38, 0x4c, 0x6b, 0x16, 0x69, 0xea, 0xca, 0xa0, 0x13, 0x3b, 0xd4, 0x54, 0x2d, 0x5f, 0x0e,
	0x69, 0x72, 0x1f, 0xe3, 0x30, 0xb9, 0x65, 0x91, 0xba, 0x6a, 0xd5, 0x5c, 0xac, 0xb1, 0x11, 0x9b,
	0x30, 0xd5, 0x22, 0x16, 0xc5, 0x9e, 0xa7, 0x2a, 0xb6, 0xea, 0xa8, 0x06, 0xd6, 0x85, 0x38, 0x9b,
	0xb6, 0x70, 0x6e, 0x5a, 0xc5, 0x76, 0x69, 0x7b, 0x9b, 0x93, 0xe7, 0x47, 0xf8, 0xdd, 0x10, 0xce,
	0xef, 0xc2, 0x69, 0x2f, 0x5c, 0x5a, 0x98, 0x60, 0x9d, 0x79, 0xf1, 0x2a, 0x13, 0xc5, 0xe8, 0x07,
	0x16, 0xa7, 0x7b, 0x87, 0xe0, 0xa4, 0x03, 0xc0, 0x36, 0x27, 0x8f, 0x38, 0xf8, 0x47, 0x30, 0xdd,
	0xc2, 0x9e, 0xd9, 0x30, 0x35, 0x75, 0x20, 0x9f, 0x42, 0x1c, 0xab, 0x2d, 0x4c, 0x5e, 0xbd, 0x52,
	0x31, 0xd1, 0x3b, 0x04, 0x47, 0x1d, 0x30, 0x22, 0x4a, 0x8d, 0x77, 0xef, 0x39, 0x56, 0x9b, 0xbf,
	0x0d, 0x21, 0x3d, 0xa0, 0x8a, 0x87, 0x35, 0xe2, 0xe9, 0xc2, 0x54, 0x16, 0xe4, 0x67, 0xe5, 0x59,
	0x7a, 0x40, 0x65, 0x96, 0xe0, 0x2b, 0x30, 0xa1, 0x3b, 0xbe, 0x8f, 0x35, 0xc5, 0x26, 0x3a, 0x16,
	0xa6, 0xb3, 0x20, 0x9f, 0x5c, 0x5f, 0xb9, 0xfa, 0x1b, 0xca, 0xd5, 0x5a, 0xad, 0x52, 0xda, 0x25,
	0x3a, 0x96, 0x61, 0xd8, 0x38, 0x38, 0xdf, 0x5b, 0xfe, 0xd4, 0x01, 0x4b, 0x70, 0x11, 0x2e, 0x94,
	0x19, 0x2c, 0x5b, 0x22, 0x4e, 0xc3, 0x34, 0x9a, 0x1e, 0xdb, 0x83, 0x07, 0xeb, 0xc5, 0x1c, 0x9c,
	0x0b, 0x19, 0x14, 0x6d, 0x9f, 0x98, 0x1a, 0xe6, 0xd3, 0x47, 0x1d, 0x10, 0xef, 0x76, 0x40, 0x2c,
	0xe8, 0x80, 0xc9, 0xc2, 0xea, 0xdd, 0xd5, 0x8d, 0x9d, 0x89, 0x19, 0x90, 0x8a, 0xed, 0x4c, 0xcc,
	0xc4, 0x52, 0xf1, 0xdc, 0x49, 0x0c, 0x26, 0x4b, 0x1e, 0x56, 0x29, 0xbe, 0x49, 0xb7, 0xca, 0xd7,
	0x76, 0x6b, 0xdc, 0xa4, 0xd2, 0x2f, 0x9a, 0x74, 0xa9, 0x2f, 0x37, 0x24, 0x7c, 0xfa, 0xcb, 0xfd,
	0x73, 0xbf, 0xea, 0x4b, 0xa4, 0x7e, 0xfd, 0x1d, 0x44, 0x53, 0x11, 0xa9, 0xbf, 0xc5, 0xe0, 0xbc,
	0x8c, 0x5d, 0x4b, 0xd5, 0xfe, 0x69, 0xfd, 0xbb, 0xb5, 0x7e, 0x17, 0x87, 0x89, 0x2d, 0x4c, 0x7f,
	0xea, 0xfc, 0x1f, 0x9c, 0x0a, 0xc1, 0xec, 0x96, 0x9b, 0x95, 0x87, 0xd1, 0x5f, 0xa6, 0xff, 0x9f,
	0xb9, 0x83, 0xae, 0x6d, 0x4f, 0x2c, 0x15, 0xbf, 0x53, 0x80, 0xf0, 0x8c, 0x96, 0xe7, 0x61, 0x32,
	0x8c, 0x94, 0xf2, 0x83, 0xda, 0x66, 0xf1, 0x61, 0x25, 0xc5, 0xf1, 0x69, 0x38, 0x37, 0xcc, 0x55,
	0xaa, 0x2c, 0x05, 0x8a, 0x6f, 0x40, 0xf7, 0x18, 0x71, 0xbd, 0x63, 0xc4, 0x9d, 0x1e, 0x23, 0xf0,
	0x2a, 0x40, 0xe0, 0x7d, 0x80, 0xc0, 0xe7, 0x00, 0x81, 0x6e, 0x80, 0x40, 0x2f, 0x40, 0xe0, 0x6b,
	0x80, 0xc0, 0x49, 0x80, 0xb8, 0xd3, 0x00, 0x81, 0xb7, 0x7d, 0xc4, 0x1d, 0xf5, 0x11, 0xe8, 0xf6,
	0x11, 0xd7, 0xeb, 0x23, 0xee, 0x69, 0xd5, 0x20, 0xee, 0x0b, 0x43, 0x1c, 0x19, 0x27, 0x36, 0x7d,
	0x89, 0x1d, 0x1a, 0xc4, 0xb3, 0xd7, 0x5c, 0x8f, 0xb4, 0x4c, 0x1d, 0x7b, 0x6b, 0xa3, 0xb2, 0xe4,
	0xd6, 0x0d, 0x22, 0xe1, 0x03, 0x3a, 0x7c, 0x43, 0x2f, 0xfc, 0x95, 0xa8, 0x4f, 0xb1, 0xa7, 0xb4,
	0xf0, 0x23, 0x00, 0x00, 0xff, 0xff, 0x4e, 0xdb, 0xbc, 0x79, 0x6d, 0x08, 0x00, 0x00,
}

func (x DNSSECMode) String() string {
	s, ok := DNSSECMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *AWSRoute53Type) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AWSRoute53Type)
	if !ok {
		that2, ok := that.(AWSRoute53Type)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Creds.Equal(that1.Creds) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.DomainChoice == nil {
		if this.DomainChoice != nil {
			return false
		}
	} else if this.DomainChoice == nil {
		return false
	} else if !this.DomainChoice.Equal(that1.DomainChoice) {
		return false
	}
	if this.TxtRecord != that1.TxtRecord {
		return false
	}
	if this.DnssecMode != that1.DnssecMode {
		return false
	}
	return true
}
func (this *GlobalSpecType_VolterraManaged) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_VolterraManaged)
	if !ok {
		that2, ok := that.(GlobalSpecType_VolterraManaged)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VolterraManaged.Equal(that1.VolterraManaged) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Route53) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Route53)
	if !ok {
		that2, ok := that.(GlobalSpecType_Route53)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Route53.Equal(that1.Route53) {
		return false
	}
	return true
}
func (this *GlobalSpecType_VerificationOnly) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_VerificationOnly)
	if !ok {
		that2, ok := that.(GlobalSpecType_VerificationOnly)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VerificationOnly.Equal(that1.VerificationOnly) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.DomainChoice == nil {
		if this.DomainChoice != nil {
			return false
		}
	} else if this.DomainChoice == nil {
		return false
	} else if !this.DomainChoice.Equal(that1.DomainChoice) {
		return false
	}
	if this.DnssecMode != that1.DnssecMode {
		return false
	}
	return true
}
func (this *CreateSpecType_VolterraManaged) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_VolterraManaged)
	if !ok {
		that2, ok := that.(CreateSpecType_VolterraManaged)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VolterraManaged.Equal(that1.VolterraManaged) {
		return false
	}
	return true
}
func (this *CreateSpecType_Route53) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_Route53)
	if !ok {
		that2, ok := that.(CreateSpecType_Route53)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Route53.Equal(that1.Route53) {
		return false
	}
	return true
}
func (this *CreateSpecType_VerificationOnly) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_VerificationOnly)
	if !ok {
		that2, ok := that.(CreateSpecType_VerificationOnly)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VerificationOnly.Equal(that1.VerificationOnly) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.DomainChoice == nil {
		if this.DomainChoice != nil {
			return false
		}
	} else if this.DomainChoice == nil {
		return false
	} else if !this.DomainChoice.Equal(that1.DomainChoice) {
		return false
	}
	if this.DnssecMode != that1.DnssecMode {
		return false
	}
	return true
}
func (this *ReplaceSpecType_VolterraManaged) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_VolterraManaged)
	if !ok {
		that2, ok := that.(ReplaceSpecType_VolterraManaged)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VolterraManaged.Equal(that1.VolterraManaged) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_Route53) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_Route53)
	if !ok {
		that2, ok := that.(ReplaceSpecType_Route53)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Route53.Equal(that1.Route53) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_VerificationOnly) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_VerificationOnly)
	if !ok {
		that2, ok := that.(ReplaceSpecType_VerificationOnly)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VerificationOnly.Equal(that1.VerificationOnly) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Domain != that1.Domain {
		return false
	}
	if that1.DomainChoice == nil {
		if this.DomainChoice != nil {
			return false
		}
	} else if this.DomainChoice == nil {
		return false
	} else if !this.DomainChoice.Equal(that1.DomainChoice) {
		return false
	}
	if this.TxtRecord != that1.TxtRecord {
		return false
	}
	if this.DnssecMode != that1.DnssecMode {
		return false
	}
	return true
}
func (this *GetSpecType_VolterraManaged) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_VolterraManaged)
	if !ok {
		that2, ok := that.(GetSpecType_VolterraManaged)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VolterraManaged.Equal(that1.VolterraManaged) {
		return false
	}
	return true
}
func (this *GetSpecType_Route53) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_Route53)
	if !ok {
		that2, ok := that.(GetSpecType_Route53)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Route53.Equal(that1.Route53) {
		return false
	}
	return true
}
func (this *GetSpecType_VerificationOnly) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_VerificationOnly)
	if !ok {
		that2, ok := that.(GetSpecType_VerificationOnly)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VerificationOnly.Equal(that1.VerificationOnly) {
		return false
	}
	return true
}
func (this *AWSRoute53Type) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dns_domain.AWSRoute53Type{")
	if this.Creds != nil {
		s = append(s, "Creds: "+fmt.Sprintf("%#v", this.Creds)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&dns_domain.GlobalSpecType{")
	if this.DomainChoice != nil {
		s = append(s, "DomainChoice: "+fmt.Sprintf("%#v", this.DomainChoice)+",\n")
	}
	s = append(s, "TxtRecord: "+fmt.Sprintf("%#v", this.TxtRecord)+",\n")
	s = append(s, "DnssecMode: "+fmt.Sprintf("%#v", this.DnssecMode)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_VolterraManaged) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_domain.GlobalSpecType_VolterraManaged{` +
		`VolterraManaged:` + fmt.Sprintf("%#v", this.VolterraManaged) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_Route53) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_domain.GlobalSpecType_Route53{` +
		`Route53:` + fmt.Sprintf("%#v", this.Route53) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_VerificationOnly) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_domain.GlobalSpecType_VerificationOnly{` +
		`VerificationOnly:` + fmt.Sprintf("%#v", this.VerificationOnly) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dns_domain.CreateSpecType{")
	if this.DomainChoice != nil {
		s = append(s, "DomainChoice: "+fmt.Sprintf("%#v", this.DomainChoice)+",\n")
	}
	s = append(s, "DnssecMode: "+fmt.Sprintf("%#v", this.DnssecMode)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_VolterraManaged) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_domain.CreateSpecType_VolterraManaged{` +
		`VolterraManaged:` + fmt.Sprintf("%#v", this.VolterraManaged) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_Route53) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_domain.CreateSpecType_Route53{` +
		`Route53:` + fmt.Sprintf("%#v", this.Route53) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_VerificationOnly) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_domain.CreateSpecType_VerificationOnly{` +
		`VerificationOnly:` + fmt.Sprintf("%#v", this.VerificationOnly) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dns_domain.ReplaceSpecType{")
	if this.DomainChoice != nil {
		s = append(s, "DomainChoice: "+fmt.Sprintf("%#v", this.DomainChoice)+",\n")
	}
	s = append(s, "DnssecMode: "+fmt.Sprintf("%#v", this.DnssecMode)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_VolterraManaged) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_domain.ReplaceSpecType_VolterraManaged{` +
		`VolterraManaged:` + fmt.Sprintf("%#v", this.VolterraManaged) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_Route53) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_domain.ReplaceSpecType_Route53{` +
		`Route53:` + fmt.Sprintf("%#v", this.Route53) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_VerificationOnly) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_domain.ReplaceSpecType_VerificationOnly{` +
		`VerificationOnly:` + fmt.Sprintf("%#v", this.VerificationOnly) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&dns_domain.GetSpecType{")
	s = append(s, "Domain: "+fmt.Sprintf("%#v", this.Domain)+",\n")
	if this.DomainChoice != nil {
		s = append(s, "DomainChoice: "+fmt.Sprintf("%#v", this.DomainChoice)+",\n")
	}
	s = append(s, "TxtRecord: "+fmt.Sprintf("%#v", this.TxtRecord)+",\n")
	s = append(s, "DnssecMode: "+fmt.Sprintf("%#v", this.DnssecMode)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_VolterraManaged) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_domain.GetSpecType_VolterraManaged{` +
		`VolterraManaged:` + fmt.Sprintf("%#v", this.VolterraManaged) + `}`}, ", ")
	return s
}
func (this *GetSpecType_Route53) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_domain.GetSpecType_Route53{` +
		`Route53:` + fmt.Sprintf("%#v", this.Route53) + `}`}, ", ")
	return s
}
func (this *GetSpecType_VerificationOnly) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dns_domain.GetSpecType_VerificationOnly{` +
		`VerificationOnly:` + fmt.Sprintf("%#v", this.VerificationOnly) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *AWSRoute53Type) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AWSRoute53Type) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AWSRoute53Type) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Creds != nil {
		{
			size, err := m.Creds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DnssecMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DnssecMode))
		i--
		dAtA[i] = 0x38
	}
	if len(m.TxtRecord) > 0 {
		i -= len(m.TxtRecord)
		copy(dAtA[i:], m.TxtRecord)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TxtRecord)))
		i--
		dAtA[i] = 0x32
	}
	if m.DomainChoice != nil {
		{
			size := m.DomainChoice.Size()
			i -= size
			if _, err := m.DomainChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_VolterraManaged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_VolterraManaged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VolterraManaged != nil {
		{
			size, err := m.VolterraManaged.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_Route53) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_Route53) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Route53 != nil {
		{
			size, err := m.Route53.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_VerificationOnly) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_VerificationOnly) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VerificationOnly != nil {
		{
			size, err := m.VerificationOnly.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DnssecMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DnssecMode))
		i--
		dAtA[i] = 0x38
	}
	if m.DomainChoice != nil {
		{
			size := m.DomainChoice.Size()
			i -= size
			if _, err := m.DomainChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_VolterraManaged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_VolterraManaged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VolterraManaged != nil {
		{
			size, err := m.VolterraManaged.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_Route53) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_Route53) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Route53 != nil {
		{
			size, err := m.Route53.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_VerificationOnly) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_VerificationOnly) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VerificationOnly != nil {
		{
			size, err := m.VerificationOnly.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DnssecMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DnssecMode))
		i--
		dAtA[i] = 0x38
	}
	if m.DomainChoice != nil {
		{
			size := m.DomainChoice.Size()
			i -= size
			if _, err := m.DomainChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_VolterraManaged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_VolterraManaged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VolterraManaged != nil {
		{
			size, err := m.VolterraManaged.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_Route53) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_Route53) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Route53 != nil {
		{
			size, err := m.Route53.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_VerificationOnly) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_VerificationOnly) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VerificationOnly != nil {
		{
			size, err := m.VerificationOnly.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DnssecMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DnssecMode))
		i--
		dAtA[i] = 0x38
	}
	if len(m.TxtRecord) > 0 {
		i -= len(m.TxtRecord)
		copy(dAtA[i:], m.TxtRecord)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TxtRecord)))
		i--
		dAtA[i] = 0x32
	}
	if m.DomainChoice != nil {
		{
			size := m.DomainChoice.Size()
			i -= size
			if _, err := m.DomainChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_VolterraManaged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_VolterraManaged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VolterraManaged != nil {
		{
			size, err := m.VolterraManaged.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_Route53) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_Route53) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Route53 != nil {
		{
			size, err := m.Route53.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_VerificationOnly) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_VerificationOnly) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VerificationOnly != nil {
		{
			size, err := m.VerificationOnly.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AWSRoute53Type) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Creds != nil {
		l = m.Creds.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DomainChoice != nil {
		n += m.DomainChoice.Size()
	}
	l = len(m.TxtRecord)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DnssecMode != 0 {
		n += 1 + sovTypes(uint64(m.DnssecMode))
	}
	return n
}

func (m *GlobalSpecType_VolterraManaged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VolterraManaged != nil {
		l = m.VolterraManaged.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_Route53) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Route53 != nil {
		l = m.Route53.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_VerificationOnly) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VerificationOnly != nil {
		l = m.VerificationOnly.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DomainChoice != nil {
		n += m.DomainChoice.Size()
	}
	if m.DnssecMode != 0 {
		n += 1 + sovTypes(uint64(m.DnssecMode))
	}
	return n
}

func (m *CreateSpecType_VolterraManaged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VolterraManaged != nil {
		l = m.VolterraManaged.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_Route53) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Route53 != nil {
		l = m.Route53.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_VerificationOnly) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VerificationOnly != nil {
		l = m.VerificationOnly.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DomainChoice != nil {
		n += m.DomainChoice.Size()
	}
	if m.DnssecMode != 0 {
		n += 1 + sovTypes(uint64(m.DnssecMode))
	}
	return n
}

func (m *ReplaceSpecType_VolterraManaged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VolterraManaged != nil {
		l = m.VolterraManaged.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_Route53) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Route53 != nil {
		l = m.Route53.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_VerificationOnly) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VerificationOnly != nil {
		l = m.VerificationOnly.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DomainChoice != nil {
		n += m.DomainChoice.Size()
	}
	l = len(m.TxtRecord)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DnssecMode != 0 {
		n += 1 + sovTypes(uint64(m.DnssecMode))
	}
	return n
}

func (m *GetSpecType_VolterraManaged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VolterraManaged != nil {
		l = m.VolterraManaged.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_Route53) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Route53 != nil {
		l = m.Route53.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_VerificationOnly) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VerificationOnly != nil {
		l = m.VerificationOnly.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AWSRoute53Type) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AWSRoute53Type{`,
		`Creds:` + strings.Replace(fmt.Sprintf("%v", this.Creds), "ObjectRefType", "views.ObjectRefType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`DomainChoice:` + fmt.Sprintf("%v", this.DomainChoice) + `,`,
		`TxtRecord:` + fmt.Sprintf("%v", this.TxtRecord) + `,`,
		`DnssecMode:` + fmt.Sprintf("%v", this.DnssecMode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_VolterraManaged) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_VolterraManaged{`,
		`VolterraManaged:` + strings.Replace(fmt.Sprintf("%v", this.VolterraManaged), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Route53) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Route53{`,
		`Route53:` + strings.Replace(fmt.Sprintf("%v", this.Route53), "AWSRoute53Type", "AWSRoute53Type", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_VerificationOnly) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_VerificationOnly{`,
		`VerificationOnly:` + strings.Replace(fmt.Sprintf("%v", this.VerificationOnly), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`DomainChoice:` + fmt.Sprintf("%v", this.DomainChoice) + `,`,
		`DnssecMode:` + fmt.Sprintf("%v", this.DnssecMode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_VolterraManaged) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_VolterraManaged{`,
		`VolterraManaged:` + strings.Replace(fmt.Sprintf("%v", this.VolterraManaged), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_Route53) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_Route53{`,
		`Route53:` + strings.Replace(fmt.Sprintf("%v", this.Route53), "AWSRoute53Type", "AWSRoute53Type", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_VerificationOnly) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_VerificationOnly{`,
		`VerificationOnly:` + strings.Replace(fmt.Sprintf("%v", this.VerificationOnly), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`DomainChoice:` + fmt.Sprintf("%v", this.DomainChoice) + `,`,
		`DnssecMode:` + fmt.Sprintf("%v", this.DnssecMode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_VolterraManaged) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_VolterraManaged{`,
		`VolterraManaged:` + strings.Replace(fmt.Sprintf("%v", this.VolterraManaged), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_Route53) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_Route53{`,
		`Route53:` + strings.Replace(fmt.Sprintf("%v", this.Route53), "AWSRoute53Type", "AWSRoute53Type", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_VerificationOnly) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_VerificationOnly{`,
		`VerificationOnly:` + strings.Replace(fmt.Sprintf("%v", this.VerificationOnly), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`Domain:` + fmt.Sprintf("%v", this.Domain) + `,`,
		`DomainChoice:` + fmt.Sprintf("%v", this.DomainChoice) + `,`,
		`TxtRecord:` + fmt.Sprintf("%v", this.TxtRecord) + `,`,
		`DnssecMode:` + fmt.Sprintf("%v", this.DnssecMode) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_VolterraManaged) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_VolterraManaged{`,
		`VolterraManaged:` + strings.Replace(fmt.Sprintf("%v", this.VolterraManaged), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_Route53) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_Route53{`,
		`Route53:` + strings.Replace(fmt.Sprintf("%v", this.Route53), "AWSRoute53Type", "AWSRoute53Type", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_VerificationOnly) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_VerificationOnly{`,
		`VerificationOnly:` + strings.Replace(fmt.Sprintf("%v", this.VerificationOnly), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AWSRoute53Type) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSRoute53Type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSRoute53Type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creds == nil {
				m.Creds = &views.ObjectRefType{}
			}
			if err := m.Creds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraManaged", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DomainChoice = &GlobalSpecType_VolterraManaged{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route53", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSRoute53Type{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DomainChoice = &GlobalSpecType_Route53{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationOnly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DomainChoice = &GlobalSpecType_VerificationOnly{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxtRecord", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxtRecord = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnssecMode", wireType)
			}
			m.DnssecMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DnssecMode |= DNSSECMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraManaged", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DomainChoice = &CreateSpecType_VolterraManaged{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route53", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSRoute53Type{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DomainChoice = &CreateSpecType_Route53{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationOnly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DomainChoice = &CreateSpecType_VerificationOnly{v}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnssecMode", wireType)
			}
			m.DnssecMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DnssecMode |= DNSSECMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraManaged", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DomainChoice = &ReplaceSpecType_VolterraManaged{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route53", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSRoute53Type{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DomainChoice = &ReplaceSpecType_Route53{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationOnly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DomainChoice = &ReplaceSpecType_VerificationOnly{v}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnssecMode", wireType)
			}
			m.DnssecMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DnssecMode |= DNSSECMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraManaged", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DomainChoice = &GetSpecType_VolterraManaged{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route53", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AWSRoute53Type{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DomainChoice = &GetSpecType_Route53{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationOnly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DomainChoice = &GetSpecType_VerificationOnly{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxtRecord", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxtRecord = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnssecMode", wireType)
			}
			m.DnssecMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DnssecMode |= DNSSECMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
