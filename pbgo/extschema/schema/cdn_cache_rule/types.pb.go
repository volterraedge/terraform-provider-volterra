// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/cdn_cache_rule/types.proto

package cdn_cache_rule

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/policy"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/route"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Header Options
//
// x-displayName: "Header Options"
type HeaderOptions int32

const (
	// Proxy Host
	//
	// x-displayName: "Proxy Host"
	// Name of the proxied server
	PROXY_HOST HeaderOptions = 0
	// Referer
	//
	// x-displayName: "Referer"
	// This is the address of the previous web page from which a link to the currently requested page was followed
	REFERER HeaderOptions = 1
	// Scheme
	//
	// x-displayName: "Scheme"
	// The http scheme used: http or https
	SCHEME HeaderOptions = 2
	// User Agent
	//
	// x-displayName: "User Agent"
	// The user agent string of the user agent
	USER_AGENT HeaderOptions = 3
)

var HeaderOptions_name = map[int32]string{
	0: "PROXY_HOST",
	1: "REFERER",
	2: "SCHEME",
	3: "USER_AGENT",
}

var HeaderOptions_value = map[string]int32{
	"PROXY_HOST": 0,
	"REFERER":    1,
	"SCHEME":     2,
	"USER_AGENT": 3,
}

func (HeaderOptions) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_319c6f6fcf27003c, []int{0}
}

// CacheHeaderMatcherType
//
// x-displayName: "Cache Header to Match"
// Header match is done using the name of the header and its value.
// The value match is done using one of the following
//
//	regex match on value
//	exact match of value
//	presence of header
//
// Header Match can also be inverse of above, which be used to check
//
//	missing header or
//	non-matching value
type CacheHeaderMatcherType struct {
	// Name
	//
	// x-displayName: "Name"
	// x-example: "Content-Type"
	// x-required
	// Name of the header
	Name HeaderOptions `protobuf:"varint,1,opt,name=name,proto3,enum=ves.io.schema.cdn_cache_rule.HeaderOptions" json:"name,omitempty"`
	// cache_operator
	//
	// x-displayName: "Operator"
	// Available operators
	Operator *CacheOperator `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
}

func (m *CacheHeaderMatcherType) Reset()      { *m = CacheHeaderMatcherType{} }
func (*CacheHeaderMatcherType) ProtoMessage() {}
func (*CacheHeaderMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_319c6f6fcf27003c, []int{0}
}
func (m *CacheHeaderMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheHeaderMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CacheHeaderMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheHeaderMatcherType.Merge(m, src)
}
func (m *CacheHeaderMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *CacheHeaderMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheHeaderMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_CacheHeaderMatcherType proto.InternalMessageInfo

func (m *CacheHeaderMatcherType) GetName() HeaderOptions {
	if m != nil {
		return m.Name
	}
	return PROXY_HOST
}

func (m *CacheHeaderMatcherType) GetOperator() *CacheOperator {
	if m != nil {
		return m.Operator
	}
	return nil
}

// Cache Operator
//
// x-displayName: "Operator"
type CacheOperator struct {
	// Cache Operator
	//
	// x-required
	// x-displayName: "Operator"
	//
	// Types that are valid to be assigned to CacheOperator:
	//	*CacheOperator_Equals
	//	*CacheOperator_DoesNotEqual
	//	*CacheOperator_Contains
	//	*CacheOperator_DoesNotContain
	//	*CacheOperator_Startswith
	//	*CacheOperator_DoesNotStartWith
	//	*CacheOperator_Endswith
	//	*CacheOperator_DoesNotEndWith
	//	*CacheOperator_MatchRegex
	CacheOperator isCacheOperator_CacheOperator `protobuf_oneof:"cache_operator"`
}

func (m *CacheOperator) Reset()      { *m = CacheOperator{} }
func (*CacheOperator) ProtoMessage() {}
func (*CacheOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_319c6f6fcf27003c, []int{1}
}
func (m *CacheOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CacheOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheOperator.Merge(m, src)
}
func (m *CacheOperator) XXX_Size() int {
	return m.Size()
}
func (m *CacheOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheOperator.DiscardUnknown(m)
}

var xxx_messageInfo_CacheOperator proto.InternalMessageInfo

type isCacheOperator_CacheOperator interface {
	isCacheOperator_CacheOperator()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CacheOperator_Equals struct {
	Equals string `protobuf:"bytes,2,opt,name=Equals,proto3,oneof" json:"Equals,omitempty"`
}
type CacheOperator_DoesNotEqual struct {
	DoesNotEqual string `protobuf:"bytes,3,opt,name=DoesNotEqual,proto3,oneof" json:"DoesNotEqual,omitempty"`
}
type CacheOperator_Contains struct {
	Contains string `protobuf:"bytes,4,opt,name=Contains,proto3,oneof" json:"Contains,omitempty"`
}
type CacheOperator_DoesNotContain struct {
	DoesNotContain string `protobuf:"bytes,5,opt,name=DoesNotContain,proto3,oneof" json:"DoesNotContain,omitempty"`
}
type CacheOperator_Startswith struct {
	Startswith string `protobuf:"bytes,6,opt,name=Startswith,proto3,oneof" json:"Startswith,omitempty"`
}
type CacheOperator_DoesNotStartWith struct {
	DoesNotStartWith string `protobuf:"bytes,7,opt,name=DoesNotStartWith,proto3,oneof" json:"DoesNotStartWith,omitempty"`
}
type CacheOperator_Endswith struct {
	Endswith string `protobuf:"bytes,8,opt,name=Endswith,proto3,oneof" json:"Endswith,omitempty"`
}
type CacheOperator_DoesNotEndWith struct {
	DoesNotEndWith string `protobuf:"bytes,9,opt,name=DoesNotEndWith,proto3,oneof" json:"DoesNotEndWith,omitempty"`
}
type CacheOperator_MatchRegex struct {
	MatchRegex string `protobuf:"bytes,10,opt,name=MatchRegex,proto3,oneof" json:"MatchRegex,omitempty"`
}

func (*CacheOperator_Equals) isCacheOperator_CacheOperator()           {}
func (*CacheOperator_DoesNotEqual) isCacheOperator_CacheOperator()     {}
func (*CacheOperator_Contains) isCacheOperator_CacheOperator()         {}
func (*CacheOperator_DoesNotContain) isCacheOperator_CacheOperator()   {}
func (*CacheOperator_Startswith) isCacheOperator_CacheOperator()       {}
func (*CacheOperator_DoesNotStartWith) isCacheOperator_CacheOperator() {}
func (*CacheOperator_Endswith) isCacheOperator_CacheOperator()         {}
func (*CacheOperator_DoesNotEndWith) isCacheOperator_CacheOperator()   {}
func (*CacheOperator_MatchRegex) isCacheOperator_CacheOperator()       {}

func (m *CacheOperator) GetCacheOperator() isCacheOperator_CacheOperator {
	if m != nil {
		return m.CacheOperator
	}
	return nil
}

func (m *CacheOperator) GetEquals() string {
	if x, ok := m.GetCacheOperator().(*CacheOperator_Equals); ok {
		return x.Equals
	}
	return ""
}

func (m *CacheOperator) GetDoesNotEqual() string {
	if x, ok := m.GetCacheOperator().(*CacheOperator_DoesNotEqual); ok {
		return x.DoesNotEqual
	}
	return ""
}

func (m *CacheOperator) GetContains() string {
	if x, ok := m.GetCacheOperator().(*CacheOperator_Contains); ok {
		return x.Contains
	}
	return ""
}

func (m *CacheOperator) GetDoesNotContain() string {
	if x, ok := m.GetCacheOperator().(*CacheOperator_DoesNotContain); ok {
		return x.DoesNotContain
	}
	return ""
}

func (m *CacheOperator) GetStartswith() string {
	if x, ok := m.GetCacheOperator().(*CacheOperator_Startswith); ok {
		return x.Startswith
	}
	return ""
}

func (m *CacheOperator) GetDoesNotStartWith() string {
	if x, ok := m.GetCacheOperator().(*CacheOperator_DoesNotStartWith); ok {
		return x.DoesNotStartWith
	}
	return ""
}

func (m *CacheOperator) GetEndswith() string {
	if x, ok := m.GetCacheOperator().(*CacheOperator_Endswith); ok {
		return x.Endswith
	}
	return ""
}

func (m *CacheOperator) GetDoesNotEndWith() string {
	if x, ok := m.GetCacheOperator().(*CacheOperator_DoesNotEndWith); ok {
		return x.DoesNotEndWith
	}
	return ""
}

func (m *CacheOperator) GetMatchRegex() string {
	if x, ok := m.GetCacheOperator().(*CacheOperator_MatchRegex); ok {
		return x.MatchRegex
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CacheOperator) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CacheOperator_Equals)(nil),
		(*CacheOperator_DoesNotEqual)(nil),
		(*CacheOperator_Contains)(nil),
		(*CacheOperator_DoesNotContain)(nil),
		(*CacheOperator_Startswith)(nil),
		(*CacheOperator_DoesNotStartWith)(nil),
		(*CacheOperator_Endswith)(nil),
		(*CacheOperator_DoesNotEndWith)(nil),
		(*CacheOperator_MatchRegex)(nil),
	}
}

// PathMatcherType
//
// x-displayName: "Path to Match"
// Path match of the URI can be either be, Prefix match or exact match or regular expression match
type CDNPathMatcherType struct {
	// cache_operator
	//
	// x-displayName: "Path Match"
	// A specification of path match
	Operator *CacheOperator `protobuf:"bytes,1,opt,name=operator,proto3" json:"operator,omitempty"`
}

func (m *CDNPathMatcherType) Reset()      { *m = CDNPathMatcherType{} }
func (*CDNPathMatcherType) ProtoMessage() {}
func (*CDNPathMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_319c6f6fcf27003c, []int{2}
}
func (m *CDNPathMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNPathMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CDNPathMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNPathMatcherType.Merge(m, src)
}
func (m *CDNPathMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *CDNPathMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNPathMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_CDNPathMatcherType proto.InternalMessageInfo

func (m *CDNPathMatcherType) GetOperator() *CacheOperator {
	if m != nil {
		return m.Operator
	}
	return nil
}

// CacheCookieMatcherType
//
// x-displayName: "Cookie Matcher"
// A cookie matcher specifies the name of a single cookie and the criteria to match it. The input has a list of values for each
// cookie in the request.
// A cookie matcher can check for one of the following:
// * Presence or absence of the cookie
// * At least one of the values for the cookie in the request satisfies the MatcherType item
type CacheCookieMatcherType struct {
	// name
	//
	// x-displayName: "Cookie Name"
	// x-example: "Session"
	// x-required
	// A case-sensitive cookie name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// cache_operator
	//
	// x-displayName: "Operator"
	Operator *CacheOperator `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
}

func (m *CacheCookieMatcherType) Reset()      { *m = CacheCookieMatcherType{} }
func (*CacheCookieMatcherType) ProtoMessage() {}
func (*CacheCookieMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_319c6f6fcf27003c, []int{3}
}
func (m *CacheCookieMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheCookieMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CacheCookieMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheCookieMatcherType.Merge(m, src)
}
func (m *CacheCookieMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *CacheCookieMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheCookieMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_CacheCookieMatcherType proto.InternalMessageInfo

func (m *CacheCookieMatcherType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CacheCookieMatcherType) GetOperator() *CacheOperator {
	if m != nil {
		return m.Operator
	}
	return nil
}

// CacheQueryParameterMatcherType
//
// x-displayName: "Query Parameter to Match"
// Query parameter match can be either regex match on value or exact match of value for given key
// An example for HTTP request with query parameter https://gitlab.com/dashboard/issues?assignee_username=xxyyxx
type CacheQueryParameterMatcherType struct {
	// key
	//
	// x-displayName: "Key"
	// x-required
	// x-example: "assignee_username"
	// Query parameter key
	// In the above example, assignee_username is the key
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// cache_operator
	//
	// x-displayName: "Operator"
	Operator *CacheOperator `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
}

func (m *CacheQueryParameterMatcherType) Reset()      { *m = CacheQueryParameterMatcherType{} }
func (*CacheQueryParameterMatcherType) ProtoMessage() {}
func (*CacheQueryParameterMatcherType) Descriptor() ([]byte, []int) {
	return fileDescriptor_319c6f6fcf27003c, []int{4}
}
func (m *CacheQueryParameterMatcherType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheQueryParameterMatcherType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CacheQueryParameterMatcherType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheQueryParameterMatcherType.Merge(m, src)
}
func (m *CacheQueryParameterMatcherType) XXX_Size() int {
	return m.Size()
}
func (m *CacheQueryParameterMatcherType) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheQueryParameterMatcherType.DiscardUnknown(m)
}

var xxx_messageInfo_CacheQueryParameterMatcherType proto.InternalMessageInfo

func (m *CacheQueryParameterMatcherType) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *CacheQueryParameterMatcherType) GetOperator() *CacheOperator {
	if m != nil {
		return m.Operator
	}
	return nil
}

// CDNCacheRuleExpression
//
// x-displayName: "Cache Rule Expression"
// Select one of the field options
type CDNCacheRuleExpression struct {
	// path_match
	//
	// x-displayName: "Path Match"
	// URI path of route
	PathMatch *CDNPathMatcherType `protobuf:"bytes,1,opt,name=path_match,json=pathMatch,proto3" json:"path_match,omitempty"`
	// query_params
	//
	// x-displayName: "Query Parameters"
	// List of (key, value) query parameters
	QueryParameters []*CacheQueryParameterMatcherType `protobuf:"bytes,2,rep,name=query_parameters,json=queryParameters,proto3" json:"query_parameters,omitempty"`
	// Cache Headers
	//
	// x-displayName: "Cache Headers"
	// Configure cache rule headers to match the criteria
	CacheHeaders []*CacheHeaderMatcherType `protobuf:"bytes,3,rep,name=cache_headers,json=cacheHeaders,proto3" json:"cache_headers,omitempty"`
	// cookie matchers
	//
	// x-displayName: "Cookie Matchers"
	// A list of predicates for all cookies that need to be matched. The criteria for matching each cookie is described in individual instances
	// of CookieMatcherType. The actual cookie values are extracted from the request API as a list of strings for each cookie name.
	// Note that all specified cookie matcher predicates must evaluate to true.
	CookieMatcher []*CacheCookieMatcherType `protobuf:"bytes,4,rep,name=cookie_matcher,json=cookieMatcher,proto3" json:"cookie_matcher,omitempty"`
}

func (m *CDNCacheRuleExpression) Reset()      { *m = CDNCacheRuleExpression{} }
func (*CDNCacheRuleExpression) ProtoMessage() {}
func (*CDNCacheRuleExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_319c6f6fcf27003c, []int{5}
}
func (m *CDNCacheRuleExpression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNCacheRuleExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CDNCacheRuleExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNCacheRuleExpression.Merge(m, src)
}
func (m *CDNCacheRuleExpression) XXX_Size() int {
	return m.Size()
}
func (m *CDNCacheRuleExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNCacheRuleExpression.DiscardUnknown(m)
}

var xxx_messageInfo_CDNCacheRuleExpression proto.InternalMessageInfo

func (m *CDNCacheRuleExpression) GetPathMatch() *CDNPathMatcherType {
	if m != nil {
		return m.PathMatch
	}
	return nil
}

func (m *CDNCacheRuleExpression) GetQueryParameters() []*CacheQueryParameterMatcherType {
	if m != nil {
		return m.QueryParameters
	}
	return nil
}

func (m *CDNCacheRuleExpression) GetCacheHeaders() []*CacheHeaderMatcherType {
	if m != nil {
		return m.CacheHeaders
	}
	return nil
}

func (m *CDNCacheRuleExpression) GetCookieMatcher() []*CacheCookieMatcherType {
	if m != nil {
		return m.CookieMatcher
	}
	return nil
}

// Cache Rule Expression List
//
// x-displayName: "Cache Rule Expression List"
// CDN Cache Rule Expressions.
type CDNCacheRuleExpressionList struct {
	// Expression Name
	//
	// x-displayName: "Expression Name"
	// x-required
	// x-example: "Expression-1"
	// Name of the Expressions items that are ANDed
	ExpressionName string `protobuf:"bytes,1,opt,name=expression_name,json=expressionName,proto3" json:"expression_name,omitempty"`
	// Terms
	//
	// x-displayName: "Terms"
	// x-required
	// The Cache Rule Expression Terms that are ANDed
	CacheRuleExpression []*CDNCacheRuleExpression `protobuf:"bytes,2,rep,name=cache_rule_expression,json=cacheRuleExpression,proto3" json:"cache_rule_expression,omitempty"`
}

func (m *CDNCacheRuleExpressionList) Reset()      { *m = CDNCacheRuleExpressionList{} }
func (*CDNCacheRuleExpressionList) ProtoMessage() {}
func (*CDNCacheRuleExpressionList) Descriptor() ([]byte, []int) {
	return fileDescriptor_319c6f6fcf27003c, []int{6}
}
func (m *CDNCacheRuleExpressionList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNCacheRuleExpressionList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CDNCacheRuleExpressionList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNCacheRuleExpressionList.Merge(m, src)
}
func (m *CDNCacheRuleExpressionList) XXX_Size() int {
	return m.Size()
}
func (m *CDNCacheRuleExpressionList) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNCacheRuleExpressionList.DiscardUnknown(m)
}

var xxx_messageInfo_CDNCacheRuleExpressionList proto.InternalMessageInfo

func (m *CDNCacheRuleExpressionList) GetExpressionName() string {
	if m != nil {
		return m.ExpressionName
	}
	return ""
}

func (m *CDNCacheRuleExpressionList) GetCacheRuleExpression() []*CDNCacheRuleExpression {
	if m != nil {
		return m.CacheRuleExpression
	}
	return nil
}

// Cache TTL Enable Props
//
// x-displayName: "Cache TTL Enable Props"
// Cache TTL Enable Values
type CacheTTLEnableProps struct {
	// Cache TTL Key
	//
	// x-displayName: "Cache TTL"
	// x-required
	// x-example: "5m, 60s, 120s, 3h, 1d, 15d"
	// Cache TTL value is used to cache the resource/content for the specified amount of time
	// Format: [0-9][smhd], where s - seconds, m - minutes, h - hours, d - days
	CacheTtl string `protobuf:"bytes,1,opt,name=cache_ttl,json=cacheTtl,proto3" json:"cache_ttl,omitempty"`
	// Set Cookie
	//
	// x-displayName: "Set-Cookie"
	// When enabled, the upstream cookie is sent to the client
	IgnoreResponseCookie bool `protobuf:"varint,2,opt,name=ignore_response_cookie,json=ignoreResponseCookie,proto3" json:"ignore_response_cookie,omitempty"`
	// Cache Override
	//
	// x-displayName: "Cache Override"
	// Honour Cache Override
	CacheOverride bool `protobuf:"varint,3,opt,name=cache_override,json=cacheOverride,proto3" json:"cache_override,omitempty"`
}

func (m *CacheTTLEnableProps) Reset()      { *m = CacheTTLEnableProps{} }
func (*CacheTTLEnableProps) ProtoMessage() {}
func (*CacheTTLEnableProps) Descriptor() ([]byte, []int) {
	return fileDescriptor_319c6f6fcf27003c, []int{7}
}
func (m *CacheTTLEnableProps) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheTTLEnableProps) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CacheTTLEnableProps) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheTTLEnableProps.Merge(m, src)
}
func (m *CacheTTLEnableProps) XXX_Size() int {
	return m.Size()
}
func (m *CacheTTLEnableProps) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheTTLEnableProps.DiscardUnknown(m)
}

var xxx_messageInfo_CacheTTLEnableProps proto.InternalMessageInfo

func (m *CacheTTLEnableProps) GetCacheTtl() string {
	if m != nil {
		return m.CacheTtl
	}
	return ""
}

func (m *CacheTTLEnableProps) GetIgnoreResponseCookie() bool {
	if m != nil {
		return m.IgnoreResponseCookie
	}
	return false
}

func (m *CacheTTLEnableProps) GetCacheOverride() bool {
	if m != nil {
		return m.CacheOverride
	}
	return false
}

// Cache Action Options
//
// x-displayName: "Cache Action Options"
// List of options for Cache Action
type CacheEligibleOptions struct {
	// Eligible For Cache
	//
	// x-displayName: "Eligible For Cache"
	// x-required
	// Compose Eligible For Cache
	//
	// Types that are valid to be assigned to EligibleForCache:
	//	*CacheEligibleOptions_SchemeProxyHostUri
	//	*CacheEligibleOptions_SchemeProxyHostRequestUri
	EligibleForCache isCacheEligibleOptions_EligibleForCache `protobuf_oneof:"eligible_for_cache"`
}

func (m *CacheEligibleOptions) Reset()      { *m = CacheEligibleOptions{} }
func (*CacheEligibleOptions) ProtoMessage() {}
func (*CacheEligibleOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_319c6f6fcf27003c, []int{8}
}
func (m *CacheEligibleOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CacheEligibleOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CacheEligibleOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheEligibleOptions.Merge(m, src)
}
func (m *CacheEligibleOptions) XXX_Size() int {
	return m.Size()
}
func (m *CacheEligibleOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheEligibleOptions.DiscardUnknown(m)
}

var xxx_messageInfo_CacheEligibleOptions proto.InternalMessageInfo

type isCacheEligibleOptions_EligibleForCache interface {
	isCacheEligibleOptions_EligibleForCache()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CacheEligibleOptions_SchemeProxyHostUri struct {
	SchemeProxyHostUri *CacheTTLEnableProps `protobuf:"bytes,2,opt,name=scheme_proxy_host_uri,json=schemeProxyHostUri,proto3,oneof" json:"scheme_proxy_host_uri,omitempty"`
}
type CacheEligibleOptions_SchemeProxyHostRequestUri struct {
	SchemeProxyHostRequestUri *CacheTTLEnableProps `protobuf:"bytes,3,opt,name=scheme_proxy_host_request_uri,json=schemeProxyHostRequestUri,proto3,oneof" json:"scheme_proxy_host_request_uri,omitempty"`
}

func (*CacheEligibleOptions_SchemeProxyHostUri) isCacheEligibleOptions_EligibleForCache()        {}
func (*CacheEligibleOptions_SchemeProxyHostRequestUri) isCacheEligibleOptions_EligibleForCache() {}

func (m *CacheEligibleOptions) GetEligibleForCache() isCacheEligibleOptions_EligibleForCache {
	if m != nil {
		return m.EligibleForCache
	}
	return nil
}

func (m *CacheEligibleOptions) GetSchemeProxyHostUri() *CacheTTLEnableProps {
	if x, ok := m.GetEligibleForCache().(*CacheEligibleOptions_SchemeProxyHostUri); ok {
		return x.SchemeProxyHostUri
	}
	return nil
}

func (m *CacheEligibleOptions) GetSchemeProxyHostRequestUri() *CacheTTLEnableProps {
	if x, ok := m.GetEligibleForCache().(*CacheEligibleOptions_SchemeProxyHostRequestUri); ok {
		return x.SchemeProxyHostRequestUri
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CacheEligibleOptions) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CacheEligibleOptions_SchemeProxyHostUri)(nil),
		(*CacheEligibleOptions_SchemeProxyHostRequestUri)(nil),
	}
}

// Cache Rule
//
// x-displayName: "Cache Rule"
// This defines a CDN Cache Rule
type CDNCacheRule struct {
	// Rule Name
	//
	// x-displayName: "Rule Name"
	// x-required
	// x-example: "Rule-1"
	// Name of the Cache Rule
	RuleName string `protobuf:"bytes,1,opt,name=rule_name,json=ruleName,proto3" json:"rule_name,omitempty"`
	// Expression List
	//
	// x-displayName: "Expressions"
	// x-required
	// Expressions are evaluated in the order in which they are specified. The evaluation stops when the first rule match occurs..
	RuleExpressionList []*CDNCacheRuleExpressionList `protobuf:"bytes,2,rep,name=rule_expression_list,json=ruleExpressionList,proto3" json:"rule_expression_list,omitempty"`
	// Cache Actions
	//
	// x-displayName: "Cache Actions"
	// x-required
	// Configure the Cache Actions for a rule.
	//
	// Types that are valid to be assigned to CacheActions:
	//	*CDNCacheRule_CacheBypass
	//	*CDNCacheRule_EligibleForCache
	CacheActions isCDNCacheRule_CacheActions `protobuf_oneof:"cache_actions"`
}

func (m *CDNCacheRule) Reset()      { *m = CDNCacheRule{} }
func (*CDNCacheRule) ProtoMessage() {}
func (*CDNCacheRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_319c6f6fcf27003c, []int{9}
}
func (m *CDNCacheRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDNCacheRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CDNCacheRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDNCacheRule.Merge(m, src)
}
func (m *CDNCacheRule) XXX_Size() int {
	return m.Size()
}
func (m *CDNCacheRule) XXX_DiscardUnknown() {
	xxx_messageInfo_CDNCacheRule.DiscardUnknown(m)
}

var xxx_messageInfo_CDNCacheRule proto.InternalMessageInfo

type isCDNCacheRule_CacheActions interface {
	isCDNCacheRule_CacheActions()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CDNCacheRule_CacheBypass struct {
	CacheBypass *schema.Empty `protobuf:"bytes,4,opt,name=cache_bypass,json=cacheBypass,proto3,oneof" json:"cache_bypass,omitempty"`
}
type CDNCacheRule_EligibleForCache struct {
	EligibleForCache *CacheEligibleOptions `protobuf:"bytes,5,opt,name=eligible_for_cache,json=eligibleForCache,proto3,oneof" json:"eligible_for_cache,omitempty"`
}

func (*CDNCacheRule_CacheBypass) isCDNCacheRule_CacheActions()      {}
func (*CDNCacheRule_EligibleForCache) isCDNCacheRule_CacheActions() {}

func (m *CDNCacheRule) GetCacheActions() isCDNCacheRule_CacheActions {
	if m != nil {
		return m.CacheActions
	}
	return nil
}

func (m *CDNCacheRule) GetRuleName() string {
	if m != nil {
		return m.RuleName
	}
	return ""
}

func (m *CDNCacheRule) GetRuleExpressionList() []*CDNCacheRuleExpressionList {
	if m != nil {
		return m.RuleExpressionList
	}
	return nil
}

func (m *CDNCacheRule) GetCacheBypass() *schema.Empty {
	if x, ok := m.GetCacheActions().(*CDNCacheRule_CacheBypass); ok {
		return x.CacheBypass
	}
	return nil
}

func (m *CDNCacheRule) GetEligibleForCache() *CacheEligibleOptions {
	if x, ok := m.GetCacheActions().(*CDNCacheRule_EligibleForCache); ok {
		return x.EligibleForCache
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CDNCacheRule) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CDNCacheRule_CacheBypass)(nil),
		(*CDNCacheRule_EligibleForCache)(nil),
	}
}

// GlobalSpecType
//
// x-displayName: "Global Specification"
// Shape of the CDN cache rule specification
type GlobalSpecType struct {
	// List of Cache rules(These rules are ORed)
	//
	// x-displayName: "Cache Rules"
	// Rules are evaluated in the order in which they are specified. The evaluation stops when the first rule match occurs.
	CacheRules *CDNCacheRule `protobuf:"bytes,1,opt,name=cache_rules,json=cacheRules,proto3" json:"cache_rules,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_319c6f6fcf27003c, []int{10}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetCacheRules() *CDNCacheRule {
	if m != nil {
		return m.CacheRules
	}
	return nil
}

// CreateSpecType
//
// x-displayName: "Create CDN cache rule"
// Shape of the CDN loadbalancer specification
type CreateSpecType struct {
	CacheRules *CDNCacheRule `protobuf:"bytes,1,opt,name=cache_rules,json=cacheRules,proto3" json:"cache_rules,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_319c6f6fcf27003c, []int{11}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

func (m *CreateSpecType) GetCacheRules() *CDNCacheRule {
	if m != nil {
		return m.CacheRules
	}
	return nil
}

// ReplaceSpecType
//
// x-displayName: "Replace CDN cache rule"
// Shape of the CDN loadbalancer specification
type ReplaceSpecType struct {
	CacheRules *CDNCacheRule `protobuf:"bytes,1,opt,name=cache_rules,json=cacheRules,proto3" json:"cache_rules,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_319c6f6fcf27003c, []int{12}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

func (m *ReplaceSpecType) GetCacheRules() *CDNCacheRule {
	if m != nil {
		return m.CacheRules
	}
	return nil
}

// GetSpecType
//
// x-displayName: "Get CDN cache rule"
// Shape of the CDN loadbalancer specification
type GetSpecType struct {
	CacheRules *CDNCacheRule `protobuf:"bytes,1,opt,name=cache_rules,json=cacheRules,proto3" json:"cache_rules,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_319c6f6fcf27003c, []int{13}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

func (m *GetSpecType) GetCacheRules() *CDNCacheRule {
	if m != nil {
		return m.CacheRules
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.cdn_cache_rule.HeaderOptions", HeaderOptions_name, HeaderOptions_value)
	golang_proto.RegisterEnum("ves.io.schema.cdn_cache_rule.HeaderOptions", HeaderOptions_name, HeaderOptions_value)
	proto.RegisterType((*CacheHeaderMatcherType)(nil), "ves.io.schema.cdn_cache_rule.CacheHeaderMatcherType")
	golang_proto.RegisterType((*CacheHeaderMatcherType)(nil), "ves.io.schema.cdn_cache_rule.CacheHeaderMatcherType")
	proto.RegisterType((*CacheOperator)(nil), "ves.io.schema.cdn_cache_rule.CacheOperator")
	golang_proto.RegisterType((*CacheOperator)(nil), "ves.io.schema.cdn_cache_rule.CacheOperator")
	proto.RegisterType((*CDNPathMatcherType)(nil), "ves.io.schema.cdn_cache_rule.CDNPathMatcherType")
	golang_proto.RegisterType((*CDNPathMatcherType)(nil), "ves.io.schema.cdn_cache_rule.CDNPathMatcherType")
	proto.RegisterType((*CacheCookieMatcherType)(nil), "ves.io.schema.cdn_cache_rule.CacheCookieMatcherType")
	golang_proto.RegisterType((*CacheCookieMatcherType)(nil), "ves.io.schema.cdn_cache_rule.CacheCookieMatcherType")
	proto.RegisterType((*CacheQueryParameterMatcherType)(nil), "ves.io.schema.cdn_cache_rule.CacheQueryParameterMatcherType")
	golang_proto.RegisterType((*CacheQueryParameterMatcherType)(nil), "ves.io.schema.cdn_cache_rule.CacheQueryParameterMatcherType")
	proto.RegisterType((*CDNCacheRuleExpression)(nil), "ves.io.schema.cdn_cache_rule.CDNCacheRuleExpression")
	golang_proto.RegisterType((*CDNCacheRuleExpression)(nil), "ves.io.schema.cdn_cache_rule.CDNCacheRuleExpression")
	proto.RegisterType((*CDNCacheRuleExpressionList)(nil), "ves.io.schema.cdn_cache_rule.CDNCacheRuleExpressionList")
	golang_proto.RegisterType((*CDNCacheRuleExpressionList)(nil), "ves.io.schema.cdn_cache_rule.CDNCacheRuleExpressionList")
	proto.RegisterType((*CacheTTLEnableProps)(nil), "ves.io.schema.cdn_cache_rule.CacheTTLEnableProps")
	golang_proto.RegisterType((*CacheTTLEnableProps)(nil), "ves.io.schema.cdn_cache_rule.CacheTTLEnableProps")
	proto.RegisterType((*CacheEligibleOptions)(nil), "ves.io.schema.cdn_cache_rule.CacheEligibleOptions")
	golang_proto.RegisterType((*CacheEligibleOptions)(nil), "ves.io.schema.cdn_cache_rule.CacheEligibleOptions")
	proto.RegisterType((*CDNCacheRule)(nil), "ves.io.schema.cdn_cache_rule.CDNCacheRule")
	golang_proto.RegisterType((*CDNCacheRule)(nil), "ves.io.schema.cdn_cache_rule.CDNCacheRule")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.cdn_cache_rule.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.cdn_cache_rule.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.cdn_cache_rule.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.cdn_cache_rule.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.cdn_cache_rule.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.cdn_cache_rule.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.cdn_cache_rule.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.cdn_cache_rule.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/cdn_cache_rule/types.proto", fileDescriptor_319c6f6fcf27003c)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/cdn_cache_rule/types.proto", fileDescriptor_319c6f6fcf27003c)
}

var fileDescriptor_319c6f6fcf27003c = []byte{
	// 1957 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x59, 0x4d, 0x6c, 0xdb, 0xc8,
	0x15, 0xd6, 0x48, 0xb4, 0x2d, 0x3f, 0x39, 0xb2, 0x3c, 0x76, 0x52, 0x59, 0xf5, 0x32, 0x5c, 0x21,
	0x41, 0xdd, 0xac, 0x22, 0xc7, 0xb2, 0xdb, 0xcd, 0xba, 0x8b, 0x04, 0x2b, 0x45, 0x6b, 0xef, 0x6e,
	0x62, 0x7b, 0x69, 0xbb, 0x7f, 0x17, 0x81, 0x96, 0xc7, 0x32, 0x11, 0x49, 0x43, 0x0f, 0x29, 0x6f,
	0x7c, 0x28, 0x90, 0x43, 0x2f, 0x2d, 0xda, 0x62, 0xd1, 0x6b, 0x6f, 0x3d, 0xed, 0xa9, 0x68, 0x4f,
	0x05, 0xaa, 0x16, 0x70, 0x03, 0x14, 0x28, 0x5c, 0xa0, 0xf5, 0x65, 0x81, 0x00, 0xbd, 0x34, 0xf6,
	0xa1, 0x3f, 0xe8, 0x21, 0x08, 0x72, 0xeb, 0xa5, 0xe0, 0x0c, 0x29, 0x91, 0x12, 0x25, 0x2b, 0x41,
	0xb3, 0x87, 0x22, 0x27, 0x91, 0xf3, 0xde, 0xbc, 0xbf, 0xf9, 0xde, 0x37, 0x33, 0x14, 0xcc, 0x1e,
	0x10, 0x33, 0xab, 0xd3, 0x39, 0xb3, 0xbc, 0x47, 0x6a, 0xda, 0x5c, 0x79, 0xa7, 0x5e, 0x2a, 0x6b,
	0xe5, 0x3d, 0x52, 0x62, 0x8d, 0x2a, 0x99, 0xb3, 0x0e, 0x0d, 0x62, 0x66, 0x0d, 0x46, 0x2d, 0x8a,
	0x67, 0x84, 0x66, 0x56, 0x68, 0x66, 0xfd, 0x9a, 0xa9, 0xeb, 0x15, 0xdd, 0xda, 0x6b, 0x6c, 0x67,
	0xcb, 0xb4, 0x36, 0x57, 0xa1, 0x15, 0x3a, 0xc7, 0x27, 0x6d, 0x37, 0x76, 0xf9, 0x1b, 0x7f, 0xe1,
	0x4f, 0xc2, 0x58, 0xea, 0x72, 0x85, 0xd2, 0x4a, 0x95, 0xb4, 0xb5, 0x2c, 0xbd, 0x46, 0x4c, 0x4b,
	0xab, 0x19, 0x8e, 0xc2, 0x97, 0xfd, 0x71, 0x51, 0xc3, 0xd2, 0x69, 0xdd, 0x09, 0x25, 0xa5, 0xf8,
	0x85, 0x06, 0xad, 0xea, 0xe5, 0x43, 0x6f, 0xb0, 0xa9, 0xcb, 0x7e, 0x0d, 0x46, 0x1b, 0x96, 0x2f,
	0x9b, 0xd4, 0xb4, 0x5f, 0xc1, 0x2b, 0x9a, 0xf1, 0x8b, 0x0e, 0xb4, 0xaa, 0xbe, 0xa3, 0x59, 0x24,
	0xd8, 0xf7, 0x81, 0x4e, 0x3e, 0x29, 0xf9, 0xa3, 0xbb, 0xdc, 0xad, 0x61, 0x7a, 0x1d, 0xa4, 0x7f,
	0x32, 0x0c, 0x97, 0x0a, 0x76, 0xe9, 0x56, 0x88, 0xb6, 0x43, 0xd8, 0x3d, 0xcd, 0x2a, 0xef, 0x11,
	0xb6, 0x79, 0x68, 0x10, 0x7c, 0x1b, 0xa4, 0xba, 0x56, 0x23, 0x49, 0xa4, 0xa0, 0xd9, 0x78, 0xee,
	0xad, 0x6c, 0xbf, 0x9a, 0x67, 0xc5, 0xf4, 0x35, 0xe1, 0x5c, 0xe5, 0x13, 0xf1, 0x3d, 0x88, 0x52,
	0x83, 0x30, 0xcd, 0xa2, 0x2c, 0x19, 0x56, 0xd0, 0x6c, 0xec, 0x3c, 0x23, 0x3c, 0x90, 0x35, 0x67,
	0x4a, 0x5e, 0x7a, 0xda, 0x44, 0x48, 0x6d, 0x99, 0x58, 0x3a, 0x93, 0x1e, 0x35, 0x51, 0x12, 0x2e,
	0xc1, 0xb8, 0x70, 0xa6, 0x58, 0x54, 0xe1, 0xf1, 0xe2, 0xc8, 0x7c, 0x26, 0x77, 0xdc, 0x44, 0x8f,
	0x24, 0x48, 0x80, 0xb4, 0xaa, 0xd5, 0x48, 0x2a, 0x2a, 0x62, 0x57, 0x10, 0xfc, 0x35, 0x0c, 0x51,
	0xd7, 0xe4, 0xb5, 0x3f, 0x87, 0xe1, 0x4f, 0x61, 0x98, 0x86, 0x71, 0xd7, 0x68, 0xb6, 0xb8, 0xdf,
	0xd0, 0xaa, 0x66, 0x6e, 0x58, 0xfc, 0xc2, 0x55, 0xb8, 0xd8, 0x12, 0xdd, 0xa1, 0xc4, 0x5c, 0xa5,
	0x16, 0x97, 0xe4, 0xc6, 0xbc, 0x6f, 0xf0, 0x06, 0x4c, 0xb4, 0xd4, 0x0a, 0xb4, 0x6e, 0x69, 0x7a,
	0xdd, 0xcc, 0x45, 0xdd, 0x27, 0xf8, 0x2a, 0x7c, 0xa9, 0xd3, 0x8a, 0x23, 0xcb, 0xc5, 0xfd, 0xef,
	0xf0, 0x26, 0x4c, 0xb6, 0x54, 0x37, 0x2c, 0x8d, 0x59, 0xe6, 0x27, 0xba, 0xb5, 0x97, 0x83, 0xf6,
	0x33, 0x5c, 0x87, 0xe9, 0x4e, 0x6b, 0x5c, 0xfa, 0x2d, 0x5b, 0x31, 0xd1, 0x39, 0xe2, 0x8b, 0xad,
	0x58, 0xdf, 0x11, 0xf6, 0xa2, 0xee, 0x53, 0x50, 0x6c, 0xc5, 0xfa, 0x0e, 0xb7, 0x15, 0xf7, 0xbf,
	0xfb, 0x62, 0xe3, 0x85, 0x56, 0x49, 0x85, 0x3c, 0xc8, 0x41, 0xfb, 0x19, 0xfe, 0x82, 0x60, 0xe8,
	0x9b, 0x5a, 0xb5, 0x41, 0x72, 0x7f, 0x40, 0x5d, 0x55, 0xed, 0x51, 0xcb, 0x80, 0xda, 0xf5, 0xac,
	0x57, 0x60, 0x75, 0xfa, 0xd4, 0x23, 0x20, 0xf7, 0x9e, 0xf9, 0x06, 0x66, 0x97, 0xfe, 0x41, 0x04,
	0x2e, 0xf8, 0x70, 0x88, 0x93, 0xe0, 0xa0, 0x83, 0x83, 0x78, 0x74, 0x25, 0xa4, 0x3a, 0xef, 0xf8,
	0x0a, 0xf8, 0x60, 0x91, 0x8c, 0x38, 0x72, 0xdf, 0x28, 0x9e, 0x81, 0x16, 0x32, 0x92, 0x92, 0xa3,
	0xd1, 0x1a, 0xc1, 0xb3, 0xd0, 0x01, 0x89, 0xe4, 0x90, 0xa3, 0xd3, 0x31, 0x8e, 0x15, 0xf0, 0xa0,
	0x22, 0x39, 0xec, 0x68, 0x79, 0xc6, 0x70, 0x06, 0xba, 0xe0, 0x90, 0x1c, 0x71, 0xf4, 0xba, 0x24,
	0x76, 0x5c, 0x6e, 0x8d, 0x92, 0x51, 0x37, 0x2e, 0x77, 0xc4, 0x13, 0x97, 0x53, 0xae, 0xe4, 0x68,
	0x47, 0x5c, 0xce, 0xb8, 0x1d, 0x57, 0xbb, 0x7e, 0x49, 0x70, 0xe3, 0x6a, 0x8f, 0xe5, 0x6f, 0x40,
	0x5c, 0x74, 0xb9, 0x5b, 0x70, 0x2c, 0x1f, 0x35, 0x51, 0xf8, 0xa4, 0x89, 0xd0, 0x69, 0x13, 0xe1,
	0x5c, 0x66, 0x21, 0xb3, 0x98, 0xf9, 0x5a, 0xe6, 0xeb, 0x99, 0xb7, 0x33, 0x37, 0x33, 0xef, 0x64,
	0xe6, 0x6f, 0x7c, 0x28, 0x45, 0x51, 0x22, 0x9c, 0x2e, 0x03, 0x2e, 0xdc, 0x59, 0x5d, 0xd7, 0xac,
	0x3d, 0x2f, 0x2f, 0x79, 0x69, 0x05, 0xbd, 0x04, 0xad, 0xfc, 0xf2, 0xb7, 0x5e, 0x5a, 0x49, 0x3f,
	0x1f, 0x72, 0x18, 0xb0, 0x40, 0xe9, 0x7d, 0x9d, 0x78, 0x3d, 0xc9, 0x1e, 0x06, 0x1c, 0xcd, 0xc3,
	0x6f, 0xfe, 0x79, 0x14, 0x19, 0x62, 0x91, 0xd9, 0x87, 0xe1, 0x57, 0x43, 0x70, 0xff, 0xb2, 0x09,
	0xee, 0x4d, 0xb8, 0x0c, 0x49, 0xae, 0xa7, 0xac, 0x6b, 0x4c, 0xab, 0x11, 0x8b, 0x30, 0x65, 0xb3,
	0x83, 0xe9, 0x8e, 0x24, 0x88, 0x3b, 0x4c, 0x37, 0x2c, 0x62, 0x7c, 0xcd, 0x73, 0xaf, 0x79, 0xee,
	0x85, 0x78, 0xee, 0xc7, 0xc3, 0x20, 0x73, 0x98, 0x7d, 0xdc, 0x20, 0xec, 0xb0, 0x05, 0x35, 0x2f,
	0xfc, 0xaf, 0x42, 0xe4, 0x3e, 0x39, 0x74, 0xd0, 0x3f, 0xd9, 0x46, 0xbf, 0xfd, 0x24, 0xb1, 0xb0,
	0x82, 0x54, 0x5b, 0xfe, 0xbf, 0xee, 0x82, 0xe7, 0xad, 0x2e, 0xe0, 0x91, 0xf5, 0xe9, 0x82, 0x63,
	0x09, 0xc6, 0x20, 0xf2, 0x11, 0x39, 0x4c, 0x0d, 0xf1, 0x48, 0xe1, 0x49, 0x18, 0xe2, 0x5c, 0x43,
	0x79, 0xdd, 0x09, 0xaf, 0xaa, 0x13, 0x3e, 0x47, 0x10, 0x13, 0x35, 0xfe, 0xff, 0xea, 0x87, 0xdf,
	0xc7, 0xe0, 0x52, 0xe1, 0xce, 0x2a, 0xc7, 0xa6, 0xda, 0xa8, 0x92, 0xe2, 0x03, 0x83, 0x11, 0xd3,
	0xd4, 0x69, 0x1d, 0x6f, 0x01, 0x18, 0x9a, 0xb5, 0x57, 0xaa, 0xd9, 0xda, 0xce, 0x96, 0x73, 0xe3,
	0x1c, 0x88, 0x77, 0x6d, 0x5b, 0x0e, 0xce, 0x47, 0x0d, 0x77, 0x18, 0x7f, 0x0f, 0x12, 0xfb, 0x36,
	0xc2, 0x4b, 0x86, 0x8b, 0x70, 0xfb, 0x84, 0x11, 0x99, 0x8d, 0xe5, 0xde, 0x1d, 0xa0, 0x7f, 0x7a,
	0xb6, 0x6d, 0x7e, 0x8a, 0x77, 0xea, 0x4f, 0x51, 0x38, 0x11, 0x75, 0x9f, 0x92, 0x48, 0x1d, 0xdf,
	0xf7, 0x4d, 0x30, 0x31, 0x85, 0x0b, 0xc2, 0xe6, 0x1e, 0x3f, 0x4d, 0x9b, 0xc9, 0x08, 0xf7, 0xbd,
	0x38, 0x80, 0xef, 0xae, 0xbb, 0x42, 0x0f, 0x9f, 0x63, 0xe5, 0xb6, 0xb6, 0x89, 0xf7, 0x21, 0x5e,
	0xe6, 0x5b, 0xac, 0x28, 0x24, 0x61, 0x49, 0x69, 0x60, 0x8f, 0x5d, 0x7b, 0x73, 0x0f, 0x8f, 0x17,
	0xca, 0x5e, 0xc5, 0xa5, 0x7f, 0x8f, 0x3c, 0xbb, 0x35, 0x32, 0x9f, 0xe1, 0x07, 0x8c, 0x47, 0x4d,
	0x34, 0x03, 0x29, 0x18, 0x17, 0xe0, 0x2d, 0xd0, 0xfa, 0x8e, 0x6e, 0x5f, 0x56, 0xb0, 0x2b, 0x3f,
	0x6e, 0xa2, 0xdf, 0x8d, 0xc0, 0x51, 0x04, 0xc0, 0x5e, 0x39, 0xc1, 0x34, 0xd7, 0x7e, 0x15, 0x81,
	0x5f, 0x44, 0xe0, 0x0a, 0xa4, 0xda, 0x00, 0xc8, 0xf6, 0x62, 0x92, 0x1b, 0xa0, 0x04, 0x69, 0xf5,
	0x21, 0x95, 0x59, 0x98, 0x09, 0x9a, 0x11, 0xc0, 0x2f, 0x8b, 0x90, 0xee, 0x63, 0xbb, 0x17, 0xd5,
	0x64, 0x40, 0x0e, 0x9a, 0xd5, 0x83, 0x75, 0x6e, 0xc2, 0x95, 0x3e, 0x3e, 0xfa, 0x11, 0x50, 0x8f,
	0x3c, 0x02, 0xb8, 0xa8, 0x7f, 0x1e, 0xbd, 0x68, 0xa9, 0x47, 0x1e, 0x3d, 0x18, 0xea, 0xd7, 0x61,
	0x67, 0x09, 0x05, 0x41, 0x7d, 0x16, 0xee, 0xb7, 0x7a, 0xe7, 0xaf, 0x59, 0xff, 0x35, 0x1a, 0x64,
	0x5d, 0xce, 0x5b, 0x85, 0xc1, 0xea, 0xde, 0xbf, 0xc6, 0x83, 0xd4, 0xf5, 0xbc, 0x2a, 0x42, 0x01,
	0x26, 0x3c, 0x7b, 0xae, 0x68, 0x81, 0x74, 0xb6, 0x9b, 0xa6, 0x30, 0x14, 0x68, 0x7d, 0x57, 0xaf,
	0x34, 0x18, 0xd9, 0x49, 0xc5, 0x57, 0xa9, 0xa5, 0xb4, 0xdf, 0xe1, 0x1b, 0x30, 0xe6, 0xdc, 0xcf,
	0xc5, 0xfc, 0xb7, 0x3a, 0x78, 0xa6, 0xef, 0xe4, 0x77, 0x61, 0x4c, 0xb4, 0xba, 0x33, 0x39, 0xd3,
	0xc9, 0x19, 0xfd, 0x66, 0xa7, 0x3f, 0x0f, 0x43, 0x2a, 0x98, 0xc3, 0xef, 0xea, 0xa6, 0x85, 0x17,
	0x60, 0x9c, 0xb4, 0x46, 0x4a, 0x01, 0x27, 0xfb, 0xe4, 0x43, 0xa4, 0xc6, 0xdb, 0x2a, 0xf6, 0xf9,
	0x1a, 0xff, 0x08, 0xc1, 0xc5, 0x36, 0x1b, 0x95, 0xda, 0x52, 0x87, 0xab, 0x17, 0xcf, 0xdd, 0x08,
	0x02, 0xc2, 0xc9, 0xa7, 0xed, 0xcd, 0xa0, 0x9b, 0xc1, 0xa2, 0xc8, 0xc3, 0x65, 0x93, 0xe5, 0xee,
	0x89, 0x4b, 0xe6, 0x71, 0x13, 0x51, 0xb8, 0x02, 0xe3, 0xed, 0x31, 0x85, 0xdf, 0x03, 0x26, 0xba,
	0x92, 0x83, 0x65, 0x48, 0x78, 0xb4, 0x44, 0x41, 0x17, 0x7a, 0x64, 0xd3, 0xb7, 0xae, 0x3f, 0x43,
	0x30, 0xc9, 0xb3, 0xd8, 0xdc, 0xbc, 0x5b, 0xac, 0x6b, 0xdb, 0x55, 0xb2, 0xce, 0xa8, 0x61, 0xe2,
	0xaf, 0xc0, 0xa8, 0x30, 0x66, 0x59, 0xd5, 0x8e, 0x52, 0x3e, 0x0d, 0x23, 0x35, 0xca, 0x85, 0x9b,
	0x56, 0x15, 0x2f, 0xc2, 0x25, 0xbd, 0x52, 0xa7, 0x8c, 0x94, 0x18, 0x31, 0x0d, 0x5a, 0x37, 0x49,
	0x49, 0x2c, 0x2b, 0x3f, 0x30, 0x46, 0xd5, 0x29, 0x21, 0x55, 0x1d, 0xa1, 0x80, 0x00, 0xbe, 0xda,
	0xba, 0x36, 0x1e, 0x10, 0xc6, 0xf4, 0x1d, 0xc2, 0x2f, 0xd8, 0x51, 0x55, 0xe0, 0x69, 0xcd, 0x19,
	0x4c, 0xff, 0x3c, 0x0c, 0x53, 0x3c, 0xba, 0x62, 0x55, 0xaf, 0xe8, 0xdb, 0x55, 0xe2, 0x7c, 0x85,
	0xc2, 0xbb, 0x70, 0x91, 0x2f, 0x0a, 0x29, 0x19, 0x8c, 0x3e, 0x38, 0x2c, 0xed, 0x51, 0xd3, 0x2a,
	0x35, 0x98, 0xee, 0x9c, 0x52, 0xe7, 0x07, 0xd8, 0x77, 0xfc, 0x09, 0xaf, 0x84, 0x54, 0x2c, 0x2c,
	0xae, 0xdb, 0x06, 0x57, 0xa8, 0x69, 0x6d, 0x31, 0x1d, 0x37, 0xe0, 0x8d, 0x6e, 0x3f, 0x8c, 0xec,
	0x37, 0x88, 0xe3, 0x2f, 0xf2, 0xf2, 0xfe, 0xa6, 0x3b, 0xfc, 0xa9, 0xc2, 0xec, 0x16, 0xd3, 0xf3,
	0x57, 0x01, 0x13, 0x27, 0xe3, 0xd2, 0x2e, 0x65, 0xc2, 0x16, 0x1e, 0xf7, 0xdc, 0xac, 0x23, 0xb9,
	0xcc, 0x82, 0x73, 0x95, 0xfe, 0xcf, 0x08, 0x8c, 0x79, 0xb1, 0x68, 0xaf, 0x1d, 0x87, 0x40, 0x8f,
	0x36, 0x88, 0xda, 0x42, 0xde, 0x00, 0x3f, 0x44, 0x30, 0xd5, 0x01, 0x96, 0x52, 0x55, 0x37, 0x2d,
	0x07, 0xff, 0x37, 0x5f, 0x06, 0xff, 0x76, 0x3b, 0xe6, 0xe5, 0x73, 0xf0, 0x8f, 0x59, 0x77, 0x0b,
	0xbf, 0x03, 0xe2, 0x4c, 0x51, 0xda, 0x3e, 0x34, 0x34, 0x53, 0x7c, 0x4f, 0x89, 0xe5, 0xa6, 0x3a,
	0x62, 0x28, 0xd6, 0x0c, 0xeb, 0x70, 0x25, 0xa4, 0xc6, 0xb8, 0x6e, 0x9e, 0xab, 0xe2, 0xed, 0xa0,
	0x72, 0xf1, 0x8f, 0x2d, 0xb1, 0x5c, 0x6e, 0x80, 0xa5, 0xe9, 0x40, 0xd7, 0x4a, 0x48, 0x4d, 0xb8,
	0xf6, 0xde, 0xa7, 0x8c, 0xab, 0x2c, 0x3d, 0x97, 0x9e, 0xdd, 0x1a, 0xe2, 0xe7, 0x89, 0xe3, 0x26,
	0xfa, 0xbb, 0x04, 0x93, 0xce, 0x25, 0x3d, 0xe6, 0x29, 0x36, 0x7c, 0x5f, 0x72, 0xbe, 0x30, 0x29,
	0xef, 0x95, 0xc5, 0xe7, 0xd2, 0x67, 0x11, 0x48, 0x63, 0x5f, 0x62, 0xa9, 0x31, 0x11, 0xb5, 0x22,
	0xec, 0x4a, 0x16, 0x6b, 0x10, 0xb8, 0x8d, 0x73, 0xdd, 0x19, 0x64, 0x03, 0x21, 0x9e, 0x6d, 0xf5,
	0x65, 0x6a, 0x54, 0xf8, 0xda, 0xdc, 0xbc, 0x0b, 0xcb, 0x78, 0x69, 0x20, 0x03, 0x1e, 0xec, 0x06,
	0x1b, 0xba, 0x87, 0x6f, 0x0f, 0x1c, 0x49, 0x70, 0xe3, 0xa7, 0x60, 0x83, 0x58, 0x8a, 0x78, 0x86,
	0x2d, 0xbc, 0xfc, 0xc2, 0x71, 0x0d, 0x60, 0xf6, 0x03, 0xfc, 0xf6, 0x0b, 0xd6, 0xcb, 0x25, 0x9a,
	0x54, 0x5c, 0xe4, 0xea, 0xbe, 0xc3, 0xc7, 0x03, 0x26, 0xdc, 0x5d, 0xb9, 0x9e, 0x26, 0x3f, 0x80,
	0x49, 0x1b, 0xd2, 0x0a, 0xdd, 0x55, 0xda, 0x20, 0x37, 0xd3, 0xb9, 0xe0, 0x6e, 0xeb, 0xc7, 0xcf,
	0xf9, 0x69, 0x77, 0x8b, 0xd5, 0x04, 0xa0, 0x70, 0xf4, 0xa8, 0x89, 0xa4, 0x93, 0x26, 0x8a, 0x7c,
	0x28, 0x45, 0x23, 0x09, 0x29, 0x6d, 0x41, 0x7c, 0xb9, 0x4a, 0xb7, 0xb5, 0xea, 0x86, 0x41, 0xca,
	0xfc, 0x6e, 0xff, 0x11, 0xc4, 0xda, 0x00, 0x37, 0x9d, 0x4b, 0xcd, 0xb5, 0xc1, 0x7b, 0x59, 0x85,
	0xd6, 0xee, 0x64, 0x2e, 0x5d, 0x7c, 0xd4, 0x44, 0x13, 0x30, 0x0e, 0x20, 0x52, 0xe4, 0xfc, 0x82,
	0xe6, 0xd3, 0x06, 0xc4, 0x0b, 0x8c, 0x68, 0x16, 0x79, 0x35, 0x5e, 0x27, 0x8e, 0x6f, 0x75, 0x64,
	0x95, 0xde, 0x87, 0x71, 0x95, 0x18, 0x55, 0xad, 0xfc, 0xc5, 0xb9, 0xac, 0x41, 0x6c, 0x99, 0x58,
	0x5f, 0x94, 0xbb, 0x6b, 0x2b, 0x70, 0xc1, 0xf7, 0x57, 0x0b, 0x8e, 0x03, 0xac, 0xab, 0x6b, 0xdf,
	0xfe, 0x4e, 0x69, 0x65, 0x6d, 0x63, 0x33, 0x11, 0xc2, 0x31, 0x18, 0x51, 0x8b, 0xef, 0x17, 0xd5,
	0xa2, 0x9a, 0x40, 0x18, 0x60, 0x78, 0xa3, 0xb0, 0x52, 0xbc, 0x57, 0x4c, 0x84, 0x6d, 0xc5, 0xad,
	0x8d, 0xa2, 0x5a, 0x7a, 0x6f, 0xb9, 0xb8, 0xba, 0x99, 0x88, 0xe4, 0x3f, 0x45, 0x27, 0x4f, 0xe4,
	0xd0, 0xe3, 0x27, 0x72, 0xe8, 0xe9, 0x13, 0x19, 0x3d, 0x3c, 0x95, 0xd1, 0x67, 0xa7, 0x32, 0xfa,
	0xe3, 0xa9, 0x8c, 0x4e, 0x4e, 0x65, 0xf4, 0xf8, 0x54, 0x46, 0x7f, 0x3b, 0x95, 0xd1, 0x3f, 0x4e,
	0xe5, 0xd0, 0xd3, 0x53, 0x19, 0x7d, 0x7a, 0x26, 0x87, 0x8e, 0xce, 0x64, 0x74, 0x72, 0x26, 0x87,
	0x1e, 0x9f, 0xc9, 0xa1, 0xef, 0xaa, 0x15, 0x6a, 0xdc, 0xaf, 0x64, 0x0f, 0x68, 0xd5, 0x22, 0x8c,
	0x69, 0xd9, 0x86, 0x39, 0xc7, 0x1f, 0x76, 0x29, 0xab, 0x5d, 0x37, 0x18, 0x3d, 0xd0, 0x77, 0x08,
	0xbb, 0xee, 0x8a, 0xe7, 0x8c, 0xed, 0x0a, 0x9d, 0x23, 0x0f, 0x2c, 0xe7, 0x8f, 0xa8, 0xc0, 0xbf,
	0xf8, 0xb6, 0x87, 0xf9, 0x7f, 0x52, 0x0b, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0xd4, 0xe4, 0x0d,
	0xe5, 0x09, 0x1c, 0x00, 0x00,
}

func (x HeaderOptions) String() string {
	s, ok := HeaderOptions_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *CacheHeaderMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheHeaderMatcherType)
	if !ok {
		that2, ok := that.(CacheHeaderMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.Operator.Equal(that1.Operator) {
		return false
	}
	return true
}
func (this *CacheOperator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheOperator)
	if !ok {
		that2, ok := that.(CacheOperator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.CacheOperator == nil {
		if this.CacheOperator != nil {
			return false
		}
	} else if this.CacheOperator == nil {
		return false
	} else if !this.CacheOperator.Equal(that1.CacheOperator) {
		return false
	}
	return true
}
func (this *CacheOperator_Equals) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheOperator_Equals)
	if !ok {
		that2, ok := that.(CacheOperator_Equals)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Equals != that1.Equals {
		return false
	}
	return true
}
func (this *CacheOperator_DoesNotEqual) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheOperator_DoesNotEqual)
	if !ok {
		that2, ok := that.(CacheOperator_DoesNotEqual)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DoesNotEqual != that1.DoesNotEqual {
		return false
	}
	return true
}
func (this *CacheOperator_Contains) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheOperator_Contains)
	if !ok {
		that2, ok := that.(CacheOperator_Contains)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Contains != that1.Contains {
		return false
	}
	return true
}
func (this *CacheOperator_DoesNotContain) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheOperator_DoesNotContain)
	if !ok {
		that2, ok := that.(CacheOperator_DoesNotContain)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DoesNotContain != that1.DoesNotContain {
		return false
	}
	return true
}
func (this *CacheOperator_Startswith) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheOperator_Startswith)
	if !ok {
		that2, ok := that.(CacheOperator_Startswith)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Startswith != that1.Startswith {
		return false
	}
	return true
}
func (this *CacheOperator_DoesNotStartWith) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheOperator_DoesNotStartWith)
	if !ok {
		that2, ok := that.(CacheOperator_DoesNotStartWith)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DoesNotStartWith != that1.DoesNotStartWith {
		return false
	}
	return true
}
func (this *CacheOperator_Endswith) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheOperator_Endswith)
	if !ok {
		that2, ok := that.(CacheOperator_Endswith)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Endswith != that1.Endswith {
		return false
	}
	return true
}
func (this *CacheOperator_DoesNotEndWith) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheOperator_DoesNotEndWith)
	if !ok {
		that2, ok := that.(CacheOperator_DoesNotEndWith)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DoesNotEndWith != that1.DoesNotEndWith {
		return false
	}
	return true
}
func (this *CacheOperator_MatchRegex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheOperator_MatchRegex)
	if !ok {
		that2, ok := that.(CacheOperator_MatchRegex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MatchRegex != that1.MatchRegex {
		return false
	}
	return true
}
func (this *CDNPathMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNPathMatcherType)
	if !ok {
		that2, ok := that.(CDNPathMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Operator.Equal(that1.Operator) {
		return false
	}
	return true
}
func (this *CacheCookieMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheCookieMatcherType)
	if !ok {
		that2, ok := that.(CacheCookieMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.Operator.Equal(that1.Operator) {
		return false
	}
	return true
}
func (this *CacheQueryParameterMatcherType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheQueryParameterMatcherType)
	if !ok {
		that2, ok := that.(CacheQueryParameterMatcherType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if !this.Operator.Equal(that1.Operator) {
		return false
	}
	return true
}
func (this *CDNCacheRuleExpression) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNCacheRuleExpression)
	if !ok {
		that2, ok := that.(CDNCacheRuleExpression)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PathMatch.Equal(that1.PathMatch) {
		return false
	}
	if len(this.QueryParameters) != len(that1.QueryParameters) {
		return false
	}
	for i := range this.QueryParameters {
		if !this.QueryParameters[i].Equal(that1.QueryParameters[i]) {
			return false
		}
	}
	if len(this.CacheHeaders) != len(that1.CacheHeaders) {
		return false
	}
	for i := range this.CacheHeaders {
		if !this.CacheHeaders[i].Equal(that1.CacheHeaders[i]) {
			return false
		}
	}
	if len(this.CookieMatcher) != len(that1.CookieMatcher) {
		return false
	}
	for i := range this.CookieMatcher {
		if !this.CookieMatcher[i].Equal(that1.CookieMatcher[i]) {
			return false
		}
	}
	return true
}
func (this *CDNCacheRuleExpressionList) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNCacheRuleExpressionList)
	if !ok {
		that2, ok := that.(CDNCacheRuleExpressionList)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExpressionName != that1.ExpressionName {
		return false
	}
	if len(this.CacheRuleExpression) != len(that1.CacheRuleExpression) {
		return false
	}
	for i := range this.CacheRuleExpression {
		if !this.CacheRuleExpression[i].Equal(that1.CacheRuleExpression[i]) {
			return false
		}
	}
	return true
}
func (this *CacheTTLEnableProps) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheTTLEnableProps)
	if !ok {
		that2, ok := that.(CacheTTLEnableProps)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CacheTtl != that1.CacheTtl {
		return false
	}
	if this.IgnoreResponseCookie != that1.IgnoreResponseCookie {
		return false
	}
	if this.CacheOverride != that1.CacheOverride {
		return false
	}
	return true
}
func (this *CacheEligibleOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheEligibleOptions)
	if !ok {
		that2, ok := that.(CacheEligibleOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.EligibleForCache == nil {
		if this.EligibleForCache != nil {
			return false
		}
	} else if this.EligibleForCache == nil {
		return false
	} else if !this.EligibleForCache.Equal(that1.EligibleForCache) {
		return false
	}
	return true
}
func (this *CacheEligibleOptions_SchemeProxyHostUri) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheEligibleOptions_SchemeProxyHostUri)
	if !ok {
		that2, ok := that.(CacheEligibleOptions_SchemeProxyHostUri)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SchemeProxyHostUri.Equal(that1.SchemeProxyHostUri) {
		return false
	}
	return true
}
func (this *CacheEligibleOptions_SchemeProxyHostRequestUri) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CacheEligibleOptions_SchemeProxyHostRequestUri)
	if !ok {
		that2, ok := that.(CacheEligibleOptions_SchemeProxyHostRequestUri)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SchemeProxyHostRequestUri.Equal(that1.SchemeProxyHostRequestUri) {
		return false
	}
	return true
}
func (this *CDNCacheRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNCacheRule)
	if !ok {
		that2, ok := that.(CDNCacheRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RuleName != that1.RuleName {
		return false
	}
	if len(this.RuleExpressionList) != len(that1.RuleExpressionList) {
		return false
	}
	for i := range this.RuleExpressionList {
		if !this.RuleExpressionList[i].Equal(that1.RuleExpressionList[i]) {
			return false
		}
	}
	if that1.CacheActions == nil {
		if this.CacheActions != nil {
			return false
		}
	} else if this.CacheActions == nil {
		return false
	} else if !this.CacheActions.Equal(that1.CacheActions) {
		return false
	}
	return true
}
func (this *CDNCacheRule_CacheBypass) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNCacheRule_CacheBypass)
	if !ok {
		that2, ok := that.(CDNCacheRule_CacheBypass)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CacheBypass.Equal(that1.CacheBypass) {
		return false
	}
	return true
}
func (this *CDNCacheRule_EligibleForCache) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CDNCacheRule_EligibleForCache)
	if !ok {
		that2, ok := that.(CDNCacheRule_EligibleForCache)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EligibleForCache.Equal(that1.EligibleForCache) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CacheRules.Equal(that1.CacheRules) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CacheRules.Equal(that1.CacheRules) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CacheRules.Equal(that1.CacheRules) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CacheRules.Equal(that1.CacheRules) {
		return false
	}
	return true
}
func (this *CacheHeaderMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_cache_rule.CacheHeaderMatcherType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Operator != nil {
		s = append(s, "Operator: "+fmt.Sprintf("%#v", this.Operator)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CacheOperator) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&cdn_cache_rule.CacheOperator{")
	if this.CacheOperator != nil {
		s = append(s, "CacheOperator: "+fmt.Sprintf("%#v", this.CacheOperator)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CacheOperator_Equals) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_cache_rule.CacheOperator_Equals{` +
		`Equals:` + fmt.Sprintf("%#v", this.Equals) + `}`}, ", ")
	return s
}
func (this *CacheOperator_DoesNotEqual) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_cache_rule.CacheOperator_DoesNotEqual{` +
		`DoesNotEqual:` + fmt.Sprintf("%#v", this.DoesNotEqual) + `}`}, ", ")
	return s
}
func (this *CacheOperator_Contains) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_cache_rule.CacheOperator_Contains{` +
		`Contains:` + fmt.Sprintf("%#v", this.Contains) + `}`}, ", ")
	return s
}
func (this *CacheOperator_DoesNotContain) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_cache_rule.CacheOperator_DoesNotContain{` +
		`DoesNotContain:` + fmt.Sprintf("%#v", this.DoesNotContain) + `}`}, ", ")
	return s
}
func (this *CacheOperator_Startswith) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_cache_rule.CacheOperator_Startswith{` +
		`Startswith:` + fmt.Sprintf("%#v", this.Startswith) + `}`}, ", ")
	return s
}
func (this *CacheOperator_DoesNotStartWith) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_cache_rule.CacheOperator_DoesNotStartWith{` +
		`DoesNotStartWith:` + fmt.Sprintf("%#v", this.DoesNotStartWith) + `}`}, ", ")
	return s
}
func (this *CacheOperator_Endswith) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_cache_rule.CacheOperator_Endswith{` +
		`Endswith:` + fmt.Sprintf("%#v", this.Endswith) + `}`}, ", ")
	return s
}
func (this *CacheOperator_DoesNotEndWith) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_cache_rule.CacheOperator_DoesNotEndWith{` +
		`DoesNotEndWith:` + fmt.Sprintf("%#v", this.DoesNotEndWith) + `}`}, ", ")
	return s
}
func (this *CacheOperator_MatchRegex) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_cache_rule.CacheOperator_MatchRegex{` +
		`MatchRegex:` + fmt.Sprintf("%#v", this.MatchRegex) + `}`}, ", ")
	return s
}
func (this *CDNPathMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cdn_cache_rule.CDNPathMatcherType{")
	if this.Operator != nil {
		s = append(s, "Operator: "+fmt.Sprintf("%#v", this.Operator)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CacheCookieMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_cache_rule.CacheCookieMatcherType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.Operator != nil {
		s = append(s, "Operator: "+fmt.Sprintf("%#v", this.Operator)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CacheQueryParameterMatcherType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_cache_rule.CacheQueryParameterMatcherType{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	if this.Operator != nil {
		s = append(s, "Operator: "+fmt.Sprintf("%#v", this.Operator)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNCacheRuleExpression) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cdn_cache_rule.CDNCacheRuleExpression{")
	if this.PathMatch != nil {
		s = append(s, "PathMatch: "+fmt.Sprintf("%#v", this.PathMatch)+",\n")
	}
	if this.QueryParameters != nil {
		s = append(s, "QueryParameters: "+fmt.Sprintf("%#v", this.QueryParameters)+",\n")
	}
	if this.CacheHeaders != nil {
		s = append(s, "CacheHeaders: "+fmt.Sprintf("%#v", this.CacheHeaders)+",\n")
	}
	if this.CookieMatcher != nil {
		s = append(s, "CookieMatcher: "+fmt.Sprintf("%#v", this.CookieMatcher)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNCacheRuleExpressionList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_cache_rule.CDNCacheRuleExpressionList{")
	s = append(s, "ExpressionName: "+fmt.Sprintf("%#v", this.ExpressionName)+",\n")
	if this.CacheRuleExpression != nil {
		s = append(s, "CacheRuleExpression: "+fmt.Sprintf("%#v", this.CacheRuleExpression)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CacheTTLEnableProps) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cdn_cache_rule.CacheTTLEnableProps{")
	s = append(s, "CacheTtl: "+fmt.Sprintf("%#v", this.CacheTtl)+",\n")
	s = append(s, "IgnoreResponseCookie: "+fmt.Sprintf("%#v", this.IgnoreResponseCookie)+",\n")
	s = append(s, "CacheOverride: "+fmt.Sprintf("%#v", this.CacheOverride)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CacheEligibleOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cdn_cache_rule.CacheEligibleOptions{")
	if this.EligibleForCache != nil {
		s = append(s, "EligibleForCache: "+fmt.Sprintf("%#v", this.EligibleForCache)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CacheEligibleOptions_SchemeProxyHostUri) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_cache_rule.CacheEligibleOptions_SchemeProxyHostUri{` +
		`SchemeProxyHostUri:` + fmt.Sprintf("%#v", this.SchemeProxyHostUri) + `}`}, ", ")
	return s
}
func (this *CacheEligibleOptions_SchemeProxyHostRequestUri) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_cache_rule.CacheEligibleOptions_SchemeProxyHostRequestUri{` +
		`SchemeProxyHostRequestUri:` + fmt.Sprintf("%#v", this.SchemeProxyHostRequestUri) + `}`}, ", ")
	return s
}
func (this *CDNCacheRule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cdn_cache_rule.CDNCacheRule{")
	s = append(s, "RuleName: "+fmt.Sprintf("%#v", this.RuleName)+",\n")
	if this.RuleExpressionList != nil {
		s = append(s, "RuleExpressionList: "+fmt.Sprintf("%#v", this.RuleExpressionList)+",\n")
	}
	if this.CacheActions != nil {
		s = append(s, "CacheActions: "+fmt.Sprintf("%#v", this.CacheActions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CDNCacheRule_CacheBypass) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_cache_rule.CDNCacheRule_CacheBypass{` +
		`CacheBypass:` + fmt.Sprintf("%#v", this.CacheBypass) + `}`}, ", ")
	return s
}
func (this *CDNCacheRule_EligibleForCache) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&cdn_cache_rule.CDNCacheRule_EligibleForCache{` +
		`EligibleForCache:` + fmt.Sprintf("%#v", this.EligibleForCache) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cdn_cache_rule.GlobalSpecType{")
	if this.CacheRules != nil {
		s = append(s, "CacheRules: "+fmt.Sprintf("%#v", this.CacheRules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cdn_cache_rule.CreateSpecType{")
	if this.CacheRules != nil {
		s = append(s, "CacheRules: "+fmt.Sprintf("%#v", this.CacheRules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cdn_cache_rule.ReplaceSpecType{")
	if this.CacheRules != nil {
		s = append(s, "CacheRules: "+fmt.Sprintf("%#v", this.CacheRules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cdn_cache_rule.GetSpecType{")
	if this.CacheRules != nil {
		s = append(s, "CacheRules: "+fmt.Sprintf("%#v", this.CacheRules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *CacheHeaderMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheHeaderMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheHeaderMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operator != nil {
		{
			size, err := m.Operator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Name != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Name))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CacheOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CacheOperator != nil {
		{
			size := m.CacheOperator.Size()
			i -= size
			if _, err := m.CacheOperator.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CacheOperator_Equals) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheOperator_Equals) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Equals)
	copy(dAtA[i:], m.Equals)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Equals)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *CacheOperator_DoesNotEqual) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheOperator_DoesNotEqual) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DoesNotEqual)
	copy(dAtA[i:], m.DoesNotEqual)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DoesNotEqual)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *CacheOperator_Contains) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheOperator_Contains) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Contains)
	copy(dAtA[i:], m.Contains)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Contains)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *CacheOperator_DoesNotContain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheOperator_DoesNotContain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DoesNotContain)
	copy(dAtA[i:], m.DoesNotContain)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DoesNotContain)))
	i--
	dAtA[i] = 0x2a
	return len(dAtA) - i, nil
}
func (m *CacheOperator_Startswith) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheOperator_Startswith) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Startswith)
	copy(dAtA[i:], m.Startswith)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Startswith)))
	i--
	dAtA[i] = 0x32
	return len(dAtA) - i, nil
}
func (m *CacheOperator_DoesNotStartWith) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheOperator_DoesNotStartWith) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DoesNotStartWith)
	copy(dAtA[i:], m.DoesNotStartWith)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DoesNotStartWith)))
	i--
	dAtA[i] = 0x3a
	return len(dAtA) - i, nil
}
func (m *CacheOperator_Endswith) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheOperator_Endswith) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Endswith)
	copy(dAtA[i:], m.Endswith)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Endswith)))
	i--
	dAtA[i] = 0x42
	return len(dAtA) - i, nil
}
func (m *CacheOperator_DoesNotEndWith) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheOperator_DoesNotEndWith) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.DoesNotEndWith)
	copy(dAtA[i:], m.DoesNotEndWith)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.DoesNotEndWith)))
	i--
	dAtA[i] = 0x4a
	return len(dAtA) - i, nil
}
func (m *CacheOperator_MatchRegex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheOperator_MatchRegex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.MatchRegex)
	copy(dAtA[i:], m.MatchRegex)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.MatchRegex)))
	i--
	dAtA[i] = 0x52
	return len(dAtA) - i, nil
}
func (m *CDNPathMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNPathMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNPathMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operator != nil {
		{
			size, err := m.Operator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CacheCookieMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheCookieMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheCookieMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operator != nil {
		{
			size, err := m.Operator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CacheQueryParameterMatcherType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheQueryParameterMatcherType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheQueryParameterMatcherType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Operator != nil {
		{
			size, err := m.Operator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CDNCacheRuleExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNCacheRuleExpression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNCacheRuleExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CookieMatcher) > 0 {
		for iNdEx := len(m.CookieMatcher) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CookieMatcher[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CacheHeaders) > 0 {
		for iNdEx := len(m.CacheHeaders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CacheHeaders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.QueryParameters) > 0 {
		for iNdEx := len(m.QueryParameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QueryParameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.PathMatch != nil {
		{
			size, err := m.PathMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CDNCacheRuleExpressionList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNCacheRuleExpressionList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNCacheRuleExpressionList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CacheRuleExpression) > 0 {
		for iNdEx := len(m.CacheRuleExpression) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CacheRuleExpression[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ExpressionName) > 0 {
		i -= len(m.ExpressionName)
		copy(dAtA[i:], m.ExpressionName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ExpressionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CacheTTLEnableProps) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheTTLEnableProps) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheTTLEnableProps) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CacheOverride {
		i--
		if m.CacheOverride {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.IgnoreResponseCookie {
		i--
		if m.IgnoreResponseCookie {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.CacheTtl) > 0 {
		i -= len(m.CacheTtl)
		copy(dAtA[i:], m.CacheTtl)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CacheTtl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CacheEligibleOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CacheEligibleOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheEligibleOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EligibleForCache != nil {
		{
			size := m.EligibleForCache.Size()
			i -= size
			if _, err := m.EligibleForCache.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CacheEligibleOptions_SchemeProxyHostUri) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheEligibleOptions_SchemeProxyHostUri) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SchemeProxyHostUri != nil {
		{
			size, err := m.SchemeProxyHostUri.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CacheEligibleOptions_SchemeProxyHostRequestUri) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CacheEligibleOptions_SchemeProxyHostRequestUri) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SchemeProxyHostRequestUri != nil {
		{
			size, err := m.SchemeProxyHostRequestUri.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CDNCacheRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDNCacheRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNCacheRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CacheActions != nil {
		{
			size := m.CacheActions.Size()
			i -= size
			if _, err := m.CacheActions.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.RuleExpressionList) > 0 {
		for iNdEx := len(m.RuleExpressionList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuleExpressionList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.RuleName) > 0 {
		i -= len(m.RuleName)
		copy(dAtA[i:], m.RuleName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RuleName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CDNCacheRule_CacheBypass) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNCacheRule_CacheBypass) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CacheBypass != nil {
		{
			size, err := m.CacheBypass.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CDNCacheRule_EligibleForCache) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDNCacheRule_EligibleForCache) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EligibleForCache != nil {
		{
			size, err := m.EligibleForCache.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CacheRules != nil {
		{
			size, err := m.CacheRules.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CacheRules != nil {
		{
			size, err := m.CacheRules.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CacheRules != nil {
		{
			size, err := m.CacheRules.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CacheRules != nil {
		{
			size, err := m.CacheRules.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CacheHeaderMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != 0 {
		n += 1 + sovTypes(uint64(m.Name))
	}
	if m.Operator != nil {
		l = m.Operator.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CacheOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CacheOperator != nil {
		n += m.CacheOperator.Size()
	}
	return n
}

func (m *CacheOperator_Equals) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Equals)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CacheOperator_DoesNotEqual) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DoesNotEqual)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CacheOperator_Contains) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Contains)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CacheOperator_DoesNotContain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DoesNotContain)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CacheOperator_Startswith) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Startswith)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CacheOperator_DoesNotStartWith) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DoesNotStartWith)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CacheOperator_Endswith) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Endswith)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CacheOperator_DoesNotEndWith) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DoesNotEndWith)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CacheOperator_MatchRegex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MatchRegex)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CDNPathMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operator != nil {
		l = m.Operator.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CacheCookieMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Operator != nil {
		l = m.Operator.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CacheQueryParameterMatcherType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Operator != nil {
		l = m.Operator.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CDNCacheRuleExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PathMatch != nil {
		l = m.PathMatch.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.QueryParameters) > 0 {
		for _, e := range m.QueryParameters {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CacheHeaders) > 0 {
		for _, e := range m.CacheHeaders {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.CookieMatcher) > 0 {
		for _, e := range m.CookieMatcher {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CDNCacheRuleExpressionList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ExpressionName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.CacheRuleExpression) > 0 {
		for _, e := range m.CacheRuleExpression {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CacheTTLEnableProps) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CacheTtl)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IgnoreResponseCookie {
		n += 2
	}
	if m.CacheOverride {
		n += 2
	}
	return n
}

func (m *CacheEligibleOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EligibleForCache != nil {
		n += m.EligibleForCache.Size()
	}
	return n
}

func (m *CacheEligibleOptions_SchemeProxyHostUri) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemeProxyHostUri != nil {
		l = m.SchemeProxyHostUri.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CacheEligibleOptions_SchemeProxyHostRequestUri) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchemeProxyHostRequestUri != nil {
		l = m.SchemeProxyHostRequestUri.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CDNCacheRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RuleName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.RuleExpressionList) > 0 {
		for _, e := range m.RuleExpressionList {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.CacheActions != nil {
		n += m.CacheActions.Size()
	}
	return n
}

func (m *CDNCacheRule_CacheBypass) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CacheBypass != nil {
		l = m.CacheBypass.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CDNCacheRule_EligibleForCache) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EligibleForCache != nil {
		l = m.EligibleForCache.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CacheRules != nil {
		l = m.CacheRules.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CacheRules != nil {
		l = m.CacheRules.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CacheRules != nil {
		l = m.CacheRules.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CacheRules != nil {
		l = m.CacheRules.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *CacheHeaderMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheHeaderMatcherType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Operator:` + strings.Replace(this.Operator.String(), "CacheOperator", "CacheOperator", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheOperator) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheOperator{`,
		`CacheOperator:` + fmt.Sprintf("%v", this.CacheOperator) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheOperator_Equals) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheOperator_Equals{`,
		`Equals:` + fmt.Sprintf("%v", this.Equals) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheOperator_DoesNotEqual) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheOperator_DoesNotEqual{`,
		`DoesNotEqual:` + fmt.Sprintf("%v", this.DoesNotEqual) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheOperator_Contains) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheOperator_Contains{`,
		`Contains:` + fmt.Sprintf("%v", this.Contains) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheOperator_DoesNotContain) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheOperator_DoesNotContain{`,
		`DoesNotContain:` + fmt.Sprintf("%v", this.DoesNotContain) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheOperator_Startswith) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheOperator_Startswith{`,
		`Startswith:` + fmt.Sprintf("%v", this.Startswith) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheOperator_DoesNotStartWith) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheOperator_DoesNotStartWith{`,
		`DoesNotStartWith:` + fmt.Sprintf("%v", this.DoesNotStartWith) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheOperator_Endswith) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheOperator_Endswith{`,
		`Endswith:` + fmt.Sprintf("%v", this.Endswith) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheOperator_DoesNotEndWith) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheOperator_DoesNotEndWith{`,
		`DoesNotEndWith:` + fmt.Sprintf("%v", this.DoesNotEndWith) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheOperator_MatchRegex) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheOperator_MatchRegex{`,
		`MatchRegex:` + fmt.Sprintf("%v", this.MatchRegex) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNPathMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNPathMatcherType{`,
		`Operator:` + strings.Replace(this.Operator.String(), "CacheOperator", "CacheOperator", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheCookieMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheCookieMatcherType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Operator:` + strings.Replace(this.Operator.String(), "CacheOperator", "CacheOperator", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheQueryParameterMatcherType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheQueryParameterMatcherType{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Operator:` + strings.Replace(this.Operator.String(), "CacheOperator", "CacheOperator", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNCacheRuleExpression) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForQueryParameters := "[]*CacheQueryParameterMatcherType{"
	for _, f := range this.QueryParameters {
		repeatedStringForQueryParameters += strings.Replace(f.String(), "CacheQueryParameterMatcherType", "CacheQueryParameterMatcherType", 1) + ","
	}
	repeatedStringForQueryParameters += "}"
	repeatedStringForCacheHeaders := "[]*CacheHeaderMatcherType{"
	for _, f := range this.CacheHeaders {
		repeatedStringForCacheHeaders += strings.Replace(f.String(), "CacheHeaderMatcherType", "CacheHeaderMatcherType", 1) + ","
	}
	repeatedStringForCacheHeaders += "}"
	repeatedStringForCookieMatcher := "[]*CacheCookieMatcherType{"
	for _, f := range this.CookieMatcher {
		repeatedStringForCookieMatcher += strings.Replace(f.String(), "CacheCookieMatcherType", "CacheCookieMatcherType", 1) + ","
	}
	repeatedStringForCookieMatcher += "}"
	s := strings.Join([]string{`&CDNCacheRuleExpression{`,
		`PathMatch:` + strings.Replace(this.PathMatch.String(), "CDNPathMatcherType", "CDNPathMatcherType", 1) + `,`,
		`QueryParameters:` + repeatedStringForQueryParameters + `,`,
		`CacheHeaders:` + repeatedStringForCacheHeaders + `,`,
		`CookieMatcher:` + repeatedStringForCookieMatcher + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNCacheRuleExpressionList) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCacheRuleExpression := "[]*CDNCacheRuleExpression{"
	for _, f := range this.CacheRuleExpression {
		repeatedStringForCacheRuleExpression += strings.Replace(f.String(), "CDNCacheRuleExpression", "CDNCacheRuleExpression", 1) + ","
	}
	repeatedStringForCacheRuleExpression += "}"
	s := strings.Join([]string{`&CDNCacheRuleExpressionList{`,
		`ExpressionName:` + fmt.Sprintf("%v", this.ExpressionName) + `,`,
		`CacheRuleExpression:` + repeatedStringForCacheRuleExpression + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheTTLEnableProps) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheTTLEnableProps{`,
		`CacheTtl:` + fmt.Sprintf("%v", this.CacheTtl) + `,`,
		`IgnoreResponseCookie:` + fmt.Sprintf("%v", this.IgnoreResponseCookie) + `,`,
		`CacheOverride:` + fmt.Sprintf("%v", this.CacheOverride) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheEligibleOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheEligibleOptions{`,
		`EligibleForCache:` + fmt.Sprintf("%v", this.EligibleForCache) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheEligibleOptions_SchemeProxyHostUri) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheEligibleOptions_SchemeProxyHostUri{`,
		`SchemeProxyHostUri:` + strings.Replace(fmt.Sprintf("%v", this.SchemeProxyHostUri), "CacheTTLEnableProps", "CacheTTLEnableProps", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CacheEligibleOptions_SchemeProxyHostRequestUri) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CacheEligibleOptions_SchemeProxyHostRequestUri{`,
		`SchemeProxyHostRequestUri:` + strings.Replace(fmt.Sprintf("%v", this.SchemeProxyHostRequestUri), "CacheTTLEnableProps", "CacheTTLEnableProps", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNCacheRule) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRuleExpressionList := "[]*CDNCacheRuleExpressionList{"
	for _, f := range this.RuleExpressionList {
		repeatedStringForRuleExpressionList += strings.Replace(f.String(), "CDNCacheRuleExpressionList", "CDNCacheRuleExpressionList", 1) + ","
	}
	repeatedStringForRuleExpressionList += "}"
	s := strings.Join([]string{`&CDNCacheRule{`,
		`RuleName:` + fmt.Sprintf("%v", this.RuleName) + `,`,
		`RuleExpressionList:` + repeatedStringForRuleExpressionList + `,`,
		`CacheActions:` + fmt.Sprintf("%v", this.CacheActions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNCacheRule_CacheBypass) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNCacheRule_CacheBypass{`,
		`CacheBypass:` + strings.Replace(fmt.Sprintf("%v", this.CacheBypass), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CDNCacheRule_EligibleForCache) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CDNCacheRule_EligibleForCache{`,
		`EligibleForCache:` + strings.Replace(fmt.Sprintf("%v", this.EligibleForCache), "CacheEligibleOptions", "CacheEligibleOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`CacheRules:` + strings.Replace(this.CacheRules.String(), "CDNCacheRule", "CDNCacheRule", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`CacheRules:` + strings.Replace(this.CacheRules.String(), "CDNCacheRule", "CDNCacheRule", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`CacheRules:` + strings.Replace(this.CacheRules.String(), "CDNCacheRule", "CDNCacheRule", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`CacheRules:` + strings.Replace(this.CacheRules.String(), "CDNCacheRule", "CDNCacheRule", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *CacheHeaderMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheHeaderMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheHeaderMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			m.Name = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Name |= HeaderOptions(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Operator == nil {
				m.Operator = &CacheOperator{}
			}
			if err := m.Operator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equals", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheOperator = &CacheOperator_Equals{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoesNotEqual", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheOperator = &CacheOperator_DoesNotEqual{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheOperator = &CacheOperator_Contains{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoesNotContain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheOperator = &CacheOperator_DoesNotContain{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Startswith", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheOperator = &CacheOperator_Startswith{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoesNotStartWith", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheOperator = &CacheOperator_DoesNotStartWith{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endswith", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheOperator = &CacheOperator_Endswith{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoesNotEndWith", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheOperator = &CacheOperator_DoesNotEndWith{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchRegex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheOperator = &CacheOperator_MatchRegex{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNPathMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNPathMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNPathMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Operator == nil {
				m.Operator = &CacheOperator{}
			}
			if err := m.Operator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheCookieMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheCookieMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheCookieMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Operator == nil {
				m.Operator = &CacheOperator{}
			}
			if err := m.Operator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheQueryParameterMatcherType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheQueryParameterMatcherType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheQueryParameterMatcherType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Operator == nil {
				m.Operator = &CacheOperator{}
			}
			if err := m.Operator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNCacheRuleExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNCacheRuleExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNCacheRuleExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PathMatch == nil {
				m.PathMatch = &CDNPathMatcherType{}
			}
			if err := m.PathMatch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryParameters = append(m.QueryParameters, &CacheQueryParameterMatcherType{})
			if err := m.QueryParameters[len(m.QueryParameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheHeaders = append(m.CacheHeaders, &CacheHeaderMatcherType{})
			if err := m.CacheHeaders[len(m.CacheHeaders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CookieMatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CookieMatcher = append(m.CookieMatcher, &CacheCookieMatcherType{})
			if err := m.CookieMatcher[len(m.CookieMatcher)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNCacheRuleExpressionList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNCacheRuleExpressionList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNCacheRuleExpressionList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpressionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpressionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheRuleExpression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheRuleExpression = append(m.CacheRuleExpression, &CDNCacheRuleExpression{})
			if err := m.CacheRuleExpression[len(m.CacheRuleExpression)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheTTLEnableProps) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheTTLEnableProps: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheTTLEnableProps: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheTtl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheTtl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreResponseCookie", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreResponseCookie = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheOverride", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CacheOverride = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CacheEligibleOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CacheEligibleOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CacheEligibleOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemeProxyHostUri", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CacheTTLEnableProps{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EligibleForCache = &CacheEligibleOptions_SchemeProxyHostUri{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemeProxyHostRequestUri", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CacheTTLEnableProps{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EligibleForCache = &CacheEligibleOptions_SchemeProxyHostRequestUri{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CDNCacheRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDNCacheRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDNCacheRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleExpressionList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleExpressionList = append(m.RuleExpressionList, &CDNCacheRuleExpressionList{})
			if err := m.RuleExpressionList[len(m.RuleExpressionList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheBypass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CacheActions = &CDNCacheRule_CacheBypass{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EligibleForCache", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CacheEligibleOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.CacheActions = &CDNCacheRule_EligibleForCache{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CacheRules == nil {
				m.CacheRules = &CDNCacheRule{}
			}
			if err := m.CacheRules.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CacheRules == nil {
				m.CacheRules = &CDNCacheRule{}
			}
			if err := m.CacheRules.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CacheRules == nil {
				m.CacheRules = &CDNCacheRule{}
			}
			if err := m.CacheRules.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CacheRules == nil {
				m.CacheRules = &CDNCacheRule{}
			}
			if err := m.CacheRules.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
