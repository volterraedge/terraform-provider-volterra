// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package cdn_cache_rule

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CDNCacheRule) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNCacheRule) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNCacheRule) DeepCopy() *CDNCacheRule {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNCacheRule{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNCacheRule) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNCacheRule) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNCacheRuleValidator().Validate(ctx, m, opts...)
}

type ValidateCDNCacheRule struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNCacheRule) CacheActionsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cache_actions")
	}
	return validatorFn, nil
}

func (v *ValidateCDNCacheRule) RuleNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for rule_name")
	}

	return validatorFn, nil
}

func (v *ValidateCDNCacheRule) RuleExpressionListValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for rule_expression_list")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*CDNCacheRuleExpressionList, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := CDNCacheRuleExpressionListValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for rule_expression_list")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*CDNCacheRuleExpressionList)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*CDNCacheRuleExpressionList, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated rule_expression_list")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items rule_expression_list")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCDNCacheRule) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNCacheRule)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNCacheRule got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_actions"]; exists {
		val := m.GetCacheActions()
		vOpts := append(opts,
			db.WithValidateField("cache_actions"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetCacheActions().(type) {
	case *CDNCacheRule_CacheBypass:
		if fv, exists := v.FldValidators["cache_actions.cache_bypass"]; exists {
			val := m.GetCacheActions().(*CDNCacheRule_CacheBypass).CacheBypass
			vOpts := append(opts,
				db.WithValidateField("cache_actions"),
				db.WithValidateField("cache_bypass"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CDNCacheRule_EligibleForCache:
		if fv, exists := v.FldValidators["cache_actions.eligible_for_cache"]; exists {
			val := m.GetCacheActions().(*CDNCacheRule_EligibleForCache).EligibleForCache
			vOpts := append(opts,
				db.WithValidateField("cache_actions"),
				db.WithValidateField("eligible_for_cache"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["rule_expression_list"]; exists {
		vOpts := append(opts, db.WithValidateField("rule_expression_list"))
		if err := fv(ctx, m.GetRuleExpressionList(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rule_name"]; exists {

		vOpts := append(opts, db.WithValidateField("rule_name"))
		if err := fv(ctx, m.GetRuleName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNCacheRuleValidator = func() *ValidateCDNCacheRule {
	v := &ValidateCDNCacheRule{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCacheActions := v.CacheActionsValidationRuleHandler
	rulesCacheActions := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhCacheActions(rulesCacheActions)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNCacheRule.cache_actions: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cache_actions"] = vFn

	vrhRuleName := v.RuleNameValidationRuleHandler
	rulesRuleName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "128",
	}
	vFn, err = vrhRuleName(rulesRuleName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNCacheRule.rule_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rule_name"] = vFn

	vrhRuleExpressionList := v.RuleExpressionListValidationRuleHandler
	rulesRuleExpressionList := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhRuleExpressionList(rulesRuleExpressionList)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNCacheRule.rule_expression_list: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rule_expression_list"] = vFn

	v.FldValidators["cache_actions.eligible_for_cache"] = CacheEligibleOptionsValidator().Validate

	return v
}()

func CDNCacheRuleValidator() db.Validator {
	return DefaultCDNCacheRuleValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNCacheRuleExpression) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNCacheRuleExpression) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNCacheRuleExpression) DeepCopy() *CDNCacheRuleExpression {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNCacheRuleExpression{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNCacheRuleExpression) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNCacheRuleExpression) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNCacheRuleExpressionValidator().Validate(ctx, m, opts...)
}

type ValidateCDNCacheRuleExpression struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNCacheRuleExpression) QueryParametersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for query_parameters")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*CacheQueryParameterMatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := CacheQueryParameterMatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for query_parameters")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*CacheQueryParameterMatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*CacheQueryParameterMatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated query_parameters")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items query_parameters")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCDNCacheRuleExpression) CacheHeadersValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for cache_headers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*CacheHeaderMatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := CacheHeaderMatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cache_headers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*CacheHeaderMatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*CacheHeaderMatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cache_headers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cache_headers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCDNCacheRuleExpression) CookieMatcherValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for cookie_matcher")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*CacheCookieMatcherType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := CacheCookieMatcherTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cookie_matcher")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*CacheCookieMatcherType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*CacheCookieMatcherType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cookie_matcher")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cookie_matcher")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCDNCacheRuleExpression) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNCacheRuleExpression)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNCacheRuleExpression got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_headers"]; exists {
		vOpts := append(opts, db.WithValidateField("cache_headers"))
		if err := fv(ctx, m.GetCacheHeaders(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cookie_matcher"]; exists {
		vOpts := append(opts, db.WithValidateField("cookie_matcher"))
		if err := fv(ctx, m.GetCookieMatcher(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["path_match"]; exists {

		vOpts := append(opts, db.WithValidateField("path_match"))
		if err := fv(ctx, m.GetPathMatch(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["query_parameters"]; exists {
		vOpts := append(opts, db.WithValidateField("query_parameters"))
		if err := fv(ctx, m.GetQueryParameters(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNCacheRuleExpressionValidator = func() *ValidateCDNCacheRuleExpression {
	v := &ValidateCDNCacheRuleExpression{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhQueryParameters := v.QueryParametersValidationRuleHandler
	rulesQueryParameters := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhQueryParameters(rulesQueryParameters)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNCacheRuleExpression.query_parameters: %s", err)
		panic(errMsg)
	}
	v.FldValidators["query_parameters"] = vFn

	vrhCacheHeaders := v.CacheHeadersValidationRuleHandler
	rulesCacheHeaders := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhCacheHeaders(rulesCacheHeaders)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNCacheRuleExpression.cache_headers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cache_headers"] = vFn

	vrhCookieMatcher := v.CookieMatcherValidationRuleHandler
	rulesCookieMatcher := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhCookieMatcher(rulesCookieMatcher)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNCacheRuleExpression.cookie_matcher: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cookie_matcher"] = vFn

	v.FldValidators["path_match"] = CDNPathMatcherTypeValidator().Validate

	return v
}()

func CDNCacheRuleExpressionValidator() db.Validator {
	return DefaultCDNCacheRuleExpressionValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNCacheRuleExpressionList) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNCacheRuleExpressionList) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNCacheRuleExpressionList) DeepCopy() *CDNCacheRuleExpressionList {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNCacheRuleExpressionList{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNCacheRuleExpressionList) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNCacheRuleExpressionList) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNCacheRuleExpressionListValidator().Validate(ctx, m, opts...)
}

type ValidateCDNCacheRuleExpressionList struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNCacheRuleExpressionList) ExpressionNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for expression_name")
	}

	return validatorFn, nil
}

func (v *ValidateCDNCacheRuleExpressionList) CacheRuleExpressionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for cache_rule_expression")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*CDNCacheRuleExpression, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := CDNCacheRuleExpressionValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for cache_rule_expression")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*CDNCacheRuleExpression)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*CDNCacheRuleExpression, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated cache_rule_expression")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items cache_rule_expression")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCDNCacheRuleExpressionList) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNCacheRuleExpressionList)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNCacheRuleExpressionList got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_rule_expression"]; exists {
		vOpts := append(opts, db.WithValidateField("cache_rule_expression"))
		if err := fv(ctx, m.GetCacheRuleExpression(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["expression_name"]; exists {

		vOpts := append(opts, db.WithValidateField("expression_name"))
		if err := fv(ctx, m.GetExpressionName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNCacheRuleExpressionListValidator = func() *ValidateCDNCacheRuleExpressionList {
	v := &ValidateCDNCacheRuleExpressionList{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhExpressionName := v.ExpressionNameValidationRuleHandler
	rulesExpressionName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "128",
	}
	vFn, err = vrhExpressionName(rulesExpressionName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNCacheRuleExpressionList.expression_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["expression_name"] = vFn

	vrhCacheRuleExpression := v.CacheRuleExpressionValidationRuleHandler
	rulesCacheRuleExpression := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhCacheRuleExpression(rulesCacheRuleExpression)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CDNCacheRuleExpressionList.cache_rule_expression: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cache_rule_expression"] = vFn

	return v
}()

func CDNCacheRuleExpressionListValidator() db.Validator {
	return DefaultCDNCacheRuleExpressionListValidator
}

// augmented methods on protoc/std generated struct

func (m *CDNPathMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CDNPathMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CDNPathMatcherType) DeepCopy() *CDNPathMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CDNPathMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CDNPathMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CDNPathMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CDNPathMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCDNPathMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCDNPathMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CDNPathMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CDNPathMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["operator"]; exists {

		vOpts := append(opts, db.WithValidateField("operator"))
		if err := fv(ctx, m.GetOperator(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCDNPathMatcherTypeValidator = func() *ValidateCDNPathMatcherType {
	v := &ValidateCDNPathMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["operator"] = CacheOperatorValidator().Validate

	return v
}()

func CDNPathMatcherTypeValidator() db.Validator {
	return DefaultCDNPathMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CacheCookieMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CacheCookieMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CacheCookieMatcherType) DeepCopy() *CacheCookieMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CacheCookieMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CacheCookieMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CacheCookieMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CacheCookieMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCacheCookieMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCacheCookieMatcherType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateCacheCookieMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CacheCookieMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CacheCookieMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operator"]; exists {

		vOpts := append(opts, db.WithValidateField("operator"))
		if err := fv(ctx, m.GetOperator(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCacheCookieMatcherTypeValidator = func() *ValidateCacheCookieMatcherType {
	v := &ValidateCacheCookieMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "256",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CacheCookieMatcherType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	v.FldValidators["operator"] = CacheOperatorValidator().Validate

	return v
}()

func CacheCookieMatcherTypeValidator() db.Validator {
	return DefaultCacheCookieMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CacheEligibleOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CacheEligibleOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CacheEligibleOptions) DeepCopy() *CacheEligibleOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CacheEligibleOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CacheEligibleOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CacheEligibleOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CacheEligibleOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateCacheEligibleOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCacheEligibleOptions) EligibleForCacheValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for eligible_for_cache")
	}
	return validatorFn, nil
}

func (v *ValidateCacheEligibleOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CacheEligibleOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CacheEligibleOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["eligible_for_cache"]; exists {
		val := m.GetEligibleForCache()
		vOpts := append(opts,
			db.WithValidateField("eligible_for_cache"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetEligibleForCache().(type) {
	case *CacheEligibleOptions_SchemeProxyHostUri:
		if fv, exists := v.FldValidators["eligible_for_cache.scheme_proxy_host_uri"]; exists {
			val := m.GetEligibleForCache().(*CacheEligibleOptions_SchemeProxyHostUri).SchemeProxyHostUri
			vOpts := append(opts,
				db.WithValidateField("eligible_for_cache"),
				db.WithValidateField("scheme_proxy_host_uri"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CacheEligibleOptions_SchemeProxyHostRequestUri:
		if fv, exists := v.FldValidators["eligible_for_cache.scheme_proxy_host_request_uri"]; exists {
			val := m.GetEligibleForCache().(*CacheEligibleOptions_SchemeProxyHostRequestUri).SchemeProxyHostRequestUri
			vOpts := append(opts,
				db.WithValidateField("eligible_for_cache"),
				db.WithValidateField("scheme_proxy_host_request_uri"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCacheEligibleOptionsValidator = func() *ValidateCacheEligibleOptions {
	v := &ValidateCacheEligibleOptions{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhEligibleForCache := v.EligibleForCacheValidationRuleHandler
	rulesEligibleForCache := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhEligibleForCache(rulesEligibleForCache)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CacheEligibleOptions.eligible_for_cache: %s", err)
		panic(errMsg)
	}
	v.FldValidators["eligible_for_cache"] = vFn

	v.FldValidators["eligible_for_cache.scheme_proxy_host_uri"] = CacheTTLEnablePropsValidator().Validate
	v.FldValidators["eligible_for_cache.scheme_proxy_host_request_uri"] = CacheTTLEnablePropsValidator().Validate

	return v
}()

func CacheEligibleOptionsValidator() db.Validator {
	return DefaultCacheEligibleOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *CacheHeaderMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CacheHeaderMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CacheHeaderMatcherType) DeepCopy() *CacheHeaderMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CacheHeaderMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CacheHeaderMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CacheHeaderMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CacheHeaderMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCacheHeaderMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCacheHeaderMatcherType) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(HeaderOptions)
		return int32(i)
	}
	// HeaderOptions_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, HeaderOptions_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateCacheHeaderMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CacheHeaderMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CacheHeaderMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operator"]; exists {

		vOpts := append(opts, db.WithValidateField("operator"))
		if err := fv(ctx, m.GetOperator(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCacheHeaderMatcherTypeValidator = func() *ValidateCacheHeaderMatcherType {
	v := &ValidateCacheHeaderMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CacheHeaderMatcherType.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	v.FldValidators["operator"] = CacheOperatorValidator().Validate

	return v
}()

func CacheHeaderMatcherTypeValidator() db.Validator {
	return DefaultCacheHeaderMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CacheOperator) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CacheOperator) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CacheOperator) DeepCopy() *CacheOperator {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CacheOperator{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CacheOperator) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CacheOperator) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CacheOperatorValidator().Validate(ctx, m, opts...)
}

type ValidateCacheOperator struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCacheOperator) CacheOperatorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cache_operator")
	}
	return validatorFn, nil
}

func (v *ValidateCacheOperator) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CacheOperator)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CacheOperator got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_operator"]; exists {
		val := m.GetCacheOperator()
		vOpts := append(opts,
			db.WithValidateField("cache_operator"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetCacheOperator().(type) {
	case *CacheOperator_Equals:
		if fv, exists := v.FldValidators["cache_operator.Equals"]; exists {
			val := m.GetCacheOperator().(*CacheOperator_Equals).Equals
			vOpts := append(opts,
				db.WithValidateField("cache_operator"),
				db.WithValidateField("Equals"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CacheOperator_DoesNotEqual:
		if fv, exists := v.FldValidators["cache_operator.DoesNotEqual"]; exists {
			val := m.GetCacheOperator().(*CacheOperator_DoesNotEqual).DoesNotEqual
			vOpts := append(opts,
				db.WithValidateField("cache_operator"),
				db.WithValidateField("DoesNotEqual"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CacheOperator_Contains:
		if fv, exists := v.FldValidators["cache_operator.Contains"]; exists {
			val := m.GetCacheOperator().(*CacheOperator_Contains).Contains
			vOpts := append(opts,
				db.WithValidateField("cache_operator"),
				db.WithValidateField("Contains"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CacheOperator_DoesNotContain:
		if fv, exists := v.FldValidators["cache_operator.DoesNotContain"]; exists {
			val := m.GetCacheOperator().(*CacheOperator_DoesNotContain).DoesNotContain
			vOpts := append(opts,
				db.WithValidateField("cache_operator"),
				db.WithValidateField("DoesNotContain"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CacheOperator_Startswith:
		if fv, exists := v.FldValidators["cache_operator.Startswith"]; exists {
			val := m.GetCacheOperator().(*CacheOperator_Startswith).Startswith
			vOpts := append(opts,
				db.WithValidateField("cache_operator"),
				db.WithValidateField("Startswith"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CacheOperator_DoesNotStartWith:
		if fv, exists := v.FldValidators["cache_operator.DoesNotStartWith"]; exists {
			val := m.GetCacheOperator().(*CacheOperator_DoesNotStartWith).DoesNotStartWith
			vOpts := append(opts,
				db.WithValidateField("cache_operator"),
				db.WithValidateField("DoesNotStartWith"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CacheOperator_Endswith:
		if fv, exists := v.FldValidators["cache_operator.Endswith"]; exists {
			val := m.GetCacheOperator().(*CacheOperator_Endswith).Endswith
			vOpts := append(opts,
				db.WithValidateField("cache_operator"),
				db.WithValidateField("Endswith"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CacheOperator_DoesNotEndWith:
		if fv, exists := v.FldValidators["cache_operator.DoesNotEndWith"]; exists {
			val := m.GetCacheOperator().(*CacheOperator_DoesNotEndWith).DoesNotEndWith
			vOpts := append(opts,
				db.WithValidateField("cache_operator"),
				db.WithValidateField("DoesNotEndWith"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CacheOperator_MatchRegex:
		if fv, exists := v.FldValidators["cache_operator.MatchRegex"]; exists {
			val := m.GetCacheOperator().(*CacheOperator_MatchRegex).MatchRegex
			vOpts := append(opts,
				db.WithValidateField("cache_operator"),
				db.WithValidateField("MatchRegex"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCacheOperatorValidator = func() *ValidateCacheOperator {
	v := &ValidateCacheOperator{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCacheOperator := v.CacheOperatorValidationRuleHandler
	rulesCacheOperator := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhCacheOperator(rulesCacheOperator)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CacheOperator.cache_operator: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cache_operator"] = vFn

	return v
}()

func CacheOperatorValidator() db.Validator {
	return DefaultCacheOperatorValidator
}

// augmented methods on protoc/std generated struct

func (m *CacheQueryParameterMatcherType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CacheQueryParameterMatcherType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CacheQueryParameterMatcherType) DeepCopy() *CacheQueryParameterMatcherType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CacheQueryParameterMatcherType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CacheQueryParameterMatcherType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CacheQueryParameterMatcherType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CacheQueryParameterMatcherTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCacheQueryParameterMatcherType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCacheQueryParameterMatcherType) KeyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for key")
	}

	return validatorFn, nil
}

func (v *ValidateCacheQueryParameterMatcherType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CacheQueryParameterMatcherType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CacheQueryParameterMatcherType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["key"]; exists {

		vOpts := append(opts, db.WithValidateField("key"))
		if err := fv(ctx, m.GetKey(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operator"]; exists {

		vOpts := append(opts, db.WithValidateField("operator"))
		if err := fv(ctx, m.GetOperator(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCacheQueryParameterMatcherTypeValidator = func() *ValidateCacheQueryParameterMatcherType {
	v := &ValidateCacheQueryParameterMatcherType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhKey := v.KeyValidationRuleHandler
	rulesKey := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "256",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhKey(rulesKey)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CacheQueryParameterMatcherType.key: %s", err)
		panic(errMsg)
	}
	v.FldValidators["key"] = vFn

	v.FldValidators["operator"] = CacheOperatorValidator().Validate

	return v
}()

func CacheQueryParameterMatcherTypeValidator() db.Validator {
	return DefaultCacheQueryParameterMatcherTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CacheTTLEnableProps) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CacheTTLEnableProps) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CacheTTLEnableProps) DeepCopy() *CacheTTLEnableProps {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CacheTTLEnableProps{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CacheTTLEnableProps) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CacheTTLEnableProps) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CacheTTLEnablePropsValidator().Validate(ctx, m, opts...)
}

type ValidateCacheTTLEnableProps struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCacheTTLEnableProps) CacheTtlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cache_ttl")
	}

	return validatorFn, nil
}

func (v *ValidateCacheTTLEnableProps) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CacheTTLEnableProps)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CacheTTLEnableProps got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_override"]; exists {

		vOpts := append(opts, db.WithValidateField("cache_override"))
		if err := fv(ctx, m.GetCacheOverride(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cache_ttl"]; exists {

		vOpts := append(opts, db.WithValidateField("cache_ttl"))
		if err := fv(ctx, m.GetCacheTtl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ignore_response_cookie"]; exists {

		vOpts := append(opts, db.WithValidateField("ignore_response_cookie"))
		if err := fv(ctx, m.GetIgnoreResponseCookie(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCacheTTLEnablePropsValidator = func() *ValidateCacheTTLEnableProps {
	v := &ValidateCacheTTLEnableProps{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCacheTtl := v.CacheTtlValidationRuleHandler
	rulesCacheTtl := map[string]string{
		"ves.io.schema.rules.message.required":     "true",
		"ves.io.schema.rules.string.time_interval": "true",
	}
	vFn, err = vrhCacheTtl(rulesCacheTtl)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CacheTTLEnableProps.cache_ttl: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cache_ttl"] = vFn

	return v
}()

func CacheTTLEnablePropsValidator() db.Validator {
	return DefaultCacheTTLEnablePropsValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_rules"]; exists {

		vOpts := append(opts, db.WithValidateField("cache_rules"))
		if err := fv(ctx, m.GetCacheRules(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["cache_rules"] = CDNCacheRuleValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_rules"]; exists {

		vOpts := append(opts, db.WithValidateField("cache_rules"))
		if err := fv(ctx, m.GetCacheRules(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["cache_rules"] = CDNCacheRuleValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_rules"]; exists {

		vOpts := append(opts, db.WithValidateField("cache_rules"))
		if err := fv(ctx, m.GetCacheRules(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["cache_rules"] = CDNCacheRuleValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache_rules"]; exists {

		vOpts := append(opts, db.WithValidateField("cache_rules"))
		if err := fv(ctx, m.GetCacheRules(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["cache_rules"] = CDNCacheRuleValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

func (m *CreateSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.CacheRules = f.GetCacheRules()
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *CreateSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *CreateSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.CacheRules = m1.CacheRules
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *CreateSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

func (m *GetSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.CacheRules = f.GetCacheRules()
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *GetSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *GetSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.CacheRules = m1.CacheRules
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *GetSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.CacheRules = f.GetCacheRules()
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.CacheRules = m1.CacheRules
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}
