// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package usage

import (
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func (o *DBObject) GetCurrentUsedObject(objKind string) (int, error) {
	if o == nil {
		return 0, status.Errorf(codes.Internal, "Nil usage.DBObject")
	}
	spec := o.GetSpec()
	if spec == nil {
		return 0, status.Errorf(codes.Internal, "Nil Spec in usage.DBObject")
	}
	gcSpec := spec.GetGcSpec()
	if gcSpec == nil {
		return 0, status.Errorf(codes.Internal, "Nil GcSpec in usage.DBObject")
	}
	usages := gcSpec.GetObjectUsages()
	if usages == nil {
		usages = map[string]*UsageType{
			objKind: &UsageType{Current: 0},
		}
		gcSpec.ObjectUsages = usages
	}
	u, exists := usages[objKind]
	if !exists {
		u = &UsageType{Current: 0}
		usages[objKind] = u
	}
	return int(u.GetCurrent()), nil
}

func (o *DBObject) updateCurrentUsedObject(objKind string, increment bool) error {
	usages := o.GetSpec().GetGcSpec().GetObjectUsages()
	if usages == nil {
		return status.Errorf(codes.Internal, "Nil in usage Object")
	}
	u, exists := usages[objKind]
	if !exists {
		return status.Errorf(codes.Internal, "No usage for object kind %s", objKind)
	}
	if increment {
		u.Current++
	} else {
		if u.Current <= 0 {
			return status.Errorf(codes.Internal, "Decrement would lead to <0 of kind %s", objKind)
		}
		u.Current--
	}
	return nil
}

func (o *DBObject) IncrementCurrentUsedObject(objKind string) error {
	return o.updateCurrentUsedObject(objKind, true)
}

func (o *DBObject) DecrementCurrentUsedObject(objKind string) error {
	return o.updateCurrentUsedObject(objKind, false)
}

func (o *DBObject) GetCurrentUsedResource(rkey string) (float64, error) {
	if o == nil {
		return 0, status.Errorf(codes.Internal, "Nil usage.DBObject")
	}
	spec := o.GetSpec()
	if spec == nil {
		return 0, status.Errorf(codes.Internal, "Nil Spec in usage.DBObject")
	}
	gcSpec := spec.GetGcSpec()
	if gcSpec == nil {
		return 0, status.Errorf(codes.Internal, "Nil GcSpec in usage.DBObject")
	}
	usages := gcSpec.GetResourceUsages()
	if usages == nil {
		usages = map[string]*FloatUsageType{
			rkey: &FloatUsageType{Current: 0},
		}
		gcSpec.ResourceUsages = usages
	}
	u, exists := usages[rkey]
	if !exists {
		u = &FloatUsageType{Current: 0}
		usages[rkey] = u
	}
	return u.GetCurrent(), nil
}

func (o *DBObject) UpdateCurrentUsedResource(rkey string, amount float64) error {
	usages := o.GetSpec().GetGcSpec().GetResourceUsages()
	if usages == nil {
		return status.Errorf(codes.Internal, "Nil in usage Object")
	}
	u, exists := usages[rkey]
	if !exists {
		return status.Errorf(codes.Internal, "No usage for resource %s", rkey)
	}
	if (u.Current + amount) < 0 {
		return status.Errorf(codes.Internal, "Decrement would lead to <0 of resource %s", rkey)
	}
	u.Current += amount
	return nil
}

func (o *DBObject) GetAllCurrentUsedObjects() (map[string]int, error) {
	usages := o.GetSpec().GetGcSpec().GetObjectUsages()

	out := make(map[string]int)
	for k, v := range usages {
		out[k] = int(v.GetCurrent())
	}
	return out, nil
}

func (o *DBObject) GetAllCurrentUsedResources() (map[string]float64, error) {
	usages := o.GetSpec().GetGcSpec().GetResourceUsages()

	out := make(map[string]float64)
	for k, v := range usages {
		out[k] = v.GetCurrent()
	}
	return out, nil
}
