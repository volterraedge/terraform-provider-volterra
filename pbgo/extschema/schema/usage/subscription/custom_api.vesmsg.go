// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package subscription

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *ListSubscriptionsReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListSubscriptionsReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListSubscriptionsReq) DeepCopy() *ListSubscriptionsReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListSubscriptionsReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListSubscriptionsReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListSubscriptionsReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListSubscriptionsReqValidator().Validate(ctx, m, opts...)
}

type ValidateListSubscriptionsReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListSubscriptionsReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListSubscriptionsReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListSubscriptionsReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["current"]; exists {

		vOpts := append(opts, db.WithValidateField("current"))
		if err := fv(ctx, m.GetCurrent(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListSubscriptionsReqValidator = func() *ValidateListSubscriptionsReq {
	v := &ValidateListSubscriptionsReq{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ListSubscriptionsReqValidator() db.Validator {
	return DefaultListSubscriptionsReqValidator
}

// augmented methods on protoc/std generated struct

func (m *ListSubscriptionsRsp) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListSubscriptionsRsp) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListSubscriptionsRsp) DeepCopy() *ListSubscriptionsRsp {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListSubscriptionsRsp{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListSubscriptionsRsp) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListSubscriptionsRsp) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListSubscriptionsRspValidator().Validate(ctx, m, opts...)
}

type ValidateListSubscriptionsRsp struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListSubscriptionsRsp) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListSubscriptionsRsp)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListSubscriptionsRsp got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["subscriptions"]; exists {

		vOpts := append(opts, db.WithValidateField("subscriptions"))
		for idx, item := range m.GetSubscriptions() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListSubscriptionsRspValidator = func() *ValidateListSubscriptionsRsp {
	v := &ValidateListSubscriptionsRsp{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ListSubscriptionsRspValidator() db.Validator {
	return DefaultListSubscriptionsRspValidator
}

// augmented methods on protoc/std generated struct

func (m *Period) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Period) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Period) DeepCopy() *Period {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Period{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Period) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Period) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PeriodValidator().Validate(ctx, m, opts...)
}

type ValidatePeriod struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePeriod) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Period)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Period got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["closed_invoice"]; exists {

		vOpts := append(opts, db.WithValidateField("closed_invoice"))
		for idx, item := range m.GetClosedInvoice() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["end_date"]; exists {

		vOpts := append(opts, db.WithValidateField("end_date"))
		if err := fv(ctx, m.GetEndDate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["internal_end_date"]; exists {

		vOpts := append(opts, db.WithValidateField("internal_end_date"))
		if err := fv(ctx, m.GetInternalEndDate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["internal_start_date"]; exists {

		vOpts := append(opts, db.WithValidateField("internal_start_date"))
		if err := fv(ctx, m.GetInternalStartDate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["invoices"]; exists {

		vOpts := append(opts, db.WithValidateField("invoices"))
		for idx, item := range m.GetInvoices() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["pending_invoice"]; exists {

		vOpts := append(opts, db.WithValidateField("pending_invoice"))
		for idx, item := range m.GetPendingInvoice() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["start_date"]; exists {

		vOpts := append(opts, db.WithValidateField("start_date"))
		if err := fv(ctx, m.GetStartDate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["trial"]; exists {

		vOpts := append(opts, db.WithValidateField("trial"))
		if err := fv(ctx, m.GetTrial(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["uid"]; exists {

		vOpts := append(opts, db.WithValidateField("uid"))
		if err := fv(ctx, m.GetUid(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPeriodValidator = func() *ValidatePeriod {
	v := &ValidatePeriod{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func PeriodValidator() db.Validator {
	return DefaultPeriodValidator
}

// augmented methods on protoc/std generated struct

func (m *SubscriptionType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SubscriptionType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SubscriptionType) DeepCopy() *SubscriptionType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SubscriptionType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SubscriptionType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SubscriptionType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SubscriptionTypeValidator().Validate(ctx, m, opts...)
}

type ValidateSubscriptionType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSubscriptionType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SubscriptionType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SubscriptionType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cancellation_date"]; exists {

		vOpts := append(opts, db.WithValidateField("cancellation_date"))
		if err := fv(ctx, m.GetCancellationDate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cancelled"]; exists {

		vOpts := append(opts, db.WithValidateField("cancelled"))
		if err := fv(ctx, m.GetCancelled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["current"]; exists {

		vOpts := append(opts, db.WithValidateField("current"))
		if err := fv(ctx, m.GetCurrent(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["last_billing_period_end_date"]; exists {

		vOpts := append(opts, db.WithValidateField("last_billing_period_end_date"))
		if err := fv(ctx, m.GetLastBillingPeriodEndDate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["last_billing_period_start_date"]; exists {

		vOpts := append(opts, db.WithValidateField("last_billing_period_start_date"))
		if err := fv(ctx, m.GetLastBillingPeriodStartDate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["plan_name"]; exists {

		vOpts := append(opts, db.WithValidateField("plan_name"))
		if err := fv(ctx, m.GetPlanName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["plan_object_name"]; exists {

		vOpts := append(opts, db.WithValidateField("plan_object_name"))
		if err := fv(ctx, m.GetPlanObjectName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["previous_billing_periods"]; exists {

		vOpts := append(opts, db.WithValidateField("previous_billing_periods"))
		for idx, item := range m.GetPreviousBillingPeriods() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["start_date"]; exists {

		vOpts := append(opts, db.WithValidateField("start_date"))
		if err := fv(ctx, m.GetStartDate(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSubscriptionTypeValidator = func() *ValidateSubscriptionType {
	v := &ValidateSubscriptionType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SubscriptionTypeValidator() db.Validator {
	return DefaultSubscriptionTypeValidator
}
