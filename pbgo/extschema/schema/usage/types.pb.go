// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/usage/types.proto

package usage

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	golang_proto "github.com/golang/protobuf/proto"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// UsageType
//
// x-displayName: "Usage"
// UsageType defines the number of objects of a specific object kind that are currently in use
type UsageType struct {
	// current
	//
	// x-displayName: "Current"
	// The in-use value for the object kind
	Current int32 `protobuf:"varint,1,opt,name=current,proto3" json:"current,omitempty"`
}

func (m *UsageType) Reset()      { *m = UsageType{} }
func (*UsageType) ProtoMessage() {}
func (*UsageType) Descriptor() ([]byte, []int) {
	return fileDescriptor_47474aa9aeda8423, []int{0}
}
func (m *UsageType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsageType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UsageType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsageType.Merge(m, src)
}
func (m *UsageType) XXX_Size() int {
	return m.Size()
}
func (m *UsageType) XXX_DiscardUnknown() {
	xxx_messageInfo_UsageType.DiscardUnknown(m)
}

var xxx_messageInfo_UsageType proto.InternalMessageInfo

func (m *UsageType) GetCurrent() int32 {
	if m != nil {
		return m.Current
	}
	return 0
}

// FloatUsageType
//
// x-displayName: "Usage (float)"
// FloatUsageType defines the usage in float. Useful to report usage for items that have limits in
// fractions
type FloatUsageType struct {
	// current
	//
	// x-displayName: "Current"
	// The in-use value
	Current float64 `protobuf:"fixed64,1,opt,name=current,proto3" json:"current,omitempty"`
}

func (m *FloatUsageType) Reset()      { *m = FloatUsageType{} }
func (*FloatUsageType) ProtoMessage() {}
func (*FloatUsageType) Descriptor() ([]byte, []int) {
	return fileDescriptor_47474aa9aeda8423, []int{1}
}
func (m *FloatUsageType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FloatUsageType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FloatUsageType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FloatUsageType.Merge(m, src)
}
func (m *FloatUsageType) XXX_Size() int {
	return m.Size()
}
func (m *FloatUsageType) XXX_DiscardUnknown() {
	xxx_messageInfo_FloatUsageType.DiscardUnknown(m)
}

var xxx_messageInfo_FloatUsageType proto.InternalMessageInfo

func (m *FloatUsageType) GetCurrent() float64 {
	if m != nil {
		return m.Current
	}
	return 0
}

// FloatUsagesType
//
// x-displayName: "UsagesType (float)"
// FloatUsagesType is used to indicate usage for a group of objects or resources.
type FloatUsagesType struct {
	// usages
	//
	// x-displayName: "Usages"
	// Usages is the map of objects or resources to their current usage.
	Usages map[string]*FloatUsageType `protobuf:"bytes,1,rep,name=usages,proto3" json:"usages,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *FloatUsagesType) Reset()      { *m = FloatUsagesType{} }
func (*FloatUsagesType) ProtoMessage() {}
func (*FloatUsagesType) Descriptor() ([]byte, []int) {
	return fileDescriptor_47474aa9aeda8423, []int{2}
}
func (m *FloatUsagesType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FloatUsagesType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FloatUsagesType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FloatUsagesType.Merge(m, src)
}
func (m *FloatUsagesType) XXX_Size() int {
	return m.Size()
}
func (m *FloatUsagesType) XXX_DiscardUnknown() {
	xxx_messageInfo_FloatUsagesType.DiscardUnknown(m)
}

var xxx_messageInfo_FloatUsagesType proto.InternalMessageInfo

func (m *FloatUsagesType) GetUsages() map[string]*FloatUsageType {
	if m != nil {
		return m.Usages
	}
	return nil
}

// GlobalSpecType
//
// x-displayName: "Global Spec"
// GlobalSpecType defines the shape of the object in database as present in Global Controller
type GlobalSpecType struct {
	// object_usages
	//
	// x-displayName: "Object Usages"
	// Object Usages holds the number of instances that are currently in use for the object kind
	// The key of the object_usages map is object kind e.g. "virtual_host"
	ObjectUsages map[string]*UsageType `protobuf:"bytes,1,rep,name=object_usages,json=objectUsages,proto3" json:"object_usages,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// resource_usages
	//
	// x-displayName: "Resource Usages"
	// Resource Usages holds the current usage for the resources. The key of resource usages is resource
	// name
	ResourceUsages map[string]*FloatUsageType `protobuf:"bytes,2,rep,name=resource_usages,json=resourceUsages,proto3" json:"resource_usages,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_47474aa9aeda8423, []int{3}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetObjectUsages() map[string]*UsageType {
	if m != nil {
		return m.ObjectUsages
	}
	return nil
}

func (m *GlobalSpecType) GetResourceUsages() map[string]*FloatUsageType {
	if m != nil {
		return m.ResourceUsages
	}
	return nil
}

func init() {
	proto.RegisterType((*UsageType)(nil), "ves.io.schema.usage.UsageType")
	golang_proto.RegisterType((*UsageType)(nil), "ves.io.schema.usage.UsageType")
	proto.RegisterType((*FloatUsageType)(nil), "ves.io.schema.usage.FloatUsageType")
	golang_proto.RegisterType((*FloatUsageType)(nil), "ves.io.schema.usage.FloatUsageType")
	proto.RegisterType((*FloatUsagesType)(nil), "ves.io.schema.usage.FloatUsagesType")
	golang_proto.RegisterType((*FloatUsagesType)(nil), "ves.io.schema.usage.FloatUsagesType")
	proto.RegisterMapType((map[string]*FloatUsageType)(nil), "ves.io.schema.usage.FloatUsagesType.UsagesEntry")
	golang_proto.RegisterMapType((map[string]*FloatUsageType)(nil), "ves.io.schema.usage.FloatUsagesType.UsagesEntry")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.usage.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.usage.GlobalSpecType")
	proto.RegisterMapType((map[string]*UsageType)(nil), "ves.io.schema.usage.GlobalSpecType.ObjectUsagesEntry")
	golang_proto.RegisterMapType((map[string]*UsageType)(nil), "ves.io.schema.usage.GlobalSpecType.ObjectUsagesEntry")
	proto.RegisterMapType((map[string]*FloatUsageType)(nil), "ves.io.schema.usage.GlobalSpecType.ResourceUsagesEntry")
	golang_proto.RegisterMapType((map[string]*FloatUsageType)(nil), "ves.io.schema.usage.GlobalSpecType.ResourceUsagesEntry")
}

func init() { proto.RegisterFile("ves.io/schema/usage/types.proto", fileDescriptor_47474aa9aeda8423) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/usage/types.proto", fileDescriptor_47474aa9aeda8423)
}

var fileDescriptor_47474aa9aeda8423 = []byte{
	// 461 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x53, 0xbd, 0x8e, 0xd3, 0x40,
	0x10, 0xf6, 0x24, 0xba, 0x43, 0xb7, 0x81, 0x1c, 0xf8, 0x9a, 0x60, 0xa4, 0x21, 0x0a, 0x42, 0x8a,
	0x90, 0xb2, 0x46, 0x07, 0x88, 0x9f, 0x12, 0x89, 0xbf, 0x0a, 0xc9, 0x40, 0x73, 0x05, 0x87, 0x6d,
	0x36, 0xbe, 0x70, 0x4e, 0xc6, 0x5a, 0xaf, 0x23, 0xd2, 0xd1, 0xd1, 0xd2, 0xf1, 0x0a, 0xbc, 0x03,
	0x0d, 0x25, 0x65, 0xca, 0x94, 0x64, 0xd3, 0x50, 0xde, 0x23, 0xa0, 0xac, 0x1d, 0x9d, 0x0d, 0x46,
	0x50, 0x5c, 0x37, 0x33, 0xfb, 0xfd, 0xcc, 0xcc, 0x6a, 0xd8, 0xd5, 0xa9, 0x48, 0xf9, 0x88, 0xdc,
	0x34, 0x3c, 0x12, 0x63, 0xdf, 0xcd, 0x52, 0x3f, 0x12, 0xae, 0x9a, 0x25, 0x22, 0xe5, 0x89, 0x24,
	0x45, 0xf6, 0x5e, 0x0e, 0xe0, 0x39, 0x80, 0x1b, 0x80, 0x33, 0x88, 0x46, 0xea, 0x28, 0x0b, 0x78,
	0x48, 0x63, 0x37, 0xa2, 0x88, 0x5c, 0x83, 0x0d, 0xb2, 0xa1, 0xc9, 0x4c, 0x62, 0xa2, 0x5c, 0xc3,
	0xb9, 0x52, 0x35, 0xa1, 0x44, 0x8d, 0x68, 0x52, 0x18, 0x38, 0x97, 0xab, 0x8f, 0x25, 0xef, 0xde,
	0x75, 0xb6, 0xf3, 0x6a, 0xed, 0xf7, 0x72, 0x96, 0x08, 0xbb, 0xc3, 0xce, 0x85, 0x99, 0x94, 0x62,
	0xa2, 0x3a, 0xd0, 0x85, 0xfe, 0x96, 0xb7, 0x49, 0x7b, 0x37, 0x58, 0xfb, 0x71, 0x4c, 0xbe, 0xfa,
	0x2b, 0x16, 0x4e, 0xb1, 0x5f, 0x81, 0xed, 0x9e, 0x82, 0x53, 0x83, 0x7e, 0xca, 0xb6, 0xcd, 0x58,
	0x69, 0x07, 0xba, 0xcd, 0x7e, 0x6b, 0xff, 0x26, 0xaf, 0x99, 0x99, 0xff, 0xc6, 0xe2, 0x79, 0xf8,
	0x68, 0xa2, 0xe4, 0xcc, 0x2b, 0xf8, 0xce, 0x6b, 0xd6, 0x2a, 0x95, 0xed, 0x8b, 0xac, 0x79, 0x2c,
	0x66, 0xa6, 0x85, 0x1d, 0x6f, 0x1d, 0xda, 0xf7, 0xd9, 0xd6, 0xd4, 0x8f, 0x33, 0xd1, 0x69, 0x74,
	0xa1, 0xdf, 0xda, 0xbf, 0xf6, 0x0f, 0xa7, 0xb5, 0x91, 0x97, 0x33, 0x1e, 0x34, 0xee, 0x41, 0xef,
	0x73, 0x93, 0xb5, 0x9f, 0xc4, 0x14, 0xf8, 0xf1, 0x8b, 0x44, 0x84, 0xa6, 0xf9, 0x03, 0x76, 0x81,
	0x82, 0x77, 0x22, 0x54, 0x87, 0x95, 0x19, 0xee, 0xd4, 0x2a, 0x57, 0xb9, 0xfc, 0xb9, 0x21, 0x96,
	0x07, 0x39, 0x4f, 0xa5, 0x92, 0xfd, 0x86, 0xed, 0x4a, 0x91, 0x52, 0x26, 0x43, 0xb1, 0x51, 0x6f,
	0x18, 0xf5, 0xbb, 0xff, 0xa3, 0xee, 0x15, 0xd4, 0xb2, 0x7e, 0x5b, 0x56, 0x8a, 0xce, 0x21, 0xbb,
	0xf4, 0x47, 0x13, 0x35, 0x6b, 0xbb, 0x5d, 0x5d, 0x1b, 0xd6, 0xda, 0xd7, 0x6d, 0xcc, 0x19, 0xb2,
	0xbd, 0x9a, 0x3e, 0xce, 0xfc, 0x67, 0x1e, 0x7e, 0x84, 0xf9, 0x12, 0xad, 0xc5, 0x12, 0xad, 0x93,
	0x25, 0xc2, 0x07, 0x8d, 0xf0, 0x45, 0x23, 0x7c, 0xd7, 0x08, 0x73, 0x8d, 0xb0, 0xd0, 0x08, 0x3f,
	0x34, 0xc2, 0x4f, 0x8d, 0xd6, 0x89, 0x46, 0xf8, 0xb4, 0x42, 0xeb, 0xdb, 0x0a, 0x61, 0xbe, 0x42,
	0x6b, 0xb1, 0x42, 0xeb, 0xe0, 0x59, 0x44, 0xc9, 0x71, 0xc4, 0xa7, 0x14, 0x2b, 0x21, 0xe5, 0xda,
	0xce, 0x35, 0xc1, 0x90, 0xe4, 0x78, 0x90, 0x48, 0x9a, 0x8e, 0xde, 0x0a, 0x39, 0xd8, 0x3c, 0xbb,
	0x49, 0x10, 0x91, 0x2b, 0xde, 0xab, 0xe2, 0x66, 0xca, 0xc7, 0x1b, 0x6c, 0x9b, 0xdb, 0xb9, 0xf5,
	0x2b, 0x00, 0x00, 0xff, 0xff, 0x72, 0xed, 0xe9, 0x3d, 0xda, 0x03, 0x00, 0x00,
}

func (this *UsageType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UsageType)
	if !ok {
		that2, ok := that.(UsageType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Current != that1.Current {
		return false
	}
	return true
}
func (this *FloatUsageType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FloatUsageType)
	if !ok {
		that2, ok := that.(FloatUsageType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Current != that1.Current {
		return false
	}
	return true
}
func (this *FloatUsagesType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FloatUsagesType)
	if !ok {
		that2, ok := that.(FloatUsagesType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Usages) != len(that1.Usages) {
		return false
	}
	for i := range this.Usages {
		if !this.Usages[i].Equal(that1.Usages[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ObjectUsages) != len(that1.ObjectUsages) {
		return false
	}
	for i := range this.ObjectUsages {
		if !this.ObjectUsages[i].Equal(that1.ObjectUsages[i]) {
			return false
		}
	}
	if len(this.ResourceUsages) != len(that1.ResourceUsages) {
		return false
	}
	for i := range this.ResourceUsages {
		if !this.ResourceUsages[i].Equal(that1.ResourceUsages[i]) {
			return false
		}
	}
	return true
}
func (this *UsageType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&usage.UsageType{")
	s = append(s, "Current: "+fmt.Sprintf("%#v", this.Current)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FloatUsageType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&usage.FloatUsageType{")
	s = append(s, "Current: "+fmt.Sprintf("%#v", this.Current)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FloatUsagesType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&usage.FloatUsagesType{")
	keysForUsages := make([]string, 0, len(this.Usages))
	for k, _ := range this.Usages {
		keysForUsages = append(keysForUsages, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForUsages)
	mapStringForUsages := "map[string]*FloatUsageType{"
	for _, k := range keysForUsages {
		mapStringForUsages += fmt.Sprintf("%#v: %#v,", k, this.Usages[k])
	}
	mapStringForUsages += "}"
	if this.Usages != nil {
		s = append(s, "Usages: "+mapStringForUsages+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&usage.GlobalSpecType{")
	keysForObjectUsages := make([]string, 0, len(this.ObjectUsages))
	for k, _ := range this.ObjectUsages {
		keysForObjectUsages = append(keysForObjectUsages, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForObjectUsages)
	mapStringForObjectUsages := "map[string]*UsageType{"
	for _, k := range keysForObjectUsages {
		mapStringForObjectUsages += fmt.Sprintf("%#v: %#v,", k, this.ObjectUsages[k])
	}
	mapStringForObjectUsages += "}"
	if this.ObjectUsages != nil {
		s = append(s, "ObjectUsages: "+mapStringForObjectUsages+",\n")
	}
	keysForResourceUsages := make([]string, 0, len(this.ResourceUsages))
	for k, _ := range this.ResourceUsages {
		keysForResourceUsages = append(keysForResourceUsages, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForResourceUsages)
	mapStringForResourceUsages := "map[string]*FloatUsageType{"
	for _, k := range keysForResourceUsages {
		mapStringForResourceUsages += fmt.Sprintf("%#v: %#v,", k, this.ResourceUsages[k])
	}
	mapStringForResourceUsages += "}"
	if this.ResourceUsages != nil {
		s = append(s, "ResourceUsages: "+mapStringForResourceUsages+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *UsageType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsageType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsageType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Current != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Current))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FloatUsageType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FloatUsageType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FloatUsageType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Current != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Current))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *FloatUsagesType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FloatUsagesType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FloatUsagesType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Usages) > 0 {
		keysForUsages := make([]string, 0, len(m.Usages))
		for k := range m.Usages {
			keysForUsages = append(keysForUsages, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForUsages)
		for iNdEx := len(keysForUsages) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Usages[string(keysForUsages[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTypes(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForUsages[iNdEx])
			copy(dAtA[i:], keysForUsages[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForUsages[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResourceUsages) > 0 {
		keysForResourceUsages := make([]string, 0, len(m.ResourceUsages))
		for k := range m.ResourceUsages {
			keysForResourceUsages = append(keysForResourceUsages, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForResourceUsages)
		for iNdEx := len(keysForResourceUsages) - 1; iNdEx >= 0; iNdEx-- {
			v := m.ResourceUsages[string(keysForResourceUsages[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTypes(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForResourceUsages[iNdEx])
			copy(dAtA[i:], keysForResourceUsages[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForResourceUsages[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ObjectUsages) > 0 {
		keysForObjectUsages := make([]string, 0, len(m.ObjectUsages))
		for k := range m.ObjectUsages {
			keysForObjectUsages = append(keysForObjectUsages, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForObjectUsages)
		for iNdEx := len(keysForObjectUsages) - 1; iNdEx >= 0; iNdEx-- {
			v := m.ObjectUsages[string(keysForObjectUsages[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTypes(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForObjectUsages[iNdEx])
			copy(dAtA[i:], keysForObjectUsages[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForObjectUsages[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UsageType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Current != 0 {
		n += 1 + sovTypes(uint64(m.Current))
	}
	return n
}

func (m *FloatUsageType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Current != 0 {
		n += 9
	}
	return n
}

func (m *FloatUsagesType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Usages) > 0 {
		for k, v := range m.Usages {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ObjectUsages) > 0 {
		for k, v := range m.ObjectUsages {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.ResourceUsages) > 0 {
		for k, v := range m.ResourceUsages {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *UsageType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UsageType{`,
		`Current:` + fmt.Sprintf("%v", this.Current) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FloatUsageType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FloatUsageType{`,
		`Current:` + fmt.Sprintf("%v", this.Current) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FloatUsagesType) String() string {
	if this == nil {
		return "nil"
	}
	keysForUsages := make([]string, 0, len(this.Usages))
	for k, _ := range this.Usages {
		keysForUsages = append(keysForUsages, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForUsages)
	mapStringForUsages := "map[string]*FloatUsageType{"
	for _, k := range keysForUsages {
		mapStringForUsages += fmt.Sprintf("%v: %v,", k, this.Usages[k])
	}
	mapStringForUsages += "}"
	s := strings.Join([]string{`&FloatUsagesType{`,
		`Usages:` + mapStringForUsages + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	keysForObjectUsages := make([]string, 0, len(this.ObjectUsages))
	for k, _ := range this.ObjectUsages {
		keysForObjectUsages = append(keysForObjectUsages, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForObjectUsages)
	mapStringForObjectUsages := "map[string]*UsageType{"
	for _, k := range keysForObjectUsages {
		mapStringForObjectUsages += fmt.Sprintf("%v: %v,", k, this.ObjectUsages[k])
	}
	mapStringForObjectUsages += "}"
	keysForResourceUsages := make([]string, 0, len(this.ResourceUsages))
	for k, _ := range this.ResourceUsages {
		keysForResourceUsages = append(keysForResourceUsages, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForResourceUsages)
	mapStringForResourceUsages := "map[string]*FloatUsageType{"
	for _, k := range keysForResourceUsages {
		mapStringForResourceUsages += fmt.Sprintf("%v: %v,", k, this.ResourceUsages[k])
	}
	mapStringForResourceUsages += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`ObjectUsages:` + mapStringForObjectUsages + `,`,
		`ResourceUsages:` + mapStringForResourceUsages + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *UsageType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UsageType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UsageType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			m.Current = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Current |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FloatUsageType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FloatUsageType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FloatUsageType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Current = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FloatUsagesType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FloatUsagesType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FloatUsagesType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Usages == nil {
				m.Usages = make(map[string]*FloatUsageType)
			}
			var mapkey string
			var mapvalue *FloatUsageType
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FloatUsageType{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Usages[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectUsages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectUsages == nil {
				m.ObjectUsages = make(map[string]*UsageType)
			}
			var mapkey string
			var mapvalue *UsageType
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &UsageType{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ObjectUsages[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceUsages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceUsages == nil {
				m.ResourceUsages = make(map[string]*FloatUsageType)
			}
			var mapkey string
			var mapvalue *FloatUsageType
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FloatUsageType{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ResourceUsages[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
