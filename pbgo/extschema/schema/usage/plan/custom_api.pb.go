// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/usage/plan/custom_api.proto

// Usage plan related Customer APIs
//
// x-displayName: "Usage plan"
// Usage plan related RPCs. Used for billing and onboarding.

package plan

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/googleapis/google/api"
	proto "github.com/gogo/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	quota "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/quota"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/vesenv"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// PlanTransitionMethod
//
// x-displayName: "PlanTransitionMethod"
// Transitioning method which UI should show to the customer to properly execute the transition between
type PlanTransitionMethod int32

const (
	// Zero value
	// x-displayName: "Zero"
	TRANSITION_METHOD_UNSPECIFIED PlanTransitionMethod = 0
	// The transition should be done via a support request, the current behaviour for any transition
	// x-displayName: "Support"
	TRANSITION_METHOD_SUPPORT PlanTransitionMethod = 1
	// The transition should be done via a custom Wizard. Fields which should be
	// provided will be guided by PlanTransitionRequiredField
	// x-displayName: "Wizard"
	TRANSITION_METHOD_WIZARD PlanTransitionMethod = 2
	// The transition should be done via logging the user out, deleting the current tenant and creating a new one
	// x-displayName: "Recreate"
	TRANSITION_METHOD_RECREATE PlanTransitionMethod = 3
)

var PlanTransitionMethod_name = map[int32]string{
	0: "TRANSITION_METHOD_UNSPECIFIED",
	1: "TRANSITION_METHOD_SUPPORT",
	2: "TRANSITION_METHOD_WIZARD",
	3: "TRANSITION_METHOD_RECREATE",
}

var PlanTransitionMethod_value = map[string]int32{
	"TRANSITION_METHOD_UNSPECIFIED": 0,
	"TRANSITION_METHOD_SUPPORT":     1,
	"TRANSITION_METHOD_WIZARD":      2,
	"TRANSITION_METHOD_RECREATE":    3,
}

func (PlanTransitionMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_007dfa1b3083d461, []int{0}
}

// PlanTransitionRequiredField
//
// x-displayName: "PlanTransitionRequiredField"
// fields which UI should provide to the backend to properly execute the transition between plans
type PlanTransitionRequiredField int32

const (
	// Zero value
	// x-displayName: "Nothing"
	TRANSITION_REQUIRED_FIELD_UNSPECIFIED PlanTransitionRequiredField = 0
	// Stripe token after user enters CC info and we submit it to stripe
	// x-displayName: "Payment provider token"
	TRANSITION_REQUIRED_FIELD_PAYMENT_TOKEN PlanTransitionRequiredField = 1
	// Domain for team/organization plans which will be used for keycloak realm
	// x-displayName: "Domain"
	TRANSITION_REQUIRED_FIELD_DOMAIN PlanTransitionRequiredField = 2
	// Contacts is billing contacts
	// x-displayName: "Contact"
	TRANSITION_REQUIRED_FIELD_CONTACTS PlanTransitionRequiredField = 3
)

var PlanTransitionRequiredField_name = map[int32]string{
	0: "TRANSITION_REQUIRED_FIELD_UNSPECIFIED",
	1: "TRANSITION_REQUIRED_FIELD_PAYMENT_TOKEN",
	2: "TRANSITION_REQUIRED_FIELD_DOMAIN",
	3: "TRANSITION_REQUIRED_FIELD_CONTACTS",
}

var PlanTransitionRequiredField_value = map[string]int32{
	"TRANSITION_REQUIRED_FIELD_UNSPECIFIED":   0,
	"TRANSITION_REQUIRED_FIELD_PAYMENT_TOKEN": 1,
	"TRANSITION_REQUIRED_FIELD_DOMAIN":        2,
	"TRANSITION_REQUIRED_FIELD_CONTACTS":      3,
}

func (PlanTransitionRequiredField) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_007dfa1b3083d461, []int{1}
}

// PlanTransitionState
//
// x-displayName: "PlanTransitionState"
// State of the
type PlanState int32

const (
	// zero value
	// x-displayName: "Unknown"
	STATE_UNSPECIFIED PlanState = 0
	// the plan is in default state
	// x-displayName: "Ready"
	STATE_READY PlanState = 1
	// the plan is in the state of plan transitioning. If the plan has current flag equals to true and in
	// TRANSITION_PENDING then tenant moves to another plan which is in state TRANSITION_PENDING.
	// At the same moment in time no more than 2 plans should have TRANSITION_PENDING state
	// x-displayName: "Pending"
	STATE_TRANSITION_PENDING PlanState = 2
)

var PlanState_name = map[int32]string{
	0: "STATE_UNSPECIFIED",
	1: "STATE_READY",
	2: "STATE_TRANSITION_PENDING",
}

var PlanState_value = map[string]int32{
	"STATE_UNSPECIFIED":        0,
	"STATE_READY":              1,
	"STATE_TRANSITION_PENDING": 2,
}

func (PlanState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_007dfa1b3083d461, []int{2}
}

// Period type
//
// x-displayName: "Period type"
// Temporal period type
type PeriodUnitType int32

const (
	// unknown, undefined period of time
	// x-displayName: "Unknown"
	PERIOD_UNKNOWN PeriodUnitType = 0
	// Day
	// x-displayName: "Day"
	PERIOD_DAY PeriodUnitType = 1
	// Week
	// x-displayName: "Week"
	PERIOD_WEEK PeriodUnitType = 2
	// Month
	// x-displayName: "Month"
	PERIOD_MONTH PeriodUnitType = 3
	// Year
	// x-displayName: "Year"
	PERIOD_YEAR PeriodUnitType = 4
)

var PeriodUnitType_name = map[int32]string{
	0: "PERIOD_UNKNOWN",
	1: "PERIOD_DAY",
	2: "PERIOD_WEEK",
	3: "PERIOD_MONTH",
	4: "PERIOD_YEAR",
}

var PeriodUnitType_value = map[string]int32{
	"PERIOD_UNKNOWN": 0,
	"PERIOD_DAY":     1,
	"PERIOD_WEEK":    2,
	"PERIOD_MONTH":   3,
	"PERIOD_YEAR":    4,
}

func (PeriodUnitType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_007dfa1b3083d461, []int{3}
}

// Usage Plans Request
//
// x-displayName: "UsagePlansReq"
// Request to get usage plans
type ListUsagePlansReq struct {
}

func (m *ListUsagePlansReq) Reset()      { *m = ListUsagePlansReq{} }
func (*ListUsagePlansReq) ProtoMessage() {}
func (*ListUsagePlansReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_007dfa1b3083d461, []int{0}
}
func (m *ListUsagePlansReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListUsagePlansReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListUsagePlansReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListUsagePlansReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUsagePlansReq.Merge(m, src)
}
func (m *ListUsagePlansReq) XXX_Size() int {
	return m.Size()
}
func (m *ListUsagePlansReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUsagePlansReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListUsagePlansReq proto.InternalMessageInfo

// Addon Service Details
//
// x-displayName: "Addon Service Details"
// Details about addon service
type AddonServiceDetails struct {
	// Name
	//
	// x-displayName: "Name"
	// x-example: "re-2-ce-v1"
	// Name of the addon feature
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Display name
	//
	// x-displayName: "Display name"
	// x-example: "Transfer from RE to CE"
	// Human readable name of addon
	DisplayName string `protobuf:"bytes,2,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
}

func (m *AddonServiceDetails) Reset()      { *m = AddonServiceDetails{} }
func (*AddonServiceDetails) ProtoMessage() {}
func (*AddonServiceDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_007dfa1b3083d461, []int{1}
}
func (m *AddonServiceDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddonServiceDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddonServiceDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddonServiceDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddonServiceDetails.Merge(m, src)
}
func (m *AddonServiceDetails) XXX_Size() int {
	return m.Size()
}
func (m *AddonServiceDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_AddonServiceDetails.DiscardUnknown(m)
}

var xxx_messageInfo_AddonServiceDetails proto.InternalMessageInfo

func (m *AddonServiceDetails) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AddonServiceDetails) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

// PlanInternal
//
// x-displayName: "PlanInternal"
// Structure that holds all data needed to choose usage plan
type PlanInternal struct {
	// Name
	//
	// x-displayName: "Name"
	// x-example: "free-p25-v2"
	// Name of the plan, the name is not guaranteed to be human readable.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Title
	//
	// x-displayName: "Title"
	// x-example: "Free"
	// Title of the plan, human readable.
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	// Description
	//
	// x-displayName: "Description"
	// x-example: "###Free plan, includes x y z *Free item 1 *Free item 2 ##Self-support only"
	// Description of the plan as mark-down text.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Tenant type
	//
	// x-displayName: "Tenant type"
	// The type of tenant the plan is intended for - if subscribed to this plan the tenant would of this tenant type.
	TenantType schema.TenantType `protobuf:"varint,4,opt,name=tenant_type,json=tenantType,proto3,enum=ves.io.schema.TenantType" json:"tenant_type,omitempty"`
	// Billing disabled
	//
	// x-displayName: "Billing disabled"
	// If true then there's no automatic billing.
	BillingDisabled bool `protobuf:"varint,5,opt,name=billing_disabled,json=billingDisabled,proto3" json:"billing_disabled,omitempty"`
	// Flat price
	//
	// x-displayName: "Flat price"
	// x-example: "100"
	// Flat fee of the plan in cents
	FlatPrice int32 `protobuf:"varint,6,opt,name=flat_price,json=flatPrice,proto3" json:"flat_price,omitempty"`
	// Renewal Period
	//
	// x-displayName: "Renewal period"
	// Renewal period unit of the plan
	RenewalPeriodUnit PeriodUnitType `protobuf:"varint,7,opt,name=renewal_period_unit,json=renewalPeriodUnit,proto3,enum=ves.io.schema.usage.plan.PeriodUnitType" json:"renewal_period_unit,omitempty"`
	// Sub-Title
	//
	// x-displayName: "Sub-title"
	// x-example: "Our free plan"
	// Optional second line of the title of the plan, human readable.
	Subtitle string `protobuf:"bytes,9,opt,name=subtitle,proto3" json:"subtitle,omitempty"`
	// Current
	//
	// x-displayName: "Current"
	// True if plan is active. Note that customers are only allowed to current plans.
	Current bool `protobuf:"varint,10,opt,name=current,proto3" json:"current,omitempty"`
	// Default quota
	//
	// x-displayName: "Default quota"
	// Default quota associated with the plan.
	DefaultQuota *quota.GlobalSpecType `protobuf:"bytes,11,opt,name=default_quota,json=defaultQuota,proto3" json:"default_quota,omitempty"`
	// Usage plan type
	//
	// x-displayName: "Usage plan type"
	// Usage plan type
	UsagePlanType schema.PlanType `protobuf:"varint,13,opt,name=usage_plan_type,json=usagePlanType,proto3,enum=ves.io.schema.PlanType" json:"usage_plan_type,omitempty"`
	// Trial period unit
	//
	// x-displayName: "Trial period unit"
	// Trial period unit of the plan
	TrialPeriodUnit PeriodUnitType `protobuf:"varint,14,opt,name=trial_period_unit,json=trialPeriodUnit,proto3,enum=ves.io.schema.usage.plan.PeriodUnitType" json:"trial_period_unit,omitempty"`
	// Transition flow
	//
	// x-displayName: "Transition flow"
	// Transaction flow for customers wanting to migrate on this plan
	TransitionFlow *UsagePlanTransitionFlow `protobuf:"bytes,15,opt,name=transition_flow,json=transitionFlow,proto3" json:"transition_flow,omitempty"`
	// Transition flow
	//
	// x-displayName: "Transition flow"
	// Transaction flow for customers wanting to migrate on this plan
	State PlanState `protobuf:"varint,16,opt,name=state,proto3,enum=ves.io.schema.usage.plan.PlanState" json:"state,omitempty"`
	// Trial period
	//
	// x-displayName: "Trial period"
	// x-example: "3"
	// Trial period associated with this plan. Different pricing conditions are in place during the trial period - flat fee my not apply, or similar
	TrialPeriod int32 `protobuf:"varint,35,opt,name=trial_period,json=trialPeriod,proto3" json:"trial_period,omitempty"`
	// included_addon_services
	// x-displayName: "Included Addon Services"
	// List of addon services that are available part of current plan.
	IncludedAddonServices []*AddonServiceDetails `protobuf:"bytes,36,rep,name=included_addon_services,json=includedAddonServices,proto3" json:"included_addon_services,omitempty"`
	// allowed_addon_services
	// x-displayName: "Allowed Addon Services"
	// List of addon services that can be subscribed part of current plan.
	AllowedAddonServices []*AddonServiceDetails `protobuf:"bytes,37,rep,name=allowed_addon_services,json=allowedAddonServices,proto3" json:"allowed_addon_services,omitempty"`
}

func (m *PlanInternal) Reset()      { *m = PlanInternal{} }
func (*PlanInternal) ProtoMessage() {}
func (*PlanInternal) Descriptor() ([]byte, []int) {
	return fileDescriptor_007dfa1b3083d461, []int{2}
}
func (m *PlanInternal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlanInternal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlanInternal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlanInternal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlanInternal.Merge(m, src)
}
func (m *PlanInternal) XXX_Size() int {
	return m.Size()
}
func (m *PlanInternal) XXX_DiscardUnknown() {
	xxx_messageInfo_PlanInternal.DiscardUnknown(m)
}

var xxx_messageInfo_PlanInternal proto.InternalMessageInfo

func (m *PlanInternal) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PlanInternal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *PlanInternal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *PlanInternal) GetTenantType() schema.TenantType {
	if m != nil {
		return m.TenantType
	}
	return schema.UNKNOWN
}

func (m *PlanInternal) GetBillingDisabled() bool {
	if m != nil {
		return m.BillingDisabled
	}
	return false
}

func (m *PlanInternal) GetFlatPrice() int32 {
	if m != nil {
		return m.FlatPrice
	}
	return 0
}

func (m *PlanInternal) GetRenewalPeriodUnit() PeriodUnitType {
	if m != nil {
		return m.RenewalPeriodUnit
	}
	return PERIOD_UNKNOWN
}

func (m *PlanInternal) GetSubtitle() string {
	if m != nil {
		return m.Subtitle
	}
	return ""
}

func (m *PlanInternal) GetCurrent() bool {
	if m != nil {
		return m.Current
	}
	return false
}

func (m *PlanInternal) GetDefaultQuota() *quota.GlobalSpecType {
	if m != nil {
		return m.DefaultQuota
	}
	return nil
}

func (m *PlanInternal) GetUsagePlanType() schema.PlanType {
	if m != nil {
		return m.UsagePlanType
	}
	return schema.FREE
}

func (m *PlanInternal) GetTrialPeriodUnit() PeriodUnitType {
	if m != nil {
		return m.TrialPeriodUnit
	}
	return PERIOD_UNKNOWN
}

func (m *PlanInternal) GetTransitionFlow() *UsagePlanTransitionFlow {
	if m != nil {
		return m.TransitionFlow
	}
	return nil
}

func (m *PlanInternal) GetState() PlanState {
	if m != nil {
		return m.State
	}
	return STATE_UNSPECIFIED
}

func (m *PlanInternal) GetTrialPeriod() int32 {
	if m != nil {
		return m.TrialPeriod
	}
	return 0
}

func (m *PlanInternal) GetIncludedAddonServices() []*AddonServiceDetails {
	if m != nil {
		return m.IncludedAddonServices
	}
	return nil
}

func (m *PlanInternal) GetAllowedAddonServices() []*AddonServiceDetails {
	if m != nil {
		return m.AllowedAddonServices
	}
	return nil
}

// UsagePlanTransitionFlow
//
// x-displayName: "UsagePlanTransitionFlow"
// Details for transition flow. Is used as part of UsagePlanInternal
type UsagePlanTransitionFlow struct {
	// Method
	//
	// x-displayName: "Method"
	// Method to migrate onto this plan
	Method PlanTransitionMethod `protobuf:"varint,1,opt,name=method,proto3,enum=ves.io.schema.usage.plan.PlanTransitionMethod" json:"method,omitempty"`
	// Required fields
	//
	// x-displayName: "Required fields"
	// Mandatory information to migrate onto this plan
	RequiredFields []PlanTransitionRequiredField `protobuf:"varint,2,rep,packed,name=required_fields,json=requiredFields,proto3,enum=ves.io.schema.usage.plan.PlanTransitionRequiredField" json:"required_fields,omitempty"`
	// Manual approval
	//
	// x-displayName: "Manual approval"
	// If true then any migration onto this plan must be approved by the billing department.
	RequiresManualApproval bool `protobuf:"varint,3,opt,name=requires_manual_approval,json=requiresManualApproval,proto3" json:"requires_manual_approval,omitempty"`
}

func (m *UsagePlanTransitionFlow) Reset()      { *m = UsagePlanTransitionFlow{} }
func (*UsagePlanTransitionFlow) ProtoMessage() {}
func (*UsagePlanTransitionFlow) Descriptor() ([]byte, []int) {
	return fileDescriptor_007dfa1b3083d461, []int{3}
}
func (m *UsagePlanTransitionFlow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsagePlanTransitionFlow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UsagePlanTransitionFlow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UsagePlanTransitionFlow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsagePlanTransitionFlow.Merge(m, src)
}
func (m *UsagePlanTransitionFlow) XXX_Size() int {
	return m.Size()
}
func (m *UsagePlanTransitionFlow) XXX_DiscardUnknown() {
	xxx_messageInfo_UsagePlanTransitionFlow.DiscardUnknown(m)
}

var xxx_messageInfo_UsagePlanTransitionFlow proto.InternalMessageInfo

func (m *UsagePlanTransitionFlow) GetMethod() PlanTransitionMethod {
	if m != nil {
		return m.Method
	}
	return TRANSITION_METHOD_UNSPECIFIED
}

func (m *UsagePlanTransitionFlow) GetRequiredFields() []PlanTransitionRequiredField {
	if m != nil {
		return m.RequiredFields
	}
	return nil
}

func (m *UsagePlanTransitionFlow) GetRequiresManualApproval() bool {
	if m != nil {
		return m.RequiresManualApproval
	}
	return false
}

// LocalizedUsagePlan
//
// x-displayName: "LocalizedUsagePlan"
// Localized info of usage plan
type LocalizedPlan struct {
	// Locale
	//
	// x-displayName: "Locale"
	// x-example: "en-us"
	// Locale in the ISO dashed  format
	Locale string `protobuf:"bytes,1,opt,name=locale,proto3" json:"locale,omitempty"`
	// Plans
	//
	// x-displayName: "Plans"
	// Collection of currently publicly available plans.
	Plans []*PlanInternal `protobuf:"bytes,2,rep,name=plans,proto3" json:"plans,omitempty"`
}

func (m *LocalizedPlan) Reset()      { *m = LocalizedPlan{} }
func (*LocalizedPlan) ProtoMessage() {}
func (*LocalizedPlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_007dfa1b3083d461, []int{4}
}
func (m *LocalizedPlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalizedPlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocalizedPlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocalizedPlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalizedPlan.Merge(m, src)
}
func (m *LocalizedPlan) XXX_Size() int {
	return m.Size()
}
func (m *LocalizedPlan) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalizedPlan.DiscardUnknown(m)
}

var xxx_messageInfo_LocalizedPlan proto.InternalMessageInfo

func (m *LocalizedPlan) GetLocale() string {
	if m != nil {
		return m.Locale
	}
	return ""
}

func (m *LocalizedPlan) GetPlans() []*PlanInternal {
	if m != nil {
		return m.Plans
	}
	return nil
}

// Usage Plans Response
//
// x-displayName: "UsagePlansRsp"
// Response with the usage plans info
type ListUsagePlansRsp struct {
	// Usage plans
	//
	// x-displayName: "Usage plans"
	// Collection of available plans
	UsagePlans []*LocalizedPlan `protobuf:"bytes,2,rep,name=usage_plans,json=usagePlans,proto3" json:"usage_plans,omitempty"`
}

func (m *ListUsagePlansRsp) Reset()      { *m = ListUsagePlansRsp{} }
func (*ListUsagePlansRsp) ProtoMessage() {}
func (*ListUsagePlansRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_007dfa1b3083d461, []int{5}
}
func (m *ListUsagePlansRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListUsagePlansRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListUsagePlansRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListUsagePlansRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUsagePlansRsp.Merge(m, src)
}
func (m *ListUsagePlansRsp) XXX_Size() int {
	return m.Size()
}
func (m *ListUsagePlansRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUsagePlansRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ListUsagePlansRsp proto.InternalMessageInfo

func (m *ListUsagePlansRsp) GetUsagePlans() []*LocalizedPlan {
	if m != nil {
		return m.UsagePlans
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.usage.plan.PlanTransitionMethod", PlanTransitionMethod_name, PlanTransitionMethod_value)
	proto.RegisterEnum("ves.io.schema.usage.plan.PlanTransitionRequiredField", PlanTransitionRequiredField_name, PlanTransitionRequiredField_value)
	proto.RegisterEnum("ves.io.schema.usage.plan.PlanState", PlanState_name, PlanState_value)
	proto.RegisterEnum("ves.io.schema.usage.plan.PeriodUnitType", PeriodUnitType_name, PeriodUnitType_value)
	proto.RegisterType((*ListUsagePlansReq)(nil), "ves.io.schema.usage.plan.ListUsagePlansReq")
	proto.RegisterType((*AddonServiceDetails)(nil), "ves.io.schema.usage.plan.AddonServiceDetails")
	proto.RegisterType((*PlanInternal)(nil), "ves.io.schema.usage.plan.PlanInternal")
	proto.RegisterType((*UsagePlanTransitionFlow)(nil), "ves.io.schema.usage.plan.UsagePlanTransitionFlow")
	proto.RegisterType((*LocalizedPlan)(nil), "ves.io.schema.usage.plan.LocalizedPlan")
	proto.RegisterType((*ListUsagePlansRsp)(nil), "ves.io.schema.usage.plan.ListUsagePlansRsp")
}

func init() {
	proto.RegisterFile("ves.io/schema/usage/plan/custom_api.proto", fileDescriptor_007dfa1b3083d461)
}

var fileDescriptor_007dfa1b3083d461 = []byte{
	// 1348 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xcf, 0x6f, 0xdb, 0xc6,
	0x12, 0x16, 0x25, 0xdb, 0xb1, 0x47, 0xb6, 0x44, 0x6f, 0x9c, 0x84, 0x51, 0x12, 0x3d, 0x45, 0xf9,
	0xa5, 0x38, 0x4f, 0x22, 0xe2, 0x20, 0x40, 0xde, 0x43, 0x81, 0x42, 0xb5, 0xe8, 0x58, 0x89, 0x2d,
	0x29, 0x14, 0x8d, 0x34, 0x06, 0x5a, 0x62, 0x45, 0xae, 0x65, 0xb6, 0x14, 0xc9, 0x70, 0x57, 0x76,
	0xdc, 0x53, 0x11, 0xf4, 0x0f, 0x28, 0x50, 0xa0, 0xe8, 0x9f, 0x50, 0xa0, 0xb7, 0x5e, 0x73, 0x29,
	0x50, 0x14, 0xe9, 0xa9, 0x08, 0xda, 0x4b, 0x8e, 0x8d, 0xdc, 0x43, 0xd1, 0x53, 0xee, 0xbd, 0x14,
	0x5c, 0x52, 0xb6, 0x64, 0x5b, 0x86, 0x9b, 0x1b, 0x67, 0xbe, 0x99, 0x6f, 0xbf, 0x9d, 0xdd, 0x19,
	0x2e, 0xdc, 0xdc, 0x22, 0xb4, 0x64, 0xb9, 0x32, 0x35, 0x36, 0x49, 0x07, 0xcb, 0x5d, 0x8a, 0xdb,
	0x44, 0xf6, 0x6c, 0xec, 0xc8, 0x46, 0x97, 0x32, 0xb7, 0xa3, 0x63, 0xcf, 0x2a, 0x79, 0xbe, 0xcb,
	0x5c, 0x24, 0x85, 0xa1, 0xa5, 0x30, 0xb4, 0xc4, 0x43, 0x4b, 0x41, 0x68, 0xe6, 0x62, 0xdb, 0x75,
	0xdb, 0x36, 0x91, 0xb1, 0x67, 0xc9, 0xd8, 0x71, 0x5c, 0x86, 0x99, 0xe5, 0x3a, 0x34, 0xcc, 0xcb,
	0x5c, 0x18, 0x5e, 0xc2, 0xf5, 0x06, 0xc1, 0xff, 0x0c, 0x83, 0x4f, 0xbb, 0x2e, 0xc3, 0x32, 0xdb,
	0xf1, 0x48, 0x3f, 0xe0, 0xfc, 0x70, 0xc0, 0x20, 0x94, 0x1f, 0x86, 0xb6, 0x08, 0x25, 0xce, 0xd6,
	0x30, 0x7f, 0xfe, 0x34, 0xcc, 0xae, 0x58, 0x94, 0xad, 0x05, 0x62, 0x1b, 0x36, 0x76, 0xa8, 0x4a,
	0x9e, 0xe6, 0x57, 0xe0, 0x74, 0xd9, 0x34, 0x5d, 0xa7, 0x49, 0xfc, 0x2d, 0xcb, 0x20, 0x15, 0xc2,
	0xb0, 0x65, 0x53, 0x84, 0x60, 0xcc, 0xc1, 0x1d, 0x22, 0x09, 0x39, 0xa1, 0x30, 0xa5, 0xf2, 0x6f,
	0x74, 0x19, 0xa6, 0x4d, 0x8b, 0x7a, 0x36, 0xde, 0xd1, 0x39, 0x16, 0xe7, 0x58, 0x32, 0xf2, 0xd5,
	0x70, 0x87, 0xe4, 0x77, 0x4f, 0xc1, 0x74, 0x40, 0x5d, 0x75, 0x18, 0xf1, 0x1d, 0x6c, 0x1f, 0xc9,
	0x33, 0x07, 0xe3, 0xcc, 0x62, 0x76, 0x9f, 0x20, 0x34, 0x50, 0x0e, 0x92, 0x26, 0xa1, 0x86, 0x6f,
	0x71, 0xcd, 0x52, 0x22, 0x22, 0xdf, 0x77, 0xa1, 0xff, 0x43, 0x92, 0x11, 0x07, 0x3b, 0x4c, 0x0f,
	0x76, 0x2e, 0x8d, 0xe5, 0x84, 0x42, 0x6a, 0xe1, 0x7c, 0x69, 0xf8, 0x28, 0x34, 0x1e, 0xa1, 0xed,
	0x78, 0x44, 0x05, 0xb6, 0xf7, 0x8d, 0x6e, 0x82, 0xd8, 0xb2, 0x6c, 0xdb, 0x72, 0xda, 0xba, 0x69,
	0x51, 0xdc, 0xb2, 0x89, 0x29, 0x8d, 0xe7, 0x84, 0xc2, 0xa4, 0x9a, 0x8e, 0xfc, 0x95, 0xc8, 0x8d,
	0x2e, 0x01, 0x6c, 0xd8, 0x98, 0xe9, 0x9e, 0x6f, 0x19, 0x44, 0x9a, 0xc8, 0x09, 0x85, 0x71, 0x75,
	0x2a, 0xf0, 0x34, 0x02, 0x07, 0xfa, 0x10, 0x4e, 0xfb, 0xc4, 0x21, 0xdb, 0xd8, 0xd6, 0x3d, 0xe2,
	0x5b, 0xae, 0xa9, 0x77, 0x1d, 0x8b, 0x49, 0xa7, 0xb8, 0x9a, 0x42, 0x69, 0xd4, 0xc5, 0x28, 0x35,
	0x78, 0xf0, 0x9a, 0x63, 0x85, 0xe2, 0x66, 0x23, 0x92, 0x7d, 0x37, 0xca, 0xc0, 0x24, 0xed, 0xb6,
	0xc2, 0xd2, 0x4c, 0xf1, 0xed, 0xef, 0xd9, 0x48, 0x82, 0x53, 0x46, 0xd7, 0xf7, 0x89, 0xc3, 0x24,
	0xe0, 0xb2, 0xfb, 0x26, 0x5a, 0x86, 0x19, 0x93, 0x6c, 0xe0, 0xae, 0xcd, 0x74, 0x7e, 0x63, 0xa4,
	0x64, 0x4e, 0x28, 0x24, 0x17, 0xae, 0x1c, 0x50, 0xc2, 0xb1, 0xd2, 0x7d, 0xdb, 0x6d, 0x61, 0xbb,
	0xe9, 0x11, 0x83, 0x8b, 0x98, 0x8e, 0x32, 0x1f, 0x05, 0x20, 0x7a, 0x1f, 0xd2, 0x5c, 0xaf, 0x1e,
	0xe8, 0x0d, 0x6b, 0x3c, 0xc3, 0x77, 0x75, 0xee, 0x00, 0x57, 0x70, 0xc2, 0x3c, 0x7f, 0xa6, 0xdb,
	0xbf, 0x4b, 0xbc, 0xc8, 0x1a, 0xcc, 0x32, 0xdf, 0x3a, 0x50, 0x98, 0xd4, 0xbf, 0x2c, 0x4c, 0x9a,
	0x53, 0x0c, 0x94, 0x65, 0x1d, 0xd2, 0xcc, 0xc7, 0x0e, 0xb5, 0x82, 0x4b, 0xa0, 0x6f, 0xd8, 0xee,
	0xb6, 0x94, 0xe6, 0x5b, 0xbc, 0x3d, 0x9a, 0x73, 0xef, 0x8e, 0x6b, 0x7b, 0x99, 0x4b, 0xb6, 0xbb,
	0xad, 0xa6, 0xd8, 0x90, 0x8d, 0xfe, 0x07, 0xe3, 0x94, 0x61, 0x46, 0x24, 0x91, 0xab, 0xbc, 0x72,
	0x8c, 0x4a, 0x1b, 0x3b, 0xcd, 0x20, 0x54, 0x0d, 0x33, 0x82, 0x6e, 0x18, 0xdc, 0xac, 0x74, 0x85,
	0x5f, 0x94, 0xe4, 0x80, 0x7a, 0x44, 0xe0, 0x9c, 0xe5, 0x18, 0x76, 0xd7, 0x24, 0xa6, 0x8e, 0x83,
	0x26, 0xd3, 0x69, 0xd8, 0x65, 0x54, 0xba, 0x9a, 0x4b, 0x14, 0x92, 0x0b, 0xc5, 0xd1, 0xeb, 0x1d,
	0xd1, 0x94, 0xea, 0x99, 0x3e, 0xdb, 0x20, 0x48, 0x91, 0x01, 0x67, 0xb1, 0x6d, 0xbb, 0xdb, 0x87,
	0x57, 0xb9, 0xf6, 0x2e, 0xab, 0xcc, 0x45, 0x64, 0x43, 0x8b, 0x3c, 0x18, 0x9b, 0x9c, 0x14, 0xa7,
	0x1e, 0x8c, 0x4d, 0x4e, 0x8b, 0x33, 0xf9, 0xbf, 0x05, 0x38, 0x37, 0xa2, 0xc2, 0x68, 0x09, 0x26,
	0x3a, 0x84, 0x6d, 0xba, 0x26, 0x6f, 0xf9, 0xd4, 0x42, 0xe9, 0xf8, 0x92, 0xee, 0x67, 0xaf, 0xf2,
	0x2c, 0x35, 0xca, 0x46, 0x1f, 0x43, 0xda, 0x27, 0x4f, 0xbb, 0x96, 0x4f, 0x4c, 0x7d, 0xc3, 0x22,
	0xb6, 0x49, 0xa5, 0x78, 0x2e, 0x51, 0x48, 0x2d, 0xdc, 0x3d, 0x29, 0xa1, 0x1a, 0xa5, 0x2f, 0x05,
	0xd9, 0x6a, 0xca, 0x1f, 0x34, 0x29, 0xba, 0x07, 0x52, 0xe4, 0xa1, 0x7a, 0x07, 0x3b, 0x5d, 0x6c,
	0xeb, 0xd8, 0xf3, 0x7c, 0x77, 0x0b, 0xdb, 0x7c, 0xf6, 0x4c, 0xaa, 0x67, 0xfb, 0xf8, 0x2a, 0x87,
	0xcb, 0x11, 0x9a, 0x27, 0x30, 0xb3, 0xe2, 0x1a, 0xd8, 0xb6, 0x3e, 0x23, 0x66, 0xb0, 0x22, 0x3a,
	0x0b, 0x13, 0x76, 0xe0, 0xe8, 0x4f, 0xb9, 0xc8, 0x42, 0xef, 0xc1, 0x78, 0x20, 0x2b, 0x14, 0x9e,
	0x5c, 0xb8, 0x7e, 0xbc, 0xf0, 0xfe, 0xc8, 0x54, 0xc3, 0xa4, 0xfc, 0x47, 0x87, 0xa6, 0x35, 0xf5,
	0xd0, 0x32, 0x24, 0xf7, 0x5b, 0xb4, 0x4f, 0x7c, 0x63, 0x34, 0xf1, 0x90, 0x50, 0x15, 0xf6, 0xda,
	0x95, 0xce, 0x7f, 0x2d, 0xc0, 0xdc, 0x51, 0x07, 0x80, 0x2e, 0xc3, 0x25, 0x4d, 0x2d, 0xd7, 0x9a,
	0x55, 0xad, 0x5a, 0xaf, 0xe9, 0xab, 0x8a, 0xb6, 0x5c, 0xaf, 0xe8, 0x6b, 0xb5, 0x66, 0x43, 0x59,
	0xac, 0x2e, 0x55, 0x95, 0x8a, 0x18, 0x43, 0x97, 0xe0, 0xfc, 0xe1, 0x90, 0xe6, 0x5a, 0xa3, 0x51,
	0x57, 0x35, 0x51, 0x40, 0x17, 0x41, 0x3a, 0x0c, 0x3f, 0xae, 0xae, 0x97, 0xd5, 0x8a, 0x18, 0x47,
	0x59, 0xc8, 0x1c, 0x46, 0x55, 0x65, 0x51, 0x55, 0xca, 0x9a, 0x22, 0x26, 0xe6, 0x7f, 0x14, 0xe0,
	0xc2, 0x31, 0x07, 0x89, 0x6e, 0xc2, 0xb5, 0x81, 0x7c, 0x55, 0x79, 0xb4, 0x56, 0x55, 0x95, 0x8a,
	0xbe, 0x54, 0x55, 0x56, 0x0e, 0xea, 0xbc, 0x05, 0x37, 0x46, 0x87, 0x36, 0xca, 0x4f, 0x56, 0x95,
	0x9a, 0xa6, 0x6b, 0xf5, 0x87, 0x4a, 0x4d, 0x14, 0xd0, 0x55, 0xc8, 0x8d, 0x0e, 0xae, 0xd4, 0x57,
	0xcb, 0xd5, 0x9a, 0x18, 0x47, 0xd7, 0x21, 0x3f, 0x3a, 0x6a, 0xb1, 0x5e, 0xd3, 0xca, 0x8b, 0x5a,
	0x53, 0x4c, 0xcc, 0x3f, 0x82, 0xa9, 0xbd, 0x89, 0x81, 0xce, 0xc0, 0x6c, 0x53, 0x2b, 0x6b, 0xca,
	0x01, 0x79, 0x69, 0x48, 0x86, 0x6e, 0x55, 0x29, 0x57, 0x9e, 0x84, 0x85, 0x0b, 0x1d, 0x03, 0x4b,
	0x34, 0x94, 0x5a, 0xa5, 0x5a, 0xbb, 0x2f, 0xc6, 0xe7, 0x37, 0x21, 0x35, 0x3c, 0x2a, 0x11, 0x82,
	0x54, 0x43, 0x51, 0xab, 0xfc, 0x7c, 0x1e, 0xd6, 0xea, 0x8f, 0x6b, 0x62, 0x0c, 0xa5, 0x00, 0x22,
	0x5f, 0xa5, 0x1c, 0x70, 0xa6, 0x21, 0x19, 0xd9, 0x8f, 0x15, 0xe5, 0xa1, 0x18, 0x47, 0x22, 0x4c,
	0x47, 0x8e, 0xd5, 0x7a, 0x4d, 0x5b, 0x16, 0x13, 0x03, 0x21, 0x4f, 0x94, 0xb2, 0x2a, 0x8e, 0x2d,
	0x7c, 0x33, 0x06, 0x53, 0x8b, 0xfc, 0xc9, 0x53, 0x6e, 0x54, 0xd1, 0xf7, 0x71, 0x48, 0x0d, 0xdf,
	0x44, 0x74, 0xeb, 0x98, 0x1b, 0x77, 0xf0, 0x85, 0x91, 0x39, 0x79, 0x30, 0xf5, 0xf2, 0x3f, 0x09,
	0xbd, 0x97, 0xd2, 0xe5, 0x8d, 0xbb, 0xcf, 0x8c, 0x62, 0xf4, 0x5f, 0xfe, 0x6f, 0x6e, 0x8b, 0xd0,
	0xa2, 0xe5, 0xf6, 0xed, 0xa2, 0x4f, 0xb0, 0xf9, 0xd7, 0x4b, 0xc9, 0x80, 0x1b, 0x11, 0x10, 0xf2,
	0x16, 0x39, 0x6f, 0x31, 0xe0, 0x2d, 0xda, 0x16, 0x65, 0xdc, 0xe4, 0x6d, 0x82, 0xee, 0x41, 0xa2,
	0x4d, 0x18, 0xba, 0x2d, 0x7b, 0xdd, 0x96, 0x6d, 0x19, 0x72, 0xf0, 0x0a, 0xa1, 0x1e, 0x36, 0x08,
	0x95, 0xe9, 0x0e, 0x65, 0xa4, 0x23, 0x0f, 0x34, 0x55, 0xff, 0xb1, 0x17, 0x70, 0x3c, 0xff, 0xed,
	0x8f, 0xaf, 0xe2, 0x77, 0xde, 0x21, 0x11, 0x7d, 0x27, 0x40, 0xea, 0x3e, 0x61, 0x8b, 0xe1, 0x4f,
	0x9a, 0x8f, 0x89, 0xb9, 0x03, 0x75, 0x50, 0x3a, 0x1e, 0xdb, 0xc9, 0x9c, 0xb4, 0x79, 0xf3, 0xeb,
	0x27, 0x2a, 0x0c, 0x57, 0x2c, 0xa3, 0xe2, 0x49, 0x15, 0x73, 0x79, 0x99, 0xc2, 0x0f, 0x2f, 0x84,
	0xc4, 0xaf, 0x2f, 0x84, 0xcc, 0x51, 0x5a, 0xea, 0xad, 0x4f, 0x88, 0xc1, 0x9e, 0xff, 0x22, 0xc5,
	0x37, 0x85, 0x0f, 0xbe, 0x10, 0x5e, 0xbd, 0xc9, 0xc6, 0x5e, 0xbf, 0xc9, 0xc6, 0xde, 0xbe, 0xc9,
	0x0a, 0x9f, 0xf7, 0xb2, 0xc2, 0xb7, 0xbd, 0xac, 0xf0, 0x73, 0x2f, 0x2b, 0xbc, 0xea, 0x65, 0x85,
	0xdf, 0x7b, 0x59, 0xe1, 0xcf, 0x5e, 0x36, 0xf6, 0xb6, 0x97, 0x15, 0xbe, 0xdc, 0xcd, 0xc6, 0x5e,
	0xed, 0x66, 0x63, 0xaf, 0x77, 0xb3, 0xb1, 0xf5, 0x5a, 0xdb, 0xf5, 0x3e, 0x6d, 0x97, 0xb6, 0x5c,
	0x9b, 0x11, 0xdf, 0x0f, 0x98, 0x65, 0xfe, 0xb1, 0xe1, 0xfa, 0x9d, 0x62, 0x30, 0x57, 0x2d, 0x93,
	0xf8, 0xc5, 0x3e, 0x2c, 0x7b, 0xad, 0xb6, 0x2b, 0x93, 0x67, 0x2c, 0x7a, 0xcd, 0x1e, 0x7a, 0x90,
	0xb7, 0x26, 0xf8, 0x8b, 0xf6, 0xce, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xa6, 0x7f, 0x29, 0x18,
	0xb3, 0x0b, 0x00, 0x00,
}

func (x PlanTransitionMethod) String() string {
	s, ok := PlanTransitionMethod_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PlanTransitionRequiredField) String() string {
	s, ok := PlanTransitionRequiredField_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PlanState) String() string {
	s, ok := PlanState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PeriodUnitType) String() string {
	s, ok := PeriodUnitType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *ListUsagePlansReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListUsagePlansReq)
	if !ok {
		that2, ok := that.(ListUsagePlansReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *AddonServiceDetails) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddonServiceDetails)
	if !ok {
		that2, ok := that.(AddonServiceDetails)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.DisplayName != that1.DisplayName {
		return false
	}
	return true
}
func (this *PlanInternal) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlanInternal)
	if !ok {
		that2, ok := that.(PlanInternal)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.TenantType != that1.TenantType {
		return false
	}
	if this.BillingDisabled != that1.BillingDisabled {
		return false
	}
	if this.FlatPrice != that1.FlatPrice {
		return false
	}
	if this.RenewalPeriodUnit != that1.RenewalPeriodUnit {
		return false
	}
	if this.Subtitle != that1.Subtitle {
		return false
	}
	if this.Current != that1.Current {
		return false
	}
	if !this.DefaultQuota.Equal(that1.DefaultQuota) {
		return false
	}
	if this.UsagePlanType != that1.UsagePlanType {
		return false
	}
	if this.TrialPeriodUnit != that1.TrialPeriodUnit {
		return false
	}
	if !this.TransitionFlow.Equal(that1.TransitionFlow) {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.TrialPeriod != that1.TrialPeriod {
		return false
	}
	if len(this.IncludedAddonServices) != len(that1.IncludedAddonServices) {
		return false
	}
	for i := range this.IncludedAddonServices {
		if !this.IncludedAddonServices[i].Equal(that1.IncludedAddonServices[i]) {
			return false
		}
	}
	if len(this.AllowedAddonServices) != len(that1.AllowedAddonServices) {
		return false
	}
	for i := range this.AllowedAddonServices {
		if !this.AllowedAddonServices[i].Equal(that1.AllowedAddonServices[i]) {
			return false
		}
	}
	return true
}
func (this *UsagePlanTransitionFlow) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UsagePlanTransitionFlow)
	if !ok {
		that2, ok := that.(UsagePlanTransitionFlow)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Method != that1.Method {
		return false
	}
	if len(this.RequiredFields) != len(that1.RequiredFields) {
		return false
	}
	for i := range this.RequiredFields {
		if this.RequiredFields[i] != that1.RequiredFields[i] {
			return false
		}
	}
	if this.RequiresManualApproval != that1.RequiresManualApproval {
		return false
	}
	return true
}
func (this *LocalizedPlan) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LocalizedPlan)
	if !ok {
		that2, ok := that.(LocalizedPlan)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Locale != that1.Locale {
		return false
	}
	if len(this.Plans) != len(that1.Plans) {
		return false
	}
	for i := range this.Plans {
		if !this.Plans[i].Equal(that1.Plans[i]) {
			return false
		}
	}
	return true
}
func (this *ListUsagePlansRsp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListUsagePlansRsp)
	if !ok {
		that2, ok := that.(ListUsagePlansRsp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.UsagePlans) != len(that1.UsagePlans) {
		return false
	}
	for i := range this.UsagePlans {
		if !this.UsagePlans[i].Equal(that1.UsagePlans[i]) {
			return false
		}
	}
	return true
}
func (this *ListUsagePlansReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&plan.ListUsagePlansReq{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AddonServiceDetails) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&plan.AddonServiceDetails{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "DisplayName: "+fmt.Sprintf("%#v", this.DisplayName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PlanInternal) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 21)
	s = append(s, "&plan.PlanInternal{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Title: "+fmt.Sprintf("%#v", this.Title)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "TenantType: "+fmt.Sprintf("%#v", this.TenantType)+",\n")
	s = append(s, "BillingDisabled: "+fmt.Sprintf("%#v", this.BillingDisabled)+",\n")
	s = append(s, "FlatPrice: "+fmt.Sprintf("%#v", this.FlatPrice)+",\n")
	s = append(s, "RenewalPeriodUnit: "+fmt.Sprintf("%#v", this.RenewalPeriodUnit)+",\n")
	s = append(s, "Subtitle: "+fmt.Sprintf("%#v", this.Subtitle)+",\n")
	s = append(s, "Current: "+fmt.Sprintf("%#v", this.Current)+",\n")
	if this.DefaultQuota != nil {
		s = append(s, "DefaultQuota: "+fmt.Sprintf("%#v", this.DefaultQuota)+",\n")
	}
	s = append(s, "UsagePlanType: "+fmt.Sprintf("%#v", this.UsagePlanType)+",\n")
	s = append(s, "TrialPeriodUnit: "+fmt.Sprintf("%#v", this.TrialPeriodUnit)+",\n")
	if this.TransitionFlow != nil {
		s = append(s, "TransitionFlow: "+fmt.Sprintf("%#v", this.TransitionFlow)+",\n")
	}
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "TrialPeriod: "+fmt.Sprintf("%#v", this.TrialPeriod)+",\n")
	if this.IncludedAddonServices != nil {
		s = append(s, "IncludedAddonServices: "+fmt.Sprintf("%#v", this.IncludedAddonServices)+",\n")
	}
	if this.AllowedAddonServices != nil {
		s = append(s, "AllowedAddonServices: "+fmt.Sprintf("%#v", this.AllowedAddonServices)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UsagePlanTransitionFlow) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&plan.UsagePlanTransitionFlow{")
	s = append(s, "Method: "+fmt.Sprintf("%#v", this.Method)+",\n")
	s = append(s, "RequiredFields: "+fmt.Sprintf("%#v", this.RequiredFields)+",\n")
	s = append(s, "RequiresManualApproval: "+fmt.Sprintf("%#v", this.RequiresManualApproval)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LocalizedPlan) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&plan.LocalizedPlan{")
	s = append(s, "Locale: "+fmt.Sprintf("%#v", this.Locale)+",\n")
	if this.Plans != nil {
		s = append(s, "Plans: "+fmt.Sprintf("%#v", this.Plans)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListUsagePlansRsp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&plan.ListUsagePlansRsp{")
	if this.UsagePlans != nil {
		s = append(s, "UsagePlans: "+fmt.Sprintf("%#v", this.UsagePlans)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringCustomApi(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CustomAPIClient is the client API for CustomAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CustomAPIClient interface {
	// List Usage Plans
	//
	// x-displayName: "List Usage Plans"
	// Endpoint to get usage plans
	ListUsagePlans(ctx context.Context, in *ListUsagePlansReq, opts ...grpc.CallOption) (*ListUsagePlansRsp, error)
	// Get current usage plan
	//
	// x-displayName: "Get current usage plan"
	// Endpoint to get current usage plan
	GetCurrentPlan(ctx context.Context, in *schema.Empty, opts ...grpc.CallOption) (*LocalizedPlan, error)
}

type customAPIClient struct {
	cc *grpc.ClientConn
}

func NewCustomAPIClient(cc *grpc.ClientConn) CustomAPIClient {
	return &customAPIClient{cc}
}

func (c *customAPIClient) ListUsagePlans(ctx context.Context, in *ListUsagePlansReq, opts ...grpc.CallOption) (*ListUsagePlansRsp, error) {
	out := new(ListUsagePlansRsp)
	err := c.cc.Invoke(ctx, "/ves.io.schema.usage.plan.CustomAPI/ListUsagePlans", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAPIClient) GetCurrentPlan(ctx context.Context, in *schema.Empty, opts ...grpc.CallOption) (*LocalizedPlan, error) {
	out := new(LocalizedPlan)
	err := c.cc.Invoke(ctx, "/ves.io.schema.usage.plan.CustomAPI/GetCurrentPlan", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CustomAPIServer is the server API for CustomAPI service.
type CustomAPIServer interface {
	// List Usage Plans
	//
	// x-displayName: "List Usage Plans"
	// Endpoint to get usage plans
	ListUsagePlans(context.Context, *ListUsagePlansReq) (*ListUsagePlansRsp, error)
	// Get current usage plan
	//
	// x-displayName: "Get current usage plan"
	// Endpoint to get current usage plan
	GetCurrentPlan(context.Context, *schema.Empty) (*LocalizedPlan, error)
}

// UnimplementedCustomAPIServer can be embedded to have forward compatible implementations.
type UnimplementedCustomAPIServer struct {
}

func (*UnimplementedCustomAPIServer) ListUsagePlans(ctx context.Context, req *ListUsagePlansReq) (*ListUsagePlansRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUsagePlans not implemented")
}
func (*UnimplementedCustomAPIServer) GetCurrentPlan(ctx context.Context, req *schema.Empty) (*LocalizedPlan, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrentPlan not implemented")
}

func RegisterCustomAPIServer(s *grpc.Server, srv CustomAPIServer) {
	s.RegisterService(&_CustomAPI_serviceDesc, srv)
}

func _CustomAPI_ListUsagePlans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUsagePlansReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).ListUsagePlans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.usage.plan.CustomAPI/ListUsagePlans",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).ListUsagePlans(ctx, req.(*ListUsagePlansReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAPI_GetCurrentPlan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(schema.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAPIServer).GetCurrentPlan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.usage.plan.CustomAPI/GetCurrentPlan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAPIServer).GetCurrentPlan(ctx, req.(*schema.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _CustomAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ves.io.schema.usage.plan.CustomAPI",
	HandlerType: (*CustomAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListUsagePlans",
			Handler:    _CustomAPI_ListUsagePlans_Handler,
		},
		{
			MethodName: "GetCurrentPlan",
			Handler:    _CustomAPI_GetCurrentPlan_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ves.io/schema/usage/plan/custom_api.proto",
}

func (m *ListUsagePlansReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUsagePlansReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListUsagePlansReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *AddonServiceDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddonServiceDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddonServiceDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintCustomApi(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCustomApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PlanInternal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlanInternal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlanInternal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AllowedAddonServices) > 0 {
		for iNdEx := len(m.AllowedAddonServices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AllowedAddonServices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCustomApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.IncludedAddonServices) > 0 {
		for iNdEx := len(m.IncludedAddonServices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IncludedAddonServices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCustomApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.TrialPeriod != 0 {
		i = encodeVarintCustomApi(dAtA, i, uint64(m.TrialPeriod))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.State != 0 {
		i = encodeVarintCustomApi(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.TransitionFlow != nil {
		{
			size, err := m.TransitionFlow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCustomApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.TrialPeriodUnit != 0 {
		i = encodeVarintCustomApi(dAtA, i, uint64(m.TrialPeriodUnit))
		i--
		dAtA[i] = 0x70
	}
	if m.UsagePlanType != 0 {
		i = encodeVarintCustomApi(dAtA, i, uint64(m.UsagePlanType))
		i--
		dAtA[i] = 0x68
	}
	if m.DefaultQuota != nil {
		{
			size, err := m.DefaultQuota.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCustomApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Current {
		i--
		if m.Current {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.Subtitle) > 0 {
		i -= len(m.Subtitle)
		copy(dAtA[i:], m.Subtitle)
		i = encodeVarintCustomApi(dAtA, i, uint64(len(m.Subtitle)))
		i--
		dAtA[i] = 0x4a
	}
	if m.RenewalPeriodUnit != 0 {
		i = encodeVarintCustomApi(dAtA, i, uint64(m.RenewalPeriodUnit))
		i--
		dAtA[i] = 0x38
	}
	if m.FlatPrice != 0 {
		i = encodeVarintCustomApi(dAtA, i, uint64(m.FlatPrice))
		i--
		dAtA[i] = 0x30
	}
	if m.BillingDisabled {
		i--
		if m.BillingDisabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.TenantType != 0 {
		i = encodeVarintCustomApi(dAtA, i, uint64(m.TenantType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintCustomApi(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintCustomApi(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCustomApi(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UsagePlanTransitionFlow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsagePlanTransitionFlow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsagePlanTransitionFlow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequiresManualApproval {
		i--
		if m.RequiresManualApproval {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.RequiredFields) > 0 {
		dAtA4 := make([]byte, len(m.RequiredFields)*10)
		var j3 int
		for _, num := range m.RequiredFields {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintCustomApi(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x12
	}
	if m.Method != 0 {
		i = encodeVarintCustomApi(dAtA, i, uint64(m.Method))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LocalizedPlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalizedPlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalizedPlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Plans) > 0 {
		for iNdEx := len(m.Plans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Plans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCustomApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Locale) > 0 {
		i -= len(m.Locale)
		copy(dAtA[i:], m.Locale)
		i = encodeVarintCustomApi(dAtA, i, uint64(len(m.Locale)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListUsagePlansRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUsagePlansRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListUsagePlansRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UsagePlans) > 0 {
		for iNdEx := len(m.UsagePlans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UsagePlans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCustomApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintCustomApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovCustomApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ListUsagePlansReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *AddonServiceDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCustomApi(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovCustomApi(uint64(l))
	}
	return n
}

func (m *PlanInternal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCustomApi(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovCustomApi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovCustomApi(uint64(l))
	}
	if m.TenantType != 0 {
		n += 1 + sovCustomApi(uint64(m.TenantType))
	}
	if m.BillingDisabled {
		n += 2
	}
	if m.FlatPrice != 0 {
		n += 1 + sovCustomApi(uint64(m.FlatPrice))
	}
	if m.RenewalPeriodUnit != 0 {
		n += 1 + sovCustomApi(uint64(m.RenewalPeriodUnit))
	}
	l = len(m.Subtitle)
	if l > 0 {
		n += 1 + l + sovCustomApi(uint64(l))
	}
	if m.Current {
		n += 2
	}
	if m.DefaultQuota != nil {
		l = m.DefaultQuota.Size()
		n += 1 + l + sovCustomApi(uint64(l))
	}
	if m.UsagePlanType != 0 {
		n += 1 + sovCustomApi(uint64(m.UsagePlanType))
	}
	if m.TrialPeriodUnit != 0 {
		n += 1 + sovCustomApi(uint64(m.TrialPeriodUnit))
	}
	if m.TransitionFlow != nil {
		l = m.TransitionFlow.Size()
		n += 1 + l + sovCustomApi(uint64(l))
	}
	if m.State != 0 {
		n += 2 + sovCustomApi(uint64(m.State))
	}
	if m.TrialPeriod != 0 {
		n += 2 + sovCustomApi(uint64(m.TrialPeriod))
	}
	if len(m.IncludedAddonServices) > 0 {
		for _, e := range m.IncludedAddonServices {
			l = e.Size()
			n += 2 + l + sovCustomApi(uint64(l))
		}
	}
	if len(m.AllowedAddonServices) > 0 {
		for _, e := range m.AllowedAddonServices {
			l = e.Size()
			n += 2 + l + sovCustomApi(uint64(l))
		}
	}
	return n
}

func (m *UsagePlanTransitionFlow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Method != 0 {
		n += 1 + sovCustomApi(uint64(m.Method))
	}
	if len(m.RequiredFields) > 0 {
		l = 0
		for _, e := range m.RequiredFields {
			l += sovCustomApi(uint64(e))
		}
		n += 1 + sovCustomApi(uint64(l)) + l
	}
	if m.RequiresManualApproval {
		n += 2
	}
	return n
}

func (m *LocalizedPlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Locale)
	if l > 0 {
		n += 1 + l + sovCustomApi(uint64(l))
	}
	if len(m.Plans) > 0 {
		for _, e := range m.Plans {
			l = e.Size()
			n += 1 + l + sovCustomApi(uint64(l))
		}
	}
	return n
}

func (m *ListUsagePlansRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UsagePlans) > 0 {
		for _, e := range m.UsagePlans {
			l = e.Size()
			n += 1 + l + sovCustomApi(uint64(l))
		}
	}
	return n
}

func sovCustomApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCustomApi(x uint64) (n int) {
	return sovCustomApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ListUsagePlansReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListUsagePlansReq{`,
		`}`,
	}, "")
	return s
}
func (this *AddonServiceDetails) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AddonServiceDetails{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`DisplayName:` + fmt.Sprintf("%v", this.DisplayName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlanInternal) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForIncludedAddonServices := "[]*AddonServiceDetails{"
	for _, f := range this.IncludedAddonServices {
		repeatedStringForIncludedAddonServices += strings.Replace(f.String(), "AddonServiceDetails", "AddonServiceDetails", 1) + ","
	}
	repeatedStringForIncludedAddonServices += "}"
	repeatedStringForAllowedAddonServices := "[]*AddonServiceDetails{"
	for _, f := range this.AllowedAddonServices {
		repeatedStringForAllowedAddonServices += strings.Replace(f.String(), "AddonServiceDetails", "AddonServiceDetails", 1) + ","
	}
	repeatedStringForAllowedAddonServices += "}"
	s := strings.Join([]string{`&PlanInternal{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Title:` + fmt.Sprintf("%v", this.Title) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`TenantType:` + fmt.Sprintf("%v", this.TenantType) + `,`,
		`BillingDisabled:` + fmt.Sprintf("%v", this.BillingDisabled) + `,`,
		`FlatPrice:` + fmt.Sprintf("%v", this.FlatPrice) + `,`,
		`RenewalPeriodUnit:` + fmt.Sprintf("%v", this.RenewalPeriodUnit) + `,`,
		`Subtitle:` + fmt.Sprintf("%v", this.Subtitle) + `,`,
		`Current:` + fmt.Sprintf("%v", this.Current) + `,`,
		`DefaultQuota:` + strings.Replace(fmt.Sprintf("%v", this.DefaultQuota), "GlobalSpecType", "quota.GlobalSpecType", 1) + `,`,
		`UsagePlanType:` + fmt.Sprintf("%v", this.UsagePlanType) + `,`,
		`TrialPeriodUnit:` + fmt.Sprintf("%v", this.TrialPeriodUnit) + `,`,
		`TransitionFlow:` + strings.Replace(this.TransitionFlow.String(), "UsagePlanTransitionFlow", "UsagePlanTransitionFlow", 1) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`TrialPeriod:` + fmt.Sprintf("%v", this.TrialPeriod) + `,`,
		`IncludedAddonServices:` + repeatedStringForIncludedAddonServices + `,`,
		`AllowedAddonServices:` + repeatedStringForAllowedAddonServices + `,`,
		`}`,
	}, "")
	return s
}
func (this *UsagePlanTransitionFlow) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UsagePlanTransitionFlow{`,
		`Method:` + fmt.Sprintf("%v", this.Method) + `,`,
		`RequiredFields:` + fmt.Sprintf("%v", this.RequiredFields) + `,`,
		`RequiresManualApproval:` + fmt.Sprintf("%v", this.RequiresManualApproval) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LocalizedPlan) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPlans := "[]*PlanInternal{"
	for _, f := range this.Plans {
		repeatedStringForPlans += strings.Replace(f.String(), "PlanInternal", "PlanInternal", 1) + ","
	}
	repeatedStringForPlans += "}"
	s := strings.Join([]string{`&LocalizedPlan{`,
		`Locale:` + fmt.Sprintf("%v", this.Locale) + `,`,
		`Plans:` + repeatedStringForPlans + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListUsagePlansRsp) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForUsagePlans := "[]*LocalizedPlan{"
	for _, f := range this.UsagePlans {
		repeatedStringForUsagePlans += strings.Replace(f.String(), "LocalizedPlan", "LocalizedPlan", 1) + ","
	}
	repeatedStringForUsagePlans += "}"
	s := strings.Join([]string{`&ListUsagePlansRsp{`,
		`UsagePlans:` + repeatedStringForUsagePlans + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringCustomApi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ListUsagePlansReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCustomApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUsagePlansReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUsagePlansReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCustomApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCustomApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCustomApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddonServiceDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCustomApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddonServiceDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddonServiceDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCustomApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCustomApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCustomApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlanInternal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCustomApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlanInternal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlanInternal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantType", wireType)
			}
			m.TenantType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantType |= schema.TenantType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BillingDisabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BillingDisabled = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlatPrice", wireType)
			}
			m.FlatPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlatPrice |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RenewalPeriodUnit", wireType)
			}
			m.RenewalPeriodUnit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RenewalPeriodUnit |= PeriodUnitType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subtitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subtitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Current = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultQuota", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCustomApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCustomApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultQuota == nil {
				m.DefaultQuota = &quota.GlobalSpecType{}
			}
			if err := m.DefaultQuota.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsagePlanType", wireType)
			}
			m.UsagePlanType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsagePlanType |= schema.PlanType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrialPeriodUnit", wireType)
			}
			m.TrialPeriodUnit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrialPeriodUnit |= PeriodUnitType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransitionFlow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCustomApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCustomApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransitionFlow == nil {
				m.TransitionFlow = &UsagePlanTransitionFlow{}
			}
			if err := m.TransitionFlow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= PlanState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrialPeriod", wireType)
			}
			m.TrialPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrialPeriod |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludedAddonServices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCustomApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCustomApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IncludedAddonServices = append(m.IncludedAddonServices, &AddonServiceDetails{})
			if err := m.IncludedAddonServices[len(m.IncludedAddonServices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedAddonServices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCustomApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCustomApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedAddonServices = append(m.AllowedAddonServices, &AddonServiceDetails{})
			if err := m.AllowedAddonServices[len(m.AllowedAddonServices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCustomApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCustomApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCustomApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsagePlanTransitionFlow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCustomApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UsagePlanTransitionFlow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UsagePlanTransitionFlow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			m.Method = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Method |= PlanTransitionMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v PlanTransitionRequiredField
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCustomApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= PlanTransitionRequiredField(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RequiredFields = append(m.RequiredFields, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCustomApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCustomApi
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCustomApi
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.RequiredFields) == 0 {
					m.RequiredFields = make([]PlanTransitionRequiredField, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v PlanTransitionRequiredField
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCustomApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= PlanTransitionRequiredField(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RequiredFields = append(m.RequiredFields, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredFields", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiresManualApproval", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequiresManualApproval = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCustomApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCustomApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCustomApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalizedPlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCustomApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalizedPlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalizedPlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locale", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locale = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Plans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCustomApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCustomApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Plans = append(m.Plans, &PlanInternal{})
			if err := m.Plans[len(m.Plans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCustomApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCustomApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCustomApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUsagePlansRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCustomApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUsagePlansRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUsagePlansRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsagePlans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCustomApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCustomApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsagePlans = append(m.UsagePlans, &LocalizedPlan{})
			if err := m.UsagePlans[len(m.UsagePlans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCustomApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCustomApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCustomApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCustomApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCustomApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCustomApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCustomApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCustomApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCustomApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCustomApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCustomApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCustomApi = fmt.Errorf("proto: unexpected end of group")
)
