// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package plan

import (
	"bytes"
	"context"
	"fmt"
	io "io"
	"net/http"
	"strings"

	"github.com/gogo/protobuf/proto"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"google.golang.org/grpc"

	"gopkg.volterra.us/stdlib/client"
	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/errors"
	"gopkg.volterra.us/stdlib/server"
	"gopkg.volterra.us/stdlib/svcfw"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
)

var (
	_ = fmt.Sprintf("dummy for fmt import use")
)

// Create CustomAPI GRPC Client satisfying server.CustomClient
type CustomAPIGrpcClient struct {
	conn       *grpc.ClientConn
	grpcClient CustomAPIClient
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error)
}

func (c *CustomAPIGrpcClient) doRPCGetCurrentPlan(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &ves_io_schema.Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.Empty", yamlReq)
	}
	rsp, err := c.grpcClient.GetCurrentPlan(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) doRPCListUsagePlans(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &ListUsagePlansReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.usage.plan.ListUsagePlansReq", yamlReq)
	}
	rsp, err := c.grpcClient.ListUsagePlans(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAPIGrpcClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	if cco.YAMLReq == "" {
		return nil, fmt.Errorf("Error, empty request body")
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := rpcFn(ctx, cco.YAMLReq, cco.GrpcCallOpts...)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using GRPC")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func NewCustomAPIGrpcClient(cc *grpc.ClientConn) server.CustomClient {
	ccl := &CustomAPIGrpcClient{
		conn:       cc,
		grpcClient: NewCustomAPIClient(cc),
	}
	rpcFns := make(map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error))
	rpcFns["GetCurrentPlan"] = ccl.doRPCGetCurrentPlan

	rpcFns["ListUsagePlans"] = ccl.doRPCListUsagePlans

	ccl.rpcFns = rpcFns

	return ccl
}

// Create CustomAPI REST Client satisfying server.CustomClient
type CustomAPIRestClient struct {
	baseURL string
	client  http.Client
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error)
}

func (c *CustomAPIRestClient) doRPCGetCurrentPlan(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &ves_io_schema.Empty{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.Empty: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &LocalizedPlan{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.usage.plan.LocalizedPlan", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) doRPCListUsagePlans(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &ListUsagePlansReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.usage.plan.ListUsagePlansReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &ListUsagePlansRsp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.usage.plan.ListUsagePlansRsp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAPIRestClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	rsp, err := rpcFn(ctx, cco)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using Rest")
	}
	return rsp, nil
}

func NewCustomAPIRestClient(baseURL string, hc http.Client) server.CustomClient {
	ccl := &CustomAPIRestClient{
		baseURL: baseURL,
		client:  hc,
	}

	rpcFns := make(map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error))
	rpcFns["GetCurrentPlan"] = ccl.doRPCGetCurrentPlan

	rpcFns["ListUsagePlans"] = ccl.doRPCListUsagePlans

	ccl.rpcFns = rpcFns

	return ccl
}

// Create customAPIInprocClient

// INPROC Client (satisfying CustomAPIClient interface)
type customAPIInprocClient struct {
	CustomAPIServer
}

func (c *customAPIInprocClient) GetCurrentPlan(ctx context.Context, in *ves_io_schema.Empty, opts ...grpc.CallOption) (*LocalizedPlan, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.usage.plan.CustomAPI.GetCurrentPlan")
	return c.CustomAPIServer.GetCurrentPlan(ctx, in)
}
func (c *customAPIInprocClient) ListUsagePlans(ctx context.Context, in *ListUsagePlansReq, opts ...grpc.CallOption) (*ListUsagePlansRsp, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.usage.plan.CustomAPI.ListUsagePlans")
	return c.CustomAPIServer.ListUsagePlans(ctx, in)
}

func NewCustomAPIInprocClient(svc svcfw.Service) CustomAPIClient {
	return &customAPIInprocClient{CustomAPIServer: NewCustomAPIServer(svc)}
}

// RegisterGwCustomAPIHandler registers with grpc-gw with an inproc-client backing so that
// rest to grpc happens without a grpc.Dial (thus avoiding additional certs for mTLS)
func RegisterGwCustomAPIHandler(ctx context.Context, mux *runtime.ServeMux, svc interface{}) error {
	s, ok := svc.(svcfw.Service)
	if !ok {
		return fmt.Errorf("svc is not svcfw.Service")
	}
	return RegisterCustomAPIHandlerClient(ctx, mux, NewCustomAPIInprocClient(s))
}

// Create customAPISrv

// SERVER (satisfying CustomAPIServer interface)
type customAPISrv struct {
	svc svcfw.Service
}

func (s *customAPISrv) GetCurrentPlan(ctx context.Context, in *ves_io_schema.Empty) (*LocalizedPlan, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.usage.plan.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *LocalizedPlan
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.Empty", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.GetCurrentPlan' operation on 'plan'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.usage.plan.CustomAPI.GetCurrentPlan"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.GetCurrentPlan(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.usage.plan.LocalizedPlan", rsp)...)

	return rsp, nil
}
func (s *customAPISrv) ListUsagePlans(ctx context.Context, in *ListUsagePlansReq) (*ListUsagePlansRsp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.usage.plan.CustomAPI")
	cah, ok := ah.(CustomAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAPIServer", ah)
	}

	var (
		rsp *ListUsagePlansRsp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.usage.plan.ListUsagePlansReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAPI.ListUsagePlans' operation on 'plan'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.usage.plan.CustomAPI.ListUsagePlans"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.ListUsagePlans(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.usage.plan.ListUsagePlansRsp", rsp)...)

	return rsp, nil
}

func NewCustomAPIServer(svc svcfw.Service) CustomAPIServer {
	return &customAPISrv{svc: svc}
}

var CustomAPISwaggerJSON string = `{
    "swagger": "2.0",
    "info": {
        "title": "Usage plan related Customer APIs",
        "description": "Usage plan related RPCs. Used for billing and onboarding.",
        "version": "version not set"
    },
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "tags": [],
    "paths": {
        "/public/namespaces/system/usage_plans/current": {
            "get": {
                "summary": "Get current usage plan",
                "description": "Endpoint to get current usage plan",
                "operationId": "ves.io.schema.usage.plan.CustomAPI.GetCurrentPlan",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/planLocalizedPlan"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-usage-plan-customapi-getcurrentplan"
                },
                "x-ves-proto-rpc": "ves.io.schema.usage.plan.CustomAPI.GetCurrentPlan"
            },
            "x-displayname": "Usage plans",
            "x-ves-proto-service": "ves.io.schema.usage.plan.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/system/usage_plans/custom_list": {
            "get": {
                "summary": "List Usage Plans",
                "description": "Endpoint to get usage plans",
                "operationId": "ves.io.schema.usage.plan.CustomAPI.ListUsagePlans",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/planListUsagePlansRsp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "tags": [
                    "CustomAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-usage-plan-customapi-listusageplans"
                },
                "x-ves-proto-rpc": "ves.io.schema.usage.plan.CustomAPI.ListUsagePlans"
            },
            "x-displayname": "Usage plans",
            "x-ves-proto-service": "ves.io.schema.usage.plan.CustomAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        }
    },
    "definitions": {
        "planAddonServiceDetails": {
            "type": "object",
            "description": "Details about addon service",
            "title": "Addon Service Details",
            "x-displayname": "Addon Service Details",
            "x-ves-proto-message": "ves.io.schema.usage.plan.AddonServiceDetails",
            "properties": {
                "display_name": {
                    "type": "string",
                    "description": " Human readable name of addon\n\nExample: - \"Transfer from RE to CE\"-",
                    "title": "Display name",
                    "x-displayname": "Display name",
                    "x-ves-example": "Transfer from RE to CE"
                },
                "name": {
                    "type": "string",
                    "description": " Name of the addon feature\n\nExample: - \"re-2-ce-v1\"-",
                    "title": "Name",
                    "x-displayname": "Name",
                    "x-ves-example": "re-2-ce-v1"
                }
            }
        },
        "planListUsagePlansRsp": {
            "type": "object",
            "description": "Response with the usage plans info",
            "title": "Usage Plans Response",
            "x-displayname": "UsagePlansRsp",
            "x-ves-proto-message": "ves.io.schema.usage.plan.ListUsagePlansRsp",
            "properties": {
                "usage_plans": {
                    "type": "array",
                    "description": " Collection of available plans",
                    "title": "Usage plans",
                    "items": {
                        "$ref": "#/definitions/planLocalizedPlan"
                    },
                    "x-displayname": "Usage plans"
                }
            }
        },
        "planLocalizedPlan": {
            "type": "object",
            "description": "Localized info of usage plan",
            "title": "LocalizedUsagePlan",
            "x-displayname": "LocalizedUsagePlan",
            "x-ves-proto-message": "ves.io.schema.usage.plan.LocalizedPlan",
            "properties": {
                "locale": {
                    "type": "string",
                    "description": " Locale in the ISO dashed  format\n\nExample: - \"en-us\"-",
                    "title": "Locale",
                    "x-displayname": "Locale",
                    "x-ves-example": "en-us"
                },
                "plans": {
                    "type": "array",
                    "description": " Collection of currently publicly available plans.",
                    "title": "Plans",
                    "items": {
                        "$ref": "#/definitions/planPlanInternal"
                    },
                    "x-displayname": "Plans"
                }
            }
        },
        "planPeriodUnitType": {
            "type": "string",
            "description": "Temporal period type\n\n - PERIOD_UNKNOWN: unknown, undefined period of time\n - PERIOD_DAY: Day\n - PERIOD_WEEK: Week\n - PERIOD_MONTH: Month\n - PERIOD_YEAR: Year",
            "title": "Period type",
            "enum": [
                "PERIOD_UNKNOWN",
                "PERIOD_DAY",
                "PERIOD_WEEK",
                "PERIOD_MONTH",
                "PERIOD_YEAR"
            ],
            "default": "PERIOD_UNKNOWN",
            "x-displayname": "Period type",
            "x-ves-proto-enum": "ves.io.schema.usage.plan.PeriodUnitType"
        },
        "planPlanInternal": {
            "type": "object",
            "description": "Structure that holds all data needed to choose usage plan",
            "title": "PlanInternal",
            "x-displayname": "PlanInternal",
            "x-ves-proto-message": "ves.io.schema.usage.plan.PlanInternal",
            "properties": {
                "allowed_addon_services": {
                    "type": "array",
                    "description": " List of addon services that can be subscribed part of current plan.",
                    "items": {
                        "$ref": "#/definitions/planAddonServiceDetails"
                    },
                    "x-displayname": "Allowed Addon Services"
                },
                "billing_disabled": {
                    "type": "boolean",
                    "description": " If true then there's no automatic billing.",
                    "title": "Billing disabled",
                    "format": "boolean",
                    "x-displayname": "Billing disabled"
                },
                "current": {
                    "type": "boolean",
                    "description": " True if plan is active. Note that customers are only allowed to current plans.",
                    "title": "Current",
                    "format": "boolean",
                    "x-displayname": "Current"
                },
                "default_quota": {
                    "description": " Default quota associated with the plan.",
                    "title": "Default quota",
                    "$ref": "#/definitions/schemaquotaGlobalSpecType",
                    "x-displayname": "Default quota"
                },
                "description": {
                    "type": "string",
                    "description": " Description of the plan as mark-down text.\n\nExample: - \"###Free plan, includes x y z *Free item 1 *Free item 2 ##Self-support only\"-",
                    "title": "Description",
                    "x-displayname": "Description",
                    "x-ves-example": "###Free plan, includes x y z *Free item 1 *Free item 2 ##Self-support only"
                },
                "flat_price": {
                    "type": "integer",
                    "description": " Flat fee of the plan in cents\n\nExample: - \"100\"-",
                    "title": "Flat price",
                    "format": "int32",
                    "x-displayname": "Flat price",
                    "x-ves-example": "100"
                },
                "included_addon_services": {
                    "type": "array",
                    "description": " List of addon services that are available part of current plan.",
                    "items": {
                        "$ref": "#/definitions/planAddonServiceDetails"
                    },
                    "x-displayname": "Included Addon Services"
                },
                "name": {
                    "type": "string",
                    "description": " Name of the plan, the name is not guaranteed to be human readable.\n\nExample: - \"free-p25-v2\"-",
                    "title": "Name",
                    "x-displayname": "Name",
                    "x-ves-example": "free-p25-v2"
                },
                "renewal_period_unit": {
                    "description": " Renewal period unit of the plan",
                    "title": "Renewal Period",
                    "$ref": "#/definitions/planPeriodUnitType",
                    "x-displayname": "Renewal period"
                },
                "state": {
                    "description": " Transaction flow for customers wanting to migrate on this plan",
                    "title": "Transition flow",
                    "$ref": "#/definitions/planPlanState",
                    "x-displayname": "Transition flow"
                },
                "subtitle": {
                    "type": "string",
                    "description": " Optional second line of the title of the plan, human readable.\n\nExample: - \"Our free plan\"-",
                    "title": "Sub-Title",
                    "x-displayname": "Sub-title",
                    "x-ves-example": "Our free plan"
                },
                "tenant_type": {
                    "description": " The type of tenant the plan is intended for - if subscribed to this plan the tenant would of this tenant type.",
                    "title": "Tenant type",
                    "$ref": "#/definitions/schemaTenantType",
                    "x-displayname": "Tenant type"
                },
                "title": {
                    "type": "string",
                    "description": " Title of the plan, human readable.\n\nExample: - \"Free\"-",
                    "title": "Title",
                    "x-displayname": "Title",
                    "x-ves-example": "Free"
                },
                "transition_flow": {
                    "description": " Transaction flow for customers wanting to migrate on this plan",
                    "title": "Transition flow",
                    "$ref": "#/definitions/planUsagePlanTransitionFlow",
                    "x-displayname": "Transition flow"
                },
                "trial_period": {
                    "type": "integer",
                    "description": " Trial period associated with this plan. Different pricing conditions are in place during the trial period - flat fee my not apply, or similar\n\nExample: - \"3\"-",
                    "title": "Trial period",
                    "format": "int32",
                    "x-displayname": "Trial period",
                    "x-ves-example": "3"
                },
                "trial_period_unit": {
                    "description": " Trial period unit of the plan",
                    "title": "Trial period unit",
                    "$ref": "#/definitions/planPeriodUnitType",
                    "x-displayname": "Trial period unit"
                },
                "usage_plan_type": {
                    "description": " Usage plan type",
                    "title": "Usage plan type",
                    "$ref": "#/definitions/schemaPlanType",
                    "x-displayname": "Usage plan type"
                }
            }
        },
        "planPlanState": {
            "type": "string",
            "description": "State of the\n\n - STATE_UNSPECIFIED: zero value\n - STATE_READY: the plan is in default state\n - STATE_TRANSITION_PENDING: the plan is in the state of plan transitioning. If the plan has current flag equals to true and in\nTRANSITION_PENDING then tenant moves to another plan which is in state TRANSITION_PENDING.\nAt the same moment in time no more than 2 plans should have TRANSITION_PENDING state",
            "title": "PlanTransitionState",
            "enum": [
                "STATE_UNSPECIFIED",
                "STATE_READY",
                "STATE_TRANSITION_PENDING"
            ],
            "default": "STATE_UNSPECIFIED",
            "x-displayname": "PlanTransitionState",
            "x-ves-proto-enum": "ves.io.schema.usage.plan.PlanState"
        },
        "planPlanTransitionMethod": {
            "type": "string",
            "description": "Transitioning method which UI should show to the customer to properly execute the transition between\n\n - TRANSITION_METHOD_UNSPECIFIED: Zero value\n - TRANSITION_METHOD_SUPPORT: The transition should be done via a support request, the current behaviour for any transition\n - TRANSITION_METHOD_WIZARD: The transition should be done via a custom Wizard. Fields which should be\nprovided will be guided by PlanTransitionRequiredField\n - TRANSITION_METHOD_RECREATE: The transition should be done via logging the user out, deleting the current tenant and creating a new one",
            "title": "PlanTransitionMethod",
            "enum": [
                "TRANSITION_METHOD_UNSPECIFIED",
                "TRANSITION_METHOD_SUPPORT",
                "TRANSITION_METHOD_WIZARD",
                "TRANSITION_METHOD_RECREATE"
            ],
            "default": "TRANSITION_METHOD_UNSPECIFIED",
            "x-displayname": "PlanTransitionMethod",
            "x-ves-proto-enum": "ves.io.schema.usage.plan.PlanTransitionMethod"
        },
        "planPlanTransitionRequiredField": {
            "type": "string",
            "description": "fields which UI should provide to the backend to properly execute the transition between plans\n\n - TRANSITION_REQUIRED_FIELD_UNSPECIFIED: Zero value\n - TRANSITION_REQUIRED_FIELD_PAYMENT_TOKEN: Stripe token after user enters CC info and we submit it to stripe\n - TRANSITION_REQUIRED_FIELD_DOMAIN: Domain for team/organization plans which will be used for keycloak realm\n - TRANSITION_REQUIRED_FIELD_CONTACTS: Contacts is billing contacts",
            "title": "PlanTransitionRequiredField",
            "enum": [
                "TRANSITION_REQUIRED_FIELD_UNSPECIFIED",
                "TRANSITION_REQUIRED_FIELD_PAYMENT_TOKEN",
                "TRANSITION_REQUIRED_FIELD_DOMAIN",
                "TRANSITION_REQUIRED_FIELD_CONTACTS"
            ],
            "default": "TRANSITION_REQUIRED_FIELD_UNSPECIFIED",
            "x-displayname": "PlanTransitionRequiredField",
            "x-ves-proto-enum": "ves.io.schema.usage.plan.PlanTransitionRequiredField"
        },
        "planUsagePlanTransitionFlow": {
            "type": "object",
            "description": "Details for transition flow. Is used as part of UsagePlanInternal",
            "title": "UsagePlanTransitionFlow",
            "x-displayname": "UsagePlanTransitionFlow",
            "x-ves-proto-message": "ves.io.schema.usage.plan.UsagePlanTransitionFlow",
            "properties": {
                "method": {
                    "description": " Method to migrate onto this plan",
                    "title": "Method",
                    "$ref": "#/definitions/planPlanTransitionMethod",
                    "x-displayname": "Method"
                },
                "required_fields": {
                    "type": "array",
                    "description": " Mandatory information to migrate onto this plan",
                    "title": "Required fields",
                    "items": {
                        "$ref": "#/definitions/planPlanTransitionRequiredField"
                    },
                    "x-displayname": "Required fields"
                },
                "requires_manual_approval": {
                    "type": "boolean",
                    "description": " If true then any migration onto this plan must be approved by the billing department.",
                    "title": "Manual approval",
                    "format": "boolean",
                    "x-displayname": "Manual approval"
                }
            }
        },
        "quotaFloatLimitType": {
            "type": "object",
            "description": "x-displayName: \"Limit (float)\"\nFloatLimitType defines a float quota value that should not be exceeded. Useful for items that have\nquotas in fractions.",
            "title": "FloatLimitType",
            "properties": {
                "maximum": {
                    "type": "number",
                    "description": "x-displayName: \"Maximum\"\nx-example: \"100\"\nThe maximum value",
                    "title": "maximum",
                    "format": "double"
                }
            }
        },
        "quotaLimitType": {
            "type": "object",
            "description": "x-displayName: \"Limit\"\nLimitType defines a quota value for a specific object kind that should not be exceeded",
            "title": "LimitType",
            "properties": {
                "maximum": {
                    "type": "integer",
                    "description": "x-displayName: \"Maximum\"\nx-example: \"100\"\nThe maximum value for the object kind",
                    "title": "maximum",
                    "format": "int32"
                }
            }
        },
        "quotaRateLimitType": {
            "type": "object",
            "description": "x-displayName: \"Rate Limit\"\nRateLimitType defines a rate quota value for a specific object kind that should not be exceeded in terms access per time unit",
            "title": "RateLimitType",
            "properties": {
                "burst": {
                    "type": "integer",
                    "description": "x-displayName: \"Burst\"\nx-example: \"100\"\nThe burst which is to be allowed per quanta",
                    "title": "burst",
                    "format": "int32"
                },
                "rate": {
                    "type": "integer",
                    "description": "x-displayName: \"Rate\"\nx-example: \"100\"\nThe sustained rate which is to be allowed per quanta",
                    "title": "rate",
                    "format": "int32"
                },
                "unit": {
                    "type": "string",
                    "description": "x-displayName: \"Unit\"\nx-example: \"per-second\"\nThe unit for the quanta",
                    "title": "unit"
                }
            }
        },
        "rate_limiterInputHours": {
            "type": "object",
            "description": "x-displayName: \"Hours\"\nInput Duration Hours",
            "title": "Hours",
            "properties": {
                "duration": {
                    "type": "integer",
                    "description": "x-displayName: \"Duration\"",
                    "title": "Duration",
                    "format": "int64"
                }
            }
        },
        "rate_limiterInputMinutes": {
            "type": "object",
            "description": "x-displayName: \"Minutes\"\nInput Duration Minutes",
            "title": "Minutes",
            "properties": {
                "duration": {
                    "type": "integer",
                    "description": "x-displayName: \"Duration\"",
                    "title": "Duration",
                    "format": "int64"
                }
            }
        },
        "rate_limiterInputSeconds": {
            "type": "object",
            "description": "x-displayName: \"Seconds\"\nInput Duration Seconds",
            "title": "Seconds",
            "properties": {
                "duration": {
                    "type": "integer",
                    "description": "x-displayName: \"Duration\"",
                    "title": "Duration",
                    "format": "int64"
                }
            }
        },
        "rate_limiterLeakyBucketRateLimiter": {
            "type": "object",
            "description": "x-displayName: \"Leaky Bucket Rate Limiter\"\nLeaky-Bucket is the default rate limiter algorithm for F5",
            "title": "LeakyBucketRateLimiter"
        },
        "rate_limiterRateLimitBlockAction": {
            "type": "object",
            "description": "x-displayName: \"Rate Limit Block Action\"\nAction where a user is blocked from making further requests after exceeding rate limit threshold.",
            "title": "RateLimitBlockAction",
            "properties": {
                "hours": {
                    "description": "x-displayName: \"Hours\"\nUser block mitigation time in Hours",
                    "title": "Hours",
                    "$ref": "#/definitions/rate_limiterInputHours"
                },
                "minutes": {
                    "description": "x-displayName: \"Minutes\"\nUser block mitigation time in Minutes",
                    "title": "Minutes",
                    "$ref": "#/definitions/rate_limiterInputMinutes"
                },
                "seconds": {
                    "description": "x-displayName: \"Seconds\"\nUser block mitigation time in Seconds",
                    "title": "Seconds",
                    "$ref": "#/definitions/rate_limiterInputSeconds"
                }
            }
        },
        "rate_limiterRateLimitPeriodUnit": {
            "type": "string",
            "description": "x-displayName: \"Rate Limit Period Unit\"\nUnit for the period per which the rate limit is applied.\n\n - SECOND: Second\n\nx-displayName: \"Seconds\"\nRate limit period unit is seconds\n - MINUTE: Minute\n\nx-displayName: \"Minutes\"\nRate limit period unit is minutes\n - HOUR: Hour\n\nx-displayName: \"Hours\"\nRate limit period unit is hours\n - DAY: Day\n\nx-displayName: \"Days\"\nRate limit period unit is days",
            "title": "RateLimitPeriodUnit",
            "enum": [
                "SECOND",
                "MINUTE",
                "HOUR",
                "DAY"
            ],
            "default": "SECOND"
        },
        "rate_limiterRateLimitValue": {
            "type": "object",
            "description": "x-displayName: \"Rate Limit Value\"\nA tuple consisting of a rate limit period unit and the total number of allowed requests for that period.",
            "title": "RateLimitValue",
            "properties": {
                "action_block": {
                    "description": "x-displayName: \"Block\"\nBlocks the user for a specified duration of time",
                    "title": "Block Action",
                    "$ref": "#/definitions/rate_limiterRateLimitBlockAction"
                },
                "burst_multiplier": {
                    "type": "integer",
                    "description": "x-displayName: \"Burst Multiplier\"\nx-example: \"1\"\nThe maximum burst of requests to accommodate, expressed as a multiple of the rate.",
                    "title": "burst_multiplier",
                    "format": "int64"
                },
                "disabled": {
                    "description": "x-displayName: \"Disabled\"",
                    "title": "Disabled",
                    "$ref": "#/definitions/schemaEmpty"
                },
                "leaky_bucket": {
                    "description": "x-displayName: \"Leaky Bucket Rate Limiter\"\nLeaky-Bucket is the default rate limiter algorithm for F5",
                    "title": "LeakyBucketRateLimiter",
                    "$ref": "#/definitions/rate_limiterLeakyBucketRateLimiter"
                },
                "period_multiplier": {
                    "type": "integer",
                    "description": "x-displayName: \"Periods\"\nx-example: \"1\"\nThis setting, combined with Per Period units, provides a duration",
                    "title": "period_multiplier",
                    "format": "int64"
                },
                "token_bucket": {
                    "description": "x-displayName: \"Token Bucket Rate Limiter\"\nToken-Bucket is a rate limiter algorithm that is stricter with enforcing limits",
                    "title": "TokenBucketRateLimiter",
                    "$ref": "#/definitions/rate_limiterTokenBucketRateLimiter"
                },
                "total_number": {
                    "type": "integer",
                    "description": "x-displayName: \"Number Of Requests\"\nx-example: \"1\"\nx-required\nThe total number of allowed requests per rate-limiting period.",
                    "title": "total_number",
                    "format": "int64"
                },
                "unit": {
                    "description": "x-displayName: \"Per Period\"\nx-required\nUnit for the period per which the rate limit is applied.",
                    "title": "unit",
                    "$ref": "#/definitions/rate_limiterRateLimitPeriodUnit"
                }
            }
        },
        "rate_limiterTokenBucketRateLimiter": {
            "type": "object",
            "description": "x-displayName: \"Token Bucket Rate Limiter\"\nToken-Bucket is a rate limiter algorithm that is stricter with enforcing limits",
            "title": "TokenBucketRateLimiter"
        },
        "schemaEmpty": {
            "type": "object",
            "description": "x-displayName: \"Empty\"\nThis can be used for messages where no values are needed",
            "title": "Empty"
        },
        "schemaPlanType": {
            "type": "string",
            "description": "PlanType is the type of billing plan for the customer\n",
            "title": "PlanType",
            "enum": [
                "FREE",
                "INDIVIDUAL",
                "TEAM",
                "ORGANIZATION",
                "PLAN_TYPE_UNSPECIFIED"
            ],
            "default": "FREE",
            "x-displayname": "Plan Type",
            "x-ves-proto-enum": "ves.io.schema.PlanType"
        },
        "schemaTenantType": {
            "type": "string",
            "description": "TenantType is the type of the customer\n\nUNKNOWN indicates the field not being set\nFREEMIUM are customer that don't have their domain\nENTERPRiISE customer have their domain",
            "title": "TenantType",
            "enum": [
                "UNKNOWN",
                "FREEMIUM",
                "ENTERPRISE"
            ],
            "default": "UNKNOWN",
            "x-displayname": "Tenant type",
            "x-ves-proto-enum": "ves.io.schema.TenantType"
        },
        "schemaquotaGlobalSpecType": {
            "type": "object",
            "description": "GlobalSpecType defines the shape of the object in database as present in Global Controller",
            "title": "GlobalSpecType",
            "x-displayname": "Global Spec",
            "x-ves-proto-message": "ves.io.schema.quota.GlobalSpecType",
            "properties": {
                "api_limits": {
                    "type": "object",
                    "description": " API Limits defines ratelimit parameters for an API at the stdlib service\n The key of the api_limits map is rpc FQN e.g. \"ves.io.schema.advertise_policy.API.Create\"\n\nValidation Rules:\n  ves.io.schema.rules.map.keys.string.max_len: 512\n  ves.io.schema.rules.map.keys.string.min_len: 1\n  ves.io.schema.rules.map.keys.string.pattern: ^[a-zA-Z][a-zA-Z0-9-._]*[a-zA-Z0-9]$\n",
                    "title": "api_limits",
                    "x-displayname": "API Limits",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.map.keys.string.max_len": "512",
                        "ves.io.schema.rules.map.keys.string.min_len": "1",
                        "ves.io.schema.rules.map.keys.string.pattern": "^[a-zA-Z][a-zA-Z0-9-._]*[a-zA-Z0-9]$"
                    }
                },
                "apigw_limits": {
                    "type": "object",
                    "description": " API Gateway Limits defines rate limit value parameters for an API at a service level (prism, sentinel, etc)\n The key of the apigw_limits map is rpc FQN e.g. \"ves.io.schema.advertise_policy.API.Create\"\n\nValidation Rules:\n  ves.io.schema.rules.map.keys.string.max_len: 512\n  ves.io.schema.rules.map.keys.string.min_len: 1\n  ves.io.schema.rules.map.keys.string.pattern: ^[a-zA-Z][a-zA-Z0-9-._]*[a-zA-Z0-9]$\n",
                    "title": "apigw_limits",
                    "x-displayname": "API Gateway Limits",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.map.keys.string.max_len": "512",
                        "ves.io.schema.rules.map.keys.string.min_len": "1",
                        "ves.io.schema.rules.map.keys.string.pattern": "^[a-zA-Z][a-zA-Z0-9-._]*[a-zA-Z0-9]$"
                    }
                },
                "object_limits": {
                    "type": "object",
                    "description": " Object Limits define maximum number of instances that can be present per object kind for the tenant\n The key of the object_limits map is object kind e.g. \"virtual_host\"\n\nValidation Rules:\n  ves.io.schema.rules.map.keys.string.max_len: 512\n  ves.io.schema.rules.map.keys.string.min_len: 1\n  ves.io.schema.rules.map.keys.string.pattern: ^[a-zA-Z][a-zA-Z0-9-._]*[a-zA-Z0-9]$\n",
                    "title": "object_limits",
                    "x-displayname": "Object Limits",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.map.keys.string.max_len": "512",
                        "ves.io.schema.rules.map.keys.string.min_len": "1",
                        "ves.io.schema.rules.map.keys.string.pattern": "^[a-zA-Z][a-zA-Z0-9-._]*[a-zA-Z0-9]$"
                    }
                },
                "resource_limits": {
                    "type": "object",
                    "description": " Resource Limits define maximum value of resources in the appropriate units that can be present. The key of\n the resource limits is the resource name\n\nValidation Rules:\n  ves.io.schema.rules.map.keys.string.max_len: 512\n  ves.io.schema.rules.map.keys.string.min_len: 1\n  ves.io.schema.rules.map.keys.string.pattern: ^[a-zA-Z][a-zA-Z0-9-._]*[a-zA-Z0-9]$\n",
                    "title": "resource_limits",
                    "x-displayname": "Resource Limits",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.map.keys.string.max_len": "512",
                        "ves.io.schema.rules.map.keys.string.min_len": "1",
                        "ves.io.schema.rules.map.keys.string.pattern": "^[a-zA-Z][a-zA-Z0-9-._]*[a-zA-Z0-9]$"
                    }
                }
            }
        }
    },
    "x-displayname": "Usage plan",
    "x-ves-proto-file": "ves.io/schema/usage/plan/custom_api.proto"
}`
