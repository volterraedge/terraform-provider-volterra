// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package plan

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema_quota "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/quota"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AddonServiceDetails) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AddonServiceDetails) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AddonServiceDetails) DeepCopy() *AddonServiceDetails {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AddonServiceDetails{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AddonServiceDetails) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AddonServiceDetails) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AddonServiceDetailsValidator().Validate(ctx, m, opts...)
}

type ValidateAddonServiceDetails struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAddonServiceDetails) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AddonServiceDetails)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AddonServiceDetails got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["display_name"]; exists {

		vOpts := append(opts, db.WithValidateField("display_name"))
		if err := fv(ctx, m.GetDisplayName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAddonServiceDetailsValidator = func() *ValidateAddonServiceDetails {
	v := &ValidateAddonServiceDetails{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AddonServiceDetailsValidator() db.Validator {
	return DefaultAddonServiceDetailsValidator
}

// augmented methods on protoc/std generated struct

func (m *ListUsagePlansReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListUsagePlansReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListUsagePlansReq) DeepCopy() *ListUsagePlansReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListUsagePlansReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListUsagePlansReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListUsagePlansReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListUsagePlansReqValidator().Validate(ctx, m, opts...)
}

type ValidateListUsagePlansReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListUsagePlansReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListUsagePlansReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListUsagePlansReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListUsagePlansReqValidator = func() *ValidateListUsagePlansReq {
	v := &ValidateListUsagePlansReq{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ListUsagePlansReqValidator() db.Validator {
	return DefaultListUsagePlansReqValidator
}

// augmented methods on protoc/std generated struct

func (m *ListUsagePlansRsp) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListUsagePlansRsp) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListUsagePlansRsp) DeepCopy() *ListUsagePlansRsp {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListUsagePlansRsp{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListUsagePlansRsp) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListUsagePlansRsp) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListUsagePlansRspValidator().Validate(ctx, m, opts...)
}

type ValidateListUsagePlansRsp struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListUsagePlansRsp) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListUsagePlansRsp)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListUsagePlansRsp got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["usage_plans"]; exists {

		vOpts := append(opts, db.WithValidateField("usage_plans"))
		for idx, item := range m.GetUsagePlans() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListUsagePlansRspValidator = func() *ValidateListUsagePlansRsp {
	v := &ValidateListUsagePlansRsp{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["usage_plans"] = LocalizedPlanValidator().Validate

	return v
}()

func ListUsagePlansRspValidator() db.Validator {
	return DefaultListUsagePlansRspValidator
}

// augmented methods on protoc/std generated struct

func (m *LocalizedPlan) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *LocalizedPlan) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *LocalizedPlan) DeepCopy() *LocalizedPlan {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &LocalizedPlan{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *LocalizedPlan) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *LocalizedPlan) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return LocalizedPlanValidator().Validate(ctx, m, opts...)
}

type ValidateLocalizedPlan struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateLocalizedPlan) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*LocalizedPlan)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *LocalizedPlan got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["locale"]; exists {

		vOpts := append(opts, db.WithValidateField("locale"))
		if err := fv(ctx, m.GetLocale(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["plans"]; exists {

		vOpts := append(opts, db.WithValidateField("plans"))
		for idx, item := range m.GetPlans() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultLocalizedPlanValidator = func() *ValidateLocalizedPlan {
	v := &ValidateLocalizedPlan{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["plans"] = PlanInternalValidator().Validate

	return v
}()

func LocalizedPlanValidator() db.Validator {
	return DefaultLocalizedPlanValidator
}

// augmented methods on protoc/std generated struct

func (m *PlanInternal) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PlanInternal) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PlanInternal) DeepCopy() *PlanInternal {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PlanInternal{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PlanInternal) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PlanInternal) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PlanInternalValidator().Validate(ctx, m, opts...)
}

type ValidatePlanInternal struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePlanInternal) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PlanInternal)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PlanInternal got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["allowed_addon_services"]; exists {

		vOpts := append(opts, db.WithValidateField("allowed_addon_services"))
		for idx, item := range m.GetAllowedAddonServices() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["billing_disabled"]; exists {

		vOpts := append(opts, db.WithValidateField("billing_disabled"))
		if err := fv(ctx, m.GetBillingDisabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["current"]; exists {

		vOpts := append(opts, db.WithValidateField("current"))
		if err := fv(ctx, m.GetCurrent(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_quota"]; exists {

		vOpts := append(opts, db.WithValidateField("default_quota"))
		if err := fv(ctx, m.GetDefaultQuota(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["flat_price"]; exists {

		vOpts := append(opts, db.WithValidateField("flat_price"))
		if err := fv(ctx, m.GetFlatPrice(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["included_addon_services"]; exists {

		vOpts := append(opts, db.WithValidateField("included_addon_services"))
		for idx, item := range m.GetIncludedAddonServices() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["renewal_period_unit"]; exists {

		vOpts := append(opts, db.WithValidateField("renewal_period_unit"))
		if err := fv(ctx, m.GetRenewalPeriodUnit(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["subtitle"]; exists {

		vOpts := append(opts, db.WithValidateField("subtitle"))
		if err := fv(ctx, m.GetSubtitle(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tenant_type"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant_type"))
		if err := fv(ctx, m.GetTenantType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["title"]; exists {

		vOpts := append(opts, db.WithValidateField("title"))
		if err := fv(ctx, m.GetTitle(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["transition_flow"]; exists {

		vOpts := append(opts, db.WithValidateField("transition_flow"))
		if err := fv(ctx, m.GetTransitionFlow(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["trial_period"]; exists {

		vOpts := append(opts, db.WithValidateField("trial_period"))
		if err := fv(ctx, m.GetTrialPeriod(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["trial_period_unit"]; exists {

		vOpts := append(opts, db.WithValidateField("trial_period_unit"))
		if err := fv(ctx, m.GetTrialPeriodUnit(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["usage_plan_type"]; exists {

		vOpts := append(opts, db.WithValidateField("usage_plan_type"))
		if err := fv(ctx, m.GetUsagePlanType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPlanInternalValidator = func() *ValidatePlanInternal {
	v := &ValidatePlanInternal{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["default_quota"] = ves_io_schema_quota.GlobalSpecTypeValidator().Validate

	return v
}()

func PlanInternalValidator() db.Validator {
	return DefaultPlanInternalValidator
}

// augmented methods on protoc/std generated struct

func (m *UsagePlanTransitionFlow) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *UsagePlanTransitionFlow) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *UsagePlanTransitionFlow) DeepCopy() *UsagePlanTransitionFlow {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &UsagePlanTransitionFlow{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *UsagePlanTransitionFlow) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *UsagePlanTransitionFlow) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return UsagePlanTransitionFlowValidator().Validate(ctx, m, opts...)
}

type ValidateUsagePlanTransitionFlow struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUsagePlanTransitionFlow) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*UsagePlanTransitionFlow)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *UsagePlanTransitionFlow got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["method"]; exists {

		vOpts := append(opts, db.WithValidateField("method"))
		if err := fv(ctx, m.GetMethod(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["required_fields"]; exists {

		vOpts := append(opts, db.WithValidateField("required_fields"))
		for idx, item := range m.GetRequiredFields() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["requires_manual_approval"]; exists {

		vOpts := append(opts, db.WithValidateField("requires_manual_approval"))
		if err := fv(ctx, m.GetRequiresManualApproval(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUsagePlanTransitionFlowValidator = func() *ValidateUsagePlanTransitionFlow {
	v := &ValidateUsagePlanTransitionFlow{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func UsagePlanTransitionFlowValidator() db.Validator {
	return DefaultUsagePlanTransitionFlowValidator
}
