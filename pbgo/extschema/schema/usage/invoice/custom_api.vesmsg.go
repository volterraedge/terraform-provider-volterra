// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package invoice

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *DownloadInvoicePdfReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DownloadInvoicePdfReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DownloadInvoicePdfReq) DeepCopy() *DownloadInvoicePdfReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DownloadInvoicePdfReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DownloadInvoicePdfReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DownloadInvoicePdfReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DownloadInvoicePdfReqValidator().Validate(ctx, m, opts...)
}

type ValidateDownloadInvoicePdfReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDownloadInvoicePdfReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DownloadInvoicePdfReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DownloadInvoicePdfReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDownloadInvoicePdfReqValidator = func() *ValidateDownloadInvoicePdfReq {
	v := &ValidateDownloadInvoicePdfReq{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DownloadInvoicePdfReqValidator() db.Validator {
	return DefaultDownloadInvoicePdfReqValidator
}

// augmented methods on protoc/std generated struct

func (m *DownloadInvoicePdfRsp) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DownloadInvoicePdfRsp) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DownloadInvoicePdfRsp) DeepCopy() *DownloadInvoicePdfRsp {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DownloadInvoicePdfRsp{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DownloadInvoicePdfRsp) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DownloadInvoicePdfRsp) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DownloadInvoicePdfRspValidator().Validate(ctx, m, opts...)
}

type ValidateDownloadInvoicePdfRsp struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDownloadInvoicePdfRsp) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DownloadInvoicePdfRsp)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DownloadInvoicePdfRsp got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["pdf"]; exists {

		vOpts := append(opts, db.WithValidateField("pdf"))
		if err := fv(ctx, m.GetPdf(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDownloadInvoicePdfRspValidator = func() *ValidateDownloadInvoicePdfRsp {
	v := &ValidateDownloadInvoicePdfRsp{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DownloadInvoicePdfRspValidator() db.Validator {
	return DefaultDownloadInvoicePdfRspValidator
}

// augmented methods on protoc/std generated struct

func (m *InvoiceType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *InvoiceType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *InvoiceType) DeepCopy() *InvoiceType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &InvoiceType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *InvoiceType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *InvoiceType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InvoiceTypeValidator().Validate(ctx, m, opts...)
}

type ValidateInvoiceType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInvoiceType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*InvoiceType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *InvoiceType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["active"]; exists {

		vOpts := append(opts, db.WithValidateField("active"))
		if err := fv(ctx, m.GetActive(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["amount"]; exists {

		vOpts := append(opts, db.WithValidateField("amount"))
		if err := fv(ctx, m.GetAmount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["currency"]; exists {

		vOpts := append(opts, db.WithValidateField("currency"))
		if err := fv(ctx, m.GetCurrency(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["period_end"]; exists {

		vOpts := append(opts, db.WithValidateField("period_end"))
		if err := fv(ctx, m.GetPeriodEnd(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["period_start"]; exists {

		vOpts := append(opts, db.WithValidateField("period_start"))
		if err := fv(ctx, m.GetPeriodStart(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInvoiceTypeValidator = func() *ValidateInvoiceType {
	v := &ValidateInvoiceType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func InvoiceTypeValidator() db.Validator {
	return DefaultInvoiceTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ListInvoicesReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListInvoicesReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListInvoicesReq) DeepCopy() *ListInvoicesReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListInvoicesReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListInvoicesReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListInvoicesReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListInvoicesReqValidator().Validate(ctx, m, opts...)
}

type ValidateListInvoicesReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListInvoicesReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListInvoicesReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListInvoicesReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["limit"]; exists {

		vOpts := append(opts, db.WithValidateField("limit"))
		if err := fv(ctx, m.GetLimit(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListInvoicesReqValidator = func() *ValidateListInvoicesReq {
	v := &ValidateListInvoicesReq{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ListInvoicesReqValidator() db.Validator {
	return DefaultListInvoicesReqValidator
}

// augmented methods on protoc/std generated struct

func (m *ListInvoicesRsp) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListInvoicesRsp) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListInvoicesRsp) DeepCopy() *ListInvoicesRsp {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListInvoicesRsp{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListInvoicesRsp) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListInvoicesRsp) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListInvoicesRspValidator().Validate(ctx, m, opts...)
}

type ValidateListInvoicesRsp struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListInvoicesRsp) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListInvoicesRsp)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListInvoicesRsp got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["invoices"]; exists {

		vOpts := append(opts, db.WithValidateField("invoices"))
		for idx, item := range m.GetInvoices() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListInvoicesRspValidator = func() *ValidateListInvoicesRsp {
	v := &ValidateListInvoicesRsp{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ListInvoicesRspValidator() db.Validator {
	return DefaultListInvoicesRspValidator
}
