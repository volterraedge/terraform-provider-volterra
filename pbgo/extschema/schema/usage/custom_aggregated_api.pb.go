// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/usage/custom_aggregated_api.proto

// Usage related Customer APIs
//
// x-displayName: "Usage"
// Resource usage and pricing custom APIs

package usage

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/googleapis/google/api"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/vesenv"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Group by data
//
// x-displayName: "Group by date"
// All possible "by date" aggregation types
type GroupDateByType int32

const (
	// No value defined
	// x-displayName: "Unknown"
	GROUP_UNKNOWN GroupDateByType = 0
	// Aggregate by hour
	// x-displayName: "Hour"
	GROUP_HOUR GroupDateByType = 1
	// Aggregate by day
	// x-displayName: "Day"
	GROUP_DAY GroupDateByType = 2
	// Aggregate by week
	// x-displayName: "Week"
	GROUP_WEEK GroupDateByType = 3
	// Aggregate by month
	// x-displayName: "Month"
	GROUP_MONTH GroupDateByType = 4
	// Aggregate by year
	// x-displayName: "Year"
	GROUP_YEAR GroupDateByType = 5
)

var GroupDateByType_name = map[int32]string{
	0: "GROUP_UNKNOWN",
	1: "GROUP_HOUR",
	2: "GROUP_DAY",
	3: "GROUP_WEEK",
	4: "GROUP_MONTH",
	5: "GROUP_YEAR",
}

var GroupDateByType_value = map[string]int32{
	"GROUP_UNKNOWN": 0,
	"GROUP_HOUR":    1,
	"GROUP_DAY":     2,
	"GROUP_WEEK":    3,
	"GROUP_MONTH":   4,
	"GROUP_YEAR":    5,
}

func (GroupDateByType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_12ae48cf380a70f0, []int{0}
}

// List usage details request
//
// x-displayName: "List usage details request"
// Request message to get usage details
type ListUsageDetailsReq struct {
	// Timestamp from
	//
	// x-displayName: "From"
	// x-example: "2020-04-20T12:32:51.341959216Z"
	// Indicates the "from" part of the request
	From *types.Timestamp `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	// Timestamp to
	//
	// x-displayName: "To"
	// x-example: "2020-04-20T12:32:51.341959216Z"
	// Indicates the "to" part of the request
	To *types.Timestamp `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty"`
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "system"
	// Namespace to be considered
	Namespace string `protobuf:"bytes,3,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *ListUsageDetailsReq) Reset()      { *m = ListUsageDetailsReq{} }
func (*ListUsageDetailsReq) ProtoMessage() {}
func (*ListUsageDetailsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_12ae48cf380a70f0, []int{0}
}
func (m *ListUsageDetailsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListUsageDetailsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListUsageDetailsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListUsageDetailsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUsageDetailsReq.Merge(m, src)
}
func (m *ListUsageDetailsReq) XXX_Size() int {
	return m.Size()
}
func (m *ListUsageDetailsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUsageDetailsReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListUsageDetailsReq proto.InternalMessageInfo

func (m *ListUsageDetailsReq) GetFrom() *types.Timestamp {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *ListUsageDetailsReq) GetTo() *types.Timestamp {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *ListUsageDetailsReq) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// List usage details response
//
// x-displayName: "List usage details response"
// Response message to get usage details
type ListUsageDetailsResp struct {
	// Usage items
	//
	// x-displayName: "Usage items"
	// Collection of usage items, lines of response
	UsageItems []*UsageItem `protobuf:"bytes,1,rep,name=usage_items,json=usageItems,proto3" json:"usage_items,omitempty"`
}

func (m *ListUsageDetailsResp) Reset()      { *m = ListUsageDetailsResp{} }
func (*ListUsageDetailsResp) ProtoMessage() {}
func (*ListUsageDetailsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_12ae48cf380a70f0, []int{1}
}
func (m *ListUsageDetailsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListUsageDetailsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListUsageDetailsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListUsageDetailsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUsageDetailsResp.Merge(m, src)
}
func (m *ListUsageDetailsResp) XXX_Size() int {
	return m.Size()
}
func (m *ListUsageDetailsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUsageDetailsResp.DiscardUnknown(m)
}

var xxx_messageInfo_ListUsageDetailsResp proto.InternalMessageInfo

func (m *ListUsageDetailsResp) GetUsageItems() []*UsageItem {
	if m != nil {
		return m.UsageItems
	}
	return nil
}

// Usage item
//
// x-displayName: "usage item"
// Usage item represents a line in a usage report, including quantity and resource incurring usage.
type UsageItem struct {
	// Object name
	//
	// x-displayName: "Object name"
	// x-example: "pa4-resource1"
	// Name of the object where the usage occurred
	ObjectName string `protobuf:"bytes,1,opt,name=object_name,json=objectName,proto3" json:"object_name,omitempty"`
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "system"
	// Namespace where the usage occurred
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Usage type
	//
	// x-displayName: "Usage type"
	// x-example: "ADN App Mgmt - VoltStack Large Containers"
	// Type of the resource
	UsageType string `protobuf:"bytes,3,opt,name=usage_type,json=usageType,proto3" json:"usage_type,omitempty"`
	// Quantity
	//
	// x-displayName: "Quantity"
	// x-example: "100"
	// Quantity incurred
	Quantity float64 `protobuf:"fixed64,4,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// Unit name
	//
	// x-displayName: "Unit name"
	// x-example: "MB"
	// Name of the quantity unit
	UnitName string `protobuf:"bytes,5,opt,name=unit_name,json=unitName,proto3" json:"unit_name,omitempty"`
	// Timestamp start
	//
	// x-displayName: "Start"
	// x-example: "2020-04-20T12:32:51.341959216Z"
	// Beginning of the time unit
	StartTimestamp *types.Timestamp `protobuf:"bytes,6,opt,name=start_timestamp,json=startTimestamp,proto3" json:"start_timestamp,omitempty"`
	// Timestamp end
	//
	// x-displayName: "End"
	// x-example: "2020-04-20T12:32:51.341959216Z"
	// End of the time unit
	EndTimestamp *types.Timestamp `protobuf:"bytes,7,opt,name=end_timestamp,json=endTimestamp,proto3" json:"end_timestamp,omitempty"`
	// Hourly breakdown
	//
	// x-displayName: "Hourly breakdown"
	// An array of HourlyItem with usage per hour. The sum of these items will result into the parent's object `quantity`
	// Deprecated: use /hourly_usage_details along with hourly_breakdown_query
	HourlyBreakdown []*HourlyItem `protobuf:"bytes,8,rep,name=hourly_breakdown,json=hourlyBreakdown,proto3" json:"hourly_breakdown,omitempty"`
	// Hourly breakdown query
	//
	// x-displayName: "Hourly breakdown query"
	// [x-required]
	// x-example: "{'MetricLabel':'label'}"
	// A base64 encoded json which should be passed as is to /hourly_usage_details
	// to get hourly items for this aggregated usage.
	HourlyBreakdownQuery string `protobuf:"bytes,9,opt,name=hourly_breakdown_query,json=hourlyBreakdownQuery,proto3" json:"hourly_breakdown_query,omitempty"`
	// Metric label
	//
	// x-displayName: "Metric label"
	// [x-required]
	// id of the usage type. As Usage type is shown for user and is a subject of frequent changes,
	// this metric_label should be static and should be usage for mapping between calculated usage and aggregated_usage.
	MetricLabel string `protobuf:"bytes,10,opt,name=metric_label,json=metricLabel,proto3" json:"metric_label,omitempty"`
}

func (m *UsageItem) Reset()      { *m = UsageItem{} }
func (*UsageItem) ProtoMessage() {}
func (*UsageItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_12ae48cf380a70f0, []int{2}
}
func (m *UsageItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsageItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UsageItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UsageItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsageItem.Merge(m, src)
}
func (m *UsageItem) XXX_Size() int {
	return m.Size()
}
func (m *UsageItem) XXX_DiscardUnknown() {
	xxx_messageInfo_UsageItem.DiscardUnknown(m)
}

var xxx_messageInfo_UsageItem proto.InternalMessageInfo

func (m *UsageItem) GetObjectName() string {
	if m != nil {
		return m.ObjectName
	}
	return ""
}

func (m *UsageItem) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *UsageItem) GetUsageType() string {
	if m != nil {
		return m.UsageType
	}
	return ""
}

func (m *UsageItem) GetQuantity() float64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *UsageItem) GetUnitName() string {
	if m != nil {
		return m.UnitName
	}
	return ""
}

func (m *UsageItem) GetStartTimestamp() *types.Timestamp {
	if m != nil {
		return m.StartTimestamp
	}
	return nil
}

func (m *UsageItem) GetEndTimestamp() *types.Timestamp {
	if m != nil {
		return m.EndTimestamp
	}
	return nil
}

func (m *UsageItem) GetHourlyBreakdown() []*HourlyItem {
	if m != nil {
		return m.HourlyBreakdown
	}
	return nil
}

func (m *UsageItem) GetHourlyBreakdownQuery() string {
	if m != nil {
		return m.HourlyBreakdownQuery
	}
	return ""
}

func (m *UsageItem) GetMetricLabel() string {
	if m != nil {
		return m.MetricLabel
	}
	return ""
}

// Hourly usage item
//
// x-displayName: "Hourly usage item"
// One line of usage by an hour. One hour as the least resolution.
type HourlyItem struct {
	// Timestamp start
	//
	// x-displayName: "Start"
	// x-example: "2020-04-20T12:32:51.341959216Z"
	// Beginning of the time unit
	StartTimestamp *types.Timestamp `protobuf:"bytes,1,opt,name=start_timestamp,json=startTimestamp,proto3" json:"start_timestamp,omitempty"`
	// Timestamp end
	//
	// x-displayName: "End"
	// x-example: "2020-04-20T12:32:51.341959216Z"
	// End of the time unit
	EndTimestamp *types.Timestamp `protobuf:"bytes,2,opt,name=end_timestamp,json=endTimestamp,proto3" json:"end_timestamp,omitempty"`
	// Unit name
	//
	// x-displayName: "Unit name"
	// x-example: "MB"
	// Name of the quantity unit
	UnitName string `protobuf:"bytes,3,opt,name=unit_name,json=unitName,proto3" json:"unit_name,omitempty"`
	// Quantity
	//
	// x-displayName: "Quantity"
	// x-example: "100"
	// Quantity incurred
	Quantity float64 `protobuf:"fixed64,4,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// Deployment
	//
	// x-displayName: "Deployment"
	// [x-required]
	// x-example: "pa4-deployment1"
	// Deployment name if this item correspond to the container usage. Otherwise it's empty
	Deployment string `protobuf:"bytes,5,opt,name=deployment,proto3" json:"deployment,omitempty"`
	// Container
	//
	// x-displayName: "Container"
	// x-example: "pa4-deployment1-abcd12"
	// Container name if this item correspond to the container usage. Otherwise it's empty
	Container string `protobuf:"bytes,6,opt,name=container,proto3" json:"container,omitempty"`
}

func (m *HourlyItem) Reset()      { *m = HourlyItem{} }
func (*HourlyItem) ProtoMessage() {}
func (*HourlyItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_12ae48cf380a70f0, []int{3}
}
func (m *HourlyItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HourlyItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HourlyItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HourlyItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HourlyItem.Merge(m, src)
}
func (m *HourlyItem) XXX_Size() int {
	return m.Size()
}
func (m *HourlyItem) XXX_DiscardUnknown() {
	xxx_messageInfo_HourlyItem.DiscardUnknown(m)
}

var xxx_messageInfo_HourlyItem proto.InternalMessageInfo

func (m *HourlyItem) GetStartTimestamp() *types.Timestamp {
	if m != nil {
		return m.StartTimestamp
	}
	return nil
}

func (m *HourlyItem) GetEndTimestamp() *types.Timestamp {
	if m != nil {
		return m.EndTimestamp
	}
	return nil
}

func (m *HourlyItem) GetUnitName() string {
	if m != nil {
		return m.UnitName
	}
	return ""
}

func (m *HourlyItem) GetQuantity() float64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *HourlyItem) GetDeployment() string {
	if m != nil {
		return m.Deployment
	}
	return ""
}

func (m *HourlyItem) GetContainer() string {
	if m != nil {
		return m.Container
	}
	return ""
}

// ListHourlyUsageDetailsReq
//
// x-displayName: "List Hourly Usage Details Request"
// Request body for ListHourlyUsageDetails rpc method
type ListHourlyUsageDetailsReq struct {
	// Namespace
	//
	// x-displayName: "namespace"
	// x-example: "system"
	// Namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// query
	//
	// x-displayName: "query"
	// x-example: "{'MetricLabel':'label'}"
	// Encoded query which is passed as is to barracute daemon
	Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
}

func (m *ListHourlyUsageDetailsReq) Reset()      { *m = ListHourlyUsageDetailsReq{} }
func (*ListHourlyUsageDetailsReq) ProtoMessage() {}
func (*ListHourlyUsageDetailsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_12ae48cf380a70f0, []int{4}
}
func (m *ListHourlyUsageDetailsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListHourlyUsageDetailsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListHourlyUsageDetailsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListHourlyUsageDetailsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListHourlyUsageDetailsReq.Merge(m, src)
}
func (m *ListHourlyUsageDetailsReq) XXX_Size() int {
	return m.Size()
}
func (m *ListHourlyUsageDetailsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListHourlyUsageDetailsReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListHourlyUsageDetailsReq proto.InternalMessageInfo

func (m *ListHourlyUsageDetailsReq) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ListHourlyUsageDetailsReq) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

// List Hourly Usage Details Response
//
// x-displayName: "List Hourly Usage Details Response"
// Response body for ListHourlyUsageDetails rpc method
type ListHourlyUsageDetailsResp struct {
	// Usage items
	//
	// x-displayName: "Usage items"
	// Array of usage by hour in the period from the query
	HourlyUsageItems []*HourlyItem `protobuf:"bytes,2,rep,name=hourly_usage_items,json=hourlyUsageItems,proto3" json:"hourly_usage_items,omitempty"`
}

func (m *ListHourlyUsageDetailsResp) Reset()      { *m = ListHourlyUsageDetailsResp{} }
func (*ListHourlyUsageDetailsResp) ProtoMessage() {}
func (*ListHourlyUsageDetailsResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_12ae48cf380a70f0, []int{5}
}
func (m *ListHourlyUsageDetailsResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListHourlyUsageDetailsResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListHourlyUsageDetailsResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListHourlyUsageDetailsResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListHourlyUsageDetailsResp.Merge(m, src)
}
func (m *ListHourlyUsageDetailsResp) XXX_Size() int {
	return m.Size()
}
func (m *ListHourlyUsageDetailsResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ListHourlyUsageDetailsResp.DiscardUnknown(m)
}

var xxx_messageInfo_ListHourlyUsageDetailsResp proto.InternalMessageInfo

func (m *ListHourlyUsageDetailsResp) GetHourlyUsageItems() []*HourlyItem {
	if m != nil {
		return m.HourlyUsageItems
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.usage.GroupDateByType", GroupDateByType_name, GroupDateByType_value)
	proto.RegisterType((*ListUsageDetailsReq)(nil), "ves.io.schema.usage.ListUsageDetailsReq")
	proto.RegisterType((*ListUsageDetailsResp)(nil), "ves.io.schema.usage.ListUsageDetailsResp")
	proto.RegisterType((*UsageItem)(nil), "ves.io.schema.usage.UsageItem")
	proto.RegisterType((*HourlyItem)(nil), "ves.io.schema.usage.HourlyItem")
	proto.RegisterType((*ListHourlyUsageDetailsReq)(nil), "ves.io.schema.usage.ListHourlyUsageDetailsReq")
	proto.RegisterType((*ListHourlyUsageDetailsResp)(nil), "ves.io.schema.usage.ListHourlyUsageDetailsResp")
}

func init() {
	proto.RegisterFile("ves.io/schema/usage/custom_aggregated_api.proto", fileDescriptor_12ae48cf380a70f0)
}

var fileDescriptor_12ae48cf380a70f0 = []byte{
	// 929 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xcd, 0x6f, 0x1b, 0x45,
	0x14, 0xf7, 0xac, 0x93, 0x12, 0x3f, 0x37, 0x8d, 0x99, 0x46, 0xd5, 0xd6, 0x2d, 0x1b, 0x77, 0x4f,
	0x26, 0xaa, 0x77, 0x45, 0x0a, 0x12, 0xe2, 0x52, 0x25, 0x4d, 0xd4, 0xa4, 0x1f, 0x76, 0x59, 0x25,
	0x8a, 0x8a, 0x90, 0x56, 0x63, 0x7b, 0xb2, 0x59, 0xba, 0xbb, 0x33, 0xd9, 0x99, 0x35, 0xb5, 0x10,
	0x02, 0xf5, 0xc6, 0x09, 0x24, 0xfe, 0x09, 0xfe, 0x87, 0x5e, 0xb8, 0x20, 0xb8, 0x80, 0x22, 0xb8,
	0xf4, 0x84, 0x88, 0xc3, 0x81, 0x0b, 0x52, 0xff, 0x04, 0xb4, 0xb3, 0xfe, 0xc6, 0x25, 0xa9, 0xb8,
	0xcd, 0xfb, 0xf8, 0xbd, 0x79, 0x1f, 0xbf, 0x79, 0xbb, 0x60, 0x77, 0xa8, 0xb0, 0x7c, 0x66, 0x8b,
	0xd6, 0x21, 0x0d, 0x89, 0x9d, 0x08, 0xe2, 0x51, 0xbb, 0x95, 0x08, 0xc9, 0x42, 0x97, 0x78, 0x5e,
	0x4c, 0x3d, 0x22, 0x69, 0xdb, 0x25, 0xdc, 0xb7, 0x78, 0xcc, 0x24, 0xc3, 0x97, 0x33, 0x80, 0x95,
	0x01, 0x2c, 0x05, 0x28, 0x5f, 0xf7, 0x18, 0xf3, 0x02, 0x6a, 0x13, 0xee, 0xdb, 0x24, 0x8a, 0x98,
	0x24, 0xd2, 0x67, 0x91, 0xc8, 0x20, 0xe5, 0x95, 0xbe, 0x55, 0x49, 0xcd, 0xe4, 0xc0, 0x96, 0x7e,
	0x48, 0x85, 0x24, 0x21, 0xef, 0x3b, 0x5c, 0x9b, 0x4c, 0x82, 0xf1, 0x71, 0xf4, 0xd5, 0x49, 0xa3,
	0xec, 0x72, 0x3a, 0x30, 0x99, 0x93, 0xa6, 0x0e, 0x15, 0x34, 0xea, 0x4c, 0xc2, 0xcd, 0xaf, 0x11,
	0x5c, 0x7e, 0xe0, 0x0b, 0xb9, 0x97, 0x26, 0xba, 0x49, 0x25, 0xf1, 0x03, 0xe1, 0xd0, 0x23, 0x6c,
	0xc1, 0xdc, 0x41, 0xcc, 0x42, 0x1d, 0x55, 0x50, 0xb5, 0xb8, 0x56, 0xb6, 0xb2, 0x1c, 0xad, 0x41,
	0x8e, 0xd6, 0xee, 0x20, 0x47, 0x47, 0xf9, 0xe1, 0x55, 0xd0, 0x24, 0xd3, 0xb5, 0x33, 0xbd, 0x35,
	0xc9, 0xf0, 0x75, 0x28, 0x44, 0x24, 0xa4, 0x82, 0x93, 0x16, 0xd5, 0xf3, 0x15, 0x54, 0x2d, 0x38,
	0x23, 0x85, 0xb9, 0x0f, 0xcb, 0xff, 0x4e, 0x48, 0x70, 0x7c, 0x1b, 0x8a, 0xaa, 0x9b, 0xae, 0x2f,
	0x69, 0x28, 0x74, 0x54, 0xc9, 0x57, 0x8b, 0x6b, 0x86, 0x35, 0xa3, 0xdf, 0x96, 0xc2, 0xee, 0x48,
	0x1a, 0x3a, 0x90, 0x0c, 0x8e, 0xc2, 0xfc, 0x39, 0x0f, 0x85, 0xa1, 0x05, 0xaf, 0x40, 0x91, 0x35,
	0x3f, 0xa1, 0x2d, 0xe9, 0xa6, 0x57, 0xab, 0x3a, 0x0b, 0x0e, 0x64, 0xaa, 0x3a, 0x09, 0xe9, 0x64,
	0x96, 0xda, 0x54, 0x96, 0xf8, 0x2d, 0xc8, 0x42, 0xbb, 0x69, 0xc3, 0x07, 0x45, 0x28, 0xcd, 0x6e,
	0x97, 0x53, 0x5c, 0x86, 0x85, 0xa3, 0x84, 0x44, 0xd2, 0x97, 0x5d, 0x7d, 0xae, 0x82, 0xaa, 0xc8,
	0x19, 0xca, 0xf8, 0x1a, 0x14, 0x92, 0xc8, 0xef, 0xdf, 0x3b, 0xaf, 0x90, 0x0b, 0xa9, 0x42, 0xdd,
	0x7a, 0x07, 0x96, 0x84, 0x24, 0xb1, 0x74, 0x87, 0x24, 0xd0, 0x2f, 0x9c, 0xd9, 0xd4, 0x4b, 0x0a,
	0x32, 0x94, 0xf1, 0x6d, 0x58, 0xa4, 0x51, 0x7b, 0x2c, 0xc4, 0x1b, 0x67, 0x86, 0xb8, 0x48, 0xa3,
	0xf6, 0x28, 0xc0, 0x3d, 0x28, 0x1d, 0xb2, 0x24, 0x0e, 0xba, 0x6e, 0x33, 0xa6, 0xe4, 0x49, 0x9b,
	0x7d, 0x1a, 0xe9, 0x0b, 0xaa, 0xe1, 0x2b, 0x33, 0x1b, 0xbe, 0xad, 0x9c, 0x55, 0xc7, 0x97, 0x32,
	0xe0, 0xc6, 0x00, 0x87, 0xdf, 0x85, 0x2b, 0xd3, 0xb1, 0xdc, 0xa3, 0x84, 0xc6, 0x5d, 0xbd, 0xa0,
	0x6a, 0x5f, 0x9e, 0x02, 0x7c, 0x98, 0xda, 0xf0, 0x0d, 0xb8, 0x18, 0x52, 0x19, 0xfb, 0x2d, 0x37,
	0x20, 0x4d, 0x1a, 0xe8, 0xa0, 0x7c, 0x8b, 0x99, 0xee, 0x41, 0xaa, 0x32, 0xbf, 0xd2, 0x00, 0x46,
	0x17, 0xcf, 0xea, 0x1c, 0xfa, 0xff, 0x9d, 0xd3, 0x5e, 0xb3, 0x73, 0x13, 0xc3, 0xcd, 0x4f, 0x0d,
	0xf7, 0xbf, 0x58, 0x61, 0x00, 0xb4, 0x29, 0x0f, 0x58, 0x37, 0xa4, 0x91, 0xec, 0xd3, 0x62, 0x4c,
	0x93, 0xd2, 0xb1, 0xc5, 0x22, 0x49, 0xfc, 0x88, 0xc6, 0x8a, 0x12, 0x05, 0x67, 0xa4, 0x30, 0x1b,
	0x70, 0x35, 0x7d, 0x34, 0x59, 0x3b, 0xa6, 0xdf, 0xf2, 0x04, 0x93, 0xd1, 0x34, 0x93, 0x97, 0x61,
	0x3e, 0x1b, 0x47, 0xc6, 0xf1, 0x4c, 0x30, 0x8f, 0xa0, 0xfc, 0xaa, 0x80, 0x82, 0xe3, 0x87, 0x80,
	0xfb, 0x33, 0x1d, 0x7f, 0x92, 0xda, 0xf9, 0x18, 0xd2, 0xa7, 0xd6, 0xf0, 0x29, 0x8a, 0x7b, 0x73,
	0x0b, 0xa8, 0xa4, 0xad, 0x4a, 0x58, 0xba, 0x1b, 0xb3, 0x84, 0x6f, 0x12, 0x49, 0x37, 0xba, 0xea,
	0x19, 0xbd, 0x09, 0x8b, 0x77, 0x9d, 0xc6, 0xde, 0x23, 0x77, 0xaf, 0x7e, 0xbf, 0xde, 0xd8, 0xaf,
	0x97, 0x72, 0xf8, 0x12, 0x40, 0xa6, 0xda, 0x6e, 0xec, 0x39, 0x25, 0x84, 0x17, 0xa1, 0x90, 0xc9,
	0x9b, 0xeb, 0x8f, 0x4b, 0xda, 0xc8, 0xbc, 0xbf, 0xb5, 0x75, 0xbf, 0x94, 0xc7, 0x4b, 0x50, 0xcc,
	0xe4, 0x87, 0x8d, 0xfa, 0xee, 0x76, 0x69, 0x6e, 0xe4, 0xf0, 0x78, 0x6b, 0xdd, 0x29, 0xcd, 0xaf,
	0xfd, 0x9d, 0x07, 0xfd, 0x8e, 0x5a, 0xe8, 0xeb, 0xc3, 0x7d, 0xae, 0x52, 0x5b, 0x7f, 0xb4, 0x83,
	0x7f, 0x40, 0x50, 0x9a, 0x5e, 0x46, 0xb8, 0x3a, 0xb3, 0xc0, 0x19, 0x4b, 0xb4, 0xfc, 0xf6, 0x39,
	0x3d, 0x05, 0x37, 0x3f, 0xee, 0xfd, 0xa8, 0xdf, 0x38, 0x78, 0xef, 0x69, 0xab, 0xd6, 0xf4, 0x83,
	0xc0, 0x8f, 0xbc, 0x9b, 0x95, 0x0e, 0x15, 0x35, 0x9f, 0x0d, 0xe4, 0x5a, 0x4c, 0x49, 0xfb, 0xd9,
	0x6f, 0x7f, 0x7e, 0xab, 0xbd, 0x63, 0xde, 0xb4, 0x79, 0xd2, 0x0c, 0xfc, 0x96, 0x3d, 0x9c, 0xa2,
	0xb0, 0x3f, 0x1b, 0x9e, 0x3f, 0xcf, 0x3e, 0x53, 0x6e, 0x3b, 0x0b, 0xff, 0x01, 0x5a, 0xc5, 0xbf,
	0x23, 0xb8, 0x32, 0x7b, 0x9c, 0xd8, 0x7a, 0x65, 0x8e, 0x33, 0xc9, 0x54, 0xb6, 0x5f, 0xcb, 0x5f,
	0x70, 0xb3, 0x75, 0xfe, 0xca, 0xde, 0x37, 0x6f, 0x9d, 0x51, 0xd9, 0x04, 0xeb, 0x46, 0x05, 0x96,
	0xab, 0xdf, 0x3f, 0x47, 0xf9, 0x5f, 0x9f, 0xa3, 0xf2, 0xac, 0xe4, 0x1a, 0x6a, 0xa9, 0x3f, 0xfb,
	0x45, 0xd7, 0x0e, 0xd1, 0xc6, 0x17, 0xc7, 0x27, 0x46, 0xee, 0xc5, 0x89, 0x91, 0x7b, 0x79, 0x62,
	0xa0, 0x2f, 0x7b, 0x06, 0xfa, 0xae, 0x67, 0xa0, 0x9f, 0x7a, 0x06, 0x3a, 0xee, 0x19, 0xe8, 0x8f,
	0x9e, 0x81, 0xfe, 0xea, 0x19, 0xb9, 0x97, 0x3d, 0x03, 0x7d, 0x73, 0x6a, 0xe4, 0x8e, 0x4f, 0x8d,
	0xdc, 0x8b, 0x53, 0x23, 0xf7, 0xd1, 0x8e, 0xc7, 0xf8, 0x13, 0xcf, 0xea, 0xb0, 0x40, 0xd2, 0x38,
	0x4e, 0x03, 0xdb, 0xea, 0x70, 0xc0, 0xe2, 0xb0, 0xc6, 0x63, 0xd6, 0xf1, 0xdb, 0x34, 0xae, 0x0d,
	0xcc, 0x36, 0x6f, 0x7a, 0xcc, 0xa6, 0x4f, 0x65, 0xff, 0xcb, 0x3b, 0xfe, 0xf7, 0xd0, 0xbc, 0xa0,
	0x76, 0xc8, 0xad, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x80, 0x6d, 0x97, 0x6e, 0x5b, 0x08, 0x00,
	0x00,
}

func (x GroupDateByType) String() string {
	s, ok := GroupDateByType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *ListUsageDetailsReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListUsageDetailsReq)
	if !ok {
		that2, ok := that.(ListUsageDetailsReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.From.Equal(that1.From) {
		return false
	}
	if !this.To.Equal(that1.To) {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	return true
}
func (this *ListUsageDetailsResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListUsageDetailsResp)
	if !ok {
		that2, ok := that.(ListUsageDetailsResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.UsageItems) != len(that1.UsageItems) {
		return false
	}
	for i := range this.UsageItems {
		if !this.UsageItems[i].Equal(that1.UsageItems[i]) {
			return false
		}
	}
	return true
}
func (this *UsageItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UsageItem)
	if !ok {
		that2, ok := that.(UsageItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ObjectName != that1.ObjectName {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.UsageType != that1.UsageType {
		return false
	}
	if this.Quantity != that1.Quantity {
		return false
	}
	if this.UnitName != that1.UnitName {
		return false
	}
	if !this.StartTimestamp.Equal(that1.StartTimestamp) {
		return false
	}
	if !this.EndTimestamp.Equal(that1.EndTimestamp) {
		return false
	}
	if len(this.HourlyBreakdown) != len(that1.HourlyBreakdown) {
		return false
	}
	for i := range this.HourlyBreakdown {
		if !this.HourlyBreakdown[i].Equal(that1.HourlyBreakdown[i]) {
			return false
		}
	}
	if this.HourlyBreakdownQuery != that1.HourlyBreakdownQuery {
		return false
	}
	if this.MetricLabel != that1.MetricLabel {
		return false
	}
	return true
}
func (this *HourlyItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HourlyItem)
	if !ok {
		that2, ok := that.(HourlyItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StartTimestamp.Equal(that1.StartTimestamp) {
		return false
	}
	if !this.EndTimestamp.Equal(that1.EndTimestamp) {
		return false
	}
	if this.UnitName != that1.UnitName {
		return false
	}
	if this.Quantity != that1.Quantity {
		return false
	}
	if this.Deployment != that1.Deployment {
		return false
	}
	if this.Container != that1.Container {
		return false
	}
	return true
}
func (this *ListHourlyUsageDetailsReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListHourlyUsageDetailsReq)
	if !ok {
		that2, ok := that.(ListHourlyUsageDetailsReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Query != that1.Query {
		return false
	}
	return true
}
func (this *ListHourlyUsageDetailsResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListHourlyUsageDetailsResp)
	if !ok {
		that2, ok := that.(ListHourlyUsageDetailsResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.HourlyUsageItems) != len(that1.HourlyUsageItems) {
		return false
	}
	for i := range this.HourlyUsageItems {
		if !this.HourlyUsageItems[i].Equal(that1.HourlyUsageItems[i]) {
			return false
		}
	}
	return true
}
func (this *ListUsageDetailsReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&usage.ListUsageDetailsReq{")
	if this.From != nil {
		s = append(s, "From: "+fmt.Sprintf("%#v", this.From)+",\n")
	}
	if this.To != nil {
		s = append(s, "To: "+fmt.Sprintf("%#v", this.To)+",\n")
	}
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListUsageDetailsResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&usage.ListUsageDetailsResp{")
	if this.UsageItems != nil {
		s = append(s, "UsageItems: "+fmt.Sprintf("%#v", this.UsageItems)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UsageItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&usage.UsageItem{")
	s = append(s, "ObjectName: "+fmt.Sprintf("%#v", this.ObjectName)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "UsageType: "+fmt.Sprintf("%#v", this.UsageType)+",\n")
	s = append(s, "Quantity: "+fmt.Sprintf("%#v", this.Quantity)+",\n")
	s = append(s, "UnitName: "+fmt.Sprintf("%#v", this.UnitName)+",\n")
	if this.StartTimestamp != nil {
		s = append(s, "StartTimestamp: "+fmt.Sprintf("%#v", this.StartTimestamp)+",\n")
	}
	if this.EndTimestamp != nil {
		s = append(s, "EndTimestamp: "+fmt.Sprintf("%#v", this.EndTimestamp)+",\n")
	}
	if this.HourlyBreakdown != nil {
		s = append(s, "HourlyBreakdown: "+fmt.Sprintf("%#v", this.HourlyBreakdown)+",\n")
	}
	s = append(s, "HourlyBreakdownQuery: "+fmt.Sprintf("%#v", this.HourlyBreakdownQuery)+",\n")
	s = append(s, "MetricLabel: "+fmt.Sprintf("%#v", this.MetricLabel)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HourlyItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&usage.HourlyItem{")
	if this.StartTimestamp != nil {
		s = append(s, "StartTimestamp: "+fmt.Sprintf("%#v", this.StartTimestamp)+",\n")
	}
	if this.EndTimestamp != nil {
		s = append(s, "EndTimestamp: "+fmt.Sprintf("%#v", this.EndTimestamp)+",\n")
	}
	s = append(s, "UnitName: "+fmt.Sprintf("%#v", this.UnitName)+",\n")
	s = append(s, "Quantity: "+fmt.Sprintf("%#v", this.Quantity)+",\n")
	s = append(s, "Deployment: "+fmt.Sprintf("%#v", this.Deployment)+",\n")
	s = append(s, "Container: "+fmt.Sprintf("%#v", this.Container)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListHourlyUsageDetailsReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&usage.ListHourlyUsageDetailsReq{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListHourlyUsageDetailsResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&usage.ListHourlyUsageDetailsResp{")
	if this.HourlyUsageItems != nil {
		s = append(s, "HourlyUsageItems: "+fmt.Sprintf("%#v", this.HourlyUsageItems)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringCustomAggregatedApi(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CustomAggregatedUsageAPIClient is the client API for CustomAggregatedUsageAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CustomAggregatedUsageAPIClient interface {
	// List usage details
	//
	// x-displayName: "List usage details"
	// List usage details per tenant and namespace. Some usage have only sense in the system namespace and this selector has no effect on it.
	ListUsageDetails(ctx context.Context, in *ListUsageDetailsReq, opts ...grpc.CallOption) (*ListUsageDetailsResp, error)
	// ListHourlyUsageDetails
	//
	// x-displayName: "List hourly usage details"
	// List the usage divided by hour. The usage is hourly aggregated, from the start of utc hour
	// to the end of utc hour. It is used to see the detailed breakdown of the usage received from ListUsageDetails
	ListHourlyUsageDetails(ctx context.Context, in *ListHourlyUsageDetailsReq, opts ...grpc.CallOption) (*ListHourlyUsageDetailsResp, error)
}

type customAggregatedUsageAPIClient struct {
	cc *grpc.ClientConn
}

func NewCustomAggregatedUsageAPIClient(cc *grpc.ClientConn) CustomAggregatedUsageAPIClient {
	return &customAggregatedUsageAPIClient{cc}
}

func (c *customAggregatedUsageAPIClient) ListUsageDetails(ctx context.Context, in *ListUsageDetailsReq, opts ...grpc.CallOption) (*ListUsageDetailsResp, error) {
	out := new(ListUsageDetailsResp)
	err := c.cc.Invoke(ctx, "/ves.io.schema.usage.CustomAggregatedUsageAPI/ListUsageDetails", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customAggregatedUsageAPIClient) ListHourlyUsageDetails(ctx context.Context, in *ListHourlyUsageDetailsReq, opts ...grpc.CallOption) (*ListHourlyUsageDetailsResp, error) {
	out := new(ListHourlyUsageDetailsResp)
	err := c.cc.Invoke(ctx, "/ves.io.schema.usage.CustomAggregatedUsageAPI/ListHourlyUsageDetails", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CustomAggregatedUsageAPIServer is the server API for CustomAggregatedUsageAPI service.
type CustomAggregatedUsageAPIServer interface {
	// List usage details
	//
	// x-displayName: "List usage details"
	// List usage details per tenant and namespace. Some usage have only sense in the system namespace and this selector has no effect on it.
	ListUsageDetails(context.Context, *ListUsageDetailsReq) (*ListUsageDetailsResp, error)
	// ListHourlyUsageDetails
	//
	// x-displayName: "List hourly usage details"
	// List the usage divided by hour. The usage is hourly aggregated, from the start of utc hour
	// to the end of utc hour. It is used to see the detailed breakdown of the usage received from ListUsageDetails
	ListHourlyUsageDetails(context.Context, *ListHourlyUsageDetailsReq) (*ListHourlyUsageDetailsResp, error)
}

// UnimplementedCustomAggregatedUsageAPIServer can be embedded to have forward compatible implementations.
type UnimplementedCustomAggregatedUsageAPIServer struct {
}

func (*UnimplementedCustomAggregatedUsageAPIServer) ListUsageDetails(ctx context.Context, req *ListUsageDetailsReq) (*ListUsageDetailsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUsageDetails not implemented")
}
func (*UnimplementedCustomAggregatedUsageAPIServer) ListHourlyUsageDetails(ctx context.Context, req *ListHourlyUsageDetailsReq) (*ListHourlyUsageDetailsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListHourlyUsageDetails not implemented")
}

func RegisterCustomAggregatedUsageAPIServer(s *grpc.Server, srv CustomAggregatedUsageAPIServer) {
	s.RegisterService(&_CustomAggregatedUsageAPI_serviceDesc, srv)
}

func _CustomAggregatedUsageAPI_ListUsageDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUsageDetailsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAggregatedUsageAPIServer).ListUsageDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.usage.CustomAggregatedUsageAPI/ListUsageDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAggregatedUsageAPIServer).ListUsageDetails(ctx, req.(*ListUsageDetailsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomAggregatedUsageAPI_ListHourlyUsageDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListHourlyUsageDetailsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomAggregatedUsageAPIServer).ListHourlyUsageDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.usage.CustomAggregatedUsageAPI/ListHourlyUsageDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomAggregatedUsageAPIServer).ListHourlyUsageDetails(ctx, req.(*ListHourlyUsageDetailsReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _CustomAggregatedUsageAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ves.io.schema.usage.CustomAggregatedUsageAPI",
	HandlerType: (*CustomAggregatedUsageAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListUsageDetails",
			Handler:    _CustomAggregatedUsageAPI_ListUsageDetails_Handler,
		},
		{
			MethodName: "ListHourlyUsageDetails",
			Handler:    _CustomAggregatedUsageAPI_ListHourlyUsageDetails_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ves.io/schema/usage/custom_aggregated_api.proto",
}

func (m *ListUsageDetailsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUsageDetailsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListUsageDetailsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintCustomAggregatedApi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x1a
	}
	if m.To != nil {
		{
			size, err := m.To.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCustomAggregatedApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.From != nil {
		{
			size, err := m.From.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCustomAggregatedApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListUsageDetailsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUsageDetailsResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListUsageDetailsResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UsageItems) > 0 {
		for iNdEx := len(m.UsageItems) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UsageItems[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCustomAggregatedApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UsageItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsageItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsageItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MetricLabel) > 0 {
		i -= len(m.MetricLabel)
		copy(dAtA[i:], m.MetricLabel)
		i = encodeVarintCustomAggregatedApi(dAtA, i, uint64(len(m.MetricLabel)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.HourlyBreakdownQuery) > 0 {
		i -= len(m.HourlyBreakdownQuery)
		copy(dAtA[i:], m.HourlyBreakdownQuery)
		i = encodeVarintCustomAggregatedApi(dAtA, i, uint64(len(m.HourlyBreakdownQuery)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.HourlyBreakdown) > 0 {
		for iNdEx := len(m.HourlyBreakdown) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HourlyBreakdown[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCustomAggregatedApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.EndTimestamp != nil {
		{
			size, err := m.EndTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCustomAggregatedApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.StartTimestamp != nil {
		{
			size, err := m.StartTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCustomAggregatedApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.UnitName) > 0 {
		i -= len(m.UnitName)
		copy(dAtA[i:], m.UnitName)
		i = encodeVarintCustomAggregatedApi(dAtA, i, uint64(len(m.UnitName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Quantity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Quantity))))
		i--
		dAtA[i] = 0x21
	}
	if len(m.UsageType) > 0 {
		i -= len(m.UsageType)
		copy(dAtA[i:], m.UsageType)
		i = encodeVarintCustomAggregatedApi(dAtA, i, uint64(len(m.UsageType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintCustomAggregatedApi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ObjectName) > 0 {
		i -= len(m.ObjectName)
		copy(dAtA[i:], m.ObjectName)
		i = encodeVarintCustomAggregatedApi(dAtA, i, uint64(len(m.ObjectName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HourlyItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HourlyItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HourlyItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Container) > 0 {
		i -= len(m.Container)
		copy(dAtA[i:], m.Container)
		i = encodeVarintCustomAggregatedApi(dAtA, i, uint64(len(m.Container)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Deployment) > 0 {
		i -= len(m.Deployment)
		copy(dAtA[i:], m.Deployment)
		i = encodeVarintCustomAggregatedApi(dAtA, i, uint64(len(m.Deployment)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Quantity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Quantity))))
		i--
		dAtA[i] = 0x21
	}
	if len(m.UnitName) > 0 {
		i -= len(m.UnitName)
		copy(dAtA[i:], m.UnitName)
		i = encodeVarintCustomAggregatedApi(dAtA, i, uint64(len(m.UnitName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.EndTimestamp != nil {
		{
			size, err := m.EndTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCustomAggregatedApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.StartTimestamp != nil {
		{
			size, err := m.StartTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCustomAggregatedApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListHourlyUsageDetailsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListHourlyUsageDetailsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListHourlyUsageDetailsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintCustomAggregatedApi(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintCustomAggregatedApi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListHourlyUsageDetailsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListHourlyUsageDetailsResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListHourlyUsageDetailsResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HourlyUsageItems) > 0 {
		for iNdEx := len(m.HourlyUsageItems) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HourlyUsageItems[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCustomAggregatedApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintCustomAggregatedApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovCustomAggregatedApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ListUsageDetailsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovCustomAggregatedApi(uint64(l))
	}
	if m.To != nil {
		l = m.To.Size()
		n += 1 + l + sovCustomAggregatedApi(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovCustomAggregatedApi(uint64(l))
	}
	return n
}

func (m *ListUsageDetailsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UsageItems) > 0 {
		for _, e := range m.UsageItems {
			l = e.Size()
			n += 1 + l + sovCustomAggregatedApi(uint64(l))
		}
	}
	return n
}

func (m *UsageItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ObjectName)
	if l > 0 {
		n += 1 + l + sovCustomAggregatedApi(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovCustomAggregatedApi(uint64(l))
	}
	l = len(m.UsageType)
	if l > 0 {
		n += 1 + l + sovCustomAggregatedApi(uint64(l))
	}
	if m.Quantity != 0 {
		n += 9
	}
	l = len(m.UnitName)
	if l > 0 {
		n += 1 + l + sovCustomAggregatedApi(uint64(l))
	}
	if m.StartTimestamp != nil {
		l = m.StartTimestamp.Size()
		n += 1 + l + sovCustomAggregatedApi(uint64(l))
	}
	if m.EndTimestamp != nil {
		l = m.EndTimestamp.Size()
		n += 1 + l + sovCustomAggregatedApi(uint64(l))
	}
	if len(m.HourlyBreakdown) > 0 {
		for _, e := range m.HourlyBreakdown {
			l = e.Size()
			n += 1 + l + sovCustomAggregatedApi(uint64(l))
		}
	}
	l = len(m.HourlyBreakdownQuery)
	if l > 0 {
		n += 1 + l + sovCustomAggregatedApi(uint64(l))
	}
	l = len(m.MetricLabel)
	if l > 0 {
		n += 1 + l + sovCustomAggregatedApi(uint64(l))
	}
	return n
}

func (m *HourlyItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartTimestamp != nil {
		l = m.StartTimestamp.Size()
		n += 1 + l + sovCustomAggregatedApi(uint64(l))
	}
	if m.EndTimestamp != nil {
		l = m.EndTimestamp.Size()
		n += 1 + l + sovCustomAggregatedApi(uint64(l))
	}
	l = len(m.UnitName)
	if l > 0 {
		n += 1 + l + sovCustomAggregatedApi(uint64(l))
	}
	if m.Quantity != 0 {
		n += 9
	}
	l = len(m.Deployment)
	if l > 0 {
		n += 1 + l + sovCustomAggregatedApi(uint64(l))
	}
	l = len(m.Container)
	if l > 0 {
		n += 1 + l + sovCustomAggregatedApi(uint64(l))
	}
	return n
}

func (m *ListHourlyUsageDetailsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovCustomAggregatedApi(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovCustomAggregatedApi(uint64(l))
	}
	return n
}

func (m *ListHourlyUsageDetailsResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.HourlyUsageItems) > 0 {
		for _, e := range m.HourlyUsageItems {
			l = e.Size()
			n += 1 + l + sovCustomAggregatedApi(uint64(l))
		}
	}
	return n
}

func sovCustomAggregatedApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCustomAggregatedApi(x uint64) (n int) {
	return sovCustomAggregatedApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ListUsageDetailsReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListUsageDetailsReq{`,
		`From:` + strings.Replace(fmt.Sprintf("%v", this.From), "Timestamp", "types.Timestamp", 1) + `,`,
		`To:` + strings.Replace(fmt.Sprintf("%v", this.To), "Timestamp", "types.Timestamp", 1) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListUsageDetailsResp) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForUsageItems := "[]*UsageItem{"
	for _, f := range this.UsageItems {
		repeatedStringForUsageItems += strings.Replace(f.String(), "UsageItem", "UsageItem", 1) + ","
	}
	repeatedStringForUsageItems += "}"
	s := strings.Join([]string{`&ListUsageDetailsResp{`,
		`UsageItems:` + repeatedStringForUsageItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *UsageItem) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHourlyBreakdown := "[]*HourlyItem{"
	for _, f := range this.HourlyBreakdown {
		repeatedStringForHourlyBreakdown += strings.Replace(f.String(), "HourlyItem", "HourlyItem", 1) + ","
	}
	repeatedStringForHourlyBreakdown += "}"
	s := strings.Join([]string{`&UsageItem{`,
		`ObjectName:` + fmt.Sprintf("%v", this.ObjectName) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`UsageType:` + fmt.Sprintf("%v", this.UsageType) + `,`,
		`Quantity:` + fmt.Sprintf("%v", this.Quantity) + `,`,
		`UnitName:` + fmt.Sprintf("%v", this.UnitName) + `,`,
		`StartTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.StartTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`EndTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.EndTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`HourlyBreakdown:` + repeatedStringForHourlyBreakdown + `,`,
		`HourlyBreakdownQuery:` + fmt.Sprintf("%v", this.HourlyBreakdownQuery) + `,`,
		`MetricLabel:` + fmt.Sprintf("%v", this.MetricLabel) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HourlyItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HourlyItem{`,
		`StartTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.StartTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`EndTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.EndTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`UnitName:` + fmt.Sprintf("%v", this.UnitName) + `,`,
		`Quantity:` + fmt.Sprintf("%v", this.Quantity) + `,`,
		`Deployment:` + fmt.Sprintf("%v", this.Deployment) + `,`,
		`Container:` + fmt.Sprintf("%v", this.Container) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListHourlyUsageDetailsReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListHourlyUsageDetailsReq{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListHourlyUsageDetailsResp) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHourlyUsageItems := "[]*HourlyItem{"
	for _, f := range this.HourlyUsageItems {
		repeatedStringForHourlyUsageItems += strings.Replace(f.String(), "HourlyItem", "HourlyItem", 1) + ","
	}
	repeatedStringForHourlyUsageItems += "}"
	s := strings.Join([]string{`&ListHourlyUsageDetailsResp{`,
		`HourlyUsageItems:` + repeatedStringForHourlyUsageItems + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringCustomAggregatedApi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ListUsageDetailsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCustomAggregatedApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUsageDetailsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUsageDetailsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomAggregatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &types.Timestamp{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomAggregatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.To == nil {
				m.To = &types.Timestamp{}
			}
			if err := m.To.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomAggregatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCustomAggregatedApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUsageDetailsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCustomAggregatedApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUsageDetailsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUsageDetailsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomAggregatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsageItems = append(m.UsageItems, &UsageItem{})
			if err := m.UsageItems[len(m.UsageItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCustomAggregatedApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsageItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCustomAggregatedApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UsageItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UsageItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomAggregatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomAggregatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomAggregatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsageType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Quantity = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomAggregatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnitName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomAggregatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTimestamp == nil {
				m.StartTimestamp = &types.Timestamp{}
			}
			if err := m.StartTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomAggregatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTimestamp == nil {
				m.EndTimestamp = &types.Timestamp{}
			}
			if err := m.EndTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HourlyBreakdown", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomAggregatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HourlyBreakdown = append(m.HourlyBreakdown, &HourlyItem{})
			if err := m.HourlyBreakdown[len(m.HourlyBreakdown)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HourlyBreakdownQuery", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomAggregatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HourlyBreakdownQuery = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomAggregatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCustomAggregatedApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HourlyItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCustomAggregatedApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HourlyItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HourlyItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomAggregatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTimestamp == nil {
				m.StartTimestamp = &types.Timestamp{}
			}
			if err := m.StartTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomAggregatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTimestamp == nil {
				m.EndTimestamp = &types.Timestamp{}
			}
			if err := m.EndTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomAggregatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnitName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Quantity = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomAggregatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deployment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomAggregatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Container = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCustomAggregatedApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListHourlyUsageDetailsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCustomAggregatedApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListHourlyUsageDetailsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListHourlyUsageDetailsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomAggregatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomAggregatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCustomAggregatedApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListHourlyUsageDetailsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCustomAggregatedApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListHourlyUsageDetailsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListHourlyUsageDetailsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HourlyUsageItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomAggregatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HourlyUsageItems = append(m.HourlyUsageItems, &HourlyItem{})
			if err := m.HourlyUsageItems[len(m.HourlyUsageItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCustomAggregatedApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCustomAggregatedApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCustomAggregatedApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCustomAggregatedApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCustomAggregatedApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCustomAggregatedApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCustomAggregatedApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCustomAggregatedApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCustomAggregatedApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCustomAggregatedApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCustomAggregatedApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCustomAggregatedApi = fmt.Errorf("proto: unexpected end of group")
)
