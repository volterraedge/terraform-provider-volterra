// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package usage

import (
	"bytes"
	"context"
	"fmt"
	io "io"
	"net/http"
	"strings"

	"github.com/gogo/protobuf/proto"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"google.golang.org/grpc"

	"gopkg.volterra.us/stdlib/client"
	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/errors"
	"gopkg.volterra.us/stdlib/server"
	"gopkg.volterra.us/stdlib/svcfw"
)

var (
	_ = fmt.Sprintf("dummy for fmt import use")
)

// Create CustomAggregatedUsageAPI GRPC Client satisfying server.CustomClient
type CustomAggregatedUsageAPIGrpcClient struct {
	conn       *grpc.ClientConn
	grpcClient CustomAggregatedUsageAPIClient
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error)
}

func (c *CustomAggregatedUsageAPIGrpcClient) doRPCListHourlyUsageDetails(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &ListHourlyUsageDetailsReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.usage.ListHourlyUsageDetailsReq", yamlReq)
	}
	rsp, err := c.grpcClient.ListHourlyUsageDetails(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAggregatedUsageAPIGrpcClient) doRPCListUsageDetails(ctx context.Context, yamlReq string, opts ...grpc.CallOption) (proto.Message, error) {
	req := &ListUsageDetailsReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.usage.ListUsageDetailsReq", yamlReq)
	}
	rsp, err := c.grpcClient.ListUsageDetails(ctx, req, opts...)
	return rsp, err
}

func (c *CustomAggregatedUsageAPIGrpcClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}
	if cco.YAMLReq == "" {
		return nil, fmt.Errorf("Error, empty request body")
	}
	ctx = client.AddHdrsToCtx(cco.Headers, ctx)

	rsp, err := rpcFn(ctx, cco.YAMLReq, cco.GrpcCallOpts...)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using GRPC")
	}
	if cco.OutCallResponse != nil {
		cco.OutCallResponse.ProtoMsg = rsp
	}
	return rsp, nil
}

func NewCustomAggregatedUsageAPIGrpcClient(cc *grpc.ClientConn) server.CustomClient {
	ccl := &CustomAggregatedUsageAPIGrpcClient{
		conn:       cc,
		grpcClient: NewCustomAggregatedUsageAPIClient(cc),
	}
	rpcFns := make(map[string]func(context.Context, string, ...grpc.CallOption) (proto.Message, error))
	rpcFns["ListHourlyUsageDetails"] = ccl.doRPCListHourlyUsageDetails

	rpcFns["ListUsageDetails"] = ccl.doRPCListUsageDetails

	ccl.rpcFns = rpcFns

	return ccl
}

// Create CustomAggregatedUsageAPI REST Client satisfying server.CustomClient
type CustomAggregatedUsageAPIRestClient struct {
	baseURL string
	client  http.Client
	// map of rpc name to its invocation
	rpcFns map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error)
}

func (c *CustomAggregatedUsageAPIRestClient) doRPCListHourlyUsageDetails(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &ListHourlyUsageDetailsReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.usage.ListHourlyUsageDetailsReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("query", fmt.Sprintf("%v", req.Query))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &ListHourlyUsageDetailsResp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.usage.ListHourlyUsageDetailsResp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAggregatedUsageAPIRestClient) doRPCListUsageDetails(ctx context.Context, callOpts *server.CustomCallOpts) (proto.Message, error) {
	if callOpts.URI == "" {
		return nil, fmt.Errorf("Error, URI should be specified, got empty")
	}
	url := fmt.Sprintf("%s%s", c.baseURL, callOpts.URI)

	yamlReq := callOpts.YAMLReq
	req := &ListUsageDetailsReq{}
	if err := codec.FromYAML(yamlReq, req); err != nil {
		return nil, fmt.Errorf("YAML Request %s is not of type *ves.io.schema.usage.ListUsageDetailsReq: %s", yamlReq, err)
	}

	var hReq *http.Request
	hm := strings.ToLower(callOpts.HTTPMethod)
	switch hm {
	case "post", "put":
		jsn, err := codec.ToJSON(req, codec.ToWithUseProtoFieldName())
		if err != nil {
			return nil, errors.Wrap(err, "Custom RestClient converting YAML to JSON")
		}
		var op string
		if hm == "post" {
			op = http.MethodPost
		} else {
			op = http.MethodPut
		}
		newReq, err := http.NewRequest(op, url, bytes.NewBuffer([]byte(jsn)))
		if err != nil {
			return nil, errors.Wrapf(err, "Creating new HTTP %s request for custom API", op)
		}
		hReq = newReq
	case "get":
		newReq, err := http.NewRequest(http.MethodGet, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP GET request for custom API")
		}
		hReq = newReq
		q := hReq.URL.Query()
		_ = q
		q.Add("from", fmt.Sprintf("%v", req.From))
		q.Add("namespace", fmt.Sprintf("%v", req.Namespace))
		q.Add("to", fmt.Sprintf("%v", req.To))

		hReq.URL.RawQuery += q.Encode()
	case "delete":
		newReq, err := http.NewRequest(http.MethodDelete, url, nil)
		if err != nil {
			return nil, errors.Wrap(err, "Creating new HTTP DELETE request for custom API")
		}
		hReq = newReq
	default:
		return nil, fmt.Errorf("Error, invalid/empty HTTPMethod(%s) specified, should be POST|DELETE|GET", callOpts.HTTPMethod)
	}
	hReq = hReq.WithContext(ctx)
	hReq.Header.Set("Content-Type", "application/json")
	client.AddHdrsToReq(callOpts.Headers, hReq)

	rsp, err := c.client.Do(hReq)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient")
	}
	defer rsp.Body.Close()

	// checking whether the status code is a successful status code (2xx series)
	if rsp.StatusCode < 200 || rsp.StatusCode > 299 {
		body, err := io.ReadAll(rsp.Body)
		return nil, fmt.Errorf("Unsuccessful custom API %s on %s, status code %d, body %s, err %s", callOpts.HTTPMethod, callOpts.URI, rsp.StatusCode, body, err)
	}

	body, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, errors.Wrap(err, "Custom API RestClient read body")
	}
	pbRsp := &ListUsageDetailsResp{}
	if err := codec.FromJSON(string(body), pbRsp); err != nil {
		return nil, errors.Wrapf(err, "JSON Response %s is not of type *ves.io.schema.usage.ListUsageDetailsResp", body)

	}
	if callOpts.OutCallResponse != nil {
		callOpts.OutCallResponse.ProtoMsg = pbRsp
		callOpts.OutCallResponse.JSON = string(body)
	}
	return pbRsp, nil
}

func (c *CustomAggregatedUsageAPIRestClient) DoRPC(ctx context.Context, rpc string, opts ...server.CustomCallOpt) (proto.Message, error) {
	rpcFn, exists := c.rpcFns[rpc]
	if !exists {
		return nil, fmt.Errorf("Error, no such rpc %s", rpc)
	}
	cco := server.NewCustomCallOpts()
	for _, opt := range opts {
		opt(cco)
	}

	rsp, err := rpcFn(ctx, cco)
	if err != nil {
		return nil, errors.Wrap(err, "Doing custom RPC using Rest")
	}
	return rsp, nil
}

func NewCustomAggregatedUsageAPIRestClient(baseURL string, hc http.Client) server.CustomClient {
	ccl := &CustomAggregatedUsageAPIRestClient{
		baseURL: baseURL,
		client:  hc,
	}

	rpcFns := make(map[string]func(context.Context, *server.CustomCallOpts) (proto.Message, error))
	rpcFns["ListHourlyUsageDetails"] = ccl.doRPCListHourlyUsageDetails

	rpcFns["ListUsageDetails"] = ccl.doRPCListUsageDetails

	ccl.rpcFns = rpcFns

	return ccl
}

// Create customAggregatedUsageAPIInprocClient

// INPROC Client (satisfying CustomAggregatedUsageAPIClient interface)
type customAggregatedUsageAPIInprocClient struct {
	CustomAggregatedUsageAPIServer
}

func (c *customAggregatedUsageAPIInprocClient) ListHourlyUsageDetails(ctx context.Context, in *ListHourlyUsageDetailsReq, opts ...grpc.CallOption) (*ListHourlyUsageDetailsResp, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.usage.CustomAggregatedUsageAPI.ListHourlyUsageDetails")
	return c.CustomAggregatedUsageAPIServer.ListHourlyUsageDetails(ctx, in)
}
func (c *customAggregatedUsageAPIInprocClient) ListUsageDetails(ctx context.Context, in *ListUsageDetailsReq, opts ...grpc.CallOption) (*ListUsageDetailsResp, error) {
	ctx = server.ContextWithRpcFQN(ctx, "ves.io.schema.usage.CustomAggregatedUsageAPI.ListUsageDetails")
	return c.CustomAggregatedUsageAPIServer.ListUsageDetails(ctx, in)
}

func NewCustomAggregatedUsageAPIInprocClient(svc svcfw.Service) CustomAggregatedUsageAPIClient {
	return &customAggregatedUsageAPIInprocClient{CustomAggregatedUsageAPIServer: NewCustomAggregatedUsageAPIServer(svc)}
}

// RegisterGwCustomAggregatedUsageAPIHandler registers with grpc-gw with an inproc-client backing so that
// rest to grpc happens without a grpc.Dial (thus avoiding additional certs for mTLS)
func RegisterGwCustomAggregatedUsageAPIHandler(ctx context.Context, mux *runtime.ServeMux, svc interface{}) error {
	s, ok := svc.(svcfw.Service)
	if !ok {
		return fmt.Errorf("svc is not svcfw.Service")
	}
	return RegisterCustomAggregatedUsageAPIHandlerClient(ctx, mux, NewCustomAggregatedUsageAPIInprocClient(s))
}

// Create customAggregatedUsageAPISrv

// SERVER (satisfying CustomAggregatedUsageAPIServer interface)
type customAggregatedUsageAPISrv struct {
	svc svcfw.Service
}

func (s *customAggregatedUsageAPISrv) ListHourlyUsageDetails(ctx context.Context, in *ListHourlyUsageDetailsReq) (*ListHourlyUsageDetailsResp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.usage.CustomAggregatedUsageAPI")
	cah, ok := ah.(CustomAggregatedUsageAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAggregatedUsageAPIServer", ah)
	}

	var (
		rsp *ListHourlyUsageDetailsResp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.usage.ListHourlyUsageDetailsReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAggregatedUsageAPI.ListHourlyUsageDetails' operation on 'usage'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.usage.CustomAggregatedUsageAPI.ListHourlyUsageDetails"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.ListHourlyUsageDetails(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.usage.ListHourlyUsageDetailsResp", rsp)...)

	return rsp, nil
}
func (s *customAggregatedUsageAPISrv) ListUsageDetails(ctx context.Context, in *ListUsageDetailsReq) (*ListUsageDetailsResp, error) {
	ah := s.svc.GetAPIHandler("ves.io.schema.usage.CustomAggregatedUsageAPI")
	cah, ok := ah.(CustomAggregatedUsageAPIServer)
	if !ok {
		return nil, fmt.Errorf("ah %v is not of type *CustomAggregatedUsageAPIServer", ah)
	}

	var (
		rsp *ListUsageDetailsResp
		err error
	)

	bodyFields := svcfw.GenAuditReqBodyFields(ctx, s.svc, "ves.io.schema.usage.ListUsageDetailsReq", in)
	defer func() {
		if len(bodyFields) > 0 {
			server.ExtendAPIAudit(ctx, svcfw.PublicAPIBodyLog.Uid, bodyFields)
		}
		userMsg := "The 'CustomAggregatedUsageAPI.ListUsageDetails' operation on 'usage'"
		if err == nil {
			userMsg += " was successfully performed."
		} else {
			userMsg += " failed to be performed."
		}
		server.AddUserMsgToAPIAudit(ctx, userMsg)
	}()

	if err := svcfw.FillOneofDefaultChoice(ctx, s.svc, in); err != nil {
		err = server.MaybePublicRestError(ctx, errors.Wrapf(err, "Filling oneof default choice"))
		return nil, server.GRPCStatusFromError(err).Err()
	}

	if s.svc.Config().EnableAPIValidation {
		if rvFn := s.svc.GetRPCValidator("ves.io.schema.usage.CustomAggregatedUsageAPI.ListUsageDetails"); rvFn != nil {
			if verr := rvFn(ctx, in); verr != nil {
				err = server.MaybePublicRestError(ctx, errors.Wrapf(verr, "Validating Request"))
				return nil, server.GRPCStatusFromError(err).Err()
			}
		}
	}

	rsp, err = cah.ListUsageDetails(ctx, in)
	if err != nil {
		return rsp, server.GRPCStatusFromError(server.MaybePublicRestError(ctx, err)).Err()
	}

	bodyFields = append(bodyFields, svcfw.GenAuditRspBodyFields(ctx, s.svc, "ves.io.schema.usage.ListUsageDetailsResp", rsp)...)

	return rsp, nil
}

func NewCustomAggregatedUsageAPIServer(svc svcfw.Service) CustomAggregatedUsageAPIServer {
	return &customAggregatedUsageAPISrv{svc: svc}
}

var CustomAggregatedUsageAPISwaggerJSON string = `{
    "swagger": "2.0",
    "info": {
        "title": "Usage related Customer APIs",
        "description": "Resource usage and pricing custom APIs",
        "version": "version not set"
    },
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ],
    "tags": [],
    "paths": {
        "/public/namespaces/{namespace}/hourly_usage_details": {
            "post": {
                "summary": "List hourly usage details",
                "description": "List the usage divided by hour. The usage is hourly aggregated, from the start of utc hour\nto the end of utc hour. It is used to see the detailed breakdown of the usage received from ListUsageDetails",
                "operationId": "ves.io.schema.usage.CustomAggregatedUsageAPI.ListHourlyUsageDetails",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/usageListHourlyUsageDetailsResp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"system\"\nNamespace",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/usageListHourlyUsageDetailsReq"
                        }
                    }
                ],
                "tags": [
                    "CustomAggregatedUsageAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-usage-customaggregatedusageapi-listhourlyusagedetails"
                },
                "x-ves-proto-rpc": "ves.io.schema.usage.CustomAggregatedUsageAPI.ListHourlyUsageDetails"
            },
            "x-displayname": "Aggregated usage",
            "x-ves-proto-service": "ves.io.schema.usage.CustomAggregatedUsageAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        },
        "/public/namespaces/{namespace}/usage_details": {
            "post": {
                "summary": "List usage details",
                "description": "List usage details per tenant and namespace. Some usage have only sense in the system namespace and this selector has no effect on it.",
                "operationId": "ves.io.schema.usage.CustomAggregatedUsageAPI.ListUsageDetails",
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/usageListUsageDetailsResp"
                        }
                    },
                    "401": {
                        "description": "Returned when operation is not authorized",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "403": {
                        "description": "Returned when there is no permission to access resource",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "404": {
                        "description": "Returned when resource is not found",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "409": {
                        "description": "Returned when operation on resource is conflicting with current value",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "429": {
                        "description": "Returned when operation has been rejected as it is happening too frequently",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "500": {
                        "description": "Returned when server encountered an error in processing API",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "503": {
                        "description": "Returned when service is unavailable temporarily",
                        "schema": {
                            "format": "string"
                        }
                    },
                    "504": {
                        "description": "Returned when server timed out processing request",
                        "schema": {
                            "format": "string"
                        }
                    }
                },
                "parameters": [
                    {
                        "name": "namespace",
                        "description": "Namespace\n\nx-example: \"system\"\nNamespace to be considered",
                        "in": "path",
                        "required": true,
                        "type": "string",
                        "x-displayname": "Namespace"
                    },
                    {
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/usageListUsageDetailsReq"
                        }
                    }
                ],
                "tags": [
                    "CustomAggregatedUsageAPI"
                ],
                "externalDocs": {
                    "description": "Examples of this operation",
                    "url": "https://docs.cloud.f5.com/docs-v2/platform/reference/api-ref/ves-io-schema-usage-customaggregatedusageapi-listusagedetails"
                },
                "x-ves-proto-rpc": "ves.io.schema.usage.CustomAggregatedUsageAPI.ListUsageDetails"
            },
            "x-displayname": "Aggregated usage",
            "x-ves-proto-service": "ves.io.schema.usage.CustomAggregatedUsageAPI",
            "x-ves-proto-service-type": "CUSTOM_PUBLIC"
        }
    },
    "definitions": {
        "usageHourlyItem": {
            "type": "object",
            "description": "One line of usage by an hour. One hour as the least resolution.",
            "title": "Hourly usage item",
            "x-displayname": "Hourly usage item",
            "x-ves-proto-message": "ves.io.schema.usage.HourlyItem",
            "properties": {
                "container": {
                    "type": "string",
                    "description": " Container name if this item correspond to the container usage. Otherwise it's empty\n\nExample: - \"pa4-deployment1-abcd12\"-",
                    "title": "Container",
                    "x-displayname": "Container",
                    "x-ves-example": "pa4-deployment1-abcd12"
                },
                "deployment": {
                    "type": "string",
                    "description": " [x-required]\n Deployment name if this item correspond to the container usage. Otherwise it's empty\n\nExample: - \"pa4-deployment1\"-\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Deployment",
                    "x-displayname": "Deployment",
                    "x-ves-example": "pa4-deployment1",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "end_timestamp": {
                    "type": "string",
                    "description": " End of the time unit\n\nExample: - \"2020-04-20T12:32:51.341959216Z\"-",
                    "title": "Timestamp end",
                    "format": "date-time",
                    "x-displayname": "End",
                    "x-ves-example": "2020-04-20T12:32:51.341959216Z"
                },
                "quantity": {
                    "type": "number",
                    "description": " Quantity incurred\n\nExample: - \"100\"-",
                    "title": "Quantity",
                    "format": "double",
                    "x-displayname": "Quantity",
                    "x-ves-example": "100"
                },
                "start_timestamp": {
                    "type": "string",
                    "description": " Beginning of the time unit\n\nExample: - \"2020-04-20T12:32:51.341959216Z\"-",
                    "title": "Timestamp start",
                    "format": "date-time",
                    "x-displayname": "Start",
                    "x-ves-example": "2020-04-20T12:32:51.341959216Z"
                },
                "unit_name": {
                    "type": "string",
                    "description": " Name of the quantity unit\n\nExample: - \"MB\"-",
                    "title": "Unit name",
                    "x-displayname": "Unit name",
                    "x-ves-example": "MB"
                }
            }
        },
        "usageListHourlyUsageDetailsReq": {
            "type": "object",
            "description": "Request body for ListHourlyUsageDetails rpc method",
            "title": "ListHourlyUsageDetailsReq",
            "x-displayname": "List Hourly Usage Details Request",
            "x-ves-proto-message": "ves.io.schema.usage.ListHourlyUsageDetailsReq",
            "properties": {
                "namespace": {
                    "type": "string",
                    "description": " Namespace\n\nExample: - \"system\"-",
                    "title": "Namespace",
                    "x-displayname": "namespace",
                    "x-ves-example": "system"
                },
                "query": {
                    "type": "string",
                    "description": " Encoded query which is passed as is to barracute daemon\n\nExample: - \"{'MetricLabel':'label'}\"-",
                    "title": "query",
                    "x-displayname": "query",
                    "x-ves-example": "{'MetricLabel':'label'}"
                }
            }
        },
        "usageListHourlyUsageDetailsResp": {
            "type": "object",
            "description": "Response body for ListHourlyUsageDetails rpc method",
            "title": "List Hourly Usage Details Response",
            "x-displayname": "List Hourly Usage Details Response",
            "x-ves-proto-message": "ves.io.schema.usage.ListHourlyUsageDetailsResp",
            "properties": {
                "hourly_usage_items": {
                    "type": "array",
                    "description": " Array of usage by hour in the period from the query",
                    "title": "Usage items",
                    "items": {
                        "$ref": "#/definitions/usageHourlyItem"
                    },
                    "x-displayname": "Usage items"
                }
            }
        },
        "usageListUsageDetailsReq": {
            "type": "object",
            "description": "Request message to get usage details",
            "title": "List usage details request",
            "x-displayname": "List usage details request",
            "x-ves-proto-message": "ves.io.schema.usage.ListUsageDetailsReq",
            "properties": {
                "from": {
                    "type": "string",
                    "description": " Indicates the \"from\" part of the request\n\nExample: - \"2020-04-20T12:32:51.341959216Z\"-",
                    "title": "Timestamp from",
                    "format": "date-time",
                    "x-displayname": "From",
                    "x-ves-example": "2020-04-20T12:32:51.341959216Z"
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace to be considered\n\nExample: - \"system\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "system"
                },
                "to": {
                    "type": "string",
                    "description": " Indicates the \"to\" part of the request\n\nExample: - \"2020-04-20T12:32:51.341959216Z\"-",
                    "title": "Timestamp to",
                    "format": "date-time",
                    "x-displayname": "To",
                    "x-ves-example": "2020-04-20T12:32:51.341959216Z"
                }
            }
        },
        "usageListUsageDetailsResp": {
            "type": "object",
            "description": "Response message to get usage details",
            "title": "List usage details response",
            "x-displayname": "List usage details response",
            "x-ves-proto-message": "ves.io.schema.usage.ListUsageDetailsResp",
            "properties": {
                "usage_items": {
                    "type": "array",
                    "description": " Collection of usage items, lines of response",
                    "title": "Usage items",
                    "items": {
                        "$ref": "#/definitions/usageUsageItem"
                    },
                    "x-displayname": "Usage items"
                }
            }
        },
        "usageUsageItem": {
            "type": "object",
            "description": "Usage item represents a line in a usage report, including quantity and resource incurring usage.",
            "title": "Usage item",
            "x-displayname": "usage item",
            "x-ves-proto-message": "ves.io.schema.usage.UsageItem",
            "properties": {
                "end_timestamp": {
                    "type": "string",
                    "description": " End of the time unit\n\nExample: - \"2020-04-20T12:32:51.341959216Z\"-",
                    "title": "Timestamp end",
                    "format": "date-time",
                    "x-displayname": "End",
                    "x-ves-example": "2020-04-20T12:32:51.341959216Z"
                },
                "hourly_breakdown": {
                    "type": "array",
                    "description": " An array of HourlyItem with usage per hour. The sum of these items will result into the parent's object -quantity-\n Deprecated: use /hourly_usage_details along with hourly_breakdown_query",
                    "title": "Hourly breakdown",
                    "items": {
                        "$ref": "#/definitions/usageHourlyItem"
                    },
                    "x-displayname": "Hourly breakdown"
                },
                "hourly_breakdown_query": {
                    "type": "string",
                    "description": " [x-required]\n A base64 encoded json which should be passed as is to /hourly_usage_details\n to get hourly items for this aggregated usage.\n\nExample: - \"{'MetricLabel':'label'}\"-\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Hourly breakdown query",
                    "x-displayname": "Hourly breakdown query",
                    "x-ves-example": "{'MetricLabel':'label'}",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "metric_label": {
                    "type": "string",
                    "description": " [x-required]\n id of the usage type. As Usage type is shown for user and is a subject of frequent changes,\n this metric_label should be static and should be usage for mapping between calculated usage and aggregated_usage.\n\nValidation Rules:\n  ves.io.schema.rules.message.required: true\n",
                    "title": "Metric label",
                    "x-displayname": "Metric label",
                    "x-ves-required": "true",
                    "x-ves-validation-rules": {
                        "ves.io.schema.rules.message.required": "true"
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": " Namespace where the usage occurred\n\nExample: - \"system\"-",
                    "title": "Namespace",
                    "x-displayname": "Namespace",
                    "x-ves-example": "system"
                },
                "object_name": {
                    "type": "string",
                    "description": " Name of the object where the usage occurred\n\nExample: - \"pa4-resource1\"-",
                    "title": "Object name",
                    "x-displayname": "Object name",
                    "x-ves-example": "pa4-resource1"
                },
                "quantity": {
                    "type": "number",
                    "description": " Quantity incurred\n\nExample: - \"100\"-",
                    "title": "Quantity",
                    "format": "double",
                    "x-displayname": "Quantity",
                    "x-ves-example": "100"
                },
                "start_timestamp": {
                    "type": "string",
                    "description": " Beginning of the time unit\n\nExample: - \"2020-04-20T12:32:51.341959216Z\"-",
                    "title": "Timestamp start",
                    "format": "date-time",
                    "x-displayname": "Start",
                    "x-ves-example": "2020-04-20T12:32:51.341959216Z"
                },
                "unit_name": {
                    "type": "string",
                    "description": " Name of the quantity unit\n\nExample: - \"MB\"-",
                    "title": "Unit name",
                    "x-displayname": "Unit name",
                    "x-ves-example": "MB"
                },
                "usage_type": {
                    "type": "string",
                    "description": " Type of the resource\n\nExample: - \"ADN App Mgmt - VoltStack Large Containers\"-",
                    "title": "Usage type",
                    "x-displayname": "Usage type",
                    "x-ves-example": "ADN App Mgmt - VoltStack Large Containers"
                }
            }
        }
    },
    "x-displayname": "Usage",
    "x-ves-proto-file": "ves.io/schema/usage/custom_aggregated_api.proto"
}`
