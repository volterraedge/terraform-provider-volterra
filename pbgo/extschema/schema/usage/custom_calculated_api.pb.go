// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/usage/custom_calculated_api.proto

// Usage related Customer APIs
//
// x-displayName: "Usage"
// Resource usage and pricing custom APIs

package usage

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/googleapis/google/api"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/vesenv"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Status type
//
// x-displayName: "Status type"
// All possible usage line statuses
type StatusType int32

const (
	// No value defined
	// x-displayName: "Unknown"
	STATUS_UNKNOWN StatusType = 0
	// No data
	// x-displayName: "No data"
	STATUS_NO_DATA StatusType = 1
	// No measured
	// x-displayName: "No measured"
	STATUS_NOT_MEASURED StatusType = 2
	// Active
	// x-displayName: "Active"
	STATUS_ACTIVE StatusType = 3
)

var StatusType_name = map[int32]string{
	0: "STATUS_UNKNOWN",
	1: "STATUS_NO_DATA",
	2: "STATUS_NOT_MEASURED",
	3: "STATUS_ACTIVE",
}

var StatusType_value = map[string]int32{
	"STATUS_UNKNOWN":      0,
	"STATUS_NO_DATA":      1,
	"STATUS_NOT_MEASURED": 2,
	"STATUS_ACTIVE":       3,
}

func (StatusType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f02c9f74e131e61a, []int{0}
}

// Discount type
//
// x-displayName: "Discount type"
// Indicates what type of discount is applied for a coupon: fixed price or percentage.
type DiscountType int32

const (
	// x-displayName: "displayName"
	// unknown
	DISCOUNT_TYPE_UNKNOWN DiscountType = 0
	// x-displayName: "displayName"
	// The specified amount will be given as discount.
	DISCOUNT_TYPE_FIXED_AMOUNT DiscountType = 1
	// x-displayName: "displayName"
	// The specified percentage will be given as discount.
	DISCOUNT_TYPE_PERCENTAGE DiscountType = 2
)

var DiscountType_name = map[int32]string{
	0: "DISCOUNT_TYPE_UNKNOWN",
	1: "DISCOUNT_TYPE_FIXED_AMOUNT",
	2: "DISCOUNT_TYPE_PERCENTAGE",
}

var DiscountType_value = map[string]int32{
	"DISCOUNT_TYPE_UNKNOWN":      0,
	"DISCOUNT_TYPE_FIXED_AMOUNT": 1,
	"DISCOUNT_TYPE_PERCENTAGE":   2,
}

func (DiscountType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f02c9f74e131e61a, []int{1}
}

// List current usage details request
//
// x-displayName: "List current usage details request"
// Request message to get current usage details
type ListCurrentUsageReq struct {
	// Timestamp from
	//
	// x-displayName: "From"
	// x-example: "2020-04-20T12:32:51.341959216Z"
	// Indicates the "from" part of the request
	From *types.Timestamp `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	// Timestamp to
	//
	// x-displayName: "To"
	// x-example: "2020-04-20T12:32:51.341959216Z"
	// Indicates the "to" part of the request
	To *types.Timestamp `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty"`
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "system"
	// Namespace to be considered
	Namespace string `protobuf:"bytes,3,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *ListCurrentUsageReq) Reset()      { *m = ListCurrentUsageReq{} }
func (*ListCurrentUsageReq) ProtoMessage() {}
func (*ListCurrentUsageReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_f02c9f74e131e61a, []int{0}
}
func (m *ListCurrentUsageReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListCurrentUsageReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListCurrentUsageReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListCurrentUsageReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListCurrentUsageReq.Merge(m, src)
}
func (m *ListCurrentUsageReq) XXX_Size() int {
	return m.Size()
}
func (m *ListCurrentUsageReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListCurrentUsageReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListCurrentUsageReq proto.InternalMessageInfo

func (m *ListCurrentUsageReq) GetFrom() *types.Timestamp {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *ListCurrentUsageReq) GetTo() *types.Timestamp {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *ListCurrentUsageReq) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// List monthly usage details request
//
// x-displayName: "List monthly usage details request"
// Request message to get mon thly usage details
type ListMonthlyUsageReq struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "system"
	// Namespace to be considered
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *ListMonthlyUsageReq) Reset()      { *m = ListMonthlyUsageReq{} }
func (*ListMonthlyUsageReq) ProtoMessage() {}
func (*ListMonthlyUsageReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_f02c9f74e131e61a, []int{1}
}
func (m *ListMonthlyUsageReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListMonthlyUsageReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListMonthlyUsageReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListMonthlyUsageReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListMonthlyUsageReq.Merge(m, src)
}
func (m *ListMonthlyUsageReq) XXX_Size() int {
	return m.Size()
}
func (m *ListMonthlyUsageReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListMonthlyUsageReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListMonthlyUsageReq proto.InternalMessageInfo

func (m *ListMonthlyUsageReq) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// List current usage details response
//
// x-displayName: "List current usage details response"
// Response message to get current usage details
type ListCurrentUsageResp struct {
	// Usage items
	//
	// x-displayName: "Usage items"
	// Collection of usage items, lines of response
	UsageItems []*CalculatedUsageItem `protobuf:"bytes,1,rep,name=usage_items,json=usageItems,proto3" json:"usage_items,omitempty"`
	// Total cost
	//
	// x-displayName: "Total cost"
	// x-example: "12345"
	// Total cost as hundredths of currency
	TotalCost int64 `protobuf:"varint,2,opt,name=total_cost,json=totalCost,proto3" json:"total_cost,omitempty"`
	// Coupons
	//
	// x-displayName: "Coupons"
	// All used coupons
	Coupons []*Coupon `protobuf:"bytes,3,rep,name=coupons,proto3" json:"coupons,omitempty"`
	// Discount
	//
	// x-displayName: "Discount"
	// x-example: "12345"
	// Discount as hundredths of currency
	Discount int64 `protobuf:"varint,4,opt,name=discount,proto3" json:"discount,omitempty"`
}

func (m *ListCurrentUsageResp) Reset()      { *m = ListCurrentUsageResp{} }
func (*ListCurrentUsageResp) ProtoMessage() {}
func (*ListCurrentUsageResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_f02c9f74e131e61a, []int{2}
}
func (m *ListCurrentUsageResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListCurrentUsageResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListCurrentUsageResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListCurrentUsageResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListCurrentUsageResp.Merge(m, src)
}
func (m *ListCurrentUsageResp) XXX_Size() int {
	return m.Size()
}
func (m *ListCurrentUsageResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ListCurrentUsageResp.DiscardUnknown(m)
}

var xxx_messageInfo_ListCurrentUsageResp proto.InternalMessageInfo

func (m *ListCurrentUsageResp) GetUsageItems() []*CalculatedUsageItem {
	if m != nil {
		return m.UsageItems
	}
	return nil
}

func (m *ListCurrentUsageResp) GetTotalCost() int64 {
	if m != nil {
		return m.TotalCost
	}
	return 0
}

func (m *ListCurrentUsageResp) GetCoupons() []*Coupon {
	if m != nil {
		return m.Coupons
	}
	return nil
}

func (m *ListCurrentUsageResp) GetDiscount() int64 {
	if m != nil {
		return m.Discount
	}
	return 0
}

// List monthly usage details response
//
// x-displayName: "List monthly usage details response"
// Response message to get monthly usage details
type ListMonthlyUsageResp struct {
	// Usage items
	//
	// x-displayName: "Usage items"
	// Collection of usage items, lines of response
	MonthlyUsageItems []*MonthlyUsageType `protobuf:"bytes,2,rep,name=monthly_usage_items,json=monthlyUsageItems,proto3" json:"monthly_usage_items,omitempty"`
}

func (m *ListMonthlyUsageResp) Reset()      { *m = ListMonthlyUsageResp{} }
func (*ListMonthlyUsageResp) ProtoMessage() {}
func (*ListMonthlyUsageResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_f02c9f74e131e61a, []int{3}
}
func (m *ListMonthlyUsageResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListMonthlyUsageResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListMonthlyUsageResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListMonthlyUsageResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListMonthlyUsageResp.Merge(m, src)
}
func (m *ListMonthlyUsageResp) XXX_Size() int {
	return m.Size()
}
func (m *ListMonthlyUsageResp) XXX_DiscardUnknown() {
	xxx_messageInfo_ListMonthlyUsageResp.DiscardUnknown(m)
}

var xxx_messageInfo_ListMonthlyUsageResp proto.InternalMessageInfo

func (m *ListMonthlyUsageResp) GetMonthlyUsageItems() []*MonthlyUsageType {
	if m != nil {
		return m.MonthlyUsageItems
	}
	return nil
}

// Coupon
//
// x-displayName: "Coupon"
// Coupon details, discount type, amount and name
type Coupon struct {
	// Discount type
	//
	// x-displayName: "Discount type"
	// [x-required]
	// How the discount affects the result price
	DiscountType DiscountType `protobuf:"varint,1,opt,name=discount_type,json=discountType,proto3,enum=ves.io.schema.usage.DiscountType" json:"discount_type,omitempty"`
	// Discount amount
	//
	// x-displayName: "Discount amount"
	// [x-required]
	// x-example: "1234"
	// If discount_type is fixed_amount, discount_amount is in cents
	// If discount_type is percentage, discount_amount is in percentages of 0.01% precision (12.35% equals to 1235)
	DiscountAmount int32 `protobuf:"varint,2,opt,name=discount_amount,json=discountAmount,proto3" json:"discount_amount,omitempty"`
	// Title
	//
	// x-displayName: "Title"
	// x-example: "Coupon 1"
	// Title (or name) of the coupon
	Title string `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
}

func (m *Coupon) Reset()      { *m = Coupon{} }
func (*Coupon) ProtoMessage() {}
func (*Coupon) Descriptor() ([]byte, []int) {
	return fileDescriptor_f02c9f74e131e61a, []int{4}
}
func (m *Coupon) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Coupon) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Coupon.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Coupon) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Coupon.Merge(m, src)
}
func (m *Coupon) XXX_Size() int {
	return m.Size()
}
func (m *Coupon) XXX_DiscardUnknown() {
	xxx_messageInfo_Coupon.DiscardUnknown(m)
}

var xxx_messageInfo_Coupon proto.InternalMessageInfo

func (m *Coupon) GetDiscountType() DiscountType {
	if m != nil {
		return m.DiscountType
	}
	return DISCOUNT_TYPE_UNKNOWN
}

func (m *Coupon) GetDiscountAmount() int32 {
	if m != nil {
		return m.DiscountAmount
	}
	return 0
}

func (m *Coupon) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

// CalculatedUsageItem
//
// x-displayName: "Usage item"
// One line of usage, including pricing details
type CalculatedUsageItem struct {
	// Usage type
	//
	// x-displayName: "Usage type"
	// x-example: "ADN App Mgmt - VoltStack Large Containers"
	// Type of the resource
	UsageType string `protobuf:"bytes,1,opt,name=usage_type,json=usageType,proto3" json:"usage_type,omitempty"`
	// Quantity
	//
	// x-displayName: "Quantity"
	// x-example: "100"
	// Quantity incurred
	Quantity float64 `protobuf:"fixed64,2,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// Unit name
	//
	// x-displayName: "Unit name"
	// x-example: "MB"
	// Name of the quantity unit
	UnitName string `protobuf:"bytes,3,opt,name=unit_name,json=unitName,proto3" json:"unit_name,omitempty"`
	// Amount
	//
	// x-displayName: "Amount"
	// x-example: "1234"
	// Cost as hundredths of currency
	Amount int64 `protobuf:"varint,4,opt,name=amount,proto3" json:"amount,omitempty"`
	// Currency code
	//
	// x-displayName: "Currency code"
	// x-example: "USD"
	// ISO currency code
	CurrencyCode string `protobuf:"bytes,5,opt,name=currency_code,json=currencyCode,proto3" json:"currency_code,omitempty"`
	// Timestamp start
	//
	// x-displayName: "Start"
	// x-example: "2020-04-20T12:32:51.341959216Z"
	// Beginning of the time unit
	StartTimestamp *types.Timestamp `protobuf:"bytes,6,opt,name=start_timestamp,json=startTimestamp,proto3" json:"start_timestamp,omitempty"`
	// Timestamp end
	//
	// x-displayName: "End"
	// x-example: "2020-04-20T12:32:51.341959216Z"
	// End of the time unit
	EndTimestamp *types.Timestamp `protobuf:"bytes,7,opt,name=end_timestamp,json=endTimestamp,proto3" json:"end_timestamp,omitempty"`
	// Fixed
	//
	// x-displayName: "Fixes"
	// Means that this data came not from usage (reserved flag for support/discount/onboarding fees)
	Fixed bool `protobuf:"varint,8,opt,name=fixed,proto3" json:"fixed,omitempty"`
	// Status
	//
	// x-displayName: "Status"
	// Describes different statuses of the metrics listed
	Status StatusType `protobuf:"varint,9,opt,name=status,proto3,enum=ves.io.schema.usage.StatusType" json:"status,omitempty"`
	// Quantity billable
	//
	// x-displayName: "Quantity billable"
	// x-example: 115
	// quantity which is used to calculate the amount. Rounded from quantity as the following:
	// * after converting quantity from unit_code to unit_code of this addon_id, if the value < 1, then
	// quantity_billable is rounded to 1
	// * after converting quantity from unit_code to unit_code of this addon_id, if the value > 1, then
	//  quantity_billable is rounded down to the nearest value.
	QuantityBillable int64 `protobuf:"varint,10,opt,name=quantity_billable,json=quantityBillable,proto3" json:"quantity_billable,omitempty"`
	// Unit name billable
	//
	// x-displayName: "Unit name billable"
	// x-example: GB
	// Unit name a quantity_billable is provided in
	UnitNameBillable string `protobuf:"bytes,11,opt,name=unit_name_billable,json=unitNameBillable,proto3" json:"unit_name_billable,omitempty"`
	// Metric labels
	//
	// x-displayName: "Metric labels"
	// x-example: "['container-usage-large', 'container-usage-medium']"
	// id of the corresponding aggregated_usage metric labels from which this calculated usage item is assembled
	MetricLabels []string `protobuf:"bytes,12,rep,name=metric_labels,json=metricLabels,proto3" json:"metric_labels,omitempty"`
}

func (m *CalculatedUsageItem) Reset()      { *m = CalculatedUsageItem{} }
func (*CalculatedUsageItem) ProtoMessage() {}
func (*CalculatedUsageItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_f02c9f74e131e61a, []int{5}
}
func (m *CalculatedUsageItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CalculatedUsageItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CalculatedUsageItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CalculatedUsageItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CalculatedUsageItem.Merge(m, src)
}
func (m *CalculatedUsageItem) XXX_Size() int {
	return m.Size()
}
func (m *CalculatedUsageItem) XXX_DiscardUnknown() {
	xxx_messageInfo_CalculatedUsageItem.DiscardUnknown(m)
}

var xxx_messageInfo_CalculatedUsageItem proto.InternalMessageInfo

func (m *CalculatedUsageItem) GetUsageType() string {
	if m != nil {
		return m.UsageType
	}
	return ""
}

func (m *CalculatedUsageItem) GetQuantity() float64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *CalculatedUsageItem) GetUnitName() string {
	if m != nil {
		return m.UnitName
	}
	return ""
}

func (m *CalculatedUsageItem) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *CalculatedUsageItem) GetCurrencyCode() string {
	if m != nil {
		return m.CurrencyCode
	}
	return ""
}

func (m *CalculatedUsageItem) GetStartTimestamp() *types.Timestamp {
	if m != nil {
		return m.StartTimestamp
	}
	return nil
}

func (m *CalculatedUsageItem) GetEndTimestamp() *types.Timestamp {
	if m != nil {
		return m.EndTimestamp
	}
	return nil
}

func (m *CalculatedUsageItem) GetFixed() bool {
	if m != nil {
		return m.Fixed
	}
	return false
}

func (m *CalculatedUsageItem) GetStatus() StatusType {
	if m != nil {
		return m.Status
	}
	return STATUS_UNKNOWN
}

func (m *CalculatedUsageItem) GetQuantityBillable() int64 {
	if m != nil {
		return m.QuantityBillable
	}
	return 0
}

func (m *CalculatedUsageItem) GetUnitNameBillable() string {
	if m != nil {
		return m.UnitNameBillable
	}
	return ""
}

func (m *CalculatedUsageItem) GetMetricLabels() []string {
	if m != nil {
		return m.MetricLabels
	}
	return nil
}

// MonthlyUsageType
//
// x-displayName: "Usage item"
// One line of usage, including pricing details
type MonthlyUsageType struct {
	// Amount
	//
	// x-displayName: "Amount"
	// x-example: "1234"
	// Cost as hundredths of currency
	Amount int64 `protobuf:"varint,1,opt,name=amount,proto3" json:"amount,omitempty"`
	// Currency code
	//
	// x-displayName: "Currency code"
	// x-example: "USD"
	// ISO currency code
	CurrencyCode string `protobuf:"bytes,2,opt,name=currency_code,json=currencyCode,proto3" json:"currency_code,omitempty"`
	// Timestamp start
	//
	// x-displayName: "Start"
	// x-example: "2020-04-20T12:32:51.341959216Z"
	// Beginning of the time unit
	StartTimestamp *types.Timestamp `protobuf:"bytes,3,opt,name=start_timestamp,json=startTimestamp,proto3" json:"start_timestamp,omitempty"`
	// Timestamp end
	//
	// x-displayName: "End"
	// x-example: "2020-04-20T12:32:51.341959216Z"
	// End of the time unit
	EndTimestamp *types.Timestamp `protobuf:"bytes,4,opt,name=end_timestamp,json=endTimestamp,proto3" json:"end_timestamp,omitempty"`
}

func (m *MonthlyUsageType) Reset()      { *m = MonthlyUsageType{} }
func (*MonthlyUsageType) ProtoMessage() {}
func (*MonthlyUsageType) Descriptor() ([]byte, []int) {
	return fileDescriptor_f02c9f74e131e61a, []int{6}
}
func (m *MonthlyUsageType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MonthlyUsageType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MonthlyUsageType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MonthlyUsageType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MonthlyUsageType.Merge(m, src)
}
func (m *MonthlyUsageType) XXX_Size() int {
	return m.Size()
}
func (m *MonthlyUsageType) XXX_DiscardUnknown() {
	xxx_messageInfo_MonthlyUsageType.DiscardUnknown(m)
}

var xxx_messageInfo_MonthlyUsageType proto.InternalMessageInfo

func (m *MonthlyUsageType) GetAmount() int64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *MonthlyUsageType) GetCurrencyCode() string {
	if m != nil {
		return m.CurrencyCode
	}
	return ""
}

func (m *MonthlyUsageType) GetStartTimestamp() *types.Timestamp {
	if m != nil {
		return m.StartTimestamp
	}
	return nil
}

func (m *MonthlyUsageType) GetEndTimestamp() *types.Timestamp {
	if m != nil {
		return m.EndTimestamp
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.usage.StatusType", StatusType_name, StatusType_value)
	proto.RegisterEnum("ves.io.schema.usage.DiscountType", DiscountType_name, DiscountType_value)
	proto.RegisterType((*ListCurrentUsageReq)(nil), "ves.io.schema.usage.ListCurrentUsageReq")
	proto.RegisterType((*ListMonthlyUsageReq)(nil), "ves.io.schema.usage.ListMonthlyUsageReq")
	proto.RegisterType((*ListCurrentUsageResp)(nil), "ves.io.schema.usage.ListCurrentUsageResp")
	proto.RegisterType((*ListMonthlyUsageResp)(nil), "ves.io.schema.usage.ListMonthlyUsageResp")
	proto.RegisterType((*Coupon)(nil), "ves.io.schema.usage.Coupon")
	proto.RegisterType((*CalculatedUsageItem)(nil), "ves.io.schema.usage.CalculatedUsageItem")
	proto.RegisterType((*MonthlyUsageType)(nil), "ves.io.schema.usage.MonthlyUsageType")
}

func init() {
	proto.RegisterFile("ves.io/schema/usage/custom_calculated_api.proto", fileDescriptor_f02c9f74e131e61a)
}

var fileDescriptor_f02c9f74e131e61a = []byte{
	// 1064 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x5d, 0x6f, 0xdb, 0x54,
	0x18, 0xce, 0x49, 0xda, 0xae, 0x39, 0xfd, 0x98, 0x77, 0x5a, 0xc0, 0x4b, 0x8b, 0x97, 0x65, 0x42,
	0x84, 0xd2, 0xda, 0xa2, 0xd3, 0x84, 0xb4, 0x1b, 0x94, 0xa5, 0x19, 0x0a, 0xac, 0x69, 0xe5, 0x26,
	0x7c, 0x09, 0xc9, 0x9c, 0x38, 0xa7, 0xa9, 0xc1, 0xf6, 0xf1, 0x7c, 0x8e, 0xa3, 0x46, 0x08, 0x81,
	0xf6, 0x07, 0x40, 0xe2, 0x4f, 0xf0, 0x1f, 0x76, 0xc3, 0x0d, 0x82, 0x2b, 0x54, 0x31, 0x90, 0x76,
	0x49, 0x53, 0x2e, 0xb8, 0xdc, 0x3f, 0x00, 0xf9, 0xf8, 0xa3, 0x4e, 0x88, 0xda, 0x21, 0xb8, 0xf3,
	0xfb, 0xbc, 0xdf, 0xef, 0xf3, 0x9e, 0x73, 0x0c, 0xb5, 0x01, 0x61, 0xaa, 0x45, 0x35, 0x66, 0x1e,
	0x11, 0x07, 0x6b, 0x01, 0xc3, 0x7d, 0xa2, 0x99, 0x01, 0xe3, 0xd4, 0x31, 0x4c, 0x6c, 0x9b, 0x81,
	0x8d, 0x39, 0xe9, 0x19, 0xd8, 0xb3, 0x54, 0xcf, 0xa7, 0x9c, 0xa2, 0x95, 0xc8, 0x41, 0x8d, 0x1c,
	0x54, 0xe1, 0x50, 0x5a, 0xef, 0x53, 0xda, 0xb7, 0x89, 0x86, 0x3d, 0x4b, 0xc3, 0xae, 0x4b, 0x39,
	0xe6, 0x16, 0x75, 0x59, 0xe4, 0x52, 0xba, 0x11, 0x6b, 0x85, 0xd4, 0x0d, 0x0e, 0x35, 0x6e, 0x39,
	0x84, 0x71, 0xec, 0x78, 0xb1, 0xc1, 0xda, 0x78, 0x11, 0xd4, 0xcb, 0x7a, 0x5f, 0x1f, 0x57, 0xf2,
	0xa1, 0x47, 0x12, 0x55, 0x65, 0x5c, 0x35, 0x20, 0x8c, 0xb8, 0x83, 0x71, 0xf7, 0xca, 0xd7, 0x00,
	0xae, 0x3c, 0xb0, 0x18, 0xaf, 0x07, 0xbe, 0x4f, 0x5c, 0xde, 0x09, 0xeb, 0xd5, 0xc9, 0x43, 0xa4,
	0xc2, 0x99, 0x43, 0x9f, 0x3a, 0x32, 0x28, 0x83, 0xea, 0xc2, 0x76, 0x49, 0x8d, 0x6a, 0x54, 0x93,
	0x1a, 0xd5, 0x76, 0x52, 0xa3, 0x2e, 0xec, 0xd0, 0x06, 0xcc, 0x73, 0x2a, 0xe7, 0x2f, 0xb5, 0xce,
	0x73, 0x8a, 0xd6, 0x61, 0xd1, 0xc5, 0x0e, 0x61, 0x1e, 0x36, 0x89, 0x5c, 0x28, 0x83, 0x6a, 0x51,
	0x3f, 0x07, 0x2a, 0xb7, 0xa3, 0x82, 0x76, 0xa9, 0xcb, 0x8f, 0xec, 0x61, 0x5a, 0xd0, 0x98, 0x13,
	0x98, 0x74, 0x7a, 0x02, 0xe0, 0xea, 0x3f, 0xdb, 0x60, 0x1e, 0x6a, 0xc2, 0x05, 0xc1, 0x81, 0x61,
	0x71, 0xe2, 0x30, 0x19, 0x94, 0x0b, 0xd5, 0x85, 0xed, 0xaa, 0x3a, 0x85, 0x25, 0xb5, 0x9e, 0xf2,
	0x29, 0xdc, 0x9b, 0x9c, 0x38, 0x3a, 0x0c, 0x92, 0x4f, 0x86, 0x5e, 0x86, 0x90, 0x53, 0x8e, 0x6d,
	0xc3, 0xa4, 0x8c, 0x8b, 0x56, 0x0b, 0x7a, 0x51, 0x20, 0x75, 0xca, 0x38, 0xba, 0x03, 0xaf, 0x98,
	0x34, 0xf0, 0xa8, 0xcb, 0xe4, 0x82, 0xc8, 0xb2, 0x36, 0x3d, 0x8b, 0xb0, 0xd1, 0x13, 0x5b, 0x54,
	0x82, 0xf3, 0x3d, 0x8b, 0x99, 0x34, 0x70, 0xb9, 0x3c, 0x23, 0x62, 0xa6, 0x72, 0x85, 0x45, 0x4d,
	0x8d, 0x8f, 0x82, 0x79, 0xa8, 0x03, 0x57, 0x9c, 0x08, 0x33, 0xb2, 0xcd, 0xe5, 0x45, 0xda, 0x57,
	0xa6, 0xa6, 0xcd, 0xc6, 0x68, 0x0f, 0x3d, 0xa2, 0x5f, 0x73, 0x32, 0x88, 0x68, 0xf0, 0x9d, 0x99,
	0x79, 0x20, 0xe5, 0xc3, 0x8d, 0x98, 0x8b, 0x8a, 0x44, 0xf7, 0xe1, 0x52, 0x52, 0x8b, 0x11, 0x2e,
	0x96, 0x98, 0xfb, 0xf2, 0xf6, 0xcd, 0xa9, 0x19, 0x76, 0x62, 0x4b, 0x11, 0x7d, 0xb1, 0x97, 0x91,
	0xd0, 0xab, 0xf0, 0x6a, 0x1a, 0x07, 0x3b, 0xa2, 0xd5, 0x70, 0x7c, 0xb3, 0xfa, 0x72, 0x02, 0xd7,
	0x04, 0x8a, 0x56, 0xe1, 0x2c, 0xb7, 0xb8, 0x9d, 0x6c, 0x45, 0x24, 0x54, 0xfe, 0x2a, 0xc0, 0x95,
	0x29, 0xe4, 0x84, 0x84, 0x44, 0xed, 0xa7, 0xb5, 0x15, 0xf5, 0x62, 0x90, 0x74, 0x18, 0x4e, 0xf6,
	0x61, 0x80, 0x5d, 0x6e, 0xf1, 0xa1, 0x48, 0x07, 0xf4, 0x54, 0x46, 0x6b, 0xb0, 0x18, 0xb8, 0x16,
	0x37, 0xc2, 0x0d, 0x8a, 0x93, 0xcd, 0x87, 0x40, 0x0b, 0x3b, 0x04, 0xbd, 0x08, 0xe7, 0xe2, 0x2a,
	0x23, 0x42, 0x62, 0x09, 0xdd, 0x82, 0x4b, 0xa6, 0xd8, 0x2f, 0x73, 0x68, 0x98, 0xb4, 0x47, 0xe4,
	0x59, 0xe1, 0xb8, 0x98, 0x80, 0x75, 0xda, 0x23, 0xa8, 0x0e, 0xaf, 0x32, 0x8e, 0x7d, 0x6e, 0xa4,
	0xa7, 0x58, 0x9e, 0xbb, 0xf4, 0x54, 0x2c, 0x0b, 0x97, 0x54, 0x46, 0x6f, 0xc1, 0x25, 0xe2, 0xf6,
	0x32, 0x21, 0xae, 0x5c, 0x1a, 0x62, 0x91, 0xb8, 0xbd, 0xf3, 0x00, 0xab, 0x70, 0xf6, 0xd0, 0x3a,
	0x26, 0x3d, 0x79, 0xbe, 0x0c, 0xaa, 0xf3, 0x7a, 0x24, 0xa0, 0x37, 0xe1, 0x1c, 0xe3, 0x98, 0x07,
	0x4c, 0x2e, 0x0a, 0x22, 0x6f, 0x4c, 0x25, 0xf2, 0x40, 0x98, 0x08, 0x1a, 0x63, 0x73, 0xf4, 0x3a,
	0xbc, 0x96, 0x8c, 0xce, 0xe8, 0x5a, 0xb6, 0x8d, 0xbb, 0x36, 0x91, 0xa1, 0x18, 0x8e, 0x94, 0x28,
	0xee, 0xc5, 0x38, 0xda, 0x84, 0x28, 0x9d, 0xed, 0xb9, 0xf5, 0x82, 0x98, 0x95, 0x94, 0x0c, 0x39,
	0xb5, 0xbe, 0x05, 0x97, 0x1c, 0xc2, 0x7d, 0xcb, 0x34, 0x6c, 0xdc, 0x25, 0x36, 0x93, 0x17, 0xcb,
	0x85, 0x70, 0xa8, 0x11, 0xf8, 0x40, 0x60, 0x95, 0xdf, 0x00, 0x94, 0x26, 0x37, 0x38, 0x43, 0x13,
	0xb8, 0x98, 0xa6, 0xfc, 0xf3, 0xd1, 0x54, 0xf8, 0xef, 0x34, 0xcd, 0xfc, 0x3b, 0x9a, 0x36, 0x3e,
	0x81, 0xf0, 0x7c, 0xda, 0x08, 0xc1, 0xe5, 0x83, 0x76, 0xad, 0xdd, 0x39, 0x30, 0x3a, 0xad, 0x77,
	0x5b, 0x7b, 0xef, 0xb7, 0xa4, 0x5c, 0x06, 0x6b, 0xed, 0x19, 0x3b, 0xb5, 0x76, 0x4d, 0x02, 0xe8,
	0x25, 0xb8, 0x92, 0x62, 0x6d, 0x63, 0xb7, 0x51, 0x3b, 0xe8, 0xe8, 0x8d, 0x1d, 0x29, 0x8f, 0xae,
	0xc1, 0xa5, 0x58, 0x51, 0xab, 0xb7, 0x9b, 0xef, 0x35, 0xa4, 0xc2, 0x46, 0x1f, 0x2e, 0x66, 0x0f,
	0x26, 0xba, 0x0e, 0x5f, 0xd8, 0x69, 0x1e, 0xd4, 0xf7, 0x3a, 0xad, 0xb6, 0xd1, 0xfe, 0x70, 0xbf,
	0x91, 0x49, 0xa5, 0xc0, 0xd2, 0xb8, 0xea, 0x7e, 0xf3, 0x83, 0xc6, 0x8e, 0x51, 0xdb, 0x0d, 0x11,
	0x09, 0xa0, 0x75, 0x28, 0x8f, 0xeb, 0xf7, 0x1b, 0x7a, 0xbd, 0xd1, 0x6a, 0xd7, 0xde, 0x6e, 0x48,
	0xf9, 0xed, 0x5f, 0x0b, 0x50, 0xae, 0x8b, 0x87, 0x71, 0xe2, 0xa8, 0xd6, 0xf6, 0x9b, 0xe8, 0x07,
	0x00, 0xa5, 0xc9, 0xeb, 0x19, 0x4d, 0xbf, 0x85, 0xa7, 0x3c, 0x46, 0xa5, 0xd7, 0x9e, 0xd3, 0x92,
	0x79, 0x95, 0x8f, 0x47, 0x3f, 0xca, 0x37, 0x0f, 0xef, 0x1c, 0x9b, 0x5b, 0xe1, 0xe6, 0x59, 0x6e,
	0x7f, 0xb3, 0x3c, 0x20, 0x6c, 0xcb, 0xa2, 0x89, 0xbc, 0xe5, 0x13, 0xdc, 0x7b, 0xf4, 0xe4, 0x8f,
	0x6f, 0xf3, 0x6f, 0x54, 0x36, 0x35, 0x2f, 0xe8, 0xda, 0x96, 0xa9, 0xa5, 0x0f, 0x09, 0xd3, 0x3e,
	0x4f, 0xbf, 0xbf, 0xd0, 0xa2, 0x8d, 0xe1, 0xd1, 0x25, 0x7b, 0x17, 0x6c, 0xa4, 0x7d, 0x64, 0x77,
	0xf1, 0x82, 0x3e, 0x26, 0xde, 0xb0, 0x0b, 0xfa, 0x98, 0xbc, 0xe2, 0xff, 0xdf, 0x3e, 0xc6, 0x1e,
	0x8b, 0xbb, 0x60, 0xa3, 0x54, 0xfd, 0xfe, 0x31, 0x28, 0xfc, 0xf2, 0x18, 0x94, 0xa6, 0xd5, 0xb3,
	0xd7, 0xfd, 0x94, 0x98, 0xfc, 0xd1, 0xcf, 0x72, 0xfe, 0x08, 0xdc, 0xfb, 0xf2, 0xe4, 0x54, 0xc9,
	0x3d, 0x3d, 0x55, 0x72, 0xcf, 0x4e, 0x15, 0xf0, 0xd5, 0x48, 0x01, 0xdf, 0x8d, 0x14, 0xf0, 0xd3,
	0x48, 0x01, 0x27, 0x23, 0x05, 0xfc, 0x3e, 0x52, 0xc0, 0x9f, 0x23, 0x25, 0xf7, 0x6c, 0xa4, 0x80,
	0x6f, 0xce, 0x94, 0xdc, 0xc9, 0x99, 0x92, 0x7b, 0x7a, 0xa6, 0xe4, 0x3e, 0x6a, 0xf6, 0xa9, 0xf7,
	0x59, 0x5f, 0x1d, 0x50, 0x9b, 0x13, 0xdf, 0x0f, 0x03, 0x6b, 0xe2, 0xe3, 0x90, 0xfa, 0xce, 0x96,
	0xe7, 0xd3, 0x81, 0xd5, 0x23, 0xfe, 0x56, 0xa2, 0xd6, 0xbc, 0x6e, 0x9f, 0x6a, 0xe4, 0x98, 0xc7,
	0x3f, 0x2a, 0xd9, 0x9f, 0xad, 0xee, 0x9c, 0x38, 0x44, 0xb7, 0xff, 0x0e, 0x00, 0x00, 0xff, 0xff,
	0xd1, 0x06, 0xce, 0xe0, 0x8a, 0x09, 0x00, 0x00,
}

func (x StatusType) String() string {
	s, ok := StatusType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DiscountType) String() string {
	s, ok := DiscountType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *ListCurrentUsageReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListCurrentUsageReq)
	if !ok {
		that2, ok := that.(ListCurrentUsageReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.From.Equal(that1.From) {
		return false
	}
	if !this.To.Equal(that1.To) {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	return true
}
func (this *ListMonthlyUsageReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListMonthlyUsageReq)
	if !ok {
		that2, ok := that.(ListMonthlyUsageReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	return true
}
func (this *ListCurrentUsageResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListCurrentUsageResp)
	if !ok {
		that2, ok := that.(ListCurrentUsageResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.UsageItems) != len(that1.UsageItems) {
		return false
	}
	for i := range this.UsageItems {
		if !this.UsageItems[i].Equal(that1.UsageItems[i]) {
			return false
		}
	}
	if this.TotalCost != that1.TotalCost {
		return false
	}
	if len(this.Coupons) != len(that1.Coupons) {
		return false
	}
	for i := range this.Coupons {
		if !this.Coupons[i].Equal(that1.Coupons[i]) {
			return false
		}
	}
	if this.Discount != that1.Discount {
		return false
	}
	return true
}
func (this *ListMonthlyUsageResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListMonthlyUsageResp)
	if !ok {
		that2, ok := that.(ListMonthlyUsageResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.MonthlyUsageItems) != len(that1.MonthlyUsageItems) {
		return false
	}
	for i := range this.MonthlyUsageItems {
		if !this.MonthlyUsageItems[i].Equal(that1.MonthlyUsageItems[i]) {
			return false
		}
	}
	return true
}
func (this *Coupon) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Coupon)
	if !ok {
		that2, ok := that.(Coupon)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DiscountType != that1.DiscountType {
		return false
	}
	if this.DiscountAmount != that1.DiscountAmount {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	return true
}
func (this *CalculatedUsageItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CalculatedUsageItem)
	if !ok {
		that2, ok := that.(CalculatedUsageItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UsageType != that1.UsageType {
		return false
	}
	if this.Quantity != that1.Quantity {
		return false
	}
	if this.UnitName != that1.UnitName {
		return false
	}
	if this.Amount != that1.Amount {
		return false
	}
	if this.CurrencyCode != that1.CurrencyCode {
		return false
	}
	if !this.StartTimestamp.Equal(that1.StartTimestamp) {
		return false
	}
	if !this.EndTimestamp.Equal(that1.EndTimestamp) {
		return false
	}
	if this.Fixed != that1.Fixed {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.QuantityBillable != that1.QuantityBillable {
		return false
	}
	if this.UnitNameBillable != that1.UnitNameBillable {
		return false
	}
	if len(this.MetricLabels) != len(that1.MetricLabels) {
		return false
	}
	for i := range this.MetricLabels {
		if this.MetricLabels[i] != that1.MetricLabels[i] {
			return false
		}
	}
	return true
}
func (this *MonthlyUsageType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MonthlyUsageType)
	if !ok {
		that2, ok := that.(MonthlyUsageType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Amount != that1.Amount {
		return false
	}
	if this.CurrencyCode != that1.CurrencyCode {
		return false
	}
	if !this.StartTimestamp.Equal(that1.StartTimestamp) {
		return false
	}
	if !this.EndTimestamp.Equal(that1.EndTimestamp) {
		return false
	}
	return true
}
func (this *ListCurrentUsageReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&usage.ListCurrentUsageReq{")
	if this.From != nil {
		s = append(s, "From: "+fmt.Sprintf("%#v", this.From)+",\n")
	}
	if this.To != nil {
		s = append(s, "To: "+fmt.Sprintf("%#v", this.To)+",\n")
	}
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListMonthlyUsageReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&usage.ListMonthlyUsageReq{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListCurrentUsageResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&usage.ListCurrentUsageResp{")
	if this.UsageItems != nil {
		s = append(s, "UsageItems: "+fmt.Sprintf("%#v", this.UsageItems)+",\n")
	}
	s = append(s, "TotalCost: "+fmt.Sprintf("%#v", this.TotalCost)+",\n")
	if this.Coupons != nil {
		s = append(s, "Coupons: "+fmt.Sprintf("%#v", this.Coupons)+",\n")
	}
	s = append(s, "Discount: "+fmt.Sprintf("%#v", this.Discount)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListMonthlyUsageResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&usage.ListMonthlyUsageResp{")
	if this.MonthlyUsageItems != nil {
		s = append(s, "MonthlyUsageItems: "+fmt.Sprintf("%#v", this.MonthlyUsageItems)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Coupon) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&usage.Coupon{")
	s = append(s, "DiscountType: "+fmt.Sprintf("%#v", this.DiscountType)+",\n")
	s = append(s, "DiscountAmount: "+fmt.Sprintf("%#v", this.DiscountAmount)+",\n")
	s = append(s, "Title: "+fmt.Sprintf("%#v", this.Title)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CalculatedUsageItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&usage.CalculatedUsageItem{")
	s = append(s, "UsageType: "+fmt.Sprintf("%#v", this.UsageType)+",\n")
	s = append(s, "Quantity: "+fmt.Sprintf("%#v", this.Quantity)+",\n")
	s = append(s, "UnitName: "+fmt.Sprintf("%#v", this.UnitName)+",\n")
	s = append(s, "Amount: "+fmt.Sprintf("%#v", this.Amount)+",\n")
	s = append(s, "CurrencyCode: "+fmt.Sprintf("%#v", this.CurrencyCode)+",\n")
	if this.StartTimestamp != nil {
		s = append(s, "StartTimestamp: "+fmt.Sprintf("%#v", this.StartTimestamp)+",\n")
	}
	if this.EndTimestamp != nil {
		s = append(s, "EndTimestamp: "+fmt.Sprintf("%#v", this.EndTimestamp)+",\n")
	}
	s = append(s, "Fixed: "+fmt.Sprintf("%#v", this.Fixed)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "QuantityBillable: "+fmt.Sprintf("%#v", this.QuantityBillable)+",\n")
	s = append(s, "UnitNameBillable: "+fmt.Sprintf("%#v", this.UnitNameBillable)+",\n")
	s = append(s, "MetricLabels: "+fmt.Sprintf("%#v", this.MetricLabels)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MonthlyUsageType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&usage.MonthlyUsageType{")
	s = append(s, "Amount: "+fmt.Sprintf("%#v", this.Amount)+",\n")
	s = append(s, "CurrencyCode: "+fmt.Sprintf("%#v", this.CurrencyCode)+",\n")
	if this.StartTimestamp != nil {
		s = append(s, "StartTimestamp: "+fmt.Sprintf("%#v", this.StartTimestamp)+",\n")
	}
	if this.EndTimestamp != nil {
		s = append(s, "EndTimestamp: "+fmt.Sprintf("%#v", this.EndTimestamp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringCustomCalculatedApi(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CustomCalculatedUsageAPIClient is the client API for CustomCalculatedUsageAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CustomCalculatedUsageAPIClient interface {
	// List current usage
	//
	// x-displayName: "List current usage details"
	// List current usage details per tenant and namespace. Some usage have only sense in the system namespace and this selector has no effect on it.
	ListCurrentUsage(ctx context.Context, in *ListCurrentUsageReq, opts ...grpc.CallOption) (*ListCurrentUsageResp, error)
	// List monthly usage
	//
	// x-displayName: "List monthly usage details"
	// List monthly usage details per tenant and namespace. Some usage have only sense in the system namespace and this selector has no effect on it.
	ListMonthlyUsage(ctx context.Context, in *ListMonthlyUsageReq, opts ...grpc.CallOption) (*ListMonthlyUsageResp, error)
}

type customCalculatedUsageAPIClient struct {
	cc *grpc.ClientConn
}

func NewCustomCalculatedUsageAPIClient(cc *grpc.ClientConn) CustomCalculatedUsageAPIClient {
	return &customCalculatedUsageAPIClient{cc}
}

func (c *customCalculatedUsageAPIClient) ListCurrentUsage(ctx context.Context, in *ListCurrentUsageReq, opts ...grpc.CallOption) (*ListCurrentUsageResp, error) {
	out := new(ListCurrentUsageResp)
	err := c.cc.Invoke(ctx, "/ves.io.schema.usage.CustomCalculatedUsageAPI/ListCurrentUsage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *customCalculatedUsageAPIClient) ListMonthlyUsage(ctx context.Context, in *ListMonthlyUsageReq, opts ...grpc.CallOption) (*ListMonthlyUsageResp, error) {
	out := new(ListMonthlyUsageResp)
	err := c.cc.Invoke(ctx, "/ves.io.schema.usage.CustomCalculatedUsageAPI/ListMonthlyUsage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CustomCalculatedUsageAPIServer is the server API for CustomCalculatedUsageAPI service.
type CustomCalculatedUsageAPIServer interface {
	// List current usage
	//
	// x-displayName: "List current usage details"
	// List current usage details per tenant and namespace. Some usage have only sense in the system namespace and this selector has no effect on it.
	ListCurrentUsage(context.Context, *ListCurrentUsageReq) (*ListCurrentUsageResp, error)
	// List monthly usage
	//
	// x-displayName: "List monthly usage details"
	// List monthly usage details per tenant and namespace. Some usage have only sense in the system namespace and this selector has no effect on it.
	ListMonthlyUsage(context.Context, *ListMonthlyUsageReq) (*ListMonthlyUsageResp, error)
}

// UnimplementedCustomCalculatedUsageAPIServer can be embedded to have forward compatible implementations.
type UnimplementedCustomCalculatedUsageAPIServer struct {
}

func (*UnimplementedCustomCalculatedUsageAPIServer) ListCurrentUsage(ctx context.Context, req *ListCurrentUsageReq) (*ListCurrentUsageResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCurrentUsage not implemented")
}
func (*UnimplementedCustomCalculatedUsageAPIServer) ListMonthlyUsage(ctx context.Context, req *ListMonthlyUsageReq) (*ListMonthlyUsageResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMonthlyUsage not implemented")
}

func RegisterCustomCalculatedUsageAPIServer(s *grpc.Server, srv CustomCalculatedUsageAPIServer) {
	s.RegisterService(&_CustomCalculatedUsageAPI_serviceDesc, srv)
}

func _CustomCalculatedUsageAPI_ListCurrentUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCurrentUsageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomCalculatedUsageAPIServer).ListCurrentUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.usage.CustomCalculatedUsageAPI/ListCurrentUsage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomCalculatedUsageAPIServer).ListCurrentUsage(ctx, req.(*ListCurrentUsageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CustomCalculatedUsageAPI_ListMonthlyUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMonthlyUsageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CustomCalculatedUsageAPIServer).ListMonthlyUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ves.io.schema.usage.CustomCalculatedUsageAPI/ListMonthlyUsage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CustomCalculatedUsageAPIServer).ListMonthlyUsage(ctx, req.(*ListMonthlyUsageReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _CustomCalculatedUsageAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ves.io.schema.usage.CustomCalculatedUsageAPI",
	HandlerType: (*CustomCalculatedUsageAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListCurrentUsage",
			Handler:    _CustomCalculatedUsageAPI_ListCurrentUsage_Handler,
		},
		{
			MethodName: "ListMonthlyUsage",
			Handler:    _CustomCalculatedUsageAPI_ListMonthlyUsage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ves.io/schema/usage/custom_calculated_api.proto",
}

func (m *ListCurrentUsageReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListCurrentUsageReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListCurrentUsageReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x1a
	}
	if m.To != nil {
		{
			size, err := m.To.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.From != nil {
		{
			size, err := m.From.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListMonthlyUsageReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListMonthlyUsageReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListMonthlyUsageReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListCurrentUsageResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListCurrentUsageResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListCurrentUsageResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Discount != 0 {
		i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(m.Discount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Coupons) > 0 {
		for iNdEx := len(m.Coupons) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Coupons[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.TotalCost != 0 {
		i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(m.TotalCost))
		i--
		dAtA[i] = 0x10
	}
	if len(m.UsageItems) > 0 {
		for iNdEx := len(m.UsageItems) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UsageItems[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListMonthlyUsageResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListMonthlyUsageResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListMonthlyUsageResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MonthlyUsageItems) > 0 {
		for iNdEx := len(m.MonthlyUsageItems) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MonthlyUsageItems[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *Coupon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Coupon) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Coupon) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DiscountAmount != 0 {
		i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(m.DiscountAmount))
		i--
		dAtA[i] = 0x10
	}
	if m.DiscountType != 0 {
		i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(m.DiscountType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CalculatedUsageItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CalculatedUsageItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CalculatedUsageItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MetricLabels) > 0 {
		for iNdEx := len(m.MetricLabels) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MetricLabels[iNdEx])
			copy(dAtA[i:], m.MetricLabels[iNdEx])
			i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(len(m.MetricLabels[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.UnitNameBillable) > 0 {
		i -= len(m.UnitNameBillable)
		copy(dAtA[i:], m.UnitNameBillable)
		i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(len(m.UnitNameBillable)))
		i--
		dAtA[i] = 0x5a
	}
	if m.QuantityBillable != 0 {
		i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(m.QuantityBillable))
		i--
		dAtA[i] = 0x50
	}
	if m.Status != 0 {
		i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x48
	}
	if m.Fixed {
		i--
		if m.Fixed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.EndTimestamp != nil {
		{
			size, err := m.EndTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.StartTimestamp != nil {
		{
			size, err := m.StartTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.CurrencyCode) > 0 {
		i -= len(m.CurrencyCode)
		copy(dAtA[i:], m.CurrencyCode)
		i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(len(m.CurrencyCode)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Amount != 0 {
		i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.UnitName) > 0 {
		i -= len(m.UnitName)
		copy(dAtA[i:], m.UnitName)
		i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(len(m.UnitName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Quantity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Quantity))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.UsageType) > 0 {
		i -= len(m.UsageType)
		copy(dAtA[i:], m.UsageType)
		i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(len(m.UsageType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MonthlyUsageType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MonthlyUsageType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MonthlyUsageType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndTimestamp != nil {
		{
			size, err := m.EndTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.StartTimestamp != nil {
		{
			size, err := m.StartTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CurrencyCode) > 0 {
		i -= len(m.CurrencyCode)
		copy(dAtA[i:], m.CurrencyCode)
		i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(len(m.CurrencyCode)))
		i--
		dAtA[i] = 0x12
	}
	if m.Amount != 0 {
		i = encodeVarintCustomCalculatedApi(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCustomCalculatedApi(dAtA []byte, offset int, v uint64) int {
	offset -= sovCustomCalculatedApi(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ListCurrentUsageReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovCustomCalculatedApi(uint64(l))
	}
	if m.To != nil {
		l = m.To.Size()
		n += 1 + l + sovCustomCalculatedApi(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovCustomCalculatedApi(uint64(l))
	}
	return n
}

func (m *ListMonthlyUsageReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovCustomCalculatedApi(uint64(l))
	}
	return n
}

func (m *ListCurrentUsageResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UsageItems) > 0 {
		for _, e := range m.UsageItems {
			l = e.Size()
			n += 1 + l + sovCustomCalculatedApi(uint64(l))
		}
	}
	if m.TotalCost != 0 {
		n += 1 + sovCustomCalculatedApi(uint64(m.TotalCost))
	}
	if len(m.Coupons) > 0 {
		for _, e := range m.Coupons {
			l = e.Size()
			n += 1 + l + sovCustomCalculatedApi(uint64(l))
		}
	}
	if m.Discount != 0 {
		n += 1 + sovCustomCalculatedApi(uint64(m.Discount))
	}
	return n
}

func (m *ListMonthlyUsageResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MonthlyUsageItems) > 0 {
		for _, e := range m.MonthlyUsageItems {
			l = e.Size()
			n += 1 + l + sovCustomCalculatedApi(uint64(l))
		}
	}
	return n
}

func (m *Coupon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DiscountType != 0 {
		n += 1 + sovCustomCalculatedApi(uint64(m.DiscountType))
	}
	if m.DiscountAmount != 0 {
		n += 1 + sovCustomCalculatedApi(uint64(m.DiscountAmount))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovCustomCalculatedApi(uint64(l))
	}
	return n
}

func (m *CalculatedUsageItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UsageType)
	if l > 0 {
		n += 1 + l + sovCustomCalculatedApi(uint64(l))
	}
	if m.Quantity != 0 {
		n += 9
	}
	l = len(m.UnitName)
	if l > 0 {
		n += 1 + l + sovCustomCalculatedApi(uint64(l))
	}
	if m.Amount != 0 {
		n += 1 + sovCustomCalculatedApi(uint64(m.Amount))
	}
	l = len(m.CurrencyCode)
	if l > 0 {
		n += 1 + l + sovCustomCalculatedApi(uint64(l))
	}
	if m.StartTimestamp != nil {
		l = m.StartTimestamp.Size()
		n += 1 + l + sovCustomCalculatedApi(uint64(l))
	}
	if m.EndTimestamp != nil {
		l = m.EndTimestamp.Size()
		n += 1 + l + sovCustomCalculatedApi(uint64(l))
	}
	if m.Fixed {
		n += 2
	}
	if m.Status != 0 {
		n += 1 + sovCustomCalculatedApi(uint64(m.Status))
	}
	if m.QuantityBillable != 0 {
		n += 1 + sovCustomCalculatedApi(uint64(m.QuantityBillable))
	}
	l = len(m.UnitNameBillable)
	if l > 0 {
		n += 1 + l + sovCustomCalculatedApi(uint64(l))
	}
	if len(m.MetricLabels) > 0 {
		for _, s := range m.MetricLabels {
			l = len(s)
			n += 1 + l + sovCustomCalculatedApi(uint64(l))
		}
	}
	return n
}

func (m *MonthlyUsageType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Amount != 0 {
		n += 1 + sovCustomCalculatedApi(uint64(m.Amount))
	}
	l = len(m.CurrencyCode)
	if l > 0 {
		n += 1 + l + sovCustomCalculatedApi(uint64(l))
	}
	if m.StartTimestamp != nil {
		l = m.StartTimestamp.Size()
		n += 1 + l + sovCustomCalculatedApi(uint64(l))
	}
	if m.EndTimestamp != nil {
		l = m.EndTimestamp.Size()
		n += 1 + l + sovCustomCalculatedApi(uint64(l))
	}
	return n
}

func sovCustomCalculatedApi(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCustomCalculatedApi(x uint64) (n int) {
	return sovCustomCalculatedApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ListCurrentUsageReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListCurrentUsageReq{`,
		`From:` + strings.Replace(fmt.Sprintf("%v", this.From), "Timestamp", "types.Timestamp", 1) + `,`,
		`To:` + strings.Replace(fmt.Sprintf("%v", this.To), "Timestamp", "types.Timestamp", 1) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListMonthlyUsageReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListMonthlyUsageReq{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListCurrentUsageResp) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForUsageItems := "[]*CalculatedUsageItem{"
	for _, f := range this.UsageItems {
		repeatedStringForUsageItems += strings.Replace(f.String(), "CalculatedUsageItem", "CalculatedUsageItem", 1) + ","
	}
	repeatedStringForUsageItems += "}"
	repeatedStringForCoupons := "[]*Coupon{"
	for _, f := range this.Coupons {
		repeatedStringForCoupons += strings.Replace(f.String(), "Coupon", "Coupon", 1) + ","
	}
	repeatedStringForCoupons += "}"
	s := strings.Join([]string{`&ListCurrentUsageResp{`,
		`UsageItems:` + repeatedStringForUsageItems + `,`,
		`TotalCost:` + fmt.Sprintf("%v", this.TotalCost) + `,`,
		`Coupons:` + repeatedStringForCoupons + `,`,
		`Discount:` + fmt.Sprintf("%v", this.Discount) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListMonthlyUsageResp) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMonthlyUsageItems := "[]*MonthlyUsageType{"
	for _, f := range this.MonthlyUsageItems {
		repeatedStringForMonthlyUsageItems += strings.Replace(f.String(), "MonthlyUsageType", "MonthlyUsageType", 1) + ","
	}
	repeatedStringForMonthlyUsageItems += "}"
	s := strings.Join([]string{`&ListMonthlyUsageResp{`,
		`MonthlyUsageItems:` + repeatedStringForMonthlyUsageItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *Coupon) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Coupon{`,
		`DiscountType:` + fmt.Sprintf("%v", this.DiscountType) + `,`,
		`DiscountAmount:` + fmt.Sprintf("%v", this.DiscountAmount) + `,`,
		`Title:` + fmt.Sprintf("%v", this.Title) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CalculatedUsageItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CalculatedUsageItem{`,
		`UsageType:` + fmt.Sprintf("%v", this.UsageType) + `,`,
		`Quantity:` + fmt.Sprintf("%v", this.Quantity) + `,`,
		`UnitName:` + fmt.Sprintf("%v", this.UnitName) + `,`,
		`Amount:` + fmt.Sprintf("%v", this.Amount) + `,`,
		`CurrencyCode:` + fmt.Sprintf("%v", this.CurrencyCode) + `,`,
		`StartTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.StartTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`EndTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.EndTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`Fixed:` + fmt.Sprintf("%v", this.Fixed) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`QuantityBillable:` + fmt.Sprintf("%v", this.QuantityBillable) + `,`,
		`UnitNameBillable:` + fmt.Sprintf("%v", this.UnitNameBillable) + `,`,
		`MetricLabels:` + fmt.Sprintf("%v", this.MetricLabels) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MonthlyUsageType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MonthlyUsageType{`,
		`Amount:` + fmt.Sprintf("%v", this.Amount) + `,`,
		`CurrencyCode:` + fmt.Sprintf("%v", this.CurrencyCode) + `,`,
		`StartTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.StartTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`EndTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.EndTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringCustomCalculatedApi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ListCurrentUsageReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCustomCalculatedApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListCurrentUsageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListCurrentUsageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &types.Timestamp{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.To == nil {
				m.To = &types.Timestamp{}
			}
			if err := m.To.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCustomCalculatedApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListMonthlyUsageReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCustomCalculatedApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListMonthlyUsageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListMonthlyUsageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCustomCalculatedApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListCurrentUsageResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCustomCalculatedApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListCurrentUsageResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListCurrentUsageResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsageItems = append(m.UsageItems, &CalculatedUsageItem{})
			if err := m.UsageItems[len(m.UsageItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCost", wireType)
			}
			m.TotalCost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCost |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coupons", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coupons = append(m.Coupons, &Coupon{})
			if err := m.Coupons[len(m.Coupons)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discount", wireType)
			}
			m.Discount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Discount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCustomCalculatedApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListMonthlyUsageResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCustomCalculatedApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListMonthlyUsageResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListMonthlyUsageResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonthlyUsageItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MonthlyUsageItems = append(m.MonthlyUsageItems, &MonthlyUsageType{})
			if err := m.MonthlyUsageItems[len(m.MonthlyUsageItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCustomCalculatedApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Coupon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCustomCalculatedApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Coupon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Coupon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscountType", wireType)
			}
			m.DiscountType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscountType |= DiscountType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscountAmount", wireType)
			}
			m.DiscountAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscountAmount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCustomCalculatedApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CalculatedUsageItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCustomCalculatedApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CalculatedUsageItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CalculatedUsageItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsageType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Quantity = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnitName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrencyCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTimestamp == nil {
				m.StartTimestamp = &types.Timestamp{}
			}
			if err := m.StartTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTimestamp == nil {
				m.EndTimestamp = &types.Timestamp{}
			}
			if err := m.EndTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fixed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fixed = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= StatusType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuantityBillable", wireType)
			}
			m.QuantityBillable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QuantityBillable |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitNameBillable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnitNameBillable = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricLabels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricLabels = append(m.MetricLabels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCustomCalculatedApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MonthlyUsageType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCustomCalculatedApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MonthlyUsageType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MonthlyUsageType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrencyCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTimestamp == nil {
				m.StartTimestamp = &types.Timestamp{}
			}
			if err := m.StartTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTimestamp == nil {
				m.EndTimestamp = &types.Timestamp{}
			}
			if err := m.EndTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCustomCalculatedApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCustomCalculatedApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCustomCalculatedApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCustomCalculatedApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCustomCalculatedApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCustomCalculatedApi
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCustomCalculatedApi
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCustomCalculatedApi
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCustomCalculatedApi        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCustomCalculatedApi          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCustomCalculatedApi = fmt.Errorf("proto: unexpected end of group")
)
