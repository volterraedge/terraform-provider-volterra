//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//
package app_firewall

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) DetectionSettingChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for detection_setting_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) EnforcementModeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for enforcement_mode_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["detection_setting_choice"]; exists {
		val := m.GetDetectionSettingChoice()
		vOpts := append(opts,
			db.WithValidateField("detection_setting_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDetectionSettingChoice().(type) {
	case *CreateSpecType_DefaultDetectionSettings:
		if fv, exists := v.FldValidators["detection_setting_choice.default_detection_settings"]; exists {
			val := m.GetDetectionSettingChoice().(*CreateSpecType_DefaultDetectionSettings).DefaultDetectionSettings
			vOpts := append(opts,
				db.WithValidateField("detection_setting_choice"),
				db.WithValidateField("default_detection_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_DetectionSettings:
		if fv, exists := v.FldValidators["detection_setting_choice.detection_settings"]; exists {
			val := m.GetDetectionSettingChoice().(*CreateSpecType_DetectionSettings).DetectionSettings
			vOpts := append(opts,
				db.WithValidateField("detection_setting_choice"),
				db.WithValidateField("detection_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["enforcement_mode_choice"]; exists {
		val := m.GetEnforcementModeChoice()
		vOpts := append(opts,
			db.WithValidateField("enforcement_mode_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetEnforcementModeChoice().(type) {
	case *CreateSpecType_UseLoadbalancerSetting:
		if fv, exists := v.FldValidators["enforcement_mode_choice.use_loadbalancer_setting"]; exists {
			val := m.GetEnforcementModeChoice().(*CreateSpecType_UseLoadbalancerSetting).UseLoadbalancerSetting
			vOpts := append(opts,
				db.WithValidateField("enforcement_mode_choice"),
				db.WithValidateField("use_loadbalancer_setting"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_Blocking:
		if fv, exists := v.FldValidators["enforcement_mode_choice.blocking"]; exists {
			val := m.GetEnforcementModeChoice().(*CreateSpecType_Blocking).Blocking
			vOpts := append(opts,
				db.WithValidateField("enforcement_mode_choice"),
				db.WithValidateField("blocking"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_Monitoring:
		if fv, exists := v.FldValidators["enforcement_mode_choice.monitoring"]; exists {
			val := m.GetEnforcementModeChoice().(*CreateSpecType_Monitoring).Monitoring
			vOpts := append(opts,
				db.WithValidateField("enforcement_mode_choice"),
				db.WithValidateField("monitoring"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDetectionSettingChoice := v.DetectionSettingChoiceValidationRuleHandler
	rulesDetectionSettingChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDetectionSettingChoice(rulesDetectionSettingChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.detection_setting_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["detection_setting_choice"] = vFn

	vrhEnforcementModeChoice := v.EnforcementModeChoiceValidationRuleHandler
	rulesEnforcementModeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhEnforcementModeChoice(rulesEnforcementModeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.enforcement_mode_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["enforcement_mode_choice"] = vFn

	v.FldValidators["detection_setting_choice.detection_settings"] = DetectionSettingValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DetectionSetting) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DetectionSetting) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DetectionSetting) DeepCopy() *DetectionSetting {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DetectionSetting{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DetectionSetting) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DetectionSetting) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DetectionSettingValidator().Validate(ctx, m, opts...)
}

type ValidateDetectionSetting struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDetectionSetting) FalsePositiveSuppressionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for false_positive_suppression")
	}
	return validatorFn, nil
}

func (v *ValidateDetectionSetting) ThreatCampaignChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for threat_campaign_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDetectionSetting) ViolationDetectionSettingValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for violation_detection_setting")
	}
	return validatorFn, nil
}

func (v *ValidateDetectionSetting) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DetectionSetting)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DetectionSetting got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["false_positive_suppression"]; exists {
		val := m.GetFalsePositiveSuppression()
		vOpts := append(opts,
			db.WithValidateField("false_positive_suppression"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetFalsePositiveSuppression().(type) {
	case *DetectionSetting_EnableSuppression:
		if fv, exists := v.FldValidators["false_positive_suppression.enable_suppression"]; exists {
			val := m.GetFalsePositiveSuppression().(*DetectionSetting_EnableSuppression).EnableSuppression
			vOpts := append(opts,
				db.WithValidateField("false_positive_suppression"),
				db.WithValidateField("enable_suppression"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DetectionSetting_DisableSuppression:
		if fv, exists := v.FldValidators["false_positive_suppression.disable_suppression"]; exists {
			val := m.GetFalsePositiveSuppression().(*DetectionSetting_DisableSuppression).DisableSuppression
			vOpts := append(opts,
				db.WithValidateField("false_positive_suppression"),
				db.WithValidateField("disable_suppression"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["signature_selection_setting"]; exists {

		vOpts := append(opts, db.WithValidateField("signature_selection_setting"))
		if err := fv(ctx, m.GetSignatureSelectionSetting(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["threat_campaign_choice"]; exists {
		val := m.GetThreatCampaignChoice()
		vOpts := append(opts,
			db.WithValidateField("threat_campaign_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetThreatCampaignChoice().(type) {
	case *DetectionSetting_EnableThreatCampaigns:
		if fv, exists := v.FldValidators["threat_campaign_choice.enable_threat_campaigns"]; exists {
			val := m.GetThreatCampaignChoice().(*DetectionSetting_EnableThreatCampaigns).EnableThreatCampaigns
			vOpts := append(opts,
				db.WithValidateField("threat_campaign_choice"),
				db.WithValidateField("enable_threat_campaigns"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DetectionSetting_DisableThreatCampaigns:
		if fv, exists := v.FldValidators["threat_campaign_choice.disable_threat_campaigns"]; exists {
			val := m.GetThreatCampaignChoice().(*DetectionSetting_DisableThreatCampaigns).DisableThreatCampaigns
			vOpts := append(opts,
				db.WithValidateField("threat_campaign_choice"),
				db.WithValidateField("disable_threat_campaigns"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["violation_detection_setting"]; exists {
		val := m.GetViolationDetectionSetting()
		vOpts := append(opts,
			db.WithValidateField("violation_detection_setting"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetViolationDetectionSetting().(type) {
	case *DetectionSetting_DefaultViolationSettings:
		if fv, exists := v.FldValidators["violation_detection_setting.default_violation_settings"]; exists {
			val := m.GetViolationDetectionSetting().(*DetectionSetting_DefaultViolationSettings).DefaultViolationSettings
			vOpts := append(opts,
				db.WithValidateField("violation_detection_setting"),
				db.WithValidateField("default_violation_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DetectionSetting_EnabledViolationTypes:
		if fv, exists := v.FldValidators["violation_detection_setting.enabled_violation_types"]; exists {
			val := m.GetViolationDetectionSetting().(*DetectionSetting_EnabledViolationTypes).EnabledViolationTypes
			vOpts := append(opts,
				db.WithValidateField("violation_detection_setting"),
				db.WithValidateField("enabled_violation_types"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDetectionSettingValidator = func() *ValidateDetectionSetting {
	v := &ValidateDetectionSetting{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhFalsePositiveSuppression := v.FalsePositiveSuppressionValidationRuleHandler
	rulesFalsePositiveSuppression := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhFalsePositiveSuppression(rulesFalsePositiveSuppression)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DetectionSetting.false_positive_suppression: %s", err)
		panic(errMsg)
	}
	v.FldValidators["false_positive_suppression"] = vFn

	vrhThreatCampaignChoice := v.ThreatCampaignChoiceValidationRuleHandler
	rulesThreatCampaignChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhThreatCampaignChoice(rulesThreatCampaignChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DetectionSetting.threat_campaign_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["threat_campaign_choice"] = vFn

	vrhViolationDetectionSetting := v.ViolationDetectionSettingValidationRuleHandler
	rulesViolationDetectionSetting := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhViolationDetectionSetting(rulesViolationDetectionSetting)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DetectionSetting.violation_detection_setting: %s", err)
		panic(errMsg)
	}
	v.FldValidators["violation_detection_setting"] = vFn

	v.FldValidators["violation_detection_setting.enabled_violation_types"] = ViolationSettingValidator().Validate

	v.FldValidators["signature_selection_setting"] = SignatureSelectionSettingValidator().Validate

	return v
}()

func DetectionSettingValidator() db.Validator {
	return DefaultDetectionSettingValidator
}

// augmented methods on protoc/std generated struct

func (m *EnabledAttackTypes) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *EnabledAttackTypes) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *EnabledAttackTypes) DeepCopy() *EnabledAttackTypes {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &EnabledAttackTypes{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *EnabledAttackTypes) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *EnabledAttackTypes) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EnabledAttackTypesValidator().Validate(ctx, m, opts...)
}

type ValidateEnabledAttackTypes struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEnabledAttackTypes) EnabledAttackTypesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(AttackType)
		return int32(i)
	}
	// AttackType_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, AttackType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for enabled_attack_types")
	}
	itemsValidatorFn := func(ctx context.Context, elems []AttackType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for enabled_attack_types")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]AttackType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []AttackType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated enabled_attack_types")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items enabled_attack_types")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateEnabledAttackTypes) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*EnabledAttackTypes)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *EnabledAttackTypes got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["enabled_attack_types"]; exists {
		vOpts := append(opts, db.WithValidateField("enabled_attack_types"))
		if err := fv(ctx, m.GetEnabledAttackTypes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEnabledAttackTypesValidator = func() *ValidateEnabledAttackTypes {
	v := &ValidateEnabledAttackTypes{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhEnabledAttackTypes := v.EnabledAttackTypesValidationRuleHandler
	rulesEnabledAttackTypes := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "22",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhEnabledAttackTypes(rulesEnabledAttackTypes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EnabledAttackTypes.enabled_attack_types: %s", err)
		panic(errMsg)
	}
	v.FldValidators["enabled_attack_types"] = vFn

	return v
}()

func EnabledAttackTypesValidator() db.Validator {
	return DefaultEnabledAttackTypesValidator
}

// augmented methods on protoc/std generated struct

func (m *EnabledEvasionSubViolations) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *EnabledEvasionSubViolations) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *EnabledEvasionSubViolations) DeepCopy() *EnabledEvasionSubViolations {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &EnabledEvasionSubViolations{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *EnabledEvasionSubViolations) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *EnabledEvasionSubViolations) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EnabledEvasionSubViolationsValidator().Validate(ctx, m, opts...)
}

type ValidateEnabledEvasionSubViolations struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEnabledEvasionSubViolations) EvasionViolationSettingsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(EvasionSubViolationType)
		return int32(i)
	}
	// EvasionSubViolationType_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, EvasionSubViolationType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for evasion_violation_settings")
	}
	itemsValidatorFn := func(ctx context.Context, elems []EvasionSubViolationType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for evasion_violation_settings")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]EvasionSubViolationType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []EvasionSubViolationType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated evasion_violation_settings")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items evasion_violation_settings")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateEnabledEvasionSubViolations) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*EnabledEvasionSubViolations)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *EnabledEvasionSubViolations got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["evasion_violation_settings"]; exists {
		vOpts := append(opts, db.WithValidateField("evasion_violation_settings"))
		if err := fv(ctx, m.GetEvasionViolationSettings(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEnabledEvasionSubViolationsValidator = func() *ValidateEnabledEvasionSubViolations {
	v := &ValidateEnabledEvasionSubViolations{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhEvasionViolationSettings := v.EvasionViolationSettingsValidationRuleHandler
	rulesEvasionViolationSettings := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhEvasionViolationSettings(rulesEvasionViolationSettings)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EnabledEvasionSubViolations.evasion_violation_settings: %s", err)
		panic(errMsg)
	}
	v.FldValidators["evasion_violation_settings"] = vFn

	return v
}()

func EnabledEvasionSubViolationsValidator() db.Validator {
	return DefaultEnabledEvasionSubViolationsValidator
}

// augmented methods on protoc/std generated struct

func (m *EnabledHTTPProtocolSubViolations) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *EnabledHTTPProtocolSubViolations) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *EnabledHTTPProtocolSubViolations) DeepCopy() *EnabledHTTPProtocolSubViolations {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &EnabledHTTPProtocolSubViolations{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *EnabledHTTPProtocolSubViolations) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *EnabledHTTPProtocolSubViolations) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EnabledHTTPProtocolSubViolationsValidator().Validate(ctx, m, opts...)
}

type ValidateEnabledHTTPProtocolSubViolations struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEnabledHTTPProtocolSubViolations) HttpProtocolSubViolationsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(HTTPProtocolSubViolationType)
		return int32(i)
	}
	// HTTPProtocolSubViolationType_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, HTTPProtocolSubViolationType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for http_protocol_sub_violations")
	}
	itemsValidatorFn := func(ctx context.Context, elems []HTTPProtocolSubViolationType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for http_protocol_sub_violations")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]HTTPProtocolSubViolationType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []HTTPProtocolSubViolationType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated http_protocol_sub_violations")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items http_protocol_sub_violations")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateEnabledHTTPProtocolSubViolations) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*EnabledHTTPProtocolSubViolations)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *EnabledHTTPProtocolSubViolations got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["http_protocol_sub_violations"]; exists {
		vOpts := append(opts, db.WithValidateField("http_protocol_sub_violations"))
		if err := fv(ctx, m.GetHttpProtocolSubViolations(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEnabledHTTPProtocolSubViolationsValidator = func() *ValidateEnabledHTTPProtocolSubViolations {
	v := &ValidateEnabledHTTPProtocolSubViolations{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHttpProtocolSubViolations := v.HttpProtocolSubViolationsValidationRuleHandler
	rulesHttpProtocolSubViolations := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "19",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhHttpProtocolSubViolations(rulesHttpProtocolSubViolations)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for EnabledHTTPProtocolSubViolations.http_protocol_sub_violations: %s", err)
		panic(errMsg)
	}
	v.FldValidators["http_protocol_sub_violations"] = vFn

	return v
}()

func EnabledHTTPProtocolSubViolationsValidator() db.Validator {
	return DefaultEnabledHTTPProtocolSubViolationsValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) DetectionSettingChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for detection_setting_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) EnforcementModeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for enforcement_mode_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["detection_setting_choice"]; exists {
		val := m.GetDetectionSettingChoice()
		vOpts := append(opts,
			db.WithValidateField("detection_setting_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDetectionSettingChoice().(type) {
	case *GetSpecType_DefaultDetectionSettings:
		if fv, exists := v.FldValidators["detection_setting_choice.default_detection_settings"]; exists {
			val := m.GetDetectionSettingChoice().(*GetSpecType_DefaultDetectionSettings).DefaultDetectionSettings
			vOpts := append(opts,
				db.WithValidateField("detection_setting_choice"),
				db.WithValidateField("default_detection_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_DetectionSettings:
		if fv, exists := v.FldValidators["detection_setting_choice.detection_settings"]; exists {
			val := m.GetDetectionSettingChoice().(*GetSpecType_DetectionSettings).DetectionSettings
			vOpts := append(opts,
				db.WithValidateField("detection_setting_choice"),
				db.WithValidateField("detection_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["enforcement_mode_choice"]; exists {
		val := m.GetEnforcementModeChoice()
		vOpts := append(opts,
			db.WithValidateField("enforcement_mode_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetEnforcementModeChoice().(type) {
	case *GetSpecType_UseLoadbalancerSetting:
		if fv, exists := v.FldValidators["enforcement_mode_choice.use_loadbalancer_setting"]; exists {
			val := m.GetEnforcementModeChoice().(*GetSpecType_UseLoadbalancerSetting).UseLoadbalancerSetting
			vOpts := append(opts,
				db.WithValidateField("enforcement_mode_choice"),
				db.WithValidateField("use_loadbalancer_setting"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Blocking:
		if fv, exists := v.FldValidators["enforcement_mode_choice.blocking"]; exists {
			val := m.GetEnforcementModeChoice().(*GetSpecType_Blocking).Blocking
			vOpts := append(opts,
				db.WithValidateField("enforcement_mode_choice"),
				db.WithValidateField("blocking"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Monitoring:
		if fv, exists := v.FldValidators["enforcement_mode_choice.monitoring"]; exists {
			val := m.GetEnforcementModeChoice().(*GetSpecType_Monitoring).Monitoring
			vOpts := append(opts,
				db.WithValidateField("enforcement_mode_choice"),
				db.WithValidateField("monitoring"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDetectionSettingChoice := v.DetectionSettingChoiceValidationRuleHandler
	rulesDetectionSettingChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDetectionSettingChoice(rulesDetectionSettingChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.detection_setting_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["detection_setting_choice"] = vFn

	vrhEnforcementModeChoice := v.EnforcementModeChoiceValidationRuleHandler
	rulesEnforcementModeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhEnforcementModeChoice(rulesEnforcementModeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.enforcement_mode_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["enforcement_mode_choice"] = vFn

	v.FldValidators["detection_setting_choice.detection_settings"] = DetectionSettingValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) DetectionSettingChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for detection_setting_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) EnforcementModeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for enforcement_mode_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["detection_setting_choice"]; exists {
		val := m.GetDetectionSettingChoice()
		vOpts := append(opts,
			db.WithValidateField("detection_setting_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDetectionSettingChoice().(type) {
	case *GlobalSpecType_DefaultDetectionSettings:
		if fv, exists := v.FldValidators["detection_setting_choice.default_detection_settings"]; exists {
			val := m.GetDetectionSettingChoice().(*GlobalSpecType_DefaultDetectionSettings).DefaultDetectionSettings
			vOpts := append(opts,
				db.WithValidateField("detection_setting_choice"),
				db.WithValidateField("default_detection_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_DetectionSettings:
		if fv, exists := v.FldValidators["detection_setting_choice.detection_settings"]; exists {
			val := m.GetDetectionSettingChoice().(*GlobalSpecType_DetectionSettings).DetectionSettings
			vOpts := append(opts,
				db.WithValidateField("detection_setting_choice"),
				db.WithValidateField("detection_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["enforcement_mode_choice"]; exists {
		val := m.GetEnforcementModeChoice()
		vOpts := append(opts,
			db.WithValidateField("enforcement_mode_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetEnforcementModeChoice().(type) {
	case *GlobalSpecType_UseLoadbalancerSetting:
		if fv, exists := v.FldValidators["enforcement_mode_choice.use_loadbalancer_setting"]; exists {
			val := m.GetEnforcementModeChoice().(*GlobalSpecType_UseLoadbalancerSetting).UseLoadbalancerSetting
			vOpts := append(opts,
				db.WithValidateField("enforcement_mode_choice"),
				db.WithValidateField("use_loadbalancer_setting"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Blocking:
		if fv, exists := v.FldValidators["enforcement_mode_choice.blocking"]; exists {
			val := m.GetEnforcementModeChoice().(*GlobalSpecType_Blocking).Blocking
			vOpts := append(opts,
				db.WithValidateField("enforcement_mode_choice"),
				db.WithValidateField("blocking"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Monitoring:
		if fv, exists := v.FldValidators["enforcement_mode_choice.monitoring"]; exists {
			val := m.GetEnforcementModeChoice().(*GlobalSpecType_Monitoring).Monitoring
			vOpts := append(opts,
				db.WithValidateField("enforcement_mode_choice"),
				db.WithValidateField("monitoring"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDetectionSettingChoice := v.DetectionSettingChoiceValidationRuleHandler
	rulesDetectionSettingChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDetectionSettingChoice(rulesDetectionSettingChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.detection_setting_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["detection_setting_choice"] = vFn

	vrhEnforcementModeChoice := v.EnforcementModeChoiceValidationRuleHandler
	rulesEnforcementModeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhEnforcementModeChoice(rulesEnforcementModeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.enforcement_mode_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["enforcement_mode_choice"] = vFn

	v.FldValidators["detection_setting_choice.detection_settings"] = DetectionSettingValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) DetectionSettingChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for detection_setting_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) EnforcementModeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for enforcement_mode_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["detection_setting_choice"]; exists {
		val := m.GetDetectionSettingChoice()
		vOpts := append(opts,
			db.WithValidateField("detection_setting_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDetectionSettingChoice().(type) {
	case *ReplaceSpecType_DefaultDetectionSettings:
		if fv, exists := v.FldValidators["detection_setting_choice.default_detection_settings"]; exists {
			val := m.GetDetectionSettingChoice().(*ReplaceSpecType_DefaultDetectionSettings).DefaultDetectionSettings
			vOpts := append(opts,
				db.WithValidateField("detection_setting_choice"),
				db.WithValidateField("default_detection_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_DetectionSettings:
		if fv, exists := v.FldValidators["detection_setting_choice.detection_settings"]; exists {
			val := m.GetDetectionSettingChoice().(*ReplaceSpecType_DetectionSettings).DetectionSettings
			vOpts := append(opts,
				db.WithValidateField("detection_setting_choice"),
				db.WithValidateField("detection_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["enforcement_mode_choice"]; exists {
		val := m.GetEnforcementModeChoice()
		vOpts := append(opts,
			db.WithValidateField("enforcement_mode_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetEnforcementModeChoice().(type) {
	case *ReplaceSpecType_UseLoadbalancerSetting:
		if fv, exists := v.FldValidators["enforcement_mode_choice.use_loadbalancer_setting"]; exists {
			val := m.GetEnforcementModeChoice().(*ReplaceSpecType_UseLoadbalancerSetting).UseLoadbalancerSetting
			vOpts := append(opts,
				db.WithValidateField("enforcement_mode_choice"),
				db.WithValidateField("use_loadbalancer_setting"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_Blocking:
		if fv, exists := v.FldValidators["enforcement_mode_choice.blocking"]; exists {
			val := m.GetEnforcementModeChoice().(*ReplaceSpecType_Blocking).Blocking
			vOpts := append(opts,
				db.WithValidateField("enforcement_mode_choice"),
				db.WithValidateField("blocking"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_Monitoring:
		if fv, exists := v.FldValidators["enforcement_mode_choice.monitoring"]; exists {
			val := m.GetEnforcementModeChoice().(*ReplaceSpecType_Monitoring).Monitoring
			vOpts := append(opts,
				db.WithValidateField("enforcement_mode_choice"),
				db.WithValidateField("monitoring"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDetectionSettingChoice := v.DetectionSettingChoiceValidationRuleHandler
	rulesDetectionSettingChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDetectionSettingChoice(rulesDetectionSettingChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.detection_setting_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["detection_setting_choice"] = vFn

	vrhEnforcementModeChoice := v.EnforcementModeChoiceValidationRuleHandler
	rulesEnforcementModeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhEnforcementModeChoice(rulesEnforcementModeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.enforcement_mode_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["enforcement_mode_choice"] = vFn

	v.FldValidators["detection_setting_choice.detection_settings"] = DetectionSettingValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SignatureSelectionSetting) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SignatureSelectionSetting) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SignatureSelectionSetting) DeepCopy() *SignatureSelectionSetting {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SignatureSelectionSetting{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SignatureSelectionSetting) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SignatureSelectionSetting) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SignatureSelectionSettingValidator().Validate(ctx, m, opts...)
}

type ValidateSignatureSelectionSetting struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSignatureSelectionSetting) AttackTypeSettingValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for attack_type_setting")
	}
	return validatorFn, nil
}

func (v *ValidateSignatureSelectionSetting) SignatureSelectionByAccuracyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for signature_selection_by_accuracy")
	}
	return validatorFn, nil
}

func (v *ValidateSignatureSelectionSetting) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SignatureSelectionSetting)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SignatureSelectionSetting got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["attack_type_setting"]; exists {
		val := m.GetAttackTypeSetting()
		vOpts := append(opts,
			db.WithValidateField("attack_type_setting"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAttackTypeSetting().(type) {
	case *SignatureSelectionSetting_DefaultAttackTypeSettings:
		if fv, exists := v.FldValidators["attack_type_setting.default_attack_type_settings"]; exists {
			val := m.GetAttackTypeSetting().(*SignatureSelectionSetting_DefaultAttackTypeSettings).DefaultAttackTypeSettings
			vOpts := append(opts,
				db.WithValidateField("attack_type_setting"),
				db.WithValidateField("default_attack_type_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SignatureSelectionSetting_EnabledAttackTypes:
		if fv, exists := v.FldValidators["attack_type_setting.enabled_attack_types"]; exists {
			val := m.GetAttackTypeSetting().(*SignatureSelectionSetting_EnabledAttackTypes).EnabledAttackTypes
			vOpts := append(opts,
				db.WithValidateField("attack_type_setting"),
				db.WithValidateField("enabled_attack_types"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["signature_selection_by_accuracy"]; exists {
		val := m.GetSignatureSelectionByAccuracy()
		vOpts := append(opts,
			db.WithValidateField("signature_selection_by_accuracy"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSignatureSelectionByAccuracy().(type) {
	case *SignatureSelectionSetting_OnlyHighAccuracySignatures:
		if fv, exists := v.FldValidators["signature_selection_by_accuracy.only_high_accuracy_signatures"]; exists {
			val := m.GetSignatureSelectionByAccuracy().(*SignatureSelectionSetting_OnlyHighAccuracySignatures).OnlyHighAccuracySignatures
			vOpts := append(opts,
				db.WithValidateField("signature_selection_by_accuracy"),
				db.WithValidateField("only_high_accuracy_signatures"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SignatureSelectionSetting_HighMediumAccuracySignatures:
		if fv, exists := v.FldValidators["signature_selection_by_accuracy.high_medium_accuracy_signatures"]; exists {
			val := m.GetSignatureSelectionByAccuracy().(*SignatureSelectionSetting_HighMediumAccuracySignatures).HighMediumAccuracySignatures
			vOpts := append(opts,
				db.WithValidateField("signature_selection_by_accuracy"),
				db.WithValidateField("high_medium_accuracy_signatures"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SignatureSelectionSetting_HighMediumLowAccuracySignatures:
		if fv, exists := v.FldValidators["signature_selection_by_accuracy.high_medium_low_accuracy_signatures"]; exists {
			val := m.GetSignatureSelectionByAccuracy().(*SignatureSelectionSetting_HighMediumLowAccuracySignatures).HighMediumLowAccuracySignatures
			vOpts := append(opts,
				db.WithValidateField("signature_selection_by_accuracy"),
				db.WithValidateField("high_medium_low_accuracy_signatures"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSignatureSelectionSettingValidator = func() *ValidateSignatureSelectionSetting {
	v := &ValidateSignatureSelectionSetting{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAttackTypeSetting := v.AttackTypeSettingValidationRuleHandler
	rulesAttackTypeSetting := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAttackTypeSetting(rulesAttackTypeSetting)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SignatureSelectionSetting.attack_type_setting: %s", err)
		panic(errMsg)
	}
	v.FldValidators["attack_type_setting"] = vFn

	vrhSignatureSelectionByAccuracy := v.SignatureSelectionByAccuracyValidationRuleHandler
	rulesSignatureSelectionByAccuracy := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSignatureSelectionByAccuracy(rulesSignatureSelectionByAccuracy)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SignatureSelectionSetting.signature_selection_by_accuracy: %s", err)
		panic(errMsg)
	}
	v.FldValidators["signature_selection_by_accuracy"] = vFn

	v.FldValidators["attack_type_setting.enabled_attack_types"] = EnabledAttackTypesValidator().Validate

	return v
}()

func SignatureSelectionSettingValidator() db.Validator {
	return DefaultSignatureSelectionSettingValidator
}

// augmented methods on protoc/std generated struct

func (m *ViolationSetting) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ViolationSetting) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ViolationSetting) DeepCopy() *ViolationSetting {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ViolationSetting{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ViolationSetting) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ViolationSetting) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ViolationSettingValidator().Validate(ctx, m, opts...)
}

type ValidateViolationSetting struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateViolationSetting) EvasionViolationSettingValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for evasion_violation_setting")
	}
	return validatorFn, nil
}

func (v *ValidateViolationSetting) HttpProtocolViolationSettingValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for http_protocol_violation_setting")
	}
	return validatorFn, nil
}

func (v *ValidateViolationSetting) EnabledViolationTypesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ViolationType)
		return int32(i)
	}
	// ViolationType_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, ViolationType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for enabled_violation_types")
	}
	itemsValidatorFn := func(ctx context.Context, elems []ViolationType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for enabled_violation_types")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]ViolationType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []ViolationType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated enabled_violation_types")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items enabled_violation_types")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateViolationSetting) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ViolationSetting)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ViolationSetting got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["enabled_violation_types"]; exists {
		vOpts := append(opts, db.WithValidateField("enabled_violation_types"))
		if err := fv(ctx, m.GetEnabledViolationTypes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["evasion_violation_setting"]; exists {
		val := m.GetEvasionViolationSetting()
		vOpts := append(opts,
			db.WithValidateField("evasion_violation_setting"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetEvasionViolationSetting().(type) {
	case *ViolationSetting_DefaultEvasionViolationSettings:
		if fv, exists := v.FldValidators["evasion_violation_setting.default_evasion_violation_settings"]; exists {
			val := m.GetEvasionViolationSetting().(*ViolationSetting_DefaultEvasionViolationSettings).DefaultEvasionViolationSettings
			vOpts := append(opts,
				db.WithValidateField("evasion_violation_setting"),
				db.WithValidateField("default_evasion_violation_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ViolationSetting_EnabledEvasionViolations:
		if fv, exists := v.FldValidators["evasion_violation_setting.enabled_evasion_violations"]; exists {
			val := m.GetEvasionViolationSetting().(*ViolationSetting_EnabledEvasionViolations).EnabledEvasionViolations
			vOpts := append(opts,
				db.WithValidateField("evasion_violation_setting"),
				db.WithValidateField("enabled_evasion_violations"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["http_protocol_violation_setting"]; exists {
		val := m.GetHttpProtocolViolationSetting()
		vOpts := append(opts,
			db.WithValidateField("http_protocol_violation_setting"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetHttpProtocolViolationSetting().(type) {
	case *ViolationSetting_DefaultHttpProtocolViolationSettings:
		if fv, exists := v.FldValidators["http_protocol_violation_setting.default_http_protocol_violation_settings"]; exists {
			val := m.GetHttpProtocolViolationSetting().(*ViolationSetting_DefaultHttpProtocolViolationSettings).DefaultHttpProtocolViolationSettings
			vOpts := append(opts,
				db.WithValidateField("http_protocol_violation_setting"),
				db.WithValidateField("default_http_protocol_violation_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ViolationSetting_EnabledHttpProtocolViolations:
		if fv, exists := v.FldValidators["http_protocol_violation_setting.enabled_http_protocol_violations"]; exists {
			val := m.GetHttpProtocolViolationSetting().(*ViolationSetting_EnabledHttpProtocolViolations).EnabledHttpProtocolViolations
			vOpts := append(opts,
				db.WithValidateField("http_protocol_violation_setting"),
				db.WithValidateField("enabled_http_protocol_violations"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultViolationSettingValidator = func() *ValidateViolationSetting {
	v := &ValidateViolationSetting{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhEvasionViolationSetting := v.EvasionViolationSettingValidationRuleHandler
	rulesEvasionViolationSetting := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhEvasionViolationSetting(rulesEvasionViolationSetting)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ViolationSetting.evasion_violation_setting: %s", err)
		panic(errMsg)
	}
	v.FldValidators["evasion_violation_setting"] = vFn

	vrhHttpProtocolViolationSetting := v.HttpProtocolViolationSettingValidationRuleHandler
	rulesHttpProtocolViolationSetting := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhHttpProtocolViolationSetting(rulesHttpProtocolViolationSetting)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ViolationSetting.http_protocol_violation_setting: %s", err)
		panic(errMsg)
	}
	v.FldValidators["http_protocol_violation_setting"] = vFn

	vrhEnabledViolationTypes := v.EnabledViolationTypesValidationRuleHandler
	rulesEnabledViolationTypes := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "10",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhEnabledViolationTypes(rulesEnabledViolationTypes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ViolationSetting.enabled_violation_types: %s", err)
		panic(errMsg)
	}
	v.FldValidators["enabled_violation_types"] = vFn

	v.FldValidators["evasion_violation_setting.enabled_evasion_violations"] = EnabledEvasionSubViolationsValidator().Validate

	v.FldValidators["http_protocol_violation_setting.enabled_http_protocol_violations"] = EnabledHTTPProtocolSubViolationsValidator().Validate

	return v
}()

func ViolationSettingValidator() db.Validator {
	return DefaultViolationSettingValidator
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetDetectionSettingChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DetectionSettingChoice.(type) {
	case nil:
		o.DetectionSettingChoice = nil

	case *CreateSpecType_DefaultDetectionSettings:
		o.DetectionSettingChoice = &GlobalSpecType_DefaultDetectionSettings{DefaultDetectionSettings: of.DefaultDetectionSettings}

	case *CreateSpecType_DetectionSettings:
		o.DetectionSettingChoice = &GlobalSpecType_DetectionSettings{DetectionSettings: of.DetectionSettings}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetDetectionSettingChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DetectionSettingChoice.(type) {
	case nil:
		r.DetectionSettingChoice = nil

	case *GlobalSpecType_DefaultDetectionSettings:
		r.DetectionSettingChoice = &CreateSpecType_DefaultDetectionSettings{DefaultDetectionSettings: of.DefaultDetectionSettings}

	case *GlobalSpecType_DetectionSettings:
		r.DetectionSettingChoice = &CreateSpecType_DetectionSettings{DetectionSettings: of.DetectionSettings}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetEnforcementModeChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.EnforcementModeChoice.(type) {
	case nil:
		o.EnforcementModeChoice = nil

	case *CreateSpecType_Blocking:
		o.EnforcementModeChoice = &GlobalSpecType_Blocking{Blocking: of.Blocking}

	case *CreateSpecType_Monitoring:
		o.EnforcementModeChoice = &GlobalSpecType_Monitoring{Monitoring: of.Monitoring}

	case *CreateSpecType_UseLoadbalancerSetting:
		o.EnforcementModeChoice = &GlobalSpecType_UseLoadbalancerSetting{UseLoadbalancerSetting: of.UseLoadbalancerSetting}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetEnforcementModeChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.EnforcementModeChoice.(type) {
	case nil:
		r.EnforcementModeChoice = nil

	case *GlobalSpecType_Blocking:
		r.EnforcementModeChoice = &CreateSpecType_Blocking{Blocking: of.Blocking}

	case *GlobalSpecType_Monitoring:
		r.EnforcementModeChoice = &CreateSpecType_Monitoring{Monitoring: of.Monitoring}

	case *GlobalSpecType_UseLoadbalancerSetting:
		r.EnforcementModeChoice = &CreateSpecType_UseLoadbalancerSetting{UseLoadbalancerSetting: of.UseLoadbalancerSetting}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.GetDetectionSettingChoiceFromGlobalSpecType(f)
	m.GetEnforcementModeChoiceFromGlobalSpecType(f)
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	m1.SetDetectionSettingChoiceToGlobalSpecType(f)
	m1.SetEnforcementModeChoiceToGlobalSpecType(f)
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetDetectionSettingChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DetectionSettingChoice.(type) {
	case nil:
		o.DetectionSettingChoice = nil

	case *GetSpecType_DefaultDetectionSettings:
		o.DetectionSettingChoice = &GlobalSpecType_DefaultDetectionSettings{DefaultDetectionSettings: of.DefaultDetectionSettings}

	case *GetSpecType_DetectionSettings:
		o.DetectionSettingChoice = &GlobalSpecType_DetectionSettings{DetectionSettings: of.DetectionSettings}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetDetectionSettingChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DetectionSettingChoice.(type) {
	case nil:
		r.DetectionSettingChoice = nil

	case *GlobalSpecType_DefaultDetectionSettings:
		r.DetectionSettingChoice = &GetSpecType_DefaultDetectionSettings{DefaultDetectionSettings: of.DefaultDetectionSettings}

	case *GlobalSpecType_DetectionSettings:
		r.DetectionSettingChoice = &GetSpecType_DetectionSettings{DetectionSettings: of.DetectionSettings}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetEnforcementModeChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.EnforcementModeChoice.(type) {
	case nil:
		o.EnforcementModeChoice = nil

	case *GetSpecType_Blocking:
		o.EnforcementModeChoice = &GlobalSpecType_Blocking{Blocking: of.Blocking}

	case *GetSpecType_Monitoring:
		o.EnforcementModeChoice = &GlobalSpecType_Monitoring{Monitoring: of.Monitoring}

	case *GetSpecType_UseLoadbalancerSetting:
		o.EnforcementModeChoice = &GlobalSpecType_UseLoadbalancerSetting{UseLoadbalancerSetting: of.UseLoadbalancerSetting}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetEnforcementModeChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.EnforcementModeChoice.(type) {
	case nil:
		r.EnforcementModeChoice = nil

	case *GlobalSpecType_Blocking:
		r.EnforcementModeChoice = &GetSpecType_Blocking{Blocking: of.Blocking}

	case *GlobalSpecType_Monitoring:
		r.EnforcementModeChoice = &GetSpecType_Monitoring{Monitoring: of.Monitoring}

	case *GlobalSpecType_UseLoadbalancerSetting:
		r.EnforcementModeChoice = &GetSpecType_UseLoadbalancerSetting{UseLoadbalancerSetting: of.UseLoadbalancerSetting}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.GetDetectionSettingChoiceFromGlobalSpecType(f)
	m.GetEnforcementModeChoiceFromGlobalSpecType(f)
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	m1.SetDetectionSettingChoiceToGlobalSpecType(f)
	m1.SetEnforcementModeChoiceToGlobalSpecType(f)
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetDetectionSettingChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DetectionSettingChoice.(type) {
	case nil:
		o.DetectionSettingChoice = nil

	case *ReplaceSpecType_DefaultDetectionSettings:
		o.DetectionSettingChoice = &GlobalSpecType_DefaultDetectionSettings{DefaultDetectionSettings: of.DefaultDetectionSettings}

	case *ReplaceSpecType_DetectionSettings:
		o.DetectionSettingChoice = &GlobalSpecType_DetectionSettings{DetectionSettings: of.DetectionSettings}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetDetectionSettingChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DetectionSettingChoice.(type) {
	case nil:
		r.DetectionSettingChoice = nil

	case *GlobalSpecType_DefaultDetectionSettings:
		r.DetectionSettingChoice = &ReplaceSpecType_DefaultDetectionSettings{DefaultDetectionSettings: of.DefaultDetectionSettings}

	case *GlobalSpecType_DetectionSettings:
		r.DetectionSettingChoice = &ReplaceSpecType_DetectionSettings{DetectionSettings: of.DetectionSettings}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetEnforcementModeChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.EnforcementModeChoice.(type) {
	case nil:
		o.EnforcementModeChoice = nil

	case *ReplaceSpecType_Blocking:
		o.EnforcementModeChoice = &GlobalSpecType_Blocking{Blocking: of.Blocking}

	case *ReplaceSpecType_Monitoring:
		o.EnforcementModeChoice = &GlobalSpecType_Monitoring{Monitoring: of.Monitoring}

	case *ReplaceSpecType_UseLoadbalancerSetting:
		o.EnforcementModeChoice = &GlobalSpecType_UseLoadbalancerSetting{UseLoadbalancerSetting: of.UseLoadbalancerSetting}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetEnforcementModeChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.EnforcementModeChoice.(type) {
	case nil:
		r.EnforcementModeChoice = nil

	case *GlobalSpecType_Blocking:
		r.EnforcementModeChoice = &ReplaceSpecType_Blocking{Blocking: of.Blocking}

	case *GlobalSpecType_Monitoring:
		r.EnforcementModeChoice = &ReplaceSpecType_Monitoring{Monitoring: of.Monitoring}

	case *GlobalSpecType_UseLoadbalancerSetting:
		r.EnforcementModeChoice = &ReplaceSpecType_UseLoadbalancerSetting{UseLoadbalancerSetting: of.UseLoadbalancerSetting}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.GetDetectionSettingChoiceFromGlobalSpecType(f)
	m.GetEnforcementModeChoiceFromGlobalSpecType(f)
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	m1.SetDetectionSettingChoiceToGlobalSpecType(f)
	m1.SetEnforcementModeChoiceToGlobalSpecType(f)
}
