// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package app_firewall

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AiRiskBasedBlocking) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AiRiskBasedBlocking) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AiRiskBasedBlocking) DeepCopy() *AiRiskBasedBlocking {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AiRiskBasedBlocking{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AiRiskBasedBlocking) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AiRiskBasedBlocking) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AiRiskBasedBlockingValidator().Validate(ctx, m, opts...)
}

type ValidateAiRiskBasedBlocking struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAiRiskBasedBlocking) HighRiskActionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(RiskBasedBlockingAction)
		return int32(i)
	}
	// RiskBasedBlockingAction_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, RiskBasedBlockingAction_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for high_risk_action")
	}

	return validatorFn, nil
}

func (v *ValidateAiRiskBasedBlocking) MediumRiskActionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(RiskBasedBlockingAction)
		return int32(i)
	}
	// RiskBasedBlockingAction_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, RiskBasedBlockingAction_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for medium_risk_action")
	}

	return validatorFn, nil
}

func (v *ValidateAiRiskBasedBlocking) LowRiskActionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(RiskBasedBlockingAction)
		return int32(i)
	}
	// RiskBasedBlockingAction_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, RiskBasedBlockingAction_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for low_risk_action")
	}

	return validatorFn, nil
}

func (v *ValidateAiRiskBasedBlocking) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AiRiskBasedBlocking)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AiRiskBasedBlocking got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["high_risk_action"]; exists {

		vOpts := append(opts, db.WithValidateField("high_risk_action"))
		if err := fv(ctx, m.GetHighRiskAction(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["low_risk_action"]; exists {

		vOpts := append(opts, db.WithValidateField("low_risk_action"))
		if err := fv(ctx, m.GetLowRiskAction(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["medium_risk_action"]; exists {

		vOpts := append(opts, db.WithValidateField("medium_risk_action"))
		if err := fv(ctx, m.GetMediumRiskAction(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAiRiskBasedBlockingValidator = func() *ValidateAiRiskBasedBlocking {
	v := &ValidateAiRiskBasedBlocking{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHighRiskAction := v.HighRiskActionValidationRuleHandler
	rulesHighRiskAction := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhHighRiskAction(rulesHighRiskAction)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AiRiskBasedBlocking.high_risk_action: %s", err)
		panic(errMsg)
	}
	v.FldValidators["high_risk_action"] = vFn

	vrhMediumRiskAction := v.MediumRiskActionValidationRuleHandler
	rulesMediumRiskAction := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhMediumRiskAction(rulesMediumRiskAction)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AiRiskBasedBlocking.medium_risk_action: %s", err)
		panic(errMsg)
	}
	v.FldValidators["medium_risk_action"] = vFn

	vrhLowRiskAction := v.LowRiskActionValidationRuleHandler
	rulesLowRiskAction := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhLowRiskAction(rulesLowRiskAction)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AiRiskBasedBlocking.low_risk_action: %s", err)
		panic(errMsg)
	}
	v.FldValidators["low_risk_action"] = vFn

	return v
}()

func AiRiskBasedBlockingValidator() db.Validator {
	return DefaultAiRiskBasedBlockingValidator
}

// augmented methods on protoc/std generated struct

func (m *AllowedResponseCodes) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AllowedResponseCodes) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AllowedResponseCodes) DeepCopy() *AllowedResponseCodes {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AllowedResponseCodes{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AllowedResponseCodes) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AllowedResponseCodes) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AllowedResponseCodesValidator().Validate(ctx, m, opts...)
}

type ValidateAllowedResponseCodes struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAllowedResponseCodes) ResponseCodeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepUint32ItemRules(rules)
	itemValFn, err := db.NewUint32ValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for response_code")
	}
	itemsValidatorFn := func(ctx context.Context, elems []uint32, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for response_code")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]uint32)
		if !ok {
			return fmt.Errorf("Repeated validation expected []uint32, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated response_code")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items response_code")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAllowedResponseCodes) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AllowedResponseCodes)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AllowedResponseCodes got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["response_code"]; exists {
		vOpts := append(opts, db.WithValidateField("response_code"))
		if err := fv(ctx, m.GetResponseCode(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAllowedResponseCodesValidator = func() *ValidateAllowedResponseCodes {
	v := &ValidateAllowedResponseCodes{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhResponseCode := v.ResponseCodeValidationRuleHandler
	rulesResponseCode := map[string]string{
		"ves.io.schema.rules.message.required":          "true",
		"ves.io.schema.rules.repeated.items.uint32.gte": "100",
		"ves.io.schema.rules.repeated.items.uint32.lte": "599",
		"ves.io.schema.rules.repeated.max_items":        "48",
		"ves.io.schema.rules.repeated.min_items":        "1",
		"ves.io.schema.rules.repeated.unique":           "true",
	}
	vFn, err = vrhResponseCode(rulesResponseCode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AllowedResponseCodes.response_code: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_code"] = vFn

	return v
}()

func AllowedResponseCodesValidator() db.Validator {
	return DefaultAllowedResponseCodesValidator
}

// augmented methods on protoc/std generated struct

func (m *AnonymizationConfiguration) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AnonymizationConfiguration) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AnonymizationConfiguration) DeepCopy() *AnonymizationConfiguration {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AnonymizationConfiguration{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AnonymizationConfiguration) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AnonymizationConfiguration) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AnonymizationConfigurationValidator().Validate(ctx, m, opts...)
}

type ValidateAnonymizationConfiguration struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAnonymizationConfiguration) AnonymizationChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for anonymization_choice")
	}
	return validatorFn, nil
}

func (v *ValidateAnonymizationConfiguration) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AnonymizationConfiguration)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AnonymizationConfiguration got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["anonymization_choice"]; exists {
		val := m.GetAnonymizationChoice()
		vOpts := append(opts,
			db.WithValidateField("anonymization_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAnonymizationChoice().(type) {
	case *AnonymizationConfiguration_HttpHeader:
		if fv, exists := v.FldValidators["anonymization_choice.http_header"]; exists {
			val := m.GetAnonymizationChoice().(*AnonymizationConfiguration_HttpHeader).HttpHeader
			vOpts := append(opts,
				db.WithValidateField("anonymization_choice"),
				db.WithValidateField("http_header"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AnonymizationConfiguration_QueryParameter:
		if fv, exists := v.FldValidators["anonymization_choice.query_parameter"]; exists {
			val := m.GetAnonymizationChoice().(*AnonymizationConfiguration_QueryParameter).QueryParameter
			vOpts := append(opts,
				db.WithValidateField("anonymization_choice"),
				db.WithValidateField("query_parameter"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *AnonymizationConfiguration_Cookie:
		if fv, exists := v.FldValidators["anonymization_choice.cookie"]; exists {
			val := m.GetAnonymizationChoice().(*AnonymizationConfiguration_Cookie).Cookie
			vOpts := append(opts,
				db.WithValidateField("anonymization_choice"),
				db.WithValidateField("cookie"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAnonymizationConfigurationValidator = func() *ValidateAnonymizationConfiguration {
	v := &ValidateAnonymizationConfiguration{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAnonymizationChoice := v.AnonymizationChoiceValidationRuleHandler
	rulesAnonymizationChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAnonymizationChoice(rulesAnonymizationChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AnonymizationConfiguration.anonymization_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["anonymization_choice"] = vFn

	v.FldValidators["anonymization_choice.http_header"] = AnonymizeHttpHeaderValidator().Validate
	v.FldValidators["anonymization_choice.query_parameter"] = AnonymizeHttpQueryParameterValidator().Validate
	v.FldValidators["anonymization_choice.cookie"] = AnonymizeHttpCookieValidator().Validate

	return v
}()

func AnonymizationConfigurationValidator() db.Validator {
	return DefaultAnonymizationConfigurationValidator
}

// augmented methods on protoc/std generated struct

func (m *AnonymizationSetting) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AnonymizationSetting) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AnonymizationSetting) DeepCopy() *AnonymizationSetting {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AnonymizationSetting{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AnonymizationSetting) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AnonymizationSetting) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AnonymizationSettingValidator().Validate(ctx, m, opts...)
}

type ValidateAnonymizationSetting struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAnonymizationSetting) AnonymizationConfigValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for anonymization_config")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*AnonymizationConfiguration, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := AnonymizationConfigurationValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for anonymization_config")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*AnonymizationConfiguration)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*AnonymizationConfiguration, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated anonymization_config")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items anonymization_config")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAnonymizationSetting) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AnonymizationSetting)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AnonymizationSetting got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["anonymization_config"]; exists {
		vOpts := append(opts, db.WithValidateField("anonymization_config"))
		if err := fv(ctx, m.GetAnonymizationConfig(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAnonymizationSettingValidator = func() *ValidateAnonymizationSetting {
	v := &ValidateAnonymizationSetting{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAnonymizationConfig := v.AnonymizationConfigValidationRuleHandler
	rulesAnonymizationConfig := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhAnonymizationConfig(rulesAnonymizationConfig)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AnonymizationSetting.anonymization_config: %s", err)
		panic(errMsg)
	}
	v.FldValidators["anonymization_config"] = vFn

	return v
}()

func AnonymizationSettingValidator() db.Validator {
	return DefaultAnonymizationSettingValidator
}

// augmented methods on protoc/std generated struct

func (m *AnonymizeHttpCookie) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AnonymizeHttpCookie) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AnonymizeHttpCookie) DeepCopy() *AnonymizeHttpCookie {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AnonymizeHttpCookie{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AnonymizeHttpCookie) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AnonymizeHttpCookie) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AnonymizeHttpCookieValidator().Validate(ctx, m, opts...)
}

type ValidateAnonymizeHttpCookie struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAnonymizeHttpCookie) CookieNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cookie_name")
	}

	return validatorFn, nil
}

func (v *ValidateAnonymizeHttpCookie) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AnonymizeHttpCookie)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AnonymizeHttpCookie got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cookie_name"]; exists {

		vOpts := append(opts, db.WithValidateField("cookie_name"))
		if err := fv(ctx, m.GetCookieName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAnonymizeHttpCookieValidator = func() *ValidateAnonymizeHttpCookie {
	v := &ValidateAnonymizeHttpCookie{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCookieName := v.CookieNameValidationRuleHandler
	rulesCookieName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFn, err = vrhCookieName(rulesCookieName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AnonymizeHttpCookie.cookie_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cookie_name"] = vFn

	return v
}()

func AnonymizeHttpCookieValidator() db.Validator {
	return DefaultAnonymizeHttpCookieValidator
}

// augmented methods on protoc/std generated struct

func (m *AnonymizeHttpHeader) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AnonymizeHttpHeader) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AnonymizeHttpHeader) DeepCopy() *AnonymizeHttpHeader {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AnonymizeHttpHeader{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AnonymizeHttpHeader) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AnonymizeHttpHeader) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AnonymizeHttpHeaderValidator().Validate(ctx, m, opts...)
}

type ValidateAnonymizeHttpHeader struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAnonymizeHttpHeader) HeaderNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for header_name")
	}

	return validatorFn, nil
}

func (v *ValidateAnonymizeHttpHeader) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AnonymizeHttpHeader)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AnonymizeHttpHeader got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["header_name"]; exists {

		vOpts := append(opts, db.WithValidateField("header_name"))
		if err := fv(ctx, m.GetHeaderName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAnonymizeHttpHeaderValidator = func() *ValidateAnonymizeHttpHeader {
	v := &ValidateAnonymizeHttpHeader{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhHeaderName := v.HeaderNameValidationRuleHandler
	rulesHeaderName := map[string]string{
		"ves.io.schema.rules.message.required":         "true",
		"ves.io.schema.rules.string.http_header_field": "true",
	}
	vFn, err = vrhHeaderName(rulesHeaderName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AnonymizeHttpHeader.header_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["header_name"] = vFn

	return v
}()

func AnonymizeHttpHeaderValidator() db.Validator {
	return DefaultAnonymizeHttpHeaderValidator
}

// augmented methods on protoc/std generated struct

func (m *AnonymizeHttpQueryParameter) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AnonymizeHttpQueryParameter) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AnonymizeHttpQueryParameter) DeepCopy() *AnonymizeHttpQueryParameter {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AnonymizeHttpQueryParameter{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AnonymizeHttpQueryParameter) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AnonymizeHttpQueryParameter) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AnonymizeHttpQueryParameterValidator().Validate(ctx, m, opts...)
}

type ValidateAnonymizeHttpQueryParameter struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAnonymizeHttpQueryParameter) QueryParamNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for query_param_name")
	}

	return validatorFn, nil
}

func (v *ValidateAnonymizeHttpQueryParameter) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AnonymizeHttpQueryParameter)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AnonymizeHttpQueryParameter got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["query_param_name"]; exists {

		vOpts := append(opts, db.WithValidateField("query_param_name"))
		if err := fv(ctx, m.GetQueryParamName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAnonymizeHttpQueryParameterValidator = func() *ValidateAnonymizeHttpQueryParameter {
	v := &ValidateAnonymizeHttpQueryParameter{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhQueryParamName := v.QueryParamNameValidationRuleHandler
	rulesQueryParamName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "256",
	}
	vFn, err = vrhQueryParamName(rulesQueryParamName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AnonymizeHttpQueryParameter.query_param_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["query_param_name"] = vFn

	return v
}()

func AnonymizeHttpQueryParameterValidator() db.Validator {
	return DefaultAnonymizeHttpQueryParameterValidator
}

// augmented methods on protoc/std generated struct

func (m *AttackTypeSettings) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AttackTypeSettings) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AttackTypeSettings) DeepCopy() *AttackTypeSettings {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AttackTypeSettings{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AttackTypeSettings) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AttackTypeSettings) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AttackTypeSettingsValidator().Validate(ctx, m, opts...)
}

type ValidateAttackTypeSettings struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAttackTypeSettings) DisabledAttackTypesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(AttackType)
		return int32(i)
	}
	// AttackType_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, AttackType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for disabled_attack_types")
	}
	itemsValidatorFn := func(ctx context.Context, elems []AttackType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for disabled_attack_types")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]AttackType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []AttackType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated disabled_attack_types")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items disabled_attack_types")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateAttackTypeSettings) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AttackTypeSettings)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AttackTypeSettings got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["disabled_attack_types"]; exists {
		vOpts := append(opts, db.WithValidateField("disabled_attack_types"))
		if err := fv(ctx, m.GetDisabledAttackTypes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAttackTypeSettingsValidator = func() *ValidateAttackTypeSettings {
	v := &ValidateAttackTypeSettings{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDisabledAttackTypes := v.DisabledAttackTypesValidationRuleHandler
	rulesDisabledAttackTypes := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "22",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhDisabledAttackTypes(rulesDisabledAttackTypes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for AttackTypeSettings.disabled_attack_types: %s", err)
		panic(errMsg)
	}
	v.FldValidators["disabled_attack_types"] = vFn

	return v
}()

func AttackTypeSettingsValidator() db.Validator {
	return DefaultAttackTypeSettingsValidator
}

// augmented methods on protoc/std generated struct

func (m *BotProtectionSetting) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BotProtectionSetting) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BotProtectionSetting) DeepCopy() *BotProtectionSetting {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BotProtectionSetting{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BotProtectionSetting) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BotProtectionSetting) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BotProtectionSettingValidator().Validate(ctx, m, opts...)
}

type ValidateBotProtectionSetting struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBotProtectionSetting) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BotProtectionSetting)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BotProtectionSetting got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["good_bot_action"]; exists {

		vOpts := append(opts, db.WithValidateField("good_bot_action"))
		if err := fv(ctx, m.GetGoodBotAction(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["malicious_bot_action"]; exists {

		vOpts := append(opts, db.WithValidateField("malicious_bot_action"))
		if err := fv(ctx, m.GetMaliciousBotAction(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["suspicious_bot_action"]; exists {

		vOpts := append(opts, db.WithValidateField("suspicious_bot_action"))
		if err := fv(ctx, m.GetSuspiciousBotAction(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBotProtectionSettingValidator = func() *ValidateBotProtectionSetting {
	v := &ValidateBotProtectionSetting{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func BotProtectionSettingValidator() db.Validator {
	return DefaultBotProtectionSettingValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) AllowedResponseCodesChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for allowed_response_codes_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) AnonymizationSettingValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for anonymization_setting")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) BlockingPageChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for blocking_page_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) BotProtectionChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bot_protection_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) DetectionSettingChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for detection_setting_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) EnforcementModeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for enforcement_mode_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["allowed_response_codes_choice"]; exists {
		val := m.GetAllowedResponseCodesChoice()
		vOpts := append(opts,
			db.WithValidateField("allowed_response_codes_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAllowedResponseCodesChoice().(type) {
	case *CreateSpecType_AllowAllResponseCodes:
		if fv, exists := v.FldValidators["allowed_response_codes_choice.allow_all_response_codes"]; exists {
			val := m.GetAllowedResponseCodesChoice().(*CreateSpecType_AllowAllResponseCodes).AllowAllResponseCodes
			vOpts := append(opts,
				db.WithValidateField("allowed_response_codes_choice"),
				db.WithValidateField("allow_all_response_codes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_AllowedResponseCodes:
		if fv, exists := v.FldValidators["allowed_response_codes_choice.allowed_response_codes"]; exists {
			val := m.GetAllowedResponseCodesChoice().(*CreateSpecType_AllowedResponseCodes).AllowedResponseCodes
			vOpts := append(opts,
				db.WithValidateField("allowed_response_codes_choice"),
				db.WithValidateField("allowed_response_codes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["anonymization_setting"]; exists {
		val := m.GetAnonymizationSetting()
		vOpts := append(opts,
			db.WithValidateField("anonymization_setting"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAnonymizationSetting().(type) {
	case *CreateSpecType_DisableAnonymization:
		if fv, exists := v.FldValidators["anonymization_setting.disable_anonymization"]; exists {
			val := m.GetAnonymizationSetting().(*CreateSpecType_DisableAnonymization).DisableAnonymization
			vOpts := append(opts,
				db.WithValidateField("anonymization_setting"),
				db.WithValidateField("disable_anonymization"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_DefaultAnonymization:
		if fv, exists := v.FldValidators["anonymization_setting.default_anonymization"]; exists {
			val := m.GetAnonymizationSetting().(*CreateSpecType_DefaultAnonymization).DefaultAnonymization
			vOpts := append(opts,
				db.WithValidateField("anonymization_setting"),
				db.WithValidateField("default_anonymization"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_CustomAnonymization:
		if fv, exists := v.FldValidators["anonymization_setting.custom_anonymization"]; exists {
			val := m.GetAnonymizationSetting().(*CreateSpecType_CustomAnonymization).CustomAnonymization
			vOpts := append(opts,
				db.WithValidateField("anonymization_setting"),
				db.WithValidateField("custom_anonymization"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["blocking_page_choice"]; exists {
		val := m.GetBlockingPageChoice()
		vOpts := append(opts,
			db.WithValidateField("blocking_page_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetBlockingPageChoice().(type) {
	case *CreateSpecType_UseDefaultBlockingPage:
		if fv, exists := v.FldValidators["blocking_page_choice.use_default_blocking_page"]; exists {
			val := m.GetBlockingPageChoice().(*CreateSpecType_UseDefaultBlockingPage).UseDefaultBlockingPage
			vOpts := append(opts,
				db.WithValidateField("blocking_page_choice"),
				db.WithValidateField("use_default_blocking_page"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_BlockingPage:
		if fv, exists := v.FldValidators["blocking_page_choice.blocking_page"]; exists {
			val := m.GetBlockingPageChoice().(*CreateSpecType_BlockingPage).BlockingPage
			vOpts := append(opts,
				db.WithValidateField("blocking_page_choice"),
				db.WithValidateField("blocking_page"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["bot_protection_choice"]; exists {
		val := m.GetBotProtectionChoice()
		vOpts := append(opts,
			db.WithValidateField("bot_protection_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetBotProtectionChoice().(type) {
	case *CreateSpecType_DefaultBotSetting:
		if fv, exists := v.FldValidators["bot_protection_choice.default_bot_setting"]; exists {
			val := m.GetBotProtectionChoice().(*CreateSpecType_DefaultBotSetting).DefaultBotSetting
			vOpts := append(opts,
				db.WithValidateField("bot_protection_choice"),
				db.WithValidateField("default_bot_setting"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_BotProtectionSetting:
		if fv, exists := v.FldValidators["bot_protection_choice.bot_protection_setting"]; exists {
			val := m.GetBotProtectionChoice().(*CreateSpecType_BotProtectionSetting).BotProtectionSetting
			vOpts := append(opts,
				db.WithValidateField("bot_protection_choice"),
				db.WithValidateField("bot_protection_setting"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["detection_setting_choice"]; exists {
		val := m.GetDetectionSettingChoice()
		vOpts := append(opts,
			db.WithValidateField("detection_setting_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDetectionSettingChoice().(type) {
	case *CreateSpecType_DefaultDetectionSettings:
		if fv, exists := v.FldValidators["detection_setting_choice.default_detection_settings"]; exists {
			val := m.GetDetectionSettingChoice().(*CreateSpecType_DefaultDetectionSettings).DefaultDetectionSettings
			vOpts := append(opts,
				db.WithValidateField("detection_setting_choice"),
				db.WithValidateField("default_detection_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_DetectionSettings:
		if fv, exists := v.FldValidators["detection_setting_choice.detection_settings"]; exists {
			val := m.GetDetectionSettingChoice().(*CreateSpecType_DetectionSettings).DetectionSettings
			vOpts := append(opts,
				db.WithValidateField("detection_setting_choice"),
				db.WithValidateField("detection_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_AiRiskBasedBlocking:
		if fv, exists := v.FldValidators["detection_setting_choice.ai_risk_based_blocking"]; exists {
			val := m.GetDetectionSettingChoice().(*CreateSpecType_AiRiskBasedBlocking).AiRiskBasedBlocking
			vOpts := append(opts,
				db.WithValidateField("detection_setting_choice"),
				db.WithValidateField("ai_risk_based_blocking"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["enforcement_mode_choice"]; exists {
		val := m.GetEnforcementModeChoice()
		vOpts := append(opts,
			db.WithValidateField("enforcement_mode_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetEnforcementModeChoice().(type) {
	case *CreateSpecType_UseLoadbalancerSetting:
		if fv, exists := v.FldValidators["enforcement_mode_choice.use_loadbalancer_setting"]; exists {
			val := m.GetEnforcementModeChoice().(*CreateSpecType_UseLoadbalancerSetting).UseLoadbalancerSetting
			vOpts := append(opts,
				db.WithValidateField("enforcement_mode_choice"),
				db.WithValidateField("use_loadbalancer_setting"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_Blocking:
		if fv, exists := v.FldValidators["enforcement_mode_choice.blocking"]; exists {
			val := m.GetEnforcementModeChoice().(*CreateSpecType_Blocking).Blocking
			vOpts := append(opts,
				db.WithValidateField("enforcement_mode_choice"),
				db.WithValidateField("blocking"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_Monitoring:
		if fv, exists := v.FldValidators["enforcement_mode_choice.monitoring"]; exists {
			val := m.GetEnforcementModeChoice().(*CreateSpecType_Monitoring).Monitoring
			vOpts := append(opts,
				db.WithValidateField("enforcement_mode_choice"),
				db.WithValidateField("monitoring"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAllowedResponseCodesChoice := v.AllowedResponseCodesChoiceValidationRuleHandler
	rulesAllowedResponseCodesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAllowedResponseCodesChoice(rulesAllowedResponseCodesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.allowed_response_codes_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["allowed_response_codes_choice"] = vFn

	vrhAnonymizationSetting := v.AnonymizationSettingValidationRuleHandler
	rulesAnonymizationSetting := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAnonymizationSetting(rulesAnonymizationSetting)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.anonymization_setting: %s", err)
		panic(errMsg)
	}
	v.FldValidators["anonymization_setting"] = vFn

	vrhBlockingPageChoice := v.BlockingPageChoiceValidationRuleHandler
	rulesBlockingPageChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhBlockingPageChoice(rulesBlockingPageChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.blocking_page_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["blocking_page_choice"] = vFn

	vrhBotProtectionChoice := v.BotProtectionChoiceValidationRuleHandler
	rulesBotProtectionChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhBotProtectionChoice(rulesBotProtectionChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.bot_protection_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bot_protection_choice"] = vFn

	vrhDetectionSettingChoice := v.DetectionSettingChoiceValidationRuleHandler
	rulesDetectionSettingChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDetectionSettingChoice(rulesDetectionSettingChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.detection_setting_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["detection_setting_choice"] = vFn

	vrhEnforcementModeChoice := v.EnforcementModeChoiceValidationRuleHandler
	rulesEnforcementModeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhEnforcementModeChoice(rulesEnforcementModeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.enforcement_mode_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["enforcement_mode_choice"] = vFn

	v.FldValidators["allowed_response_codes_choice.allowed_response_codes"] = AllowedResponseCodesValidator().Validate

	v.FldValidators["anonymization_setting.custom_anonymization"] = AnonymizationSettingValidator().Validate

	v.FldValidators["blocking_page_choice.blocking_page"] = CustomBlockingPageValidator().Validate

	v.FldValidators["detection_setting_choice.detection_settings"] = DetectionSettingValidator().Validate
	v.FldValidators["detection_setting_choice.ai_risk_based_blocking"] = AiRiskBasedBlockingValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CustomBlockingPage) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CustomBlockingPage) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CustomBlockingPage) DeepCopy() *CustomBlockingPage {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CustomBlockingPage{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CustomBlockingPage) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CustomBlockingPage) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CustomBlockingPageValidator().Validate(ctx, m, opts...)
}

type ValidateCustomBlockingPage struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCustomBlockingPage) BlockingPageValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for blocking_page")
	}

	return validatorFn, nil
}

func (v *ValidateCustomBlockingPage) ResponseCodeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.HttpStatusCode)
		return int32(i)
	}
	// ves_io_schema.HttpStatusCode_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.HttpStatusCode_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for response_code")
	}

	return validatorFn, nil
}

func (v *ValidateCustomBlockingPage) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CustomBlockingPage)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CustomBlockingPage got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["blocking_page"]; exists {

		vOpts := append(opts, db.WithValidateField("blocking_page"))
		if err := fv(ctx, m.GetBlockingPage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["response_code"]; exists {

		vOpts := append(opts, db.WithValidateField("response_code"))
		if err := fv(ctx, m.GetResponseCode(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCustomBlockingPageValidator = func() *ValidateCustomBlockingPage {
	v := &ValidateCustomBlockingPage{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhBlockingPage := v.BlockingPageValidationRuleHandler
	rulesBlockingPage := map[string]string{
		"ves.io.schema.rules.string.max_len": "4096",
		"ves.io.schema.rules.string.uri_ref": "true",
	}
	vFn, err = vrhBlockingPage(rulesBlockingPage)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CustomBlockingPage.blocking_page: %s", err)
		panic(errMsg)
	}
	v.FldValidators["blocking_page"] = vFn

	vrhResponseCode := v.ResponseCodeValidationRuleHandler
	rulesResponseCode := map[string]string{
		"ves.io.schema.rules.enum.defined_only": "true",
		"ves.io.schema.rules.enum.not_in":       "[0]",
	}
	vFn, err = vrhResponseCode(rulesResponseCode)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CustomBlockingPage.response_code: %s", err)
		panic(errMsg)
	}
	v.FldValidators["response_code"] = vFn

	return v
}()

func CustomBlockingPageValidator() db.Validator {
	return DefaultCustomBlockingPageValidator
}

// augmented methods on protoc/std generated struct

func (m *DetectionSetting) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DetectionSetting) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DetectionSetting) DeepCopy() *DetectionSetting {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DetectionSetting{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DetectionSetting) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DetectionSetting) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DetectionSettingValidator().Validate(ctx, m, opts...)
}

type ValidateDetectionSetting struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDetectionSetting) FalsePositiveSuppressionValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for false_positive_suppression")
	}
	return validatorFn, nil
}

func (v *ValidateDetectionSetting) ThreatCampaignChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for threat_campaign_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDetectionSetting) ViolationDetectionSettingValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for violation_detection_setting")
	}
	return validatorFn, nil
}

func (v *ValidateDetectionSetting) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DetectionSetting)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DetectionSetting got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["false_positive_suppression"]; exists {
		val := m.GetFalsePositiveSuppression()
		vOpts := append(opts,
			db.WithValidateField("false_positive_suppression"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetFalsePositiveSuppression().(type) {
	case *DetectionSetting_EnableSuppression:
		if fv, exists := v.FldValidators["false_positive_suppression.enable_suppression"]; exists {
			val := m.GetFalsePositiveSuppression().(*DetectionSetting_EnableSuppression).EnableSuppression
			vOpts := append(opts,
				db.WithValidateField("false_positive_suppression"),
				db.WithValidateField("enable_suppression"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DetectionSetting_DisableSuppression:
		if fv, exists := v.FldValidators["false_positive_suppression.disable_suppression"]; exists {
			val := m.GetFalsePositiveSuppression().(*DetectionSetting_DisableSuppression).DisableSuppression
			vOpts := append(opts,
				db.WithValidateField("false_positive_suppression"),
				db.WithValidateField("disable_suppression"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["signature_selection_setting"]; exists {

		vOpts := append(opts, db.WithValidateField("signature_selection_setting"))
		if err := fv(ctx, m.GetSignatureSelectionSetting(), vOpts...); err != nil {
			return err
		}

	}

	switch m.GetSignaturesStagingSettings().(type) {
	case *DetectionSetting_DisableStaging:
		if fv, exists := v.FldValidators["signatures_staging_settings.disable_staging"]; exists {
			val := m.GetSignaturesStagingSettings().(*DetectionSetting_DisableStaging).DisableStaging
			vOpts := append(opts,
				db.WithValidateField("signatures_staging_settings"),
				db.WithValidateField("disable_staging"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DetectionSetting_StageNewSignatures:
		if fv, exists := v.FldValidators["signatures_staging_settings.stage_new_signatures"]; exists {
			val := m.GetSignaturesStagingSettings().(*DetectionSetting_StageNewSignatures).StageNewSignatures
			vOpts := append(opts,
				db.WithValidateField("signatures_staging_settings"),
				db.WithValidateField("stage_new_signatures"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DetectionSetting_StageNewAndUpdatedSignatures:
		if fv, exists := v.FldValidators["signatures_staging_settings.stage_new_and_updated_signatures"]; exists {
			val := m.GetSignaturesStagingSettings().(*DetectionSetting_StageNewAndUpdatedSignatures).StageNewAndUpdatedSignatures
			vOpts := append(opts,
				db.WithValidateField("signatures_staging_settings"),
				db.WithValidateField("stage_new_and_updated_signatures"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["threat_campaign_choice"]; exists {
		val := m.GetThreatCampaignChoice()
		vOpts := append(opts,
			db.WithValidateField("threat_campaign_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetThreatCampaignChoice().(type) {
	case *DetectionSetting_EnableThreatCampaigns:
		if fv, exists := v.FldValidators["threat_campaign_choice.enable_threat_campaigns"]; exists {
			val := m.GetThreatCampaignChoice().(*DetectionSetting_EnableThreatCampaigns).EnableThreatCampaigns
			vOpts := append(opts,
				db.WithValidateField("threat_campaign_choice"),
				db.WithValidateField("enable_threat_campaigns"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DetectionSetting_DisableThreatCampaigns:
		if fv, exists := v.FldValidators["threat_campaign_choice.disable_threat_campaigns"]; exists {
			val := m.GetThreatCampaignChoice().(*DetectionSetting_DisableThreatCampaigns).DisableThreatCampaigns
			vOpts := append(opts,
				db.WithValidateField("threat_campaign_choice"),
				db.WithValidateField("disable_threat_campaigns"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["violation_detection_setting"]; exists {
		val := m.GetViolationDetectionSetting()
		vOpts := append(opts,
			db.WithValidateField("violation_detection_setting"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetViolationDetectionSetting().(type) {
	case *DetectionSetting_DefaultViolationSettings:
		if fv, exists := v.FldValidators["violation_detection_setting.default_violation_settings"]; exists {
			val := m.GetViolationDetectionSetting().(*DetectionSetting_DefaultViolationSettings).DefaultViolationSettings
			vOpts := append(opts,
				db.WithValidateField("violation_detection_setting"),
				db.WithValidateField("default_violation_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DetectionSetting_ViolationSettings:
		if fv, exists := v.FldValidators["violation_detection_setting.violation_settings"]; exists {
			val := m.GetViolationDetectionSetting().(*DetectionSetting_ViolationSettings).ViolationSettings
			vOpts := append(opts,
				db.WithValidateField("violation_detection_setting"),
				db.WithValidateField("violation_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDetectionSettingValidator = func() *ValidateDetectionSetting {
	v := &ValidateDetectionSetting{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhFalsePositiveSuppression := v.FalsePositiveSuppressionValidationRuleHandler
	rulesFalsePositiveSuppression := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhFalsePositiveSuppression(rulesFalsePositiveSuppression)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DetectionSetting.false_positive_suppression: %s", err)
		panic(errMsg)
	}
	v.FldValidators["false_positive_suppression"] = vFn

	vrhThreatCampaignChoice := v.ThreatCampaignChoiceValidationRuleHandler
	rulesThreatCampaignChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhThreatCampaignChoice(rulesThreatCampaignChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DetectionSetting.threat_campaign_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["threat_campaign_choice"] = vFn

	vrhViolationDetectionSetting := v.ViolationDetectionSettingValidationRuleHandler
	rulesViolationDetectionSetting := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhViolationDetectionSetting(rulesViolationDetectionSetting)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DetectionSetting.violation_detection_setting: %s", err)
		panic(errMsg)
	}
	v.FldValidators["violation_detection_setting"] = vFn

	v.FldValidators["signatures_staging_settings.stage_new_signatures"] = SignaturesStagingSettingsValidator().Validate
	v.FldValidators["signatures_staging_settings.stage_new_and_updated_signatures"] = SignaturesStagingSettingsValidator().Validate

	v.FldValidators["violation_detection_setting.violation_settings"] = ViolationSettingsValidator().Validate

	v.FldValidators["signature_selection_setting"] = SignatureSelectionSettingValidator().Validate

	return v
}()

func DetectionSettingValidator() db.Validator {
	return DefaultDetectionSettingValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) AllowedResponseCodesChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for allowed_response_codes_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) AnonymizationSettingValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for anonymization_setting")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) BlockingPageChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for blocking_page_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) BotProtectionChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bot_protection_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) DetectionSettingChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for detection_setting_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) EnforcementModeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for enforcement_mode_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["allowed_response_codes_choice"]; exists {
		val := m.GetAllowedResponseCodesChoice()
		vOpts := append(opts,
			db.WithValidateField("allowed_response_codes_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAllowedResponseCodesChoice().(type) {
	case *GetSpecType_AllowAllResponseCodes:
		if fv, exists := v.FldValidators["allowed_response_codes_choice.allow_all_response_codes"]; exists {
			val := m.GetAllowedResponseCodesChoice().(*GetSpecType_AllowAllResponseCodes).AllowAllResponseCodes
			vOpts := append(opts,
				db.WithValidateField("allowed_response_codes_choice"),
				db.WithValidateField("allow_all_response_codes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_AllowedResponseCodes:
		if fv, exists := v.FldValidators["allowed_response_codes_choice.allowed_response_codes"]; exists {
			val := m.GetAllowedResponseCodesChoice().(*GetSpecType_AllowedResponseCodes).AllowedResponseCodes
			vOpts := append(opts,
				db.WithValidateField("allowed_response_codes_choice"),
				db.WithValidateField("allowed_response_codes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["anonymization_setting"]; exists {
		val := m.GetAnonymizationSetting()
		vOpts := append(opts,
			db.WithValidateField("anonymization_setting"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAnonymizationSetting().(type) {
	case *GetSpecType_DisableAnonymization:
		if fv, exists := v.FldValidators["anonymization_setting.disable_anonymization"]; exists {
			val := m.GetAnonymizationSetting().(*GetSpecType_DisableAnonymization).DisableAnonymization
			vOpts := append(opts,
				db.WithValidateField("anonymization_setting"),
				db.WithValidateField("disable_anonymization"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_DefaultAnonymization:
		if fv, exists := v.FldValidators["anonymization_setting.default_anonymization"]; exists {
			val := m.GetAnonymizationSetting().(*GetSpecType_DefaultAnonymization).DefaultAnonymization
			vOpts := append(opts,
				db.WithValidateField("anonymization_setting"),
				db.WithValidateField("default_anonymization"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_CustomAnonymization:
		if fv, exists := v.FldValidators["anonymization_setting.custom_anonymization"]; exists {
			val := m.GetAnonymizationSetting().(*GetSpecType_CustomAnonymization).CustomAnonymization
			vOpts := append(opts,
				db.WithValidateField("anonymization_setting"),
				db.WithValidateField("custom_anonymization"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["blocking_page_choice"]; exists {
		val := m.GetBlockingPageChoice()
		vOpts := append(opts,
			db.WithValidateField("blocking_page_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetBlockingPageChoice().(type) {
	case *GetSpecType_UseDefaultBlockingPage:
		if fv, exists := v.FldValidators["blocking_page_choice.use_default_blocking_page"]; exists {
			val := m.GetBlockingPageChoice().(*GetSpecType_UseDefaultBlockingPage).UseDefaultBlockingPage
			vOpts := append(opts,
				db.WithValidateField("blocking_page_choice"),
				db.WithValidateField("use_default_blocking_page"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_BlockingPage:
		if fv, exists := v.FldValidators["blocking_page_choice.blocking_page"]; exists {
			val := m.GetBlockingPageChoice().(*GetSpecType_BlockingPage).BlockingPage
			vOpts := append(opts,
				db.WithValidateField("blocking_page_choice"),
				db.WithValidateField("blocking_page"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["bot_protection_choice"]; exists {
		val := m.GetBotProtectionChoice()
		vOpts := append(opts,
			db.WithValidateField("bot_protection_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetBotProtectionChoice().(type) {
	case *GetSpecType_DefaultBotSetting:
		if fv, exists := v.FldValidators["bot_protection_choice.default_bot_setting"]; exists {
			val := m.GetBotProtectionChoice().(*GetSpecType_DefaultBotSetting).DefaultBotSetting
			vOpts := append(opts,
				db.WithValidateField("bot_protection_choice"),
				db.WithValidateField("default_bot_setting"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_BotProtectionSetting:
		if fv, exists := v.FldValidators["bot_protection_choice.bot_protection_setting"]; exists {
			val := m.GetBotProtectionChoice().(*GetSpecType_BotProtectionSetting).BotProtectionSetting
			vOpts := append(opts,
				db.WithValidateField("bot_protection_choice"),
				db.WithValidateField("bot_protection_setting"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["detection_setting_choice"]; exists {
		val := m.GetDetectionSettingChoice()
		vOpts := append(opts,
			db.WithValidateField("detection_setting_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDetectionSettingChoice().(type) {
	case *GetSpecType_DefaultDetectionSettings:
		if fv, exists := v.FldValidators["detection_setting_choice.default_detection_settings"]; exists {
			val := m.GetDetectionSettingChoice().(*GetSpecType_DefaultDetectionSettings).DefaultDetectionSettings
			vOpts := append(opts,
				db.WithValidateField("detection_setting_choice"),
				db.WithValidateField("default_detection_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_DetectionSettings:
		if fv, exists := v.FldValidators["detection_setting_choice.detection_settings"]; exists {
			val := m.GetDetectionSettingChoice().(*GetSpecType_DetectionSettings).DetectionSettings
			vOpts := append(opts,
				db.WithValidateField("detection_setting_choice"),
				db.WithValidateField("detection_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_AiRiskBasedBlocking:
		if fv, exists := v.FldValidators["detection_setting_choice.ai_risk_based_blocking"]; exists {
			val := m.GetDetectionSettingChoice().(*GetSpecType_AiRiskBasedBlocking).AiRiskBasedBlocking
			vOpts := append(opts,
				db.WithValidateField("detection_setting_choice"),
				db.WithValidateField("ai_risk_based_blocking"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["enforcement_mode_choice"]; exists {
		val := m.GetEnforcementModeChoice()
		vOpts := append(opts,
			db.WithValidateField("enforcement_mode_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetEnforcementModeChoice().(type) {
	case *GetSpecType_UseLoadbalancerSetting:
		if fv, exists := v.FldValidators["enforcement_mode_choice.use_loadbalancer_setting"]; exists {
			val := m.GetEnforcementModeChoice().(*GetSpecType_UseLoadbalancerSetting).UseLoadbalancerSetting
			vOpts := append(opts,
				db.WithValidateField("enforcement_mode_choice"),
				db.WithValidateField("use_loadbalancer_setting"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Blocking:
		if fv, exists := v.FldValidators["enforcement_mode_choice.blocking"]; exists {
			val := m.GetEnforcementModeChoice().(*GetSpecType_Blocking).Blocking
			vOpts := append(opts,
				db.WithValidateField("enforcement_mode_choice"),
				db.WithValidateField("blocking"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Monitoring:
		if fv, exists := v.FldValidators["enforcement_mode_choice.monitoring"]; exists {
			val := m.GetEnforcementModeChoice().(*GetSpecType_Monitoring).Monitoring
			vOpts := append(opts,
				db.WithValidateField("enforcement_mode_choice"),
				db.WithValidateField("monitoring"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAllowedResponseCodesChoice := v.AllowedResponseCodesChoiceValidationRuleHandler
	rulesAllowedResponseCodesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAllowedResponseCodesChoice(rulesAllowedResponseCodesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.allowed_response_codes_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["allowed_response_codes_choice"] = vFn

	vrhAnonymizationSetting := v.AnonymizationSettingValidationRuleHandler
	rulesAnonymizationSetting := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAnonymizationSetting(rulesAnonymizationSetting)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.anonymization_setting: %s", err)
		panic(errMsg)
	}
	v.FldValidators["anonymization_setting"] = vFn

	vrhBlockingPageChoice := v.BlockingPageChoiceValidationRuleHandler
	rulesBlockingPageChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhBlockingPageChoice(rulesBlockingPageChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.blocking_page_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["blocking_page_choice"] = vFn

	vrhBotProtectionChoice := v.BotProtectionChoiceValidationRuleHandler
	rulesBotProtectionChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhBotProtectionChoice(rulesBotProtectionChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.bot_protection_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bot_protection_choice"] = vFn

	vrhDetectionSettingChoice := v.DetectionSettingChoiceValidationRuleHandler
	rulesDetectionSettingChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDetectionSettingChoice(rulesDetectionSettingChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.detection_setting_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["detection_setting_choice"] = vFn

	vrhEnforcementModeChoice := v.EnforcementModeChoiceValidationRuleHandler
	rulesEnforcementModeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhEnforcementModeChoice(rulesEnforcementModeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.enforcement_mode_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["enforcement_mode_choice"] = vFn

	v.FldValidators["allowed_response_codes_choice.allowed_response_codes"] = AllowedResponseCodesValidator().Validate

	v.FldValidators["anonymization_setting.custom_anonymization"] = AnonymizationSettingValidator().Validate

	v.FldValidators["blocking_page_choice.blocking_page"] = CustomBlockingPageValidator().Validate

	v.FldValidators["detection_setting_choice.detection_settings"] = DetectionSettingValidator().Validate
	v.FldValidators["detection_setting_choice.ai_risk_based_blocking"] = AiRiskBasedBlockingValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) AllowedResponseCodesChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for allowed_response_codes_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) AnonymizationSettingValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for anonymization_setting")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) BlockingPageChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for blocking_page_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) BotProtectionChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bot_protection_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) DetectionSettingChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for detection_setting_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) EnforcementModeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for enforcement_mode_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["allowed_response_codes_choice"]; exists {
		val := m.GetAllowedResponseCodesChoice()
		vOpts := append(opts,
			db.WithValidateField("allowed_response_codes_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAllowedResponseCodesChoice().(type) {
	case *GlobalSpecType_AllowAllResponseCodes:
		if fv, exists := v.FldValidators["allowed_response_codes_choice.allow_all_response_codes"]; exists {
			val := m.GetAllowedResponseCodesChoice().(*GlobalSpecType_AllowAllResponseCodes).AllowAllResponseCodes
			vOpts := append(opts,
				db.WithValidateField("allowed_response_codes_choice"),
				db.WithValidateField("allow_all_response_codes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_AllowedResponseCodes:
		if fv, exists := v.FldValidators["allowed_response_codes_choice.allowed_response_codes"]; exists {
			val := m.GetAllowedResponseCodesChoice().(*GlobalSpecType_AllowedResponseCodes).AllowedResponseCodes
			vOpts := append(opts,
				db.WithValidateField("allowed_response_codes_choice"),
				db.WithValidateField("allowed_response_codes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["anonymization_setting"]; exists {
		val := m.GetAnonymizationSetting()
		vOpts := append(opts,
			db.WithValidateField("anonymization_setting"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAnonymizationSetting().(type) {
	case *GlobalSpecType_DisableAnonymization:
		if fv, exists := v.FldValidators["anonymization_setting.disable_anonymization"]; exists {
			val := m.GetAnonymizationSetting().(*GlobalSpecType_DisableAnonymization).DisableAnonymization
			vOpts := append(opts,
				db.WithValidateField("anonymization_setting"),
				db.WithValidateField("disable_anonymization"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_DefaultAnonymization:
		if fv, exists := v.FldValidators["anonymization_setting.default_anonymization"]; exists {
			val := m.GetAnonymizationSetting().(*GlobalSpecType_DefaultAnonymization).DefaultAnonymization
			vOpts := append(opts,
				db.WithValidateField("anonymization_setting"),
				db.WithValidateField("default_anonymization"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_CustomAnonymization:
		if fv, exists := v.FldValidators["anonymization_setting.custom_anonymization"]; exists {
			val := m.GetAnonymizationSetting().(*GlobalSpecType_CustomAnonymization).CustomAnonymization
			vOpts := append(opts,
				db.WithValidateField("anonymization_setting"),
				db.WithValidateField("custom_anonymization"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["blocking_page_choice"]; exists {
		val := m.GetBlockingPageChoice()
		vOpts := append(opts,
			db.WithValidateField("blocking_page_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetBlockingPageChoice().(type) {
	case *GlobalSpecType_UseDefaultBlockingPage:
		if fv, exists := v.FldValidators["blocking_page_choice.use_default_blocking_page"]; exists {
			val := m.GetBlockingPageChoice().(*GlobalSpecType_UseDefaultBlockingPage).UseDefaultBlockingPage
			vOpts := append(opts,
				db.WithValidateField("blocking_page_choice"),
				db.WithValidateField("use_default_blocking_page"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_BlockingPage:
		if fv, exists := v.FldValidators["blocking_page_choice.blocking_page"]; exists {
			val := m.GetBlockingPageChoice().(*GlobalSpecType_BlockingPage).BlockingPage
			vOpts := append(opts,
				db.WithValidateField("blocking_page_choice"),
				db.WithValidateField("blocking_page"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["bot_protection_choice"]; exists {
		val := m.GetBotProtectionChoice()
		vOpts := append(opts,
			db.WithValidateField("bot_protection_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetBotProtectionChoice().(type) {
	case *GlobalSpecType_DefaultBotSetting:
		if fv, exists := v.FldValidators["bot_protection_choice.default_bot_setting"]; exists {
			val := m.GetBotProtectionChoice().(*GlobalSpecType_DefaultBotSetting).DefaultBotSetting
			vOpts := append(opts,
				db.WithValidateField("bot_protection_choice"),
				db.WithValidateField("default_bot_setting"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_BotProtectionSetting:
		if fv, exists := v.FldValidators["bot_protection_choice.bot_protection_setting"]; exists {
			val := m.GetBotProtectionChoice().(*GlobalSpecType_BotProtectionSetting).BotProtectionSetting
			vOpts := append(opts,
				db.WithValidateField("bot_protection_choice"),
				db.WithValidateField("bot_protection_setting"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["detection_setting_choice"]; exists {
		val := m.GetDetectionSettingChoice()
		vOpts := append(opts,
			db.WithValidateField("detection_setting_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDetectionSettingChoice().(type) {
	case *GlobalSpecType_DefaultDetectionSettings:
		if fv, exists := v.FldValidators["detection_setting_choice.default_detection_settings"]; exists {
			val := m.GetDetectionSettingChoice().(*GlobalSpecType_DefaultDetectionSettings).DefaultDetectionSettings
			vOpts := append(opts,
				db.WithValidateField("detection_setting_choice"),
				db.WithValidateField("default_detection_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_DetectionSettings:
		if fv, exists := v.FldValidators["detection_setting_choice.detection_settings"]; exists {
			val := m.GetDetectionSettingChoice().(*GlobalSpecType_DetectionSettings).DetectionSettings
			vOpts := append(opts,
				db.WithValidateField("detection_setting_choice"),
				db.WithValidateField("detection_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_AiRiskBasedBlocking:
		if fv, exists := v.FldValidators["detection_setting_choice.ai_risk_based_blocking"]; exists {
			val := m.GetDetectionSettingChoice().(*GlobalSpecType_AiRiskBasedBlocking).AiRiskBasedBlocking
			vOpts := append(opts,
				db.WithValidateField("detection_setting_choice"),
				db.WithValidateField("ai_risk_based_blocking"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["enforcement_mode_choice"]; exists {
		val := m.GetEnforcementModeChoice()
		vOpts := append(opts,
			db.WithValidateField("enforcement_mode_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetEnforcementModeChoice().(type) {
	case *GlobalSpecType_UseLoadbalancerSetting:
		if fv, exists := v.FldValidators["enforcement_mode_choice.use_loadbalancer_setting"]; exists {
			val := m.GetEnforcementModeChoice().(*GlobalSpecType_UseLoadbalancerSetting).UseLoadbalancerSetting
			vOpts := append(opts,
				db.WithValidateField("enforcement_mode_choice"),
				db.WithValidateField("use_loadbalancer_setting"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Blocking:
		if fv, exists := v.FldValidators["enforcement_mode_choice.blocking"]; exists {
			val := m.GetEnforcementModeChoice().(*GlobalSpecType_Blocking).Blocking
			vOpts := append(opts,
				db.WithValidateField("enforcement_mode_choice"),
				db.WithValidateField("blocking"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Monitoring:
		if fv, exists := v.FldValidators["enforcement_mode_choice.monitoring"]; exists {
			val := m.GetEnforcementModeChoice().(*GlobalSpecType_Monitoring).Monitoring
			vOpts := append(opts,
				db.WithValidateField("enforcement_mode_choice"),
				db.WithValidateField("monitoring"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAllowedResponseCodesChoice := v.AllowedResponseCodesChoiceValidationRuleHandler
	rulesAllowedResponseCodesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAllowedResponseCodesChoice(rulesAllowedResponseCodesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.allowed_response_codes_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["allowed_response_codes_choice"] = vFn

	vrhAnonymizationSetting := v.AnonymizationSettingValidationRuleHandler
	rulesAnonymizationSetting := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAnonymizationSetting(rulesAnonymizationSetting)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.anonymization_setting: %s", err)
		panic(errMsg)
	}
	v.FldValidators["anonymization_setting"] = vFn

	vrhBlockingPageChoice := v.BlockingPageChoiceValidationRuleHandler
	rulesBlockingPageChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhBlockingPageChoice(rulesBlockingPageChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.blocking_page_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["blocking_page_choice"] = vFn

	vrhBotProtectionChoice := v.BotProtectionChoiceValidationRuleHandler
	rulesBotProtectionChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhBotProtectionChoice(rulesBotProtectionChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.bot_protection_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bot_protection_choice"] = vFn

	vrhDetectionSettingChoice := v.DetectionSettingChoiceValidationRuleHandler
	rulesDetectionSettingChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDetectionSettingChoice(rulesDetectionSettingChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.detection_setting_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["detection_setting_choice"] = vFn

	vrhEnforcementModeChoice := v.EnforcementModeChoiceValidationRuleHandler
	rulesEnforcementModeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhEnforcementModeChoice(rulesEnforcementModeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.enforcement_mode_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["enforcement_mode_choice"] = vFn

	v.FldValidators["allowed_response_codes_choice.allowed_response_codes"] = AllowedResponseCodesValidator().Validate

	v.FldValidators["anonymization_setting.custom_anonymization"] = AnonymizationSettingValidator().Validate

	v.FldValidators["blocking_page_choice.blocking_page"] = CustomBlockingPageValidator().Validate

	v.FldValidators["detection_setting_choice.detection_settings"] = DetectionSettingValidator().Validate
	v.FldValidators["detection_setting_choice.ai_risk_based_blocking"] = AiRiskBasedBlockingValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) AllowedResponseCodesChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for allowed_response_codes_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) AnonymizationSettingValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for anonymization_setting")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) BlockingPageChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for blocking_page_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) BotProtectionChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bot_protection_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) DetectionSettingChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for detection_setting_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) EnforcementModeChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for enforcement_mode_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["allowed_response_codes_choice"]; exists {
		val := m.GetAllowedResponseCodesChoice()
		vOpts := append(opts,
			db.WithValidateField("allowed_response_codes_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAllowedResponseCodesChoice().(type) {
	case *ReplaceSpecType_AllowAllResponseCodes:
		if fv, exists := v.FldValidators["allowed_response_codes_choice.allow_all_response_codes"]; exists {
			val := m.GetAllowedResponseCodesChoice().(*ReplaceSpecType_AllowAllResponseCodes).AllowAllResponseCodes
			vOpts := append(opts,
				db.WithValidateField("allowed_response_codes_choice"),
				db.WithValidateField("allow_all_response_codes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_AllowedResponseCodes:
		if fv, exists := v.FldValidators["allowed_response_codes_choice.allowed_response_codes"]; exists {
			val := m.GetAllowedResponseCodesChoice().(*ReplaceSpecType_AllowedResponseCodes).AllowedResponseCodes
			vOpts := append(opts,
				db.WithValidateField("allowed_response_codes_choice"),
				db.WithValidateField("allowed_response_codes"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["anonymization_setting"]; exists {
		val := m.GetAnonymizationSetting()
		vOpts := append(opts,
			db.WithValidateField("anonymization_setting"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAnonymizationSetting().(type) {
	case *ReplaceSpecType_DisableAnonymization:
		if fv, exists := v.FldValidators["anonymization_setting.disable_anonymization"]; exists {
			val := m.GetAnonymizationSetting().(*ReplaceSpecType_DisableAnonymization).DisableAnonymization
			vOpts := append(opts,
				db.WithValidateField("anonymization_setting"),
				db.WithValidateField("disable_anonymization"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_DefaultAnonymization:
		if fv, exists := v.FldValidators["anonymization_setting.default_anonymization"]; exists {
			val := m.GetAnonymizationSetting().(*ReplaceSpecType_DefaultAnonymization).DefaultAnonymization
			vOpts := append(opts,
				db.WithValidateField("anonymization_setting"),
				db.WithValidateField("default_anonymization"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_CustomAnonymization:
		if fv, exists := v.FldValidators["anonymization_setting.custom_anonymization"]; exists {
			val := m.GetAnonymizationSetting().(*ReplaceSpecType_CustomAnonymization).CustomAnonymization
			vOpts := append(opts,
				db.WithValidateField("anonymization_setting"),
				db.WithValidateField("custom_anonymization"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["blocking_page_choice"]; exists {
		val := m.GetBlockingPageChoice()
		vOpts := append(opts,
			db.WithValidateField("blocking_page_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetBlockingPageChoice().(type) {
	case *ReplaceSpecType_UseDefaultBlockingPage:
		if fv, exists := v.FldValidators["blocking_page_choice.use_default_blocking_page"]; exists {
			val := m.GetBlockingPageChoice().(*ReplaceSpecType_UseDefaultBlockingPage).UseDefaultBlockingPage
			vOpts := append(opts,
				db.WithValidateField("blocking_page_choice"),
				db.WithValidateField("use_default_blocking_page"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_BlockingPage:
		if fv, exists := v.FldValidators["blocking_page_choice.blocking_page"]; exists {
			val := m.GetBlockingPageChoice().(*ReplaceSpecType_BlockingPage).BlockingPage
			vOpts := append(opts,
				db.WithValidateField("blocking_page_choice"),
				db.WithValidateField("blocking_page"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["bot_protection_choice"]; exists {
		val := m.GetBotProtectionChoice()
		vOpts := append(opts,
			db.WithValidateField("bot_protection_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetBotProtectionChoice().(type) {
	case *ReplaceSpecType_DefaultBotSetting:
		if fv, exists := v.FldValidators["bot_protection_choice.default_bot_setting"]; exists {
			val := m.GetBotProtectionChoice().(*ReplaceSpecType_DefaultBotSetting).DefaultBotSetting
			vOpts := append(opts,
				db.WithValidateField("bot_protection_choice"),
				db.WithValidateField("default_bot_setting"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_BotProtectionSetting:
		if fv, exists := v.FldValidators["bot_protection_choice.bot_protection_setting"]; exists {
			val := m.GetBotProtectionChoice().(*ReplaceSpecType_BotProtectionSetting).BotProtectionSetting
			vOpts := append(opts,
				db.WithValidateField("bot_protection_choice"),
				db.WithValidateField("bot_protection_setting"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["detection_setting_choice"]; exists {
		val := m.GetDetectionSettingChoice()
		vOpts := append(opts,
			db.WithValidateField("detection_setting_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDetectionSettingChoice().(type) {
	case *ReplaceSpecType_DefaultDetectionSettings:
		if fv, exists := v.FldValidators["detection_setting_choice.default_detection_settings"]; exists {
			val := m.GetDetectionSettingChoice().(*ReplaceSpecType_DefaultDetectionSettings).DefaultDetectionSettings
			vOpts := append(opts,
				db.WithValidateField("detection_setting_choice"),
				db.WithValidateField("default_detection_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_DetectionSettings:
		if fv, exists := v.FldValidators["detection_setting_choice.detection_settings"]; exists {
			val := m.GetDetectionSettingChoice().(*ReplaceSpecType_DetectionSettings).DetectionSettings
			vOpts := append(opts,
				db.WithValidateField("detection_setting_choice"),
				db.WithValidateField("detection_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_AiRiskBasedBlocking:
		if fv, exists := v.FldValidators["detection_setting_choice.ai_risk_based_blocking"]; exists {
			val := m.GetDetectionSettingChoice().(*ReplaceSpecType_AiRiskBasedBlocking).AiRiskBasedBlocking
			vOpts := append(opts,
				db.WithValidateField("detection_setting_choice"),
				db.WithValidateField("ai_risk_based_blocking"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["enforcement_mode_choice"]; exists {
		val := m.GetEnforcementModeChoice()
		vOpts := append(opts,
			db.WithValidateField("enforcement_mode_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetEnforcementModeChoice().(type) {
	case *ReplaceSpecType_UseLoadbalancerSetting:
		if fv, exists := v.FldValidators["enforcement_mode_choice.use_loadbalancer_setting"]; exists {
			val := m.GetEnforcementModeChoice().(*ReplaceSpecType_UseLoadbalancerSetting).UseLoadbalancerSetting
			vOpts := append(opts,
				db.WithValidateField("enforcement_mode_choice"),
				db.WithValidateField("use_loadbalancer_setting"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_Blocking:
		if fv, exists := v.FldValidators["enforcement_mode_choice.blocking"]; exists {
			val := m.GetEnforcementModeChoice().(*ReplaceSpecType_Blocking).Blocking
			vOpts := append(opts,
				db.WithValidateField("enforcement_mode_choice"),
				db.WithValidateField("blocking"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_Monitoring:
		if fv, exists := v.FldValidators["enforcement_mode_choice.monitoring"]; exists {
			val := m.GetEnforcementModeChoice().(*ReplaceSpecType_Monitoring).Monitoring
			vOpts := append(opts,
				db.WithValidateField("enforcement_mode_choice"),
				db.WithValidateField("monitoring"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAllowedResponseCodesChoice := v.AllowedResponseCodesChoiceValidationRuleHandler
	rulesAllowedResponseCodesChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAllowedResponseCodesChoice(rulesAllowedResponseCodesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.allowed_response_codes_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["allowed_response_codes_choice"] = vFn

	vrhAnonymizationSetting := v.AnonymizationSettingValidationRuleHandler
	rulesAnonymizationSetting := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAnonymizationSetting(rulesAnonymizationSetting)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.anonymization_setting: %s", err)
		panic(errMsg)
	}
	v.FldValidators["anonymization_setting"] = vFn

	vrhBlockingPageChoice := v.BlockingPageChoiceValidationRuleHandler
	rulesBlockingPageChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhBlockingPageChoice(rulesBlockingPageChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.blocking_page_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["blocking_page_choice"] = vFn

	vrhBotProtectionChoice := v.BotProtectionChoiceValidationRuleHandler
	rulesBotProtectionChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhBotProtectionChoice(rulesBotProtectionChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.bot_protection_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bot_protection_choice"] = vFn

	vrhDetectionSettingChoice := v.DetectionSettingChoiceValidationRuleHandler
	rulesDetectionSettingChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhDetectionSettingChoice(rulesDetectionSettingChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.detection_setting_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["detection_setting_choice"] = vFn

	vrhEnforcementModeChoice := v.EnforcementModeChoiceValidationRuleHandler
	rulesEnforcementModeChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhEnforcementModeChoice(rulesEnforcementModeChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.enforcement_mode_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["enforcement_mode_choice"] = vFn

	v.FldValidators["allowed_response_codes_choice.allowed_response_codes"] = AllowedResponseCodesValidator().Validate

	v.FldValidators["anonymization_setting.custom_anonymization"] = AnonymizationSettingValidator().Validate

	v.FldValidators["blocking_page_choice.blocking_page"] = CustomBlockingPageValidator().Validate

	v.FldValidators["detection_setting_choice.detection_settings"] = DetectionSettingValidator().Validate
	v.FldValidators["detection_setting_choice.ai_risk_based_blocking"] = AiRiskBasedBlockingValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *SignatureSelectionSetting) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SignatureSelectionSetting) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SignatureSelectionSetting) DeepCopy() *SignatureSelectionSetting {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SignatureSelectionSetting{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SignatureSelectionSetting) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SignatureSelectionSetting) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SignatureSelectionSettingValidator().Validate(ctx, m, opts...)
}

type ValidateSignatureSelectionSetting struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSignatureSelectionSetting) AttackTypeSettingValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for attack_type_setting")
	}
	return validatorFn, nil
}

func (v *ValidateSignatureSelectionSetting) SignatureSelectionByAccuracyValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for signature_selection_by_accuracy")
	}
	return validatorFn, nil
}

func (v *ValidateSignatureSelectionSetting) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SignatureSelectionSetting)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SignatureSelectionSetting got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["attack_type_setting"]; exists {
		val := m.GetAttackTypeSetting()
		vOpts := append(opts,
			db.WithValidateField("attack_type_setting"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAttackTypeSetting().(type) {
	case *SignatureSelectionSetting_DefaultAttackTypeSettings:
		if fv, exists := v.FldValidators["attack_type_setting.default_attack_type_settings"]; exists {
			val := m.GetAttackTypeSetting().(*SignatureSelectionSetting_DefaultAttackTypeSettings).DefaultAttackTypeSettings
			vOpts := append(opts,
				db.WithValidateField("attack_type_setting"),
				db.WithValidateField("default_attack_type_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SignatureSelectionSetting_AttackTypeSettings:
		if fv, exists := v.FldValidators["attack_type_setting.attack_type_settings"]; exists {
			val := m.GetAttackTypeSetting().(*SignatureSelectionSetting_AttackTypeSettings).AttackTypeSettings
			vOpts := append(opts,
				db.WithValidateField("attack_type_setting"),
				db.WithValidateField("attack_type_settings"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["signature_selection_by_accuracy"]; exists {
		val := m.GetSignatureSelectionByAccuracy()
		vOpts := append(opts,
			db.WithValidateField("signature_selection_by_accuracy"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSignatureSelectionByAccuracy().(type) {
	case *SignatureSelectionSetting_OnlyHighAccuracySignatures:
		if fv, exists := v.FldValidators["signature_selection_by_accuracy.only_high_accuracy_signatures"]; exists {
			val := m.GetSignatureSelectionByAccuracy().(*SignatureSelectionSetting_OnlyHighAccuracySignatures).OnlyHighAccuracySignatures
			vOpts := append(opts,
				db.WithValidateField("signature_selection_by_accuracy"),
				db.WithValidateField("only_high_accuracy_signatures"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SignatureSelectionSetting_HighMediumAccuracySignatures:
		if fv, exists := v.FldValidators["signature_selection_by_accuracy.high_medium_accuracy_signatures"]; exists {
			val := m.GetSignatureSelectionByAccuracy().(*SignatureSelectionSetting_HighMediumAccuracySignatures).HighMediumAccuracySignatures
			vOpts := append(opts,
				db.WithValidateField("signature_selection_by_accuracy"),
				db.WithValidateField("high_medium_accuracy_signatures"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *SignatureSelectionSetting_HighMediumLowAccuracySignatures:
		if fv, exists := v.FldValidators["signature_selection_by_accuracy.high_medium_low_accuracy_signatures"]; exists {
			val := m.GetSignatureSelectionByAccuracy().(*SignatureSelectionSetting_HighMediumLowAccuracySignatures).HighMediumLowAccuracySignatures
			vOpts := append(opts,
				db.WithValidateField("signature_selection_by_accuracy"),
				db.WithValidateField("high_medium_low_accuracy_signatures"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSignatureSelectionSettingValidator = func() *ValidateSignatureSelectionSetting {
	v := &ValidateSignatureSelectionSetting{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAttackTypeSetting := v.AttackTypeSettingValidationRuleHandler
	rulesAttackTypeSetting := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhAttackTypeSetting(rulesAttackTypeSetting)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SignatureSelectionSetting.attack_type_setting: %s", err)
		panic(errMsg)
	}
	v.FldValidators["attack_type_setting"] = vFn

	vrhSignatureSelectionByAccuracy := v.SignatureSelectionByAccuracyValidationRuleHandler
	rulesSignatureSelectionByAccuracy := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhSignatureSelectionByAccuracy(rulesSignatureSelectionByAccuracy)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SignatureSelectionSetting.signature_selection_by_accuracy: %s", err)
		panic(errMsg)
	}
	v.FldValidators["signature_selection_by_accuracy"] = vFn

	v.FldValidators["attack_type_setting.attack_type_settings"] = AttackTypeSettingsValidator().Validate

	return v
}()

func SignatureSelectionSettingValidator() db.Validator {
	return DefaultSignatureSelectionSettingValidator
}

// augmented methods on protoc/std generated struct

func (m *SignaturesStagingSettings) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SignaturesStagingSettings) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SignaturesStagingSettings) DeepCopy() *SignaturesStagingSettings {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SignaturesStagingSettings{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SignaturesStagingSettings) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SignaturesStagingSettings) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SignaturesStagingSettingsValidator().Validate(ctx, m, opts...)
}

type ValidateSignaturesStagingSettings struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSignaturesStagingSettings) StagingPeriodValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for staging_period")
	}

	return validatorFn, nil
}

func (v *ValidateSignaturesStagingSettings) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SignaturesStagingSettings)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SignaturesStagingSettings got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["staging_period"]; exists {

		vOpts := append(opts, db.WithValidateField("staging_period"))
		if err := fv(ctx, m.GetStagingPeriod(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSignaturesStagingSettingsValidator = func() *ValidateSignaturesStagingSettings {
	v := &ValidateSignaturesStagingSettings{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhStagingPeriod := v.StagingPeriodValidationRuleHandler
	rulesStagingPeriod := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "1",
		"ves.io.schema.rules.uint32.lte":       "20",
	}
	vFn, err = vrhStagingPeriod(rulesStagingPeriod)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SignaturesStagingSettings.staging_period: %s", err)
		panic(errMsg)
	}
	v.FldValidators["staging_period"] = vFn

	return v
}()

func SignaturesStagingSettingsValidator() db.Validator {
	return DefaultSignaturesStagingSettingsValidator
}

// augmented methods on protoc/std generated struct

func (m *ViolationSettings) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ViolationSettings) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ViolationSettings) DeepCopy() *ViolationSettings {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ViolationSettings{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ViolationSettings) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ViolationSettings) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ViolationSettingsValidator().Validate(ctx, m, opts...)
}

type ValidateViolationSettings struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateViolationSettings) DisabledViolationTypesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(AppFirewallViolationType)
		return int32(i)
	}
	// AppFirewallViolationType_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, AppFirewallViolationType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for disabled_violation_types")
	}
	itemsValidatorFn := func(ctx context.Context, elems []AppFirewallViolationType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for disabled_violation_types")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]AppFirewallViolationType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []AppFirewallViolationType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated disabled_violation_types")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items disabled_violation_types")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateViolationSettings) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ViolationSettings)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ViolationSettings got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["disabled_violation_types"]; exists {
		vOpts := append(opts, db.WithValidateField("disabled_violation_types"))
		if err := fv(ctx, m.GetDisabledViolationTypes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultViolationSettingsValidator = func() *ValidateViolationSettings {
	v := &ValidateViolationSettings{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhDisabledViolationTypes := v.DisabledViolationTypesValidationRuleHandler
	rulesDisabledViolationTypes := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "40",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhDisabledViolationTypes(rulesDisabledViolationTypes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ViolationSettings.disabled_violation_types: %s", err)
		panic(errMsg)
	}
	v.FldValidators["disabled_violation_types"] = vFn

	return v
}()

func ViolationSettingsValidator() db.Validator {
	return DefaultViolationSettingsValidator
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetAllowedResponseCodesChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.AllowedResponseCodesChoice.(type) {
	case nil:
		o.AllowedResponseCodesChoice = nil

	case *CreateSpecType_AllowAllResponseCodes:
		o.AllowedResponseCodesChoice = &GlobalSpecType_AllowAllResponseCodes{AllowAllResponseCodes: of.AllowAllResponseCodes}

	case *CreateSpecType_AllowedResponseCodes:
		o.AllowedResponseCodesChoice = &GlobalSpecType_AllowedResponseCodes{AllowedResponseCodes: of.AllowedResponseCodes}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetAllowedResponseCodesChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.AllowedResponseCodesChoice.(type) {
	case nil:
		r.AllowedResponseCodesChoice = nil

	case *GlobalSpecType_AllowAllResponseCodes:
		r.AllowedResponseCodesChoice = &CreateSpecType_AllowAllResponseCodes{AllowAllResponseCodes: of.AllowAllResponseCodes}

	case *GlobalSpecType_AllowedResponseCodes:
		r.AllowedResponseCodesChoice = &CreateSpecType_AllowedResponseCodes{AllowedResponseCodes: of.AllowedResponseCodes}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetAnonymizationSettingToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.AnonymizationSetting.(type) {
	case nil:
		o.AnonymizationSetting = nil

	case *CreateSpecType_CustomAnonymization:
		o.AnonymizationSetting = &GlobalSpecType_CustomAnonymization{CustomAnonymization: of.CustomAnonymization}

	case *CreateSpecType_DefaultAnonymization:
		o.AnonymizationSetting = &GlobalSpecType_DefaultAnonymization{DefaultAnonymization: of.DefaultAnonymization}

	case *CreateSpecType_DisableAnonymization:
		o.AnonymizationSetting = &GlobalSpecType_DisableAnonymization{DisableAnonymization: of.DisableAnonymization}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetAnonymizationSettingFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.AnonymizationSetting.(type) {
	case nil:
		r.AnonymizationSetting = nil

	case *GlobalSpecType_CustomAnonymization:
		r.AnonymizationSetting = &CreateSpecType_CustomAnonymization{CustomAnonymization: of.CustomAnonymization}

	case *GlobalSpecType_DefaultAnonymization:
		r.AnonymizationSetting = &CreateSpecType_DefaultAnonymization{DefaultAnonymization: of.DefaultAnonymization}

	case *GlobalSpecType_DisableAnonymization:
		r.AnonymizationSetting = &CreateSpecType_DisableAnonymization{DisableAnonymization: of.DisableAnonymization}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetBlockingPageChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.BlockingPageChoice.(type) {
	case nil:
		o.BlockingPageChoice = nil

	case *CreateSpecType_BlockingPage:
		o.BlockingPageChoice = &GlobalSpecType_BlockingPage{BlockingPage: of.BlockingPage}

	case *CreateSpecType_UseDefaultBlockingPage:
		o.BlockingPageChoice = &GlobalSpecType_UseDefaultBlockingPage{UseDefaultBlockingPage: of.UseDefaultBlockingPage}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetBlockingPageChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.BlockingPageChoice.(type) {
	case nil:
		r.BlockingPageChoice = nil

	case *GlobalSpecType_BlockingPage:
		r.BlockingPageChoice = &CreateSpecType_BlockingPage{BlockingPage: of.BlockingPage}

	case *GlobalSpecType_UseDefaultBlockingPage:
		r.BlockingPageChoice = &CreateSpecType_UseDefaultBlockingPage{UseDefaultBlockingPage: of.UseDefaultBlockingPage}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetBotProtectionChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.BotProtectionChoice.(type) {
	case nil:
		o.BotProtectionChoice = nil

	case *CreateSpecType_BotProtectionSetting:
		o.BotProtectionChoice = &GlobalSpecType_BotProtectionSetting{BotProtectionSetting: of.BotProtectionSetting}

	case *CreateSpecType_DefaultBotSetting:
		o.BotProtectionChoice = &GlobalSpecType_DefaultBotSetting{DefaultBotSetting: of.DefaultBotSetting}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetBotProtectionChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.BotProtectionChoice.(type) {
	case nil:
		r.BotProtectionChoice = nil

	case *GlobalSpecType_BotProtectionSetting:
		r.BotProtectionChoice = &CreateSpecType_BotProtectionSetting{BotProtectionSetting: of.BotProtectionSetting}

	case *GlobalSpecType_DefaultBotSetting:
		r.BotProtectionChoice = &CreateSpecType_DefaultBotSetting{DefaultBotSetting: of.DefaultBotSetting}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetDetectionSettingChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DetectionSettingChoice.(type) {
	case nil:
		o.DetectionSettingChoice = nil

	case *CreateSpecType_AiRiskBasedBlocking:
		o.DetectionSettingChoice = &GlobalSpecType_AiRiskBasedBlocking{AiRiskBasedBlocking: of.AiRiskBasedBlocking}

	case *CreateSpecType_DefaultDetectionSettings:
		o.DetectionSettingChoice = &GlobalSpecType_DefaultDetectionSettings{DefaultDetectionSettings: of.DefaultDetectionSettings}

	case *CreateSpecType_DetectionSettings:
		o.DetectionSettingChoice = &GlobalSpecType_DetectionSettings{DetectionSettings: of.DetectionSettings}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetDetectionSettingChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DetectionSettingChoice.(type) {
	case nil:
		r.DetectionSettingChoice = nil

	case *GlobalSpecType_AiRiskBasedBlocking:
		r.DetectionSettingChoice = &CreateSpecType_AiRiskBasedBlocking{AiRiskBasedBlocking: of.AiRiskBasedBlocking}

	case *GlobalSpecType_DefaultDetectionSettings:
		r.DetectionSettingChoice = &CreateSpecType_DefaultDetectionSettings{DefaultDetectionSettings: of.DefaultDetectionSettings}

	case *GlobalSpecType_DetectionSettings:
		r.DetectionSettingChoice = &CreateSpecType_DetectionSettings{DetectionSettings: of.DetectionSettings}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetEnforcementModeChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.EnforcementModeChoice.(type) {
	case nil:
		o.EnforcementModeChoice = nil

	case *CreateSpecType_Blocking:
		o.EnforcementModeChoice = &GlobalSpecType_Blocking{Blocking: of.Blocking}

	case *CreateSpecType_Monitoring:
		o.EnforcementModeChoice = &GlobalSpecType_Monitoring{Monitoring: of.Monitoring}

	case *CreateSpecType_UseLoadbalancerSetting:
		o.EnforcementModeChoice = &GlobalSpecType_UseLoadbalancerSetting{UseLoadbalancerSetting: of.UseLoadbalancerSetting}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetEnforcementModeChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.EnforcementModeChoice.(type) {
	case nil:
		r.EnforcementModeChoice = nil

	case *GlobalSpecType_Blocking:
		r.EnforcementModeChoice = &CreateSpecType_Blocking{Blocking: of.Blocking}

	case *GlobalSpecType_Monitoring:
		r.EnforcementModeChoice = &CreateSpecType_Monitoring{Monitoring: of.Monitoring}

	case *GlobalSpecType_UseLoadbalancerSetting:
		r.EnforcementModeChoice = &CreateSpecType_UseLoadbalancerSetting{UseLoadbalancerSetting: of.UseLoadbalancerSetting}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *CreateSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.GetAllowedResponseCodesChoiceFromGlobalSpecType(f)
	m.GetAnonymizationSettingFromGlobalSpecType(f)
	m.GetBlockingPageChoiceFromGlobalSpecType(f)
	m.GetBotProtectionChoiceFromGlobalSpecType(f)
	m.GetDetectionSettingChoiceFromGlobalSpecType(f)
	m.GetEnforcementModeChoiceFromGlobalSpecType(f)
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *CreateSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *CreateSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	m1.SetAllowedResponseCodesChoiceToGlobalSpecType(f)
	m1.SetAnonymizationSettingToGlobalSpecType(f)
	m1.SetBlockingPageChoiceToGlobalSpecType(f)
	m1.SetBotProtectionChoiceToGlobalSpecType(f)
	m1.SetDetectionSettingChoiceToGlobalSpecType(f)
	m1.SetEnforcementModeChoiceToGlobalSpecType(f)
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *CreateSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetAllowedResponseCodesChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.AllowedResponseCodesChoice.(type) {
	case nil:
		o.AllowedResponseCodesChoice = nil

	case *GetSpecType_AllowAllResponseCodes:
		o.AllowedResponseCodesChoice = &GlobalSpecType_AllowAllResponseCodes{AllowAllResponseCodes: of.AllowAllResponseCodes}

	case *GetSpecType_AllowedResponseCodes:
		o.AllowedResponseCodesChoice = &GlobalSpecType_AllowedResponseCodes{AllowedResponseCodes: of.AllowedResponseCodes}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetAllowedResponseCodesChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.AllowedResponseCodesChoice.(type) {
	case nil:
		r.AllowedResponseCodesChoice = nil

	case *GlobalSpecType_AllowAllResponseCodes:
		r.AllowedResponseCodesChoice = &GetSpecType_AllowAllResponseCodes{AllowAllResponseCodes: of.AllowAllResponseCodes}

	case *GlobalSpecType_AllowedResponseCodes:
		r.AllowedResponseCodesChoice = &GetSpecType_AllowedResponseCodes{AllowedResponseCodes: of.AllowedResponseCodes}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetAnonymizationSettingToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.AnonymizationSetting.(type) {
	case nil:
		o.AnonymizationSetting = nil

	case *GetSpecType_CustomAnonymization:
		o.AnonymizationSetting = &GlobalSpecType_CustomAnonymization{CustomAnonymization: of.CustomAnonymization}

	case *GetSpecType_DefaultAnonymization:
		o.AnonymizationSetting = &GlobalSpecType_DefaultAnonymization{DefaultAnonymization: of.DefaultAnonymization}

	case *GetSpecType_DisableAnonymization:
		o.AnonymizationSetting = &GlobalSpecType_DisableAnonymization{DisableAnonymization: of.DisableAnonymization}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetAnonymizationSettingFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.AnonymizationSetting.(type) {
	case nil:
		r.AnonymizationSetting = nil

	case *GlobalSpecType_CustomAnonymization:
		r.AnonymizationSetting = &GetSpecType_CustomAnonymization{CustomAnonymization: of.CustomAnonymization}

	case *GlobalSpecType_DefaultAnonymization:
		r.AnonymizationSetting = &GetSpecType_DefaultAnonymization{DefaultAnonymization: of.DefaultAnonymization}

	case *GlobalSpecType_DisableAnonymization:
		r.AnonymizationSetting = &GetSpecType_DisableAnonymization{DisableAnonymization: of.DisableAnonymization}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetBlockingPageChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.BlockingPageChoice.(type) {
	case nil:
		o.BlockingPageChoice = nil

	case *GetSpecType_BlockingPage:
		o.BlockingPageChoice = &GlobalSpecType_BlockingPage{BlockingPage: of.BlockingPage}

	case *GetSpecType_UseDefaultBlockingPage:
		o.BlockingPageChoice = &GlobalSpecType_UseDefaultBlockingPage{UseDefaultBlockingPage: of.UseDefaultBlockingPage}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetBlockingPageChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.BlockingPageChoice.(type) {
	case nil:
		r.BlockingPageChoice = nil

	case *GlobalSpecType_BlockingPage:
		r.BlockingPageChoice = &GetSpecType_BlockingPage{BlockingPage: of.BlockingPage}

	case *GlobalSpecType_UseDefaultBlockingPage:
		r.BlockingPageChoice = &GetSpecType_UseDefaultBlockingPage{UseDefaultBlockingPage: of.UseDefaultBlockingPage}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetBotProtectionChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.BotProtectionChoice.(type) {
	case nil:
		o.BotProtectionChoice = nil

	case *GetSpecType_BotProtectionSetting:
		o.BotProtectionChoice = &GlobalSpecType_BotProtectionSetting{BotProtectionSetting: of.BotProtectionSetting}

	case *GetSpecType_DefaultBotSetting:
		o.BotProtectionChoice = &GlobalSpecType_DefaultBotSetting{DefaultBotSetting: of.DefaultBotSetting}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetBotProtectionChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.BotProtectionChoice.(type) {
	case nil:
		r.BotProtectionChoice = nil

	case *GlobalSpecType_BotProtectionSetting:
		r.BotProtectionChoice = &GetSpecType_BotProtectionSetting{BotProtectionSetting: of.BotProtectionSetting}

	case *GlobalSpecType_DefaultBotSetting:
		r.BotProtectionChoice = &GetSpecType_DefaultBotSetting{DefaultBotSetting: of.DefaultBotSetting}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetDetectionSettingChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DetectionSettingChoice.(type) {
	case nil:
		o.DetectionSettingChoice = nil

	case *GetSpecType_AiRiskBasedBlocking:
		o.DetectionSettingChoice = &GlobalSpecType_AiRiskBasedBlocking{AiRiskBasedBlocking: of.AiRiskBasedBlocking}

	case *GetSpecType_DefaultDetectionSettings:
		o.DetectionSettingChoice = &GlobalSpecType_DefaultDetectionSettings{DefaultDetectionSettings: of.DefaultDetectionSettings}

	case *GetSpecType_DetectionSettings:
		o.DetectionSettingChoice = &GlobalSpecType_DetectionSettings{DetectionSettings: of.DetectionSettings}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetDetectionSettingChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DetectionSettingChoice.(type) {
	case nil:
		r.DetectionSettingChoice = nil

	case *GlobalSpecType_AiRiskBasedBlocking:
		r.DetectionSettingChoice = &GetSpecType_AiRiskBasedBlocking{AiRiskBasedBlocking: of.AiRiskBasedBlocking}

	case *GlobalSpecType_DefaultDetectionSettings:
		r.DetectionSettingChoice = &GetSpecType_DefaultDetectionSettings{DefaultDetectionSettings: of.DefaultDetectionSettings}

	case *GlobalSpecType_DetectionSettings:
		r.DetectionSettingChoice = &GetSpecType_DetectionSettings{DetectionSettings: of.DetectionSettings}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetEnforcementModeChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.EnforcementModeChoice.(type) {
	case nil:
		o.EnforcementModeChoice = nil

	case *GetSpecType_Blocking:
		o.EnforcementModeChoice = &GlobalSpecType_Blocking{Blocking: of.Blocking}

	case *GetSpecType_Monitoring:
		o.EnforcementModeChoice = &GlobalSpecType_Monitoring{Monitoring: of.Monitoring}

	case *GetSpecType_UseLoadbalancerSetting:
		o.EnforcementModeChoice = &GlobalSpecType_UseLoadbalancerSetting{UseLoadbalancerSetting: of.UseLoadbalancerSetting}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetEnforcementModeChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.EnforcementModeChoice.(type) {
	case nil:
		r.EnforcementModeChoice = nil

	case *GlobalSpecType_Blocking:
		r.EnforcementModeChoice = &GetSpecType_Blocking{Blocking: of.Blocking}

	case *GlobalSpecType_Monitoring:
		r.EnforcementModeChoice = &GetSpecType_Monitoring{Monitoring: of.Monitoring}

	case *GlobalSpecType_UseLoadbalancerSetting:
		r.EnforcementModeChoice = &GetSpecType_UseLoadbalancerSetting{UseLoadbalancerSetting: of.UseLoadbalancerSetting}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *GetSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.GetAllowedResponseCodesChoiceFromGlobalSpecType(f)
	m.GetAnonymizationSettingFromGlobalSpecType(f)
	m.GetBlockingPageChoiceFromGlobalSpecType(f)
	m.GetBotProtectionChoiceFromGlobalSpecType(f)
	m.GetDetectionSettingChoiceFromGlobalSpecType(f)
	m.GetEnforcementModeChoiceFromGlobalSpecType(f)
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *GetSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *GetSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	m1.SetAllowedResponseCodesChoiceToGlobalSpecType(f)
	m1.SetAnonymizationSettingToGlobalSpecType(f)
	m1.SetBlockingPageChoiceToGlobalSpecType(f)
	m1.SetBotProtectionChoiceToGlobalSpecType(f)
	m1.SetDetectionSettingChoiceToGlobalSpecType(f)
	m1.SetEnforcementModeChoiceToGlobalSpecType(f)
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *GetSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetAllowedResponseCodesChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.AllowedResponseCodesChoice.(type) {
	case nil:
		o.AllowedResponseCodesChoice = nil

	case *ReplaceSpecType_AllowAllResponseCodes:
		o.AllowedResponseCodesChoice = &GlobalSpecType_AllowAllResponseCodes{AllowAllResponseCodes: of.AllowAllResponseCodes}

	case *ReplaceSpecType_AllowedResponseCodes:
		o.AllowedResponseCodesChoice = &GlobalSpecType_AllowedResponseCodes{AllowedResponseCodes: of.AllowedResponseCodes}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetAllowedResponseCodesChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.AllowedResponseCodesChoice.(type) {
	case nil:
		r.AllowedResponseCodesChoice = nil

	case *GlobalSpecType_AllowAllResponseCodes:
		r.AllowedResponseCodesChoice = &ReplaceSpecType_AllowAllResponseCodes{AllowAllResponseCodes: of.AllowAllResponseCodes}

	case *GlobalSpecType_AllowedResponseCodes:
		r.AllowedResponseCodesChoice = &ReplaceSpecType_AllowedResponseCodes{AllowedResponseCodes: of.AllowedResponseCodes}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetAnonymizationSettingToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.AnonymizationSetting.(type) {
	case nil:
		o.AnonymizationSetting = nil

	case *ReplaceSpecType_CustomAnonymization:
		o.AnonymizationSetting = &GlobalSpecType_CustomAnonymization{CustomAnonymization: of.CustomAnonymization}

	case *ReplaceSpecType_DefaultAnonymization:
		o.AnonymizationSetting = &GlobalSpecType_DefaultAnonymization{DefaultAnonymization: of.DefaultAnonymization}

	case *ReplaceSpecType_DisableAnonymization:
		o.AnonymizationSetting = &GlobalSpecType_DisableAnonymization{DisableAnonymization: of.DisableAnonymization}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetAnonymizationSettingFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.AnonymizationSetting.(type) {
	case nil:
		r.AnonymizationSetting = nil

	case *GlobalSpecType_CustomAnonymization:
		r.AnonymizationSetting = &ReplaceSpecType_CustomAnonymization{CustomAnonymization: of.CustomAnonymization}

	case *GlobalSpecType_DefaultAnonymization:
		r.AnonymizationSetting = &ReplaceSpecType_DefaultAnonymization{DefaultAnonymization: of.DefaultAnonymization}

	case *GlobalSpecType_DisableAnonymization:
		r.AnonymizationSetting = &ReplaceSpecType_DisableAnonymization{DisableAnonymization: of.DisableAnonymization}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetBlockingPageChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.BlockingPageChoice.(type) {
	case nil:
		o.BlockingPageChoice = nil

	case *ReplaceSpecType_BlockingPage:
		o.BlockingPageChoice = &GlobalSpecType_BlockingPage{BlockingPage: of.BlockingPage}

	case *ReplaceSpecType_UseDefaultBlockingPage:
		o.BlockingPageChoice = &GlobalSpecType_UseDefaultBlockingPage{UseDefaultBlockingPage: of.UseDefaultBlockingPage}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetBlockingPageChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.BlockingPageChoice.(type) {
	case nil:
		r.BlockingPageChoice = nil

	case *GlobalSpecType_BlockingPage:
		r.BlockingPageChoice = &ReplaceSpecType_BlockingPage{BlockingPage: of.BlockingPage}

	case *GlobalSpecType_UseDefaultBlockingPage:
		r.BlockingPageChoice = &ReplaceSpecType_UseDefaultBlockingPage{UseDefaultBlockingPage: of.UseDefaultBlockingPage}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetBotProtectionChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.BotProtectionChoice.(type) {
	case nil:
		o.BotProtectionChoice = nil

	case *ReplaceSpecType_BotProtectionSetting:
		o.BotProtectionChoice = &GlobalSpecType_BotProtectionSetting{BotProtectionSetting: of.BotProtectionSetting}

	case *ReplaceSpecType_DefaultBotSetting:
		o.BotProtectionChoice = &GlobalSpecType_DefaultBotSetting{DefaultBotSetting: of.DefaultBotSetting}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetBotProtectionChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.BotProtectionChoice.(type) {
	case nil:
		r.BotProtectionChoice = nil

	case *GlobalSpecType_BotProtectionSetting:
		r.BotProtectionChoice = &ReplaceSpecType_BotProtectionSetting{BotProtectionSetting: of.BotProtectionSetting}

	case *GlobalSpecType_DefaultBotSetting:
		r.BotProtectionChoice = &ReplaceSpecType_DefaultBotSetting{DefaultBotSetting: of.DefaultBotSetting}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetDetectionSettingChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.DetectionSettingChoice.(type) {
	case nil:
		o.DetectionSettingChoice = nil

	case *ReplaceSpecType_AiRiskBasedBlocking:
		o.DetectionSettingChoice = &GlobalSpecType_AiRiskBasedBlocking{AiRiskBasedBlocking: of.AiRiskBasedBlocking}

	case *ReplaceSpecType_DefaultDetectionSettings:
		o.DetectionSettingChoice = &GlobalSpecType_DefaultDetectionSettings{DefaultDetectionSettings: of.DefaultDetectionSettings}

	case *ReplaceSpecType_DetectionSettings:
		o.DetectionSettingChoice = &GlobalSpecType_DetectionSettings{DetectionSettings: of.DetectionSettings}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetDetectionSettingChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.DetectionSettingChoice.(type) {
	case nil:
		r.DetectionSettingChoice = nil

	case *GlobalSpecType_AiRiskBasedBlocking:
		r.DetectionSettingChoice = &ReplaceSpecType_AiRiskBasedBlocking{AiRiskBasedBlocking: of.AiRiskBasedBlocking}

	case *GlobalSpecType_DefaultDetectionSettings:
		r.DetectionSettingChoice = &ReplaceSpecType_DefaultDetectionSettings{DefaultDetectionSettings: of.DefaultDetectionSettings}

	case *GlobalSpecType_DetectionSettings:
		r.DetectionSettingChoice = &ReplaceSpecType_DetectionSettings{DetectionSettings: of.DetectionSettings}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetEnforcementModeChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.EnforcementModeChoice.(type) {
	case nil:
		o.EnforcementModeChoice = nil

	case *ReplaceSpecType_Blocking:
		o.EnforcementModeChoice = &GlobalSpecType_Blocking{Blocking: of.Blocking}

	case *ReplaceSpecType_Monitoring:
		o.EnforcementModeChoice = &GlobalSpecType_Monitoring{Monitoring: of.Monitoring}

	case *ReplaceSpecType_UseLoadbalancerSetting:
		o.EnforcementModeChoice = &GlobalSpecType_UseLoadbalancerSetting{UseLoadbalancerSetting: of.UseLoadbalancerSetting}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetEnforcementModeChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.EnforcementModeChoice.(type) {
	case nil:
		r.EnforcementModeChoice = nil

	case *GlobalSpecType_Blocking:
		r.EnforcementModeChoice = &ReplaceSpecType_Blocking{Blocking: of.Blocking}

	case *GlobalSpecType_Monitoring:
		r.EnforcementModeChoice = &ReplaceSpecType_Monitoring{Monitoring: of.Monitoring}

	case *GlobalSpecType_UseLoadbalancerSetting:
		r.EnforcementModeChoice = &ReplaceSpecType_UseLoadbalancerSetting{UseLoadbalancerSetting: of.UseLoadbalancerSetting}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *ReplaceSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.GetAllowedResponseCodesChoiceFromGlobalSpecType(f)
	m.GetAnonymizationSettingFromGlobalSpecType(f)
	m.GetBlockingPageChoiceFromGlobalSpecType(f)
	m.GetBotProtectionChoiceFromGlobalSpecType(f)
	m.GetDetectionSettingChoiceFromGlobalSpecType(f)
	m.GetEnforcementModeChoiceFromGlobalSpecType(f)
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	m1.SetAllowedResponseCodesChoiceToGlobalSpecType(f)
	m1.SetAnonymizationSettingToGlobalSpecType(f)
	m1.SetBlockingPageChoiceToGlobalSpecType(f)
	m1.SetBotProtectionChoiceToGlobalSpecType(f)
	m1.SetDetectionSettingChoiceToGlobalSpecType(f)
	m1.SetEnforcementModeChoiceToGlobalSpecType(f)
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}
