// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/pvt_types.proto

package schema

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Title
//
// x-displayName: "displayname"
// Only added so codegeneration does not break
type ServiceConnectionType int32

const (
	// x-displayName: "displayname"
	// Only added so codegeneration does not break
	TLS ServiceConnectionType = 0
	// x-displayName: "displayname"
	// Only added so codegeneration does not break
	NoTLS ServiceConnectionType = 1
)

var ServiceConnectionType_name = map[int32]string{
	0: "TLS",
	1: "NoTLS",
}

var ServiceConnectionType_value = map[string]int32{
	"TLS":   0,
	"NoTLS": 1,
}

func (ServiceConnectionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2daa839768ffece4, []int{0}
}

// DaemonTLSParamsType
//
// x-displayName: "DaemonTLSParamsType"
// DaemonTLSParamsType specifies all TLS related information for a Volterra
// service-framework based daemon.
type DaemonTLSParamsType struct {
	// Server Params
	//
	// x-displayName: "Server Params"
	// TLS Params for server
	ServerParams *DaemonTlsParametersType `protobuf:"bytes,1,opt,name=server_params,json=serverParams,proto3" json:"server_params,omitempty"`
	// Client Params
	//
	// x-displayName: "Client Params"
	// TLS Params for client
	ClientParams *DaemonTlsParametersType `protobuf:"bytes,2,opt,name=client_params,json=clientParams,proto3" json:"client_params,omitempty"`
}

func (m *DaemonTLSParamsType) Reset()      { *m = DaemonTLSParamsType{} }
func (*DaemonTLSParamsType) ProtoMessage() {}
func (*DaemonTLSParamsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2daa839768ffece4, []int{0}
}
func (m *DaemonTLSParamsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaemonTLSParamsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DaemonTLSParamsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaemonTLSParamsType.Merge(m, src)
}
func (m *DaemonTLSParamsType) XXX_Size() int {
	return m.Size()
}
func (m *DaemonTLSParamsType) XXX_DiscardUnknown() {
	xxx_messageInfo_DaemonTLSParamsType.DiscardUnknown(m)
}

var xxx_messageInfo_DaemonTLSParamsType proto.InternalMessageInfo

func (m *DaemonTLSParamsType) GetServerParams() *DaemonTlsParametersType {
	if m != nil {
		return m.ServerParams
	}
	return nil
}

func (m *DaemonTLSParamsType) GetClientParams() *DaemonTlsParametersType {
	if m != nil {
		return m.ClientParams
	}
	return nil
}

// DaemonTlsCertificateType
//
// x-displayName: "TLS Certificate"
// Handle to fetch certificate and key
type DaemonTlsCertificateType struct {
	// certificate_url
	//
	// x-displayName: "Certificate URL"
	// The TLS certificate URL.
	CertificateUrl string `protobuf:"bytes,1,opt,name=certificate_url,json=certificateUrl,proto3" json:"certificate_url,omitempty"`
	// key_url
	//
	// x-displayName: "Key URL"
	// The TLS private key URL.
	PrivateKeyUrl string `protobuf:"bytes,2,opt,name=private_key_url,json=privateKeyUrl,proto3" json:"private_key_url,omitempty"`
}

func (m *DaemonTlsCertificateType) Reset()      { *m = DaemonTlsCertificateType{} }
func (*DaemonTlsCertificateType) ProtoMessage() {}
func (*DaemonTlsCertificateType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2daa839768ffece4, []int{1}
}
func (m *DaemonTlsCertificateType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaemonTlsCertificateType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DaemonTlsCertificateType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaemonTlsCertificateType.Merge(m, src)
}
func (m *DaemonTlsCertificateType) XXX_Size() int {
	return m.Size()
}
func (m *DaemonTlsCertificateType) XXX_DiscardUnknown() {
	xxx_messageInfo_DaemonTlsCertificateType.DiscardUnknown(m)
}

var xxx_messageInfo_DaemonTlsCertificateType proto.InternalMessageInfo

func (m *DaemonTlsCertificateType) GetCertificateUrl() string {
	if m != nil {
		return m.CertificateUrl
	}
	return ""
}

func (m *DaemonTlsCertificateType) GetPrivateKeyUrl() string {
	if m != nil {
		return m.PrivateKeyUrl
	}
	return ""
}

// DaemonTlsParamsType
//
// x-displayName: "Daemon TLS parameters"
// Information of different aspects for TLS authentication related to ciphers,
// certificates and trust store
type DaemonTlsParametersType struct {
	// minimum_protocol_version
	//
	// x-displayName: "Minimum TLS version"
	// Minimum TLS protocol version. Not being used right now.
	MinimumProtocolVersion TlsProtocol `protobuf:"varint,1,opt,name=minimum_protocol_version,json=minimumProtocolVersion,proto3,enum=ves.io.schema.TlsProtocol" json:"minimum_protocol_version,omitempty"`
	// maximum_protocol_version
	//
	// x-displayName: "Maximum TLS version"
	// Maximum TLS protocol version. Not being used right now.
	MaximumProtocolVersion TlsProtocol `protobuf:"varint,2,opt,name=maximum_protocol_version,json=maximumProtocolVersion,proto3,enum=ves.io.schema.TlsProtocol" json:"maximum_protocol_version,omitempty"`
	// cipher_suites
	//
	// x-displayName: "Cipher Suites"
	// If specified, the TLS listener will only support the specified [cipher list.]
	// (https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration>)
	// If not specified, the default list:
	//   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
	//   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
	//   ECDHE-ECDSA-AES128-SHA
	//   ECDHE-RSA-AES128-SHA
	//   AES128-GCM-SHA256
	//   AES128-SHA
	//   ECDHE-ECDSA-AES256-GCM-SHA384
	//   ECDHE-RSA-AES256-GCM-SHA384
	//   ECDHE-ECDSA-AES256-SHA
	//   ECDHE-RSA-AES256-SHA
	//   AES256-GCM-SHA384
	//   AES256-SHA
	// will be used. Not being used right now.
	CipherSuites []string `protobuf:"bytes,3,rep,name=cipher_suites,json=cipherSuites,proto3" json:"cipher_suites,omitempty"`
	// tls_certificates
	//
	// x-displayName: "TLS Certificates"
	// Set of TLS certificates
	TlsCertificates []*DaemonTlsCertificateType `protobuf:"bytes,4,rep,name=tls_certificates,json=tlsCertificates,proto3" json:"tls_certificates,omitempty"`
	// trusted_ca_url
	//
	// x-displayName: "Trusted CA"
	// The URL for a trust store
	TrustedCaUrl string `protobuf:"bytes,5,opt,name=trusted_ca_url,json=trustedCaUrl,proto3" json:"trusted_ca_url,omitempty"`
}

func (m *DaemonTlsParametersType) Reset()      { *m = DaemonTlsParametersType{} }
func (*DaemonTlsParametersType) ProtoMessage() {}
func (*DaemonTlsParametersType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2daa839768ffece4, []int{2}
}
func (m *DaemonTlsParametersType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaemonTlsParametersType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DaemonTlsParametersType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaemonTlsParametersType.Merge(m, src)
}
func (m *DaemonTlsParametersType) XXX_Size() int {
	return m.Size()
}
func (m *DaemonTlsParametersType) XXX_DiscardUnknown() {
	xxx_messageInfo_DaemonTlsParametersType.DiscardUnknown(m)
}

var xxx_messageInfo_DaemonTlsParametersType proto.InternalMessageInfo

func (m *DaemonTlsParametersType) GetMinimumProtocolVersion() TlsProtocol {
	if m != nil {
		return m.MinimumProtocolVersion
	}
	return TLS_AUTO
}

func (m *DaemonTlsParametersType) GetMaximumProtocolVersion() TlsProtocol {
	if m != nil {
		return m.MaximumProtocolVersion
	}
	return TLS_AUTO
}

func (m *DaemonTlsParametersType) GetCipherSuites() []string {
	if m != nil {
		return m.CipherSuites
	}
	return nil
}

func (m *DaemonTlsParametersType) GetTlsCertificates() []*DaemonTlsCertificateType {
	if m != nil {
		return m.TlsCertificates
	}
	return nil
}

func (m *DaemonTlsParametersType) GetTrustedCaUrl() string {
	if m != nil {
		return m.TrustedCaUrl
	}
	return ""
}

// Title
//
// x-displayName "displayname"
// UseragentType specifies all attributes encoded in Useragent header
// emitted by a service-framework based client.
type UseragentType struct {
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	ProgramName string `protobuf:"bytes,1,opt,name=program_name,json=programName,proto3" json:"program_name,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	HostName string `protobuf:"bytes,2,opt,name=host_name,json=hostName,proto3" json:"host_name,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	ServiceName string `protobuf:"bytes,3,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	SiteName string `protobuf:"bytes,4,opt,name=site_name,json=siteName,proto3" json:"site_name,omitempty"`
}

func (m *UseragentType) Reset()      { *m = UseragentType{} }
func (*UseragentType) ProtoMessage() {}
func (*UseragentType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2daa839768ffece4, []int{3}
}
func (m *UseragentType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UseragentType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UseragentType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UseragentType.Merge(m, src)
}
func (m *UseragentType) XXX_Size() int {
	return m.Size()
}
func (m *UseragentType) XXX_DiscardUnknown() {
	xxx_messageInfo_UseragentType.DiscardUnknown(m)
}

var xxx_messageInfo_UseragentType proto.InternalMessageInfo

func (m *UseragentType) GetProgramName() string {
	if m != nil {
		return m.ProgramName
	}
	return ""
}

func (m *UseragentType) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *UseragentType) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *UseragentType) GetSiteName() string {
	if m != nil {
		return m.SiteName
	}
	return ""
}

// Title
//
// x-displayName "displayname"
// ServiceParam groups all parameters required for a client to connect to a server
type ServiceParameters struct {
	// Title
	//
	// x-displayName: "displayname"
	// Only added so codegeneration does not break
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// Title
	//
	// x-displayName: "displayname"
	// Only added so codegeneration does not break
	Ctype ServiceConnectionType `protobuf:"varint,2,opt,name=ctype,proto3,enum=ves.io.schema.ServiceConnectionType" json:"ctype,omitempty"`
}

func (m *ServiceParameters) Reset()      { *m = ServiceParameters{} }
func (*ServiceParameters) ProtoMessage() {}
func (*ServiceParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_2daa839768ffece4, []int{4}
}
func (m *ServiceParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ServiceParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceParameters.Merge(m, src)
}
func (m *ServiceParameters) XXX_Size() int {
	return m.Size()
}
func (m *ServiceParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceParameters.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceParameters proto.InternalMessageInfo

func (m *ServiceParameters) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *ServiceParameters) GetCtype() ServiceConnectionType {
	if m != nil {
		return m.Ctype
	}
	return TLS
}

// Title
//
// x-displayName "displayname"
// OperMetaType is metadata that oper objects may have.
// Implementors can decided whether individual oper objects should have this field or not.
// If an oper object does have metadata, it should use this message type.
type OperMetaType struct {
	// Title
	//
	// x-displayName "displayname"
	// Tenant to which this object belongs.
	Tenant string `protobuf:"bytes,1,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Namespace defines the space within each name must be unique.
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Name must be unique within a namespace.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// UID is the unique in time and space value for this object.
	Uid string `protobuf:"bytes,4,opt,name=uid,proto3" json:"uid,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Creation timestamp for this object.
	CreationTimestamp *types.Timestamp `protobuf:"bytes,5,opt,name=creation_timestamp,json=creationTimestamp,proto3" json:"creation_timestamp,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Last modification timestamp for this object.
	ModificationTimestamp *types.Timestamp `protobuf:"bytes,6,opt,name=modification_timestamp,json=modificationTimestamp,proto3" json:"modification_timestamp,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Annotations is the unstructured annotation for this object.
	Annotations map[string]string `protobuf:"bytes,7,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *OperMetaType) Reset()      { *m = OperMetaType{} }
func (*OperMetaType) ProtoMessage() {}
func (*OperMetaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2daa839768ffece4, []int{5}
}
func (m *OperMetaType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperMetaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OperMetaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperMetaType.Merge(m, src)
}
func (m *OperMetaType) XXX_Size() int {
	return m.Size()
}
func (m *OperMetaType) XXX_DiscardUnknown() {
	xxx_messageInfo_OperMetaType.DiscardUnknown(m)
}

var xxx_messageInfo_OperMetaType proto.InternalMessageInfo

func (m *OperMetaType) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *OperMetaType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *OperMetaType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OperMetaType) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *OperMetaType) GetCreationTimestamp() *types.Timestamp {
	if m != nil {
		return m.CreationTimestamp
	}
	return nil
}

func (m *OperMetaType) GetModificationTimestamp() *types.Timestamp {
	if m != nil {
		return m.ModificationTimestamp
	}
	return nil
}

func (m *OperMetaType) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

// Title
//
// x-displayName "displayname"
// DaemonEnvironmentType is the specification of the environment in which the daemon is launched
type DaemonEnvironmentType struct {
	// Title
	//
	// x-displayName "displayname"
	// Name of the environment - staging, demo1, crt, etc.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// DNS suffix to use for internal communication - int.ves.io, int.volterra.us, etc.
	InternalDnsSuffix string `protobuf:"bytes,2,opt,name=internal_dns_suffix,json=internalDnsSuffix,proto3" json:"internal_dns_suffix,omitempty"`
}

func (m *DaemonEnvironmentType) Reset()      { *m = DaemonEnvironmentType{} }
func (*DaemonEnvironmentType) ProtoMessage() {}
func (*DaemonEnvironmentType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2daa839768ffece4, []int{6}
}
func (m *DaemonEnvironmentType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaemonEnvironmentType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DaemonEnvironmentType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaemonEnvironmentType.Merge(m, src)
}
func (m *DaemonEnvironmentType) XXX_Size() int {
	return m.Size()
}
func (m *DaemonEnvironmentType) XXX_DiscardUnknown() {
	xxx_messageInfo_DaemonEnvironmentType.DiscardUnknown(m)
}

var xxx_messageInfo_DaemonEnvironmentType proto.InternalMessageInfo

func (m *DaemonEnvironmentType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DaemonEnvironmentType) GetInternalDnsSuffix() string {
	if m != nil {
		return m.InternalDnsSuffix
	}
	return ""
}

// VTRPGracefulRestartParamsType
//
// x-displayName: "VTRPGracefulRestartParamsType"
// VTRPGracefulRestartParamsType contains configuration with VTRP GR/LLGR parameters
type VTRPGracefulRestartParamsType struct {
	// GR Enabled
	//
	// x-displayName: Graceful Restart Enabled"
	GrEnabled bool `protobuf:"varint,1,opt,name=gr_enabled,json=grEnabled,proto3" json:"gr_enabled,omitempty"`
	// GR Timer
	//
	// x-displayName: Graceful Restart Timer in seconds"
	GrTime uint32 `protobuf:"varint,2,opt,name=gr_time,json=grTime,proto3" json:"gr_time,omitempty"`
	// LLGR Enabled
	//
	// x-displayName: Long lived Graceful Restart Enabled"
	LlgrEnabled bool `protobuf:"varint,3,opt,name=llgr_enabled,json=llgrEnabled,proto3" json:"llgr_enabled,omitempty"`
	// LLGR Timer
	//
	// x-displayName: Long lived Graceful Restart Timer in seconds"
	LlgrTime uint32 `protobuf:"varint,4,opt,name=llgr_time,json=llgrTime,proto3" json:"llgr_time,omitempty"`
}

func (m *VTRPGracefulRestartParamsType) Reset()      { *m = VTRPGracefulRestartParamsType{} }
func (*VTRPGracefulRestartParamsType) ProtoMessage() {}
func (*VTRPGracefulRestartParamsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2daa839768ffece4, []int{7}
}
func (m *VTRPGracefulRestartParamsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VTRPGracefulRestartParamsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VTRPGracefulRestartParamsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VTRPGracefulRestartParamsType.Merge(m, src)
}
func (m *VTRPGracefulRestartParamsType) XXX_Size() int {
	return m.Size()
}
func (m *VTRPGracefulRestartParamsType) XXX_DiscardUnknown() {
	xxx_messageInfo_VTRPGracefulRestartParamsType.DiscardUnknown(m)
}

var xxx_messageInfo_VTRPGracefulRestartParamsType proto.InternalMessageInfo

func (m *VTRPGracefulRestartParamsType) GetGrEnabled() bool {
	if m != nil {
		return m.GrEnabled
	}
	return false
}

func (m *VTRPGracefulRestartParamsType) GetGrTime() uint32 {
	if m != nil {
		return m.GrTime
	}
	return 0
}

func (m *VTRPGracefulRestartParamsType) GetLlgrEnabled() bool {
	if m != nil {
		return m.LlgrEnabled
	}
	return false
}

func (m *VTRPGracefulRestartParamsType) GetLlgrTime() uint32 {
	if m != nil {
		return m.LlgrTime
	}
	return 0
}

// SyncServerParamsType
//
// x-displayName: "SyncServerParamsType"
// SyncServerParamsType specifies all status server params.
type SyncServerParamsType struct {
	// Sync Server Service Params
	//
	// x-displayName: "Sync Server List"
	// x-required
	SyncServerList []*ServiceParameters `protobuf:"bytes,1,rep,name=sync_server_list,json=syncServerList,proto3" json:"sync_server_list,omitempty"`
	// VTRPGracefulRestartParamsType
	//
	// x-displayName: "VTRPGracefulRestartParamsType"
	// VTRPGracefulRestartParamsType contains configuration with VTRP GR/LLGR parameters
	VtrpGracefulRestartParams *VTRPGracefulRestartParamsType `protobuf:"bytes,6,opt,name=vtrp_graceful_restart_params,json=vtrpGracefulRestartParams,proto3" json:"vtrp_graceful_restart_params,omitempty"`
}

func (m *SyncServerParamsType) Reset()      { *m = SyncServerParamsType{} }
func (*SyncServerParamsType) ProtoMessage() {}
func (*SyncServerParamsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2daa839768ffece4, []int{8}
}
func (m *SyncServerParamsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncServerParamsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SyncServerParamsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncServerParamsType.Merge(m, src)
}
func (m *SyncServerParamsType) XXX_Size() int {
	return m.Size()
}
func (m *SyncServerParamsType) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncServerParamsType.DiscardUnknown(m)
}

var xxx_messageInfo_SyncServerParamsType proto.InternalMessageInfo

func (m *SyncServerParamsType) GetSyncServerList() []*ServiceParameters {
	if m != nil {
		return m.SyncServerList
	}
	return nil
}

func (m *SyncServerParamsType) GetVtrpGracefulRestartParams() *VTRPGracefulRestartParamsType {
	if m != nil {
		return m.VtrpGracefulRestartParams
	}
	return nil
}

// SuggestValuesResp
//
// x-displayName: "Response for SuggestValues"
// Response body of SuggestValues request
type SuggestValuesResp struct {
	// item_lists
	//
	// x-displayName: "Suggested Items"
	// List of suggested items.
	Items []*SuggestedItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *SuggestValuesResp) Reset()      { *m = SuggestValuesResp{} }
func (*SuggestValuesResp) ProtoMessage() {}
func (*SuggestValuesResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_2daa839768ffece4, []int{9}
}
func (m *SuggestValuesResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SuggestValuesResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SuggestValuesResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SuggestValuesResp.Merge(m, src)
}
func (m *SuggestValuesResp) XXX_Size() int {
	return m.Size()
}
func (m *SuggestValuesResp) XXX_DiscardUnknown() {
	xxx_messageInfo_SuggestValuesResp.DiscardUnknown(m)
}

var xxx_messageInfo_SuggestValuesResp proto.InternalMessageInfo

func (m *SuggestValuesResp) GetItems() []*SuggestedItem {
	if m != nil {
		return m.Items
	}
	return nil
}

// SuggestedItem
//
// x-displayName: "Suggested Item"
// A tuple with a suggested value and it's description.
type SuggestedItem struct {
	// value
	//
	// x-displayName: "Value"
	// Suggested value for the field.
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// description
	//
	// x-displayName: "Description"
	// Optional description for the suggested value.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *SuggestedItem) Reset()      { *m = SuggestedItem{} }
func (*SuggestedItem) ProtoMessage() {}
func (*SuggestedItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_2daa839768ffece4, []int{10}
}
func (m *SuggestedItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SuggestedItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SuggestedItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SuggestedItem.Merge(m, src)
}
func (m *SuggestedItem) XXX_Size() int {
	return m.Size()
}
func (m *SuggestedItem) XXX_DiscardUnknown() {
	xxx_messageInfo_SuggestedItem.DiscardUnknown(m)
}

var xxx_messageInfo_SuggestedItem proto.InternalMessageInfo

func (m *SuggestedItem) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *SuggestedItem) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// Site mesh group status
//
// x-displayName: "Status"
// Status of the site mesh group (this will be used in site status object and smg status object)
type SiteMeshGroupStatus struct {
	// other_connected_sites
	//
	// x-displayName: "Other Connected Sites"
	// x-example: "[ce01-sfo, ce01-nyc]"
	// List of sites connected by this Site Mesh Group
	OtherConnectedSites []string `protobuf:"bytes,1,rep,name=other_connected_sites,json=otherConnectedSites,proto3" json:"other_connected_sites,omitempty"`
	// site_info
	//
	// x-displayName: "site info"
	// The list of sites in the site mesh group and information about each
	SiteInfo []*SiteInfo `protobuf:"bytes,2,rep,name=site_info,json=siteInfo,proto3" json:"site_info,omitempty"`
}

func (m *SiteMeshGroupStatus) Reset()      { *m = SiteMeshGroupStatus{} }
func (*SiteMeshGroupStatus) ProtoMessage() {}
func (*SiteMeshGroupStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_2daa839768ffece4, []int{11}
}
func (m *SiteMeshGroupStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SiteMeshGroupStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SiteMeshGroupStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SiteMeshGroupStatus.Merge(m, src)
}
func (m *SiteMeshGroupStatus) XXX_Size() int {
	return m.Size()
}
func (m *SiteMeshGroupStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SiteMeshGroupStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SiteMeshGroupStatus proto.InternalMessageInfo

func (m *SiteMeshGroupStatus) GetOtherConnectedSites() []string {
	if m != nil {
		return m.OtherConnectedSites
	}
	return nil
}

func (m *SiteMeshGroupStatus) GetSiteInfo() []*SiteInfo {
	if m != nil {
		return m.SiteInfo
	}
	return nil
}

// dc cluster group status
//
// x-displayName: "Status"
// Status of the dc cluster group (this will be used in site status object and dcg status object)
type DcClusterGroupStatus struct {
	// site_info
	//
	// x-required
	// x-displayName: "site info"
	// The list of sites in the dc cluster group and information about each
	SiteInfo []*SiteInfo `protobuf:"bytes,1,rep,name=site_info,json=siteInfo,proto3" json:"site_info,omitempty"`
}

func (m *DcClusterGroupStatus) Reset()      { *m = DcClusterGroupStatus{} }
func (*DcClusterGroupStatus) ProtoMessage() {}
func (*DcClusterGroupStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_2daa839768ffece4, []int{12}
}
func (m *DcClusterGroupStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DcClusterGroupStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DcClusterGroupStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DcClusterGroupStatus.Merge(m, src)
}
func (m *DcClusterGroupStatus) XXX_Size() int {
	return m.Size()
}
func (m *DcClusterGroupStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_DcClusterGroupStatus.DiscardUnknown(m)
}

var xxx_messageInfo_DcClusterGroupStatus proto.InternalMessageInfo

func (m *DcClusterGroupStatus) GetSiteInfo() []*SiteInfo {
	if m != nil {
		return m.SiteInfo
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.ServiceConnectionType", ServiceConnectionType_name, ServiceConnectionType_value)
	golang_proto.RegisterEnum("ves.io.schema.ServiceConnectionType", ServiceConnectionType_name, ServiceConnectionType_value)
	proto.RegisterType((*DaemonTLSParamsType)(nil), "ves.io.schema.DaemonTLSParamsType")
	golang_proto.RegisterType((*DaemonTLSParamsType)(nil), "ves.io.schema.DaemonTLSParamsType")
	proto.RegisterType((*DaemonTlsCertificateType)(nil), "ves.io.schema.DaemonTlsCertificateType")
	golang_proto.RegisterType((*DaemonTlsCertificateType)(nil), "ves.io.schema.DaemonTlsCertificateType")
	proto.RegisterType((*DaemonTlsParametersType)(nil), "ves.io.schema.DaemonTlsParametersType")
	golang_proto.RegisterType((*DaemonTlsParametersType)(nil), "ves.io.schema.DaemonTlsParametersType")
	proto.RegisterType((*UseragentType)(nil), "ves.io.schema.UseragentType")
	golang_proto.RegisterType((*UseragentType)(nil), "ves.io.schema.UseragentType")
	proto.RegisterType((*ServiceParameters)(nil), "ves.io.schema.ServiceParameters")
	golang_proto.RegisterType((*ServiceParameters)(nil), "ves.io.schema.ServiceParameters")
	proto.RegisterType((*OperMetaType)(nil), "ves.io.schema.OperMetaType")
	golang_proto.RegisterType((*OperMetaType)(nil), "ves.io.schema.OperMetaType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.OperMetaType.AnnotationsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.OperMetaType.AnnotationsEntry")
	proto.RegisterType((*DaemonEnvironmentType)(nil), "ves.io.schema.DaemonEnvironmentType")
	golang_proto.RegisterType((*DaemonEnvironmentType)(nil), "ves.io.schema.DaemonEnvironmentType")
	proto.RegisterType((*VTRPGracefulRestartParamsType)(nil), "ves.io.schema.VTRPGracefulRestartParamsType")
	golang_proto.RegisterType((*VTRPGracefulRestartParamsType)(nil), "ves.io.schema.VTRPGracefulRestartParamsType")
	proto.RegisterType((*SyncServerParamsType)(nil), "ves.io.schema.SyncServerParamsType")
	golang_proto.RegisterType((*SyncServerParamsType)(nil), "ves.io.schema.SyncServerParamsType")
	proto.RegisterType((*SuggestValuesResp)(nil), "ves.io.schema.SuggestValuesResp")
	golang_proto.RegisterType((*SuggestValuesResp)(nil), "ves.io.schema.SuggestValuesResp")
	proto.RegisterType((*SuggestedItem)(nil), "ves.io.schema.SuggestedItem")
	golang_proto.RegisterType((*SuggestedItem)(nil), "ves.io.schema.SuggestedItem")
	proto.RegisterType((*SiteMeshGroupStatus)(nil), "ves.io.schema.SiteMeshGroupStatus")
	golang_proto.RegisterType((*SiteMeshGroupStatus)(nil), "ves.io.schema.SiteMeshGroupStatus")
	proto.RegisterType((*DcClusterGroupStatus)(nil), "ves.io.schema.DcClusterGroupStatus")
	golang_proto.RegisterType((*DcClusterGroupStatus)(nil), "ves.io.schema.DcClusterGroupStatus")
}

func init() { proto.RegisterFile("ves.io/schema/pvt_types.proto", fileDescriptor_2daa839768ffece4) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/pvt_types.proto", fileDescriptor_2daa839768ffece4)
}

var fileDescriptor_2daa839768ffece4 = []byte{
	// 1255 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0x3d, 0x73, 0xdb, 0x46,
	0x13, 0xe6, 0xf1, 0x43, 0x12, 0x8f, 0xa2, 0x4c, 0x41, 0x96, 0x44, 0xcb, 0x12, 0x4c, 0xc3, 0x1e,
	0xdb, 0xf3, 0xbe, 0x36, 0x38, 0x66, 0x52, 0x64, 0x5c, 0x64, 0x26, 0xa6, 0x3c, 0x1a, 0x7f, 0xc6,
	0x01, 0x69, 0x17, 0x49, 0x81, 0x39, 0x81, 0x47, 0xe8, 0x22, 0x00, 0x87, 0xb9, 0x3b, 0xd0, 0x66,
	0x97, 0xfc, 0x82, 0x64, 0xd2, 0x24, 0x3f, 0x20, 0x45, 0xba, 0xf4, 0x71, 0xe3, 0x71, 0x95, 0xd2,
	0xa5, 0xcb, 0x88, 0x6a, 0x92, 0x54, 0xce, 0x3f, 0xc8, 0xdc, 0x1d, 0x20, 0x82, 0x1c, 0x39, 0x71,
	0x2a, 0x1e, 0x9e, 0xdd, 0x67, 0x6f, 0xf7, 0xd9, 0xc5, 0x82, 0x70, 0x67, 0x84, 0xb9, 0x4d, 0x68,
	0x9b, 0x7b, 0x07, 0x38, 0x44, 0xed, 0x78, 0x24, 0x5c, 0x31, 0x8e, 0x31, 0xb7, 0x63, 0x46, 0x05,
	0x35, 0xea, 0xda, 0x6c, 0x6b, 0xf3, 0xd6, 0x0d, 0x9f, 0x88, 0x83, 0x64, 0xdf, 0xf6, 0x68, 0xd8,
	0xf6, 0xa9, 0x4f, 0xdb, 0xca, 0x6b, 0x3f, 0x19, 0xaa, 0x27, 0xf5, 0xa0, 0x4e, 0x9a, 0xbd, 0x75,
	0xc1, 0xa7, 0xd4, 0x0f, 0xf0, 0xd4, 0x4b, 0x90, 0x10, 0x73, 0x81, 0xc2, 0x38, 0x75, 0x38, 0x37,
	0x7b, 0x7b, 0xee, 0xe6, 0xad, 0xed, 0x59, 0xd3, 0x08, 0x05, 0x64, 0x80, 0x04, 0x4e, 0xad, 0xad,
	0x39, 0x2b, 0xc1, 0xcf, 0x5c, 0x1a, 0x0b, 0x42, 0xa3, 0x94, 0x6f, 0xfd, 0x0c, 0xe0, 0xda, 0x2e,
	0xc2, 0x21, 0x8d, 0xfa, 0x0f, 0x7a, 0x8f, 0x11, 0x43, 0x21, 0xef, 0x8f, 0x63, 0x6c, 0xdc, 0x87,
	0x75, 0x8e, 0xd9, 0x08, 0x33, 0x37, 0x56, 0x60, 0x13, 0xb4, 0xc0, 0xb5, 0x5a, 0xe7, 0x8a, 0x3d,
	0x53, 0xa9, 0x9d, 0x52, 0x03, 0xae, 0xa8, 0x58, 0x60, 0xa6, 0xe8, 0xce, 0xb2, 0x26, 0xeb, 0x80,
	0x32, 0x98, 0x17, 0x10, 0x1c, 0x89, 0x2c, 0x58, 0xf1, 0xbf, 0x05, 0xd3, 0x64, 0x1d, 0xcc, 0x7a,
	0x06, 0x9b, 0x27, 0x8e, 0x5d, 0xcc, 0x04, 0x19, 0x12, 0x0f, 0x09, 0xac, 0xb2, 0xbe, 0x0a, 0xcf,
	0x78, 0x53, 0xc8, 0x4d, 0x58, 0xa0, 0xf2, 0xae, 0x3a, 0x2b, 0x39, 0xf8, 0x09, 0x0b, 0x8c, 0x2b,
	0xf0, 0x4c, 0xcc, 0xc8, 0x48, 0x3a, 0x1d, 0xe2, 0xb1, 0x72, 0x2c, 0x2a, 0xc7, 0x7a, 0x0a, 0xdf,
	0xc7, 0xe3, 0x27, 0x2c, 0xb8, 0x57, 0x5e, 0x2a, 0x35, 0xca, 0xf7, 0xca, 0x4b, 0xe5, 0x46, 0xc5,
	0xfa, 0xb3, 0x08, 0x37, 0xdf, 0x91, 0xa2, 0xd1, 0x87, 0xcd, 0x90, 0x44, 0x24, 0x4c, 0x42, 0x57,
	0xe9, 0xea, 0xd1, 0xc0, 0x1d, 0x61, 0xc6, 0x09, 0x8d, 0x54, 0x06, 0x2b, 0x9d, 0xad, 0xb9, 0x62,
	0x65, 0x8c, 0xd4, 0xd3, 0xd9, 0x48, 0xb9, 0x19, 0xf0, 0x54, 0x33, 0x55, 0x54, 0xf4, 0xfc, 0xf4,
	0xa8, 0xc5, 0xf7, 0x88, 0xaa, 0xb9, 0xf3, 0x51, 0x2f, 0xc1, 0xba, 0x47, 0xe2, 0x03, 0xcc, 0x5c,
	0x9e, 0x10, 0x81, 0x79, 0xb3, 0xd4, 0x2a, 0x5d, 0xab, 0x3a, 0xcb, 0x1a, 0xec, 0x29, 0xcc, 0x70,
	0x60, 0x43, 0x04, 0xdc, 0xcd, 0xc9, 0xc6, 0x9b, 0xe5, 0x56, 0xe9, 0x5a, 0xad, 0x73, 0xf5, 0x5d,
	0x5d, 0x9b, 0x6b, 0x86, 0x73, 0x46, 0xcc, 0x60, 0xdc, 0xb8, 0x0c, 0x57, 0x04, 0x4b, 0xb8, 0xc0,
	0x03, 0xd7, 0x43, 0x4a, 0xf3, 0x8a, 0xd2, 0x7c, 0x39, 0x45, 0xbb, 0x48, 0x4b, 0xbe, 0xd0, 0x58,
	0xb4, 0xbe, 0x01, 0xb0, 0xfe, 0x84, 0x63, 0x86, 0x7c, 0x1c, 0x09, 0x25, 0xf1, 0x45, 0xb8, 0x1c,
	0x33, 0xea, 0x33, 0x14, 0xba, 0x11, 0x0a, 0x71, 0xda, 0xd8, 0x5a, 0x8a, 0x3d, 0x42, 0x21, 0x36,
	0xce, 0xc3, 0xea, 0x01, 0xe5, 0x42, 0xdb, 0x75, 0x3f, 0x97, 0x24, 0xa0, 0x8c, 0x17, 0xa1, 0x1a,
	0x4a, 0xe2, 0x61, 0x6d, 0x2f, 0x69, 0x7e, 0x8a, 0x65, 0x7c, 0x4e, 0x44, 0x6a, 0x2f, 0x6b, 0xbe,
	0x04, 0xa4, 0xd1, 0x42, 0x70, 0xb5, 0xa7, 0x7d, 0xa7, 0xbd, 0x37, 0x1a, 0xb0, 0x34, 0x1d, 0x32,
	0x79, 0x34, 0x6e, 0xc1, 0x8a, 0x27, 0x5f, 0xd0, 0xb4, 0x41, 0x97, 0xe7, 0xd4, 0x4a, 0x43, 0x74,
	0x69, 0x14, 0x61, 0x4f, 0xbe, 0x88, 0x4a, 0x2a, 0x4d, 0xb1, 0x7e, 0x28, 0xc1, 0xe5, 0x4f, 0x63,
	0xcc, 0x1e, 0x62, 0x81, 0x54, 0xcd, 0x1b, 0x70, 0x41, 0xe0, 0x08, 0x45, 0x22, 0xbd, 0x21, 0x7d,
	0x32, 0xb6, 0x61, 0x55, 0xe6, 0xc8, 0x63, 0xe4, 0x65, 0x85, 0x4e, 0x01, 0xc3, 0x80, 0xe5, 0x5c,
	0x85, 0xea, 0xac, 0x12, 0x25, 0x83, 0xb4, 0x28, 0x79, 0x34, 0xee, 0x42, 0xc3, 0x63, 0x18, 0xc9,
	0x1c, 0xdc, 0x93, 0x85, 0xa3, 0x3a, 0x52, 0xeb, 0x6c, 0xd9, 0x7a, 0x25, 0xd9, 0xd9, 0x4a, 0xb2,
	0xfb, 0x99, 0x87, 0xb3, 0x9a, 0xb1, 0x4e, 0x20, 0xe3, 0x33, 0xb8, 0x11, 0xd2, 0x81, 0xee, 0xf3,
	0x6c, 0xb8, 0x85, 0x7f, 0x0d, 0xb7, 0x9e, 0x67, 0x4e, 0x43, 0x3e, 0x82, 0x35, 0x14, 0x45, 0x54,
	0x28, 0x98, 0x37, 0x17, 0xd5, 0xe8, 0x5d, 0x9f, 0x13, 0x33, 0xaf, 0x95, 0xfd, 0xc9, 0xd4, 0xfd,
	0x4e, 0x24, 0xd8, 0xd8, 0xc9, 0x07, 0xd8, 0xfa, 0x18, 0x36, 0xe6, 0x1d, 0xa4, 0x26, 0x87, 0x78,
	0x9c, 0x35, 0xef, 0x10, 0x8f, 0x8d, 0xb3, 0xb0, 0x32, 0x42, 0x41, 0x92, 0x69, 0xaa, 0x1f, 0x6e,
	0x15, 0x3f, 0x02, 0xd6, 0x17, 0x70, 0x5d, 0x0f, 0xfa, 0x9d, 0x68, 0x44, 0x18, 0x8d, 0xc2, 0x6c,
	0x2c, 0x33, 0xb1, 0x41, 0x4e, 0x6c, 0x1b, 0xae, 0x91, 0x48, 0x60, 0x16, 0xa1, 0xc0, 0x1d, 0x44,
	0xdc, 0xe5, 0xc9, 0x70, 0x48, 0x9e, 0xa7, 0x41, 0x57, 0x33, 0xd3, 0x6e, 0xc4, 0x7b, 0xca, 0x60,
	0x7d, 0x0f, 0xe0, 0xce, 0xd3, 0xbe, 0xf3, 0x78, 0x8f, 0x21, 0x0f, 0x0f, 0x93, 0xc0, 0x91, 0x22,
	0x30, 0x91, 0x5b, 0xc7, 0x3b, 0x10, 0xfa, 0xcc, 0xc5, 0x11, 0xda, 0x0f, 0xf0, 0x40, 0xdd, 0xb5,
	0xe4, 0x54, 0x7d, 0x76, 0x47, 0x03, 0xc6, 0x26, 0x5c, 0xf4, 0x99, 0x92, 0x5d, 0x5d, 0x52, 0x77,
	0x16, 0x7c, 0x26, 0xb5, 0x94, 0x43, 0x1f, 0x04, 0x39, 0x66, 0x49, 0x31, 0x6b, 0x12, 0xcb, 0xb8,
	0xe7, 0x61, 0x55, 0xb9, 0x28, 0x76, 0x59, 0xb1, 0x97, 0x24, 0x20, 0xf9, 0xd6, 0x5f, 0x00, 0x9e,
	0xed, 0x8d, 0x23, 0xaf, 0x97, 0x5b, 0xe7, 0x2a, 0xa1, 0x2f, 0x61, 0x83, 0x8f, 0x23, 0xcf, 0x4d,
	0x3f, 0x12, 0x01, 0xe1, 0x72, 0x46, 0x65, 0x93, 0x5a, 0xa7, 0x4f, 0xfc, 0xf4, 0xa5, 0xb9, 0x6d,
	0xfe, 0xf2, 0xc7, 0xcb, 0x52, 0xe5, 0x3b, 0x50, 0x6c, 0x14, 0xb3, 0xd3, 0xd2, 0xc9, 0xa9, 0x09,
	0x9c, 0x15, 0x7e, 0x72, 0xe3, 0x03, 0xc2, 0x85, 0x11, 0xc2, 0xed, 0x91, 0x60, 0xb1, 0xeb, 0xa7,
	0xf2, 0xb8, 0x4c, 0xeb, 0x93, 0x7d, 0x4d, 0xf4, 0x90, 0xcd, 0x0f, 0xc7, 0x3f, 0x0a, 0xea, 0x9c,
	0x93, 0x11, 0x4f, 0x35, 0x5b, 0x7b, 0x70, 0xb5, 0x97, 0xf8, 0x3e, 0xe6, 0xe2, 0xa9, 0x6c, 0x3f,
	0x77, 0x30, 0x8f, 0x8d, 0x0e, 0xac, 0x10, 0x81, 0xd5, 0x77, 0x50, 0x16, 0xb9, 0x3d, 0x5f, 0xa4,
	0x26, 0xe0, 0xc1, 0x5d, 0x81, 0x43, 0x47, 0xbb, 0x5a, 0x7b, 0xb0, 0x3e, 0x83, 0x4f, 0xc7, 0x0b,
	0xe4, 0xc6, 0xcb, 0x68, 0xc1, 0xda, 0x00, 0x73, 0x8f, 0x11, 0xf5, 0x61, 0x4e, 0xa7, 0x24, 0x0f,
	0x59, 0x3f, 0x02, 0xb8, 0xd6, 0x23, 0x02, 0x3f, 0xc4, 0xfc, 0x60, 0x8f, 0xd1, 0x24, 0xee, 0x09,
	0x24, 0x12, 0x6e, 0x74, 0xe0, 0x3a, 0x15, 0x72, 0x91, 0x7b, 0x7a, 0x9d, 0xe0, 0x81, 0xcb, 0xd5,
	0x46, 0x07, 0x6a, 0xa3, 0xaf, 0x29, 0x63, 0x37, 0xb3, 0xf5, 0xd4, 0x62, 0xff, 0x30, 0xdd, 0x71,
	0x24, 0x1a, 0xd2, 0x66, 0x51, 0x15, 0xb3, 0x39, 0x5f, 0x0c, 0x11, 0xf8, 0x6e, 0x34, 0xa4, 0x7a,
	0xf9, 0xc9, 0xd3, 0xad, 0x4b, 0xaf, 0x5e, 0x80, 0x0b, 0x70, 0x07, 0x6e, 0x48, 0x5b, 0x4b, 0xe6,
	0xd1, 0x52, 0x89, 0xb4, 0xd2, 0x4c, 0x4a, 0x37, 0xaf, 0x77, 0xac, 0x18, 0x9e, 0xdd, 0xf5, 0xba,
	0x81, 0xdc, 0xe5, 0x2c, 0x9f, 0xe6, 0xcc, 0x95, 0xe0, 0x7d, 0xaf, 0xb4, 0x5e, 0xbd, 0x00, 0x26,
	0xdc, 0x86, 0x9b, 0xbb, 0xdd, 0x56, 0x1a, 0x74, 0xf6, 0x4e, 0x70, 0xf3, 0x7f, 0xff, 0x87, 0xeb,
	0xa7, 0x2e, 0x54, 0x63, 0x11, 0x96, 0xfa, 0x0f, 0x7a, 0x8d, 0x82, 0x51, 0x85, 0x95, 0x47, 0x54,
	0x1e, 0xc1, 0xed, 0xaf, 0xc1, 0xeb, 0x23, 0xb3, 0xf0, 0xe6, 0xc8, 0x2c, 0xbc, 0x3d, 0x32, 0xc1,
	0x57, 0x13, 0x13, 0xfc, 0x34, 0x31, 0xc1, 0xaf, 0x13, 0x13, 0xbc, 0x9e, 0x98, 0xe0, 0xcd, 0xc4,
	0x04, 0xbf, 0x4d, 0x4c, 0xf0, 0xfb, 0xc4, 0x2c, 0xbc, 0x9d, 0x98, 0xe0, 0xdb, 0x63, 0xb3, 0xf0,
	0xf2, 0xd8, 0x04, 0xaf, 0x8f, 0xcd, 0xc2, 0x9b, 0x63, 0xb3, 0xf0, 0x79, 0xd7, 0xa7, 0xf1, 0xa1,
	0x6f, 0x8f, 0x68, 0x20, 0x30, 0x63, 0xc8, 0x4e, 0x78, 0x5b, 0x1d, 0x86, 0x94, 0x85, 0x37, 0x62,
	0x46, 0x47, 0x64, 0x80, 0xd9, 0x8d, 0xcc, 0xdc, 0x8e, 0xf7, 0x7d, 0xda, 0xc6, 0xcf, 0x45, 0xfa,
	0xd7, 0x4b, 0xff, 0xec, 0x2f, 0xa8, 0x0d, 0xf8, 0xc1, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xdf,
	0x33, 0xf5, 0xcf, 0x50, 0x0a, 0x00, 0x00,
}

func (x ServiceConnectionType) String() string {
	s, ok := ServiceConnectionType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *DaemonTLSParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DaemonTLSParamsType)
	if !ok {
		that2, ok := that.(DaemonTLSParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerParams.Equal(that1.ServerParams) {
		return false
	}
	if !this.ClientParams.Equal(that1.ClientParams) {
		return false
	}
	return true
}
func (this *DaemonTlsCertificateType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DaemonTlsCertificateType)
	if !ok {
		that2, ok := that.(DaemonTlsCertificateType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CertificateUrl != that1.CertificateUrl {
		return false
	}
	if this.PrivateKeyUrl != that1.PrivateKeyUrl {
		return false
	}
	return true
}
func (this *DaemonTlsParametersType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DaemonTlsParametersType)
	if !ok {
		that2, ok := that.(DaemonTlsParametersType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MinimumProtocolVersion != that1.MinimumProtocolVersion {
		return false
	}
	if this.MaximumProtocolVersion != that1.MaximumProtocolVersion {
		return false
	}
	if len(this.CipherSuites) != len(that1.CipherSuites) {
		return false
	}
	for i := range this.CipherSuites {
		if this.CipherSuites[i] != that1.CipherSuites[i] {
			return false
		}
	}
	if len(this.TlsCertificates) != len(that1.TlsCertificates) {
		return false
	}
	for i := range this.TlsCertificates {
		if !this.TlsCertificates[i].Equal(that1.TlsCertificates[i]) {
			return false
		}
	}
	if this.TrustedCaUrl != that1.TrustedCaUrl {
		return false
	}
	return true
}
func (this *UseragentType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UseragentType)
	if !ok {
		that2, ok := that.(UseragentType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProgramName != that1.ProgramName {
		return false
	}
	if this.HostName != that1.HostName {
		return false
	}
	if this.ServiceName != that1.ServiceName {
		return false
	}
	if this.SiteName != that1.SiteName {
		return false
	}
	return true
}
func (this *ServiceParameters) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceParameters)
	if !ok {
		that2, ok := that.(ServiceParameters)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	if this.Ctype != that1.Ctype {
		return false
	}
	return true
}
func (this *OperMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OperMetaType)
	if !ok {
		that2, ok := that.(OperMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Tenant != that1.Tenant {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if !this.CreationTimestamp.Equal(that1.CreationTimestamp) {
		return false
	}
	if !this.ModificationTimestamp.Equal(that1.ModificationTimestamp) {
		return false
	}
	if len(this.Annotations) != len(that1.Annotations) {
		return false
	}
	for i := range this.Annotations {
		if this.Annotations[i] != that1.Annotations[i] {
			return false
		}
	}
	return true
}
func (this *DaemonEnvironmentType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DaemonEnvironmentType)
	if !ok {
		that2, ok := that.(DaemonEnvironmentType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.InternalDnsSuffix != that1.InternalDnsSuffix {
		return false
	}
	return true
}
func (this *VTRPGracefulRestartParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VTRPGracefulRestartParamsType)
	if !ok {
		that2, ok := that.(VTRPGracefulRestartParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GrEnabled != that1.GrEnabled {
		return false
	}
	if this.GrTime != that1.GrTime {
		return false
	}
	if this.LlgrEnabled != that1.LlgrEnabled {
		return false
	}
	if this.LlgrTime != that1.LlgrTime {
		return false
	}
	return true
}
func (this *SyncServerParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SyncServerParamsType)
	if !ok {
		that2, ok := that.(SyncServerParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SyncServerList) != len(that1.SyncServerList) {
		return false
	}
	for i := range this.SyncServerList {
		if !this.SyncServerList[i].Equal(that1.SyncServerList[i]) {
			return false
		}
	}
	if !this.VtrpGracefulRestartParams.Equal(that1.VtrpGracefulRestartParams) {
		return false
	}
	return true
}
func (this *SuggestValuesResp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SuggestValuesResp)
	if !ok {
		that2, ok := that.(SuggestValuesResp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *SuggestedItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SuggestedItem)
	if !ok {
		that2, ok := that.(SuggestedItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	return true
}
func (this *SiteMeshGroupStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteMeshGroupStatus)
	if !ok {
		that2, ok := that.(SiteMeshGroupStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.OtherConnectedSites) != len(that1.OtherConnectedSites) {
		return false
	}
	for i := range this.OtherConnectedSites {
		if this.OtherConnectedSites[i] != that1.OtherConnectedSites[i] {
			return false
		}
	}
	if len(this.SiteInfo) != len(that1.SiteInfo) {
		return false
	}
	for i := range this.SiteInfo {
		if !this.SiteInfo[i].Equal(that1.SiteInfo[i]) {
			return false
		}
	}
	return true
}
func (this *DcClusterGroupStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DcClusterGroupStatus)
	if !ok {
		that2, ok := that.(DcClusterGroupStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SiteInfo) != len(that1.SiteInfo) {
		return false
	}
	for i := range this.SiteInfo {
		if !this.SiteInfo[i].Equal(that1.SiteInfo[i]) {
			return false
		}
	}
	return true
}
func (this *DaemonTLSParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.DaemonTLSParamsType{")
	if this.ServerParams != nil {
		s = append(s, "ServerParams: "+fmt.Sprintf("%#v", this.ServerParams)+",\n")
	}
	if this.ClientParams != nil {
		s = append(s, "ClientParams: "+fmt.Sprintf("%#v", this.ClientParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DaemonTlsCertificateType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.DaemonTlsCertificateType{")
	s = append(s, "CertificateUrl: "+fmt.Sprintf("%#v", this.CertificateUrl)+",\n")
	s = append(s, "PrivateKeyUrl: "+fmt.Sprintf("%#v", this.PrivateKeyUrl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DaemonTlsParametersType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.DaemonTlsParametersType{")
	s = append(s, "MinimumProtocolVersion: "+fmt.Sprintf("%#v", this.MinimumProtocolVersion)+",\n")
	s = append(s, "MaximumProtocolVersion: "+fmt.Sprintf("%#v", this.MaximumProtocolVersion)+",\n")
	s = append(s, "CipherSuites: "+fmt.Sprintf("%#v", this.CipherSuites)+",\n")
	if this.TlsCertificates != nil {
		s = append(s, "TlsCertificates: "+fmt.Sprintf("%#v", this.TlsCertificates)+",\n")
	}
	s = append(s, "TrustedCaUrl: "+fmt.Sprintf("%#v", this.TrustedCaUrl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UseragentType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.UseragentType{")
	s = append(s, "ProgramName: "+fmt.Sprintf("%#v", this.ProgramName)+",\n")
	s = append(s, "HostName: "+fmt.Sprintf("%#v", this.HostName)+",\n")
	s = append(s, "ServiceName: "+fmt.Sprintf("%#v", this.ServiceName)+",\n")
	s = append(s, "SiteName: "+fmt.Sprintf("%#v", this.SiteName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ServiceParameters) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.ServiceParameters{")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "Ctype: "+fmt.Sprintf("%#v", this.Ctype)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OperMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&schema.OperMetaType{")
	s = append(s, "Tenant: "+fmt.Sprintf("%#v", this.Tenant)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	if this.CreationTimestamp != nil {
		s = append(s, "CreationTimestamp: "+fmt.Sprintf("%#v", this.CreationTimestamp)+",\n")
	}
	if this.ModificationTimestamp != nil {
		s = append(s, "ModificationTimestamp: "+fmt.Sprintf("%#v", this.ModificationTimestamp)+",\n")
	}
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%#v: %#v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	if this.Annotations != nil {
		s = append(s, "Annotations: "+mapStringForAnnotations+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DaemonEnvironmentType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.DaemonEnvironmentType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "InternalDnsSuffix: "+fmt.Sprintf("%#v", this.InternalDnsSuffix)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VTRPGracefulRestartParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.VTRPGracefulRestartParamsType{")
	s = append(s, "GrEnabled: "+fmt.Sprintf("%#v", this.GrEnabled)+",\n")
	s = append(s, "GrTime: "+fmt.Sprintf("%#v", this.GrTime)+",\n")
	s = append(s, "LlgrEnabled: "+fmt.Sprintf("%#v", this.LlgrEnabled)+",\n")
	s = append(s, "LlgrTime: "+fmt.Sprintf("%#v", this.LlgrTime)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SyncServerParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.SyncServerParamsType{")
	if this.SyncServerList != nil {
		s = append(s, "SyncServerList: "+fmt.Sprintf("%#v", this.SyncServerList)+",\n")
	}
	if this.VtrpGracefulRestartParams != nil {
		s = append(s, "VtrpGracefulRestartParams: "+fmt.Sprintf("%#v", this.VtrpGracefulRestartParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SuggestValuesResp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.SuggestValuesResp{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SuggestedItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.SuggestedItem{")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteMeshGroupStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.SiteMeshGroupStatus{")
	s = append(s, "OtherConnectedSites: "+fmt.Sprintf("%#v", this.OtherConnectedSites)+",\n")
	if this.SiteInfo != nil {
		s = append(s, "SiteInfo: "+fmt.Sprintf("%#v", this.SiteInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DcClusterGroupStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.DcClusterGroupStatus{")
	if this.SiteInfo != nil {
		s = append(s, "SiteInfo: "+fmt.Sprintf("%#v", this.SiteInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringPvtTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *DaemonTLSParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaemonTLSParamsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaemonTLSParamsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClientParams != nil {
		{
			size, err := m.ClientParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPvtTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ServerParams != nil {
		{
			size, err := m.ServerParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPvtTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DaemonTlsCertificateType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaemonTlsCertificateType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaemonTlsCertificateType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PrivateKeyUrl) > 0 {
		i -= len(m.PrivateKeyUrl)
		copy(dAtA[i:], m.PrivateKeyUrl)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.PrivateKeyUrl)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CertificateUrl) > 0 {
		i -= len(m.CertificateUrl)
		copy(dAtA[i:], m.CertificateUrl)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.CertificateUrl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DaemonTlsParametersType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaemonTlsParametersType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaemonTlsParametersType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TrustedCaUrl) > 0 {
		i -= len(m.TrustedCaUrl)
		copy(dAtA[i:], m.TrustedCaUrl)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.TrustedCaUrl)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TlsCertificates) > 0 {
		for iNdEx := len(m.TlsCertificates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TlsCertificates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPvtTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CipherSuites) > 0 {
		for iNdEx := len(m.CipherSuites) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CipherSuites[iNdEx])
			copy(dAtA[i:], m.CipherSuites[iNdEx])
			i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.CipherSuites[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.MaximumProtocolVersion != 0 {
		i = encodeVarintPvtTypes(dAtA, i, uint64(m.MaximumProtocolVersion))
		i--
		dAtA[i] = 0x10
	}
	if m.MinimumProtocolVersion != 0 {
		i = encodeVarintPvtTypes(dAtA, i, uint64(m.MinimumProtocolVersion))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UseragentType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UseragentType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UseragentType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SiteName) > 0 {
		i -= len(m.SiteName)
		copy(dAtA[i:], m.SiteName)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.SiteName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ServiceName) > 0 {
		i -= len(m.ServiceName)
		copy(dAtA[i:], m.ServiceName)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.ServiceName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.HostName) > 0 {
		i -= len(m.HostName)
		copy(dAtA[i:], m.HostName)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.HostName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProgramName) > 0 {
		i -= len(m.ProgramName)
		copy(dAtA[i:], m.ProgramName)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.ProgramName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ctype != 0 {
		i = encodeVarintPvtTypes(dAtA, i, uint64(m.Ctype))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OperMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperMetaType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperMetaType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Annotations) > 0 {
		keysForAnnotations := make([]string, 0, len(m.Annotations))
		for k := range m.Annotations {
			keysForAnnotations = append(keysForAnnotations, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
		for iNdEx := len(keysForAnnotations) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Annotations[string(keysForAnnotations[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintPvtTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForAnnotations[iNdEx])
			copy(dAtA[i:], keysForAnnotations[iNdEx])
			i = encodeVarintPvtTypes(dAtA, i, uint64(len(keysForAnnotations[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPvtTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.ModificationTimestamp != nil {
		{
			size, err := m.ModificationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPvtTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.CreationTimestamp != nil {
		{
			size, err := m.CreationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPvtTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Tenant) > 0 {
		i -= len(m.Tenant)
		copy(dAtA[i:], m.Tenant)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.Tenant)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DaemonEnvironmentType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaemonEnvironmentType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaemonEnvironmentType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InternalDnsSuffix) > 0 {
		i -= len(m.InternalDnsSuffix)
		copy(dAtA[i:], m.InternalDnsSuffix)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.InternalDnsSuffix)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VTRPGracefulRestartParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VTRPGracefulRestartParamsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VTRPGracefulRestartParamsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LlgrTime != 0 {
		i = encodeVarintPvtTypes(dAtA, i, uint64(m.LlgrTime))
		i--
		dAtA[i] = 0x20
	}
	if m.LlgrEnabled {
		i--
		if m.LlgrEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.GrTime != 0 {
		i = encodeVarintPvtTypes(dAtA, i, uint64(m.GrTime))
		i--
		dAtA[i] = 0x10
	}
	if m.GrEnabled {
		i--
		if m.GrEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncServerParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncServerParamsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncServerParamsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VtrpGracefulRestartParams != nil {
		{
			size, err := m.VtrpGracefulRestartParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPvtTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.SyncServerList) > 0 {
		for iNdEx := len(m.SyncServerList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SyncServerList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPvtTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SuggestValuesResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuggestValuesResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SuggestValuesResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPvtTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SuggestedItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SuggestedItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SuggestedItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SiteMeshGroupStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteMeshGroupStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteMeshGroupStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SiteInfo) > 0 {
		for iNdEx := len(m.SiteInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SiteInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPvtTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.OtherConnectedSites) > 0 {
		for iNdEx := len(m.OtherConnectedSites) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OtherConnectedSites[iNdEx])
			copy(dAtA[i:], m.OtherConnectedSites[iNdEx])
			i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.OtherConnectedSites[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DcClusterGroupStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DcClusterGroupStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DcClusterGroupStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SiteInfo) > 0 {
		for iNdEx := len(m.SiteInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SiteInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPvtTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintPvtTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovPvtTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DaemonTLSParamsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerParams != nil {
		l = m.ServerParams.Size()
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	if m.ClientParams != nil {
		l = m.ClientParams.Size()
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	return n
}

func (m *DaemonTlsCertificateType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CertificateUrl)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.PrivateKeyUrl)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	return n
}

func (m *DaemonTlsParametersType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinimumProtocolVersion != 0 {
		n += 1 + sovPvtTypes(uint64(m.MinimumProtocolVersion))
	}
	if m.MaximumProtocolVersion != 0 {
		n += 1 + sovPvtTypes(uint64(m.MaximumProtocolVersion))
	}
	if len(m.CipherSuites) > 0 {
		for _, s := range m.CipherSuites {
			l = len(s)
			n += 1 + l + sovPvtTypes(uint64(l))
		}
	}
	if len(m.TlsCertificates) > 0 {
		for _, e := range m.TlsCertificates {
			l = e.Size()
			n += 1 + l + sovPvtTypes(uint64(l))
		}
	}
	l = len(m.TrustedCaUrl)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	return n
}

func (m *UseragentType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProgramName)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.SiteName)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	return n
}

func (m *ServiceParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	if m.Ctype != 0 {
		n += 1 + sovPvtTypes(uint64(m.Ctype))
	}
	return n
}

func (m *OperMetaType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	if m.CreationTimestamp != nil {
		l = m.CreationTimestamp.Size()
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	if m.ModificationTimestamp != nil {
		l = m.ModificationTimestamp.Size()
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPvtTypes(uint64(len(k))) + 1 + len(v) + sovPvtTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovPvtTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DaemonEnvironmentType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.InternalDnsSuffix)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	return n
}

func (m *VTRPGracefulRestartParamsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GrEnabled {
		n += 2
	}
	if m.GrTime != 0 {
		n += 1 + sovPvtTypes(uint64(m.GrTime))
	}
	if m.LlgrEnabled {
		n += 2
	}
	if m.LlgrTime != 0 {
		n += 1 + sovPvtTypes(uint64(m.LlgrTime))
	}
	return n
}

func (m *SyncServerParamsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SyncServerList) > 0 {
		for _, e := range m.SyncServerList {
			l = e.Size()
			n += 1 + l + sovPvtTypes(uint64(l))
		}
	}
	if m.VtrpGracefulRestartParams != nil {
		l = m.VtrpGracefulRestartParams.Size()
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	return n
}

func (m *SuggestValuesResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovPvtTypes(uint64(l))
		}
	}
	return n
}

func (m *SuggestedItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	return n
}

func (m *SiteMeshGroupStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OtherConnectedSites) > 0 {
		for _, s := range m.OtherConnectedSites {
			l = len(s)
			n += 1 + l + sovPvtTypes(uint64(l))
		}
	}
	if len(m.SiteInfo) > 0 {
		for _, e := range m.SiteInfo {
			l = e.Size()
			n += 1 + l + sovPvtTypes(uint64(l))
		}
	}
	return n
}

func (m *DcClusterGroupStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SiteInfo) > 0 {
		for _, e := range m.SiteInfo {
			l = e.Size()
			n += 1 + l + sovPvtTypes(uint64(l))
		}
	}
	return n
}

func sovPvtTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPvtTypes(x uint64) (n int) {
	return sovPvtTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *DaemonTLSParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DaemonTLSParamsType{`,
		`ServerParams:` + strings.Replace(this.ServerParams.String(), "DaemonTlsParametersType", "DaemonTlsParametersType", 1) + `,`,
		`ClientParams:` + strings.Replace(this.ClientParams.String(), "DaemonTlsParametersType", "DaemonTlsParametersType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DaemonTlsCertificateType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DaemonTlsCertificateType{`,
		`CertificateUrl:` + fmt.Sprintf("%v", this.CertificateUrl) + `,`,
		`PrivateKeyUrl:` + fmt.Sprintf("%v", this.PrivateKeyUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DaemonTlsParametersType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTlsCertificates := "[]*DaemonTlsCertificateType{"
	for _, f := range this.TlsCertificates {
		repeatedStringForTlsCertificates += strings.Replace(f.String(), "DaemonTlsCertificateType", "DaemonTlsCertificateType", 1) + ","
	}
	repeatedStringForTlsCertificates += "}"
	s := strings.Join([]string{`&DaemonTlsParametersType{`,
		`MinimumProtocolVersion:` + fmt.Sprintf("%v", this.MinimumProtocolVersion) + `,`,
		`MaximumProtocolVersion:` + fmt.Sprintf("%v", this.MaximumProtocolVersion) + `,`,
		`CipherSuites:` + fmt.Sprintf("%v", this.CipherSuites) + `,`,
		`TlsCertificates:` + repeatedStringForTlsCertificates + `,`,
		`TrustedCaUrl:` + fmt.Sprintf("%v", this.TrustedCaUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UseragentType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UseragentType{`,
		`ProgramName:` + fmt.Sprintf("%v", this.ProgramName) + `,`,
		`HostName:` + fmt.Sprintf("%v", this.HostName) + `,`,
		`ServiceName:` + fmt.Sprintf("%v", this.ServiceName) + `,`,
		`SiteName:` + fmt.Sprintf("%v", this.SiteName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServiceParameters) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceParameters{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`Ctype:` + fmt.Sprintf("%v", this.Ctype) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OperMetaType) String() string {
	if this == nil {
		return "nil"
	}
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%v: %v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	s := strings.Join([]string{`&OperMetaType{`,
		`Tenant:` + fmt.Sprintf("%v", this.Tenant) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`CreationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.CreationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`ModificationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ModificationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`Annotations:` + mapStringForAnnotations + `,`,
		`}`,
	}, "")
	return s
}
func (this *DaemonEnvironmentType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DaemonEnvironmentType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`InternalDnsSuffix:` + fmt.Sprintf("%v", this.InternalDnsSuffix) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VTRPGracefulRestartParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VTRPGracefulRestartParamsType{`,
		`GrEnabled:` + fmt.Sprintf("%v", this.GrEnabled) + `,`,
		`GrTime:` + fmt.Sprintf("%v", this.GrTime) + `,`,
		`LlgrEnabled:` + fmt.Sprintf("%v", this.LlgrEnabled) + `,`,
		`LlgrTime:` + fmt.Sprintf("%v", this.LlgrTime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SyncServerParamsType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSyncServerList := "[]*ServiceParameters{"
	for _, f := range this.SyncServerList {
		repeatedStringForSyncServerList += strings.Replace(f.String(), "ServiceParameters", "ServiceParameters", 1) + ","
	}
	repeatedStringForSyncServerList += "}"
	s := strings.Join([]string{`&SyncServerParamsType{`,
		`SyncServerList:` + repeatedStringForSyncServerList + `,`,
		`VtrpGracefulRestartParams:` + strings.Replace(this.VtrpGracefulRestartParams.String(), "VTRPGracefulRestartParamsType", "VTRPGracefulRestartParamsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SuggestValuesResp) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*SuggestedItem{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "SuggestedItem", "SuggestedItem", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&SuggestValuesResp{`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *SuggestedItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SuggestedItem{`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteMeshGroupStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSiteInfo := "[]*SiteInfo{"
	for _, f := range this.SiteInfo {
		repeatedStringForSiteInfo += strings.Replace(fmt.Sprintf("%v", f), "SiteInfo", "SiteInfo", 1) + ","
	}
	repeatedStringForSiteInfo += "}"
	s := strings.Join([]string{`&SiteMeshGroupStatus{`,
		`OtherConnectedSites:` + fmt.Sprintf("%v", this.OtherConnectedSites) + `,`,
		`SiteInfo:` + repeatedStringForSiteInfo + `,`,
		`}`,
	}, "")
	return s
}
func (this *DcClusterGroupStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSiteInfo := "[]*SiteInfo{"
	for _, f := range this.SiteInfo {
		repeatedStringForSiteInfo += strings.Replace(fmt.Sprintf("%v", f), "SiteInfo", "SiteInfo", 1) + ","
	}
	repeatedStringForSiteInfo += "}"
	s := strings.Join([]string{`&DcClusterGroupStatus{`,
		`SiteInfo:` + repeatedStringForSiteInfo + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringPvtTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *DaemonTLSParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaemonTLSParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaemonTLSParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerParams == nil {
				m.ServerParams = &DaemonTlsParametersType{}
			}
			if err := m.ServerParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientParams == nil {
				m.ClientParams = &DaemonTlsParametersType{}
			}
			if err := m.ClientParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaemonTlsCertificateType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaemonTlsCertificateType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaemonTlsCertificateType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertificateUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKeyUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateKeyUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaemonTlsParametersType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaemonTlsParametersType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaemonTlsParametersType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumProtocolVersion", wireType)
			}
			m.MinimumProtocolVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumProtocolVersion |= TlsProtocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumProtocolVersion", wireType)
			}
			m.MaximumProtocolVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumProtocolVersion |= TlsProtocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherSuites", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CipherSuites = append(m.CipherSuites, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsCertificates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsCertificates = append(m.TlsCertificates, &DaemonTlsCertificateType{})
			if err := m.TlsCertificates[len(m.TlsCertificates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedCaUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UseragentType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UseragentType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UseragentType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctype", wireType)
			}
			m.Ctype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctype |= ServiceConnectionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTimestamp == nil {
				m.CreationTimestamp = &types.Timestamp{}
			}
			if err := m.CreationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModificationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModificationTimestamp == nil {
				m.ModificationTimestamp = &types.Timestamp{}
			}
			if err := m.ModificationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPvtTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPvtTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPvtTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPvtTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPvtTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPvtTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPvtTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPvtTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPvtTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaemonEnvironmentType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaemonEnvironmentType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaemonEnvironmentType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalDnsSuffix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InternalDnsSuffix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VTRPGracefulRestartParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VTRPGracefulRestartParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VTRPGracefulRestartParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GrEnabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrTime", wireType)
			}
			m.GrTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GrTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LlgrEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LlgrEnabled = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LlgrTime", wireType)
			}
			m.LlgrTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LlgrTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncServerParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncServerParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncServerParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncServerList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SyncServerList = append(m.SyncServerList, &ServiceParameters{})
			if err := m.SyncServerList[len(m.SyncServerList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VtrpGracefulRestartParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VtrpGracefulRestartParams == nil {
				m.VtrpGracefulRestartParams = &VTRPGracefulRestartParamsType{}
			}
			if err := m.VtrpGracefulRestartParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SuggestValuesResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SuggestValuesResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SuggestValuesResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &SuggestedItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SuggestedItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SuggestedItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SuggestedItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteMeshGroupStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteMeshGroupStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteMeshGroupStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherConnectedSites", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OtherConnectedSites = append(m.OtherConnectedSites, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteInfo = append(m.SiteInfo, &SiteInfo{})
			if err := m.SiteInfo[len(m.SiteInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DcClusterGroupStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DcClusterGroupStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DcClusterGroupStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteInfo = append(m.SiteInfo, &SiteInfo{})
			if err := m.SiteInfo[len(m.SiteInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPvtTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPvtTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPvtTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPvtTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPvtTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPvtTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPvtTypes = fmt.Errorf("proto: unexpected end of group")
)
