// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/pvt_types.proto

package schema

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Title
//
// x-displayName: "displayname"
// Only added so codegeneration does not break
type ServiceConnectionType int32

const (
	// x-displayName: "displayname"
	// Only added so codegeneration does not break
	TLS ServiceConnectionType = 0
	// x-displayName: "displayname"
	// Only added so codegeneration does not break
	NoTLS ServiceConnectionType = 1
)

var ServiceConnectionType_name = map[int32]string{
	0: "TLS",
	1: "NoTLS",
}

var ServiceConnectionType_value = map[string]int32{
	"TLS":   0,
	"NoTLS": 1,
}

func (ServiceConnectionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2daa839768ffece4, []int{0}
}

// DaemonTLSParamsType
//
// x-displayName: "DaemonTLSParamsType"
// DaemonTLSParamsType specifies all TLS related information for a Volterra
// service-framework based daemon.
type DaemonTLSParamsType struct {
	// Server Params
	//
	// x-displayName: "Server Params"
	// TLS Params for server
	ServerParams *DaemonTlsParametersType `protobuf:"bytes,1,opt,name=server_params,json=serverParams,proto3" json:"server_params,omitempty"`
	// Client Params
	//
	// x-displayName: "Client Params"
	// TLS Params for client
	ClientParams *DaemonTlsParametersType `protobuf:"bytes,2,opt,name=client_params,json=clientParams,proto3" json:"client_params,omitempty"`
}

func (m *DaemonTLSParamsType) Reset()      { *m = DaemonTLSParamsType{} }
func (*DaemonTLSParamsType) ProtoMessage() {}
func (*DaemonTLSParamsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2daa839768ffece4, []int{0}
}
func (m *DaemonTLSParamsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaemonTLSParamsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DaemonTLSParamsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaemonTLSParamsType.Merge(m, src)
}
func (m *DaemonTLSParamsType) XXX_Size() int {
	return m.Size()
}
func (m *DaemonTLSParamsType) XXX_DiscardUnknown() {
	xxx_messageInfo_DaemonTLSParamsType.DiscardUnknown(m)
}

var xxx_messageInfo_DaemonTLSParamsType proto.InternalMessageInfo

func (m *DaemonTLSParamsType) GetServerParams() *DaemonTlsParametersType {
	if m != nil {
		return m.ServerParams
	}
	return nil
}

func (m *DaemonTLSParamsType) GetClientParams() *DaemonTlsParametersType {
	if m != nil {
		return m.ClientParams
	}
	return nil
}

// DaemonTlsCertificateType
//
// x-displayName: "TLS Certificate"
// Handle to fetch certificate and key
type DaemonTlsCertificateType struct {
	// certificate_url
	//
	// x-displayName: "Certificate URL"
	// The TLS certificate URL.
	CertificateUrl string `protobuf:"bytes,1,opt,name=certificate_url,json=certificateUrl,proto3" json:"certificate_url,omitempty"`
	// key_url
	//
	// x-displayName: "Key URL"
	// The TLS private key URL.
	PrivateKeyUrl string `protobuf:"bytes,2,opt,name=private_key_url,json=privateKeyUrl,proto3" json:"private_key_url,omitempty"`
}

func (m *DaemonTlsCertificateType) Reset()      { *m = DaemonTlsCertificateType{} }
func (*DaemonTlsCertificateType) ProtoMessage() {}
func (*DaemonTlsCertificateType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2daa839768ffece4, []int{1}
}
func (m *DaemonTlsCertificateType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaemonTlsCertificateType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DaemonTlsCertificateType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaemonTlsCertificateType.Merge(m, src)
}
func (m *DaemonTlsCertificateType) XXX_Size() int {
	return m.Size()
}
func (m *DaemonTlsCertificateType) XXX_DiscardUnknown() {
	xxx_messageInfo_DaemonTlsCertificateType.DiscardUnknown(m)
}

var xxx_messageInfo_DaemonTlsCertificateType proto.InternalMessageInfo

func (m *DaemonTlsCertificateType) GetCertificateUrl() string {
	if m != nil {
		return m.CertificateUrl
	}
	return ""
}

func (m *DaemonTlsCertificateType) GetPrivateKeyUrl() string {
	if m != nil {
		return m.PrivateKeyUrl
	}
	return ""
}

// DaemonTlsParamsType
//
// x-displayName: "Daemon TLS parameters"
// Information of different aspects for TLS authentication related to ciphers,
// certificates and trust store
type DaemonTlsParametersType struct {
	// minimum_protocol_version
	//
	// x-displayName: "Minimum TLS version"
	// Minimum TLS protocol version. Not being used right now.
	MinimumProtocolVersion TlsProtocol `protobuf:"varint,1,opt,name=minimum_protocol_version,json=minimumProtocolVersion,proto3,enum=ves.io.schema.TlsProtocol" json:"minimum_protocol_version,omitempty"`
	// maximum_protocol_version
	//
	// x-displayName: "Maximum TLS version"
	// Maximum TLS protocol version. Not being used right now.
	MaximumProtocolVersion TlsProtocol `protobuf:"varint,2,opt,name=maximum_protocol_version,json=maximumProtocolVersion,proto3,enum=ves.io.schema.TlsProtocol" json:"maximum_protocol_version,omitempty"`
	// cipher_suites
	//
	// x-displayName: "Cipher Suites"
	// If specified, the TLS listener will only support the specified [cipher list.]
	// (https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration>)
	// If not specified, the default list:
	//   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
	//   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
	//   ECDHE-ECDSA-AES128-SHA
	//   ECDHE-RSA-AES128-SHA
	//   AES128-GCM-SHA256
	//   AES128-SHA
	//   ECDHE-ECDSA-AES256-GCM-SHA384
	//   ECDHE-RSA-AES256-GCM-SHA384
	//   ECDHE-ECDSA-AES256-SHA
	//   ECDHE-RSA-AES256-SHA
	//   AES256-GCM-SHA384
	//   AES256-SHA
	// will be used. Not being used right now.
	CipherSuites []string `protobuf:"bytes,3,rep,name=cipher_suites,json=cipherSuites,proto3" json:"cipher_suites,omitempty"`
	// tls_certificates
	//
	// x-displayName: "TLS Certificates"
	// Set of TLS certificates
	TlsCertificates []*DaemonTlsCertificateType `protobuf:"bytes,4,rep,name=tls_certificates,json=tlsCertificates,proto3" json:"tls_certificates,omitempty"`
	// trusted_ca_url
	//
	// x-displayName: "Trusted CA"
	// The URL for a trust store
	TrustedCaUrl string `protobuf:"bytes,5,opt,name=trusted_ca_url,json=trustedCaUrl,proto3" json:"trusted_ca_url,omitempty"`
}

func (m *DaemonTlsParametersType) Reset()      { *m = DaemonTlsParametersType{} }
func (*DaemonTlsParametersType) ProtoMessage() {}
func (*DaemonTlsParametersType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2daa839768ffece4, []int{2}
}
func (m *DaemonTlsParametersType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaemonTlsParametersType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DaemonTlsParametersType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaemonTlsParametersType.Merge(m, src)
}
func (m *DaemonTlsParametersType) XXX_Size() int {
	return m.Size()
}
func (m *DaemonTlsParametersType) XXX_DiscardUnknown() {
	xxx_messageInfo_DaemonTlsParametersType.DiscardUnknown(m)
}

var xxx_messageInfo_DaemonTlsParametersType proto.InternalMessageInfo

func (m *DaemonTlsParametersType) GetMinimumProtocolVersion() TlsProtocol {
	if m != nil {
		return m.MinimumProtocolVersion
	}
	return TLS_AUTO
}

func (m *DaemonTlsParametersType) GetMaximumProtocolVersion() TlsProtocol {
	if m != nil {
		return m.MaximumProtocolVersion
	}
	return TLS_AUTO
}

func (m *DaemonTlsParametersType) GetCipherSuites() []string {
	if m != nil {
		return m.CipherSuites
	}
	return nil
}

func (m *DaemonTlsParametersType) GetTlsCertificates() []*DaemonTlsCertificateType {
	if m != nil {
		return m.TlsCertificates
	}
	return nil
}

func (m *DaemonTlsParametersType) GetTrustedCaUrl() string {
	if m != nil {
		return m.TrustedCaUrl
	}
	return ""
}

// Title
//
// x-displayName "displayname"
// Only added so codegeneration does not break
// UseragentType specifies all attributes encoded in Useragent header
// emitted by a service-framework based client.
type UseragentType struct {
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	ProgramName string `protobuf:"bytes,1,opt,name=program_name,json=programName,proto3" json:"program_name,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	HostName string `protobuf:"bytes,2,opt,name=host_name,json=hostName,proto3" json:"host_name,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	ServiceName string `protobuf:"bytes,3,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	SiteName string `protobuf:"bytes,4,opt,name=site_name,json=siteName,proto3" json:"site_name,omitempty"`
}

func (m *UseragentType) Reset()      { *m = UseragentType{} }
func (*UseragentType) ProtoMessage() {}
func (*UseragentType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2daa839768ffece4, []int{3}
}
func (m *UseragentType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UseragentType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UseragentType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UseragentType.Merge(m, src)
}
func (m *UseragentType) XXX_Size() int {
	return m.Size()
}
func (m *UseragentType) XXX_DiscardUnknown() {
	xxx_messageInfo_UseragentType.DiscardUnknown(m)
}

var xxx_messageInfo_UseragentType proto.InternalMessageInfo

func (m *UseragentType) GetProgramName() string {
	if m != nil {
		return m.ProgramName
	}
	return ""
}

func (m *UseragentType) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *UseragentType) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *UseragentType) GetSiteName() string {
	if m != nil {
		return m.SiteName
	}
	return ""
}

// Title
//
// x-displayName "displayname"
// Only added so codegeneration does not break
// ServiceParam groups all parameters required for a client to connect to a server
type ServiceParameters struct {
	// Title
	//
	// x-displayName: "displayname"
	// Only added so codegeneration does not break
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// Title
	//
	// x-displayName: "displayname"
	// Only added so codegeneration does not break
	Ctype ServiceConnectionType `protobuf:"varint,2,opt,name=ctype,proto3,enum=ves.io.schema.ServiceConnectionType" json:"ctype,omitempty"`
}

func (m *ServiceParameters) Reset()      { *m = ServiceParameters{} }
func (*ServiceParameters) ProtoMessage() {}
func (*ServiceParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_2daa839768ffece4, []int{4}
}
func (m *ServiceParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ServiceParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceParameters.Merge(m, src)
}
func (m *ServiceParameters) XXX_Size() int {
	return m.Size()
}
func (m *ServiceParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceParameters.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceParameters proto.InternalMessageInfo

func (m *ServiceParameters) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *ServiceParameters) GetCtype() ServiceConnectionType {
	if m != nil {
		return m.Ctype
	}
	return TLS
}

// Title
//
// x-displayName "displayname"
// Only added so codegeneration does not break
// OperMetaType is metadata that oper objects may have.
// Implementors can decided whether individual oper objects should have this field or not.
// If an oper object does have metadata, it should use this message type.
type OperMetaType struct {
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// Tenant to which this object belongs.
	Tenant string `protobuf:"bytes,1,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// Namespace defines the space within each name must be unique.
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// Name must be unique within a namespace.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// UID is the unique in time and space value for this object.
	Uid string `protobuf:"bytes,4,opt,name=uid,proto3" json:"uid,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// Creation and last modification timestamps for this object.
	CreationTimestamp *types.Timestamp `protobuf:"bytes,5,opt,name=creation_timestamp,json=creationTimestamp,proto3" json:"creation_timestamp,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	ModificationTimestamp *types.Timestamp `protobuf:"bytes,6,opt,name=modification_timestamp,json=modificationTimestamp,proto3" json:"modification_timestamp,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// Annotations is the unstructured annotation for this object.
	Annotations map[string]string `protobuf:"bytes,7,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *OperMetaType) Reset()      { *m = OperMetaType{} }
func (*OperMetaType) ProtoMessage() {}
func (*OperMetaType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2daa839768ffece4, []int{5}
}
func (m *OperMetaType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperMetaType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OperMetaType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperMetaType.Merge(m, src)
}
func (m *OperMetaType) XXX_Size() int {
	return m.Size()
}
func (m *OperMetaType) XXX_DiscardUnknown() {
	xxx_messageInfo_OperMetaType.DiscardUnknown(m)
}

var xxx_messageInfo_OperMetaType proto.InternalMessageInfo

func (m *OperMetaType) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *OperMetaType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *OperMetaType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OperMetaType) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *OperMetaType) GetCreationTimestamp() *types.Timestamp {
	if m != nil {
		return m.CreationTimestamp
	}
	return nil
}

func (m *OperMetaType) GetModificationTimestamp() *types.Timestamp {
	if m != nil {
		return m.ModificationTimestamp
	}
	return nil
}

func (m *OperMetaType) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

// Title
//
// x-displayName "displayname"
// Only added so codegeneration does not break
// DaemonEnvironmentType is the specification of the environment in which the daemon is launched
type DaemonEnvironmentType struct {
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// Name of the environment - staging, demo1, crt, etc.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Title
	//
	// x-displayName "displayname"
	// Only added so codegeneration does not break
	// DNS suffix to use for internal communication - int.ves.io, int.volterra.us, etc.
	InternalDnsSuffix string `protobuf:"bytes,2,opt,name=internal_dns_suffix,json=internalDnsSuffix,proto3" json:"internal_dns_suffix,omitempty"`
}

func (m *DaemonEnvironmentType) Reset()      { *m = DaemonEnvironmentType{} }
func (*DaemonEnvironmentType) ProtoMessage() {}
func (*DaemonEnvironmentType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2daa839768ffece4, []int{6}
}
func (m *DaemonEnvironmentType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DaemonEnvironmentType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DaemonEnvironmentType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DaemonEnvironmentType.Merge(m, src)
}
func (m *DaemonEnvironmentType) XXX_Size() int {
	return m.Size()
}
func (m *DaemonEnvironmentType) XXX_DiscardUnknown() {
	xxx_messageInfo_DaemonEnvironmentType.DiscardUnknown(m)
}

var xxx_messageInfo_DaemonEnvironmentType proto.InternalMessageInfo

func (m *DaemonEnvironmentType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DaemonEnvironmentType) GetInternalDnsSuffix() string {
	if m != nil {
		return m.InternalDnsSuffix
	}
	return ""
}

// SyncServerParamsType
//
// x-displayName: "SyncServerParamsType"
// SyncServerParamsType specifies all status server params.
type SyncServerParamsType struct {
	// Sync Server Service Params
	//
	// x-displayName: "Sync Server List"
	// x-required
	SyncServerList []*ServiceParameters `protobuf:"bytes,1,rep,name=sync_server_list,json=syncServerList,proto3" json:"sync_server_list,omitempty"`
}

func (m *SyncServerParamsType) Reset()      { *m = SyncServerParamsType{} }
func (*SyncServerParamsType) ProtoMessage() {}
func (*SyncServerParamsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_2daa839768ffece4, []int{7}
}
func (m *SyncServerParamsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncServerParamsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SyncServerParamsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncServerParamsType.Merge(m, src)
}
func (m *SyncServerParamsType) XXX_Size() int {
	return m.Size()
}
func (m *SyncServerParamsType) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncServerParamsType.DiscardUnknown(m)
}

var xxx_messageInfo_SyncServerParamsType proto.InternalMessageInfo

func (m *SyncServerParamsType) GetSyncServerList() []*ServiceParameters {
	if m != nil {
		return m.SyncServerList
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.ServiceConnectionType", ServiceConnectionType_name, ServiceConnectionType_value)
	golang_proto.RegisterEnum("ves.io.schema.ServiceConnectionType", ServiceConnectionType_name, ServiceConnectionType_value)
	proto.RegisterType((*DaemonTLSParamsType)(nil), "ves.io.schema.DaemonTLSParamsType")
	golang_proto.RegisterType((*DaemonTLSParamsType)(nil), "ves.io.schema.DaemonTLSParamsType")
	proto.RegisterType((*DaemonTlsCertificateType)(nil), "ves.io.schema.DaemonTlsCertificateType")
	golang_proto.RegisterType((*DaemonTlsCertificateType)(nil), "ves.io.schema.DaemonTlsCertificateType")
	proto.RegisterType((*DaemonTlsParametersType)(nil), "ves.io.schema.DaemonTlsParametersType")
	golang_proto.RegisterType((*DaemonTlsParametersType)(nil), "ves.io.schema.DaemonTlsParametersType")
	proto.RegisterType((*UseragentType)(nil), "ves.io.schema.UseragentType")
	golang_proto.RegisterType((*UseragentType)(nil), "ves.io.schema.UseragentType")
	proto.RegisterType((*ServiceParameters)(nil), "ves.io.schema.ServiceParameters")
	golang_proto.RegisterType((*ServiceParameters)(nil), "ves.io.schema.ServiceParameters")
	proto.RegisterType((*OperMetaType)(nil), "ves.io.schema.OperMetaType")
	golang_proto.RegisterType((*OperMetaType)(nil), "ves.io.schema.OperMetaType")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.OperMetaType.AnnotationsEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.OperMetaType.AnnotationsEntry")
	proto.RegisterType((*DaemonEnvironmentType)(nil), "ves.io.schema.DaemonEnvironmentType")
	golang_proto.RegisterType((*DaemonEnvironmentType)(nil), "ves.io.schema.DaemonEnvironmentType")
	proto.RegisterType((*SyncServerParamsType)(nil), "ves.io.schema.SyncServerParamsType")
	golang_proto.RegisterType((*SyncServerParamsType)(nil), "ves.io.schema.SyncServerParamsType")
}

func init() { proto.RegisterFile("ves.io/schema/pvt_types.proto", fileDescriptor_2daa839768ffece4) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/pvt_types.proto", fileDescriptor_2daa839768ffece4)
}

var fileDescriptor_2daa839768ffece4 = []byte{
	// 951 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0xbf, 0x73, 0x1b, 0x45,
	0x14, 0xd6, 0xea, 0x87, 0x7f, 0xac, 0x25, 0x5b, 0xbe, 0xc4, 0x46, 0x28, 0xe1, 0x70, 0x44, 0x26,
	0xf1, 0x00, 0x3e, 0xcd, 0x98, 0x86, 0x49, 0xc1, 0x0c, 0x71, 0x52, 0x90, 0x18, 0x03, 0x92, 0x4c,
	0x01, 0xc5, 0xcd, 0xfa, 0xf4, 0x74, 0x5e, 0x7c, 0xb7, 0x7b, 0xb3, 0xbb, 0x3a, 0xac, 0x0e, 0xf8,
	0x07, 0x60, 0xa8, 0xf8, 0x13, 0xe8, 0xe8, 0xa9, 0x52, 0x52, 0xba, 0x74, 0x89, 0xe5, 0x06, 0xa8,
	0xf2, 0x27, 0x30, 0xb7, 0xbb, 0xa7, 0x5f, 0xe3, 0x0c, 0xa4, 0xf2, 0xbb, 0xef, 0xbd, 0xef, 0xdb,
	0xb7, 0xdf, 0x7b, 0x5a, 0xe3, 0xb7, 0x52, 0x90, 0x1e, 0xe5, 0x6d, 0x19, 0x9c, 0x42, 0x4c, 0xda,
	0x49, 0xaa, 0x7c, 0x35, 0x4a, 0x40, 0x7a, 0x89, 0xe0, 0x8a, 0x3b, 0x35, 0x93, 0xf6, 0x4c, 0xba,
	0xb9, 0x17, 0x52, 0x75, 0x3a, 0x3c, 0xf1, 0x02, 0x1e, 0xb7, 0x43, 0x1e, 0xf2, 0xb6, 0xae, 0x3a,
	0x19, 0x0e, 0xf4, 0x97, 0xfe, 0xd0, 0x91, 0x61, 0x37, 0xdf, 0x0e, 0x39, 0x0f, 0x23, 0x98, 0x56,
	0x29, 0x1a, 0x83, 0x54, 0x24, 0x4e, 0x6c, 0xc1, 0x9d, 0xf9, 0xd3, 0x79, 0xa2, 0x28, 0x67, 0xf6,
	0xec, 0xe6, 0x9b, 0xf3, 0xc9, 0x99, 0xb6, 0x9a, 0x77, 0xe7, 0x53, 0x29, 0x89, 0x68, 0x9f, 0x28,
	0x30, 0xd9, 0xd6, 0x6f, 0x08, 0xdf, 0x7a, 0x42, 0x20, 0xe6, 0xac, 0x77, 0xd8, 0xfd, 0x9c, 0x08,
	0x12, 0xcb, 0xde, 0x28, 0x01, 0xe7, 0x39, 0xae, 0x49, 0x10, 0x29, 0x08, 0x3f, 0xd1, 0x60, 0x03,
	0xed, 0xa0, 0xdd, 0xb5, 0xfd, 0x07, 0xde, 0xdc, 0x25, 0x3d, 0x4b, 0x8d, 0xa4, 0xa6, 0x82, 0x02,
	0xa1, 0xe9, 0x9d, 0xaa, 0x21, 0x1b, 0xc1, 0x4c, 0x2c, 0x88, 0x28, 0x30, 0x95, 0x8b, 0x15, 0x5f,
	0x4f, 0xcc, 0x90, 0x8d, 0x58, 0xeb, 0x5b, 0xdc, 0x98, 0x14, 0x1e, 0x80, 0x50, 0x74, 0x40, 0x03,
	0xa2, 0x40, 0x77, 0xfd, 0x10, 0x6f, 0x04, 0x53, 0xc8, 0x1f, 0x8a, 0x48, 0xf7, 0xbd, 0xda, 0x59,
	0x9f, 0x81, 0x8f, 0x45, 0xe4, 0x3c, 0xc0, 0x1b, 0x89, 0xa0, 0x69, 0x56, 0x74, 0x06, 0x23, 0x5d,
	0x58, 0xd4, 0x85, 0x35, 0x0b, 0x3f, 0x87, 0xd1, 0xb1, 0x88, 0x9e, 0x95, 0x57, 0x4a, 0xf5, 0xf2,
	0xb3, 0xf2, 0x4a, 0xb9, 0x5e, 0x69, 0xfd, 0x53, 0xc4, 0x6f, 0xbc, 0xa2, 0x45, 0xa7, 0x87, 0x1b,
	0x31, 0x65, 0x34, 0x1e, 0xc6, 0xbe, 0xf6, 0x35, 0xe0, 0x91, 0x9f, 0x82, 0x90, 0x94, 0x33, 0xdd,
	0xc1, 0xfa, 0x7e, 0x73, 0xe1, 0xb2, 0x99, 0x86, 0xad, 0xec, 0x6c, 0x5b, 0x6e, 0x0e, 0x7c, 0x69,
	0x98, 0x5a, 0x95, 0x9c, 0xdf, 0xac, 0x5a, 0xfc, 0x1f, 0xaa, 0x86, 0xbb, 0xa8, 0xfa, 0x0e, 0xae,
	0x05, 0x34, 0x39, 0x05, 0xe1, 0xcb, 0x21, 0x55, 0x20, 0x1b, 0xa5, 0x9d, 0xd2, 0xee, 0x6a, 0xa7,
	0x6a, 0xc0, 0xae, 0xc6, 0x9c, 0x0e, 0xae, 0xab, 0x48, 0xfa, 0x33, 0xb6, 0xc9, 0x46, 0x79, 0xa7,
	0xb4, 0xbb, 0xb6, 0xff, 0xf0, 0x55, 0x53, 0x5b, 0x18, 0x46, 0x67, 0x43, 0xcd, 0x61, 0xd2, 0xb9,
	0x8f, 0xd7, 0x95, 0x18, 0x4a, 0x05, 0x7d, 0x3f, 0x20, 0xda, 0xf3, 0x8a, 0xf6, 0xbc, 0x6a, 0xd1,
	0x03, 0x62, 0x2c, 0x5f, 0xaa, 0x2f, 0xb7, 0x7e, 0x44, 0xb8, 0x76, 0x2c, 0x41, 0x90, 0x10, 0x98,
	0xd2, 0x16, 0xdf, 0xc3, 0xd5, 0x44, 0xf0, 0x50, 0x90, 0xd8, 0x67, 0x24, 0x06, 0x3b, 0xd8, 0x35,
	0x8b, 0x1d, 0x91, 0x18, 0x9c, 0x3b, 0x78, 0xf5, 0x94, 0x4b, 0x65, 0xf2, 0x66, 0x9e, 0x2b, 0x19,
	0xa0, 0x93, 0xf7, 0xb0, 0x5e, 0x4a, 0x1a, 0x80, 0xc9, 0x97, 0x0c, 0xdf, 0x62, 0x39, 0x5f, 0x52,
	0x65, 0xf3, 0x65, 0xc3, 0xcf, 0x80, 0x2c, 0xd9, 0x22, 0x78, 0xb3, 0x6b, 0x6a, 0xa7, 0xb3, 0x77,
	0xea, 0xb8, 0x34, 0x5d, 0xb2, 0x2c, 0x74, 0x1e, 0xe1, 0x4a, 0x90, 0xfd, 0xfc, 0xec, 0x80, 0xee,
	0x2f, 0xb8, 0x65, 0x25, 0x0e, 0x38, 0x63, 0x10, 0x64, 0xbf, 0x60, 0x6d, 0x95, 0xa1, 0xb4, 0x7e,
	0x29, 0xe1, 0xea, 0x67, 0x09, 0x88, 0x4f, 0x41, 0x11, 0x7d, 0xe7, 0x6d, 0xbc, 0xa4, 0x80, 0x11,
	0xa6, 0xec, 0x09, 0xf6, 0xcb, 0xb9, 0x8b, 0x57, 0xb3, 0x1e, 0x65, 0x42, 0x82, 0xfc, 0xa2, 0x53,
	0xc0, 0x71, 0x70, 0x79, 0xe6, 0x86, 0x3a, 0xd6, 0x8d, 0xd2, 0xbe, 0xbd, 0x54, 0x16, 0x3a, 0x9f,
	0x60, 0x27, 0x10, 0x40, 0xb2, 0x1e, 0xfc, 0xc9, 0x5b, 0xa3, 0x27, 0xb2, 0xb6, 0xdf, 0xf4, 0xcc,
	0x6b, 0xe4, 0xe5, 0xaf, 0x91, 0xd7, 0xcb, 0x2b, 0x3a, 0x9b, 0x39, 0x6b, 0x02, 0x39, 0x5f, 0xe0,
	0xed, 0x98, 0xf7, 0xcd, 0x9c, 0xe7, 0xe5, 0x96, 0xfe, 0x53, 0x6e, 0x6b, 0x96, 0x39, 0x95, 0x3c,
	0xc2, 0x6b, 0x84, 0x31, 0xae, 0x34, 0x2c, 0x1b, 0xcb, 0x7a, 0xf5, 0xde, 0x5f, 0x30, 0x73, 0xd6,
	0x2b, 0xef, 0xe3, 0x69, 0xf9, 0x53, 0xa6, 0xc4, 0xa8, 0x33, 0x2b, 0xd0, 0xfc, 0x08, 0xd7, 0x17,
	0x0b, 0x32, 0x4f, 0xce, 0x60, 0x94, 0x0f, 0xef, 0x0c, 0x46, 0xce, 0x6d, 0x5c, 0x49, 0x49, 0x34,
	0xcc, 0x3d, 0x35, 0x1f, 0x8f, 0x8a, 0x1f, 0xa2, 0xd6, 0xd7, 0x78, 0xcb, 0x2c, 0xfa, 0x53, 0x96,
	0x52, 0xc1, 0x59, 0x9c, 0xaf, 0x65, 0x6e, 0x36, 0x9a, 0x31, 0xdb, 0xc3, 0xb7, 0x28, 0x53, 0x20,
	0x18, 0x89, 0xfc, 0x3e, 0x93, 0xbe, 0x1c, 0x0e, 0x06, 0xf4, 0xdc, 0x8a, 0x6e, 0xe6, 0xa9, 0x27,
	0x4c, 0x76, 0x75, 0xa2, 0xf5, 0x03, 0xc2, 0xb7, 0xbb, 0x23, 0x16, 0x74, 0x67, 0x1e, 0x4d, 0x2d,
	0xfe, 0x0d, 0xae, 0xcb, 0x11, 0x0b, 0x7c, 0xfb, 0x14, 0x47, 0x54, 0x66, 0x9b, 0x90, 0x59, 0xb1,
	0x73, 0xf3, 0x5e, 0x4d, 0x57, 0xf3, 0xb1, 0xfb, 0xfb, 0xdf, 0x2f, 0x4a, 0x95, 0x9f, 0x51, 0xb1,
	0x5e, 0xcc, 0xa3, 0x95, 0x49, 0xd4, 0x40, 0x9d, 0x75, 0x39, 0x39, 0xf1, 0x90, 0x4a, 0xf5, 0xee,
	0x7b, 0x78, 0xeb, 0xc6, 0xe5, 0x74, 0x96, 0x71, 0xa9, 0x77, 0xd8, 0xad, 0x17, 0x9c, 0x55, 0x5c,
	0x39, 0xe2, 0x59, 0x88, 0x1e, 0x7f, 0x8f, 0x2e, 0xae, 0xdc, 0xc2, 0xe5, 0x95, 0x5b, 0x78, 0x79,
	0xe5, 0xa2, 0xef, 0xc6, 0x2e, 0xfa, 0x75, 0xec, 0xa2, 0x3f, 0xc6, 0x2e, 0xba, 0x18, 0xbb, 0xe8,
	0x72, 0xec, 0xa2, 0x3f, 0xc7, 0x2e, 0xfa, 0x6b, 0xec, 0x16, 0x5e, 0x8e, 0x5d, 0xf4, 0xd3, 0xb5,
	0x5b, 0x78, 0x71, 0xed, 0xa2, 0x8b, 0x6b, 0xb7, 0x70, 0x79, 0xed, 0x16, 0xbe, 0x3a, 0x08, 0x79,
	0x72, 0x16, 0x7a, 0x29, 0x8f, 0x14, 0x08, 0x41, 0xbc, 0xa1, 0x6c, 0xeb, 0x60, 0xc0, 0x45, 0xbc,
	0x97, 0x08, 0x9e, 0xd2, 0x3e, 0x88, 0xbd, 0x3c, 0xdd, 0x4e, 0x4e, 0x42, 0xde, 0x86, 0x73, 0x65,
	0xff, 0x85, 0x99, 0x3f, 0x27, 0x4b, 0x7a, 0x9b, 0x3e, 0xf8, 0x37, 0x00, 0x00, 0xff, 0xff, 0xe5,
	0xc9, 0x51, 0xe0, 0x97, 0x07, 0x00, 0x00,
}

func (x ServiceConnectionType) String() string {
	s, ok := ServiceConnectionType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *DaemonTLSParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DaemonTLSParamsType)
	if !ok {
		that2, ok := that.(DaemonTLSParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ServerParams.Equal(that1.ServerParams) {
		return false
	}
	if !this.ClientParams.Equal(that1.ClientParams) {
		return false
	}
	return true
}
func (this *DaemonTlsCertificateType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DaemonTlsCertificateType)
	if !ok {
		that2, ok := that.(DaemonTlsCertificateType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CertificateUrl != that1.CertificateUrl {
		return false
	}
	if this.PrivateKeyUrl != that1.PrivateKeyUrl {
		return false
	}
	return true
}
func (this *DaemonTlsParametersType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DaemonTlsParametersType)
	if !ok {
		that2, ok := that.(DaemonTlsParametersType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MinimumProtocolVersion != that1.MinimumProtocolVersion {
		return false
	}
	if this.MaximumProtocolVersion != that1.MaximumProtocolVersion {
		return false
	}
	if len(this.CipherSuites) != len(that1.CipherSuites) {
		return false
	}
	for i := range this.CipherSuites {
		if this.CipherSuites[i] != that1.CipherSuites[i] {
			return false
		}
	}
	if len(this.TlsCertificates) != len(that1.TlsCertificates) {
		return false
	}
	for i := range this.TlsCertificates {
		if !this.TlsCertificates[i].Equal(that1.TlsCertificates[i]) {
			return false
		}
	}
	if this.TrustedCaUrl != that1.TrustedCaUrl {
		return false
	}
	return true
}
func (this *UseragentType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UseragentType)
	if !ok {
		that2, ok := that.(UseragentType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProgramName != that1.ProgramName {
		return false
	}
	if this.HostName != that1.HostName {
		return false
	}
	if this.ServiceName != that1.ServiceName {
		return false
	}
	if this.SiteName != that1.SiteName {
		return false
	}
	return true
}
func (this *ServiceParameters) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServiceParameters)
	if !ok {
		that2, ok := that.(ServiceParameters)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	if this.Ctype != that1.Ctype {
		return false
	}
	return true
}
func (this *OperMetaType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OperMetaType)
	if !ok {
		that2, ok := that.(OperMetaType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Tenant != that1.Tenant {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if !this.CreationTimestamp.Equal(that1.CreationTimestamp) {
		return false
	}
	if !this.ModificationTimestamp.Equal(that1.ModificationTimestamp) {
		return false
	}
	if len(this.Annotations) != len(that1.Annotations) {
		return false
	}
	for i := range this.Annotations {
		if this.Annotations[i] != that1.Annotations[i] {
			return false
		}
	}
	return true
}
func (this *DaemonEnvironmentType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DaemonEnvironmentType)
	if !ok {
		that2, ok := that.(DaemonEnvironmentType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.InternalDnsSuffix != that1.InternalDnsSuffix {
		return false
	}
	return true
}
func (this *SyncServerParamsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SyncServerParamsType)
	if !ok {
		that2, ok := that.(SyncServerParamsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SyncServerList) != len(that1.SyncServerList) {
		return false
	}
	for i := range this.SyncServerList {
		if !this.SyncServerList[i].Equal(that1.SyncServerList[i]) {
			return false
		}
	}
	return true
}
func (this *DaemonTLSParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.DaemonTLSParamsType{")
	if this.ServerParams != nil {
		s = append(s, "ServerParams: "+fmt.Sprintf("%#v", this.ServerParams)+",\n")
	}
	if this.ClientParams != nil {
		s = append(s, "ClientParams: "+fmt.Sprintf("%#v", this.ClientParams)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DaemonTlsCertificateType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.DaemonTlsCertificateType{")
	s = append(s, "CertificateUrl: "+fmt.Sprintf("%#v", this.CertificateUrl)+",\n")
	s = append(s, "PrivateKeyUrl: "+fmt.Sprintf("%#v", this.PrivateKeyUrl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DaemonTlsParametersType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&schema.DaemonTlsParametersType{")
	s = append(s, "MinimumProtocolVersion: "+fmt.Sprintf("%#v", this.MinimumProtocolVersion)+",\n")
	s = append(s, "MaximumProtocolVersion: "+fmt.Sprintf("%#v", this.MaximumProtocolVersion)+",\n")
	s = append(s, "CipherSuites: "+fmt.Sprintf("%#v", this.CipherSuites)+",\n")
	if this.TlsCertificates != nil {
		s = append(s, "TlsCertificates: "+fmt.Sprintf("%#v", this.TlsCertificates)+",\n")
	}
	s = append(s, "TrustedCaUrl: "+fmt.Sprintf("%#v", this.TrustedCaUrl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UseragentType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&schema.UseragentType{")
	s = append(s, "ProgramName: "+fmt.Sprintf("%#v", this.ProgramName)+",\n")
	s = append(s, "HostName: "+fmt.Sprintf("%#v", this.HostName)+",\n")
	s = append(s, "ServiceName: "+fmt.Sprintf("%#v", this.ServiceName)+",\n")
	s = append(s, "SiteName: "+fmt.Sprintf("%#v", this.SiteName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ServiceParameters) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.ServiceParameters{")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "Ctype: "+fmt.Sprintf("%#v", this.Ctype)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OperMetaType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&schema.OperMetaType{")
	s = append(s, "Tenant: "+fmt.Sprintf("%#v", this.Tenant)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	if this.CreationTimestamp != nil {
		s = append(s, "CreationTimestamp: "+fmt.Sprintf("%#v", this.CreationTimestamp)+",\n")
	}
	if this.ModificationTimestamp != nil {
		s = append(s, "ModificationTimestamp: "+fmt.Sprintf("%#v", this.ModificationTimestamp)+",\n")
	}
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%#v: %#v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	if this.Annotations != nil {
		s = append(s, "Annotations: "+mapStringForAnnotations+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DaemonEnvironmentType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&schema.DaemonEnvironmentType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "InternalDnsSuffix: "+fmt.Sprintf("%#v", this.InternalDnsSuffix)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SyncServerParamsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&schema.SyncServerParamsType{")
	if this.SyncServerList != nil {
		s = append(s, "SyncServerList: "+fmt.Sprintf("%#v", this.SyncServerList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringPvtTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *DaemonTLSParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaemonTLSParamsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaemonTLSParamsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClientParams != nil {
		{
			size, err := m.ClientParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPvtTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ServerParams != nil {
		{
			size, err := m.ServerParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPvtTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DaemonTlsCertificateType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaemonTlsCertificateType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaemonTlsCertificateType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PrivateKeyUrl) > 0 {
		i -= len(m.PrivateKeyUrl)
		copy(dAtA[i:], m.PrivateKeyUrl)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.PrivateKeyUrl)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CertificateUrl) > 0 {
		i -= len(m.CertificateUrl)
		copy(dAtA[i:], m.CertificateUrl)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.CertificateUrl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DaemonTlsParametersType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaemonTlsParametersType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaemonTlsParametersType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TrustedCaUrl) > 0 {
		i -= len(m.TrustedCaUrl)
		copy(dAtA[i:], m.TrustedCaUrl)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.TrustedCaUrl)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TlsCertificates) > 0 {
		for iNdEx := len(m.TlsCertificates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TlsCertificates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPvtTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.CipherSuites) > 0 {
		for iNdEx := len(m.CipherSuites) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CipherSuites[iNdEx])
			copy(dAtA[i:], m.CipherSuites[iNdEx])
			i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.CipherSuites[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.MaximumProtocolVersion != 0 {
		i = encodeVarintPvtTypes(dAtA, i, uint64(m.MaximumProtocolVersion))
		i--
		dAtA[i] = 0x10
	}
	if m.MinimumProtocolVersion != 0 {
		i = encodeVarintPvtTypes(dAtA, i, uint64(m.MinimumProtocolVersion))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UseragentType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UseragentType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UseragentType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SiteName) > 0 {
		i -= len(m.SiteName)
		copy(dAtA[i:], m.SiteName)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.SiteName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ServiceName) > 0 {
		i -= len(m.ServiceName)
		copy(dAtA[i:], m.ServiceName)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.ServiceName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.HostName) > 0 {
		i -= len(m.HostName)
		copy(dAtA[i:], m.HostName)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.HostName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProgramName) > 0 {
		i -= len(m.ProgramName)
		copy(dAtA[i:], m.ProgramName)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.ProgramName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ctype != 0 {
		i = encodeVarintPvtTypes(dAtA, i, uint64(m.Ctype))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OperMetaType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperMetaType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperMetaType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Annotations) > 0 {
		keysForAnnotations := make([]string, 0, len(m.Annotations))
		for k := range m.Annotations {
			keysForAnnotations = append(keysForAnnotations, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
		for iNdEx := len(keysForAnnotations) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Annotations[string(keysForAnnotations[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintPvtTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForAnnotations[iNdEx])
			copy(dAtA[i:], keysForAnnotations[iNdEx])
			i = encodeVarintPvtTypes(dAtA, i, uint64(len(keysForAnnotations[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPvtTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.ModificationTimestamp != nil {
		{
			size, err := m.ModificationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPvtTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.CreationTimestamp != nil {
		{
			size, err := m.CreationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPvtTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Tenant) > 0 {
		i -= len(m.Tenant)
		copy(dAtA[i:], m.Tenant)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.Tenant)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DaemonEnvironmentType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DaemonEnvironmentType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DaemonEnvironmentType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InternalDnsSuffix) > 0 {
		i -= len(m.InternalDnsSuffix)
		copy(dAtA[i:], m.InternalDnsSuffix)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.InternalDnsSuffix)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPvtTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SyncServerParamsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncServerParamsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncServerParamsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SyncServerList) > 0 {
		for iNdEx := len(m.SyncServerList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SyncServerList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPvtTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintPvtTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovPvtTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DaemonTLSParamsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ServerParams != nil {
		l = m.ServerParams.Size()
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	if m.ClientParams != nil {
		l = m.ClientParams.Size()
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	return n
}

func (m *DaemonTlsCertificateType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CertificateUrl)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.PrivateKeyUrl)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	return n
}

func (m *DaemonTlsParametersType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinimumProtocolVersion != 0 {
		n += 1 + sovPvtTypes(uint64(m.MinimumProtocolVersion))
	}
	if m.MaximumProtocolVersion != 0 {
		n += 1 + sovPvtTypes(uint64(m.MaximumProtocolVersion))
	}
	if len(m.CipherSuites) > 0 {
		for _, s := range m.CipherSuites {
			l = len(s)
			n += 1 + l + sovPvtTypes(uint64(l))
		}
	}
	if len(m.TlsCertificates) > 0 {
		for _, e := range m.TlsCertificates {
			l = e.Size()
			n += 1 + l + sovPvtTypes(uint64(l))
		}
	}
	l = len(m.TrustedCaUrl)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	return n
}

func (m *UseragentType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProgramName)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.SiteName)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	return n
}

func (m *ServiceParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	if m.Ctype != 0 {
		n += 1 + sovPvtTypes(uint64(m.Ctype))
	}
	return n
}

func (m *OperMetaType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	if m.CreationTimestamp != nil {
		l = m.CreationTimestamp.Size()
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	if m.ModificationTimestamp != nil {
		l = m.ModificationTimestamp.Size()
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPvtTypes(uint64(len(k))) + 1 + len(v) + sovPvtTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovPvtTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DaemonEnvironmentType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	l = len(m.InternalDnsSuffix)
	if l > 0 {
		n += 1 + l + sovPvtTypes(uint64(l))
	}
	return n
}

func (m *SyncServerParamsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SyncServerList) > 0 {
		for _, e := range m.SyncServerList {
			l = e.Size()
			n += 1 + l + sovPvtTypes(uint64(l))
		}
	}
	return n
}

func sovPvtTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPvtTypes(x uint64) (n int) {
	return sovPvtTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *DaemonTLSParamsType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DaemonTLSParamsType{`,
		`ServerParams:` + strings.Replace(this.ServerParams.String(), "DaemonTlsParametersType", "DaemonTlsParametersType", 1) + `,`,
		`ClientParams:` + strings.Replace(this.ClientParams.String(), "DaemonTlsParametersType", "DaemonTlsParametersType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DaemonTlsCertificateType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DaemonTlsCertificateType{`,
		`CertificateUrl:` + fmt.Sprintf("%v", this.CertificateUrl) + `,`,
		`PrivateKeyUrl:` + fmt.Sprintf("%v", this.PrivateKeyUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DaemonTlsParametersType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTlsCertificates := "[]*DaemonTlsCertificateType{"
	for _, f := range this.TlsCertificates {
		repeatedStringForTlsCertificates += strings.Replace(f.String(), "DaemonTlsCertificateType", "DaemonTlsCertificateType", 1) + ","
	}
	repeatedStringForTlsCertificates += "}"
	s := strings.Join([]string{`&DaemonTlsParametersType{`,
		`MinimumProtocolVersion:` + fmt.Sprintf("%v", this.MinimumProtocolVersion) + `,`,
		`MaximumProtocolVersion:` + fmt.Sprintf("%v", this.MaximumProtocolVersion) + `,`,
		`CipherSuites:` + fmt.Sprintf("%v", this.CipherSuites) + `,`,
		`TlsCertificates:` + repeatedStringForTlsCertificates + `,`,
		`TrustedCaUrl:` + fmt.Sprintf("%v", this.TrustedCaUrl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UseragentType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UseragentType{`,
		`ProgramName:` + fmt.Sprintf("%v", this.ProgramName) + `,`,
		`HostName:` + fmt.Sprintf("%v", this.HostName) + `,`,
		`ServiceName:` + fmt.Sprintf("%v", this.ServiceName) + `,`,
		`SiteName:` + fmt.Sprintf("%v", this.SiteName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ServiceParameters) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceParameters{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`Ctype:` + fmt.Sprintf("%v", this.Ctype) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OperMetaType) String() string {
	if this == nil {
		return "nil"
	}
	keysForAnnotations := make([]string, 0, len(this.Annotations))
	for k, _ := range this.Annotations {
		keysForAnnotations = append(keysForAnnotations, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForAnnotations)
	mapStringForAnnotations := "map[string]string{"
	for _, k := range keysForAnnotations {
		mapStringForAnnotations += fmt.Sprintf("%v: %v,", k, this.Annotations[k])
	}
	mapStringForAnnotations += "}"
	s := strings.Join([]string{`&OperMetaType{`,
		`Tenant:` + fmt.Sprintf("%v", this.Tenant) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`CreationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.CreationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`ModificationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ModificationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`Annotations:` + mapStringForAnnotations + `,`,
		`}`,
	}, "")
	return s
}
func (this *DaemonEnvironmentType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DaemonEnvironmentType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`InternalDnsSuffix:` + fmt.Sprintf("%v", this.InternalDnsSuffix) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SyncServerParamsType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSyncServerList := "[]*ServiceParameters{"
	for _, f := range this.SyncServerList {
		repeatedStringForSyncServerList += strings.Replace(f.String(), "ServiceParameters", "ServiceParameters", 1) + ","
	}
	repeatedStringForSyncServerList += "}"
	s := strings.Join([]string{`&SyncServerParamsType{`,
		`SyncServerList:` + repeatedStringForSyncServerList + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringPvtTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *DaemonTLSParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaemonTLSParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaemonTLSParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerParams == nil {
				m.ServerParams = &DaemonTlsParametersType{}
			}
			if err := m.ServerParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientParams == nil {
				m.ClientParams = &DaemonTlsParametersType{}
			}
			if err := m.ClientParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaemonTlsCertificateType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaemonTlsCertificateType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaemonTlsCertificateType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificateUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertificateUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKeyUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateKeyUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaemonTlsParametersType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaemonTlsParametersType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaemonTlsParametersType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumProtocolVersion", wireType)
			}
			m.MinimumProtocolVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumProtocolVersion |= TlsProtocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumProtocolVersion", wireType)
			}
			m.MaximumProtocolVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumProtocolVersion |= TlsProtocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherSuites", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CipherSuites = append(m.CipherSuites, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsCertificates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsCertificates = append(m.TlsCertificates, &DaemonTlsCertificateType{})
			if err := m.TlsCertificates[len(m.TlsCertificates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCaUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedCaUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UseragentType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UseragentType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UseragentType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctype", wireType)
			}
			m.Ctype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctype |= ServiceConnectionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperMetaType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperMetaType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperMetaType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTimestamp == nil {
				m.CreationTimestamp = &types.Timestamp{}
			}
			if err := m.CreationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModificationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModificationTimestamp == nil {
				m.ModificationTimestamp = &types.Timestamp{}
			}
			if err := m.ModificationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPvtTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPvtTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPvtTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPvtTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPvtTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPvtTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPvtTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPvtTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPvtTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaemonEnvironmentType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaemonEnvironmentType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaemonEnvironmentType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalDnsSuffix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InternalDnsSuffix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncServerParamsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncServerParamsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncServerParamsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncServerList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvtTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SyncServerList = append(m.SyncServerList, &ServiceParameters{})
			if err := m.SyncServerList[len(m.SyncServerList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvtTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPvtTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPvtTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPvtTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPvtTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPvtTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPvtTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPvtTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPvtTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPvtTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPvtTypes = fmt.Errorf("proto: unexpected end of group")
)
