// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/dos_mitigation/types.proto

package dos_mitigation

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	policy "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/policy"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Type
//
// x-displayName: "DoS Mitigation Type"
// DoS Mitigation can either be manually added by a user (SRE), or can be automatically generated based on
type Type int32

const (
	// x-displayName: "Manual Mitigation"
	// MITIGATION_MANUAL
	MITIGATION_MANUAL Type = 0
	// x-displayName: "Auto-Mitigation"
	// MITIGATION_AUTOMATIC
	MITIGATION_AUTOMATIC Type = 1
)

var Type_name = map[int32]string{
	0: "MITIGATION_MANUAL",
	1: "MITIGATION_AUTOMATIC",
}

var Type_value = map[string]int32{
	"MITIGATION_MANUAL":    0,
	"MITIGATION_AUTOMATIC": 1,
}

func (Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a812e8894b362209, []int{0}
}

// Destination
//
// x-displayName: "Destination Object"
// A reference to the object on which the DoS Attack is going to be mitigated
type Destination struct {
	// virtual_host
	//
	// x-displayName: "Virtual Host"
	// x-required
	// Virtual Host on which mitigation is to occur
	VirtualHost []*schema.ObjectRefType `protobuf:"bytes,3,rep,name=virtual_host,json=virtualHost,proto3" json:"virtual_host,omitempty"`
}

func (m *Destination) Reset()      { *m = Destination{} }
func (*Destination) ProtoMessage() {}
func (*Destination) Descriptor() ([]byte, []int) {
	return fileDescriptor_a812e8894b362209, []int{0}
}
func (m *Destination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Destination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Destination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Destination.Merge(m, src)
}
func (m *Destination) XXX_Size() int {
	return m.Size()
}
func (m *Destination) XXX_DiscardUnknown() {
	xxx_messageInfo_Destination.DiscardUnknown(m)
}

var xxx_messageInfo_Destination proto.InternalMessageInfo

func (m *Destination) GetVirtualHost() []*schema.ObjectRefType {
	if m != nil {
		return m.VirtualHost
	}
	return nil
}

// GlobalSpecType
//
// x-displayName: "DoS Mitigation Specification"
type GlobalSpecType struct {
	// type
	//
	// x-displayName: "Type"
	// The type of mitigation rule (default: manually created)
	Type Type `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.dos_mitigation.Type" json:"type,omitempty"`
	// destination
	//
	// x-displayName: "Destination"
	// x-required
	// Destination object on which mitigation is to occur
	Destination *Destination `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
	// expiration
	//
	// x-displayName: "Expiration"
	// x-required
	// Configures how long will this mitigation stay active before being automatically deleted from the system
	//
	// Types that are valid to be assigned to Expiration:
	//	*GlobalSpecType_ExpirationNever
	//	*GlobalSpecType_ExpirationTtl
	//	*GlobalSpecType_ExpirationTimestamp
	Expiration isGlobalSpecType_Expiration `protobuf_oneof:"expiration"`
	// ip_prefixes
	//
	// x-displayName: "IP Prefixes"
	// x-example: "[192.168.1.0/24, 192.168.2.0/24, 4c6f:5ce7:df51:97f2:1619:ffff:b9f3:da35/126]"
	// IP Address prefix in string format. String must contain both prefix and prefix-length.
	// Accepts both IPv4 and IPv6 prefixes.
	IpPrefixes []string `protobuf:"bytes,7,rep,name=ip_prefixes,json=ipPrefixes,proto3" json:"ip_prefixes,omitempty"`
	// countries
	//
	// x-displayName: "Country List"
	// Sources that are located in one of the countries in the given list
	Countries []policy.CountryCode `protobuf:"varint,8,rep,packed,name=countries,proto3,enum=ves.io.schema.policy.CountryCode" json:"countries,omitempty"`
	// as numbers
	//
	// x-displayName: "AS Numbers"
	// x-example: "[713, 7932, 847325, 4683, 15269, 1000001]"
	// x-required
	// An unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy.
	AsNumbers []uint32 `protobuf:"varint,9,rep,packed,name=as_numbers,json=asNumbers,proto3" json:"as_numbers,omitempty"`
	// tls_fingerprints
	//
	// x-displayName: "TLS Fingerprints"
	// x-example: "1aa7bf8b97e540ca5edd75f7b8384bfa"
	// A list of exact TLS JA3 fingerprints to match the input TLS JA3 fingerprint against
	TlsFingerprints []string `protobuf:"bytes,10,rep,name=tls_fingerprints,json=tlsFingerprints,proto3" json:"tls_fingerprints,omitempty"`
	// paths
	//
	// x-displayName: "Paths"
	// x-example: "['/api/web/namespaces/project179/users/user1', '/api/config/namespaces/accounting/bgps', '/api/data/namespaces/project443/virtual_host_101']"
	// A list of exact path values to match the input HTTP path against
	Paths []string `protobuf:"bytes,11,rep,name=paths,proto3" json:"paths,omitempty"`
	// ja4_tls_fingerprints
	//
	// x-displayName: "JA4 TLS Fingerprints"
	// x-example: "t13d1516h2_8daaf6152771_199a283f251c"
	// A list of exact TLS JA4 fingerprints to match the input TLS JA4 fingerprint against
	Ja4TlsFingerprints []string `protobuf:"bytes,12,rep,name=ja4_tls_fingerprints,json=ja4TlsFingerprints,proto3" json:"ja4_tls_fingerprints,omitempty"`
	// throttling
	//
	// x-displayName: "Throttling"
	// When configured, traffic to the virtual host will be throttled
	Throttling *schema.Empty `protobuf:"bytes,13,opt,name=throttling,proto3" json:"throttling,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_a812e8894b362209, []int{1}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_Expiration interface {
	isGlobalSpecType_Expiration()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_ExpirationNever struct {
	ExpirationNever *schema.Empty `protobuf:"bytes,4,opt,name=expiration_never,json=expirationNever,proto3,oneof" json:"expiration_never,omitempty"`
}
type GlobalSpecType_ExpirationTtl struct {
	ExpirationTtl uint32 `protobuf:"varint,5,opt,name=expiration_ttl,json=expirationTtl,proto3,oneof" json:"expiration_ttl,omitempty"`
}
type GlobalSpecType_ExpirationTimestamp struct {
	ExpirationTimestamp *types.Timestamp `protobuf:"bytes,6,opt,name=expiration_timestamp,json=expirationTimestamp,proto3,oneof" json:"expiration_timestamp,omitempty"`
}

func (*GlobalSpecType_ExpirationNever) isGlobalSpecType_Expiration()     {}
func (*GlobalSpecType_ExpirationTtl) isGlobalSpecType_Expiration()       {}
func (*GlobalSpecType_ExpirationTimestamp) isGlobalSpecType_Expiration() {}

func (m *GlobalSpecType) GetExpiration() isGlobalSpecType_Expiration {
	if m != nil {
		return m.Expiration
	}
	return nil
}

func (m *GlobalSpecType) GetType() Type {
	if m != nil {
		return m.Type
	}
	return MITIGATION_MANUAL
}

func (m *GlobalSpecType) GetDestination() *Destination {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *GlobalSpecType) GetExpirationNever() *schema.Empty {
	if x, ok := m.GetExpiration().(*GlobalSpecType_ExpirationNever); ok {
		return x.ExpirationNever
	}
	return nil
}

func (m *GlobalSpecType) GetExpirationTtl() uint32 {
	if x, ok := m.GetExpiration().(*GlobalSpecType_ExpirationTtl); ok {
		return x.ExpirationTtl
	}
	return 0
}

func (m *GlobalSpecType) GetExpirationTimestamp() *types.Timestamp {
	if x, ok := m.GetExpiration().(*GlobalSpecType_ExpirationTimestamp); ok {
		return x.ExpirationTimestamp
	}
	return nil
}

func (m *GlobalSpecType) GetIpPrefixes() []string {
	if m != nil {
		return m.IpPrefixes
	}
	return nil
}

func (m *GlobalSpecType) GetCountries() []policy.CountryCode {
	if m != nil {
		return m.Countries
	}
	return nil
}

func (m *GlobalSpecType) GetAsNumbers() []uint32 {
	if m != nil {
		return m.AsNumbers
	}
	return nil
}

func (m *GlobalSpecType) GetTlsFingerprints() []string {
	if m != nil {
		return m.TlsFingerprints
	}
	return nil
}

func (m *GlobalSpecType) GetPaths() []string {
	if m != nil {
		return m.Paths
	}
	return nil
}

func (m *GlobalSpecType) GetJa4TlsFingerprints() []string {
	if m != nil {
		return m.Ja4TlsFingerprints
	}
	return nil
}

func (m *GlobalSpecType) GetThrottling() *schema.Empty {
	if m != nil {
		return m.Throttling
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_ExpirationNever)(nil),
		(*GlobalSpecType_ExpirationTtl)(nil),
		(*GlobalSpecType_ExpirationTimestamp)(nil),
	}
}

// Create DoS Mitigation
//
// x-displayName: "Create DoS Mitigation"
// Create DoS Mitigation
type CreateSpecType struct {
	Type        Type         `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.dos_mitigation.Type" json:"type,omitempty"`
	Destination *Destination `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
	// Types that are valid to be assigned to Expiration:
	//	*CreateSpecType_ExpirationNever
	//	*CreateSpecType_ExpirationTtl
	//	*CreateSpecType_ExpirationTimestamp
	Expiration      isCreateSpecType_Expiration `protobuf_oneof:"expiration"`
	IpPrefixes      []string                    `protobuf:"bytes,7,rep,name=ip_prefixes,json=ipPrefixes,proto3" json:"ip_prefixes,omitempty"`
	Countries       []policy.CountryCode        `protobuf:"varint,8,rep,packed,name=countries,proto3,enum=ves.io.schema.policy.CountryCode" json:"countries,omitempty"`
	AsNumbers       []uint32                    `protobuf:"varint,9,rep,packed,name=as_numbers,json=asNumbers,proto3" json:"as_numbers,omitempty"`
	TlsFingerprints []string                    `protobuf:"bytes,10,rep,name=tls_fingerprints,json=tlsFingerprints,proto3" json:"tls_fingerprints,omitempty"`
	Paths           []string                    `protobuf:"bytes,11,rep,name=paths,proto3" json:"paths,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_a812e8894b362209, []int{2}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_Expiration interface {
	isCreateSpecType_Expiration()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_ExpirationNever struct {
	ExpirationNever *schema.Empty `protobuf:"bytes,4,opt,name=expiration_never,json=expirationNever,proto3,oneof" json:"expiration_never,omitempty"`
}
type CreateSpecType_ExpirationTtl struct {
	ExpirationTtl uint32 `protobuf:"varint,5,opt,name=expiration_ttl,json=expirationTtl,proto3,oneof" json:"expiration_ttl,omitempty"`
}
type CreateSpecType_ExpirationTimestamp struct {
	ExpirationTimestamp *types.Timestamp `protobuf:"bytes,6,opt,name=expiration_timestamp,json=expirationTimestamp,proto3,oneof" json:"expiration_timestamp,omitempty"`
}

func (*CreateSpecType_ExpirationNever) isCreateSpecType_Expiration()     {}
func (*CreateSpecType_ExpirationTtl) isCreateSpecType_Expiration()       {}
func (*CreateSpecType_ExpirationTimestamp) isCreateSpecType_Expiration() {}

func (m *CreateSpecType) GetExpiration() isCreateSpecType_Expiration {
	if m != nil {
		return m.Expiration
	}
	return nil
}

func (m *CreateSpecType) GetType() Type {
	if m != nil {
		return m.Type
	}
	return MITIGATION_MANUAL
}

func (m *CreateSpecType) GetDestination() *Destination {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *CreateSpecType) GetExpirationNever() *schema.Empty {
	if x, ok := m.GetExpiration().(*CreateSpecType_ExpirationNever); ok {
		return x.ExpirationNever
	}
	return nil
}

func (m *CreateSpecType) GetExpirationTtl() uint32 {
	if x, ok := m.GetExpiration().(*CreateSpecType_ExpirationTtl); ok {
		return x.ExpirationTtl
	}
	return 0
}

func (m *CreateSpecType) GetExpirationTimestamp() *types.Timestamp {
	if x, ok := m.GetExpiration().(*CreateSpecType_ExpirationTimestamp); ok {
		return x.ExpirationTimestamp
	}
	return nil
}

func (m *CreateSpecType) GetIpPrefixes() []string {
	if m != nil {
		return m.IpPrefixes
	}
	return nil
}

func (m *CreateSpecType) GetCountries() []policy.CountryCode {
	if m != nil {
		return m.Countries
	}
	return nil
}

func (m *CreateSpecType) GetAsNumbers() []uint32 {
	if m != nil {
		return m.AsNumbers
	}
	return nil
}

func (m *CreateSpecType) GetTlsFingerprints() []string {
	if m != nil {
		return m.TlsFingerprints
	}
	return nil
}

func (m *CreateSpecType) GetPaths() []string {
	if m != nil {
		return m.Paths
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_ExpirationNever)(nil),
		(*CreateSpecType_ExpirationTtl)(nil),
		(*CreateSpecType_ExpirationTimestamp)(nil),
	}
}

// Replace DoS Mitigation
//
// x-displayName: "Replace DoS Mitigation"
// Replace DoS Mitigation
type ReplaceSpecType struct {
	// --- No type in replacement, this can only be set on creation! --- Type type = 1;
	Destination *Destination `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
	// Types that are valid to be assigned to Expiration:
	//	*ReplaceSpecType_ExpirationNever
	//	*ReplaceSpecType_ExpirationTtl
	//	*ReplaceSpecType_ExpirationTimestamp
	Expiration      isReplaceSpecType_Expiration `protobuf_oneof:"expiration"`
	IpPrefixes      []string                     `protobuf:"bytes,7,rep,name=ip_prefixes,json=ipPrefixes,proto3" json:"ip_prefixes,omitempty"`
	Countries       []policy.CountryCode         `protobuf:"varint,8,rep,packed,name=countries,proto3,enum=ves.io.schema.policy.CountryCode" json:"countries,omitempty"`
	AsNumbers       []uint32                     `protobuf:"varint,9,rep,packed,name=as_numbers,json=asNumbers,proto3" json:"as_numbers,omitempty"`
	TlsFingerprints []string                     `protobuf:"bytes,10,rep,name=tls_fingerprints,json=tlsFingerprints,proto3" json:"tls_fingerprints,omitempty"`
	Paths           []string                     `protobuf:"bytes,11,rep,name=paths,proto3" json:"paths,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_a812e8894b362209, []int{3}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_Expiration interface {
	isReplaceSpecType_Expiration()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_ExpirationNever struct {
	ExpirationNever *schema.Empty `protobuf:"bytes,4,opt,name=expiration_never,json=expirationNever,proto3,oneof" json:"expiration_never,omitempty"`
}
type ReplaceSpecType_ExpirationTtl struct {
	ExpirationTtl uint32 `protobuf:"varint,5,opt,name=expiration_ttl,json=expirationTtl,proto3,oneof" json:"expiration_ttl,omitempty"`
}
type ReplaceSpecType_ExpirationTimestamp struct {
	ExpirationTimestamp *types.Timestamp `protobuf:"bytes,6,opt,name=expiration_timestamp,json=expirationTimestamp,proto3,oneof" json:"expiration_timestamp,omitempty"`
}

func (*ReplaceSpecType_ExpirationNever) isReplaceSpecType_Expiration()     {}
func (*ReplaceSpecType_ExpirationTtl) isReplaceSpecType_Expiration()       {}
func (*ReplaceSpecType_ExpirationTimestamp) isReplaceSpecType_Expiration() {}

func (m *ReplaceSpecType) GetExpiration() isReplaceSpecType_Expiration {
	if m != nil {
		return m.Expiration
	}
	return nil
}

func (m *ReplaceSpecType) GetDestination() *Destination {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *ReplaceSpecType) GetExpirationNever() *schema.Empty {
	if x, ok := m.GetExpiration().(*ReplaceSpecType_ExpirationNever); ok {
		return x.ExpirationNever
	}
	return nil
}

func (m *ReplaceSpecType) GetExpirationTtl() uint32 {
	if x, ok := m.GetExpiration().(*ReplaceSpecType_ExpirationTtl); ok {
		return x.ExpirationTtl
	}
	return 0
}

func (m *ReplaceSpecType) GetExpirationTimestamp() *types.Timestamp {
	if x, ok := m.GetExpiration().(*ReplaceSpecType_ExpirationTimestamp); ok {
		return x.ExpirationTimestamp
	}
	return nil
}

func (m *ReplaceSpecType) GetIpPrefixes() []string {
	if m != nil {
		return m.IpPrefixes
	}
	return nil
}

func (m *ReplaceSpecType) GetCountries() []policy.CountryCode {
	if m != nil {
		return m.Countries
	}
	return nil
}

func (m *ReplaceSpecType) GetAsNumbers() []uint32 {
	if m != nil {
		return m.AsNumbers
	}
	return nil
}

func (m *ReplaceSpecType) GetTlsFingerprints() []string {
	if m != nil {
		return m.TlsFingerprints
	}
	return nil
}

func (m *ReplaceSpecType) GetPaths() []string {
	if m != nil {
		return m.Paths
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_ExpirationNever)(nil),
		(*ReplaceSpecType_ExpirationTtl)(nil),
		(*ReplaceSpecType_ExpirationTimestamp)(nil),
	}
}

// Get DoS Mitigation
//
// x-displayName: "Get DoS Mitigation"
// Get DoS Mitigation
type GetSpecType struct {
	Type        Type         `protobuf:"varint,1,opt,name=type,proto3,enum=ves.io.schema.dos_mitigation.Type" json:"type,omitempty"`
	Destination *Destination `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
	// Types that are valid to be assigned to Expiration:
	//	*GetSpecType_ExpirationNever
	//	*GetSpecType_ExpirationTtl
	//	*GetSpecType_ExpirationTimestamp
	Expiration      isGetSpecType_Expiration `protobuf_oneof:"expiration"`
	IpPrefixes      []string                 `protobuf:"bytes,7,rep,name=ip_prefixes,json=ipPrefixes,proto3" json:"ip_prefixes,omitempty"`
	Countries       []policy.CountryCode     `protobuf:"varint,8,rep,packed,name=countries,proto3,enum=ves.io.schema.policy.CountryCode" json:"countries,omitempty"`
	AsNumbers       []uint32                 `protobuf:"varint,9,rep,packed,name=as_numbers,json=asNumbers,proto3" json:"as_numbers,omitempty"`
	TlsFingerprints []string                 `protobuf:"bytes,10,rep,name=tls_fingerprints,json=tlsFingerprints,proto3" json:"tls_fingerprints,omitempty"`
	Paths           []string                 `protobuf:"bytes,11,rep,name=paths,proto3" json:"paths,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_a812e8894b362209, []int{4}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_Expiration interface {
	isGetSpecType_Expiration()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_ExpirationNever struct {
	ExpirationNever *schema.Empty `protobuf:"bytes,4,opt,name=expiration_never,json=expirationNever,proto3,oneof" json:"expiration_never,omitempty"`
}
type GetSpecType_ExpirationTtl struct {
	ExpirationTtl uint32 `protobuf:"varint,5,opt,name=expiration_ttl,json=expirationTtl,proto3,oneof" json:"expiration_ttl,omitempty"`
}
type GetSpecType_ExpirationTimestamp struct {
	ExpirationTimestamp *types.Timestamp `protobuf:"bytes,6,opt,name=expiration_timestamp,json=expirationTimestamp,proto3,oneof" json:"expiration_timestamp,omitempty"`
}

func (*GetSpecType_ExpirationNever) isGetSpecType_Expiration()     {}
func (*GetSpecType_ExpirationTtl) isGetSpecType_Expiration()       {}
func (*GetSpecType_ExpirationTimestamp) isGetSpecType_Expiration() {}

func (m *GetSpecType) GetExpiration() isGetSpecType_Expiration {
	if m != nil {
		return m.Expiration
	}
	return nil
}

func (m *GetSpecType) GetType() Type {
	if m != nil {
		return m.Type
	}
	return MITIGATION_MANUAL
}

func (m *GetSpecType) GetDestination() *Destination {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *GetSpecType) GetExpirationNever() *schema.Empty {
	if x, ok := m.GetExpiration().(*GetSpecType_ExpirationNever); ok {
		return x.ExpirationNever
	}
	return nil
}

func (m *GetSpecType) GetExpirationTtl() uint32 {
	if x, ok := m.GetExpiration().(*GetSpecType_ExpirationTtl); ok {
		return x.ExpirationTtl
	}
	return 0
}

func (m *GetSpecType) GetExpirationTimestamp() *types.Timestamp {
	if x, ok := m.GetExpiration().(*GetSpecType_ExpirationTimestamp); ok {
		return x.ExpirationTimestamp
	}
	return nil
}

func (m *GetSpecType) GetIpPrefixes() []string {
	if m != nil {
		return m.IpPrefixes
	}
	return nil
}

func (m *GetSpecType) GetCountries() []policy.CountryCode {
	if m != nil {
		return m.Countries
	}
	return nil
}

func (m *GetSpecType) GetAsNumbers() []uint32 {
	if m != nil {
		return m.AsNumbers
	}
	return nil
}

func (m *GetSpecType) GetTlsFingerprints() []string {
	if m != nil {
		return m.TlsFingerprints
	}
	return nil
}

func (m *GetSpecType) GetPaths() []string {
	if m != nil {
		return m.Paths
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_ExpirationNever)(nil),
		(*GetSpecType_ExpirationTtl)(nil),
		(*GetSpecType_ExpirationTimestamp)(nil),
	}
}

// DoS Mitigation Rule Info
//
// x-displayName: "DoS Mitigation Object"
// DoS Mitigation Object to auto-configure rules to block attackers
type DoSMitigationRuleInfo struct {
	// uid
	//
	// x-displayName: "UID"
	// x-example: "d15f1fad-4d37-48c0-8706-df1824d76d31"
	// uid is the unique in time and space value for this object. It is generated by
	// the server on successful creation of an object and is not allowed to change on Replace
	// API. The value of is taken from uid field of ObjectMetaType, if provided.
	Uid string `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// name
	//
	// x-displayName: "Name"
	// x-example: "acmecorp-web"
	// x-required
	// This is the name of configuration object. It has to be unique within the namespace.
	// It can only be specified during create API and cannot be changed during replace API.
	// The value of name has to follow DNS-1035 format.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// creation_timestamp
	//
	// x-displayName: "Creation Timestamp"
	// CreationTimestamp is a timestamp representing the server time when this object was
	// created. It is not guaranteed to be set in happens-before order across separate operations.
	// Clients may not set this value. It is represented in RFC3339 form and is in UTC.
	CreationTimestamp *types.Timestamp `protobuf:"bytes,3,opt,name=creation_timestamp,json=creationTimestamp,proto3" json:"creation_timestamp,omitempty"`
	// global_spec_type
	//
	// x-displayName: "DoS Mitigation Rule Spec"
	Item *GetSpecType `protobuf:"bytes,4,opt,name=item,proto3" json:"item,omitempty"`
}

func (m *DoSMitigationRuleInfo) Reset()      { *m = DoSMitigationRuleInfo{} }
func (*DoSMitigationRuleInfo) ProtoMessage() {}
func (*DoSMitigationRuleInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a812e8894b362209, []int{5}
}
func (m *DoSMitigationRuleInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DoSMitigationRuleInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DoSMitigationRuleInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DoSMitigationRuleInfo.Merge(m, src)
}
func (m *DoSMitigationRuleInfo) XXX_Size() int {
	return m.Size()
}
func (m *DoSMitigationRuleInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DoSMitigationRuleInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DoSMitigationRuleInfo proto.InternalMessageInfo

func (m *DoSMitigationRuleInfo) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *DoSMitigationRuleInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DoSMitigationRuleInfo) GetCreationTimestamp() *types.Timestamp {
	if m != nil {
		return m.CreationTimestamp
	}
	return nil
}

func (m *DoSMitigationRuleInfo) GetItem() *GetSpecType {
	if m != nil {
		return m.Item
	}
	return nil
}

func init() {
	proto.RegisterEnum("ves.io.schema.dos_mitigation.Type", Type_name, Type_value)
	proto.RegisterType((*Destination)(nil), "ves.io.schema.dos_mitigation.Destination")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.dos_mitigation.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.dos_mitigation.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.dos_mitigation.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.dos_mitigation.GetSpecType")
	proto.RegisterType((*DoSMitigationRuleInfo)(nil), "ves.io.schema.dos_mitigation.DoSMitigationRuleInfo")
}

func init() {
	proto.RegisterFile("ves.io/schema/dos_mitigation/types.proto", fileDescriptor_a812e8894b362209)
}

var fileDescriptor_a812e8894b362209 = []byte{
	// 1033 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0xcf, 0x6f, 0xe3, 0x44,
	0x18, 0xf5, 0xd4, 0xce, 0xb6, 0x9d, 0x6c, 0x53, 0x77, 0xc8, 0x0a, 0x13, 0x8a, 0x1b, 0x0a, 0x12,
	0xde, 0xd5, 0xd6, 0x59, 0x95, 0xd2, 0x95, 0x90, 0xf8, 0x91, 0x74, 0xa1, 0x4d, 0xa1, 0xed, 0xca,
	0x9b, 0x5e, 0xb8, 0x44, 0x4e, 0x32, 0x71, 0xa7, 0x6b, 0x7b, 0x2c, 0x7b, 0x12, 0xda, 0x03, 0x52,
	0xc5, 0x89, 0x03, 0x07, 0x54, 0x21, 0xc1, 0x9f, 0xb0, 0xe2, 0x4f, 0xa0, 0x1c, 0xf6, 0x04, 0x2b,
	0xb8, 0xf4, 0x58, 0x71, 0xa2, 0xe9, 0x05, 0x6e, 0x7b, 0x44, 0x9c, 0x90, 0x27, 0x0e, 0x19, 0xb7,
	0xd9, 0x5d, 0x09, 0x24, 0x0e, 0xd0, 0xdb, 0x7c, 0xf9, 0xde, 0x7b, 0x7e, 0x33, 0xf3, 0x3e, 0x47,
	0x86, 0x46, 0x17, 0x47, 0x26, 0xa1, 0xa5, 0xa8, 0xb9, 0x83, 0x3d, 0xbb, 0xd4, 0xa2, 0x51, 0xdd,
	0x23, 0x8c, 0x38, 0x36, 0x23, 0xd4, 0x2f, 0xb1, 0xfd, 0x00, 0x47, 0x66, 0x10, 0x52, 0x46, 0xd1,
	0x6c, 0x1f, 0x69, 0xf6, 0x91, 0x66, 0x1a, 0x59, 0x58, 0x70, 0x08, 0xdb, 0xe9, 0x34, 0xcc, 0x26,
	0xf5, 0x4a, 0x0e, 0x75, 0x68, 0x89, 0x93, 0x1a, 0x9d, 0x36, 0xaf, 0x78, 0xc1, 0x57, 0x7d, 0xb1,
	0xc2, 0x9c, 0x43, 0xa9, 0xe3, 0xe2, 0x21, 0x8a, 0x11, 0x0f, 0x47, 0xcc, 0xf6, 0x82, 0x04, 0xf0,
	0x7c, 0xda, 0x97, 0x8f, 0x59, 0xd2, 0x78, 0x31, 0xdd, 0xa0, 0x41, 0xfc, 0xf8, 0xc4, 0x63, 0xa1,
	0x98, 0x6e, 0x06, 0xd4, 0x25, 0xcd, 0x7d, 0x71, 0x17, 0x85, 0x17, 0xd2, 0x08, 0xb1, 0x35, 0x9b,
	0x6e, 0x75, 0x6d, 0x97, 0xb4, 0x6c, 0x86, 0x47, 0x4b, 0x77, 0x09, 0xfe, 0xb8, 0x9e, 0x7e, 0xf8,
	0xdc, 0x45, 0x44, 0x24, 0x3e, 0x60, 0xfe, 0x3e, 0xcc, 0xde, 0xc1, 0x11, 0x23, 0x3e, 0x3f, 0x32,
	0x74, 0x17, 0x5e, 0xed, 0x92, 0x90, 0x75, 0x6c, 0xb7, 0xbe, 0x43, 0x23, 0xa6, 0xc9, 0x45, 0xd9,
	0xc8, 0x2e, 0xce, 0x9a, 0xe9, 0x73, 0xde, 0x6a, 0xec, 0xe2, 0x26, 0xb3, 0x70, 0xbb, 0xb6, 0x1f,
	0xe0, 0xca, 0xf4, 0x37, 0x9f, 0xa4, 0x48, 0x56, 0x36, 0xa9, 0xd6, 0x68, 0xc4, 0xd6, 0x95, 0x09,
	0xa0, 0x8e, 0xad, 0x2b, 0x13, 0x63, 0xaa, 0x3c, 0xff, 0xd5, 0x38, 0xcc, 0xad, 0xba, 0xb4, 0x61,
	0xbb, 0xf7, 0x02, 0xdc, 0x8c, 0xc9, 0x68, 0x19, 0x2a, 0xb1, 0x1d, 0x0d, 0x14, 0x81, 0x91, 0x5b,
	0x9c, 0x37, 0x9f, 0x76, 0xa1, 0x66, 0xcc, 0xb0, 0x38, 0x1e, 0x7d, 0x00, 0xb3, 0xad, 0xa1, 0x6f,
	0x6d, 0xac, 0x08, 0x8c, 0xec, 0xe2, 0xf5, 0xa7, 0xd3, 0x85, 0x8d, 0x5a, 0x22, 0x1b, 0x95, 0xa1,
	0x8a, 0xf7, 0x02, 0x12, 0xf2, 0xaa, 0xee, 0xe3, 0x2e, 0x0e, 0x35, 0x85, 0x2b, 0xe6, 0xcf, 0x29,
	0xbe, 0xe7, 0x05, 0x6c, 0x7f, 0x4d, 0xb2, 0xa6, 0x87, 0xf8, 0xcd, 0x18, 0x8e, 0x56, 0x60, 0x4e,
	0x90, 0x60, 0xcc, 0xd5, 0x32, 0x45, 0x60, 0x4c, 0x55, 0x0a, 0x3f, 0x1f, 0x01, 0x79, 0xf9, 0xd6,
	0xad, 0xdf, 0x8f, 0x80, 0xf4, 0xd9, 0x77, 0x00, 0x7c, 0xfb, 0xdb, 0x43, 0xf9, 0xca, 0x0d, 0x45,
	0x3b, 0xf8, 0x1e, 0xae, 0x49, 0xd6, 0xd4, 0x90, 0x53, 0x63, 0x2e, 0xda, 0x82, 0x79, 0x51, 0x64,
	0x10, 0x3f, 0xed, 0x0a, 0xf7, 0x52, 0x30, 0xfb, 0x01, 0x35, 0x07, 0x01, 0x35, 0x6b, 0x03, 0xc4,
	0x9a, 0x64, 0x3d, 0x27, 0x48, 0x0d, 0x7e, 0x46, 0x55, 0x98, 0x25, 0x41, 0x3d, 0x08, 0x71, 0x9b,
	0xec, 0xe1, 0x48, 0x1b, 0x2f, 0xca, 0xc6, 0x64, 0xc5, 0x88, 0xbd, 0xc4, 0x3e, 0xe0, 0x21, 0x18,
	0x9f, 0xcf, 0x84, 0xf2, 0x83, 0xc4, 0xd6, 0x21, 0x90, 0xd5, 0x83, 0x89, 0x78, 0x99, 0x39, 0x04,
	0x63, 0x1a, 0xb0, 0x20, 0x09, 0xee, 0x26, 0x5c, 0xb4, 0x0d, 0x27, 0x9b, 0xb4, 0xe3, 0xb3, 0x90,
	0xe0, 0x48, 0x9b, 0x28, 0xca, 0x46, 0x6e, 0xf1, 0xe5, 0x73, 0x87, 0xd3, 0x8f, 0xb6, 0xb9, 0xc2,
	0x61, 0xfb, 0x2b, 0xb4, 0x85, 0x2b, 0xf9, 0x81, 0x9a, 0xfa, 0xae, 0xa0, 0x3b, 0x54, 0x42, 0xb7,
	0x21, 0xb4, 0xa3, 0xba, 0xdf, 0xf1, 0x1a, 0x38, 0x8c, 0xb4, 0xc9, 0xa2, 0x6c, 0x4c, 0x55, 0xb4,
	0x81, 0xc1, 0x8b, 0x44, 0x3b, 0xda, 0xec, 0x43, 0xd1, 0x26, 0x54, 0x99, 0x1b, 0xd5, 0xdb, 0xc4,
	0x77, 0x70, 0x18, 0x84, 0xc4, 0x67, 0x91, 0x06, 0xf9, 0xfe, 0x5e, 0x11, 0xf7, 0xf6, 0x35, 0x28,
	0x8e, 0x54, 0x9a, 0x66, 0x6e, 0xf4, 0xbe, 0xc0, 0x45, 0x6b, 0x30, 0x13, 0xd8, 0x6c, 0x27, 0xd2,
	0xb2, 0x5c, 0x64, 0x51, 0x14, 0x31, 0x0e, 0xc6, 0xc4, 0xf2, 0xa4, 0x7f, 0x5e, 0x5c, 0x53, 0x15,
	0x34, 0xfb, 0x02, 0x68, 0x1b, 0xe6, 0x77, 0xed, 0xa5, 0xfa, 0x05, 0x77, 0x57, 0x47, 0xb9, 0x7b,
	0x75, 0xa4, 0x3b, 0xb4, 0x6b, 0x2f, 0xd5, 0xce, 0x19, 0x5c, 0x82, 0x90, 0xed, 0x84, 0x94, 0x31,
	0x97, 0xf8, 0x8e, 0x36, 0xf5, 0xe4, 0x78, 0x5a, 0x02, 0xae, 0x32, 0x07, 0xe1, 0x30, 0x18, 0x68,
	0xe6, 0xe1, 0x11, 0xc8, 0x1c, 0x1f, 0x01, 0xb9, 0x77, 0x04, 0x32, 0x4b, 0x37, 0xdf, 0xb8, 0xb9,
	0xbc, 0xae, 0x4c, 0xc8, 0xaa, 0x32, 0xff, 0x93, 0x02, 0x73, 0x2b, 0x21, 0xb6, 0x19, 0xfe, 0xcf,
	0x4d, 0xe6, 0x6b, 0xa3, 0x27, 0xf3, 0x5f, 0x98, 0xbe, 0xb9, 0x11, 0xd3, 0x97, 0x9a, 0xa9, 0x77,
	0xfe, 0xce, 0x4c, 0x89, 0xd3, 0xf3, 0xd2, 0xc5, 0xe9, 0x11, 0x67, 0xe4, 0xfa, 0x93, 0x66, 0xe4,
	0x62, 0xfc, 0xf3, 0xa9, 0xf8, 0x27, 0x51, 0x7e, 0x73, 0xe6, 0xc7, 0xb7, 0xcf, 0xbd, 0xb0, 0x2b,
	0xb3, 0xa9, 0x40, 0xe5, 0x3e, 0xfd, 0x03, 0x08, 0x75, 0x92, 0xa6, 0x2f, 0x15, 0x38, 0x6d, 0xe1,
	0xc0, 0xb5, 0x9b, 0xc3, 0x38, 0x5d, 0xc6, 0xe2, 0x7f, 0x1f, 0x8b, 0x47, 0x0a, 0xcc, 0xae, 0x62,
	0x76, 0xf9, 0x86, 0xb9, 0x8c, 0xd2, 0x3f, 0x8d, 0xd2, 0x0f, 0x00, 0x5e, 0xbb, 0x43, 0xef, 0x6d,
	0xfc, 0x75, 0xc1, 0x56, 0xc7, 0xc5, 0x55, 0xbf, 0x4d, 0x91, 0x0a, 0xe5, 0x0e, 0x69, 0xf1, 0x4c,
	0x4d, 0x5a, 0xf1, 0x12, 0x21, 0xa8, 0xf8, 0xb6, 0x87, 0x79, 0x4e, 0x26, 0x2d, 0xbe, 0x46, 0x55,
	0x88, 0x9a, 0xf1, 0xdf, 0x5d, 0xfa, 0x1e, 0xe4, 0x67, 0xdd, 0x83, 0x35, 0x33, 0x60, 0x0d, 0xef,
	0xe0, 0x2d, 0xa8, 0x10, 0x86, 0xbd, 0x24, 0x34, 0xcf, 0x88, 0xa1, 0x10, 0x7f, 0x8b, 0xd3, 0x6e,
	0xdc, 0x86, 0x0a, 0x1f, 0x86, 0x6b, 0x70, 0x66, 0xa3, 0x5a, 0xab, 0xae, 0x96, 0x6b, 0xd5, 0xad,
	0xcd, 0xfa, 0x46, 0x79, 0x73, 0xbb, 0xfc, 0xa1, 0x2a, 0x21, 0x0d, 0xe6, 0x85, 0x9f, 0xcb, 0xdb,
	0xb5, 0xad, 0x8d, 0x72, 0xad, 0xba, 0xa2, 0x82, 0xca, 0xe7, 0xe0, 0xf8, 0x54, 0x97, 0x4e, 0x4e,
	0x75, 0xe9, 0xf1, 0xa9, 0x0e, 0x0e, 0x7a, 0x3a, 0x78, 0xd0, 0xd3, 0xc1, 0xa3, 0x9e, 0x0e, 0x8e,
	0x7b, 0x3a, 0x38, 0xe9, 0xe9, 0xe0, 0x97, 0x9e, 0x0e, 0x7e, 0xed, 0xe9, 0xd2, 0xe3, 0x9e, 0x0e,
	0xbe, 0x38, 0xd3, 0xa5, 0xe3, 0x33, 0x5d, 0x3a, 0x39, 0xd3, 0xa5, 0x8f, 0x2c, 0x87, 0x06, 0xf7,
	0x1d, 0xb3, 0x4b, 0x5d, 0x86, 0xc3, 0xd0, 0x36, 0x3b, 0x51, 0x89, 0x2f, 0xda, 0x34, 0xf4, 0x16,
	0x82, 0x90, 0x76, 0x49, 0x0b, 0x87, 0x0b, 0x83, 0x76, 0x29, 0x68, 0x38, 0xb4, 0x84, 0xf7, 0x58,
	0xf2, 0x11, 0x31, 0xf2, 0xb3, 0xac, 0x71, 0x85, 0x9f, 0xd6, 0xeb, 0x7f, 0x06, 0x00, 0x00, 0xff,
	0xff, 0x6f, 0xb9, 0xac, 0xcc, 0xbd, 0x0d, 0x00, 0x00,
}

func (x Type) String() string {
	s, ok := Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Destination) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Destination)
	if !ok {
		that2, ok := that.(Destination)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.VirtualHost) != len(that1.VirtualHost) {
		return false
	}
	for i := range this.VirtualHost {
		if !this.VirtualHost[i].Equal(that1.VirtualHost[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.Destination.Equal(that1.Destination) {
		return false
	}
	if that1.Expiration == nil {
		if this.Expiration != nil {
			return false
		}
	} else if this.Expiration == nil {
		return false
	} else if !this.Expiration.Equal(that1.Expiration) {
		return false
	}
	if len(this.IpPrefixes) != len(that1.IpPrefixes) {
		return false
	}
	for i := range this.IpPrefixes {
		if this.IpPrefixes[i] != that1.IpPrefixes[i] {
			return false
		}
	}
	if len(this.Countries) != len(that1.Countries) {
		return false
	}
	for i := range this.Countries {
		if this.Countries[i] != that1.Countries[i] {
			return false
		}
	}
	if len(this.AsNumbers) != len(that1.AsNumbers) {
		return false
	}
	for i := range this.AsNumbers {
		if this.AsNumbers[i] != that1.AsNumbers[i] {
			return false
		}
	}
	if len(this.TlsFingerprints) != len(that1.TlsFingerprints) {
		return false
	}
	for i := range this.TlsFingerprints {
		if this.TlsFingerprints[i] != that1.TlsFingerprints[i] {
			return false
		}
	}
	if len(this.Paths) != len(that1.Paths) {
		return false
	}
	for i := range this.Paths {
		if this.Paths[i] != that1.Paths[i] {
			return false
		}
	}
	if len(this.Ja4TlsFingerprints) != len(that1.Ja4TlsFingerprints) {
		return false
	}
	for i := range this.Ja4TlsFingerprints {
		if this.Ja4TlsFingerprints[i] != that1.Ja4TlsFingerprints[i] {
			return false
		}
	}
	if !this.Throttling.Equal(that1.Throttling) {
		return false
	}
	return true
}
func (this *GlobalSpecType_ExpirationNever) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ExpirationNever)
	if !ok {
		that2, ok := that.(GlobalSpecType_ExpirationNever)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExpirationNever.Equal(that1.ExpirationNever) {
		return false
	}
	return true
}
func (this *GlobalSpecType_ExpirationTtl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ExpirationTtl)
	if !ok {
		that2, ok := that.(GlobalSpecType_ExpirationTtl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExpirationTtl != that1.ExpirationTtl {
		return false
	}
	return true
}
func (this *GlobalSpecType_ExpirationTimestamp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_ExpirationTimestamp)
	if !ok {
		that2, ok := that.(GlobalSpecType_ExpirationTimestamp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExpirationTimestamp.Equal(that1.ExpirationTimestamp) {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.Destination.Equal(that1.Destination) {
		return false
	}
	if that1.Expiration == nil {
		if this.Expiration != nil {
			return false
		}
	} else if this.Expiration == nil {
		return false
	} else if !this.Expiration.Equal(that1.Expiration) {
		return false
	}
	if len(this.IpPrefixes) != len(that1.IpPrefixes) {
		return false
	}
	for i := range this.IpPrefixes {
		if this.IpPrefixes[i] != that1.IpPrefixes[i] {
			return false
		}
	}
	if len(this.Countries) != len(that1.Countries) {
		return false
	}
	for i := range this.Countries {
		if this.Countries[i] != that1.Countries[i] {
			return false
		}
	}
	if len(this.AsNumbers) != len(that1.AsNumbers) {
		return false
	}
	for i := range this.AsNumbers {
		if this.AsNumbers[i] != that1.AsNumbers[i] {
			return false
		}
	}
	if len(this.TlsFingerprints) != len(that1.TlsFingerprints) {
		return false
	}
	for i := range this.TlsFingerprints {
		if this.TlsFingerprints[i] != that1.TlsFingerprints[i] {
			return false
		}
	}
	if len(this.Paths) != len(that1.Paths) {
		return false
	}
	for i := range this.Paths {
		if this.Paths[i] != that1.Paths[i] {
			return false
		}
	}
	return true
}
func (this *CreateSpecType_ExpirationNever) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ExpirationNever)
	if !ok {
		that2, ok := that.(CreateSpecType_ExpirationNever)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExpirationNever.Equal(that1.ExpirationNever) {
		return false
	}
	return true
}
func (this *CreateSpecType_ExpirationTtl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ExpirationTtl)
	if !ok {
		that2, ok := that.(CreateSpecType_ExpirationTtl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExpirationTtl != that1.ExpirationTtl {
		return false
	}
	return true
}
func (this *CreateSpecType_ExpirationTimestamp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_ExpirationTimestamp)
	if !ok {
		that2, ok := that.(CreateSpecType_ExpirationTimestamp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExpirationTimestamp.Equal(that1.ExpirationTimestamp) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Destination.Equal(that1.Destination) {
		return false
	}
	if that1.Expiration == nil {
		if this.Expiration != nil {
			return false
		}
	} else if this.Expiration == nil {
		return false
	} else if !this.Expiration.Equal(that1.Expiration) {
		return false
	}
	if len(this.IpPrefixes) != len(that1.IpPrefixes) {
		return false
	}
	for i := range this.IpPrefixes {
		if this.IpPrefixes[i] != that1.IpPrefixes[i] {
			return false
		}
	}
	if len(this.Countries) != len(that1.Countries) {
		return false
	}
	for i := range this.Countries {
		if this.Countries[i] != that1.Countries[i] {
			return false
		}
	}
	if len(this.AsNumbers) != len(that1.AsNumbers) {
		return false
	}
	for i := range this.AsNumbers {
		if this.AsNumbers[i] != that1.AsNumbers[i] {
			return false
		}
	}
	if len(this.TlsFingerprints) != len(that1.TlsFingerprints) {
		return false
	}
	for i := range this.TlsFingerprints {
		if this.TlsFingerprints[i] != that1.TlsFingerprints[i] {
			return false
		}
	}
	if len(this.Paths) != len(that1.Paths) {
		return false
	}
	for i := range this.Paths {
		if this.Paths[i] != that1.Paths[i] {
			return false
		}
	}
	return true
}
func (this *ReplaceSpecType_ExpirationNever) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ExpirationNever)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ExpirationNever)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExpirationNever.Equal(that1.ExpirationNever) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ExpirationTtl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ExpirationTtl)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ExpirationTtl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExpirationTtl != that1.ExpirationTtl {
		return false
	}
	return true
}
func (this *ReplaceSpecType_ExpirationTimestamp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_ExpirationTimestamp)
	if !ok {
		that2, ok := that.(ReplaceSpecType_ExpirationTimestamp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExpirationTimestamp.Equal(that1.ExpirationTimestamp) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.Destination.Equal(that1.Destination) {
		return false
	}
	if that1.Expiration == nil {
		if this.Expiration != nil {
			return false
		}
	} else if this.Expiration == nil {
		return false
	} else if !this.Expiration.Equal(that1.Expiration) {
		return false
	}
	if len(this.IpPrefixes) != len(that1.IpPrefixes) {
		return false
	}
	for i := range this.IpPrefixes {
		if this.IpPrefixes[i] != that1.IpPrefixes[i] {
			return false
		}
	}
	if len(this.Countries) != len(that1.Countries) {
		return false
	}
	for i := range this.Countries {
		if this.Countries[i] != that1.Countries[i] {
			return false
		}
	}
	if len(this.AsNumbers) != len(that1.AsNumbers) {
		return false
	}
	for i := range this.AsNumbers {
		if this.AsNumbers[i] != that1.AsNumbers[i] {
			return false
		}
	}
	if len(this.TlsFingerprints) != len(that1.TlsFingerprints) {
		return false
	}
	for i := range this.TlsFingerprints {
		if this.TlsFingerprints[i] != that1.TlsFingerprints[i] {
			return false
		}
	}
	if len(this.Paths) != len(that1.Paths) {
		return false
	}
	for i := range this.Paths {
		if this.Paths[i] != that1.Paths[i] {
			return false
		}
	}
	return true
}
func (this *GetSpecType_ExpirationNever) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ExpirationNever)
	if !ok {
		that2, ok := that.(GetSpecType_ExpirationNever)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExpirationNever.Equal(that1.ExpirationNever) {
		return false
	}
	return true
}
func (this *GetSpecType_ExpirationTtl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ExpirationTtl)
	if !ok {
		that2, ok := that.(GetSpecType_ExpirationTtl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExpirationTtl != that1.ExpirationTtl {
		return false
	}
	return true
}
func (this *GetSpecType_ExpirationTimestamp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_ExpirationTimestamp)
	if !ok {
		that2, ok := that.(GetSpecType_ExpirationTimestamp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExpirationTimestamp.Equal(that1.ExpirationTimestamp) {
		return false
	}
	return true
}
func (this *DoSMitigationRuleInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DoSMitigationRuleInfo)
	if !ok {
		that2, ok := that.(DoSMitigationRuleInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.CreationTimestamp.Equal(that1.CreationTimestamp) {
		return false
	}
	if !this.Item.Equal(that1.Item) {
		return false
	}
	return true
}
func (this *Destination) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dos_mitigation.Destination{")
	if this.VirtualHost != nil {
		s = append(s, "VirtualHost: "+fmt.Sprintf("%#v", this.VirtualHost)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&dos_mitigation.GlobalSpecType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Destination != nil {
		s = append(s, "Destination: "+fmt.Sprintf("%#v", this.Destination)+",\n")
	}
	if this.Expiration != nil {
		s = append(s, "Expiration: "+fmt.Sprintf("%#v", this.Expiration)+",\n")
	}
	s = append(s, "IpPrefixes: "+fmt.Sprintf("%#v", this.IpPrefixes)+",\n")
	s = append(s, "Countries: "+fmt.Sprintf("%#v", this.Countries)+",\n")
	s = append(s, "AsNumbers: "+fmt.Sprintf("%#v", this.AsNumbers)+",\n")
	s = append(s, "TlsFingerprints: "+fmt.Sprintf("%#v", this.TlsFingerprints)+",\n")
	s = append(s, "Paths: "+fmt.Sprintf("%#v", this.Paths)+",\n")
	s = append(s, "Ja4TlsFingerprints: "+fmt.Sprintf("%#v", this.Ja4TlsFingerprints)+",\n")
	if this.Throttling != nil {
		s = append(s, "Throttling: "+fmt.Sprintf("%#v", this.Throttling)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_ExpirationNever) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dos_mitigation.GlobalSpecType_ExpirationNever{` +
		`ExpirationNever:` + fmt.Sprintf("%#v", this.ExpirationNever) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ExpirationTtl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dos_mitigation.GlobalSpecType_ExpirationTtl{` +
		`ExpirationTtl:` + fmt.Sprintf("%#v", this.ExpirationTtl) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_ExpirationTimestamp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dos_mitigation.GlobalSpecType_ExpirationTimestamp{` +
		`ExpirationTimestamp:` + fmt.Sprintf("%#v", this.ExpirationTimestamp) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&dos_mitigation.CreateSpecType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Destination != nil {
		s = append(s, "Destination: "+fmt.Sprintf("%#v", this.Destination)+",\n")
	}
	if this.Expiration != nil {
		s = append(s, "Expiration: "+fmt.Sprintf("%#v", this.Expiration)+",\n")
	}
	s = append(s, "IpPrefixes: "+fmt.Sprintf("%#v", this.IpPrefixes)+",\n")
	s = append(s, "Countries: "+fmt.Sprintf("%#v", this.Countries)+",\n")
	s = append(s, "AsNumbers: "+fmt.Sprintf("%#v", this.AsNumbers)+",\n")
	s = append(s, "TlsFingerprints: "+fmt.Sprintf("%#v", this.TlsFingerprints)+",\n")
	s = append(s, "Paths: "+fmt.Sprintf("%#v", this.Paths)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_ExpirationNever) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dos_mitigation.CreateSpecType_ExpirationNever{` +
		`ExpirationNever:` + fmt.Sprintf("%#v", this.ExpirationNever) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ExpirationTtl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dos_mitigation.CreateSpecType_ExpirationTtl{` +
		`ExpirationTtl:` + fmt.Sprintf("%#v", this.ExpirationTtl) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_ExpirationTimestamp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dos_mitigation.CreateSpecType_ExpirationTimestamp{` +
		`ExpirationTimestamp:` + fmt.Sprintf("%#v", this.ExpirationTimestamp) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&dos_mitigation.ReplaceSpecType{")
	if this.Destination != nil {
		s = append(s, "Destination: "+fmt.Sprintf("%#v", this.Destination)+",\n")
	}
	if this.Expiration != nil {
		s = append(s, "Expiration: "+fmt.Sprintf("%#v", this.Expiration)+",\n")
	}
	s = append(s, "IpPrefixes: "+fmt.Sprintf("%#v", this.IpPrefixes)+",\n")
	s = append(s, "Countries: "+fmt.Sprintf("%#v", this.Countries)+",\n")
	s = append(s, "AsNumbers: "+fmt.Sprintf("%#v", this.AsNumbers)+",\n")
	s = append(s, "TlsFingerprints: "+fmt.Sprintf("%#v", this.TlsFingerprints)+",\n")
	s = append(s, "Paths: "+fmt.Sprintf("%#v", this.Paths)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_ExpirationNever) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dos_mitigation.ReplaceSpecType_ExpirationNever{` +
		`ExpirationNever:` + fmt.Sprintf("%#v", this.ExpirationNever) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ExpirationTtl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dos_mitigation.ReplaceSpecType_ExpirationTtl{` +
		`ExpirationTtl:` + fmt.Sprintf("%#v", this.ExpirationTtl) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_ExpirationTimestamp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dos_mitigation.ReplaceSpecType_ExpirationTimestamp{` +
		`ExpirationTimestamp:` + fmt.Sprintf("%#v", this.ExpirationTimestamp) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&dos_mitigation.GetSpecType{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.Destination != nil {
		s = append(s, "Destination: "+fmt.Sprintf("%#v", this.Destination)+",\n")
	}
	if this.Expiration != nil {
		s = append(s, "Expiration: "+fmt.Sprintf("%#v", this.Expiration)+",\n")
	}
	s = append(s, "IpPrefixes: "+fmt.Sprintf("%#v", this.IpPrefixes)+",\n")
	s = append(s, "Countries: "+fmt.Sprintf("%#v", this.Countries)+",\n")
	s = append(s, "AsNumbers: "+fmt.Sprintf("%#v", this.AsNumbers)+",\n")
	s = append(s, "TlsFingerprints: "+fmt.Sprintf("%#v", this.TlsFingerprints)+",\n")
	s = append(s, "Paths: "+fmt.Sprintf("%#v", this.Paths)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_ExpirationNever) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dos_mitigation.GetSpecType_ExpirationNever{` +
		`ExpirationNever:` + fmt.Sprintf("%#v", this.ExpirationNever) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ExpirationTtl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dos_mitigation.GetSpecType_ExpirationTtl{` +
		`ExpirationTtl:` + fmt.Sprintf("%#v", this.ExpirationTtl) + `}`}, ", ")
	return s
}
func (this *GetSpecType_ExpirationTimestamp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dos_mitigation.GetSpecType_ExpirationTimestamp{` +
		`ExpirationTimestamp:` + fmt.Sprintf("%#v", this.ExpirationTimestamp) + `}`}, ", ")
	return s
}
func (this *DoSMitigationRuleInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dos_mitigation.DoSMitigationRuleInfo{")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	if this.CreationTimestamp != nil {
		s = append(s, "CreationTimestamp: "+fmt.Sprintf("%#v", this.CreationTimestamp)+",\n")
	}
	if this.Item != nil {
		s = append(s, "Item: "+fmt.Sprintf("%#v", this.Item)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Destination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Destination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Destination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VirtualHost) > 0 {
		for iNdEx := len(m.VirtualHost) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VirtualHost[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Throttling != nil {
		{
			size, err := m.Throttling.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Ja4TlsFingerprints) > 0 {
		for iNdEx := len(m.Ja4TlsFingerprints) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Ja4TlsFingerprints[iNdEx])
			copy(dAtA[i:], m.Ja4TlsFingerprints[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Ja4TlsFingerprints[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.Paths) > 0 {
		for iNdEx := len(m.Paths) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Paths[iNdEx])
			copy(dAtA[i:], m.Paths[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Paths[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.TlsFingerprints) > 0 {
		for iNdEx := len(m.TlsFingerprints) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TlsFingerprints[iNdEx])
			copy(dAtA[i:], m.TlsFingerprints[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.TlsFingerprints[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.AsNumbers) > 0 {
		dAtA3 := make([]byte, len(m.AsNumbers)*10)
		var j2 int
		for _, num := range m.AsNumbers {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintTypes(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Countries) > 0 {
		dAtA5 := make([]byte, len(m.Countries)*10)
		var j4 int
		for _, num := range m.Countries {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintTypes(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x42
	}
	if len(m.IpPrefixes) > 0 {
		for iNdEx := len(m.IpPrefixes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IpPrefixes[iNdEx])
			copy(dAtA[i:], m.IpPrefixes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.IpPrefixes[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Expiration != nil {
		{
			size := m.Expiration.Size()
			i -= size
			if _, err := m.Expiration.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Destination != nil {
		{
			size, err := m.Destination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_ExpirationNever) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_ExpirationNever) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ExpirationNever != nil {
		{
			size, err := m.ExpirationNever.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_ExpirationTtl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_ExpirationTtl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.ExpirationTtl))
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_ExpirationTimestamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_ExpirationTimestamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ExpirationTimestamp != nil {
		{
			size, err := m.ExpirationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Paths) > 0 {
		for iNdEx := len(m.Paths) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Paths[iNdEx])
			copy(dAtA[i:], m.Paths[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Paths[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.TlsFingerprints) > 0 {
		for iNdEx := len(m.TlsFingerprints) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TlsFingerprints[iNdEx])
			copy(dAtA[i:], m.TlsFingerprints[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.TlsFingerprints[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.AsNumbers) > 0 {
		dAtA10 := make([]byte, len(m.AsNumbers)*10)
		var j9 int
		for _, num := range m.AsNumbers {
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintTypes(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Countries) > 0 {
		dAtA12 := make([]byte, len(m.Countries)*10)
		var j11 int
		for _, num := range m.Countries {
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintTypes(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0x42
	}
	if len(m.IpPrefixes) > 0 {
		for iNdEx := len(m.IpPrefixes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IpPrefixes[iNdEx])
			copy(dAtA[i:], m.IpPrefixes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.IpPrefixes[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Expiration != nil {
		{
			size := m.Expiration.Size()
			i -= size
			if _, err := m.Expiration.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Destination != nil {
		{
			size, err := m.Destination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_ExpirationNever) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_ExpirationNever) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ExpirationNever != nil {
		{
			size, err := m.ExpirationNever.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_ExpirationTtl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_ExpirationTtl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.ExpirationTtl))
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_ExpirationTimestamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_ExpirationTimestamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ExpirationTimestamp != nil {
		{
			size, err := m.ExpirationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Paths) > 0 {
		for iNdEx := len(m.Paths) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Paths[iNdEx])
			copy(dAtA[i:], m.Paths[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Paths[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.TlsFingerprints) > 0 {
		for iNdEx := len(m.TlsFingerprints) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TlsFingerprints[iNdEx])
			copy(dAtA[i:], m.TlsFingerprints[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.TlsFingerprints[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.AsNumbers) > 0 {
		dAtA17 := make([]byte, len(m.AsNumbers)*10)
		var j16 int
		for _, num := range m.AsNumbers {
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		i -= j16
		copy(dAtA[i:], dAtA17[:j16])
		i = encodeVarintTypes(dAtA, i, uint64(j16))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Countries) > 0 {
		dAtA19 := make([]byte, len(m.Countries)*10)
		var j18 int
		for _, num := range m.Countries {
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		i -= j18
		copy(dAtA[i:], dAtA19[:j18])
		i = encodeVarintTypes(dAtA, i, uint64(j18))
		i--
		dAtA[i] = 0x42
	}
	if len(m.IpPrefixes) > 0 {
		for iNdEx := len(m.IpPrefixes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IpPrefixes[iNdEx])
			copy(dAtA[i:], m.IpPrefixes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.IpPrefixes[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Expiration != nil {
		{
			size := m.Expiration.Size()
			i -= size
			if _, err := m.Expiration.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Destination != nil {
		{
			size, err := m.Destination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_ExpirationNever) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_ExpirationNever) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ExpirationNever != nil {
		{
			size, err := m.ExpirationNever.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_ExpirationTtl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_ExpirationTtl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.ExpirationTtl))
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_ExpirationTimestamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_ExpirationTimestamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ExpirationTimestamp != nil {
		{
			size, err := m.ExpirationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Paths) > 0 {
		for iNdEx := len(m.Paths) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Paths[iNdEx])
			copy(dAtA[i:], m.Paths[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Paths[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.TlsFingerprints) > 0 {
		for iNdEx := len(m.TlsFingerprints) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TlsFingerprints[iNdEx])
			copy(dAtA[i:], m.TlsFingerprints[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.TlsFingerprints[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.AsNumbers) > 0 {
		dAtA24 := make([]byte, len(m.AsNumbers)*10)
		var j23 int
		for _, num := range m.AsNumbers {
			for num >= 1<<7 {
				dAtA24[j23] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j23++
			}
			dAtA24[j23] = uint8(num)
			j23++
		}
		i -= j23
		copy(dAtA[i:], dAtA24[:j23])
		i = encodeVarintTypes(dAtA, i, uint64(j23))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Countries) > 0 {
		dAtA26 := make([]byte, len(m.Countries)*10)
		var j25 int
		for _, num := range m.Countries {
			for num >= 1<<7 {
				dAtA26[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA26[j25] = uint8(num)
			j25++
		}
		i -= j25
		copy(dAtA[i:], dAtA26[:j25])
		i = encodeVarintTypes(dAtA, i, uint64(j25))
		i--
		dAtA[i] = 0x42
	}
	if len(m.IpPrefixes) > 0 {
		for iNdEx := len(m.IpPrefixes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IpPrefixes[iNdEx])
			copy(dAtA[i:], m.IpPrefixes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.IpPrefixes[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Expiration != nil {
		{
			size := m.Expiration.Size()
			i -= size
			if _, err := m.Expiration.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Destination != nil {
		{
			size, err := m.Destination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_ExpirationNever) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_ExpirationNever) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ExpirationNever != nil {
		{
			size, err := m.ExpirationNever.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_ExpirationTtl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_ExpirationTtl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTypes(dAtA, i, uint64(m.ExpirationTtl))
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *GetSpecType_ExpirationTimestamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_ExpirationTimestamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ExpirationTimestamp != nil {
		{
			size, err := m.ExpirationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *DoSMitigationRuleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSMitigationRuleInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DoSMitigationRuleInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CreationTimestamp != nil {
		{
			size, err := m.CreationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Destination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VirtualHost) > 0 {
		for _, e := range m.VirtualHost {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.Destination != nil {
		l = m.Destination.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Expiration != nil {
		n += m.Expiration.Size()
	}
	if len(m.IpPrefixes) > 0 {
		for _, s := range m.IpPrefixes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Countries) > 0 {
		l = 0
		for _, e := range m.Countries {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.AsNumbers) > 0 {
		l = 0
		for _, e := range m.AsNumbers {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.TlsFingerprints) > 0 {
		for _, s := range m.TlsFingerprints {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Paths) > 0 {
		for _, s := range m.Paths {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Ja4TlsFingerprints) > 0 {
		for _, s := range m.Ja4TlsFingerprints {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Throttling != nil {
		l = m.Throttling.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType_ExpirationNever) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpirationNever != nil {
		l = m.ExpirationNever.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_ExpirationTtl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.ExpirationTtl))
	return n
}
func (m *GlobalSpecType_ExpirationTimestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpirationTimestamp != nil {
		l = m.ExpirationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.Destination != nil {
		l = m.Destination.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Expiration != nil {
		n += m.Expiration.Size()
	}
	if len(m.IpPrefixes) > 0 {
		for _, s := range m.IpPrefixes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Countries) > 0 {
		l = 0
		for _, e := range m.Countries {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.AsNumbers) > 0 {
		l = 0
		for _, e := range m.AsNumbers {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.TlsFingerprints) > 0 {
		for _, s := range m.TlsFingerprints {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Paths) > 0 {
		for _, s := range m.Paths {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CreateSpecType_ExpirationNever) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpirationNever != nil {
		l = m.ExpirationNever.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_ExpirationTtl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.ExpirationTtl))
	return n
}
func (m *CreateSpecType_ExpirationTimestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpirationTimestamp != nil {
		l = m.ExpirationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Destination != nil {
		l = m.Destination.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Expiration != nil {
		n += m.Expiration.Size()
	}
	if len(m.IpPrefixes) > 0 {
		for _, s := range m.IpPrefixes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Countries) > 0 {
		l = 0
		for _, e := range m.Countries {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.AsNumbers) > 0 {
		l = 0
		for _, e := range m.AsNumbers {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.TlsFingerprints) > 0 {
		for _, s := range m.TlsFingerprints {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Paths) > 0 {
		for _, s := range m.Paths {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *ReplaceSpecType_ExpirationNever) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpirationNever != nil {
		l = m.ExpirationNever.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_ExpirationTtl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.ExpirationTtl))
	return n
}
func (m *ReplaceSpecType_ExpirationTimestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpirationTimestamp != nil {
		l = m.ExpirationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.Destination != nil {
		l = m.Destination.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Expiration != nil {
		n += m.Expiration.Size()
	}
	if len(m.IpPrefixes) > 0 {
		for _, s := range m.IpPrefixes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Countries) > 0 {
		l = 0
		for _, e := range m.Countries {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.AsNumbers) > 0 {
		l = 0
		for _, e := range m.AsNumbers {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.TlsFingerprints) > 0 {
		for _, s := range m.TlsFingerprints {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Paths) > 0 {
		for _, s := range m.Paths {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GetSpecType_ExpirationNever) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpirationNever != nil {
		l = m.ExpirationNever.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_ExpirationTtl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.ExpirationTtl))
	return n
}
func (m *GetSpecType_ExpirationTimestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpirationTimestamp != nil {
		l = m.ExpirationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DoSMitigationRuleInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreationTimestamp != nil {
		l = m.CreationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Destination) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForVirtualHost := "[]*ObjectRefType{"
	for _, f := range this.VirtualHost {
		repeatedStringForVirtualHost += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForVirtualHost += "}"
	s := strings.Join([]string{`&Destination{`,
		`VirtualHost:` + repeatedStringForVirtualHost + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Destination:` + strings.Replace(this.Destination.String(), "Destination", "Destination", 1) + `,`,
		`Expiration:` + fmt.Sprintf("%v", this.Expiration) + `,`,
		`IpPrefixes:` + fmt.Sprintf("%v", this.IpPrefixes) + `,`,
		`Countries:` + fmt.Sprintf("%v", this.Countries) + `,`,
		`AsNumbers:` + fmt.Sprintf("%v", this.AsNumbers) + `,`,
		`TlsFingerprints:` + fmt.Sprintf("%v", this.TlsFingerprints) + `,`,
		`Paths:` + fmt.Sprintf("%v", this.Paths) + `,`,
		`Ja4TlsFingerprints:` + fmt.Sprintf("%v", this.Ja4TlsFingerprints) + `,`,
		`Throttling:` + strings.Replace(fmt.Sprintf("%v", this.Throttling), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ExpirationNever) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ExpirationNever{`,
		`ExpirationNever:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationNever), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ExpirationTtl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ExpirationTtl{`,
		`ExpirationTtl:` + fmt.Sprintf("%v", this.ExpirationTtl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_ExpirationTimestamp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_ExpirationTimestamp{`,
		`ExpirationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Destination:` + strings.Replace(this.Destination.String(), "Destination", "Destination", 1) + `,`,
		`Expiration:` + fmt.Sprintf("%v", this.Expiration) + `,`,
		`IpPrefixes:` + fmt.Sprintf("%v", this.IpPrefixes) + `,`,
		`Countries:` + fmt.Sprintf("%v", this.Countries) + `,`,
		`AsNumbers:` + fmt.Sprintf("%v", this.AsNumbers) + `,`,
		`TlsFingerprints:` + fmt.Sprintf("%v", this.TlsFingerprints) + `,`,
		`Paths:` + fmt.Sprintf("%v", this.Paths) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ExpirationNever) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ExpirationNever{`,
		`ExpirationNever:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationNever), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ExpirationTtl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ExpirationTtl{`,
		`ExpirationTtl:` + fmt.Sprintf("%v", this.ExpirationTtl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_ExpirationTimestamp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_ExpirationTimestamp{`,
		`ExpirationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Destination:` + strings.Replace(this.Destination.String(), "Destination", "Destination", 1) + `,`,
		`Expiration:` + fmt.Sprintf("%v", this.Expiration) + `,`,
		`IpPrefixes:` + fmt.Sprintf("%v", this.IpPrefixes) + `,`,
		`Countries:` + fmt.Sprintf("%v", this.Countries) + `,`,
		`AsNumbers:` + fmt.Sprintf("%v", this.AsNumbers) + `,`,
		`TlsFingerprints:` + fmt.Sprintf("%v", this.TlsFingerprints) + `,`,
		`Paths:` + fmt.Sprintf("%v", this.Paths) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ExpirationNever) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ExpirationNever{`,
		`ExpirationNever:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationNever), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ExpirationTtl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ExpirationTtl{`,
		`ExpirationTtl:` + fmt.Sprintf("%v", this.ExpirationTtl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_ExpirationTimestamp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_ExpirationTimestamp{`,
		`ExpirationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Destination:` + strings.Replace(this.Destination.String(), "Destination", "Destination", 1) + `,`,
		`Expiration:` + fmt.Sprintf("%v", this.Expiration) + `,`,
		`IpPrefixes:` + fmt.Sprintf("%v", this.IpPrefixes) + `,`,
		`Countries:` + fmt.Sprintf("%v", this.Countries) + `,`,
		`AsNumbers:` + fmt.Sprintf("%v", this.AsNumbers) + `,`,
		`TlsFingerprints:` + fmt.Sprintf("%v", this.TlsFingerprints) + `,`,
		`Paths:` + fmt.Sprintf("%v", this.Paths) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ExpirationNever) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ExpirationNever{`,
		`ExpirationNever:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationNever), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ExpirationTtl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ExpirationTtl{`,
		`ExpirationTtl:` + fmt.Sprintf("%v", this.ExpirationTtl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_ExpirationTimestamp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_ExpirationTimestamp{`,
		`ExpirationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DoSMitigationRuleInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DoSMitigationRuleInfo{`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`CreationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.CreationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`Item:` + strings.Replace(this.Item.String(), "GetSpecType", "GetSpecType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Destination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Destination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Destination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualHost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualHost = append(m.VirtualHost, &schema.ObjectRefType{})
			if err := m.VirtualHost[len(m.VirtualHost)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Destination == nil {
				m.Destination = &Destination{}
			}
			if err := m.Destination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationNever", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expiration = &GlobalSpecType_ExpirationNever{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTtl", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Expiration = &GlobalSpecType_ExpirationTtl{v}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.Timestamp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expiration = &GlobalSpecType_ExpirationTimestamp{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpPrefixes = append(m.IpPrefixes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v policy.CountryCode
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= policy.CountryCode(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Countries = append(m.Countries, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Countries) == 0 {
					m.Countries = make([]policy.CountryCode, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v policy.CountryCode
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= policy.CountryCode(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Countries = append(m.Countries, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Countries", wireType)
			}
		case 9:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AsNumbers = append(m.AsNumbers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AsNumbers) == 0 {
					m.AsNumbers = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AsNumbers = append(m.AsNumbers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AsNumbers", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsFingerprints", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsFingerprints = append(m.TlsFingerprints, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paths", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paths = append(m.Paths, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ja4TlsFingerprints", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ja4TlsFingerprints = append(m.Ja4TlsFingerprints, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Throttling", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Throttling == nil {
				m.Throttling = &schema.Empty{}
			}
			if err := m.Throttling.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Destination == nil {
				m.Destination = &Destination{}
			}
			if err := m.Destination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationNever", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expiration = &CreateSpecType_ExpirationNever{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTtl", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Expiration = &CreateSpecType_ExpirationTtl{v}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.Timestamp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expiration = &CreateSpecType_ExpirationTimestamp{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpPrefixes = append(m.IpPrefixes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v policy.CountryCode
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= policy.CountryCode(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Countries = append(m.Countries, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Countries) == 0 {
					m.Countries = make([]policy.CountryCode, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v policy.CountryCode
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= policy.CountryCode(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Countries = append(m.Countries, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Countries", wireType)
			}
		case 9:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AsNumbers = append(m.AsNumbers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AsNumbers) == 0 {
					m.AsNumbers = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AsNumbers = append(m.AsNumbers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AsNumbers", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsFingerprints", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsFingerprints = append(m.TlsFingerprints, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paths", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paths = append(m.Paths, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Destination == nil {
				m.Destination = &Destination{}
			}
			if err := m.Destination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationNever", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expiration = &ReplaceSpecType_ExpirationNever{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTtl", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Expiration = &ReplaceSpecType_ExpirationTtl{v}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.Timestamp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expiration = &ReplaceSpecType_ExpirationTimestamp{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpPrefixes = append(m.IpPrefixes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v policy.CountryCode
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= policy.CountryCode(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Countries = append(m.Countries, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Countries) == 0 {
					m.Countries = make([]policy.CountryCode, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v policy.CountryCode
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= policy.CountryCode(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Countries = append(m.Countries, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Countries", wireType)
			}
		case 9:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AsNumbers = append(m.AsNumbers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AsNumbers) == 0 {
					m.AsNumbers = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AsNumbers = append(m.AsNumbers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AsNumbers", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsFingerprints", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsFingerprints = append(m.TlsFingerprints, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paths", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paths = append(m.Paths, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Destination == nil {
				m.Destination = &Destination{}
			}
			if err := m.Destination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationNever", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expiration = &GetSpecType_ExpirationNever{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTtl", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Expiration = &GetSpecType_ExpirationTtl{v}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.Timestamp{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Expiration = &GetSpecType_ExpirationTimestamp{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPrefixes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpPrefixes = append(m.IpPrefixes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v policy.CountryCode
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= policy.CountryCode(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Countries = append(m.Countries, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Countries) == 0 {
					m.Countries = make([]policy.CountryCode, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v policy.CountryCode
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= policy.CountryCode(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Countries = append(m.Countries, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Countries", wireType)
			}
		case 9:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AsNumbers = append(m.AsNumbers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AsNumbers) == 0 {
					m.AsNumbers = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AsNumbers = append(m.AsNumbers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AsNumbers", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsFingerprints", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsFingerprints = append(m.TlsFingerprints, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paths", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paths = append(m.Paths, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSMitigationRuleInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSMitigationRuleInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSMitigationRuleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTimestamp == nil {
				m.CreationTimestamp = &types.Timestamp{}
			}
			if err := m.CreationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Item == nil {
				m.Item = &GetSpecType{}
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
