// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package dos_mitigation

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CreateBulkRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateBulkRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateBulkRequest) DeepCopy() *CreateBulkRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateBulkRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateBulkRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateBulkRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateBulkRequestValidator().Validate(ctx, m, opts...)
}

func (m *CreateBulkRequest) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	return nil, nil

}

type ValidateCreateBulkRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateBulkRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateBulkRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateBulkRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["objects"]; exists {

		vOpts := append(opts, db.WithValidateField("objects"))
		for idx, item := range m.GetObjects() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateBulkRequestValidator = func() *ValidateCreateBulkRequest {
	v := &ValidateCreateBulkRequest{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["objects"] = ObjectValidator().Validate

	return v
}()

func CreateBulkRequestValidator() db.Validator {
	return DefaultCreateBulkRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateBulkResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateBulkResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateBulkResponse) DeepCopy() *CreateBulkResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateBulkResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateBulkResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateBulkResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateBulkResponseValidator().Validate(ctx, m, opts...)
}

type ValidateCreateBulkResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateBulkResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateBulkResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateBulkResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["created"]; exists {

		vOpts := append(opts, db.WithValidateField("created"))
		for idx, item := range m.GetCreated() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["not_created"]; exists {

		vOpts := append(opts, db.WithValidateField("not_created"))
		for idx, item := range m.GetNotCreated() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["rebuild_errors"]; exists {

		vOpts := append(opts, db.WithValidateField("rebuild_errors"))
		for idx, item := range m.GetRebuildErrors() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["rebuilt"]; exists {

		vOpts := append(opts, db.WithValidateField("rebuilt"))
		for idx, item := range m.GetRebuilt() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateBulkResponseValidator = func() *ValidateCreateBulkResponse {
	v := &ValidateCreateBulkResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CreateBulkResponseValidator() db.Validator {
	return DefaultCreateBulkResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *DeleteBulkRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DeleteBulkRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DeleteBulkRequest) DeepCopy() *DeleteBulkRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DeleteBulkRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DeleteBulkRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DeleteBulkRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DeleteBulkRequestValidator().Validate(ctx, m, opts...)
}

type ValidateDeleteBulkRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDeleteBulkRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DeleteBulkRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DeleteBulkRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["objects"]; exists {

		vOpts := append(opts, db.WithValidateField("objects"))
		for idx, item := range m.GetObjects() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDeleteBulkRequestValidator = func() *ValidateDeleteBulkRequest {
	v := &ValidateDeleteBulkRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DeleteBulkRequestValidator() db.Validator {
	return DefaultDeleteBulkRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *DeleteBulkResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DeleteBulkResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DeleteBulkResponse) DeepCopy() *DeleteBulkResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DeleteBulkResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DeleteBulkResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DeleteBulkResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DeleteBulkResponseValidator().Validate(ctx, m, opts...)
}

type ValidateDeleteBulkResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDeleteBulkResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DeleteBulkResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DeleteBulkResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["deleted"]; exists {

		vOpts := append(opts, db.WithValidateField("deleted"))
		for idx, item := range m.GetDeleted() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["not_deleted"]; exists {

		vOpts := append(opts, db.WithValidateField("not_deleted"))
		for idx, item := range m.GetNotDeleted() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["rebuild_errors"]; exists {

		vOpts := append(opts, db.WithValidateField("rebuild_errors"))
		for idx, item := range m.GetRebuildErrors() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["rebuilt"]; exists {

		vOpts := append(opts, db.WithValidateField("rebuilt"))
		for idx, item := range m.GetRebuilt() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDeleteBulkResponseValidator = func() *ValidateDeleteBulkResponse {
	v := &ValidateDeleteBulkResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DeleteBulkResponseValidator() db.Validator {
	return DefaultDeleteBulkResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *FailedOperation) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FailedOperation) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FailedOperation) DeepCopy() *FailedOperation {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FailedOperation{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FailedOperation) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FailedOperation) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FailedOperationValidator().Validate(ctx, m, opts...)
}

type ValidateFailedOperation struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFailedOperation) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FailedOperation)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FailedOperation got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["error"]; exists {

		vOpts := append(opts, db.WithValidateField("error"))
		if err := fv(ctx, m.GetError(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["object"]; exists {

		vOpts := append(opts, db.WithValidateField("object"))
		if err := fv(ctx, m.GetObject(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFailedOperationValidator = func() *ValidateFailedOperation {
	v := &ValidateFailedOperation{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FailedOperationValidator() db.Validator {
	return DefaultFailedOperationValidator
}
