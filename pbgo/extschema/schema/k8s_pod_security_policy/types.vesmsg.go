//
// Copyright (c) 2018 Volterra, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//
package k8s_pod_security_policy

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *CapabilityListType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CapabilityListType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CapabilityListType) DeepCopy() *CapabilityListType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CapabilityListType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CapabilityListType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CapabilityListType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CapabilityListTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCapabilityListType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCapabilityListType) CapabilitiesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for capabilities")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for capabilities")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated capabilities")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items capabilities")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCapabilityListType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CapabilityListType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CapabilityListType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["capabilities"]; exists {
		vOpts := append(opts, db.WithValidateField("capabilities"))
		if err := fv(ctx, m.GetCapabilities(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCapabilityListTypeValidator = func() *ValidateCapabilityListType {
	v := &ValidateCapabilityListType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhCapabilities := v.CapabilitiesValidationRuleHandler
	rulesCapabilities := map[string]string{
		"ves.io.schema.rules.message.required":   "true",
		"ves.io.schema.rules.repeated.max_items": "64",
		"ves.io.schema.rules.repeated.min_items": "1",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhCapabilities(rulesCapabilities)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CapabilityListType.capabilities: %s", err)
		panic(errMsg)
	}
	v.FldValidators["capabilities"] = vFn

	return v
}()

func CapabilityListTypeValidator() db.Validator {
	return DefaultCapabilityListTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) ConfigMethodChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for config_method_choice")
	}
	return validatorFn, nil
}

func (v *ValidateCreateSpecType) ConfigMethodChoiceYamlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Yaml, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for yaml")
	}
	return oValidatorFn_Yaml, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["config_method_choice"]; exists {
		val := m.GetConfigMethodChoice()
		vOpts := append(opts,
			db.WithValidateField("config_method_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetConfigMethodChoice().(type) {
	case *CreateSpecType_PspSpec:
		if fv, exists := v.FldValidators["config_method_choice.psp_spec"]; exists {
			val := m.GetConfigMethodChoice().(*CreateSpecType_PspSpec).PspSpec
			vOpts := append(opts,
				db.WithValidateField("config_method_choice"),
				db.WithValidateField("psp_spec"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *CreateSpecType_Yaml:
		if fv, exists := v.FldValidators["config_method_choice.yaml"]; exists {
			val := m.GetConfigMethodChoice().(*CreateSpecType_Yaml).Yaml
			vOpts := append(opts,
				db.WithValidateField("config_method_choice"),
				db.WithValidateField("yaml"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhConfigMethodChoice := v.ConfigMethodChoiceValidationRuleHandler
	rulesConfigMethodChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhConfigMethodChoice(rulesConfigMethodChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.config_method_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["config_method_choice"] = vFn

	vrhConfigMethodChoiceYaml := v.ConfigMethodChoiceYamlValidationRuleHandler
	rulesConfigMethodChoiceYaml := map[string]string{
		"ves.io.schema.rules.string.max_len": "4096",
		"ves.io.schema.rules.string.uri_ref": "true",
	}
	vFnMap["config_method_choice.yaml"], err = vrhConfigMethodChoiceYaml(rulesConfigMethodChoiceYaml)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field CreateSpecType.config_method_choice_yaml: %s", err)
		panic(errMsg)
	}

	v.FldValidators["config_method_choice.yaml"] = vFnMap["config_method_choice.yaml"]

	v.FldValidators["config_method_choice.psp_spec"] = PodSecurityPolicySpecTypeValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) ConfigMethodChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for config_method_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGetSpecType) ConfigMethodChoiceYamlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Yaml, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for yaml")
	}
	return oValidatorFn_Yaml, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["config_method_choice"]; exists {
		val := m.GetConfigMethodChoice()
		vOpts := append(opts,
			db.WithValidateField("config_method_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetConfigMethodChoice().(type) {
	case *GetSpecType_PspSpec:
		if fv, exists := v.FldValidators["config_method_choice.psp_spec"]; exists {
			val := m.GetConfigMethodChoice().(*GetSpecType_PspSpec).PspSpec
			vOpts := append(opts,
				db.WithValidateField("config_method_choice"),
				db.WithValidateField("psp_spec"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GetSpecType_Yaml:
		if fv, exists := v.FldValidators["config_method_choice.yaml"]; exists {
			val := m.GetConfigMethodChoice().(*GetSpecType_Yaml).Yaml
			vOpts := append(opts,
				db.WithValidateField("config_method_choice"),
				db.WithValidateField("yaml"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhConfigMethodChoice := v.ConfigMethodChoiceValidationRuleHandler
	rulesConfigMethodChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhConfigMethodChoice(rulesConfigMethodChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.config_method_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["config_method_choice"] = vFn

	vrhConfigMethodChoiceYaml := v.ConfigMethodChoiceYamlValidationRuleHandler
	rulesConfigMethodChoiceYaml := map[string]string{
		"ves.io.schema.rules.string.max_len": "4096",
		"ves.io.schema.rules.string.uri_ref": "true",
	}
	vFnMap["config_method_choice.yaml"], err = vrhConfigMethodChoiceYaml(rulesConfigMethodChoiceYaml)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GetSpecType.config_method_choice_yaml: %s", err)
		panic(errMsg)
	}

	v.FldValidators["config_method_choice.yaml"] = vFnMap["config_method_choice.yaml"]

	v.FldValidators["config_method_choice.psp_spec"] = PodSecurityPolicySpecTypeValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) ConfigMethodChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for config_method_choice")
	}
	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ConfigMethodChoiceYamlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Yaml, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for yaml")
	}
	return oValidatorFn_Yaml, nil
}

func (v *ValidateGlobalSpecType) GeneratedYamlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for generated_yaml")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["config_method_choice"]; exists {
		val := m.GetConfigMethodChoice()
		vOpts := append(opts,
			db.WithValidateField("config_method_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetConfigMethodChoice().(type) {
	case *GlobalSpecType_PspSpec:
		if fv, exists := v.FldValidators["config_method_choice.psp_spec"]; exists {
			val := m.GetConfigMethodChoice().(*GlobalSpecType_PspSpec).PspSpec
			vOpts := append(opts,
				db.WithValidateField("config_method_choice"),
				db.WithValidateField("psp_spec"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *GlobalSpecType_Yaml:
		if fv, exists := v.FldValidators["config_method_choice.yaml"]; exists {
			val := m.GetConfigMethodChoice().(*GlobalSpecType_Yaml).Yaml
			vOpts := append(opts,
				db.WithValidateField("config_method_choice"),
				db.WithValidateField("yaml"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["generated_yaml"]; exists {

		vOpts := append(opts, db.WithValidateField("generated_yaml"))
		if err := fv(ctx, m.GetGeneratedYaml(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhConfigMethodChoice := v.ConfigMethodChoiceValidationRuleHandler
	rulesConfigMethodChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhConfigMethodChoice(rulesConfigMethodChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.config_method_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["config_method_choice"] = vFn

	vrhConfigMethodChoiceYaml := v.ConfigMethodChoiceYamlValidationRuleHandler
	rulesConfigMethodChoiceYaml := map[string]string{
		"ves.io.schema.rules.string.max_len": "4096",
		"ves.io.schema.rules.string.uri_ref": "true",
	}
	vFnMap["config_method_choice.yaml"], err = vrhConfigMethodChoiceYaml(rulesConfigMethodChoiceYaml)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field GlobalSpecType.config_method_choice_yaml: %s", err)
		panic(errMsg)
	}

	v.FldValidators["config_method_choice.yaml"] = vFnMap["config_method_choice.yaml"]

	vrhGeneratedYaml := v.GeneratedYamlValidationRuleHandler
	rulesGeneratedYaml := map[string]string{
		"ves.io.schema.rules.string.max_len": "4096",
		"ves.io.schema.rules.string.uri_ref": "true",
	}
	vFn, err = vrhGeneratedYaml(rulesGeneratedYaml)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.generated_yaml: %s", err)
		panic(errMsg)
	}
	v.FldValidators["generated_yaml"] = vFn

	v.FldValidators["config_method_choice.psp_spec"] = PodSecurityPolicySpecTypeValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *HostPathType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *HostPathType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *HostPathType) DeepCopy() *HostPathType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &HostPathType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *HostPathType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *HostPathType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return HostPathTypeValidator().Validate(ctx, m, opts...)
}

type ValidateHostPathType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateHostPathType) PathPrefixValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for path_prefix")
	}

	return validatorFn, nil
}

func (v *ValidateHostPathType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*HostPathType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *HostPathType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["path_prefix"]; exists {

		vOpts := append(opts, db.WithValidateField("path_prefix"))
		if err := fv(ctx, m.GetPathPrefix(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["read_only"]; exists {

		vOpts := append(opts, db.WithValidateField("read_only"))
		if err := fv(ctx, m.GetReadOnly(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultHostPathTypeValidator = func() *ValidateHostPathType {
	v := &ValidateHostPathType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPathPrefix := v.PathPrefixValidationRuleHandler
	rulesPathPrefix := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_len":   "128",
		"ves.io.schema.rules.string.min_len":   "1",
	}
	vFn, err = vrhPathPrefix(rulesPathPrefix)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for HostPathType.path_prefix: %s", err)
		panic(errMsg)
	}
	v.FldValidators["path_prefix"] = vFn

	return v
}()

func HostPathTypeValidator() db.Validator {
	return DefaultHostPathTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *IDRangeType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IDRangeType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IDRangeType) DeepCopy() *IDRangeType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IDRangeType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IDRangeType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IDRangeType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IDRangeTypeValidator().Validate(ctx, m, opts...)
}

type ValidateIDRangeType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIDRangeType) MinIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for min_id")
	}

	return validatorFn, nil
}

func (v *ValidateIDRangeType) MaxIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for max_id")
	}

	return validatorFn, nil
}

func (v *ValidateIDRangeType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IDRangeType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IDRangeType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["max_id"]; exists {

		vOpts := append(opts, db.WithValidateField("max_id"))
		if err := fv(ctx, m.GetMaxId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["min_id"]; exists {

		vOpts := append(opts, db.WithValidateField("min_id"))
		if err := fv(ctx, m.GetMinId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIDRangeTypeValidator = func() *ValidateIDRangeType {
	v := &ValidateIDRangeType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMinId := v.MinIdValidationRuleHandler
	rulesMinId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "1",
		"ves.io.schema.rules.uint32.lte":       "65535",
	}
	vFn, err = vrhMinId(rulesMinId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IDRangeType.min_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["min_id"] = vFn

	vrhMaxId := v.MaxIdValidationRuleHandler
	rulesMaxId := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.uint32.gte":       "1",
		"ves.io.schema.rules.uint32.lte":       "65535",
	}
	vFn, err = vrhMaxId(rulesMaxId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IDRangeType.max_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["max_id"] = vFn

	return v
}()

func IDRangeTypeValidator() db.Validator {
	return DefaultIDRangeTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *IDStrategyOptionsType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *IDStrategyOptionsType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *IDStrategyOptionsType) DeepCopy() *IDStrategyOptionsType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &IDStrategyOptionsType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *IDStrategyOptionsType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *IDStrategyOptionsType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return IDStrategyOptionsTypeValidator().Validate(ctx, m, opts...)
}

type ValidateIDStrategyOptionsType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateIDStrategyOptionsType) IdRangesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*IDRangeType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := IDRangeTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for id_ranges")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*IDRangeType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*IDRangeType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated id_ranges")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items id_ranges")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateIDStrategyOptionsType) RuleValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for rule")
	}

	return validatorFn, nil
}

func (v *ValidateIDStrategyOptionsType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*IDStrategyOptionsType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *IDStrategyOptionsType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["id_ranges"]; exists {
		vOpts := append(opts, db.WithValidateField("id_ranges"))
		if err := fv(ctx, m.GetIdRanges(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rule"]; exists {

		vOpts := append(opts, db.WithValidateField("rule"))
		if err := fv(ctx, m.GetRule(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultIDStrategyOptionsTypeValidator = func() *ValidateIDStrategyOptionsType {
	v := &ValidateIDStrategyOptionsType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhIdRanges := v.IdRangesValidationRuleHandler
	rulesIdRanges := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
	}
	vFn, err = vrhIdRanges(rulesIdRanges)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IDStrategyOptionsType.id_ranges: %s", err)
		panic(errMsg)
	}
	v.FldValidators["id_ranges"] = vFn

	vrhRule := v.RuleValidationRuleHandler
	rulesRule := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "128",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhRule(rulesRule)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for IDStrategyOptionsType.rule: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rule"] = vFn

	return v
}()

func IDStrategyOptionsTypeValidator() db.Validator {
	return DefaultIDStrategyOptionsTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *PodSecurityPolicySpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PodSecurityPolicySpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PodSecurityPolicySpecType) DeepCopy() *PodSecurityPolicySpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PodSecurityPolicySpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PodSecurityPolicySpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PodSecurityPolicySpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PodSecurityPolicySpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidatePodSecurityPolicySpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePodSecurityPolicySpecType) AllowedCapabilitiesChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for allowed_capabilities_choice")
	}
	return validatorFn, nil
}

func (v *ValidatePodSecurityPolicySpecType) DefaultCapabilitiesChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for default_capabilities_choice")
	}
	return validatorFn, nil
}

func (v *ValidatePodSecurityPolicySpecType) DropCapabilitiesChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for drop_capabilities_choice")
	}
	return validatorFn, nil
}

func (v *ValidatePodSecurityPolicySpecType) FsGroupChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for fs_group_choice")
	}
	return validatorFn, nil
}

func (v *ValidatePodSecurityPolicySpecType) GroupChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for group_choice")
	}
	return validatorFn, nil
}

func (v *ValidatePodSecurityPolicySpecType) RuntimeClassChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for runtime_class_choice")
	}
	return validatorFn, nil
}

func (v *ValidatePodSecurityPolicySpecType) SeLinuxChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for se_linux_choice")
	}
	return validatorFn, nil
}

func (v *ValidatePodSecurityPolicySpecType) SupplementalGroupChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for supplemental_group_choice")
	}
	return validatorFn, nil
}

func (v *ValidatePodSecurityPolicySpecType) UserChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for user_choice")
	}
	return validatorFn, nil
}

func (v *ValidatePodSecurityPolicySpecType) VolumesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for volumes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for volumes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated volumes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items volumes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePodSecurityPolicySpecType) AllowedFlexVolumesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for allowed_flex_volumes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for allowed_flex_volumes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated allowed_flex_volumes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items allowed_flex_volumes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePodSecurityPolicySpecType) AllowedHostPathsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemsValidatorFn := func(ctx context.Context, elems []*HostPathType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := HostPathTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for allowed_host_paths")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*HostPathType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*HostPathType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated allowed_host_paths")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items allowed_host_paths")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePodSecurityPolicySpecType) AllowedProcMountsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for allowed_proc_mounts")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for allowed_proc_mounts")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated allowed_proc_mounts")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items allowed_proc_mounts")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePodSecurityPolicySpecType) AllowedCsiDriversValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for allowed_csi_drivers")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for allowed_csi_drivers")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated allowed_csi_drivers")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items allowed_csi_drivers")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePodSecurityPolicySpecType) HostPortRangesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for host_port_ranges")
	}

	return validatorFn, nil
}

func (v *ValidatePodSecurityPolicySpecType) AllowedUnsafeSysctlsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for allowed_unsafe_sysctls")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for allowed_unsafe_sysctls")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated allowed_unsafe_sysctls")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items allowed_unsafe_sysctls")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePodSecurityPolicySpecType) ForbiddenSysctlsValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for forbidden_sysctls")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for forbidden_sysctls")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated forbidden_sysctls")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items forbidden_sysctls")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePodSecurityPolicySpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PodSecurityPolicySpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PodSecurityPolicySpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["allow_privilege_escalation"]; exists {

		vOpts := append(opts, db.WithValidateField("allow_privilege_escalation"))
		if err := fv(ctx, m.GetAllowPrivilegeEscalation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["allowed_capabilities_choice"]; exists {
		val := m.GetAllowedCapabilitiesChoice()
		vOpts := append(opts,
			db.WithValidateField("allowed_capabilities_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetAllowedCapabilitiesChoice().(type) {
	case *PodSecurityPolicySpecType_NoAllowedCapabilities:
		if fv, exists := v.FldValidators["allowed_capabilities_choice.no_allowed_capabilities"]; exists {
			val := m.GetAllowedCapabilitiesChoice().(*PodSecurityPolicySpecType_NoAllowedCapabilities).NoAllowedCapabilities
			vOpts := append(opts,
				db.WithValidateField("allowed_capabilities_choice"),
				db.WithValidateField("no_allowed_capabilities"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PodSecurityPolicySpecType_AllowedCapabilities:
		if fv, exists := v.FldValidators["allowed_capabilities_choice.allowed_capabilities"]; exists {
			val := m.GetAllowedCapabilitiesChoice().(*PodSecurityPolicySpecType_AllowedCapabilities).AllowedCapabilities
			vOpts := append(opts,
				db.WithValidateField("allowed_capabilities_choice"),
				db.WithValidateField("allowed_capabilities"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["allowed_csi_drivers"]; exists {
		vOpts := append(opts, db.WithValidateField("allowed_csi_drivers"))
		if err := fv(ctx, m.GetAllowedCsiDrivers(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["allowed_flex_volumes"]; exists {
		vOpts := append(opts, db.WithValidateField("allowed_flex_volumes"))
		if err := fv(ctx, m.GetAllowedFlexVolumes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["allowed_host_paths"]; exists {
		vOpts := append(opts, db.WithValidateField("allowed_host_paths"))
		if err := fv(ctx, m.GetAllowedHostPaths(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["allowed_proc_mounts"]; exists {
		vOpts := append(opts, db.WithValidateField("allowed_proc_mounts"))
		if err := fv(ctx, m.GetAllowedProcMounts(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["allowed_unsafe_sysctls"]; exists {
		vOpts := append(opts, db.WithValidateField("allowed_unsafe_sysctls"))
		if err := fv(ctx, m.GetAllowedUnsafeSysctls(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_allow_privilege_escalation"]; exists {

		vOpts := append(opts, db.WithValidateField("default_allow_privilege_escalation"))
		if err := fv(ctx, m.GetDefaultAllowPrivilegeEscalation(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_capabilities_choice"]; exists {
		val := m.GetDefaultCapabilitiesChoice()
		vOpts := append(opts,
			db.WithValidateField("default_capabilities_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDefaultCapabilitiesChoice().(type) {
	case *PodSecurityPolicySpecType_NoDefaultCapabilities:
		if fv, exists := v.FldValidators["default_capabilities_choice.no_default_capabilities"]; exists {
			val := m.GetDefaultCapabilitiesChoice().(*PodSecurityPolicySpecType_NoDefaultCapabilities).NoDefaultCapabilities
			vOpts := append(opts,
				db.WithValidateField("default_capabilities_choice"),
				db.WithValidateField("no_default_capabilities"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PodSecurityPolicySpecType_DefaultCapabilities:
		if fv, exists := v.FldValidators["default_capabilities_choice.default_capabilities"]; exists {
			val := m.GetDefaultCapabilitiesChoice().(*PodSecurityPolicySpecType_DefaultCapabilities).DefaultCapabilities
			vOpts := append(opts,
				db.WithValidateField("default_capabilities_choice"),
				db.WithValidateField("default_capabilities"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["drop_capabilities_choice"]; exists {
		val := m.GetDropCapabilitiesChoice()
		vOpts := append(opts,
			db.WithValidateField("drop_capabilities_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetDropCapabilitiesChoice().(type) {
	case *PodSecurityPolicySpecType_NoDropCapabilities:
		if fv, exists := v.FldValidators["drop_capabilities_choice.no_drop_capabilities"]; exists {
			val := m.GetDropCapabilitiesChoice().(*PodSecurityPolicySpecType_NoDropCapabilities).NoDropCapabilities
			vOpts := append(opts,
				db.WithValidateField("drop_capabilities_choice"),
				db.WithValidateField("no_drop_capabilities"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PodSecurityPolicySpecType_DropCapabilities:
		if fv, exists := v.FldValidators["drop_capabilities_choice.drop_capabilities"]; exists {
			val := m.GetDropCapabilitiesChoice().(*PodSecurityPolicySpecType_DropCapabilities).DropCapabilities
			vOpts := append(opts,
				db.WithValidateField("drop_capabilities_choice"),
				db.WithValidateField("drop_capabilities"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["forbidden_sysctls"]; exists {
		vOpts := append(opts, db.WithValidateField("forbidden_sysctls"))
		if err := fv(ctx, m.GetForbiddenSysctls(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["fs_group_choice"]; exists {
		val := m.GetFsGroupChoice()
		vOpts := append(opts,
			db.WithValidateField("fs_group_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetFsGroupChoice().(type) {
	case *PodSecurityPolicySpecType_NoFsGroups:
		if fv, exists := v.FldValidators["fs_group_choice.no_fs_groups"]; exists {
			val := m.GetFsGroupChoice().(*PodSecurityPolicySpecType_NoFsGroups).NoFsGroups
			vOpts := append(opts,
				db.WithValidateField("fs_group_choice"),
				db.WithValidateField("no_fs_groups"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PodSecurityPolicySpecType_FsGroupStrategyOptions:
		if fv, exists := v.FldValidators["fs_group_choice.fs_group_strategy_options"]; exists {
			val := m.GetFsGroupChoice().(*PodSecurityPolicySpecType_FsGroupStrategyOptions).FsGroupStrategyOptions
			vOpts := append(opts,
				db.WithValidateField("fs_group_choice"),
				db.WithValidateField("fs_group_strategy_options"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["group_choice"]; exists {
		val := m.GetGroupChoice()
		vOpts := append(opts,
			db.WithValidateField("group_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetGroupChoice().(type) {
	case *PodSecurityPolicySpecType_NoRunAsGroup:
		if fv, exists := v.FldValidators["group_choice.no_run_as_group"]; exists {
			val := m.GetGroupChoice().(*PodSecurityPolicySpecType_NoRunAsGroup).NoRunAsGroup
			vOpts := append(opts,
				db.WithValidateField("group_choice"),
				db.WithValidateField("no_run_as_group"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PodSecurityPolicySpecType_RunAsGroup:
		if fv, exists := v.FldValidators["group_choice.run_as_group"]; exists {
			val := m.GetGroupChoice().(*PodSecurityPolicySpecType_RunAsGroup).RunAsGroup
			vOpts := append(opts,
				db.WithValidateField("group_choice"),
				db.WithValidateField("run_as_group"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["host_ipc"]; exists {

		vOpts := append(opts, db.WithValidateField("host_ipc"))
		if err := fv(ctx, m.GetHostIpc(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["host_network"]; exists {

		vOpts := append(opts, db.WithValidateField("host_network"))
		if err := fv(ctx, m.GetHostNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["host_pid"]; exists {

		vOpts := append(opts, db.WithValidateField("host_pid"))
		if err := fv(ctx, m.GetHostPid(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["host_port_ranges"]; exists {

		vOpts := append(opts, db.WithValidateField("host_port_ranges"))
		if err := fv(ctx, m.GetHostPortRanges(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["privileged"]; exists {

		vOpts := append(opts, db.WithValidateField("privileged"))
		if err := fv(ctx, m.GetPrivileged(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["read_only_root_filesystem"]; exists {

		vOpts := append(opts, db.WithValidateField("read_only_root_filesystem"))
		if err := fv(ctx, m.GetReadOnlyRootFilesystem(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["runtime_class_choice"]; exists {
		val := m.GetRuntimeClassChoice()
		vOpts := append(opts,
			db.WithValidateField("runtime_class_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetRuntimeClassChoice().(type) {
	case *PodSecurityPolicySpecType_NoRuntimeClass:
		if fv, exists := v.FldValidators["runtime_class_choice.no_runtime_class"]; exists {
			val := m.GetRuntimeClassChoice().(*PodSecurityPolicySpecType_NoRuntimeClass).NoRuntimeClass
			vOpts := append(opts,
				db.WithValidateField("runtime_class_choice"),
				db.WithValidateField("no_runtime_class"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PodSecurityPolicySpecType_RuntimeClass:
		if fv, exists := v.FldValidators["runtime_class_choice.runtime_class"]; exists {
			val := m.GetRuntimeClassChoice().(*PodSecurityPolicySpecType_RuntimeClass).RuntimeClass
			vOpts := append(opts,
				db.WithValidateField("runtime_class_choice"),
				db.WithValidateField("runtime_class"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["se_linux_choice"]; exists {
		val := m.GetSeLinuxChoice()
		vOpts := append(opts,
			db.WithValidateField("se_linux_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSeLinuxChoice().(type) {
	case *PodSecurityPolicySpecType_NoSeLinuxOptions:
		if fv, exists := v.FldValidators["se_linux_choice.no_se_linux_options"]; exists {
			val := m.GetSeLinuxChoice().(*PodSecurityPolicySpecType_NoSeLinuxOptions).NoSeLinuxOptions
			vOpts := append(opts,
				db.WithValidateField("se_linux_choice"),
				db.WithValidateField("no_se_linux_options"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PodSecurityPolicySpecType_SeLinuxOptions:
		if fv, exists := v.FldValidators["se_linux_choice.se_linux_options"]; exists {
			val := m.GetSeLinuxChoice().(*PodSecurityPolicySpecType_SeLinuxOptions).SeLinuxOptions
			vOpts := append(opts,
				db.WithValidateField("se_linux_choice"),
				db.WithValidateField("se_linux_options"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["supplemental_group_choice"]; exists {
		val := m.GetSupplementalGroupChoice()
		vOpts := append(opts,
			db.WithValidateField("supplemental_group_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetSupplementalGroupChoice().(type) {
	case *PodSecurityPolicySpecType_NoSupplementalGroups:
		if fv, exists := v.FldValidators["supplemental_group_choice.no_supplemental_groups"]; exists {
			val := m.GetSupplementalGroupChoice().(*PodSecurityPolicySpecType_NoSupplementalGroups).NoSupplementalGroups
			vOpts := append(opts,
				db.WithValidateField("supplemental_group_choice"),
				db.WithValidateField("no_supplemental_groups"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PodSecurityPolicySpecType_SupplementalGroups:
		if fv, exists := v.FldValidators["supplemental_group_choice.supplemental_groups"]; exists {
			val := m.GetSupplementalGroupChoice().(*PodSecurityPolicySpecType_SupplementalGroups).SupplementalGroups
			vOpts := append(opts,
				db.WithValidateField("supplemental_group_choice"),
				db.WithValidateField("supplemental_groups"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["user_choice"]; exists {
		val := m.GetUserChoice()
		vOpts := append(opts,
			db.WithValidateField("user_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetUserChoice().(type) {
	case *PodSecurityPolicySpecType_NoRunAsUser:
		if fv, exists := v.FldValidators["user_choice.no_run_as_user"]; exists {
			val := m.GetUserChoice().(*PodSecurityPolicySpecType_NoRunAsUser).NoRunAsUser
			vOpts := append(opts,
				db.WithValidateField("user_choice"),
				db.WithValidateField("no_run_as_user"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *PodSecurityPolicySpecType_RunAsUser:
		if fv, exists := v.FldValidators["user_choice.run_as_user"]; exists {
			val := m.GetUserChoice().(*PodSecurityPolicySpecType_RunAsUser).RunAsUser
			vOpts := append(opts,
				db.WithValidateField("user_choice"),
				db.WithValidateField("run_as_user"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["volumes"]; exists {
		vOpts := append(opts, db.WithValidateField("volumes"))
		if err := fv(ctx, m.GetVolumes(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPodSecurityPolicySpecTypeValidator = func() *ValidatePodSecurityPolicySpecType {
	v := &ValidatePodSecurityPolicySpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAllowedCapabilitiesChoice := v.AllowedCapabilitiesChoiceValidationRuleHandler
	rulesAllowedCapabilitiesChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhAllowedCapabilitiesChoice(rulesAllowedCapabilitiesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PodSecurityPolicySpecType.allowed_capabilities_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["allowed_capabilities_choice"] = vFn

	vrhDefaultCapabilitiesChoice := v.DefaultCapabilitiesChoiceValidationRuleHandler
	rulesDefaultCapabilitiesChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDefaultCapabilitiesChoice(rulesDefaultCapabilitiesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PodSecurityPolicySpecType.default_capabilities_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["default_capabilities_choice"] = vFn

	vrhDropCapabilitiesChoice := v.DropCapabilitiesChoiceValidationRuleHandler
	rulesDropCapabilitiesChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhDropCapabilitiesChoice(rulesDropCapabilitiesChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PodSecurityPolicySpecType.drop_capabilities_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["drop_capabilities_choice"] = vFn

	vrhFsGroupChoice := v.FsGroupChoiceValidationRuleHandler
	rulesFsGroupChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhFsGroupChoice(rulesFsGroupChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PodSecurityPolicySpecType.fs_group_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["fs_group_choice"] = vFn

	vrhGroupChoice := v.GroupChoiceValidationRuleHandler
	rulesGroupChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhGroupChoice(rulesGroupChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PodSecurityPolicySpecType.group_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["group_choice"] = vFn

	vrhRuntimeClassChoice := v.RuntimeClassChoiceValidationRuleHandler
	rulesRuntimeClassChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhRuntimeClassChoice(rulesRuntimeClassChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PodSecurityPolicySpecType.runtime_class_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["runtime_class_choice"] = vFn

	vrhSeLinuxChoice := v.SeLinuxChoiceValidationRuleHandler
	rulesSeLinuxChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSeLinuxChoice(rulesSeLinuxChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PodSecurityPolicySpecType.se_linux_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["se_linux_choice"] = vFn

	vrhSupplementalGroupChoice := v.SupplementalGroupChoiceValidationRuleHandler
	rulesSupplementalGroupChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhSupplementalGroupChoice(rulesSupplementalGroupChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PodSecurityPolicySpecType.supplemental_group_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["supplemental_group_choice"] = vFn

	vrhUserChoice := v.UserChoiceValidationRuleHandler
	rulesUserChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhUserChoice(rulesUserChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PodSecurityPolicySpecType.user_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["user_choice"] = vFn

	vrhVolumes := v.VolumesValidationRuleHandler
	rulesVolumes := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "64",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "8",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhVolumes(rulesVolumes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PodSecurityPolicySpecType.volumes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["volumes"] = vFn

	vrhAllowedFlexVolumes := v.AllowedFlexVolumesValidationRuleHandler
	rulesAllowedFlexVolumes := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "64",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "8",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhAllowedFlexVolumes(rulesAllowedFlexVolumes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PodSecurityPolicySpecType.allowed_flex_volumes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["allowed_flex_volumes"] = vFn

	vrhAllowedHostPaths := v.AllowedHostPathsValidationRuleHandler
	rulesAllowedHostPaths := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhAllowedHostPaths(rulesAllowedHostPaths)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PodSecurityPolicySpecType.allowed_host_paths: %s", err)
		panic(errMsg)
	}
	v.FldValidators["allowed_host_paths"] = vFn

	vrhAllowedProcMounts := v.AllowedProcMountsValidationRuleHandler
	rulesAllowedProcMounts := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "8",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhAllowedProcMounts(rulesAllowedProcMounts)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PodSecurityPolicySpecType.allowed_proc_mounts: %s", err)
		panic(errMsg)
	}
	v.FldValidators["allowed_proc_mounts"] = vFn

	vrhAllowedCsiDrivers := v.AllowedCsiDriversValidationRuleHandler
	rulesAllowedCsiDrivers := map[string]string{
		"ves.io.schema.rules.repeated.items.string.max_bytes": "64",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "8",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhAllowedCsiDrivers(rulesAllowedCsiDrivers)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PodSecurityPolicySpecType.allowed_csi_drivers: %s", err)
		panic(errMsg)
	}
	v.FldValidators["allowed_csi_drivers"] = vFn

	vrhHostPortRanges := v.HostPortRangesValidationRuleHandler
	rulesHostPortRanges := map[string]string{
		"ves.io.schema.rules.string.port_range_list": "true",
	}
	vFn, err = vrhHostPortRanges(rulesHostPortRanges)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PodSecurityPolicySpecType.host_port_ranges: %s", err)
		panic(errMsg)
	}
	v.FldValidators["host_port_ranges"] = vFn

	vrhAllowedUnsafeSysctls := v.AllowedUnsafeSysctlsValidationRuleHandler
	rulesAllowedUnsafeSysctls := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhAllowedUnsafeSysctls(rulesAllowedUnsafeSysctls)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PodSecurityPolicySpecType.allowed_unsafe_sysctls: %s", err)
		panic(errMsg)
	}
	v.FldValidators["allowed_unsafe_sysctls"] = vFn

	vrhForbiddenSysctls := v.ForbiddenSysctlsValidationRuleHandler
	rulesForbiddenSysctls := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "16",
		"ves.io.schema.rules.repeated.unique":    "true",
	}
	vFn, err = vrhForbiddenSysctls(rulesForbiddenSysctls)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PodSecurityPolicySpecType.forbidden_sysctls: %s", err)
		panic(errMsg)
	}
	v.FldValidators["forbidden_sysctls"] = vFn

	v.FldValidators["allowed_capabilities_choice.allowed_capabilities"] = CapabilityListTypeValidator().Validate

	v.FldValidators["default_capabilities_choice.default_capabilities"] = CapabilityListTypeValidator().Validate

	v.FldValidators["drop_capabilities_choice.drop_capabilities"] = CapabilityListTypeValidator().Validate

	v.FldValidators["fs_group_choice.fs_group_strategy_options"] = IDStrategyOptionsTypeValidator().Validate

	v.FldValidators["group_choice.run_as_group"] = IDStrategyOptionsTypeValidator().Validate

	v.FldValidators["runtime_class_choice.runtime_class"] = RuntimeClassStrategyOptionsValidator().Validate

	v.FldValidators["se_linux_choice.se_linux_options"] = SELinuxStrategyOptionsValidator().Validate

	v.FldValidators["supplemental_group_choice.supplemental_groups"] = IDStrategyOptionsTypeValidator().Validate

	v.FldValidators["user_choice.run_as_user"] = IDStrategyOptionsTypeValidator().Validate

	return v
}()

func PodSecurityPolicySpecTypeValidator() db.Validator {
	return DefaultPodSecurityPolicySpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) ConfigMethodChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for config_method_choice")
	}
	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) ConfigMethodChoiceYamlValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	oValidatorFn_Yaml, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for yaml")
	}
	return oValidatorFn_Yaml, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["config_method_choice"]; exists {
		val := m.GetConfigMethodChoice()
		vOpts := append(opts,
			db.WithValidateField("config_method_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetConfigMethodChoice().(type) {
	case *ReplaceSpecType_PspSpec:
		if fv, exists := v.FldValidators["config_method_choice.psp_spec"]; exists {
			val := m.GetConfigMethodChoice().(*ReplaceSpecType_PspSpec).PspSpec
			vOpts := append(opts,
				db.WithValidateField("config_method_choice"),
				db.WithValidateField("psp_spec"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReplaceSpecType_Yaml:
		if fv, exists := v.FldValidators["config_method_choice.yaml"]; exists {
			val := m.GetConfigMethodChoice().(*ReplaceSpecType_Yaml).Yaml
			vOpts := append(opts,
				db.WithValidateField("config_method_choice"),
				db.WithValidateField("yaml"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhConfigMethodChoice := v.ConfigMethodChoiceValidationRuleHandler
	rulesConfigMethodChoice := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhConfigMethodChoice(rulesConfigMethodChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.config_method_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["config_method_choice"] = vFn

	vrhConfigMethodChoiceYaml := v.ConfigMethodChoiceYamlValidationRuleHandler
	rulesConfigMethodChoiceYaml := map[string]string{
		"ves.io.schema.rules.string.max_len": "4096",
		"ves.io.schema.rules.string.uri_ref": "true",
	}
	vFnMap["config_method_choice.yaml"], err = vrhConfigMethodChoiceYaml(rulesConfigMethodChoiceYaml)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for oneof field ReplaceSpecType.config_method_choice_yaml: %s", err)
		panic(errMsg)
	}

	v.FldValidators["config_method_choice.yaml"] = vFnMap["config_method_choice.yaml"]

	v.FldValidators["config_method_choice.psp_spec"] = PodSecurityPolicySpecTypeValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *RuntimeClassStrategyOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RuntimeClassStrategyOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RuntimeClassStrategyOptions) DeepCopy() *RuntimeClassStrategyOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RuntimeClassStrategyOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RuntimeClassStrategyOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RuntimeClassStrategyOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RuntimeClassStrategyOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateRuntimeClassStrategyOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRuntimeClassStrategyOptions) AllowedRuntimeClassNamesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for allowed_runtime_class_names")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for allowed_runtime_class_names")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated allowed_runtime_class_names")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items allowed_runtime_class_names")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateRuntimeClassStrategyOptions) DefaultRuntimeClassNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for default_runtime_class_name")
	}

	return validatorFn, nil
}

func (v *ValidateRuntimeClassStrategyOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RuntimeClassStrategyOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RuntimeClassStrategyOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["allowed_runtime_class_names"]; exists {
		vOpts := append(opts, db.WithValidateField("allowed_runtime_class_names"))
		if err := fv(ctx, m.GetAllowedRuntimeClassNames(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_runtime_class_name"]; exists {

		vOpts := append(opts, db.WithValidateField("default_runtime_class_name"))
		if err := fv(ctx, m.GetDefaultRuntimeClassName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRuntimeClassStrategyOptionsValidator = func() *ValidateRuntimeClassStrategyOptions {
	v := &ValidateRuntimeClassStrategyOptions{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAllowedRuntimeClassNames := v.AllowedRuntimeClassNamesValidationRuleHandler
	rulesAllowedRuntimeClassNames := map[string]string{
		"ves.io.schema.rules.message.required":                "true",
		"ves.io.schema.rules.repeated.items.string.max_bytes": "64",
		"ves.io.schema.rules.repeated.items.string.min_bytes": "1",
		"ves.io.schema.rules.repeated.max_items":              "4",
		"ves.io.schema.rules.repeated.min_items":              "1",
		"ves.io.schema.rules.repeated.unique":                 "true",
	}
	vFn, err = vrhAllowedRuntimeClassNames(rulesAllowedRuntimeClassNames)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RuntimeClassStrategyOptions.allowed_runtime_class_names: %s", err)
		panic(errMsg)
	}
	v.FldValidators["allowed_runtime_class_names"] = vFn

	vrhDefaultRuntimeClassName := v.DefaultRuntimeClassNameValidationRuleHandler
	rulesDefaultRuntimeClassName := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhDefaultRuntimeClassName(rulesDefaultRuntimeClassName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RuntimeClassStrategyOptions.default_runtime_class_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["default_runtime_class_name"] = vFn

	return v
}()

func RuntimeClassStrategyOptionsValidator() db.Validator {
	return DefaultRuntimeClassStrategyOptionsValidator
}

// augmented methods on protoc/std generated struct

func (m *SELinuxStrategyOptions) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SELinuxStrategyOptions) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SELinuxStrategyOptions) DeepCopy() *SELinuxStrategyOptions {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SELinuxStrategyOptions{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SELinuxStrategyOptions) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SELinuxStrategyOptions) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SELinuxStrategyOptionsValidator().Validate(ctx, m, opts...)
}

type ValidateSELinuxStrategyOptions struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSELinuxStrategyOptions) RuleValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for rule")
	}

	return validatorFn, nil
}

func (v *ValidateSELinuxStrategyOptions) LevelValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for Level")
	}

	return validatorFn, nil
}

func (v *ValidateSELinuxStrategyOptions) RoleValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for role")
	}

	return validatorFn, nil
}

func (v *ValidateSELinuxStrategyOptions) TypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for type")
	}

	return validatorFn, nil
}

func (v *ValidateSELinuxStrategyOptions) UserValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for user")
	}

	return validatorFn, nil
}

func (v *ValidateSELinuxStrategyOptions) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SELinuxStrategyOptions)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SELinuxStrategyOptions got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["Level"]; exists {

		vOpts := append(opts, db.WithValidateField("Level"))
		if err := fv(ctx, m.GetLevel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["role"]; exists {

		vOpts := append(opts, db.WithValidateField("role"))
		if err := fv(ctx, m.GetRole(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rule"]; exists {

		vOpts := append(opts, db.WithValidateField("rule"))
		if err := fv(ctx, m.GetRule(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user"]; exists {

		vOpts := append(opts, db.WithValidateField("user"))
		if err := fv(ctx, m.GetUser(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSELinuxStrategyOptionsValidator = func() *ValidateSELinuxStrategyOptions {
	v := &ValidateSELinuxStrategyOptions{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhRule := v.RuleValidationRuleHandler
	rulesRule := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "128",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhRule(rulesRule)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SELinuxStrategyOptions.rule: %s", err)
		panic(errMsg)
	}
	v.FldValidators["rule"] = vFn

	vrhLevel := v.LevelValidationRuleHandler
	rulesLevel := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhLevel(rulesLevel)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SELinuxStrategyOptions.Level: %s", err)
		panic(errMsg)
	}
	v.FldValidators["Level"] = vFn

	vrhRole := v.RoleValidationRuleHandler
	rulesRole := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhRole(rulesRole)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SELinuxStrategyOptions.role: %s", err)
		panic(errMsg)
	}
	v.FldValidators["role"] = vFn

	vrhType := v.TypeValidationRuleHandler
	rulesType := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhType(rulesType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SELinuxStrategyOptions.type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["type"] = vFn

	vrhUser := v.UserValidationRuleHandler
	rulesUser := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhUser(rulesUser)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for SELinuxStrategyOptions.user: %s", err)
		panic(errMsg)
	}
	v.FldValidators["user"] = vFn

	return v
}()

func SELinuxStrategyOptionsValidator() db.Validator {
	return DefaultSELinuxStrategyOptionsValidator
}

// create setters in CreateSpecType from GlobalSpecType for oneof fields
func (r *CreateSpecType) SetConfigMethodChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ConfigMethodChoice.(type) {
	case nil:
		o.ConfigMethodChoice = nil

	case *CreateSpecType_PspSpec:
		o.ConfigMethodChoice = &GlobalSpecType_PspSpec{PspSpec: of.PspSpec}

	case *CreateSpecType_Yaml:
		o.ConfigMethodChoice = &GlobalSpecType_Yaml{Yaml: of.Yaml}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *CreateSpecType) GetConfigMethodChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ConfigMethodChoice.(type) {
	case nil:
		r.ConfigMethodChoice = nil

	case *GlobalSpecType_PspSpec:
		r.ConfigMethodChoice = &CreateSpecType_PspSpec{PspSpec: of.PspSpec}

	case *GlobalSpecType_Yaml:
		r.ConfigMethodChoice = &CreateSpecType_Yaml{Yaml: of.Yaml}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.GetConfigMethodChoiceFromGlobalSpecType(f)
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	m1.SetConfigMethodChoiceToGlobalSpecType(f)
}

// create setters in GetSpecType from GlobalSpecType for oneof fields
func (r *GetSpecType) SetConfigMethodChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ConfigMethodChoice.(type) {
	case nil:
		o.ConfigMethodChoice = nil

	case *GetSpecType_PspSpec:
		o.ConfigMethodChoice = &GlobalSpecType_PspSpec{PspSpec: of.PspSpec}

	case *GetSpecType_Yaml:
		o.ConfigMethodChoice = &GlobalSpecType_Yaml{Yaml: of.Yaml}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *GetSpecType) GetConfigMethodChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ConfigMethodChoice.(type) {
	case nil:
		r.ConfigMethodChoice = nil

	case *GlobalSpecType_PspSpec:
		r.ConfigMethodChoice = &GetSpecType_PspSpec{PspSpec: of.PspSpec}

	case *GlobalSpecType_Yaml:
		r.ConfigMethodChoice = &GetSpecType_Yaml{Yaml: of.Yaml}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.GetConfigMethodChoiceFromGlobalSpecType(f)
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	m1.SetConfigMethodChoiceToGlobalSpecType(f)
}

// create setters in ReplaceSpecType from GlobalSpecType for oneof fields
func (r *ReplaceSpecType) SetConfigMethodChoiceToGlobalSpecType(o *GlobalSpecType) error {
	switch of := r.ConfigMethodChoice.(type) {
	case nil:
		o.ConfigMethodChoice = nil

	case *ReplaceSpecType_PspSpec:
		o.ConfigMethodChoice = &GlobalSpecType_PspSpec{PspSpec: of.PspSpec}

	case *ReplaceSpecType_Yaml:
		o.ConfigMethodChoice = &GlobalSpecType_Yaml{Yaml: of.Yaml}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (r *ReplaceSpecType) GetConfigMethodChoiceFromGlobalSpecType(o *GlobalSpecType) error {
	switch of := o.ConfigMethodChoice.(type) {
	case nil:
		r.ConfigMethodChoice = nil

	case *GlobalSpecType_PspSpec:
		r.ConfigMethodChoice = &ReplaceSpecType_PspSpec{PspSpec: of.PspSpec}

	case *GlobalSpecType_Yaml:
		r.ConfigMethodChoice = &ReplaceSpecType_Yaml{Yaml: of.Yaml}

	default:
		return fmt.Errorf("Unknown oneof field %T", of)
	}
	return nil
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	if f == nil {
		return
	}
	m.GetConfigMethodChoiceFromGlobalSpecType(f)
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m1 := m.DeepCopy()
	_ = m1
	if f == nil {
		return
	}
	m1.SetConfigMethodChoiceToGlobalSpecType(f)
}
