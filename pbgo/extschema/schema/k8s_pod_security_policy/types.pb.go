// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/k8s_pod_security_policy/types.proto

package k8s_pod_security_policy

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Capability List
//
// x-displayName: "Capability List"
// List of capabilities that docker container has.
type CapabilityListType struct {
	// Capability List
	//
	// x-displayName: "Capability List"
	// x-required
	// List of capabilities that docker container has.
	Capabilities []string `protobuf:"bytes,1,rep,name=capabilities,proto3" json:"capabilities,omitempty"`
}

func (m *CapabilityListType) Reset()      { *m = CapabilityListType{} }
func (*CapabilityListType) ProtoMessage() {}
func (*CapabilityListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_669bbfbe00eebfa8, []int{0}
}
func (m *CapabilityListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CapabilityListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CapabilityListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CapabilityListType.Merge(m, src)
}
func (m *CapabilityListType) XXX_Size() int {
	return m.Size()
}
func (m *CapabilityListType) XXX_DiscardUnknown() {
	xxx_messageInfo_CapabilityListType.DiscardUnknown(m)
}

var xxx_messageInfo_CapabilityListType proto.InternalMessageInfo

func (m *CapabilityListType) GetCapabilities() []string {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

// Host Path
//
// x-displayName: "Host Path"
// Host path and read/write or read-only
type HostPathType struct {
	// Host Path Prefix
	//
	// x-displayName: "Host Path Prefix"
	// x-required
	// Host path prefix is the path prefix that the host volume must match. It does not support *.
	PathPrefix string `protobuf:"bytes,1,opt,name=path_prefix,json=pathPrefix,proto3" json:"path_prefix,omitempty"`
	// Read Only
	//
	// x-displayName: "Read Only"
	// This volume will be allowed to mount read only.
	ReadOnly bool `protobuf:"varint,2,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
}

func (m *HostPathType) Reset()      { *m = HostPathType{} }
func (*HostPathType) ProtoMessage() {}
func (*HostPathType) Descriptor() ([]byte, []int) {
	return fileDescriptor_669bbfbe00eebfa8, []int{1}
}
func (m *HostPathType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HostPathType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *HostPathType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HostPathType.Merge(m, src)
}
func (m *HostPathType) XXX_Size() int {
	return m.Size()
}
func (m *HostPathType) XXX_DiscardUnknown() {
	xxx_messageInfo_HostPathType.DiscardUnknown(m)
}

var xxx_messageInfo_HostPathType proto.InternalMessageInfo

func (m *HostPathType) GetPathPrefix() string {
	if m != nil {
		return m.PathPrefix
	}
	return ""
}

func (m *HostPathType) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

type IDRangeType struct {
	// Starting ID
	//
	// x-displayName: "Starting ID"
	// x-required
	// x-example: "2000"
	// Starting(minimum) ID for for ID range
	MinId uint32 `protobuf:"varint,1,opt,name=min_id,json=minId,proto3" json:"min_id,omitempty"`
	// Ending ID
	//
	// x-displayName: "Ending ID"
	// x-required
	// x-example: "3000"
	// Ending(maximum) ID for for ID range
	MaxId uint32 `protobuf:"varint,2,opt,name=max_id,json=maxId,proto3" json:"max_id,omitempty"`
}

func (m *IDRangeType) Reset()      { *m = IDRangeType{} }
func (*IDRangeType) ProtoMessage() {}
func (*IDRangeType) Descriptor() ([]byte, []int) {
	return fileDescriptor_669bbfbe00eebfa8, []int{2}
}
func (m *IDRangeType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IDRangeType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IDRangeType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IDRangeType.Merge(m, src)
}
func (m *IDRangeType) XXX_Size() int {
	return m.Size()
}
func (m *IDRangeType) XXX_DiscardUnknown() {
	xxx_messageInfo_IDRangeType.DiscardUnknown(m)
}

var xxx_messageInfo_IDRangeType proto.InternalMessageInfo

func (m *IDRangeType) GetMinId() uint32 {
	if m != nil {
		return m.MinId
	}
	return 0
}

func (m *IDRangeType) GetMaxId() uint32 {
	if m != nil {
		return m.MaxId
	}
	return 0
}

// ID(User,Group,FSGroup) Strategy
//
// x-displayName: "ID(User,Group,FSGroup) Strategy"
// ID ranges and rules
type IDStrategyOptionsType struct {
	// ID Ranges
	//
	// x-displayName: "ID Ranges"
	// List of range of  ID(s)
	IdRanges []*IDRangeType `protobuf:"bytes,1,rep,name=id_ranges,json=idRanges,proto3" json:"id_ranges,omitempty"`
	// Rule
	//
	// x-displayName: "Rule"
	// x-example: "MustRunAs"
	// Rule indicated how the FS group ID range is used
	Rule string `protobuf:"bytes,2,opt,name=rule,proto3" json:"rule,omitempty"`
}

func (m *IDStrategyOptionsType) Reset()      { *m = IDStrategyOptionsType{} }
func (*IDStrategyOptionsType) ProtoMessage() {}
func (*IDStrategyOptionsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_669bbfbe00eebfa8, []int{3}
}
func (m *IDStrategyOptionsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IDStrategyOptionsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IDStrategyOptionsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IDStrategyOptionsType.Merge(m, src)
}
func (m *IDStrategyOptionsType) XXX_Size() int {
	return m.Size()
}
func (m *IDStrategyOptionsType) XXX_DiscardUnknown() {
	xxx_messageInfo_IDStrategyOptionsType.DiscardUnknown(m)
}

var xxx_messageInfo_IDStrategyOptionsType proto.InternalMessageInfo

func (m *IDStrategyOptionsType) GetIdRanges() []*IDRangeType {
	if m != nil {
		return m.IdRanges
	}
	return nil
}

func (m *IDStrategyOptionsType) GetRule() string {
	if m != nil {
		return m.Rule
	}
	return ""
}

// Runtime Class Strategy
//
// x-displayName: "Runtime Class Strategy"
// Allowed runtime classes
type RuntimeClassStrategyOptions struct {
	// Allowed Runtime Classes
	//
	// x-displayName: "Allowed Runtime Classes"
	// x-required
	// List of allowed runtime class names
	AllowedRuntimeClassNames []string `protobuf:"bytes,1,rep,name=allowed_runtime_class_names,json=allowedRuntimeClassNames,proto3" json:"allowed_runtime_class_names,omitempty"`
	// Default Runtime Class
	//
	// x-displayName: "Default Runtime Class"
	// description
	DefaultRuntimeClassName string `protobuf:"bytes,2,opt,name=default_runtime_class_name,json=defaultRuntimeClassName,proto3" json:"default_runtime_class_name,omitempty"`
}

func (m *RuntimeClassStrategyOptions) Reset()      { *m = RuntimeClassStrategyOptions{} }
func (*RuntimeClassStrategyOptions) ProtoMessage() {}
func (*RuntimeClassStrategyOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_669bbfbe00eebfa8, []int{4}
}
func (m *RuntimeClassStrategyOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuntimeClassStrategyOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RuntimeClassStrategyOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuntimeClassStrategyOptions.Merge(m, src)
}
func (m *RuntimeClassStrategyOptions) XXX_Size() int {
	return m.Size()
}
func (m *RuntimeClassStrategyOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_RuntimeClassStrategyOptions.DiscardUnknown(m)
}

var xxx_messageInfo_RuntimeClassStrategyOptions proto.InternalMessageInfo

func (m *RuntimeClassStrategyOptions) GetAllowedRuntimeClassNames() []string {
	if m != nil {
		return m.AllowedRuntimeClassNames
	}
	return nil
}

func (m *RuntimeClassStrategyOptions) GetDefaultRuntimeClassName() string {
	if m != nil {
		return m.DefaultRuntimeClassName
	}
	return ""
}

// SE Linux Strategy
//
// x-displayName: "SE Linux Strategy"
//
type SELinuxStrategyOptions struct {
	// Rule
	//
	// x-displayName: "Rule"
	// x-example: "MustRunAs"
	// Rule indicated how the FS group ID range is used
	Rule string `protobuf:"bytes,1,opt,name=rule,proto3" json:"rule,omitempty"`
	// SE Linux Level
	//
	// x-displayName: "SE Linux Level"
	// x-example: "secret"
	// Run as SE linux level label
	Level string `protobuf:"bytes,2,opt,name=Level,proto3" json:"Level,omitempty"`
	// SE Linux Role
	//
	// x-displayName: "SE Linux Role"
	// x-example: "admin_r"
	// Run as SE linux label
	Role string `protobuf:"bytes,3,opt,name=role,proto3" json:"role,omitempty"`
	// SE Linux Type
	//
	// x-displayName: "SE Linux Type"
	// x-example: "admin_t"
	// Run as SE linux type label
	Type string `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
	// SE Linux User
	//
	// x-displayName: "SE Linux User"
	// x-example: "system_u"
	// Run as SE linux user label
	User string `protobuf:"bytes,5,opt,name=user,proto3" json:"user,omitempty"`
}

func (m *SELinuxStrategyOptions) Reset()      { *m = SELinuxStrategyOptions{} }
func (*SELinuxStrategyOptions) ProtoMessage() {}
func (*SELinuxStrategyOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_669bbfbe00eebfa8, []int{5}
}
func (m *SELinuxStrategyOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SELinuxStrategyOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SELinuxStrategyOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SELinuxStrategyOptions.Merge(m, src)
}
func (m *SELinuxStrategyOptions) XXX_Size() int {
	return m.Size()
}
func (m *SELinuxStrategyOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_SELinuxStrategyOptions.DiscardUnknown(m)
}

var xxx_messageInfo_SELinuxStrategyOptions proto.InternalMessageInfo

func (m *SELinuxStrategyOptions) GetRule() string {
	if m != nil {
		return m.Rule
	}
	return ""
}

func (m *SELinuxStrategyOptions) GetLevel() string {
	if m != nil {
		return m.Level
	}
	return ""
}

func (m *SELinuxStrategyOptions) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *SELinuxStrategyOptions) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *SELinuxStrategyOptions) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

// Pod Security Policy Specification
//
// x-displayName: "Pod Security Policy Specification"
// Form based pod security specification
type PodSecurityPolicySpecType struct {
	// Privileged
	//
	// x-displayName: "Privileged"
	// Privileged determines if a pod can request to be run as privileged.
	Privileged bool `protobuf:"varint,1,opt,name=privileged,proto3" json:"privileged,omitempty"`
	// Allow Privilege Escalation
	//
	// x-displayName: "Allow Privilege Escalation"
	// Pod can request to privilege escalation
	AllowPrivilegeEscalation bool `protobuf:"varint,2,opt,name=allow_privilege_escalation,json=allowPrivilegeEscalation,proto3" json:"allow_privilege_escalation,omitempty"`
	// Default Allow Privilege Escalation
	//
	// x-displayName: "Default Allow Privilege Escalation"
	// Pod has permission for privilege escalation by default
	DefaultAllowPrivilegeEscalation bool `protobuf:"varint,3,opt,name=default_allow_privilege_escalation,json=defaultAllowPrivilegeEscalation,proto3" json:"default_allow_privilege_escalation,omitempty"`
	// Change Default Capabilities
	//
	// x-displayName: "Change Default Capabilities"
	// x-required
	// Select to use K8s default or custom default capabilities
	//
	// Types that are valid to be assigned to DefaultCapabilitiesChoice:
	//	*PodSecurityPolicySpecType_NoDefaultCapabilities
	//	*PodSecurityPolicySpecType_DefaultCapabilities
	DefaultCapabilitiesChoice isPodSecurityPolicySpecType_DefaultCapabilitiesChoice `protobuf_oneof:"default_capabilities_choice"`
	// Allowed Add Capabilities
	//
	// x-displayName: "Allowed Add Capabilities"
	// x-required
	// Select to allow adding of capabilities to the POD
	//
	// Types that are valid to be assigned to AllowedCapabilitiesChoice:
	//	*PodSecurityPolicySpecType_NoAllowedCapabilities
	//	*PodSecurityPolicySpecType_AllowedCapabilities
	AllowedCapabilitiesChoice isPodSecurityPolicySpecType_AllowedCapabilitiesChoice `protobuf_oneof:"allowed_capabilities_choice"`
	// Drop from K8s Default Capabilities
	//
	// x-displayName: "Drop from K8s Default Capabilities"
	// x-required
	// Select to drop from default capabilities
	//
	// Types that are valid to be assigned to DropCapabilitiesChoice:
	//	*PodSecurityPolicySpecType_NoDropCapabilities
	//	*PodSecurityPolicySpecType_DropCapabilities
	DropCapabilitiesChoice isPodSecurityPolicySpecType_DropCapabilitiesChoice `protobuf_oneof:"drop_capabilities_choice"`
	// Volumes
	//
	// x-displayName: "Volume"
	// Allow List of volume plugins. Empty no volumes are allowed
	Volumes []string `protobuf:"bytes,13,rep,name=volumes,proto3" json:"volumes,omitempty"`
	// Allowed Flex Volumes
	//
	// x-displayName: "Allowed Flex Volumes"
	// Restrict list of Flex volumes, default all volumes are allowed
	AllowedFlexVolumes []string `protobuf:"bytes,14,rep,name=allowed_flex_volumes,json=allowedFlexVolumes,proto3" json:"allowed_flex_volumes,omitempty"`
	// Allowed Host Paths
	//
	// x-displayName: "Allowed Host Paths"
	// Restrict list of host paths, default all host paths are allowed
	AllowedHostPaths []*HostPathType `protobuf:"bytes,15,rep,name=allowed_host_paths,json=allowedHostPaths,proto3" json:"allowed_host_paths,omitempty"`
	// Allowed Proc Mounts
	//
	// x-displayName: "Allowed Proc Mounts"
	// allowed list of proc mounts, empty list allows default proc mounts.
	AllowedProcMounts []string `protobuf:"bytes,16,rep,name=allowed_proc_mounts,json=allowedProcMounts,proto3" json:"allowed_proc_mounts,omitempty"`
	// Read Only Root Filesystem
	//
	// x-displayName: "Read Only Root Filesystem"
	// Containers can only run with read only root filesystem.
	ReadOnlyRootFilesystem bool `protobuf:"varint,17,opt,name=read_only_root_filesystem,json=readOnlyRootFilesystem,proto3" json:"read_only_root_filesystem,omitempty"`
	// Allowed CSI drivers
	//
	// x-displayName: "Allowed CSI drivers"
	// Restrict the available CSI drivers for POD, default all drivers are available.
	AllowedCsiDrivers []string `protobuf:"bytes,18,rep,name=allowed_csi_drivers,json=allowedCsiDrivers,proto3" json:"allowed_csi_drivers,omitempty"`
	// Host Network
	//
	// x-displayName: "Host Network"
	// Host Network determines if the policy allows the use of host network in the pod spec.
	HostNetwork bool `protobuf:"varint,19,opt,name=host_network,json=hostNetwork,proto3" json:"host_network,omitempty"`
	// Host Port Ranges
	//
	// x-displayName: "Host Ports Ranges"
	// x-example: "80,443,8080-8191,9080"
	// Host port ranges determines which ports ranges are allowed to be exposed
	HostPortRanges string `protobuf:"bytes,20,opt,name=host_port_ranges,json=hostPortRanges,proto3" json:"host_port_ranges,omitempty"`
	// Host IPC
	//
	// x-displayName: "Host IPC"
	// Host IPC determines if the policy allows the use of host IPC in the pod spec.
	HostIpc bool `protobuf:"varint,21,opt,name=host_ipc,json=hostIpc,proto3" json:"host_ipc,omitempty"`
	// Host PID
	//
	// x-displayName: "Host PID"
	// Host PID determines if the policy allows the use of host PID in the pod spec.
	HostPid bool `protobuf:"varint,22,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty"`
	// Allowed Unsafe Sysctls
	//
	// x-displayName: "Allowed Unsafe Sysctls"
	// allowed list of unsafe sysctls, empty list allows none. supports prefix reg-ex
	AllowedUnsafeSysctls []string `protobuf:"bytes,23,rep,name=allowed_unsafe_sysctls,json=allowedUnsafeSysctls,proto3" json:"allowed_unsafe_sysctls,omitempty"`
	// Forbidden Sysctls
	//
	// x-displayName: "Forbidden Sysctls"
	// Forbidden list of sysctls, empty list forbids none. supports prefix reg-ex
	ForbiddenSysctls []string `protobuf:"bytes,24,rep,name=forbidden_sysctls,json=forbiddenSysctls,proto3" json:"forbidden_sysctls,omitempty"`
	// Runs As User
	//
	// x-displayName: "Select Runs As User"
	// x-required
	// Restrict user id  allowed in runs as user
	//
	// Types that are valid to be assigned to UserChoice:
	//	*PodSecurityPolicySpecType_NoRunAsUser
	//	*PodSecurityPolicySpecType_RunAsUser
	UserChoice isPodSecurityPolicySpecType_UserChoice `protobuf_oneof:"user_choice"`
	// Runs As Group
	//
	// x-displayName: "Select Runs As Group"
	// x-required
	// Restrict user id  allowed in runs as user
	//
	// Types that are valid to be assigned to GroupChoice:
	//	*PodSecurityPolicySpecType_NoRunAsGroup
	//	*PodSecurityPolicySpecType_RunAsGroup
	GroupChoice isPodSecurityPolicySpecType_GroupChoice `protobuf_oneof:"group_choice"`
	// Supplemental Groups
	//
	// x-displayName: "Select Supplemental Groups"
	// x-required
	// Restrict supplemental groups that are allowed
	//
	// Types that are valid to be assigned to SupplementalGroupChoice:
	//	*PodSecurityPolicySpecType_NoSupplementalGroups
	//	*PodSecurityPolicySpecType_SupplementalGroups
	SupplementalGroupChoice isPodSecurityPolicySpecType_SupplementalGroupChoice `protobuf_oneof:"supplemental_group_choice"`
	// FS Groups
	//
	// x-displayName: "Select FS Groups"
	// x-required
	// Restrict FS groups that are allowed
	//
	// Types that are valid to be assigned to FsGroupChoice:
	//	*PodSecurityPolicySpecType_NoFsGroups
	//	*PodSecurityPolicySpecType_FsGroupStrategyOptions
	FsGroupChoice isPodSecurityPolicySpecType_FsGroupChoice `protobuf_oneof:"fs_group_choice"`
	// Select SE Linux Options
	//
	// x-displayName: "Select SE Linux Options"
	// x-required
	// Select if SE Linux options are allowed in security context
	//
	// Types that are valid to be assigned to SeLinuxChoice:
	//	*PodSecurityPolicySpecType_NoSeLinuxOptions
	//	*PodSecurityPolicySpecType_SeLinuxOptions
	SeLinuxChoice isPodSecurityPolicySpecType_SeLinuxChoice `protobuf_oneof:"se_linux_choice"`
	// Select Run Time Class Option
	//
	// x-displayName: "Select Run Time Class Option"
	// x-required
	// Select if runtime class is allowed in security context
	//
	// Types that are valid to be assigned to RuntimeClassChoice:
	//	*PodSecurityPolicySpecType_NoRuntimeClass
	//	*PodSecurityPolicySpecType_RuntimeClass
	RuntimeClassChoice isPodSecurityPolicySpecType_RuntimeClassChoice `protobuf_oneof:"runtime_class_choice"`
}

func (m *PodSecurityPolicySpecType) Reset()      { *m = PodSecurityPolicySpecType{} }
func (*PodSecurityPolicySpecType) ProtoMessage() {}
func (*PodSecurityPolicySpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_669bbfbe00eebfa8, []int{6}
}
func (m *PodSecurityPolicySpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodSecurityPolicySpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PodSecurityPolicySpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodSecurityPolicySpecType.Merge(m, src)
}
func (m *PodSecurityPolicySpecType) XXX_Size() int {
	return m.Size()
}
func (m *PodSecurityPolicySpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_PodSecurityPolicySpecType.DiscardUnknown(m)
}

var xxx_messageInfo_PodSecurityPolicySpecType proto.InternalMessageInfo

type isPodSecurityPolicySpecType_DefaultCapabilitiesChoice interface {
	isPodSecurityPolicySpecType_DefaultCapabilitiesChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isPodSecurityPolicySpecType_AllowedCapabilitiesChoice interface {
	isPodSecurityPolicySpecType_AllowedCapabilitiesChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isPodSecurityPolicySpecType_DropCapabilitiesChoice interface {
	isPodSecurityPolicySpecType_DropCapabilitiesChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isPodSecurityPolicySpecType_UserChoice interface {
	isPodSecurityPolicySpecType_UserChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isPodSecurityPolicySpecType_GroupChoice interface {
	isPodSecurityPolicySpecType_GroupChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isPodSecurityPolicySpecType_SupplementalGroupChoice interface {
	isPodSecurityPolicySpecType_SupplementalGroupChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isPodSecurityPolicySpecType_FsGroupChoice interface {
	isPodSecurityPolicySpecType_FsGroupChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isPodSecurityPolicySpecType_SeLinuxChoice interface {
	isPodSecurityPolicySpecType_SeLinuxChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}
type isPodSecurityPolicySpecType_RuntimeClassChoice interface {
	isPodSecurityPolicySpecType_RuntimeClassChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PodSecurityPolicySpecType_NoDefaultCapabilities struct {
	NoDefaultCapabilities *schema.Empty `protobuf:"bytes,5,opt,name=no_default_capabilities,json=noDefaultCapabilities,proto3,oneof" json:"no_default_capabilities,omitempty"`
}
type PodSecurityPolicySpecType_DefaultCapabilities struct {
	DefaultCapabilities *CapabilityListType `protobuf:"bytes,6,opt,name=default_capabilities,json=defaultCapabilities,proto3,oneof" json:"default_capabilities,omitempty"`
}
type PodSecurityPolicySpecType_NoAllowedCapabilities struct {
	NoAllowedCapabilities *schema.Empty `protobuf:"bytes,8,opt,name=no_allowed_capabilities,json=noAllowedCapabilities,proto3,oneof" json:"no_allowed_capabilities,omitempty"`
}
type PodSecurityPolicySpecType_AllowedCapabilities struct {
	AllowedCapabilities *CapabilityListType `protobuf:"bytes,9,opt,name=allowed_capabilities,json=allowedCapabilities,proto3,oneof" json:"allowed_capabilities,omitempty"`
}
type PodSecurityPolicySpecType_NoDropCapabilities struct {
	NoDropCapabilities *schema.Empty `protobuf:"bytes,11,opt,name=no_drop_capabilities,json=noDropCapabilities,proto3,oneof" json:"no_drop_capabilities,omitempty"`
}
type PodSecurityPolicySpecType_DropCapabilities struct {
	DropCapabilities *CapabilityListType `protobuf:"bytes,12,opt,name=drop_capabilities,json=dropCapabilities,proto3,oneof" json:"drop_capabilities,omitempty"`
}
type PodSecurityPolicySpecType_NoRunAsUser struct {
	NoRunAsUser *schema.Empty `protobuf:"bytes,26,opt,name=no_run_as_user,json=noRunAsUser,proto3,oneof" json:"no_run_as_user,omitempty"`
}
type PodSecurityPolicySpecType_RunAsUser struct {
	RunAsUser *IDStrategyOptionsType `protobuf:"bytes,27,opt,name=run_as_user,json=runAsUser,proto3,oneof" json:"run_as_user,omitempty"`
}
type PodSecurityPolicySpecType_NoRunAsGroup struct {
	NoRunAsGroup *schema.Empty `protobuf:"bytes,29,opt,name=no_run_as_group,json=noRunAsGroup,proto3,oneof" json:"no_run_as_group,omitempty"`
}
type PodSecurityPolicySpecType_RunAsGroup struct {
	RunAsGroup *IDStrategyOptionsType `protobuf:"bytes,30,opt,name=run_as_group,json=runAsGroup,proto3,oneof" json:"run_as_group,omitempty"`
}
type PodSecurityPolicySpecType_NoSupplementalGroups struct {
	NoSupplementalGroups *schema.Empty `protobuf:"bytes,32,opt,name=no_supplemental_groups,json=noSupplementalGroups,proto3,oneof" json:"no_supplemental_groups,omitempty"`
}
type PodSecurityPolicySpecType_SupplementalGroups struct {
	SupplementalGroups *IDStrategyOptionsType `protobuf:"bytes,33,opt,name=supplemental_groups,json=supplementalGroups,proto3,oneof" json:"supplemental_groups,omitempty"`
}
type PodSecurityPolicySpecType_NoFsGroups struct {
	NoFsGroups *schema.Empty `protobuf:"bytes,35,opt,name=no_fs_groups,json=noFsGroups,proto3,oneof" json:"no_fs_groups,omitempty"`
}
type PodSecurityPolicySpecType_FsGroupStrategyOptions struct {
	FsGroupStrategyOptions *IDStrategyOptionsType `protobuf:"bytes,36,opt,name=fs_group_strategy_options,json=fsGroupStrategyOptions,proto3,oneof" json:"fs_group_strategy_options,omitempty"`
}
type PodSecurityPolicySpecType_NoSeLinuxOptions struct {
	NoSeLinuxOptions *schema.Empty `protobuf:"bytes,38,opt,name=no_se_linux_options,json=noSeLinuxOptions,proto3,oneof" json:"no_se_linux_options,omitempty"`
}
type PodSecurityPolicySpecType_SeLinuxOptions struct {
	SeLinuxOptions *SELinuxStrategyOptions `protobuf:"bytes,39,opt,name=se_linux_options,json=seLinuxOptions,proto3,oneof" json:"se_linux_options,omitempty"`
}
type PodSecurityPolicySpecType_NoRuntimeClass struct {
	NoRuntimeClass *schema.Empty `protobuf:"bytes,41,opt,name=no_runtime_class,json=noRuntimeClass,proto3,oneof" json:"no_runtime_class,omitempty"`
}
type PodSecurityPolicySpecType_RuntimeClass struct {
	RuntimeClass *RuntimeClassStrategyOptions `protobuf:"bytes,42,opt,name=runtime_class,json=runtimeClass,proto3,oneof" json:"runtime_class,omitempty"`
}

func (*PodSecurityPolicySpecType_NoDefaultCapabilities) isPodSecurityPolicySpecType_DefaultCapabilitiesChoice() {
}
func (*PodSecurityPolicySpecType_DefaultCapabilities) isPodSecurityPolicySpecType_DefaultCapabilitiesChoice() {
}
func (*PodSecurityPolicySpecType_NoAllowedCapabilities) isPodSecurityPolicySpecType_AllowedCapabilitiesChoice() {
}
func (*PodSecurityPolicySpecType_AllowedCapabilities) isPodSecurityPolicySpecType_AllowedCapabilitiesChoice() {
}
func (*PodSecurityPolicySpecType_NoDropCapabilities) isPodSecurityPolicySpecType_DropCapabilitiesChoice() {
}
func (*PodSecurityPolicySpecType_DropCapabilities) isPodSecurityPolicySpecType_DropCapabilitiesChoice() {
}
func (*PodSecurityPolicySpecType_NoRunAsUser) isPodSecurityPolicySpecType_UserChoice()   {}
func (*PodSecurityPolicySpecType_RunAsUser) isPodSecurityPolicySpecType_UserChoice()     {}
func (*PodSecurityPolicySpecType_NoRunAsGroup) isPodSecurityPolicySpecType_GroupChoice() {}
func (*PodSecurityPolicySpecType_RunAsGroup) isPodSecurityPolicySpecType_GroupChoice()   {}
func (*PodSecurityPolicySpecType_NoSupplementalGroups) isPodSecurityPolicySpecType_SupplementalGroupChoice() {
}
func (*PodSecurityPolicySpecType_SupplementalGroups) isPodSecurityPolicySpecType_SupplementalGroupChoice() {
}
func (*PodSecurityPolicySpecType_NoFsGroups) isPodSecurityPolicySpecType_FsGroupChoice() {}
func (*PodSecurityPolicySpecType_FsGroupStrategyOptions) isPodSecurityPolicySpecType_FsGroupChoice() {
}
func (*PodSecurityPolicySpecType_NoSeLinuxOptions) isPodSecurityPolicySpecType_SeLinuxChoice()    {}
func (*PodSecurityPolicySpecType_SeLinuxOptions) isPodSecurityPolicySpecType_SeLinuxChoice()      {}
func (*PodSecurityPolicySpecType_NoRuntimeClass) isPodSecurityPolicySpecType_RuntimeClassChoice() {}
func (*PodSecurityPolicySpecType_RuntimeClass) isPodSecurityPolicySpecType_RuntimeClassChoice()   {}

func (m *PodSecurityPolicySpecType) GetDefaultCapabilitiesChoice() isPodSecurityPolicySpecType_DefaultCapabilitiesChoice {
	if m != nil {
		return m.DefaultCapabilitiesChoice
	}
	return nil
}
func (m *PodSecurityPolicySpecType) GetAllowedCapabilitiesChoice() isPodSecurityPolicySpecType_AllowedCapabilitiesChoice {
	if m != nil {
		return m.AllowedCapabilitiesChoice
	}
	return nil
}
func (m *PodSecurityPolicySpecType) GetDropCapabilitiesChoice() isPodSecurityPolicySpecType_DropCapabilitiesChoice {
	if m != nil {
		return m.DropCapabilitiesChoice
	}
	return nil
}
func (m *PodSecurityPolicySpecType) GetUserChoice() isPodSecurityPolicySpecType_UserChoice {
	if m != nil {
		return m.UserChoice
	}
	return nil
}
func (m *PodSecurityPolicySpecType) GetGroupChoice() isPodSecurityPolicySpecType_GroupChoice {
	if m != nil {
		return m.GroupChoice
	}
	return nil
}
func (m *PodSecurityPolicySpecType) GetSupplementalGroupChoice() isPodSecurityPolicySpecType_SupplementalGroupChoice {
	if m != nil {
		return m.SupplementalGroupChoice
	}
	return nil
}
func (m *PodSecurityPolicySpecType) GetFsGroupChoice() isPodSecurityPolicySpecType_FsGroupChoice {
	if m != nil {
		return m.FsGroupChoice
	}
	return nil
}
func (m *PodSecurityPolicySpecType) GetSeLinuxChoice() isPodSecurityPolicySpecType_SeLinuxChoice {
	if m != nil {
		return m.SeLinuxChoice
	}
	return nil
}
func (m *PodSecurityPolicySpecType) GetRuntimeClassChoice() isPodSecurityPolicySpecType_RuntimeClassChoice {
	if m != nil {
		return m.RuntimeClassChoice
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetPrivileged() bool {
	if m != nil {
		return m.Privileged
	}
	return false
}

func (m *PodSecurityPolicySpecType) GetAllowPrivilegeEscalation() bool {
	if m != nil {
		return m.AllowPrivilegeEscalation
	}
	return false
}

func (m *PodSecurityPolicySpecType) GetDefaultAllowPrivilegeEscalation() bool {
	if m != nil {
		return m.DefaultAllowPrivilegeEscalation
	}
	return false
}

func (m *PodSecurityPolicySpecType) GetNoDefaultCapabilities() *schema.Empty {
	if x, ok := m.GetDefaultCapabilitiesChoice().(*PodSecurityPolicySpecType_NoDefaultCapabilities); ok {
		return x.NoDefaultCapabilities
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetDefaultCapabilities() *CapabilityListType {
	if x, ok := m.GetDefaultCapabilitiesChoice().(*PodSecurityPolicySpecType_DefaultCapabilities); ok {
		return x.DefaultCapabilities
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetNoAllowedCapabilities() *schema.Empty {
	if x, ok := m.GetAllowedCapabilitiesChoice().(*PodSecurityPolicySpecType_NoAllowedCapabilities); ok {
		return x.NoAllowedCapabilities
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetAllowedCapabilities() *CapabilityListType {
	if x, ok := m.GetAllowedCapabilitiesChoice().(*PodSecurityPolicySpecType_AllowedCapabilities); ok {
		return x.AllowedCapabilities
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetNoDropCapabilities() *schema.Empty {
	if x, ok := m.GetDropCapabilitiesChoice().(*PodSecurityPolicySpecType_NoDropCapabilities); ok {
		return x.NoDropCapabilities
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetDropCapabilities() *CapabilityListType {
	if x, ok := m.GetDropCapabilitiesChoice().(*PodSecurityPolicySpecType_DropCapabilities); ok {
		return x.DropCapabilities
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetVolumes() []string {
	if m != nil {
		return m.Volumes
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetAllowedFlexVolumes() []string {
	if m != nil {
		return m.AllowedFlexVolumes
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetAllowedHostPaths() []*HostPathType {
	if m != nil {
		return m.AllowedHostPaths
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetAllowedProcMounts() []string {
	if m != nil {
		return m.AllowedProcMounts
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetReadOnlyRootFilesystem() bool {
	if m != nil {
		return m.ReadOnlyRootFilesystem
	}
	return false
}

func (m *PodSecurityPolicySpecType) GetAllowedCsiDrivers() []string {
	if m != nil {
		return m.AllowedCsiDrivers
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetHostNetwork() bool {
	if m != nil {
		return m.HostNetwork
	}
	return false
}

func (m *PodSecurityPolicySpecType) GetHostPortRanges() string {
	if m != nil {
		return m.HostPortRanges
	}
	return ""
}

func (m *PodSecurityPolicySpecType) GetHostIpc() bool {
	if m != nil {
		return m.HostIpc
	}
	return false
}

func (m *PodSecurityPolicySpecType) GetHostPid() bool {
	if m != nil {
		return m.HostPid
	}
	return false
}

func (m *PodSecurityPolicySpecType) GetAllowedUnsafeSysctls() []string {
	if m != nil {
		return m.AllowedUnsafeSysctls
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetForbiddenSysctls() []string {
	if m != nil {
		return m.ForbiddenSysctls
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetNoRunAsUser() *schema.Empty {
	if x, ok := m.GetUserChoice().(*PodSecurityPolicySpecType_NoRunAsUser); ok {
		return x.NoRunAsUser
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetRunAsUser() *IDStrategyOptionsType {
	if x, ok := m.GetUserChoice().(*PodSecurityPolicySpecType_RunAsUser); ok {
		return x.RunAsUser
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetNoRunAsGroup() *schema.Empty {
	if x, ok := m.GetGroupChoice().(*PodSecurityPolicySpecType_NoRunAsGroup); ok {
		return x.NoRunAsGroup
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetRunAsGroup() *IDStrategyOptionsType {
	if x, ok := m.GetGroupChoice().(*PodSecurityPolicySpecType_RunAsGroup); ok {
		return x.RunAsGroup
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetNoSupplementalGroups() *schema.Empty {
	if x, ok := m.GetSupplementalGroupChoice().(*PodSecurityPolicySpecType_NoSupplementalGroups); ok {
		return x.NoSupplementalGroups
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetSupplementalGroups() *IDStrategyOptionsType {
	if x, ok := m.GetSupplementalGroupChoice().(*PodSecurityPolicySpecType_SupplementalGroups); ok {
		return x.SupplementalGroups
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetNoFsGroups() *schema.Empty {
	if x, ok := m.GetFsGroupChoice().(*PodSecurityPolicySpecType_NoFsGroups); ok {
		return x.NoFsGroups
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetFsGroupStrategyOptions() *IDStrategyOptionsType {
	if x, ok := m.GetFsGroupChoice().(*PodSecurityPolicySpecType_FsGroupStrategyOptions); ok {
		return x.FsGroupStrategyOptions
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetNoSeLinuxOptions() *schema.Empty {
	if x, ok := m.GetSeLinuxChoice().(*PodSecurityPolicySpecType_NoSeLinuxOptions); ok {
		return x.NoSeLinuxOptions
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetSeLinuxOptions() *SELinuxStrategyOptions {
	if x, ok := m.GetSeLinuxChoice().(*PodSecurityPolicySpecType_SeLinuxOptions); ok {
		return x.SeLinuxOptions
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetNoRuntimeClass() *schema.Empty {
	if x, ok := m.GetRuntimeClassChoice().(*PodSecurityPolicySpecType_NoRuntimeClass); ok {
		return x.NoRuntimeClass
	}
	return nil
}

func (m *PodSecurityPolicySpecType) GetRuntimeClass() *RuntimeClassStrategyOptions {
	if x, ok := m.GetRuntimeClassChoice().(*PodSecurityPolicySpecType_RuntimeClass); ok {
		return x.RuntimeClass
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PodSecurityPolicySpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PodSecurityPolicySpecType_NoDefaultCapabilities)(nil),
		(*PodSecurityPolicySpecType_DefaultCapabilities)(nil),
		(*PodSecurityPolicySpecType_NoAllowedCapabilities)(nil),
		(*PodSecurityPolicySpecType_AllowedCapabilities)(nil),
		(*PodSecurityPolicySpecType_NoDropCapabilities)(nil),
		(*PodSecurityPolicySpecType_DropCapabilities)(nil),
		(*PodSecurityPolicySpecType_NoRunAsUser)(nil),
		(*PodSecurityPolicySpecType_RunAsUser)(nil),
		(*PodSecurityPolicySpecType_NoRunAsGroup)(nil),
		(*PodSecurityPolicySpecType_RunAsGroup)(nil),
		(*PodSecurityPolicySpecType_NoSupplementalGroups)(nil),
		(*PodSecurityPolicySpecType_SupplementalGroups)(nil),
		(*PodSecurityPolicySpecType_NoFsGroups)(nil),
		(*PodSecurityPolicySpecType_FsGroupStrategyOptions)(nil),
		(*PodSecurityPolicySpecType_NoSeLinuxOptions)(nil),
		(*PodSecurityPolicySpecType_SeLinuxOptions)(nil),
		(*PodSecurityPolicySpecType_NoRuntimeClass)(nil),
		(*PodSecurityPolicySpecType_RuntimeClass)(nil),
	}
}

// GlobalSpecType
//
// x-displayName: "Global Configuration Specification"
// Configuration specification for K8s Pod Security Policy
type GlobalSpecType struct {
	// Configuration Method
	//
	// x-displayName: "Configuration Method"
	// x-required
	// Select Configuration method, form based or direct K8s YAML
	//
	// Types that are valid to be assigned to ConfigMethodChoice:
	//	*GlobalSpecType_PspSpec
	//	*GlobalSpecType_Yaml
	ConfigMethodChoice isGlobalSpecType_ConfigMethodChoice `protobuf_oneof:"config_method_choice"`
	// K8s YAML
	//
	// x-displayName: "K8s YAML"
	// K8s YAML for ClusterRoleBinding
	GeneratedYaml string `protobuf:"bytes,1001,opt,name=generated_yaml,json=generatedYaml,proto3" json:"generated_yaml,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_669bbfbe00eebfa8, []int{7}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

type isGlobalSpecType_ConfigMethodChoice interface {
	isGlobalSpecType_ConfigMethodChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GlobalSpecType_PspSpec struct {
	PspSpec *PodSecurityPolicySpecType `protobuf:"bytes,2,opt,name=psp_spec,json=pspSpec,proto3,oneof" json:"psp_spec,omitempty"`
}
type GlobalSpecType_Yaml struct {
	Yaml string `protobuf:"bytes,3,opt,name=yaml,proto3,oneof" json:"yaml,omitempty"`
}

func (*GlobalSpecType_PspSpec) isGlobalSpecType_ConfigMethodChoice() {}
func (*GlobalSpecType_Yaml) isGlobalSpecType_ConfigMethodChoice()    {}

func (m *GlobalSpecType) GetConfigMethodChoice() isGlobalSpecType_ConfigMethodChoice {
	if m != nil {
		return m.ConfigMethodChoice
	}
	return nil
}

func (m *GlobalSpecType) GetPspSpec() *PodSecurityPolicySpecType {
	if x, ok := m.GetConfigMethodChoice().(*GlobalSpecType_PspSpec); ok {
		return x.PspSpec
	}
	return nil
}

func (m *GlobalSpecType) GetYaml() string {
	if x, ok := m.GetConfigMethodChoice().(*GlobalSpecType_Yaml); ok {
		return x.Yaml
	}
	return ""
}

func (m *GlobalSpecType) GetGeneratedYaml() string {
	if m != nil {
		return m.GeneratedYaml
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GlobalSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GlobalSpecType_PspSpec)(nil),
		(*GlobalSpecType_Yaml)(nil),
	}
}

// Create k8s_pod_security_policy
//
// x-displayName: "Create Configuration Specification"
// Create k8s_pod_security_policy will create the object in the storage backend for namespace metadata.namespace
type CreateSpecType struct {
	// Types that are valid to be assigned to ConfigMethodChoice:
	//	*CreateSpecType_PspSpec
	//	*CreateSpecType_Yaml
	ConfigMethodChoice isCreateSpecType_ConfigMethodChoice `protobuf_oneof:"config_method_choice"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_669bbfbe00eebfa8, []int{8}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

type isCreateSpecType_ConfigMethodChoice interface {
	isCreateSpecType_ConfigMethodChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type CreateSpecType_PspSpec struct {
	PspSpec *PodSecurityPolicySpecType `protobuf:"bytes,2,opt,name=psp_spec,json=pspSpec,proto3,oneof" json:"psp_spec,omitempty"`
}
type CreateSpecType_Yaml struct {
	Yaml string `protobuf:"bytes,3,opt,name=yaml,proto3,oneof" json:"yaml,omitempty"`
}

func (*CreateSpecType_PspSpec) isCreateSpecType_ConfigMethodChoice() {}
func (*CreateSpecType_Yaml) isCreateSpecType_ConfigMethodChoice()    {}

func (m *CreateSpecType) GetConfigMethodChoice() isCreateSpecType_ConfigMethodChoice {
	if m != nil {
		return m.ConfigMethodChoice
	}
	return nil
}

func (m *CreateSpecType) GetPspSpec() *PodSecurityPolicySpecType {
	if x, ok := m.GetConfigMethodChoice().(*CreateSpecType_PspSpec); ok {
		return x.PspSpec
	}
	return nil
}

func (m *CreateSpecType) GetYaml() string {
	if x, ok := m.GetConfigMethodChoice().(*CreateSpecType_Yaml); ok {
		return x.Yaml
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateSpecType_PspSpec)(nil),
		(*CreateSpecType_Yaml)(nil),
	}
}

// Replace k8s_pod_security_policy
//
// x-displayName: "Replace Configuration Specification"
// Replacing an k8s_pod_security_policy object will update the object by replacing the existing spec with the provided one.
// For read-then-write operations a resourceVersion mismatch will occur if the object was modified between the read and write
type ReplaceSpecType struct {
	// Types that are valid to be assigned to ConfigMethodChoice:
	//	*ReplaceSpecType_PspSpec
	//	*ReplaceSpecType_Yaml
	ConfigMethodChoice isReplaceSpecType_ConfigMethodChoice `protobuf_oneof:"config_method_choice"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_669bbfbe00eebfa8, []int{9}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

type isReplaceSpecType_ConfigMethodChoice interface {
	isReplaceSpecType_ConfigMethodChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplaceSpecType_PspSpec struct {
	PspSpec *PodSecurityPolicySpecType `protobuf:"bytes,2,opt,name=psp_spec,json=pspSpec,proto3,oneof" json:"psp_spec,omitempty"`
}
type ReplaceSpecType_Yaml struct {
	Yaml string `protobuf:"bytes,3,opt,name=yaml,proto3,oneof" json:"yaml,omitempty"`
}

func (*ReplaceSpecType_PspSpec) isReplaceSpecType_ConfigMethodChoice() {}
func (*ReplaceSpecType_Yaml) isReplaceSpecType_ConfigMethodChoice()    {}

func (m *ReplaceSpecType) GetConfigMethodChoice() isReplaceSpecType_ConfigMethodChoice {
	if m != nil {
		return m.ConfigMethodChoice
	}
	return nil
}

func (m *ReplaceSpecType) GetPspSpec() *PodSecurityPolicySpecType {
	if x, ok := m.GetConfigMethodChoice().(*ReplaceSpecType_PspSpec); ok {
		return x.PspSpec
	}
	return nil
}

func (m *ReplaceSpecType) GetYaml() string {
	if x, ok := m.GetConfigMethodChoice().(*ReplaceSpecType_Yaml); ok {
		return x.Yaml
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplaceSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplaceSpecType_PspSpec)(nil),
		(*ReplaceSpecType_Yaml)(nil),
	}
}

// Get k8s_pod_security_policy
//
// x-displayName: "Get Configuration Specification"
// Get k8s_pod_security_policy will get the object from the storage backend for namespace metadata.namespace
type GetSpecType struct {
	// Types that are valid to be assigned to ConfigMethodChoice:
	//	*GetSpecType_PspSpec
	//	*GetSpecType_Yaml
	ConfigMethodChoice isGetSpecType_ConfigMethodChoice `protobuf_oneof:"config_method_choice"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_669bbfbe00eebfa8, []int{10}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

type isGetSpecType_ConfigMethodChoice interface {
	isGetSpecType_ConfigMethodChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetSpecType_PspSpec struct {
	PspSpec *PodSecurityPolicySpecType `protobuf:"bytes,2,opt,name=psp_spec,json=pspSpec,proto3,oneof" json:"psp_spec,omitempty"`
}
type GetSpecType_Yaml struct {
	Yaml string `protobuf:"bytes,3,opt,name=yaml,proto3,oneof" json:"yaml,omitempty"`
}

func (*GetSpecType_PspSpec) isGetSpecType_ConfigMethodChoice() {}
func (*GetSpecType_Yaml) isGetSpecType_ConfigMethodChoice()    {}

func (m *GetSpecType) GetConfigMethodChoice() isGetSpecType_ConfigMethodChoice {
	if m != nil {
		return m.ConfigMethodChoice
	}
	return nil
}

func (m *GetSpecType) GetPspSpec() *PodSecurityPolicySpecType {
	if x, ok := m.GetConfigMethodChoice().(*GetSpecType_PspSpec); ok {
		return x.PspSpec
	}
	return nil
}

func (m *GetSpecType) GetYaml() string {
	if x, ok := m.GetConfigMethodChoice().(*GetSpecType_Yaml); ok {
		return x.Yaml
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GetSpecType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GetSpecType_PspSpec)(nil),
		(*GetSpecType_Yaml)(nil),
	}
}

func init() {
	proto.RegisterType((*CapabilityListType)(nil), "ves.io.schema.k8s_pod_security_policy.CapabilityListType")
	golang_proto.RegisterType((*CapabilityListType)(nil), "ves.io.schema.k8s_pod_security_policy.CapabilityListType")
	proto.RegisterType((*HostPathType)(nil), "ves.io.schema.k8s_pod_security_policy.HostPathType")
	golang_proto.RegisterType((*HostPathType)(nil), "ves.io.schema.k8s_pod_security_policy.HostPathType")
	proto.RegisterType((*IDRangeType)(nil), "ves.io.schema.k8s_pod_security_policy.IDRangeType")
	golang_proto.RegisterType((*IDRangeType)(nil), "ves.io.schema.k8s_pod_security_policy.IDRangeType")
	proto.RegisterType((*IDStrategyOptionsType)(nil), "ves.io.schema.k8s_pod_security_policy.IDStrategyOptionsType")
	golang_proto.RegisterType((*IDStrategyOptionsType)(nil), "ves.io.schema.k8s_pod_security_policy.IDStrategyOptionsType")
	proto.RegisterType((*RuntimeClassStrategyOptions)(nil), "ves.io.schema.k8s_pod_security_policy.RuntimeClassStrategyOptions")
	golang_proto.RegisterType((*RuntimeClassStrategyOptions)(nil), "ves.io.schema.k8s_pod_security_policy.RuntimeClassStrategyOptions")
	proto.RegisterType((*SELinuxStrategyOptions)(nil), "ves.io.schema.k8s_pod_security_policy.SELinuxStrategyOptions")
	golang_proto.RegisterType((*SELinuxStrategyOptions)(nil), "ves.io.schema.k8s_pod_security_policy.SELinuxStrategyOptions")
	proto.RegisterType((*PodSecurityPolicySpecType)(nil), "ves.io.schema.k8s_pod_security_policy.PodSecurityPolicySpecType")
	golang_proto.RegisterType((*PodSecurityPolicySpecType)(nil), "ves.io.schema.k8s_pod_security_policy.PodSecurityPolicySpecType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.k8s_pod_security_policy.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.k8s_pod_security_policy.GlobalSpecType")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.k8s_pod_security_policy.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.k8s_pod_security_policy.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.k8s_pod_security_policy.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.k8s_pod_security_policy.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.k8s_pod_security_policy.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.k8s_pod_security_policy.GetSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/k8s_pod_security_policy/types.proto", fileDescriptor_669bbfbe00eebfa8)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/k8s_pod_security_policy/types.proto", fileDescriptor_669bbfbe00eebfa8)
}

var fileDescriptor_669bbfbe00eebfa8 = []byte{
	// 4107 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x5a, 0x5f, 0x6c, 0x1b, 0x47,
	0x7a, 0xf7, 0x4a, 0x94, 0x44, 0x8d, 0x64, 0x9b, 0xde, 0x38, 0x0e, 0x65, 0x27, 0xca, 0x58, 0xb1,
	0x13, 0x2a, 0x47, 0x51, 0x11, 0x25, 0xc7, 0x76, 0x9c, 0x1c, 0xc2, 0x7f, 0x92, 0x28, 0x8b, 0x22,
	0xb1, 0xa4, 0xec, 0x4b, 0xae, 0x77, 0xdb, 0xd1, 0xee, 0x90, 0x9c, 0x68, 0x77, 0x67, 0x33, 0x33,
	0x2b, 0x99, 0x05, 0x0e, 0x70, 0x8b, 0x00, 0x45, 0x5f, 0x8a, 0x83, 0xdf, 0xae, 0x7d, 0x2b, 0x70,
	0xc5, 0xf5, 0xa5, 0x7d, 0xaf, 0x52, 0xc0, 0xb8, 0x87, 0x22, 0x28, 0x50, 0x40, 0x7d, 0x29, 0xf2,
	0x54, 0x34, 0x0a, 0x50, 0x5c, 0xd0, 0x87, 0xde, 0x63, 0xd1, 0x97, 0x2b, 0x66, 0x76, 0x97, 0xa2,
	0xfe, 0x58, 0x51, 0x71, 0x29, 0x70, 0xb8, 0xb7, 0xdd, 0x99, 0xef, 0xfb, 0x7d, 0xdf, 0x7c, 0xf3,
	0xfd, 0x5d, 0x12, 0x2c, 0xec, 0x60, 0x9e, 0x23, 0x74, 0x9e, 0x5b, 0x5d, 0xec, 0xa2, 0xf9, 0xed,
	0x7b, 0xdc, 0xf4, 0xa9, 0x6d, 0x72, 0x6c, 0x05, 0x8c, 0x88, 0x9e, 0xe9, 0x53, 0x87, 0x58, 0xbd,
	0x79, 0xd1, 0xf3, 0x31, 0xcf, 0xf9, 0x8c, 0x0a, 0xaa, 0xdf, 0x0e, 0x59, 0x72, 0x21, 0x4b, 0xee,
	0x05, 0x2c, 0xd7, 0xe7, 0x3a, 0x44, 0x74, 0x83, 0xad, 0x9c, 0x45, 0xdd, 0xf9, 0x0e, 0xed, 0xd0,
	0x79, 0xc5, 0xbd, 0x15, 0xb4, 0xd5, 0x9b, 0x7a, 0x51, 0x4f, 0x21, 0xea, 0xf5, 0x1b, 0x47, 0x15,
	0xa1, 0xbe, 0x20, 0xd4, 0x8b, 0x44, 0x5e, 0x9f, 0x3a, 0xba, 0x39, 0xa0, 0xcd, 0xf5, 0x57, 0x8f,
	0x6e, 0xed, 0x20, 0x87, 0xd8, 0x48, 0xe0, 0x68, 0x17, 0x1e, 0xdb, 0x25, 0x78, 0xd7, 0x3c, 0x02,
	0x3d, 0xf3, 0xf3, 0x29, 0xa0, 0x97, 0x90, 0x8f, 0xb6, 0x88, 0x43, 0x44, 0x6f, 0x9d, 0x70, 0xd1,
	0xea, 0xf9, 0x58, 0xff, 0xf3, 0x29, 0x30, 0x69, 0xc5, 0xcb, 0x04, 0xf3, 0xb4, 0x06, 0x87, 0x33,
	0xe3, 0xc5, 0x6f, 0xd2, 0xcf, 0x3e, 0xd7, 0xfe, 0x31, 0x0d, 0x9e, 0x6a, 0xe0, 0x62, 0x61, 0xb3,
	0x5c, 0x6d, 0x99, 0xa5, 0xfa, 0x46, 0xcb, 0xa8, 0xaf, 0xeb, 0xb4, 0xe2, 0xa1, 0x2d, 0x07, 0x43,
	0xe4, 0xd9, 0xd0, 0x26, 0x5c, 0x3d, 0x6f, 0x63, 0xe6, 0x61, 0x07, 0xa2, 0xc0, 0x26, 0x82, 0x78,
	0x9d, 0x07, 0xd0, 0xea, 0x22, 0xaf, 0x83, 0xfb, 0x0b, 0xb0, 0x4d, 0x1c, 0x81, 0x19, 0x64, 0x81,
	0x83, 0xf9, 0x03, 0xc8, 0xb0, 0x60, 0x04, 0xef, 0x0c, 0xec, 0x73, 0x81, 0x44, 0xc0, 0x15, 0x66,
	0x48, 0x2a, 0x17, 0x15, 0x75, 0x0e, 0xac, 0x00, 0x10, 0x6a, 0x60, 0x54, 0x0a, 0x65, 0xfd, 0x7e,
	0xc1, 0x71, 0xe8, 0x2e, 0x64, 0x18, 0xd9, 0x92, 0x46, 0x74, 0x23, 0x14, 0xe8, 0xd0, 0x0e, 0xdc,
	0x21, 0x08, 0xba, 0x81, 0x23, 0x88, 0x85, 0xb8, 0x80, 0x1e, 0x16, 0x0e, 0xf1, 0xb6, 0x21, 0xa7,
	0xd6, 0x36, 0x16, 0x39, 0x90, 0x07, 0x17, 0x8b, 0xeb, 0xf5, 0xd2, 0x43, 0xb3, 0xb9, 0xd9, 0x6c,
	0x54, 0x36, 0xca, 0xfa, 0xcd, 0x10, 0xcb, 0x67, 0x78, 0x07, 0x7b, 0xa1, 0x1e, 0x3d, 0x2e, 0xb0,
	0x0b, 0x79, 0xc0, 0x7d, 0xec, 0xd9, 0x3c, 0x07, 0x18, 0x18, 0x2e, 0x36, 0x96, 0xf5, 0xed, 0x90,
	0xd2, 0x62, 0x18, 0x29, 0xba, 0x62, 0x63, 0x19, 0xba, 0xc8, 0xe7, 0x59, 0xe8, 0xd0, 0x50, 0x11,
	0xb9, 0x22, 0x0d, 0x0a, 0x97, 0x29, 0x73, 0x91, 0x80, 0x99, 0x62, 0x6b, 0x79, 0x16, 0xda, 0x48,
	0xa0, 0xec, 0xe1, 0x79, 0xd7, 0xaa, 0x2d, 0x6c, 0x43, 0x8b, 0xda, 0x18, 0xd2, 0xb6, 0x62, 0xf1,
	0x19, 0xed, 0x30, 0xe4, 0xf2, 0xac, 0x3a, 0xbb, 0x4b, 0x19, 0xce, 0x81, 0x3f, 0x00, 0x7a, 0x69,
	0xb5, 0x52, 0x7a, 0xd8, 0xa8, 0x57, 0x37, 0xe4, 0xa9, 0x9b, 0xad, 0xba, 0x51, 0xd1, 0x97, 0x23,
	0x15, 0xba, 0xd8, 0xda, 0xf6, 0x29, 0xf1, 0xc4, 0x3c, 0xc3, 0x5c, 0x50, 0x86, 0x21, 0xc3, 0x0e,
	0x12, 0xd8, 0x86, 0xd4, 0xc7, 0x0c, 0x85, 0x57, 0x0e, 0xab, 0x9e, 0x60, 0xd4, 0x0e, 0x2c, 0x6c,
	0x43, 0xe2, 0xc5, 0xf7, 0x73, 0x27, 0x77, 0x3f, 0x07, 0x3a, 0xe0, 0x72, 0xb9, 0x50, 0x52, 0xc6,
	0x34, 0x9b, 0x95, 0x82, 0x51, 0x5a, 0xd5, 0x5b, 0xc5, 0x9e, 0x8f, 0x38, 0x97, 0xa6, 0xc7, 0xca,
	0xb2, 0xd0, 0xc7, 0xcc, 0x25, 0x9c, 0x13, 0xea, 0x85, 0x02, 0x79, 0x74, 0xdd, 0x0c, 0x5b, 0x82,
	0xb2, 0x5e, 0x48, 0x24, 0x97, 0xf0, 0x13, 0x6c, 0x05, 0x02, 0x9f, 0x64, 0xc8, 0x81, 0x32, 0x48,
	0x56, 0x1b, 0x25, 0x53, 0x5a, 0x5c, 0xbf, 0xb7, 0x4e, 0xad, 0x6d, 0xe8, 0x62, 0x57, 0x32, 0x67,
	0x5c, 0x87, 0x5a, 0xdb, 0x99, 0xfc, 0x6c, 0x16, 0xaa, 0x27, 0xe4, 0x38, 0xe1, 0x8b, 0x8b, 0x7c,
	0xf5, 0xc0, 0xbb, 0xae, 0x25, 0xe4, 0xda, 0x6c, 0x0e, 0xd4, 0xc0, 0xb8, 0x44, 0xa9, 0x3f, 0xde,
	0xa8, 0x18, 0xfa, 0x87, 0x91, 0xa2, 0x27, 0xd5, 0x6b, 0x53, 0x36, 0x70, 0x7e, 0x48, 0x3d, 0xd8,
	0x0c, 0xaf, 0xf2, 0x11, 0xac, 0x36, 0x4a, 0x90, 0x6e, 0x7d, 0x82, 0x2d, 0xc1, 0x73, 0xe0, 0x7d,
	0x30, 0xb2, 0x5e, 0x29, 0x34, 0x2b, 0xfa, 0x62, 0x85, 0x0b, 0xb4, 0xe5, 0x10, 0xde, 0x85, 0x0e,
	0x46, 0x1c, 0x2b, 0x1e, 0xc4, 0xb6, 0x88, 0x60, 0x88, 0xf5, 0x94, 0x29, 0x38, 0xcc, 0x70, 0x8c,
	0x61, 0xdb, 0xf2, 0x62, 0x65, 0xaa, 0xe0, 0xf2, 0x7a, 0x75, 0x63, 0xf3, 0x07, 0x66, 0xb5, 0x56,
	0xdb, 0x6c, 0x15, 0x8a, 0xeb, 0x15, 0xfd, 0xdd, 0x26, 0x16, 0xca, 0x0b, 0x97, 0x9b, 0x66, 0xa1,
	0x21, 0xdd, 0xca, 0x5c, 0x5e, 0x57, 0xa6, 0x59, 0x6e, 0x1e, 0x92, 0xc9, 0x35, 0x32, 0xe7, 0xc9,
	0x8b, 0x6f, 0x3b, 0xa8, 0xc3, 0x73, 0x60, 0x13, 0x8c, 0xd7, 0x0a, 0x25, 0xb3, 0x50, 0xae, 0x55,
	0x37, 0xf4, 0xd5, 0xf0, 0x6e, 0x6b, 0x85, 0x12, 0xb4, 0xa8, 0xd7, 0x26, 0x9d, 0x20, 0x3c, 0x08,
	0xa4, 0x4c, 0x85, 0x06, 0x8e, 0x02, 0x4a, 0x5e, 0xac, 0xeb, 0x3b, 0xd8, 0xc5, 0x9e, 0xbc, 0x70,
	0x79, 0x68, 0x29, 0xba, 0xe9, 0x22, 0x6b, 0x1b, 0xae, 0x37, 0x6b, 0x39, 0x40, 0xc1, 0xa4, 0x84,
	0xad, 0x3f, 0xaa, 0x18, 0x46, 0xb5, 0x5c, 0xd1, 0xcd, 0xfa, 0x0e, 0x66, 0x8c, 0xd8, 0x18, 0xd6,
	0x90, 0x67, 0x23, 0x75, 0x79, 0x05, 0xcb, 0xc2, 0x9c, 0xc3, 0x12, 0x95, 0x3e, 0xe2, 0xc0, 0x4c,
	0xad, 0x50, 0x9a, 0x3d, 0x13, 0x98, 0x78, 0xc1, 0x13, 0xd8, 0x8c, 0xd2, 0x1e, 0xac, 0x51, 0x3b,
	0x70, 0x30, 0xcc, 0xac, 0x37, 0x6b, 0xb3, 0x39, 0x70, 0x0f, 0x8c, 0x6f, 0x54, 0x5a, 0xd1, 0x39,
	0xbe, 0xd7, 0xc0, 0xac, 0x4d, 0x99, 0x0b, 0x77, 0x10, 0x23, 0x34, 0xe0, 0x32, 0x04, 0x77, 0x29,
	0xdb, 0x9e, 0x3b, 0xc5, 0x45, 0x41, 0x11, 0x5c, 0x94, 0x9c, 0x45, 0xa3, 0x5e, 0x28, 0x97, 0x0a,
	0xcd, 0x96, 0xbe, 0x50, 0x43, 0xdb, 0x38, 0x8a, 0x56, 0xb8, 0xc5, 0x28, 0xb2, 0x65, 0x18, 0x47,
	0xa1, 0xe1, 0x10, 0x2e, 0xb0, 0x07, 0x05, 0x3d, 0x0c, 0x70, 0x9e, 0x03, 0x9f, 0x69, 0x60, 0xac,
	0x51, 0x31, 0x96, 0x6b, 0xf5, 0x0d, 0xbd, 0x17, 0x1a, 0x31, 0x0a, 0x61, 0x3f, 0xd4, 0x04, 0x79,
	0x56, 0x98, 0xaa, 0xe8, 0x16, 0xc7, 0x6c, 0x27, 0xca, 0x7e, 0xd0, 0x67, 0x64, 0x87, 0x38, 0xb8,
	0x73, 0x44, 0x25, 0x18, 0x70, 0x19, 0xc9, 0x92, 0xd3, 0x54, 0x19, 0x81, 0x67, 0x21, 0xb9, 0xbf,
	0x70, 0xc7, 0x94, 0x2b, 0x21, 0x88, 0xe8, 0x62, 0x16, 0x47, 0x13, 0x0f, 0xb6, 0x42, 0x59, 0x1c,
	0x14, 0xc0, 0x78, 0xf3, 0xa3, 0x66, 0x64, 0x84, 0xa5, 0xd8, 0x08, 0x08, 0x32, 0x95, 0x05, 0x69,
	0x3b, 0x56, 0x0a, 0xd9, 0x2e, 0xf1, 0x08, 0x17, 0xf1, 0xed, 0x0e, 0x58, 0xe3, 0xc7, 0x20, 0x29,
	0x21, 0x8a, 0xf5, 0x7a, 0x4b, 0x37, 0x36, 0xb9, 0x8c, 0xc3, 0x2d, 0x4a, 0x45, 0x26, 0x3f, 0xab,
	0x24, 0x6f, 0xcb, 0x40, 0x33, 0x65, 0xb2, 0x51, 0x11, 0x12, 0x6e, 0x86, 0x86, 0xa1, 0x32, 0x14,
	0xa1, 0x87, 0x77, 0x63, 0xc5, 0xe4, 0xed, 0x49, 0x73, 0xb3, 0x28, 0x3a, 0x09, 0xf5, 0x72, 0x60,
	0x0e, 0x00, 0x89, 0x5f, 0xab, 0x97, 0x37, 0xd7, 0x2b, 0xfa, 0xeb, 0xeb, 0x34, 0x0a, 0xe0, 0xc0,
	0x53, 0x00, 0x11, 0xab, 0xab, 0xee, 0x96, 0xe7, 0xc0, 0xa7, 0xa1, 0x3a, 0x1b, 0xd5, 0x52, 0x45,
	0xc7, 0x06, 0x22, 0x1c, 0xcb, 0x54, 0xa5, 0xfc, 0xc6, 0x23, 0x16, 0x86, 0x3b, 0xc8, 0x09, 0x30,
	0xcc, 0xc8, 0xe7, 0x30, 0x64, 0xb1, 0xf0, 0x19, 0xa1, 0xd2, 0x41, 0x64, 0xa8, 0x28, 0xe8, 0xa8,
	0x08, 0x48, 0x47, 0x1a, 0xe0, 0x91, 0xda, 0x1d, 0xc6, 0x59, 0x04, 0x2a, 0x45, 0x7e, 0x3f, 0x34,
	0x62, 0xa3, 0x50, 0x2a, 0xb5, 0xf4, 0x05, 0x69, 0x02, 0x64, 0x59, 0x22, 0x44, 0xdf, 0x25, 0xc2,
	0xea, 0xf6, 0x35, 0x40, 0x96, 0x45, 0x83, 0x30, 0x61, 0x87, 0x31, 0x42, 0xdb, 0x6d, 0xe9, 0x89,
	0xea, 0x84, 0x8d, 0x96, 0x51, 0x28, 0x55, 0xf4, 0xb7, 0x5b, 0x0c, 0xc9, 0xab, 0x3f, 0x29, 0x29,
	0xbe, 0x66, 0x21, 0x09, 0x32, 0xf9, 0xd9, 0x5c, 0x7c, 0x7d, 0x46, 0xe1, 0x71, 0xb5, 0x7e, 0x78,
	0x7d, 0xd5, 0xf9, 0x3a, 0xf4, 0x29, 0x13, 0x83, 0x1e, 0x92, 0x21, 0xd4, 0x77, 0xe2, 0x3b, 0x21,
	0x72, 0xc3, 0x0d, 0x33, 0xc3, 0x2c, 0x98, 0x54, 0x10, 0x95, 0x66, 0x7d, 0xd3, 0x28, 0x55, 0xf4,
	0xa9, 0x7e, 0xdc, 0x31, 0xcc, 0x69, 0xc0, 0x2c, 0x0c, 0xd7, 0x89, 0x4b, 0xa4, 0xcf, 0xb6, 0x43,
	0xd3, 0xb6, 0xaa, 0xb5, 0x8a, 0xfe, 0xb1, 0xcc, 0x1e, 0x91, 0x73, 0x58, 0x32, 0x17, 0xca, 0x94,
	0x23, 0x04, 0x71, 0x31, 0x6d, 0xdb, 0xa8, 0x17, 0x1e, 0x5e, 0xbe, 0xaa, 0x27, 0x64, 0x7f, 0x22,
	0x9f, 0x9f, 0x48, 0x91, 0x0f, 0xa4, 0xc9, 0x65, 0x1e, 0x76, 0xe6, 0xe4, 0x1a, 0xcc, 0x74, 0x11,
	0xb3, 0x77, 0x11, 0xc3, 0xb3, 0x21, 0x50, 0x0e, 0x60, 0x70, 0x49, 0xc9, 0x69, 0x7d, 0x24, 0x6b,
	0xf7, 0x72, 0x75, 0x45, 0x6f, 0x4a, 0xa3, 0xee, 0xc8, 0x5b, 0x09, 0x64, 0xa2, 0x7d, 0x00, 0xb1,
	0xeb, 0x3b, 0xb4, 0xd7, 0x8f, 0xd6, 0x81, 0xa8, 0x20, 0x34, 0xcc, 0xc0, 0xc7, 0x92, 0xea, 0x0e,
	0x61, 0x22, 0x40, 0x0e, 0x14, 0x32, 0x01, 0x7b, 0xc8, 0xe1, 0xb2, 0xaa, 0x8e, 0x36, 0x3f, 0x6a,
	0xae, 0xd7, 0x57, 0xf4, 0x4c, 0x6c, 0xb9, 0x01, 0x1c, 0xde, 0xe3, 0x0e, 0xed, 0x1c, 0x05, 0xca,
	0x81, 0x0f, 0x00, 0x78, 0x5c, 0x78, 0x58, 0x31, 0x0b, 0xeb, 0x05, 0xa3, 0xa6, 0xcf, 0xb7, 0x18,
	0xe9, 0x74, 0x30, 0x83, 0x9c, 0xba, 0x58, 0x74, 0xc3, 0xb2, 0x8e, 0x04, 0xdc, 0x25, 0x8e, 0x03,
	0x77, 0x65, 0x4e, 0x08, 0x7c, 0xe5, 0x45, 0xa1, 0xa1, 0x72, 0x60, 0x09, 0x4c, 0x84, 0x1d, 0xc1,
	0x63, 0xa3, 0xda, 0xaa, 0xe8, 0xb7, 0x1f, 0x33, 0x22, 0xa4, 0xa1, 0x2d, 0xca, 0x6c, 0x2e, 0x53,
	0xc4, 0xb1, 0x7e, 0x44, 0xf6, 0x06, 0x39, 0x50, 0x01, 0x23, 0xa5, 0xd5, 0xfa, 0xe3, 0x0d, 0xfd,
	0x7d, 0x95, 0x67, 0x0e, 0x3d, 0x23, 0xca, 0xad, 0x92, 0x51, 0x55, 0xc0, 0xcd, 0x6a, 0x39, 0xac,
	0x77, 0x2b, 0xf2, 0x41, 0xd5, 0x00, 0xab, 0x4b, 0x77, 0xbd, 0xf0, 0xa6, 0x57, 0xc0, 0x64, 0x79,
	0x30, 0xc3, 0xde, 0x3d, 0x5e, 0x3c, 0xb3, 0x70, 0x57, 0xea, 0x93, 0xfd, 0xb6, 0xfa, 0xf8, 0xa7,
	0x1a, 0x18, 0x5d, 0x0e, 0xeb, 0xda, 0x4f, 0x5e, 0x58, 0xd7, 0x8e, 0x64, 0x89, 0xd0, 0x2c, 0x9e,
	0x4c, 0x6b, 0x8e, 0x23, 0x8b, 0xf0, 0xa7, 0x01, 0x61, 0x61, 0x80, 0x29, 0xe9, 0x91, 0x23, 0x6d,
	0x56, 0xcb, 0x32, 0xe7, 0xc8, 0xe5, 0x38, 0x62, 0x64, 0xda, 0x44, 0x32, 0x84, 0xe4, 0xe2, 0xc0,
	0xbe, 0x64, 0xcb, 0x81, 0x1f, 0x81, 0xd1, 0xe5, 0x66, 0xa5, 0x55, 0x2d, 0xeb, 0xcd, 0x32, 0xf5,
	0x0e, 0x9e, 0xfe, 0x4c, 0x40, 0xcb, 0xc1, 0x88, 0x49, 0x17, 0x9b, 0x0b, 0x38, 0x66, 0x73, 0xd5,
	0xb2, 0x3a, 0x8d, 0x7c, 0xef, 0x30, 0x1a, 0xf8, 0x72, 0x61, 0x40, 0xd9, 0x2d, 0x22, 0x38, 0xdc,
	0xed, 0x62, 0x0f, 0xa2, 0x50, 0x13, 0xc2, 0x65, 0x2a, 0x21, 0x6d, 0x82, 0xed, 0x1c, 0xb8, 0x03,
	0x12, 0x0f, 0xab, 0xeb, 0xeb, 0xfa, 0xdc, 0x99, 0xd5, 0x9b, 0x63, 0x4f, 0x35, 0x52, 0x9c, 0x74,
	0x42, 0xc7, 0x9a, 0x03, 0x23, 0xb5, 0x87, 0x1b, 0xf5, 0xb2, 0x7e, 0xab, 0x24, 0xdb, 0x2e, 0x0c,
	0xb9, 0x8f, 0x2d, 0x82, 0x9c, 0xa8, 0x36, 0x87, 0x51, 0xec, 0x6e, 0x7b, 0xd4, 0x56, 0x41, 0x6c,
	0x83, 0x94, 0x2a, 0x27, 0xd5, 0x0d, 0xd9, 0xd7, 0x18, 0x8f, 0x64, 0xe6, 0x6a, 0x14, 0x89, 0x27,
	0x93, 0x63, 0x54, 0x53, 0x04, 0x85, 0xc4, 0x13, 0xd2, 0x37, 0x04, 0xb4, 0xa9, 0x8b, 0x88, 0x37,
	0xe8, 0xaa, 0x32, 0xd6, 0x39, 0xcc, 0xa8, 0x90, 0xf7, 0x02, 0x77, 0x0b, 0x33, 0x0e, 0x1d, 0x65,
	0xbc, 0x2e, 0xf2, 0xe0, 0xc2, 0x3b, 0xf9, 0xa5, 0xd9, 0x1c, 0x78, 0x13, 0x8c, 0x49, 0x29, 0x46,
	0xe1, 0xb1, 0x7e, 0x43, 0x46, 0x93, 0x51, 0x78, 0xac, 0x2c, 0xd3, 0x28, 0x94, 0x1e, 0x56, 0x5a,
	0x91, 0x20, 0x9e, 0x03, 0x37, 0xc1, 0x58, 0xb3, 0xd2, 0x5a, 0x2e, 0x15, 0x1a, 0xfa, 0x35, 0x19,
	0xe3, 0xca, 0x2a, 0x83, 0x7d, 0x76, 0x0e, 0x18, 0x60, 0xb4, 0x59, 0x69, 0xad, 0x54, 0xcb, 0xfa,
	0xea, 0x31, 0x87, 0x74, 0x91, 0x47, 0xfc, 0xc0, 0x89, 0xc3, 0xae, 0xdd, 0xbf, 0xc6, 0x95, 0xd8,
	0x33, 0x79, 0xe0, 0x47, 0xd5, 0x5a, 0xd2, 0xaf, 0x54, 0xcb, 0xaa, 0x3e, 0xe6, 0xc0, 0x5b, 0x4a,
	0x6c, 0x43, 0x8a, 0x7d, 0xb5, 0x26, 0x2f, 0xa0, 0x9f, 0xf7, 0x8e, 0x09, 0xbf, 0xab, 0x84, 0x6f,
	0x56, 0xcb, 0xfa, 0xdc, 0x79, 0x85, 0xcb, 0xb0, 0xc8, 0x81, 0xc5, 0x30, 0xcb, 0x96, 0x56, 0x0d,
	0x59, 0xa9, 0x6e, 0x4b, 0x1b, 0x58, 0x5d, 0x16, 0x56, 0xaa, 0x6c, 0x9c, 0xf2, 0xe5, 0xfb, 0x61,
	0xb7, 0x98, 0xfb, 0xfb, 0x6f, 0x9e, 0x0f, 0x8f, 0x3c, 0xd3, 0x86, 0x52, 0x1f, 0xc6, 0x4f, 0x49,
	0x2d, 0x7e, 0x4a, 0x6b, 0xc6, 0x91, 0xf9, 0x63, 0xe6, 0x63, 0x30, 0xb9, 0x4a, 0xb9, 0x68, 0x20,
	0xd1, 0x55, 0x03, 0xca, 0x1c, 0x98, 0xf0, 0x91, 0xe8, 0x9a, 0x3e, 0xc3, 0x6d, 0xf2, 0x24, 0xad,
	0x41, 0x2d, 0x33, 0x5e, 0x9c, 0x94, 0xec, 0x63, 0x6c, 0x24, 0xa5, 0xa5, 0x9f, 0x6a, 0x06, 0x90,
	0x04, 0x0d, 0xb5, 0xaf, 0xdf, 0x00, 0xe3, 0x32, 0x08, 0x4d, 0xea, 0x39, 0xbd, 0xf4, 0x10, 0xd4,
	0x32, 0x49, 0x23, 0x29, 0x17, 0xea, 0x9e, 0xd3, 0x9b, 0xf9, 0x08, 0x4c, 0x54, 0xcb, 0x86, 0x54,
	0x51, 0x41, 0xdf, 0x02, 0xa3, 0x2e, 0xf1, 0x4c, 0x62, 0x2b, 0xd4, 0x8b, 0xc5, 0x8b, 0x12, 0x35,
	0xf9, 0xf6, 0x68, 0xfa, 0x37, 0xbf, 0x19, 0xce, 0x68, 0xc6, 0x88, 0x4b, 0xbc, 0xaa, 0xad, 0xa8,
	0xd0, 0x13, 0x49, 0x35, 0x74, 0x3a, 0x15, 0x7a, 0x52, 0xb5, 0x67, 0xfe, 0x3a, 0x01, 0x5e, 0xae,
	0x96, 0x9b, 0xb2, 0xb4, 0xe3, 0x4e, 0xaf, 0x1e, 0x8e, 0x5e, 0x4a, 0xca, 0x0f, 0xc1, 0x38, 0xb1,
	0x4d, 0xd5, 0x0a, 0x84, 0xd3, 0xd5, 0x44, 0x3e, 0x9f, 0x3b, 0xd7, 0x68, 0x99, 0x1b, 0x50, 0xb6,
	0x08, 0xfa, 0x56, 0x4c, 0x19, 0x49, 0x62, 0xab, 0x0d, 0xae, 0xff, 0xdd, 0x30, 0x48, 0xc8, 0x39,
	0x49, 0xe9, 0x36, 0x5e, 0xfc, 0x8b, 0xe1, 0x67, 0x9f, 0x6b, 0x7f, 0x36, 0x0c, 0x9e, 0x69, 0x60,
	0xbc, 0x16, 0x70, 0x61, 0x04, 0x5e, 0x81, 0xeb, 0x9f, 0x69, 0x46, 0x98, 0x2a, 0x38, 0x44, 0x42,
	0xb5, 0xbb, 0x02, 0x52, 0x0f, 0x47, 0xed, 0x89, 0xa0, 0x70, 0x2b, 0x0a, 0x2e, 0x15, 0xaf, 0x70,
	0x53, 0x16, 0x49, 0x99, 0x1d, 0x64, 0xb3, 0xe2, 0x06, 0x6e, 0x54, 0xb8, 0xfb, 0x29, 0x83, 0x71,
	0x11, 0xb1, 0xa2, 0x90, 0xce, 0xc6, 0x6d, 0x14, 0x38, 0x22, 0x07, 0x1f, 0x45, 0x43, 0x29, 0x87,
	0xa8, 0x83, 0x88, 0xc7, 0x05, 0x44, 0x8e, 0x13, 0xd2, 0xf2, 0x1c, 0xf8, 0x85, 0x06, 0x92, 0x35,
	0xd4, 0x0b, 0x75, 0xfa, 0xcb, 0xff, 0x9b, 0x4e, 0xaa, 0xb7, 0xe3, 0x70, 0xb9, 0xb9, 0x22, 0xd3,
	0x0f, 0x8f, 0x08, 0x1c, 0xdc, 0x16, 0x30, 0xf0, 0x64, 0x25, 0xdc, 0x25, 0xa2, 0x4b, 0x03, 0x21,
	0xbd, 0x75, 0x87, 0xa8, 0x44, 0x82, 0xce, 0xa7, 0x17, 0x24, 0xed, 0x43, 0x58, 0xc2, 0x65, 0x8e,
	0x93, 0x49, 0x3e, 0xa9, 0xd4, 0x2c, 0x78, 0x3d, 0xfd, 0xc1, 0x06, 0x8d, 0x91, 0x22, 0xf4, 0x01,
	0x85, 0x90, 0xd7, 0x83, 0x6d, 0xae, 0xb8, 0x61, 0xb5, 0x7c, 0x42, 0xef, 0xc8, 0x4d, 0xa1, 0x96,
	0x79, 0xaa, 0x19, 0xea, 0xa2, 0x66, 0xfe, 0x55, 0x03, 0x37, 0x0c, 0xd9, 0xbd, 0xb8, 0xb8, 0xe4,
	0x20, 0xce, 0x8f, 0xb9, 0x8c, 0xee, 0x82, 0x1b, 0x48, 0x62, 0x63, 0xdb, 0x64, 0x21, 0x99, 0x69,
	0x49, 0x3a, 0xd3, 0x43, 0x6e, 0x7f, 0x3c, 0x57, 0xc0, 0x13, 0xcf, 0xb4, 0xe4, 0xcc, 0x28, 0x4b,
	0x40, 0x2d, 0xd3, 0x0f, 0xac, 0x54, 0xe2, 0xd4, 0x10, 0x4b, 0x47, 0x90, 0x83, 0x82, 0x37, 0x24,
	0x9e, 0xbe, 0x0a, 0xae, 0x47, 0x87, 0x3b, 0x45, 0x5c, 0xe4, 0x55, 0x13, 0x12, 0x29, 0x12, 0x64,
	0xbc, 0x12, 0x91, 0x1f, 0x87, 0x9a, 0xf9, 0xf9, 0x30, 0xb8, 0xd6, 0xac, 0xa8, 0x61, 0xe1, 0xf8,
	0x99, 0x3e, 0x1b, 0x8a, 0xbc, 0x34, 0x8c, 0xde, 0xff, 0xd2, 0x9e, 0x7d, 0xae, 0xfd, 0x9b, 0xf6,
	0xbb, 0xe9, 0xa5, 0xff, 0x7f, 0x57, 0xaf, 0xdf, 0x04, 0x23, 0xeb, 0x78, 0x07, 0x3b, 0xa7, 0x99,
	0x35, 0xdc, 0xd1, 0x5f, 0x07, 0x09, 0x46, 0x1d, 0x9c, 0x1e, 0x3e, 0x49, 0xa1, 0x36, 0x24, 0x81,
	0xe8, 0xf9, 0x38, 0x9d, 0x38, 0x85, 0x40, 0x6e, 0x48, 0x02, 0x59, 0xb2, 0xd3, 0x23, 0xa7, 0x10,
	0xc8, 0x8d, 0x99, 0xff, 0xbc, 0x01, 0xa6, 0x1a, 0xd4, 0x8e, 0xe7, 0xb9, 0x86, 0x4a, 0x35, 0x4d,
	0x1f, 0x5b, 0x2a, 0x5b, 0x4d, 0x03, 0x70, 0x58, 0x13, 0xd5, 0x7d, 0x25, 0x8d, 0x81, 0x15, 0xfd,
	0x7d, 0x70, 0x5d, 0xf9, 0x92, 0xd9, 0x5f, 0x33, 0x31, 0xb7, 0x50, 0x58, 0x2f, 0xa2, 0x84, 0x1b,
	0x7a, 0x5b, 0x23, 0x26, 0xa8, 0xf4, 0xf7, 0xf5, 0x87, 0x60, 0x26, 0xf6, 0xb6, 0x33, 0x50, 0x86,
	0x15, 0xca, 0xeb, 0x11, 0x65, 0xe1, 0x45, 0x60, 0x1b, 0xe0, 0x15, 0x8f, 0x9a, 0x31, 0xde, 0x91,
	0x8f, 0x58, 0xf2, 0xf0, 0x13, 0xf9, 0xab, 0xc7, 0xd2, 0x6c, 0xc5, 0xf5, 0x45, 0x6f, 0xf5, 0x82,
	0xf1, 0xb2, 0x47, 0xcb, 0x21, 0x57, 0x69, 0x80, 0x49, 0xf7, 0xc0, 0xd5, 0x53, 0xc1, 0x46, 0x15,
	0xd8, 0xfd, 0x73, 0xe6, 0xec, 0x93, 0xdf, 0xd8, 0x56, 0x2f, 0x18, 0x2f, 0xd9, 0xa7, 0xc8, 0x0b,
	0xf5, 0x8f, 0x83, 0xfd, 0x88, 0xc8, 0xe4, 0x19, 0xfa, 0x6b, 0x52, 0xff, 0x42, 0xc8, 0x75, 0x5c,
	0xff, 0x53, 0xc1, 0xc6, 0x7f, 0x5b, 0xfd, 0x35, 0xe3, 0x25, 0x74, 0x8a, 0xbc, 0x55, 0x70, 0x55,
	0xda, 0x9f, 0x51, 0xff, 0xa8, 0xbc, 0x89, 0x33, 0x94, 0x1f, 0x32, 0x74, 0x8f, 0x96, 0x19, 0xf5,
	0x8f, 0x20, 0x75, 0xc1, 0x95, 0x93, 0x30, 0x93, 0xbf, 0xad, 0xda, 0x43, 0x46, 0xca, 0x3e, 0x2e,
	0xe9, 0x8f, 0x87, 0xc1, 0xd8, 0x0e, 0x75, 0x02, 0x99, 0x4a, 0x2f, 0xaa, 0x54, 0xfa, 0x1f, 0x43,
	0x07, 0x7b, 0xda, 0x3f, 0x0c, 0x01, 0xed, 0x6d, 0x70, 0x15, 0xed, 0xf2, 0x8a, 0x83, 0xb8, 0x20,
	0x56, 0x51, 0xce, 0x50, 0x4d, 0x41, 0x19, 0x06, 0xe3, 0xe8, 0x8f, 0x02, 0x86, 0xcb, 0x84, 0x6f,
	0x47, 0x8f, 0xcb, 0xc4, 0xc1, 0x60, 0xd4, 0xc2, 0x7e, 0x77, 0xb9, 0x09, 0x46, 0x2d, 0xe2, 0xd9,
	0x98, 0x81, 0xf1, 0xf0, 0xc3, 0x4d, 0x0d, 0xf9, 0x60, 0xd8, 0xe2, 0x04, 0x4c, 0xd8, 0x74, 0xd7,
	0xdb, 0x45, 0xcc, 0x2e, 0x34, 0xaa, 0x20, 0x89, 0xe5, 0xe1, 0xcb, 0x84, 0x81, 0xa1, 0xb6, 0x05,
	0x40, 0xdb, 0xc1, 0x4f, 0x1e, 0x29, 0x25, 0xc0, 0x58, 0x5b, 0x0a, 0xc2, 0x0c, 0x5c, 0xe9, 0x58,
	0xb8, 0x81, 0x19, 0x57, 0x9f, 0x39, 0x84, 0x92, 0x36, 0xd6, 0x21, 0xc2, 0xc0, 0x3e, 0x05, 0xe3,
	0x1d, 0x27, 0xe0, 0x02, 0xb3, 0x36, 0x07, 0xc9, 0x6e, 0xd4, 0x1b, 0x81, 0x11, 0xc2, 0xa5, 0x9c,
	0x61, 0xaf, 0xcd, 0xc1, 0xcb, 0x7e, 0x9f, 0x33, 0xc4, 0x2d, 0x39, 0x88, 0xb8, 0xe0, 0xaa, 0xdf,
	0xa5, 0x82, 0x7a, 0xc7, 0x60, 0x2f, 0xc9, 0x0e, 0x77, 0x97, 0xb2, 0x58, 0x85, 0x71, 0x9f, 0xd1,
	0x4f, 0xb0, 0x25, 0xb0, 0x0d, 0xc6, 0x3e, 0x0d, 0xe8, 0x56, 0x4f, 0x60, 0x30, 0xcc, 0xb6, 0x6c,
	0x30, 0x26, 0x43, 0x0d, 0x57, 0xeb, 0x60, 0x94, 0x63, 0x8b, 0x61, 0x01, 0xc6, 0xb9, 0xa0, 0x0c,
	0x75, 0x30, 0xe5, 0xe0, 0xe2, 0x0e, 0xf7, 0xbb, 0x98, 0xe1, 0x10, 0xe3, 0x85, 0xd5, 0x28, 0x39,
	0x50, 0x83, 0x62, 0xbb, 0xeb, 0x8f, 0x0e, 0xfd, 0x54, 0x5a, 0xc2, 0x8c, 0xef, 0xe3, 0x92, 0xba,
	0x8f, 0x5b, 0xe7, 0x02, 0xd3, 0x23, 0x84, 0xe5, 0xbe, 0x29, 0xb9, 0xbe, 0x0b, 0xe2, 0x55, 0x53,
	0x5a, 0xc9, 0x94, 0x5d, 0x21, 0x4f, 0x5f, 0x56, 0x1d, 0xd7, 0xe2, 0x39, 0xdd, 0x68, 0xb0, 0xf5,
	0x2c, 0x5e, 0x3d, 0x55, 0x74, 0x2a, 0x12, 0x12, 0x93, 0x72, 0xbd, 0x0c, 0xe2, 0xf8, 0x30, 0x65,
	0xb3, 0x6c, 0xba, 0x34, 0xf0, 0x04, 0x4f, 0xa7, 0xd4, 0x79, 0x4e, 0x07, 0xb9, 0x12, 0x31, 0x34,
	0x18, 0xb5, 0x6a, 0x8a, 0x5c, 0xbf, 0x0f, 0xa6, 0xfa, 0x9d, 0xab, 0x29, 0x3b, 0x68, 0x53, 0x0d,
	0x3a, 0x6a, 0xa6, 0x4b, 0x5f, 0x51, 0x29, 0xf1, 0x5a, 0xdc, 0xc9, 0x1a, 0x94, 0x8a, 0xe5, 0xfe,
	0xae, 0xfe, 0x83, 0x43, 0x05, 0x2c, 0x4e, 0x4c, 0x9b, 0x91, 0x1d, 0xcc, 0x78, 0x5a, 0x57, 0x0a,
	0x64, 0x9e, 0xef, 0x69, 0xda, 0xb9, 0x8c, 0x1a, 0x2b, 0x55, 0xe2, 0xa4, 0x1c, 0x42, 0xe8, 0x37,
	0xc1, 0xa4, 0xb2, 0x65, 0xf4, 0x21, 0x2f, 0xfd, 0x92, 0xd2, 0x63, 0x42, 0xae, 0x6d, 0x84, 0x4b,
	0xfa, 0x12, 0x48, 0x85, 0xe6, 0xa6, 0x4c, 0xc4, 0x6d, 0xee, 0x55, 0x55, 0x7c, 0xc2, 0x96, 0x95,
	0x0d, 0x7f, 0x31, 0xa4, 0x19, 0x97, 0x94, 0xe3, 0x52, 0x26, 0xa2, 0xc6, 0x75, 0x2a, 0x74, 0x65,
	0x93, 0xf8, 0x56, 0xfa, 0x65, 0x05, 0x3a, 0x26, 0xdf, 0xab, 0xbe, 0xd5, 0xdf, 0xf2, 0x89, 0x9d,
	0xbe, 0x76, 0xb8, 0xd5, 0x20, 0xb6, 0xbe, 0x01, 0xae, 0xc5, 0x07, 0x0d, 0x3c, 0x8e, 0xda, 0xd8,
	0xe4, 0x3d, 0x6e, 0x09, 0x87, 0xa7, 0x5f, 0x51, 0x67, 0x4d, 0xc7, 0x67, 0x0d, 0x1b, 0xe5, 0x81,
	0xb3, 0xc5, 0x2e, 0xb7, 0xa9, 0xd8, 0x9a, 0x21, 0x97, 0x5e, 0x01, 0x57, 0xda, 0x94, 0x6d, 0x11,
	0xdb, 0xc6, 0x5e, 0x1f, 0x2a, 0xfd, 0x2d, 0x50, 0xa9, 0x3e, 0x4b, 0x0c, 0xf3, 0x00, 0x5c, 0xf2,
	0xa8, 0xec, 0x9f, 0x4c, 0xc4, 0x4d, 0x55, 0x7d, 0xaf, 0x9f, 0x91, 0x03, 0x87, 0x8d, 0x09, 0x8f,
	0xaa, 0x1e, 0x63, 0x93, 0x63, 0xa6, 0xff, 0x18, 0x4c, 0x0c, 0x72, 0xde, 0x50, 0x9c, 0xef, 0x9f,
	0x7b, 0x42, 0x38, 0x65, 0xe4, 0x58, 0x1d, 0x36, 0xc6, 0x59, 0x1f, 0xff, 0x03, 0x70, 0xf9, 0x50,
	0x39, 0x35, 0xbd, 0xa7, 0x5f, 0x3b, 0x43, 0xbb, 0x84, 0x31, 0x19, 0x69, 0xa7, 0x5a, 0x1b, 0xfd,
	0x0f, 0xc1, 0xe4, 0x11, 0xde, 0xe9, 0xef, 0x40, 0xbf, 0x84, 0x01, 0xd8, 0xa1, 0x84, 0x75, 0x70,
	0xcd, 0xa3, 0xe6, 0xc0, 0x48, 0xeb, 0x84, 0xa2, 0x78, 0x1a, 0x9e, 0xa1, 0xe7, 0x88, 0x71, 0xd5,
	0xa3, 0xcd, 0x01, 0xa6, 0xb0, 0x85, 0xd7, 0x29, 0x78, 0xe9, 0x34, 0xa8, 0x9b, 0xdf, 0x81, 0xda,
	0x23, 0x86, 0xce, 0x4f, 0x0a, 0xbc, 0x07, 0x26, 0x3d, 0x6a, 0xb6, 0x79, 0x2c, 0xe9, 0x8d, 0x33,
	0x94, 0x1e, 0x35, 0x80, 0x47, 0x97, 0x79, 0xc4, 0xd9, 0x03, 0x53, 0x31, 0x9b, 0xc9, 0x23, 0x79,
	0xf1, 0xaf, 0x76, 0xe9, 0x5b, 0xdf, 0x81, 0xc2, 0xa3, 0xc6, 0xb5, 0xa8, 0x43, 0x3d, 0xde, 0x91,
	0x3f, 0x04, 0x2f, 0x49, 0x9b, 0x63, 0xd3, 0x91, 0xfd, 0x7a, 0x5f, 0xe8, 0x9b, 0x2f, 0xd6, 0xbd,
	0x98, 0x90, 0x01, 0xb1, 0x3a, 0x66, 0xa4, 0x3c, 0xda, 0xc4, 0xaa, 0xcd, 0x8f, 0xc1, 0x38, 0x48,
	0x9d, 0x40, 0x7a, 0x4b, 0x21, 0x7d, 0x70, 0x4e, 0xf5, 0x4f, 0x9f, 0x1b, 0x8a, 0x49, 0x29, 0xf2,
	0x57, 0xa1, 0xd8, 0x4b, 0xfc, 0xa8, 0xd0, 0x65, 0x90, 0x0a, 0xdd, 0xfa, 0x70, 0x66, 0x49, 0xcf,
	0x7e, 0xab, 0xfa, 0x49, 0xe3, 0x92, 0xf2, 0xee, 0xfe, 0xe8, 0xa2, 0x73, 0x70, 0xf1, 0x28, 0xc8,
	0xdb, 0x0a, 0xa4, 0x78, 0x4e, 0xcd, 0xcf, 0x18, 0xe5, 0x06, 0xd4, 0x4f, 0x1a, 0x93, 0x6c, 0x80,
	0xf0, 0xbd, 0xbf, 0xd5, 0x7e, 0xb9, 0xa7, 0xfd, 0x8d, 0x06, 0xde, 0x06, 0xd7, 0xfb, 0x9d, 0xad,
	0xfa, 0xb0, 0x73, 0xa4, 0x59, 0x99, 0x5c, 0xc8, 0xe6, 0xb3, 0x8b, 0xd9, 0xa5, 0xec, 0xdd, 0xec,
	0xc2, 0x3b, 0xe0, 0x2d, 0xa0, 0x47, 0x95, 0x4e, 0x51, 0x46, 0x55, 0xe3, 0xca, 0xc2, 0x62, 0x76,
	0x61, 0x29, 0xbb, 0x70, 0x27, 0xbb, 0xf0, 0x6e, 0x76, 0xe1, 0x6e, 0x76, 0xe1, 0x1e, 0xf8, 0x1e,
	0xb8, 0x26, 0x6b, 0x53, 0xfc, 0x3b, 0x8f, 0x24, 0x0e, 0x13, 0x95, 0x7e, 0x65, 0xe1, 0x7e, 0x36,
	0xff, 0x4e, 0x36, 0xbf, 0x90, 0xcd, 0xe7, 0xb3, 0xf9, 0xc5, 0x6c, 0x7e, 0x09, 0xdc, 0x06, 0xa9,
	0xfe, 0x2f, 0x3b, 0x25, 0xea, 0x09, 0xfc, 0x44, 0xe8, 0x57, 0xf2, 0x77, 0xb2, 0xf9, 0x7b, 0xd9,
	0xc5, 0x85, 0xec, 0xe2, 0x52, 0x76, 0xf1, 0x6e, 0x76, 0xe9, 0x9d, 0x62, 0x0e, 0xdc, 0x38, 0xad,
	0x37, 0x36, 0xad, 0x2e, 0x25, 0x16, 0xd6, 0x2f, 0x3f, 0xdf, 0xd3, 0x46, 0xf6, 0xf7, 0xb4, 0xc4,
	0xc1, 0x9e, 0x36, 0x7c, 0x27, 0xfb, 0xae, 0xa4, 0x3f, 0xad, 0x17, 0x1d, 0xa4, 0x4f, 0xee, 0xef,
	0x69, 0x63, 0x92, 0xfe, 0x5e, 0xf6, 0x7e, 0x71, 0x0e, 0xa4, 0x4f, 0x74, 0x80, 0x31, 0xf1, 0x95,
	0xe7, 0x7b, 0xda, 0xc4, 0xfe, 0x9e, 0x06, 0x0e, 0xf6, 0xb4, 0x91, 0x85, 0x85, 0xec, 0x42, 0xbe,
	0x08, 0xc1, 0x84, 0x4c, 0x96, 0x83, 0x14, 0xd7, 0xf7, 0xf7, 0xb4, 0x29, 0x49, 0x91, 0x7f, 0x37,
	0x9b, 0xbf, 0x5b, 0xbc, 0x09, 0x26, 0xc3, 0xc0, 0x1a, 0x20, 0x79, 0x6d, 0x7f, 0x4f, 0x7b, 0x55,
	0x91, 0xdc, 0xcf, 0x2e, 0xca, 0x33, 0x4d, 0x9d, 0xcc, 0x14, 0x83, 0xf4, 0x70, 0x7f, 0x4f, 0x7b,
	0x5d, 0xd2, 0x2f, 0xe6, 0xb3, 0x8b, 0x8b, 0xc5, 0x5b, 0xe0, 0x72, 0x3f, 0x5c, 0x07, 0xa8, 0xde,
	0xd8, 0xdf, 0xd3, 0x66, 0x14, 0xd5, 0x9d, 0xec, 0xe2, 0xbb, 0xc5, 0x0c, 0xb8, 0xdc, 0x0f, 0x86,
	0x88, 0xea, 0xe5, 0xe7, 0x7b, 0xda, 0x9b, 0x5f, 0xec, 0x69, 0xda, 0xfe, 0x9e, 0x76, 0x5b, 0x51,
	0xde, 0xcb, 0x2e, 0xca, 0x33, 0x5f, 0x3d, 0x3a, 0x72, 0x0f, 0x90, 0xcf, 0x46, 0xe4, 0x19, 0x49,
	0xbe, 0xb4, 0x90, 0x5d, 0xca, 0xaf, 0x25, 0x92, 0x89, 0xd4, 0xc8, 0x5a, 0x22, 0x39, 0x96, 0x4a,
	0xae, 0x25, 0x92, 0x20, 0x35, 0xb1, 0x96, 0x48, 0x4e, 0xa5, 0xae, 0xaf, 0x25, 0x92, 0xaf, 0xa6,
	0x5e, 0x5b, 0x4b, 0x24, 0x5f, 0x4f, 0xc1, 0xb5, 0x44, 0x72, 0x26, 0xf5, 0xc6, 0x5a, 0x22, 0x79,
	0x3b, 0xf5, 0xe6, 0x5a, 0x22, 0x99, 0x49, 0xcd, 0xce, 0xec, 0x0f, 0x81, 0x4b, 0x2b, 0x0e, 0xdd,
	0x42, 0x4e, 0x7f, 0xc4, 0xb3, 0x40, 0xd2, 0xe7, 0xbe, 0x29, 0x47, 0x55, 0x35, 0xb0, 0x4d, 0xe4,
	0x3f, 0x3c, 0xa7, 0xb3, 0xbf, 0x70, 0x6c, 0x2c, 0x26, 0xf6, 0xa5, 0x9b, 0x5f, 0x30, 0xc6, 0x7c,
	0xee, 0xcb, 0x45, 0xfd, 0x3d, 0x90, 0xe8, 0x21, 0xd7, 0x89, 0x06, 0xd9, 0x5b, 0x32, 0x12, 0xfe,
	0x7b, 0x4f, 0x4b, 0xfc, 0xd5, 0xe7, 0x9a, 0x5a, 0x8f, 0x3a, 0x83, 0xf4, 0x53, 0x18, 0x3d, 0xfd,
	0x54, 0xb1, 0xab, 0x3d, 0xbd, 0x04, 0x2e, 0x75, 0xb0, 0x87, 0x65, 0x30, 0xd9, 0xa6, 0x42, 0xf9,
	0x66, 0x4c, 0xc1, 0xdc, 0xf8, 0xf2, 0x27, 0x2a, 0x9e, 0x4e, 0xe3, 0x36, 0x2e, 0xf6, 0x79, 0x3e,
	0x42, 0xae, 0xf3, 0xde, 0xec, 0x2f, 0xf7, 0xb4, 0xdb, 0xe0, 0x0d, 0x30, 0xdd, 0xa0, 0xf6, 0xe1,
	0x8f, 0x97, 0xa1, 0xda, 0xb0, 0x81, 0x18, 0x72, 0xb1, 0x90, 0x1d, 0x8e, 0xb6, 0x50, 0x7c, 0x0b,
	0x5c, 0x0d, 0xbb, 0x77, 0xd3, 0xc5, 0xa2, 0x4b, 0xed, 0x41, 0x2f, 0x1d, 0x92, 0x07, 0x93, 0x5e,
	0x9a, 0xcf, 0x2e, 0xae, 0x25, 0x92, 0x5a, 0x6a, 0x68, 0x66, 0x5f, 0x03, 0x97, 0xc2, 0x4f, 0xd2,
	0x7d, 0x93, 0xfe, 0xe8, 0xbb, 0x37, 0xe9, 0xa0, 0x31, 0xaf, 0x0e, 0x1a, 0x33, 0x36, 0xd3, 0x7b,
	0x57, 0xfe, 0xe9, 0xfb, 0xc7, 0xae, 0xb6, 0xf8, 0xce, 0x0b, 0x4e, 0x92, 0xfe, 0x93, 0xff, 0xd1,
	0x4e, 0xdd, 0x89, 0x8e, 0xf4, 0x2f, 0x1a, 0xb8, 0x6c, 0x60, 0xdf, 0x41, 0xd6, 0xef, 0xcf, 0x99,
	0xfe, 0x59, 0x03, 0x13, 0x2b, 0x58, 0xfc, 0xbe, 0x9c, 0xa7, 0xf8, 0x33, 0x6d, 0xff, 0xab, 0xe9,
	0x0b, 0x5f, 0x7e, 0x35, 0x7d, 0xe1, 0xd7, 0x5f, 0x4d, 0x6b, 0x4f, 0x0f, 0xa6, 0xb5, 0x5f, 0x1c,
	0x4c, 0x6b, 0x5f, 0x1c, 0x4c, 0x6b, 0xfb, 0x07, 0xd3, 0xda, 0x97, 0x07, 0xd3, 0xda, 0xbf, 0x1f,
	0x4c, 0x6b, 0xbf, 0x3a, 0x98, 0xbe, 0xf0, 0xeb, 0x83, 0x69, 0xed, 0xa7, 0x5f, 0x4f, 0x5f, 0x78,
	0xfe, 0xf5, 0xb4, 0xb6, 0xff, 0xf5, 0xf4, 0x85, 0x2f, 0xbf, 0x9e, 0xbe, 0xf0, 0xf1, 0x0f, 0x3b,
	0xd4, 0xdf, 0xee, 0xe4, 0x76, 0xa8, 0x23, 0x30, 0x63, 0x28, 0x17, 0xf0, 0x79, 0xf5, 0xd0, 0xa6,
	0xcc, 0x9d, 0x8b, 0x3e, 0x6e, 0xb1, 0xb9, 0x78, 0x7b, 0xde, 0xdf, 0xea, 0xd0, 0x79, 0xfc, 0x44,
	0x44, 0x7f, 0x28, 0x3a, 0xfb, 0x6f, 0x53, 0x5b, 0xa3, 0xea, 0x3f, 0x46, 0x8b, 0xff, 0x1b, 0x00,
	0x00, 0xff, 0xff, 0x10, 0xe6, 0x32, 0x9d, 0x66, 0x25, 0x00, 0x00,
}

func (this *CapabilityListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CapabilityListType)
	if !ok {
		that2, ok := that.(CapabilityListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Capabilities) != len(that1.Capabilities) {
		return false
	}
	for i := range this.Capabilities {
		if this.Capabilities[i] != that1.Capabilities[i] {
			return false
		}
	}
	return true
}
func (this *HostPathType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HostPathType)
	if !ok {
		that2, ok := that.(HostPathType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PathPrefix != that1.PathPrefix {
		return false
	}
	if this.ReadOnly != that1.ReadOnly {
		return false
	}
	return true
}
func (this *IDRangeType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IDRangeType)
	if !ok {
		that2, ok := that.(IDRangeType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MinId != that1.MinId {
		return false
	}
	if this.MaxId != that1.MaxId {
		return false
	}
	return true
}
func (this *IDStrategyOptionsType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IDStrategyOptionsType)
	if !ok {
		that2, ok := that.(IDStrategyOptionsType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.IdRanges) != len(that1.IdRanges) {
		return false
	}
	for i := range this.IdRanges {
		if !this.IdRanges[i].Equal(that1.IdRanges[i]) {
			return false
		}
	}
	if this.Rule != that1.Rule {
		return false
	}
	return true
}
func (this *RuntimeClassStrategyOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RuntimeClassStrategyOptions)
	if !ok {
		that2, ok := that.(RuntimeClassStrategyOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.AllowedRuntimeClassNames) != len(that1.AllowedRuntimeClassNames) {
		return false
	}
	for i := range this.AllowedRuntimeClassNames {
		if this.AllowedRuntimeClassNames[i] != that1.AllowedRuntimeClassNames[i] {
			return false
		}
	}
	if this.DefaultRuntimeClassName != that1.DefaultRuntimeClassName {
		return false
	}
	return true
}
func (this *SELinuxStrategyOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SELinuxStrategyOptions)
	if !ok {
		that2, ok := that.(SELinuxStrategyOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Rule != that1.Rule {
		return false
	}
	if this.Level != that1.Level {
		return false
	}
	if this.Role != that1.Role {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.User != that1.User {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Privileged != that1.Privileged {
		return false
	}
	if this.AllowPrivilegeEscalation != that1.AllowPrivilegeEscalation {
		return false
	}
	if this.DefaultAllowPrivilegeEscalation != that1.DefaultAllowPrivilegeEscalation {
		return false
	}
	if that1.DefaultCapabilitiesChoice == nil {
		if this.DefaultCapabilitiesChoice != nil {
			return false
		}
	} else if this.DefaultCapabilitiesChoice == nil {
		return false
	} else if !this.DefaultCapabilitiesChoice.Equal(that1.DefaultCapabilitiesChoice) {
		return false
	}
	if that1.AllowedCapabilitiesChoice == nil {
		if this.AllowedCapabilitiesChoice != nil {
			return false
		}
	} else if this.AllowedCapabilitiesChoice == nil {
		return false
	} else if !this.AllowedCapabilitiesChoice.Equal(that1.AllowedCapabilitiesChoice) {
		return false
	}
	if that1.DropCapabilitiesChoice == nil {
		if this.DropCapabilitiesChoice != nil {
			return false
		}
	} else if this.DropCapabilitiesChoice == nil {
		return false
	} else if !this.DropCapabilitiesChoice.Equal(that1.DropCapabilitiesChoice) {
		return false
	}
	if len(this.Volumes) != len(that1.Volumes) {
		return false
	}
	for i := range this.Volumes {
		if this.Volumes[i] != that1.Volumes[i] {
			return false
		}
	}
	if len(this.AllowedFlexVolumes) != len(that1.AllowedFlexVolumes) {
		return false
	}
	for i := range this.AllowedFlexVolumes {
		if this.AllowedFlexVolumes[i] != that1.AllowedFlexVolumes[i] {
			return false
		}
	}
	if len(this.AllowedHostPaths) != len(that1.AllowedHostPaths) {
		return false
	}
	for i := range this.AllowedHostPaths {
		if !this.AllowedHostPaths[i].Equal(that1.AllowedHostPaths[i]) {
			return false
		}
	}
	if len(this.AllowedProcMounts) != len(that1.AllowedProcMounts) {
		return false
	}
	for i := range this.AllowedProcMounts {
		if this.AllowedProcMounts[i] != that1.AllowedProcMounts[i] {
			return false
		}
	}
	if this.ReadOnlyRootFilesystem != that1.ReadOnlyRootFilesystem {
		return false
	}
	if len(this.AllowedCsiDrivers) != len(that1.AllowedCsiDrivers) {
		return false
	}
	for i := range this.AllowedCsiDrivers {
		if this.AllowedCsiDrivers[i] != that1.AllowedCsiDrivers[i] {
			return false
		}
	}
	if this.HostNetwork != that1.HostNetwork {
		return false
	}
	if this.HostPortRanges != that1.HostPortRanges {
		return false
	}
	if this.HostIpc != that1.HostIpc {
		return false
	}
	if this.HostPid != that1.HostPid {
		return false
	}
	if len(this.AllowedUnsafeSysctls) != len(that1.AllowedUnsafeSysctls) {
		return false
	}
	for i := range this.AllowedUnsafeSysctls {
		if this.AllowedUnsafeSysctls[i] != that1.AllowedUnsafeSysctls[i] {
			return false
		}
	}
	if len(this.ForbiddenSysctls) != len(that1.ForbiddenSysctls) {
		return false
	}
	for i := range this.ForbiddenSysctls {
		if this.ForbiddenSysctls[i] != that1.ForbiddenSysctls[i] {
			return false
		}
	}
	if that1.UserChoice == nil {
		if this.UserChoice != nil {
			return false
		}
	} else if this.UserChoice == nil {
		return false
	} else if !this.UserChoice.Equal(that1.UserChoice) {
		return false
	}
	if that1.GroupChoice == nil {
		if this.GroupChoice != nil {
			return false
		}
	} else if this.GroupChoice == nil {
		return false
	} else if !this.GroupChoice.Equal(that1.GroupChoice) {
		return false
	}
	if that1.SupplementalGroupChoice == nil {
		if this.SupplementalGroupChoice != nil {
			return false
		}
	} else if this.SupplementalGroupChoice == nil {
		return false
	} else if !this.SupplementalGroupChoice.Equal(that1.SupplementalGroupChoice) {
		return false
	}
	if that1.FsGroupChoice == nil {
		if this.FsGroupChoice != nil {
			return false
		}
	} else if this.FsGroupChoice == nil {
		return false
	} else if !this.FsGroupChoice.Equal(that1.FsGroupChoice) {
		return false
	}
	if that1.SeLinuxChoice == nil {
		if this.SeLinuxChoice != nil {
			return false
		}
	} else if this.SeLinuxChoice == nil {
		return false
	} else if !this.SeLinuxChoice.Equal(that1.SeLinuxChoice) {
		return false
	}
	if that1.RuntimeClassChoice == nil {
		if this.RuntimeClassChoice != nil {
			return false
		}
	} else if this.RuntimeClassChoice == nil {
		return false
	} else if !this.RuntimeClassChoice.Equal(that1.RuntimeClassChoice) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_NoDefaultCapabilities) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_NoDefaultCapabilities)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_NoDefaultCapabilities)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoDefaultCapabilities.Equal(that1.NoDefaultCapabilities) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_DefaultCapabilities) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_DefaultCapabilities)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_DefaultCapabilities)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DefaultCapabilities.Equal(that1.DefaultCapabilities) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_NoAllowedCapabilities) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_NoAllowedCapabilities)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_NoAllowedCapabilities)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoAllowedCapabilities.Equal(that1.NoAllowedCapabilities) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_AllowedCapabilities) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_AllowedCapabilities)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_AllowedCapabilities)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AllowedCapabilities.Equal(that1.AllowedCapabilities) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_NoDropCapabilities) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_NoDropCapabilities)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_NoDropCapabilities)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoDropCapabilities.Equal(that1.NoDropCapabilities) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_DropCapabilities) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_DropCapabilities)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_DropCapabilities)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DropCapabilities.Equal(that1.DropCapabilities) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_NoRunAsUser) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_NoRunAsUser)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_NoRunAsUser)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoRunAsUser.Equal(that1.NoRunAsUser) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_RunAsUser) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_RunAsUser)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_RunAsUser)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RunAsUser.Equal(that1.RunAsUser) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_NoRunAsGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_NoRunAsGroup)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_NoRunAsGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoRunAsGroup.Equal(that1.NoRunAsGroup) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_RunAsGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_RunAsGroup)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_RunAsGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RunAsGroup.Equal(that1.RunAsGroup) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_NoSupplementalGroups) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_NoSupplementalGroups)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_NoSupplementalGroups)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoSupplementalGroups.Equal(that1.NoSupplementalGroups) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_SupplementalGroups) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_SupplementalGroups)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_SupplementalGroups)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SupplementalGroups.Equal(that1.SupplementalGroups) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_NoFsGroups) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_NoFsGroups)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_NoFsGroups)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoFsGroups.Equal(that1.NoFsGroups) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_FsGroupStrategyOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_FsGroupStrategyOptions)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_FsGroupStrategyOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FsGroupStrategyOptions.Equal(that1.FsGroupStrategyOptions) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_NoSeLinuxOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_NoSeLinuxOptions)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_NoSeLinuxOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoSeLinuxOptions.Equal(that1.NoSeLinuxOptions) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_SeLinuxOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_SeLinuxOptions)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_SeLinuxOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SeLinuxOptions.Equal(that1.SeLinuxOptions) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_NoRuntimeClass) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_NoRuntimeClass)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_NoRuntimeClass)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NoRuntimeClass.Equal(that1.NoRuntimeClass) {
		return false
	}
	return true
}
func (this *PodSecurityPolicySpecType_RuntimeClass) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodSecurityPolicySpecType_RuntimeClass)
	if !ok {
		that2, ok := that.(PodSecurityPolicySpecType_RuntimeClass)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RuntimeClass.Equal(that1.RuntimeClass) {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ConfigMethodChoice == nil {
		if this.ConfigMethodChoice != nil {
			return false
		}
	} else if this.ConfigMethodChoice == nil {
		return false
	} else if !this.ConfigMethodChoice.Equal(that1.ConfigMethodChoice) {
		return false
	}
	if this.GeneratedYaml != that1.GeneratedYaml {
		return false
	}
	return true
}
func (this *GlobalSpecType_PspSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_PspSpec)
	if !ok {
		that2, ok := that.(GlobalSpecType_PspSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PspSpec.Equal(that1.PspSpec) {
		return false
	}
	return true
}
func (this *GlobalSpecType_Yaml) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType_Yaml)
	if !ok {
		that2, ok := that.(GlobalSpecType_Yaml)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Yaml != that1.Yaml {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ConfigMethodChoice == nil {
		if this.ConfigMethodChoice != nil {
			return false
		}
	} else if this.ConfigMethodChoice == nil {
		return false
	} else if !this.ConfigMethodChoice.Equal(that1.ConfigMethodChoice) {
		return false
	}
	return true
}
func (this *CreateSpecType_PspSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_PspSpec)
	if !ok {
		that2, ok := that.(CreateSpecType_PspSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PspSpec.Equal(that1.PspSpec) {
		return false
	}
	return true
}
func (this *CreateSpecType_Yaml) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType_Yaml)
	if !ok {
		that2, ok := that.(CreateSpecType_Yaml)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Yaml != that1.Yaml {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ConfigMethodChoice == nil {
		if this.ConfigMethodChoice != nil {
			return false
		}
	} else if this.ConfigMethodChoice == nil {
		return false
	} else if !this.ConfigMethodChoice.Equal(that1.ConfigMethodChoice) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_PspSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_PspSpec)
	if !ok {
		that2, ok := that.(ReplaceSpecType_PspSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PspSpec.Equal(that1.PspSpec) {
		return false
	}
	return true
}
func (this *ReplaceSpecType_Yaml) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType_Yaml)
	if !ok {
		that2, ok := that.(ReplaceSpecType_Yaml)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Yaml != that1.Yaml {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ConfigMethodChoice == nil {
		if this.ConfigMethodChoice != nil {
			return false
		}
	} else if this.ConfigMethodChoice == nil {
		return false
	} else if !this.ConfigMethodChoice.Equal(that1.ConfigMethodChoice) {
		return false
	}
	return true
}
func (this *GetSpecType_PspSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_PspSpec)
	if !ok {
		that2, ok := that.(GetSpecType_PspSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PspSpec.Equal(that1.PspSpec) {
		return false
	}
	return true
}
func (this *GetSpecType_Yaml) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType_Yaml)
	if !ok {
		that2, ok := that.(GetSpecType_Yaml)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Yaml != that1.Yaml {
		return false
	}
	return true
}
func (this *CapabilityListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&k8s_pod_security_policy.CapabilityListType{")
	s = append(s, "Capabilities: "+fmt.Sprintf("%#v", this.Capabilities)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HostPathType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&k8s_pod_security_policy.HostPathType{")
	s = append(s, "PathPrefix: "+fmt.Sprintf("%#v", this.PathPrefix)+",\n")
	s = append(s, "ReadOnly: "+fmt.Sprintf("%#v", this.ReadOnly)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IDRangeType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&k8s_pod_security_policy.IDRangeType{")
	s = append(s, "MinId: "+fmt.Sprintf("%#v", this.MinId)+",\n")
	s = append(s, "MaxId: "+fmt.Sprintf("%#v", this.MaxId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IDStrategyOptionsType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&k8s_pod_security_policy.IDStrategyOptionsType{")
	if this.IdRanges != nil {
		s = append(s, "IdRanges: "+fmt.Sprintf("%#v", this.IdRanges)+",\n")
	}
	s = append(s, "Rule: "+fmt.Sprintf("%#v", this.Rule)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RuntimeClassStrategyOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&k8s_pod_security_policy.RuntimeClassStrategyOptions{")
	s = append(s, "AllowedRuntimeClassNames: "+fmt.Sprintf("%#v", this.AllowedRuntimeClassNames)+",\n")
	s = append(s, "DefaultRuntimeClassName: "+fmt.Sprintf("%#v", this.DefaultRuntimeClassName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SELinuxStrategyOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&k8s_pod_security_policy.SELinuxStrategyOptions{")
	s = append(s, "Rule: "+fmt.Sprintf("%#v", this.Rule)+",\n")
	s = append(s, "Level: "+fmt.Sprintf("%#v", this.Level)+",\n")
	s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PodSecurityPolicySpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 37)
	s = append(s, "&k8s_pod_security_policy.PodSecurityPolicySpecType{")
	s = append(s, "Privileged: "+fmt.Sprintf("%#v", this.Privileged)+",\n")
	s = append(s, "AllowPrivilegeEscalation: "+fmt.Sprintf("%#v", this.AllowPrivilegeEscalation)+",\n")
	s = append(s, "DefaultAllowPrivilegeEscalation: "+fmt.Sprintf("%#v", this.DefaultAllowPrivilegeEscalation)+",\n")
	if this.DefaultCapabilitiesChoice != nil {
		s = append(s, "DefaultCapabilitiesChoice: "+fmt.Sprintf("%#v", this.DefaultCapabilitiesChoice)+",\n")
	}
	if this.AllowedCapabilitiesChoice != nil {
		s = append(s, "AllowedCapabilitiesChoice: "+fmt.Sprintf("%#v", this.AllowedCapabilitiesChoice)+",\n")
	}
	if this.DropCapabilitiesChoice != nil {
		s = append(s, "DropCapabilitiesChoice: "+fmt.Sprintf("%#v", this.DropCapabilitiesChoice)+",\n")
	}
	s = append(s, "Volumes: "+fmt.Sprintf("%#v", this.Volumes)+",\n")
	s = append(s, "AllowedFlexVolumes: "+fmt.Sprintf("%#v", this.AllowedFlexVolumes)+",\n")
	if this.AllowedHostPaths != nil {
		s = append(s, "AllowedHostPaths: "+fmt.Sprintf("%#v", this.AllowedHostPaths)+",\n")
	}
	s = append(s, "AllowedProcMounts: "+fmt.Sprintf("%#v", this.AllowedProcMounts)+",\n")
	s = append(s, "ReadOnlyRootFilesystem: "+fmt.Sprintf("%#v", this.ReadOnlyRootFilesystem)+",\n")
	s = append(s, "AllowedCsiDrivers: "+fmt.Sprintf("%#v", this.AllowedCsiDrivers)+",\n")
	s = append(s, "HostNetwork: "+fmt.Sprintf("%#v", this.HostNetwork)+",\n")
	s = append(s, "HostPortRanges: "+fmt.Sprintf("%#v", this.HostPortRanges)+",\n")
	s = append(s, "HostIpc: "+fmt.Sprintf("%#v", this.HostIpc)+",\n")
	s = append(s, "HostPid: "+fmt.Sprintf("%#v", this.HostPid)+",\n")
	s = append(s, "AllowedUnsafeSysctls: "+fmt.Sprintf("%#v", this.AllowedUnsafeSysctls)+",\n")
	s = append(s, "ForbiddenSysctls: "+fmt.Sprintf("%#v", this.ForbiddenSysctls)+",\n")
	if this.UserChoice != nil {
		s = append(s, "UserChoice: "+fmt.Sprintf("%#v", this.UserChoice)+",\n")
	}
	if this.GroupChoice != nil {
		s = append(s, "GroupChoice: "+fmt.Sprintf("%#v", this.GroupChoice)+",\n")
	}
	if this.SupplementalGroupChoice != nil {
		s = append(s, "SupplementalGroupChoice: "+fmt.Sprintf("%#v", this.SupplementalGroupChoice)+",\n")
	}
	if this.FsGroupChoice != nil {
		s = append(s, "FsGroupChoice: "+fmt.Sprintf("%#v", this.FsGroupChoice)+",\n")
	}
	if this.SeLinuxChoice != nil {
		s = append(s, "SeLinuxChoice: "+fmt.Sprintf("%#v", this.SeLinuxChoice)+",\n")
	}
	if this.RuntimeClassChoice != nil {
		s = append(s, "RuntimeClassChoice: "+fmt.Sprintf("%#v", this.RuntimeClassChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PodSecurityPolicySpecType_NoDefaultCapabilities) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_NoDefaultCapabilities{` +
		`NoDefaultCapabilities:` + fmt.Sprintf("%#v", this.NoDefaultCapabilities) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_DefaultCapabilities) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_DefaultCapabilities{` +
		`DefaultCapabilities:` + fmt.Sprintf("%#v", this.DefaultCapabilities) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_NoAllowedCapabilities) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_NoAllowedCapabilities{` +
		`NoAllowedCapabilities:` + fmt.Sprintf("%#v", this.NoAllowedCapabilities) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_AllowedCapabilities) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_AllowedCapabilities{` +
		`AllowedCapabilities:` + fmt.Sprintf("%#v", this.AllowedCapabilities) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_NoDropCapabilities) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_NoDropCapabilities{` +
		`NoDropCapabilities:` + fmt.Sprintf("%#v", this.NoDropCapabilities) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_DropCapabilities) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_DropCapabilities{` +
		`DropCapabilities:` + fmt.Sprintf("%#v", this.DropCapabilities) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_NoRunAsUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_NoRunAsUser{` +
		`NoRunAsUser:` + fmt.Sprintf("%#v", this.NoRunAsUser) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_RunAsUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_RunAsUser{` +
		`RunAsUser:` + fmt.Sprintf("%#v", this.RunAsUser) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_NoRunAsGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_NoRunAsGroup{` +
		`NoRunAsGroup:` + fmt.Sprintf("%#v", this.NoRunAsGroup) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_RunAsGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_RunAsGroup{` +
		`RunAsGroup:` + fmt.Sprintf("%#v", this.RunAsGroup) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_NoSupplementalGroups) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_NoSupplementalGroups{` +
		`NoSupplementalGroups:` + fmt.Sprintf("%#v", this.NoSupplementalGroups) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_SupplementalGroups) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_SupplementalGroups{` +
		`SupplementalGroups:` + fmt.Sprintf("%#v", this.SupplementalGroups) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_NoFsGroups) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_NoFsGroups{` +
		`NoFsGroups:` + fmt.Sprintf("%#v", this.NoFsGroups) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_FsGroupStrategyOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_FsGroupStrategyOptions{` +
		`FsGroupStrategyOptions:` + fmt.Sprintf("%#v", this.FsGroupStrategyOptions) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_NoSeLinuxOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_NoSeLinuxOptions{` +
		`NoSeLinuxOptions:` + fmt.Sprintf("%#v", this.NoSeLinuxOptions) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_SeLinuxOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_SeLinuxOptions{` +
		`SeLinuxOptions:` + fmt.Sprintf("%#v", this.SeLinuxOptions) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_NoRuntimeClass) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_NoRuntimeClass{` +
		`NoRuntimeClass:` + fmt.Sprintf("%#v", this.NoRuntimeClass) + `}`}, ", ")
	return s
}
func (this *PodSecurityPolicySpecType_RuntimeClass) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.PodSecurityPolicySpecType_RuntimeClass{` +
		`RuntimeClass:` + fmt.Sprintf("%#v", this.RuntimeClass) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&k8s_pod_security_policy.GlobalSpecType{")
	if this.ConfigMethodChoice != nil {
		s = append(s, "ConfigMethodChoice: "+fmt.Sprintf("%#v", this.ConfigMethodChoice)+",\n")
	}
	s = append(s, "GeneratedYaml: "+fmt.Sprintf("%#v", this.GeneratedYaml)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType_PspSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.GlobalSpecType_PspSpec{` +
		`PspSpec:` + fmt.Sprintf("%#v", this.PspSpec) + `}`}, ", ")
	return s
}
func (this *GlobalSpecType_Yaml) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.GlobalSpecType_Yaml{` +
		`Yaml:` + fmt.Sprintf("%#v", this.Yaml) + `}`}, ", ")
	return s
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&k8s_pod_security_policy.CreateSpecType{")
	if this.ConfigMethodChoice != nil {
		s = append(s, "ConfigMethodChoice: "+fmt.Sprintf("%#v", this.ConfigMethodChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType_PspSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.CreateSpecType_PspSpec{` +
		`PspSpec:` + fmt.Sprintf("%#v", this.PspSpec) + `}`}, ", ")
	return s
}
func (this *CreateSpecType_Yaml) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.CreateSpecType_Yaml{` +
		`Yaml:` + fmt.Sprintf("%#v", this.Yaml) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&k8s_pod_security_policy.ReplaceSpecType{")
	if this.ConfigMethodChoice != nil {
		s = append(s, "ConfigMethodChoice: "+fmt.Sprintf("%#v", this.ConfigMethodChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType_PspSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.ReplaceSpecType_PspSpec{` +
		`PspSpec:` + fmt.Sprintf("%#v", this.PspSpec) + `}`}, ", ")
	return s
}
func (this *ReplaceSpecType_Yaml) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.ReplaceSpecType_Yaml{` +
		`Yaml:` + fmt.Sprintf("%#v", this.Yaml) + `}`}, ", ")
	return s
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&k8s_pod_security_policy.GetSpecType{")
	if this.ConfigMethodChoice != nil {
		s = append(s, "ConfigMethodChoice: "+fmt.Sprintf("%#v", this.ConfigMethodChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType_PspSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.GetSpecType_PspSpec{` +
		`PspSpec:` + fmt.Sprintf("%#v", this.PspSpec) + `}`}, ", ")
	return s
}
func (this *GetSpecType_Yaml) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&k8s_pod_security_policy.GetSpecType_Yaml{` +
		`Yaml:` + fmt.Sprintf("%#v", this.Yaml) + `}`}, ", ")
	return s
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *CapabilityListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CapabilityListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CapabilityListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Capabilities) > 0 {
		for iNdEx := len(m.Capabilities) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Capabilities[iNdEx])
			copy(dAtA[i:], m.Capabilities[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Capabilities[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *HostPathType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HostPathType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HostPathType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReadOnly {
		i--
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.PathPrefix) > 0 {
		i -= len(m.PathPrefix)
		copy(dAtA[i:], m.PathPrefix)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PathPrefix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IDRangeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IDRangeType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IDRangeType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxId))
		i--
		dAtA[i] = 0x10
	}
	if m.MinId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MinId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IDStrategyOptionsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IDStrategyOptionsType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IDStrategyOptionsType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rule) > 0 {
		i -= len(m.Rule)
		copy(dAtA[i:], m.Rule)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Rule)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.IdRanges) > 0 {
		for iNdEx := len(m.IdRanges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IdRanges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RuntimeClassStrategyOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuntimeClassStrategyOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RuntimeClassStrategyOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DefaultRuntimeClassName) > 0 {
		i -= len(m.DefaultRuntimeClassName)
		copy(dAtA[i:], m.DefaultRuntimeClassName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DefaultRuntimeClassName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AllowedRuntimeClassNames) > 0 {
		for iNdEx := len(m.AllowedRuntimeClassNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedRuntimeClassNames[iNdEx])
			copy(dAtA[i:], m.AllowedRuntimeClassNames[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AllowedRuntimeClassNames[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SELinuxStrategyOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SELinuxStrategyOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SELinuxStrategyOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Level) > 0 {
		i -= len(m.Level)
		copy(dAtA[i:], m.Level)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Level)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Rule) > 0 {
		i -= len(m.Rule)
		copy(dAtA[i:], m.Rule)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Rule)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PodSecurityPolicySpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodSecurityPolicySpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodSecurityPolicySpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RuntimeClassChoice != nil {
		{
			size := m.RuntimeClassChoice.Size()
			i -= size
			if _, err := m.RuntimeClassChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SeLinuxChoice != nil {
		{
			size := m.SeLinuxChoice.Size()
			i -= size
			if _, err := m.SeLinuxChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.FsGroupChoice != nil {
		{
			size := m.FsGroupChoice.Size()
			i -= size
			if _, err := m.FsGroupChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.SupplementalGroupChoice != nil {
		{
			size := m.SupplementalGroupChoice.Size()
			i -= size
			if _, err := m.SupplementalGroupChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.GroupChoice != nil {
		{
			size := m.GroupChoice.Size()
			i -= size
			if _, err := m.GroupChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.UserChoice != nil {
		{
			size := m.UserChoice.Size()
			i -= size
			if _, err := m.UserChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.ForbiddenSysctls) > 0 {
		for iNdEx := len(m.ForbiddenSysctls) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ForbiddenSysctls[iNdEx])
			copy(dAtA[i:], m.ForbiddenSysctls[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ForbiddenSysctls[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.AllowedUnsafeSysctls) > 0 {
		for iNdEx := len(m.AllowedUnsafeSysctls) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedUnsafeSysctls[iNdEx])
			copy(dAtA[i:], m.AllowedUnsafeSysctls[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AllowedUnsafeSysctls[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xba
		}
	}
	if m.HostPid {
		i--
		if m.HostPid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.HostIpc {
		i--
		if m.HostIpc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if len(m.HostPortRanges) > 0 {
		i -= len(m.HostPortRanges)
		copy(dAtA[i:], m.HostPortRanges)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HostPortRanges)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.HostNetwork {
		i--
		if m.HostNetwork {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if len(m.AllowedCsiDrivers) > 0 {
		for iNdEx := len(m.AllowedCsiDrivers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedCsiDrivers[iNdEx])
			copy(dAtA[i:], m.AllowedCsiDrivers[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AllowedCsiDrivers[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if m.ReadOnlyRootFilesystem {
		i--
		if m.ReadOnlyRootFilesystem {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.AllowedProcMounts) > 0 {
		for iNdEx := len(m.AllowedProcMounts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedProcMounts[iNdEx])
			copy(dAtA[i:], m.AllowedProcMounts[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AllowedProcMounts[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.AllowedHostPaths) > 0 {
		for iNdEx := len(m.AllowedHostPaths) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AllowedHostPaths[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.AllowedFlexVolumes) > 0 {
		for iNdEx := len(m.AllowedFlexVolumes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedFlexVolumes[iNdEx])
			copy(dAtA[i:], m.AllowedFlexVolumes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AllowedFlexVolumes[iNdEx])))
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.Volumes) > 0 {
		for iNdEx := len(m.Volumes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Volumes[iNdEx])
			copy(dAtA[i:], m.Volumes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Volumes[iNdEx])))
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.DropCapabilitiesChoice != nil {
		{
			size := m.DropCapabilitiesChoice.Size()
			i -= size
			if _, err := m.DropCapabilitiesChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AllowedCapabilitiesChoice != nil {
		{
			size := m.AllowedCapabilitiesChoice.Size()
			i -= size
			if _, err := m.AllowedCapabilitiesChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DefaultCapabilitiesChoice != nil {
		{
			size := m.DefaultCapabilitiesChoice.Size()
			i -= size
			if _, err := m.DefaultCapabilitiesChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.DefaultAllowPrivilegeEscalation {
		i--
		if m.DefaultAllowPrivilegeEscalation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AllowPrivilegeEscalation {
		i--
		if m.AllowPrivilegeEscalation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Privileged {
		i--
		if m.Privileged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PodSecurityPolicySpecType_NoDefaultCapabilities) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodSecurityPolicySpecType_NoDefaultCapabilities) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoDefaultCapabilities != nil {
		{
			size, err := m.NoDefaultCapabilities.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *PodSecurityPolicySpecType_DefaultCapabilities) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodSecurityPolicySpecType_DefaultCapabilities) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DefaultCapabilities != nil {
		{
			size, err := m.DefaultCapabilities.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *PodSecurityPolicySpecType_NoAllowedCapabilities) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodSecurityPolicySpecType_NoAllowedCapabilities) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoAllowedCapabilities != nil {
		{
			size, err := m.NoAllowedCapabilities.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *PodSecurityPolicySpecType_AllowedCapabilities) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodSecurityPolicySpecType_AllowedCapabilities) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AllowedCapabilities != nil {
		{
			size, err := m.AllowedCapabilities.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *PodSecurityPolicySpecType_NoDropCapabilities) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodSecurityPolicySpecType_NoDropCapabilities) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoDropCapabilities != nil {
		{
			size, err := m.NoDropCapabilities.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *PodSecurityPolicySpecType_DropCapabilities) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodSecurityPolicySpecType_DropCapabilities) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DropCapabilities != nil {
		{
			size, err := m.DropCapabilities.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *PodSecurityPolicySpecType_NoRunAsUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodSecurityPolicySpecType_NoRunAsUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoRunAsUser != nil {
		{
			size, err := m.NoRunAsUser.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *PodSecurityPolicySpecType_RunAsUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodSecurityPolicySpecType_RunAsUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RunAsUser != nil {
		{
			size, err := m.RunAsUser.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *PodSecurityPolicySpecType_NoRunAsGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodSecurityPolicySpecType_NoRunAsGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoRunAsGroup != nil {
		{
			size, err := m.NoRunAsGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *PodSecurityPolicySpecType_RunAsGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodSecurityPolicySpecType_RunAsGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RunAsGroup != nil {
		{
			size, err := m.RunAsGroup.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *PodSecurityPolicySpecType_NoSupplementalGroups) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodSecurityPolicySpecType_NoSupplementalGroups) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoSupplementalGroups != nil {
		{
			size, err := m.NoSupplementalGroups.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *PodSecurityPolicySpecType_SupplementalGroups) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodSecurityPolicySpecType_SupplementalGroups) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SupplementalGroups != nil {
		{
			size, err := m.SupplementalGroups.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *PodSecurityPolicySpecType_NoFsGroups) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodSecurityPolicySpecType_NoFsGroups) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoFsGroups != nil {
		{
			size, err := m.NoFsGroups.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *PodSecurityPolicySpecType_FsGroupStrategyOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodSecurityPolicySpecType_FsGroupStrategyOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FsGroupStrategyOptions != nil {
		{
			size, err := m.FsGroupStrategyOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *PodSecurityPolicySpecType_NoSeLinuxOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodSecurityPolicySpecType_NoSeLinuxOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoSeLinuxOptions != nil {
		{
			size, err := m.NoSeLinuxOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *PodSecurityPolicySpecType_SeLinuxOptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodSecurityPolicySpecType_SeLinuxOptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SeLinuxOptions != nil {
		{
			size, err := m.SeLinuxOptions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *PodSecurityPolicySpecType_NoRuntimeClass) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodSecurityPolicySpecType_NoRuntimeClass) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NoRuntimeClass != nil {
		{
			size, err := m.NoRuntimeClass.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *PodSecurityPolicySpecType_RuntimeClass) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PodSecurityPolicySpecType_RuntimeClass) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RuntimeClass != nil {
		{
			size, err := m.RuntimeClass.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GeneratedYaml) > 0 {
		i -= len(m.GeneratedYaml)
		copy(dAtA[i:], m.GeneratedYaml)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GeneratedYaml)))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xca
	}
	if m.ConfigMethodChoice != nil {
		{
			size := m.ConfigMethodChoice.Size()
			i -= size
			if _, err := m.ConfigMethodChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType_PspSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_PspSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PspSpec != nil {
		{
			size, err := m.PspSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GlobalSpecType_Yaml) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType_Yaml) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Yaml)
	copy(dAtA[i:], m.Yaml)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Yaml)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConfigMethodChoice != nil {
		{
			size := m.ConfigMethodChoice.Size()
			i -= size
			if _, err := m.ConfigMethodChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType_PspSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_PspSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PspSpec != nil {
		{
			size, err := m.PspSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CreateSpecType_Yaml) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType_Yaml) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Yaml)
	copy(dAtA[i:], m.Yaml)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Yaml)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConfigMethodChoice != nil {
		{
			size := m.ConfigMethodChoice.Size()
			i -= size
			if _, err := m.ConfigMethodChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType_PspSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_PspSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PspSpec != nil {
		{
			size, err := m.PspSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ReplaceSpecType_Yaml) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType_Yaml) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Yaml)
	copy(dAtA[i:], m.Yaml)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Yaml)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConfigMethodChoice != nil {
		{
			size := m.ConfigMethodChoice.Size()
			i -= size
			if _, err := m.ConfigMethodChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType_PspSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_PspSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PspSpec != nil {
		{
			size, err := m.PspSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GetSpecType_Yaml) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType_Yaml) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Yaml)
	copy(dAtA[i:], m.Yaml)
	i = encodeVarintTypes(dAtA, i, uint64(len(m.Yaml)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CapabilityListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Capabilities) > 0 {
		for _, s := range m.Capabilities {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *HostPathType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PathPrefix)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ReadOnly {
		n += 2
	}
	return n
}

func (m *IDRangeType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinId != 0 {
		n += 1 + sovTypes(uint64(m.MinId))
	}
	if m.MaxId != 0 {
		n += 1 + sovTypes(uint64(m.MaxId))
	}
	return n
}

func (m *IDStrategyOptionsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IdRanges) > 0 {
		for _, e := range m.IdRanges {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Rule)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RuntimeClassStrategyOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AllowedRuntimeClassNames) > 0 {
		for _, s := range m.AllowedRuntimeClassNames {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.DefaultRuntimeClassName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SELinuxStrategyOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Rule)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Level)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *PodSecurityPolicySpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Privileged {
		n += 2
	}
	if m.AllowPrivilegeEscalation {
		n += 2
	}
	if m.DefaultAllowPrivilegeEscalation {
		n += 2
	}
	if m.DefaultCapabilitiesChoice != nil {
		n += m.DefaultCapabilitiesChoice.Size()
	}
	if m.AllowedCapabilitiesChoice != nil {
		n += m.AllowedCapabilitiesChoice.Size()
	}
	if m.DropCapabilitiesChoice != nil {
		n += m.DropCapabilitiesChoice.Size()
	}
	if len(m.Volumes) > 0 {
		for _, s := range m.Volumes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AllowedFlexVolumes) > 0 {
		for _, s := range m.AllowedFlexVolumes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AllowedHostPaths) > 0 {
		for _, e := range m.AllowedHostPaths {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AllowedProcMounts) > 0 {
		for _, s := range m.AllowedProcMounts {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.ReadOnlyRootFilesystem {
		n += 3
	}
	if len(m.AllowedCsiDrivers) > 0 {
		for _, s := range m.AllowedCsiDrivers {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.HostNetwork {
		n += 3
	}
	l = len(m.HostPortRanges)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.HostIpc {
		n += 3
	}
	if m.HostPid {
		n += 3
	}
	if len(m.AllowedUnsafeSysctls) > 0 {
		for _, s := range m.AllowedUnsafeSysctls {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ForbiddenSysctls) > 0 {
		for _, s := range m.ForbiddenSysctls {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.UserChoice != nil {
		n += m.UserChoice.Size()
	}
	if m.GroupChoice != nil {
		n += m.GroupChoice.Size()
	}
	if m.SupplementalGroupChoice != nil {
		n += m.SupplementalGroupChoice.Size()
	}
	if m.FsGroupChoice != nil {
		n += m.FsGroupChoice.Size()
	}
	if m.SeLinuxChoice != nil {
		n += m.SeLinuxChoice.Size()
	}
	if m.RuntimeClassChoice != nil {
		n += m.RuntimeClassChoice.Size()
	}
	return n
}

func (m *PodSecurityPolicySpecType_NoDefaultCapabilities) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoDefaultCapabilities != nil {
		l = m.NoDefaultCapabilities.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_DefaultCapabilities) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultCapabilities != nil {
		l = m.DefaultCapabilities.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_NoAllowedCapabilities) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoAllowedCapabilities != nil {
		l = m.NoAllowedCapabilities.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_AllowedCapabilities) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowedCapabilities != nil {
		l = m.AllowedCapabilities.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_NoDropCapabilities) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoDropCapabilities != nil {
		l = m.NoDropCapabilities.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_DropCapabilities) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropCapabilities != nil {
		l = m.DropCapabilities.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_NoRunAsUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoRunAsUser != nil {
		l = m.NoRunAsUser.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_RunAsUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RunAsUser != nil {
		l = m.RunAsUser.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_NoRunAsGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoRunAsGroup != nil {
		l = m.NoRunAsGroup.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_RunAsGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RunAsGroup != nil {
		l = m.RunAsGroup.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_NoSupplementalGroups) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoSupplementalGroups != nil {
		l = m.NoSupplementalGroups.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_SupplementalGroups) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SupplementalGroups != nil {
		l = m.SupplementalGroups.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_NoFsGroups) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoFsGroups != nil {
		l = m.NoFsGroups.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_FsGroupStrategyOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FsGroupStrategyOptions != nil {
		l = m.FsGroupStrategyOptions.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_NoSeLinuxOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoSeLinuxOptions != nil {
		l = m.NoSeLinuxOptions.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_SeLinuxOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SeLinuxOptions != nil {
		l = m.SeLinuxOptions.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_NoRuntimeClass) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NoRuntimeClass != nil {
		l = m.NoRuntimeClass.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PodSecurityPolicySpecType_RuntimeClass) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RuntimeClass != nil {
		l = m.RuntimeClass.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfigMethodChoice != nil {
		n += m.ConfigMethodChoice.Size()
	}
	l = len(m.GeneratedYaml)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType_PspSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PspSpec != nil {
		l = m.PspSpec.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GlobalSpecType_Yaml) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Yaml)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfigMethodChoice != nil {
		n += m.ConfigMethodChoice.Size()
	}
	return n
}

func (m *CreateSpecType_PspSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PspSpec != nil {
		l = m.PspSpec.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *CreateSpecType_Yaml) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Yaml)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfigMethodChoice != nil {
		n += m.ConfigMethodChoice.Size()
	}
	return n
}

func (m *ReplaceSpecType_PspSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PspSpec != nil {
		l = m.PspSpec.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *ReplaceSpecType_Yaml) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Yaml)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfigMethodChoice != nil {
		n += m.ConfigMethodChoice.Size()
	}
	return n
}

func (m *GetSpecType_PspSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PspSpec != nil {
		l = m.PspSpec.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *GetSpecType_Yaml) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Yaml)
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *CapabilityListType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CapabilityListType{`,
		`Capabilities:` + fmt.Sprintf("%v", this.Capabilities) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HostPathType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HostPathType{`,
		`PathPrefix:` + fmt.Sprintf("%v", this.PathPrefix) + `,`,
		`ReadOnly:` + fmt.Sprintf("%v", this.ReadOnly) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IDRangeType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IDRangeType{`,
		`MinId:` + fmt.Sprintf("%v", this.MinId) + `,`,
		`MaxId:` + fmt.Sprintf("%v", this.MaxId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IDStrategyOptionsType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForIdRanges := "[]*IDRangeType{"
	for _, f := range this.IdRanges {
		repeatedStringForIdRanges += strings.Replace(f.String(), "IDRangeType", "IDRangeType", 1) + ","
	}
	repeatedStringForIdRanges += "}"
	s := strings.Join([]string{`&IDStrategyOptionsType{`,
		`IdRanges:` + repeatedStringForIdRanges + `,`,
		`Rule:` + fmt.Sprintf("%v", this.Rule) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RuntimeClassStrategyOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RuntimeClassStrategyOptions{`,
		`AllowedRuntimeClassNames:` + fmt.Sprintf("%v", this.AllowedRuntimeClassNames) + `,`,
		`DefaultRuntimeClassName:` + fmt.Sprintf("%v", this.DefaultRuntimeClassName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SELinuxStrategyOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SELinuxStrategyOptions{`,
		`Rule:` + fmt.Sprintf("%v", this.Rule) + `,`,
		`Level:` + fmt.Sprintf("%v", this.Level) + `,`,
		`Role:` + fmt.Sprintf("%v", this.Role) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`User:` + fmt.Sprintf("%v", this.User) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAllowedHostPaths := "[]*HostPathType{"
	for _, f := range this.AllowedHostPaths {
		repeatedStringForAllowedHostPaths += strings.Replace(f.String(), "HostPathType", "HostPathType", 1) + ","
	}
	repeatedStringForAllowedHostPaths += "}"
	s := strings.Join([]string{`&PodSecurityPolicySpecType{`,
		`Privileged:` + fmt.Sprintf("%v", this.Privileged) + `,`,
		`AllowPrivilegeEscalation:` + fmt.Sprintf("%v", this.AllowPrivilegeEscalation) + `,`,
		`DefaultAllowPrivilegeEscalation:` + fmt.Sprintf("%v", this.DefaultAllowPrivilegeEscalation) + `,`,
		`DefaultCapabilitiesChoice:` + fmt.Sprintf("%v", this.DefaultCapabilitiesChoice) + `,`,
		`AllowedCapabilitiesChoice:` + fmt.Sprintf("%v", this.AllowedCapabilitiesChoice) + `,`,
		`DropCapabilitiesChoice:` + fmt.Sprintf("%v", this.DropCapabilitiesChoice) + `,`,
		`Volumes:` + fmt.Sprintf("%v", this.Volumes) + `,`,
		`AllowedFlexVolumes:` + fmt.Sprintf("%v", this.AllowedFlexVolumes) + `,`,
		`AllowedHostPaths:` + repeatedStringForAllowedHostPaths + `,`,
		`AllowedProcMounts:` + fmt.Sprintf("%v", this.AllowedProcMounts) + `,`,
		`ReadOnlyRootFilesystem:` + fmt.Sprintf("%v", this.ReadOnlyRootFilesystem) + `,`,
		`AllowedCsiDrivers:` + fmt.Sprintf("%v", this.AllowedCsiDrivers) + `,`,
		`HostNetwork:` + fmt.Sprintf("%v", this.HostNetwork) + `,`,
		`HostPortRanges:` + fmt.Sprintf("%v", this.HostPortRanges) + `,`,
		`HostIpc:` + fmt.Sprintf("%v", this.HostIpc) + `,`,
		`HostPid:` + fmt.Sprintf("%v", this.HostPid) + `,`,
		`AllowedUnsafeSysctls:` + fmt.Sprintf("%v", this.AllowedUnsafeSysctls) + `,`,
		`ForbiddenSysctls:` + fmt.Sprintf("%v", this.ForbiddenSysctls) + `,`,
		`UserChoice:` + fmt.Sprintf("%v", this.UserChoice) + `,`,
		`GroupChoice:` + fmt.Sprintf("%v", this.GroupChoice) + `,`,
		`SupplementalGroupChoice:` + fmt.Sprintf("%v", this.SupplementalGroupChoice) + `,`,
		`FsGroupChoice:` + fmt.Sprintf("%v", this.FsGroupChoice) + `,`,
		`SeLinuxChoice:` + fmt.Sprintf("%v", this.SeLinuxChoice) + `,`,
		`RuntimeClassChoice:` + fmt.Sprintf("%v", this.RuntimeClassChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_NoDefaultCapabilities) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_NoDefaultCapabilities{`,
		`NoDefaultCapabilities:` + strings.Replace(fmt.Sprintf("%v", this.NoDefaultCapabilities), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_DefaultCapabilities) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_DefaultCapabilities{`,
		`DefaultCapabilities:` + strings.Replace(fmt.Sprintf("%v", this.DefaultCapabilities), "CapabilityListType", "CapabilityListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_NoAllowedCapabilities) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_NoAllowedCapabilities{`,
		`NoAllowedCapabilities:` + strings.Replace(fmt.Sprintf("%v", this.NoAllowedCapabilities), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_AllowedCapabilities) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_AllowedCapabilities{`,
		`AllowedCapabilities:` + strings.Replace(fmt.Sprintf("%v", this.AllowedCapabilities), "CapabilityListType", "CapabilityListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_NoDropCapabilities) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_NoDropCapabilities{`,
		`NoDropCapabilities:` + strings.Replace(fmt.Sprintf("%v", this.NoDropCapabilities), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_DropCapabilities) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_DropCapabilities{`,
		`DropCapabilities:` + strings.Replace(fmt.Sprintf("%v", this.DropCapabilities), "CapabilityListType", "CapabilityListType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_NoRunAsUser) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_NoRunAsUser{`,
		`NoRunAsUser:` + strings.Replace(fmt.Sprintf("%v", this.NoRunAsUser), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_RunAsUser) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_RunAsUser{`,
		`RunAsUser:` + strings.Replace(fmt.Sprintf("%v", this.RunAsUser), "IDStrategyOptionsType", "IDStrategyOptionsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_NoRunAsGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_NoRunAsGroup{`,
		`NoRunAsGroup:` + strings.Replace(fmt.Sprintf("%v", this.NoRunAsGroup), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_RunAsGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_RunAsGroup{`,
		`RunAsGroup:` + strings.Replace(fmt.Sprintf("%v", this.RunAsGroup), "IDStrategyOptionsType", "IDStrategyOptionsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_NoSupplementalGroups) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_NoSupplementalGroups{`,
		`NoSupplementalGroups:` + strings.Replace(fmt.Sprintf("%v", this.NoSupplementalGroups), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_SupplementalGroups) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_SupplementalGroups{`,
		`SupplementalGroups:` + strings.Replace(fmt.Sprintf("%v", this.SupplementalGroups), "IDStrategyOptionsType", "IDStrategyOptionsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_NoFsGroups) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_NoFsGroups{`,
		`NoFsGroups:` + strings.Replace(fmt.Sprintf("%v", this.NoFsGroups), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_FsGroupStrategyOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_FsGroupStrategyOptions{`,
		`FsGroupStrategyOptions:` + strings.Replace(fmt.Sprintf("%v", this.FsGroupStrategyOptions), "IDStrategyOptionsType", "IDStrategyOptionsType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_NoSeLinuxOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_NoSeLinuxOptions{`,
		`NoSeLinuxOptions:` + strings.Replace(fmt.Sprintf("%v", this.NoSeLinuxOptions), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_SeLinuxOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_SeLinuxOptions{`,
		`SeLinuxOptions:` + strings.Replace(fmt.Sprintf("%v", this.SeLinuxOptions), "SELinuxStrategyOptions", "SELinuxStrategyOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_NoRuntimeClass) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_NoRuntimeClass{`,
		`NoRuntimeClass:` + strings.Replace(fmt.Sprintf("%v", this.NoRuntimeClass), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodSecurityPolicySpecType_RuntimeClass) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodSecurityPolicySpecType_RuntimeClass{`,
		`RuntimeClass:` + strings.Replace(fmt.Sprintf("%v", this.RuntimeClass), "RuntimeClassStrategyOptions", "RuntimeClassStrategyOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType{`,
		`ConfigMethodChoice:` + fmt.Sprintf("%v", this.ConfigMethodChoice) + `,`,
		`GeneratedYaml:` + fmt.Sprintf("%v", this.GeneratedYaml) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_PspSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_PspSpec{`,
		`PspSpec:` + strings.Replace(fmt.Sprintf("%v", this.PspSpec), "PodSecurityPolicySpecType", "PodSecurityPolicySpecType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType_Yaml) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalSpecType_Yaml{`,
		`Yaml:` + fmt.Sprintf("%v", this.Yaml) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`ConfigMethodChoice:` + fmt.Sprintf("%v", this.ConfigMethodChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_PspSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_PspSpec{`,
		`PspSpec:` + strings.Replace(fmt.Sprintf("%v", this.PspSpec), "PodSecurityPolicySpecType", "PodSecurityPolicySpecType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType_Yaml) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType_Yaml{`,
		`Yaml:` + fmt.Sprintf("%v", this.Yaml) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`ConfigMethodChoice:` + fmt.Sprintf("%v", this.ConfigMethodChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_PspSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_PspSpec{`,
		`PspSpec:` + strings.Replace(fmt.Sprintf("%v", this.PspSpec), "PodSecurityPolicySpecType", "PodSecurityPolicySpecType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType_Yaml) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType_Yaml{`,
		`Yaml:` + fmt.Sprintf("%v", this.Yaml) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType{`,
		`ConfigMethodChoice:` + fmt.Sprintf("%v", this.ConfigMethodChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_PspSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_PspSpec{`,
		`PspSpec:` + strings.Replace(fmt.Sprintf("%v", this.PspSpec), "PodSecurityPolicySpecType", "PodSecurityPolicySpecType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType_Yaml) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetSpecType_Yaml{`,
		`Yaml:` + fmt.Sprintf("%v", this.Yaml) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *CapabilityListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CapabilityListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CapabilityListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capabilities", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Capabilities = append(m.Capabilities, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HostPathType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HostPathType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HostPathType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IDRangeType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IDRangeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IDRangeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinId", wireType)
			}
			m.MinId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxId", wireType)
			}
			m.MaxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IDStrategyOptionsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IDStrategyOptionsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IDStrategyOptionsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdRanges = append(m.IdRanges, &IDRangeType{})
			if err := m.IdRanges[len(m.IdRanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rule = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuntimeClassStrategyOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuntimeClassStrategyOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuntimeClassStrategyOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedRuntimeClassNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedRuntimeClassNames = append(m.AllowedRuntimeClassNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultRuntimeClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultRuntimeClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SELinuxStrategyOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SELinuxStrategyOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SELinuxStrategyOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rule = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Level = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodSecurityPolicySpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodSecurityPolicySpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodSecurityPolicySpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Privileged = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowPrivilegeEscalation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowPrivilegeEscalation = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultAllowPrivilegeEscalation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DefaultAllowPrivilegeEscalation = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoDefaultCapabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DefaultCapabilitiesChoice = &PodSecurityPolicySpecType_NoDefaultCapabilities{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultCapabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CapabilityListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DefaultCapabilitiesChoice = &PodSecurityPolicySpecType_DefaultCapabilities{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoAllowedCapabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AllowedCapabilitiesChoice = &PodSecurityPolicySpecType_NoAllowedCapabilities{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedCapabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CapabilityListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AllowedCapabilitiesChoice = &PodSecurityPolicySpecType_AllowedCapabilities{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoDropCapabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DropCapabilitiesChoice = &PodSecurityPolicySpecType_NoDropCapabilities{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropCapabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CapabilityListType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DropCapabilitiesChoice = &PodSecurityPolicySpecType_DropCapabilities{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volumes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Volumes = append(m.Volumes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedFlexVolumes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedFlexVolumes = append(m.AllowedFlexVolumes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedHostPaths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedHostPaths = append(m.AllowedHostPaths, &HostPathType{})
			if err := m.AllowedHostPaths[len(m.AllowedHostPaths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedProcMounts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedProcMounts = append(m.AllowedProcMounts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnlyRootFilesystem", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnlyRootFilesystem = bool(v != 0)
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedCsiDrivers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedCsiDrivers = append(m.AllowedCsiDrivers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostNetwork", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostNetwork = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPortRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostPortRanges = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIpc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostIpc = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostPid = bool(v != 0)
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedUnsafeSysctls", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedUnsafeSysctls = append(m.AllowedUnsafeSysctls, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForbiddenSysctls", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForbiddenSysctls = append(m.ForbiddenSysctls, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoRunAsUser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UserChoice = &PodSecurityPolicySpecType_NoRunAsUser{v}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunAsUser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IDStrategyOptionsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UserChoice = &PodSecurityPolicySpecType_RunAsUser{v}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoRunAsGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GroupChoice = &PodSecurityPolicySpecType_NoRunAsGroup{v}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunAsGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IDStrategyOptionsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.GroupChoice = &PodSecurityPolicySpecType_RunAsGroup{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoSupplementalGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SupplementalGroupChoice = &PodSecurityPolicySpecType_NoSupplementalGroups{v}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupplementalGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IDStrategyOptionsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SupplementalGroupChoice = &PodSecurityPolicySpecType_SupplementalGroups{v}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoFsGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FsGroupChoice = &PodSecurityPolicySpecType_NoFsGroups{v}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FsGroupStrategyOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &IDStrategyOptionsType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.FsGroupChoice = &PodSecurityPolicySpecType_FsGroupStrategyOptions{v}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoSeLinuxOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SeLinuxChoice = &PodSecurityPolicySpecType_NoSeLinuxOptions{v}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeLinuxOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SELinuxStrategyOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.SeLinuxChoice = &PodSecurityPolicySpecType_SeLinuxOptions{v}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoRuntimeClass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuntimeClassChoice = &PodSecurityPolicySpecType_NoRuntimeClass{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeClass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RuntimeClassStrategyOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuntimeClassChoice = &PodSecurityPolicySpecType_RuntimeClass{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PspSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PodSecurityPolicySpecType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConfigMethodChoice = &GlobalSpecType_PspSpec{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigMethodChoice = &GlobalSpecType_Yaml{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedYaml", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeneratedYaml = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PspSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PodSecurityPolicySpecType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConfigMethodChoice = &CreateSpecType_PspSpec{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigMethodChoice = &CreateSpecType_Yaml{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PspSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PodSecurityPolicySpecType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConfigMethodChoice = &ReplaceSpecType_PspSpec{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigMethodChoice = &ReplaceSpecType_Yaml{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PspSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PodSecurityPolicySpecType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ConfigMethodChoice = &GetSpecType_PspSpec{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigMethodChoice = &GetSpecType_Yaml{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
