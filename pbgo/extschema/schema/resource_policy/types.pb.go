// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/resource_policy/types.proto

package resource_policy

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	golang_proto "github.com/golang/protobuf/proto"
	_ "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Resource List
//
// x-displayName: "Resource List"
// List of resources in terms of resource-types/resource-instances and verbs
type ResourceListType struct {
	// Resource Type
	//
	// x-displayName: "Resource Types"
	// x-example: "virtual_network"
	// x-required
	// list of resource types, match any one
	ResourceTypes []string `protobuf:"bytes,2,rep,name=resource_types,json=resourceTypes,proto3" json:"resource_types,omitempty"`
	// Resource Instances
	//
	// x-displayName: "Resource Instances"
	// x-example: "private-network-tenant1"
	// list of resource instances within the matched resource types, match any one.
	// Use * for all resource instances
	ResourceInstances []string `protobuf:"bytes,3,rep,name=resource_instances,json=resourceInstances,proto3" json:"resource_instances,omitempty"`
	// Access Type
	//
	// x-displayName: "Access Type"
	// x-example: "get"
	// x-required
	// Allowed list of verbs(operations) on resources. Use * for all operations
	Verbs []string `protobuf:"bytes,4,rep,name=verbs,proto3" json:"verbs,omitempty"`
}

func (m *ResourceListType) Reset()      { *m = ResourceListType{} }
func (*ResourceListType) ProtoMessage() {}
func (*ResourceListType) Descriptor() ([]byte, []int) {
	return fileDescriptor_adece90bcba7812a, []int{0}
}
func (m *ResourceListType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceListType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ResourceListType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceListType.Merge(m, src)
}
func (m *ResourceListType) XXX_Size() int {
	return m.Size()
}
func (m *ResourceListType) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceListType.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceListType proto.InternalMessageInfo

func (m *ResourceListType) GetResourceTypes() []string {
	if m != nil {
		return m.ResourceTypes
	}
	return nil
}

func (m *ResourceListType) GetResourceInstances() []string {
	if m != nil {
		return m.ResourceInstances
	}
	return nil
}

func (m *ResourceListType) GetVerbs() []string {
	if m != nil {
		return m.Verbs
	}
	return nil
}

// Tenant Subject Type
//
// x-displayName: "Tenant Subject Type"
// Allowed tuple  Of {tenant and role}
type TenantSubjectType struct {
	// Tenant
	//
	// x-displayName: "Tenant"
	// x-example: "tenant-1"
	// x-required
	// Id of the tenant that is allowed access, * means all tenants
	Tenant string `protobuf:"bytes,1,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// Role
	//
	// x-displayName: "admin"
	// x-example: "admin"
	// x-required
	// role within matching tenant is allowed access, * means all role
	Role string `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
}

func (m *TenantSubjectType) Reset()      { *m = TenantSubjectType{} }
func (*TenantSubjectType) ProtoMessage() {}
func (*TenantSubjectType) Descriptor() ([]byte, []int) {
	return fileDescriptor_adece90bcba7812a, []int{1}
}
func (m *TenantSubjectType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TenantSubjectType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TenantSubjectType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TenantSubjectType.Merge(m, src)
}
func (m *TenantSubjectType) XXX_Size() int {
	return m.Size()
}
func (m *TenantSubjectType) XXX_DiscardUnknown() {
	xxx_messageInfo_TenantSubjectType.DiscardUnknown(m)
}

var xxx_messageInfo_TenantSubjectType proto.InternalMessageInfo

func (m *TenantSubjectType) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *TenantSubjectType) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

// Rule
//
// x-displayName: "Rule"
// Access policy rule specification
type TenantRuleType struct {
	// Resource Access Match
	//
	// x-displayName: "Resource Access Match"
	// x-required
	// Match access to the resource type/instance/access-type
	Resource *ResourceListType `protobuf:"bytes,1,opt,name=resource,proto3" json:"resource,omitempty"`
	// Allowed Tenant and Role
	//
	// x-displayName: "Allowed Tenant and Role"
	// x-required
	// Match access to the resource type/instance/access-type
	Tenants []*TenantSubjectType `protobuf:"bytes,2,rep,name=tenants,proto3" json:"tenants,omitempty"`
}

func (m *TenantRuleType) Reset()      { *m = TenantRuleType{} }
func (*TenantRuleType) ProtoMessage() {}
func (*TenantRuleType) Descriptor() ([]byte, []int) {
	return fileDescriptor_adece90bcba7812a, []int{2}
}
func (m *TenantRuleType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TenantRuleType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TenantRuleType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TenantRuleType.Merge(m, src)
}
func (m *TenantRuleType) XXX_Size() int {
	return m.Size()
}
func (m *TenantRuleType) XXX_DiscardUnknown() {
	xxx_messageInfo_TenantRuleType.DiscardUnknown(m)
}

var xxx_messageInfo_TenantRuleType proto.InternalMessageInfo

func (m *TenantRuleType) GetResource() *ResourceListType {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *TenantRuleType) GetTenants() []*TenantSubjectType {
	if m != nil {
		return m.Tenants
	}
	return nil
}

// User Subject Type
//
// x-displayName: "User Subject Type"
// Allowed tuple  Of {namespace, role}
type UserSubjectType struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-example: "production"
	// namespace that is allowed access, * means all namespaces, empty means current namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Role
	//
	// x-displayName: "admin"
	// x-example: "admin"
	// x-required
	// role within matching namespace is allowed access, * means all role
	Role string `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
}

func (m *UserSubjectType) Reset()      { *m = UserSubjectType{} }
func (*UserSubjectType) ProtoMessage() {}
func (*UserSubjectType) Descriptor() ([]byte, []int) {
	return fileDescriptor_adece90bcba7812a, []int{3}
}
func (m *UserSubjectType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserSubjectType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UserSubjectType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserSubjectType.Merge(m, src)
}
func (m *UserSubjectType) XXX_Size() int {
	return m.Size()
}
func (m *UserSubjectType) XXX_DiscardUnknown() {
	xxx_messageInfo_UserSubjectType.DiscardUnknown(m)
}

var xxx_messageInfo_UserSubjectType proto.InternalMessageInfo

func (m *UserSubjectType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *UserSubjectType) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

// Rule
//
// x-displayName: "Rule"
// Access policy rule specification
type UserRuleType struct {
	// Resource Access Match
	//
	// x-displayName: "Resource Access Match"
	// x-required
	// Match access to the resource type/instance/access-type
	Resource *ResourceListType `protobuf:"bytes,1,opt,name=resource,proto3" json:"resource,omitempty"`
	// Allowed Namespace and Role
	//
	// x-displayName: "Allowed Namespace and Role"
	// x-required
	// Allowed subjects who can access
	Users []*UserSubjectType `protobuf:"bytes,2,rep,name=users,proto3" json:"users,omitempty"`
}

func (m *UserRuleType) Reset()      { *m = UserRuleType{} }
func (*UserRuleType) ProtoMessage() {}
func (*UserRuleType) Descriptor() ([]byte, []int) {
	return fileDescriptor_adece90bcba7812a, []int{4}
}
func (m *UserRuleType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserRuleType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UserRuleType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRuleType.Merge(m, src)
}
func (m *UserRuleType) XXX_Size() int {
	return m.Size()
}
func (m *UserRuleType) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRuleType.DiscardUnknown(m)
}

var xxx_messageInfo_UserRuleType proto.InternalMessageInfo

func (m *UserRuleType) GetResource() *ResourceListType {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *UserRuleType) GetUsers() []*UserSubjectType {
	if m != nil {
		return m.Users
	}
	return nil
}

// Policy Rule
//
// x-displayName: "Policy Rule"
// Rule for role permission
type PolicyRuleType struct {
	// Select type of rule
	//
	// x-displayName: "Select Rule Type"
	// x-required
	// Select rule type
	//
	// Types that are valid to be assigned to RuleChoice:
	//	*PolicyRuleType_TenantShare
	//	*PolicyRuleType_NamespaceShare
	RuleChoice isPolicyRuleType_RuleChoice `protobuf_oneof:"rule_choice"`
}

func (m *PolicyRuleType) Reset()      { *m = PolicyRuleType{} }
func (*PolicyRuleType) ProtoMessage() {}
func (*PolicyRuleType) Descriptor() ([]byte, []int) {
	return fileDescriptor_adece90bcba7812a, []int{5}
}
func (m *PolicyRuleType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PolicyRuleType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PolicyRuleType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyRuleType.Merge(m, src)
}
func (m *PolicyRuleType) XXX_Size() int {
	return m.Size()
}
func (m *PolicyRuleType) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyRuleType.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyRuleType proto.InternalMessageInfo

type isPolicyRuleType_RuleChoice interface {
	isPolicyRuleType_RuleChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PolicyRuleType_TenantShare struct {
	TenantShare *TenantRuleType `protobuf:"bytes,2,opt,name=tenant_share,json=tenantShare,proto3,oneof" json:"tenant_share,omitempty"`
}
type PolicyRuleType_NamespaceShare struct {
	NamespaceShare *UserRuleType `protobuf:"bytes,3,opt,name=namespace_share,json=namespaceShare,proto3,oneof" json:"namespace_share,omitempty"`
}

func (*PolicyRuleType_TenantShare) isPolicyRuleType_RuleChoice()    {}
func (*PolicyRuleType_NamespaceShare) isPolicyRuleType_RuleChoice() {}

func (m *PolicyRuleType) GetRuleChoice() isPolicyRuleType_RuleChoice {
	if m != nil {
		return m.RuleChoice
	}
	return nil
}

func (m *PolicyRuleType) GetTenantShare() *TenantRuleType {
	if x, ok := m.GetRuleChoice().(*PolicyRuleType_TenantShare); ok {
		return x.TenantShare
	}
	return nil
}

func (m *PolicyRuleType) GetNamespaceShare() *UserRuleType {
	if x, ok := m.GetRuleChoice().(*PolicyRuleType_NamespaceShare); ok {
		return x.NamespaceShare
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PolicyRuleType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PolicyRuleType_TenantShare)(nil),
		(*PolicyRuleType_NamespaceShare)(nil),
	}
}

// Subject Type
//
// x-displayName: "Subject Type"
// Allowed tuple  Of {tenant, namespace, role}
type SubjectType struct {
	// Tenant
	//
	// x-displayName: "Tenant"
	// x-example: "tenant-1"
	// tenant that is allowed access, * means all tenants, empty means ignore tenant
	Tenant string `protobuf:"bytes,1,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// NameSpace
	//
	// x-displayName: "Namespace"
	// x-example: "production"
	// namespace that is allowed access, * means all namespaces, empty means ignore namespace
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Role
	//
	// x-displayName: "admin"
	// x-example: "admin"
	// x-required
	// role within matching tenant and namespace is allowed access, * means all roles
	Role string `protobuf:"bytes,3,opt,name=role,proto3" json:"role,omitempty"`
}

func (m *SubjectType) Reset()      { *m = SubjectType{} }
func (*SubjectType) ProtoMessage() {}
func (*SubjectType) Descriptor() ([]byte, []int) {
	return fileDescriptor_adece90bcba7812a, []int{6}
}
func (m *SubjectType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubjectType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SubjectType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubjectType.Merge(m, src)
}
func (m *SubjectType) XXX_Size() int {
	return m.Size()
}
func (m *SubjectType) XXX_DiscardUnknown() {
	xxx_messageInfo_SubjectType.DiscardUnknown(m)
}

var xxx_messageInfo_SubjectType proto.InternalMessageInfo

func (m *SubjectType) GetTenant() string {
	if m != nil {
		return m.Tenant
	}
	return ""
}

func (m *SubjectType) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *SubjectType) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

// Rule
//
// x-displayName: "Rule"
// Access policy rule specification
type RuleType struct {
	// Resource Access Match
	//
	// x-displayName: "Resource Access Match"
	// x-required
	// Match access to the resource type/instance/access-type
	Resource *ResourceListType `protobuf:"bytes,1,opt,name=resource,proto3" json:"resource,omitempty"`
	// Allowed Tenant and Role
	//
	// x-displayName: "Allowed Tenant and Role"
	// x-required
	// Allowed subjects who can access
	Subjects []*SubjectType `protobuf:"bytes,2,rep,name=subjects,proto3" json:"subjects,omitempty"`
}

func (m *RuleType) Reset()      { *m = RuleType{} }
func (*RuleType) ProtoMessage() {}
func (*RuleType) Descriptor() ([]byte, []int) {
	return fileDescriptor_adece90bcba7812a, []int{7}
}
func (m *RuleType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuleType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RuleType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuleType.Merge(m, src)
}
func (m *RuleType) XXX_Size() int {
	return m.Size()
}
func (m *RuleType) XXX_DiscardUnknown() {
	xxx_messageInfo_RuleType.DiscardUnknown(m)
}

var xxx_messageInfo_RuleType proto.InternalMessageInfo

func (m *RuleType) GetResource() *ResourceListType {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *RuleType) GetSubjects() []*SubjectType {
	if m != nil {
		return m.Subjects
	}
	return nil
}

// GlobalSpecType
//
// x-displayName: "Global Configuration Specification"
// Configuration specification for Resource Policy
type GlobalSpecType struct {
	// Rules
	//
	// x-displayName: "Rules"
	// Generated Rules if rule_list is non-empty. These rules will get overwritten by system if rule_list is non-empty
	Rules []*RuleType `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty"`
	// Policy Rule List
	//
	// x-displayName: "Policy Rules"
	// List of resource access rules
	RuleList []*PolicyRuleType `protobuf:"bytes,2,rep,name=rule_list,json=ruleList,proto3" json:"rule_list,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_adece90bcba7812a, []int{8}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetRules() []*RuleType {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *GlobalSpecType) GetRuleList() []*PolicyRuleType {
	if m != nil {
		return m.RuleList
	}
	return nil
}

func init() {
	proto.RegisterType((*ResourceListType)(nil), "ves.io.schema.resource_policy.ResourceListType")
	golang_proto.RegisterType((*ResourceListType)(nil), "ves.io.schema.resource_policy.ResourceListType")
	proto.RegisterType((*TenantSubjectType)(nil), "ves.io.schema.resource_policy.TenantSubjectType")
	golang_proto.RegisterType((*TenantSubjectType)(nil), "ves.io.schema.resource_policy.TenantSubjectType")
	proto.RegisterType((*TenantRuleType)(nil), "ves.io.schema.resource_policy.TenantRuleType")
	golang_proto.RegisterType((*TenantRuleType)(nil), "ves.io.schema.resource_policy.TenantRuleType")
	proto.RegisterType((*UserSubjectType)(nil), "ves.io.schema.resource_policy.UserSubjectType")
	golang_proto.RegisterType((*UserSubjectType)(nil), "ves.io.schema.resource_policy.UserSubjectType")
	proto.RegisterType((*UserRuleType)(nil), "ves.io.schema.resource_policy.UserRuleType")
	golang_proto.RegisterType((*UserRuleType)(nil), "ves.io.schema.resource_policy.UserRuleType")
	proto.RegisterType((*PolicyRuleType)(nil), "ves.io.schema.resource_policy.PolicyRuleType")
	golang_proto.RegisterType((*PolicyRuleType)(nil), "ves.io.schema.resource_policy.PolicyRuleType")
	proto.RegisterType((*SubjectType)(nil), "ves.io.schema.resource_policy.SubjectType")
	golang_proto.RegisterType((*SubjectType)(nil), "ves.io.schema.resource_policy.SubjectType")
	proto.RegisterType((*RuleType)(nil), "ves.io.schema.resource_policy.RuleType")
	golang_proto.RegisterType((*RuleType)(nil), "ves.io.schema.resource_policy.RuleType")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.resource_policy.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.resource_policy.GlobalSpecType")
}

func init() {
	proto.RegisterFile("ves.io/schema/resource_policy/types.proto", fileDescriptor_adece90bcba7812a)
}
func init() {
	golang_proto.RegisterFile("ves.io/schema/resource_policy/types.proto", fileDescriptor_adece90bcba7812a)
}

var fileDescriptor_adece90bcba7812a = []byte{
	// 855 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x96, 0x4f, 0x73, 0xdb, 0x44,
	0x18, 0xc6, 0xfd, 0xca, 0x76, 0x6a, 0xaf, 0x8b, 0xed, 0x6a, 0x80, 0x11, 0x06, 0xb6, 0x42, 0x3d,
	0xd4, 0x84, 0x46, 0xa2, 0xc9, 0x30, 0xcc, 0x74, 0x86, 0x99, 0x8e, 0x2e, 0xfc, 0x3d, 0x74, 0x94,
	0x32, 0x03, 0x14, 0xc6, 0x23, 0x29, 0x1b, 0x47, 0xad, 0xe2, 0xd5, 0xec, 0x4a, 0x0e, 0xe1, 0x94,
	0xe1, 0x13, 0x40, 0x3e, 0x05, 0x9f, 0x01, 0x1f, 0x08, 0x9c, 0xe0, 0xc2, 0xe4, 0x98, 0x23, 0x91,
	0x39, 0x94, 0x0b, 0xd3, 0x8f, 0xc0, 0x68, 0x57, 0x52, 0x6d, 0xb7, 0x54, 0xe9, 0xa1, 0x27, 0xad,
	0xf2, 0xee, 0xfb, 0x7b, 0xf7, 0x79, 0xf4, 0x28, 0x32, 0x7a, 0x7b, 0x4a, 0xb8, 0x19, 0x50, 0x8b,
	0xfb, 0x7b, 0x64, 0xdf, 0xb5, 0x18, 0xe1, 0x34, 0x61, 0x3e, 0x19, 0x45, 0x34, 0x0c, 0xfc, 0x43,
	0x2b, 0x3e, 0x8c, 0x08, 0x37, 0x23, 0x46, 0x63, 0xaa, 0xbe, 0x29, 0xb7, 0x9a, 0x72, 0xab, 0xb9,
	0xb2, 0x75, 0xb0, 0x31, 0x0e, 0xe2, 0xbd, 0xc4, 0x33, 0x7d, 0xba, 0x6f, 0x8d, 0xe9, 0x98, 0x5a,
	0xa2, 0xcb, 0x4b, 0x76, 0xc5, 0x9d, 0xb8, 0x11, 0x2b, 0x49, 0x1b, 0xbc, 0xbe, 0x3c, 0x98, 0x46,
	0x71, 0x40, 0x27, 0xf9, 0xa8, 0xc1, 0x6b, 0xcb, 0xc5, 0x85, 0x53, 0x0c, 0xde, 0x58, 0x2e, 0x4d,
	0xdd, 0x30, 0xd8, 0x71, 0x63, 0x92, 0x57, 0xf5, 0x95, 0x6a, 0x40, 0x0e, 0x46, 0x4b, 0x68, 0xe3,
	0x6f, 0x05, 0xf5, 0x9d, 0xfc, 0xe8, 0x9f, 0x05, 0x3c, 0xbe, 0x7b, 0x18, 0x11, 0xf5, 0x00, 0x75,
	0x4b, 0x39, 0x62, 0x98, 0xa6, 0xe8, 0xf5, 0x61, 0xdb, 0xbe, 0x93, 0xce, 0xe0, 0x2a, 0x82, 0x75,
	0xd4, 0x9b, 0x06, 0x2c, 0x4e, 0xdc, 0x70, 0x34, 0x21, 0xf1, 0x01, 0x65, 0x0f, 0x50, 0x3b, 0x4a,
	0xbc, 0x30, 0xf0, 0x47, 0x41, 0xf4, 0xf3, 0x3f, 0x27, 0x75, 0x74, 0x0c, 0x97, 0x8c, 0x26, 0xab,
	0x0f, 0x8f, 0x94, 0xec, 0xb6, 0x79, 0x0c, 0x4a, 0xbf, 0x5f, 0xac, 0x5a, 0x50, 0xac, 0x34, 0x70,
	0x5e, 0x2a, 0xe6, 0x64, 0x73, 0xb9, 0xea, 0x20, 0xb5, 0x1c, 0x1c, 0x4c, 0x78, 0xec, 0x4e, 0x7c,
	0xc2, 0xb5, 0xba, 0x18, 0x7e, 0xad, 0x92, 0xac, 0x81, 0x73, 0xa5, 0x68, 0xff, 0xb8, 0xe8, 0x56,
	0xbf, 0x07, 0xd4, 0x9c, 0x12, 0xe6, 0x71, 0xad, 0x21, 0x38, 0x61, 0xb6, 0xfd, 0xd6, 0x31, 0xbc,
	0x6f, 0xbc, 0xc7, 0xb6, 0x9c, 0x9b, 0xf7, 0x74, 0x63, 0xdd, 0xb8, 0xa1, 0x1b, 0x3e, 0x23, 0x6e,
	0x4c, 0xb2, 0xd5, 0x98, 0xc4, 0xd9, 0x25, 0x0c, 0xb8, 0xb8, 0x32, 0x12, 0x85, 0xae, 0x2f, 0x2a,
	0x09, 0x27, 0xc6, 0x37, 0xcf, 0x27, 0x50, 0x8e, 0x36, 0xbe, 0x44, 0x57, 0xee, 0x92, 0x89, 0x3b,
	0x89, 0xb7, 0x13, 0xef, 0x3e, 0xf1, 0xa5, 0xcd, 0xd7, 0xd0, 0x5a, 0x2c, 0xfe, 0xa8, 0x81, 0x0e,
	0xc3, 0xb6, 0xdd, 0xc9, 0xfa, 0xd6, 0x58, 0x43, 0x87, 0xe1, 0x6d, 0x27, 0x2f, 0xa9, 0x57, 0x51,
	0x83, 0xd1, 0x90, 0x68, 0xca, 0x93, 0x5b, 0x44, 0xc1, 0xf8, 0x03, 0x50, 0x57, 0xb2, 0x9d, 0x24,
	0x14, 0x3e, 0xaa, 0x9f, 0xa2, 0x56, 0xe1, 0x83, 0x40, 0x77, 0x36, 0x2d, 0xf3, 0x99, 0x69, 0x35,
	0x57, 0x23, 0xe0, 0x94, 0x00, 0xf5, 0x3e, 0xba, 0x24, 0x8f, 0x22, 0x53, 0xd0, 0xd9, 0x7c, 0xb7,
	0x82, 0xf5, 0x84, 0x50, 0x1b, 0x97, 0x26, 0xe9, 0x4f, 0x35, 0xa9, 0x18, 0x60, 0xdc, 0x43, 0xbd,
	0xcf, 0x39, 0x61, 0x8b, 0x26, 0x5d, 0x47, 0xed, 0x89, 0xbb, 0x4f, 0x78, 0xe4, 0xe6, 0x62, 0xda,
	0x76, 0x3b, 0x6b, 0x6d, 0x30, 0x65, 0x78, 0xdb, 0x79, 0x5c, 0xab, 0x36, 0xea, 0x57, 0x40, 0x97,
	0x33, 0xfa, 0x8b, 0xb1, 0x69, 0x07, 0x35, 0x13, 0x4e, 0x58, 0x61, 0x92, 0x59, 0x41, 0x5a, 0x91,
	0x59, 0x69, 0x91, 0x84, 0x1b, 0xff, 0x02, 0xea, 0xde, 0x11, 0x84, 0x52, 0xc5, 0x17, 0xe8, 0xb2,
	0xb4, 0x6f, 0xc4, 0xf7, 0x5c, 0x26, 0xf5, 0x77, 0x36, 0x37, 0x2e, 0xf4, 0x90, 0x0a, 0x88, 0xdd,
	0x78, 0x38, 0x03, 0xf8, 0xa8, 0xe6, 0x74, 0x24, 0x6a, 0x3b, 0x23, 0xa9, 0x5f, 0xa3, 0x5e, 0x69,
	0x6f, 0x0e, 0xaf, 0x0b, 0xf8, 0x3b, 0x17, 0x10, 0xf7, 0x18, 0x7d, 0x2a, 0xd1, 0xdd, 0x92, 0x25,
	0xe8, 0x36, 0x46, 0x1d, 0x96, 0x84, 0x64, 0xe4, 0xef, 0xd1, 0xc0, 0x27, 0x6a, 0xef, 0x64, 0x06,
	0x4a, 0xb6, 0x35, 0x9d, 0x41, 0x7d, 0xf3, 0xc6, 0xd6, 0x27, 0x8d, 0x16, 0xf4, 0x15, 0xe3, 0x3b,
	0xd4, 0x59, 0x4c, 0xc3, 0x5b, 0x2b, 0xaf, 0xcc, 0x42, 0x14, 0x8a, 0x17, 0x66, 0x29, 0x30, 0xca,
	0x05, 0x02, 0x53, 0xff, 0xbf, 0xc0, 0xfc, 0x02, 0xa8, 0xf5, 0x62, 0xc2, 0xb2, 0x8b, 0x5a, 0x5c,
	0xaa, 0x2a, 0xf2, 0xb2, 0x5e, 0x01, 0x7b, 0x9e, 0xac, 0x94, 0x6c, 0xe3, 0x4f, 0x40, 0xdd, 0x0f,
	0x43, 0xea, 0xb9, 0xe1, 0x76, 0x44, 0x7c, 0xa1, 0xe3, 0x03, 0xd4, 0xcc, 0x6c, 0xe7, 0x1a, 0x88,
	0xb9, 0xd7, 0xab, 0x44, 0xe4, 0xfa, 0x1d, 0xd9, 0xa5, 0xba, 0xa8, 0x2d, 0x9e, 0x5a, 0xf6, 0xdf,
	0x31, 0x3f, 0x7a, 0x55, 0xd4, 0x96, 0xf3, 0x6a, 0xbf, 0x22, 0x8c, 0x3e, 0x86, 0x7a, 0xff, 0xa8,
	0xb5, 0x78, 0xe8, 0x0c, 0x9b, 0x59, 0x75, 0x6b, 0xf0, 0xdb, 0x0c, 0x5e, 0x45, 0x2f, 0xa3, 0x5e,
	0x61, 0xa0, 0x2e, 0x09, 0x2a, 0xdc, 0xb4, 0x7f, 0x84, 0xd3, 0x73, 0x5c, 0x3b, 0x3b, 0xc7, 0xb5,
	0x47, 0xe7, 0x18, 0x8e, 0x52, 0x0c, 0x3f, 0xa5, 0x18, 0x7e, 0x4f, 0x31, 0x9c, 0xa6, 0x18, 0xce,
	0x52, 0x0c, 0x7f, 0xa5, 0x18, 0x1e, 0xa6, 0xb8, 0xf6, 0x28, 0xc5, 0xf0, 0xc3, 0x1c, 0xd7, 0x4e,
	0xe6, 0x18, 0x4e, 0xe7, 0xb8, 0x76, 0x36, 0xc7, 0xb5, 0xaf, 0xb6, 0xc7, 0x34, 0x7a, 0x30, 0x36,
	0xa7, 0x34, 0x8c, 0x09, 0x63, 0xae, 0x99, 0x70, 0x4b, 0x2c, 0x76, 0x29, 0xdb, 0xdf, 0x88, 0x18,
	0x9d, 0x06, 0x3b, 0x84, 0x6d, 0x14, 0x65, 0x2b, 0xf2, 0xc6, 0xd4, 0x22, 0xdf, 0xc6, 0xf9, 0xe7,
	0xf3, 0xe9, 0x3f, 0x0a, 0xbc, 0x35, 0xf1, 0x25, 0xdd, 0xfa, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x1e,
	0x49, 0xe0, 0x68, 0x3c, 0x08, 0x00, 0x00,
}

func (this *ResourceListType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResourceListType)
	if !ok {
		that2, ok := that.(ResourceListType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ResourceTypes) != len(that1.ResourceTypes) {
		return false
	}
	for i := range this.ResourceTypes {
		if this.ResourceTypes[i] != that1.ResourceTypes[i] {
			return false
		}
	}
	if len(this.ResourceInstances) != len(that1.ResourceInstances) {
		return false
	}
	for i := range this.ResourceInstances {
		if this.ResourceInstances[i] != that1.ResourceInstances[i] {
			return false
		}
	}
	if len(this.Verbs) != len(that1.Verbs) {
		return false
	}
	for i := range this.Verbs {
		if this.Verbs[i] != that1.Verbs[i] {
			return false
		}
	}
	return true
}
func (this *TenantSubjectType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TenantSubjectType)
	if !ok {
		that2, ok := that.(TenantSubjectType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Tenant != that1.Tenant {
		return false
	}
	if this.Role != that1.Role {
		return false
	}
	return true
}
func (this *TenantRuleType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TenantRuleType)
	if !ok {
		that2, ok := that.(TenantRuleType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Resource.Equal(that1.Resource) {
		return false
	}
	if len(this.Tenants) != len(that1.Tenants) {
		return false
	}
	for i := range this.Tenants {
		if !this.Tenants[i].Equal(that1.Tenants[i]) {
			return false
		}
	}
	return true
}
func (this *UserSubjectType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserSubjectType)
	if !ok {
		that2, ok := that.(UserSubjectType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Role != that1.Role {
		return false
	}
	return true
}
func (this *UserRuleType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserRuleType)
	if !ok {
		that2, ok := that.(UserRuleType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Resource.Equal(that1.Resource) {
		return false
	}
	if len(this.Users) != len(that1.Users) {
		return false
	}
	for i := range this.Users {
		if !this.Users[i].Equal(that1.Users[i]) {
			return false
		}
	}
	return true
}
func (this *PolicyRuleType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PolicyRuleType)
	if !ok {
		that2, ok := that.(PolicyRuleType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.RuleChoice == nil {
		if this.RuleChoice != nil {
			return false
		}
	} else if this.RuleChoice == nil {
		return false
	} else if !this.RuleChoice.Equal(that1.RuleChoice) {
		return false
	}
	return true
}
func (this *PolicyRuleType_TenantShare) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PolicyRuleType_TenantShare)
	if !ok {
		that2, ok := that.(PolicyRuleType_TenantShare)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TenantShare.Equal(that1.TenantShare) {
		return false
	}
	return true
}
func (this *PolicyRuleType_NamespaceShare) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PolicyRuleType_NamespaceShare)
	if !ok {
		that2, ok := that.(PolicyRuleType_NamespaceShare)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.NamespaceShare.Equal(that1.NamespaceShare) {
		return false
	}
	return true
}
func (this *SubjectType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubjectType)
	if !ok {
		that2, ok := that.(SubjectType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Tenant != that1.Tenant {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Role != that1.Role {
		return false
	}
	return true
}
func (this *RuleType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RuleType)
	if !ok {
		that2, ok := that.(RuleType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Resource.Equal(that1.Resource) {
		return false
	}
	if len(this.Subjects) != len(that1.Subjects) {
		return false
	}
	for i := range this.Subjects {
		if !this.Subjects[i].Equal(that1.Subjects[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Rules) != len(that1.Rules) {
		return false
	}
	for i := range this.Rules {
		if !this.Rules[i].Equal(that1.Rules[i]) {
			return false
		}
	}
	if len(this.RuleList) != len(that1.RuleList) {
		return false
	}
	for i := range this.RuleList {
		if !this.RuleList[i].Equal(that1.RuleList[i]) {
			return false
		}
	}
	return true
}
func (this *ResourceListType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&resource_policy.ResourceListType{")
	s = append(s, "ResourceTypes: "+fmt.Sprintf("%#v", this.ResourceTypes)+",\n")
	s = append(s, "ResourceInstances: "+fmt.Sprintf("%#v", this.ResourceInstances)+",\n")
	s = append(s, "Verbs: "+fmt.Sprintf("%#v", this.Verbs)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TenantSubjectType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&resource_policy.TenantSubjectType{")
	s = append(s, "Tenant: "+fmt.Sprintf("%#v", this.Tenant)+",\n")
	s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TenantRuleType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&resource_policy.TenantRuleType{")
	if this.Resource != nil {
		s = append(s, "Resource: "+fmt.Sprintf("%#v", this.Resource)+",\n")
	}
	if this.Tenants != nil {
		s = append(s, "Tenants: "+fmt.Sprintf("%#v", this.Tenants)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UserSubjectType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&resource_policy.UserSubjectType{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UserRuleType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&resource_policy.UserRuleType{")
	if this.Resource != nil {
		s = append(s, "Resource: "+fmt.Sprintf("%#v", this.Resource)+",\n")
	}
	if this.Users != nil {
		s = append(s, "Users: "+fmt.Sprintf("%#v", this.Users)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PolicyRuleType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&resource_policy.PolicyRuleType{")
	if this.RuleChoice != nil {
		s = append(s, "RuleChoice: "+fmt.Sprintf("%#v", this.RuleChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PolicyRuleType_TenantShare) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&resource_policy.PolicyRuleType_TenantShare{` +
		`TenantShare:` + fmt.Sprintf("%#v", this.TenantShare) + `}`}, ", ")
	return s
}
func (this *PolicyRuleType_NamespaceShare) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&resource_policy.PolicyRuleType_NamespaceShare{` +
		`NamespaceShare:` + fmt.Sprintf("%#v", this.NamespaceShare) + `}`}, ", ")
	return s
}
func (this *SubjectType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&resource_policy.SubjectType{")
	s = append(s, "Tenant: "+fmt.Sprintf("%#v", this.Tenant)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RuleType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&resource_policy.RuleType{")
	if this.Resource != nil {
		s = append(s, "Resource: "+fmt.Sprintf("%#v", this.Resource)+",\n")
	}
	if this.Subjects != nil {
		s = append(s, "Subjects: "+fmt.Sprintf("%#v", this.Subjects)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&resource_policy.GlobalSpecType{")
	if this.Rules != nil {
		s = append(s, "Rules: "+fmt.Sprintf("%#v", this.Rules)+",\n")
	}
	if this.RuleList != nil {
		s = append(s, "RuleList: "+fmt.Sprintf("%#v", this.RuleList)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *ResourceListType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceListType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceListType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Verbs) > 0 {
		for iNdEx := len(m.Verbs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Verbs[iNdEx])
			copy(dAtA[i:], m.Verbs[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Verbs[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ResourceInstances) > 0 {
		for iNdEx := len(m.ResourceInstances) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResourceInstances[iNdEx])
			copy(dAtA[i:], m.ResourceInstances[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ResourceInstances[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ResourceTypes) > 0 {
		for iNdEx := len(m.ResourceTypes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ResourceTypes[iNdEx])
			copy(dAtA[i:], m.ResourceTypes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ResourceTypes[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *TenantSubjectType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TenantSubjectType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TenantSubjectType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Tenant) > 0 {
		i -= len(m.Tenant)
		copy(dAtA[i:], m.Tenant)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Tenant)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TenantRuleType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TenantRuleType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TenantRuleType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tenants) > 0 {
		for iNdEx := len(m.Tenants) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tenants[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Resource != nil {
		{
			size, err := m.Resource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserSubjectType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserSubjectType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserSubjectType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserRuleType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRuleType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserRuleType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Users) > 0 {
		for iNdEx := len(m.Users) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Users[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Resource != nil {
		{
			size, err := m.Resource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PolicyRuleType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PolicyRuleType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicyRuleType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RuleChoice != nil {
		{
			size := m.RuleChoice.Size()
			i -= size
			if _, err := m.RuleChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *PolicyRuleType_TenantShare) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicyRuleType_TenantShare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TenantShare != nil {
		{
			size, err := m.TenantShare.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *PolicyRuleType_NamespaceShare) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PolicyRuleType_NamespaceShare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NamespaceShare != nil {
		{
			size, err := m.NamespaceShare.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SubjectType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubjectType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubjectType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Tenant) > 0 {
		i -= len(m.Tenant)
		copy(dAtA[i:], m.Tenant)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Tenant)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RuleType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RuleType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Subjects) > 0 {
		for iNdEx := len(m.Subjects) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subjects[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Resource != nil {
		{
			size, err := m.Resource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RuleList) > 0 {
		for iNdEx := len(m.RuleList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RuleList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ResourceListType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ResourceTypes) > 0 {
		for _, s := range m.ResourceTypes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ResourceInstances) > 0 {
		for _, s := range m.ResourceInstances {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Verbs) > 0 {
		for _, s := range m.Verbs {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *TenantSubjectType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *TenantRuleType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Resource != nil {
		l = m.Resource.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Tenants) > 0 {
		for _, e := range m.Tenants {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *UserSubjectType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *UserRuleType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Resource != nil {
		l = m.Resource.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *PolicyRuleType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RuleChoice != nil {
		n += m.RuleChoice.Size()
	}
	return n
}

func (m *PolicyRuleType_TenantShare) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TenantShare != nil {
		l = m.TenantShare.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PolicyRuleType_NamespaceShare) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NamespaceShare != nil {
		l = m.NamespaceShare.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *SubjectType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tenant)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RuleType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Resource != nil {
		l = m.Resource.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Subjects) > 0 {
		for _, e := range m.Subjects {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RuleList) > 0 {
		for _, e := range m.RuleList {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ResourceListType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResourceListType{`,
		`ResourceTypes:` + fmt.Sprintf("%v", this.ResourceTypes) + `,`,
		`ResourceInstances:` + fmt.Sprintf("%v", this.ResourceInstances) + `,`,
		`Verbs:` + fmt.Sprintf("%v", this.Verbs) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TenantSubjectType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TenantSubjectType{`,
		`Tenant:` + fmt.Sprintf("%v", this.Tenant) + `,`,
		`Role:` + fmt.Sprintf("%v", this.Role) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TenantRuleType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTenants := "[]*TenantSubjectType{"
	for _, f := range this.Tenants {
		repeatedStringForTenants += strings.Replace(f.String(), "TenantSubjectType", "TenantSubjectType", 1) + ","
	}
	repeatedStringForTenants += "}"
	s := strings.Join([]string{`&TenantRuleType{`,
		`Resource:` + strings.Replace(this.Resource.String(), "ResourceListType", "ResourceListType", 1) + `,`,
		`Tenants:` + repeatedStringForTenants + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserSubjectType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserSubjectType{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Role:` + fmt.Sprintf("%v", this.Role) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserRuleType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForUsers := "[]*UserSubjectType{"
	for _, f := range this.Users {
		repeatedStringForUsers += strings.Replace(f.String(), "UserSubjectType", "UserSubjectType", 1) + ","
	}
	repeatedStringForUsers += "}"
	s := strings.Join([]string{`&UserRuleType{`,
		`Resource:` + strings.Replace(this.Resource.String(), "ResourceListType", "ResourceListType", 1) + `,`,
		`Users:` + repeatedStringForUsers + `,`,
		`}`,
	}, "")
	return s
}
func (this *PolicyRuleType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PolicyRuleType{`,
		`RuleChoice:` + fmt.Sprintf("%v", this.RuleChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PolicyRuleType_TenantShare) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PolicyRuleType_TenantShare{`,
		`TenantShare:` + strings.Replace(fmt.Sprintf("%v", this.TenantShare), "TenantRuleType", "TenantRuleType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PolicyRuleType_NamespaceShare) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PolicyRuleType_NamespaceShare{`,
		`NamespaceShare:` + strings.Replace(fmt.Sprintf("%v", this.NamespaceShare), "UserRuleType", "UserRuleType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SubjectType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SubjectType{`,
		`Tenant:` + fmt.Sprintf("%v", this.Tenant) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Role:` + fmt.Sprintf("%v", this.Role) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RuleType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSubjects := "[]*SubjectType{"
	for _, f := range this.Subjects {
		repeatedStringForSubjects += strings.Replace(f.String(), "SubjectType", "SubjectType", 1) + ","
	}
	repeatedStringForSubjects += "}"
	s := strings.Join([]string{`&RuleType{`,
		`Resource:` + strings.Replace(this.Resource.String(), "ResourceListType", "ResourceListType", 1) + `,`,
		`Subjects:` + repeatedStringForSubjects + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRules := "[]*RuleType{"
	for _, f := range this.Rules {
		repeatedStringForRules += strings.Replace(f.String(), "RuleType", "RuleType", 1) + ","
	}
	repeatedStringForRules += "}"
	repeatedStringForRuleList := "[]*PolicyRuleType{"
	for _, f := range this.RuleList {
		repeatedStringForRuleList += strings.Replace(f.String(), "PolicyRuleType", "PolicyRuleType", 1) + ","
	}
	repeatedStringForRuleList += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`Rules:` + repeatedStringForRules + `,`,
		`RuleList:` + repeatedStringForRuleList + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ResourceListType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceListType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceListType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceTypes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceTypes = append(m.ResourceTypes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceInstances", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceInstances = append(m.ResourceInstances, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verbs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Verbs = append(m.Verbs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TenantSubjectType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TenantSubjectType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TenantSubjectType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TenantRuleType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TenantRuleType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TenantRuleType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resource == nil {
				m.Resource = &ResourceListType{}
			}
			if err := m.Resource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenants = append(m.Tenants, &TenantSubjectType{})
			if err := m.Tenants[len(m.Tenants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserSubjectType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserSubjectType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserSubjectType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRuleType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRuleType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRuleType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resource == nil {
				m.Resource = &ResourceListType{}
			}
			if err := m.Resource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &UserSubjectType{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyRuleType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyRuleType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyRuleType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantShare", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TenantRuleType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &PolicyRuleType_TenantShare{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespaceShare", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UserRuleType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RuleChoice = &PolicyRuleType_NamespaceShare{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubjectType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubjectType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubjectType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tenant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tenant = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuleType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuleType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuleType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resource == nil {
				m.Resource = &ResourceListType{}
			}
			if err := m.Resource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subjects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subjects = append(m.Subjects, &SubjectType{})
			if err := m.Subjects[len(m.Subjects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &RuleType{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleList = append(m.RuleList, &PolicyRuleType{})
			if err := m.RuleList[len(m.RuleList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
