// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package resource_policy

import (
	"context"

	"gopkg.volterra.us/stdlib/db/sro"
	"gopkg.volterra.us/stdlib/errors"
	"gopkg.volterra.us/stdlib/server"
	"gopkg.volterra.us/stdlib/svcfw"
)

func (o *DBObject) visitRules(ctx context.Context, vFn func(ruleObjTypes, ruleObjNames, ruleOps []string, ruleSubjects []*SubjectType) bool) error {
	for _, rule := range o.GetSpec().GetGcSpec().GetRules() {
		ruleObjTypes := rule.Resource.ResourceTypes
		ruleObjNames := rule.Resource.ResourceInstances
		ruleOps := rule.Resource.Verbs
		if stop := vFn(ruleObjTypes, ruleObjNames, ruleOps, rule.Subjects); stop {
			return nil
		}
	}
	return nil
}

func (o *DBObject) listHasMatch(allowed []string, candidate string) bool {
	for _, a := range allowed {
		switch a {
		case "":
			continue
		case "*":
			return true
		default:
			if a == candidate {
				return true
			}
		}
	}
	return false
}

func (o *DBObject) objTypeHasMatch(ruleObjTypes []string, sharedNSObj sro.SRO) bool {
	return o.listHasMatch(ruleObjTypes, sharedNSObj.GetObjType())
}

func (o *DBObject) objNameHasMatch(ruleObjNames []string, sharedNSObj sro.SRO) bool {
	return o.listHasMatch(ruleObjNames, sharedNSObj.GetObjName())
}

func (o *DBObject) opHasMatch(ruleOps []string, op string) bool {
	return o.listHasMatch(ruleOps, op)
}

func (o *DBObject) tenantHasMatch(ruleSubjects []*SubjectType, accessingTenant string) bool {
	allowedTenants := []string{}
	for _, rs := range ruleSubjects {
		allowedTenants = append(allowedTenants, rs.Tenant)
	}
	return o.listHasMatch(allowedTenants, accessingTenant)
}

func (o *DBObject) namespaceHasMatch(ruleSubjects []*SubjectType, accessingNS string) bool {
	allowedNS := []string{}
	for _, rs := range ruleSubjects {
		allowedNS = append(allowedNS, rs.Namespace)
	}
	return o.listHasMatch(allowedNS, accessingNS)
}

func (o *DBObject) roleHasMatch(ruleSubjects []*SubjectType, accessingRoles []string) bool {
	// till wire is guaranteed to send role header, allow none
	if len(accessingRoles) == 0 {
		return true
	}
	allowedRoles := []string{}
	for _, rs := range ruleSubjects {
		allowedRoles = append(allowedRoles, rs.Role)
	}
	for _, accRole := range accessingRoles {
		if o.listHasMatch(allowedRoles, accRole) {
			return true
		}
	}
	return false
}

func (o *DBObject) ReadAllowedForTenant(ctx context.Context, accessingTenant string, vesIOSharedNSObj sro.SRO, opts ...svcfw.RPAccessOpt) (bool, error) {
	// safety-check: only ves-io/shared objects can be shared between tenants
	if (vesIOSharedNSObj.GetObjTenant() != svcfw.VesTenantVal) || (vesIOSharedNSObj.GetObjNamespace() != svcfw.SharedNSVal) {
		return false, nil
	}
	rpo, err := svcfw.NewRPAccessOpts(opts...)
	if err != nil {
		return false, errors.Wrapf(err, "Building from options")
	}

	var readAllowed bool
	if rpo.ImplicitDeny {
		readAllowed = false
	} else {
		readAllowed = true
	}

	if err := o.visitRules(ctx, func(ruleObjTypes, ruleObjNames, ruleOps []string, ruleSubjects []*SubjectType) bool {
		if !o.objTypeHasMatch(ruleObjTypes, vesIOSharedNSObj) {
			return false // see next rule
		}
		if !o.objNameHasMatch(ruleObjNames, vesIOSharedNSObj) {
			return false // see next rule
		}
		if !o.opHasMatch(ruleOps, "get") {
			return false // see next rule
		}
		readAllowed = o.tenantHasMatch(ruleSubjects, accessingTenant) && o.roleHasMatch(ruleSubjects, server.RolesFromContext(ctx))
		return true // stop visit
	}); err != nil {
		return false, errors.Wrapf(err, "Visiting rules for resource access check")
	}
	return readAllowed, nil
}

func (o *DBObject) ReadAllowedForNamespace(ctx context.Context, accessingNS string, tenantSharedNSObj sro.SRO, opts ...svcfw.RPAccessOpt) (bool, error) {
	// safety-check: only xxx/shared objects can be shared between namespaces
	if tenantSharedNSObj.GetObjNamespace() != svcfw.SharedNSVal {
		return false, nil
	}

	rpo, err := svcfw.NewRPAccessOpts(opts...)
	if err != nil {
		return false, errors.Wrapf(err, "Building from options")
	}

	var readAllowed bool
	if rpo.ImplicitDeny {
		readAllowed = false
	} else {
		readAllowed = true
	}

	if err := o.visitRules(ctx, func(ruleObjTypes, ruleObjNames, ruleOps []string, ruleSubjects []*SubjectType) bool {
		if !o.objTypeHasMatch(ruleObjTypes, tenantSharedNSObj) {
			return false // see next rule
		}
		if !o.objNameHasMatch(ruleObjNames, tenantSharedNSObj) {
			return false // see next rule
		}
		if !o.opHasMatch(ruleOps, "get") {
			return false // see next rule
		}
		readAllowed = o.namespaceHasMatch(ruleSubjects, accessingNS) && o.roleHasMatch(ruleSubjects, server.RolesFromContext(ctx))
		return true // stop visit
	}); err != nil {
		return false, errors.Wrapf(err, "Visiting rules for resource access check")
	}
	return readAllowed, nil
}
