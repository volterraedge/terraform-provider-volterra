// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.

package site

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *ConfigMapListRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ConfigMapListRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ConfigMapListRequest) DeepCopy() *ConfigMapListRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ConfigMapListRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ConfigMapListRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ConfigMapListRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ConfigMapListRequestValidator().Validate(ctx, m, opts...)
}

type ValidateConfigMapListRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateConfigMapListRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ConfigMapListRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ConfigMapListRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultConfigMapListRequestValidator = func() *ValidateConfigMapListRequest {
	v := &ValidateConfigMapListRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ConfigMapListRequestValidator() db.Validator {
	return DefaultConfigMapListRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *CronJobListRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CronJobListRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CronJobListRequest) DeepCopy() *CronJobListRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CronJobListRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CronJobListRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CronJobListRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CronJobListRequestValidator().Validate(ctx, m, opts...)
}

type ValidateCronJobListRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCronJobListRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CronJobListRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CronJobListRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCronJobListRequestValidator = func() *ValidateCronJobListRequest {
	v := &ValidateCronJobListRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CronJobListRequestValidator() db.Validator {
	return DefaultCronJobListRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *DaemonSetListRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DaemonSetListRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DaemonSetListRequest) DeepCopy() *DaemonSetListRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DaemonSetListRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DaemonSetListRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DaemonSetListRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DaemonSetListRequestValidator().Validate(ctx, m, opts...)
}

type ValidateDaemonSetListRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDaemonSetListRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DaemonSetListRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DaemonSetListRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDaemonSetListRequestValidator = func() *ValidateDaemonSetListRequest {
	v := &ValidateDaemonSetListRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DaemonSetListRequestValidator() db.Validator {
	return DefaultDaemonSetListRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *DeploymentListRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DeploymentListRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DeploymentListRequest) DeepCopy() *DeploymentListRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DeploymentListRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DeploymentListRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DeploymentListRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DeploymentListRequestValidator().Validate(ctx, m, opts...)
}

type ValidateDeploymentListRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDeploymentListRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DeploymentListRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DeploymentListRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDeploymentListRequestValidator = func() *ValidateDeploymentListRequest {
	v := &ValidateDeploymentListRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DeploymentListRequestValidator() db.Validator {
	return DefaultDeploymentListRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *EndpointsListRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *EndpointsListRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *EndpointsListRequest) DeepCopy() *EndpointsListRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &EndpointsListRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *EndpointsListRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *EndpointsListRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return EndpointsListRequestValidator().Validate(ctx, m, opts...)
}

type ValidateEndpointsListRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateEndpointsListRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*EndpointsListRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *EndpointsListRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultEndpointsListRequestValidator = func() *ValidateEndpointsListRequest {
	v := &ValidateEndpointsListRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func EndpointsListRequestValidator() db.Validator {
	return DefaultEndpointsListRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *JobListRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *JobListRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *JobListRequest) DeepCopy() *JobListRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &JobListRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *JobListRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *JobListRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return JobListRequestValidator().Validate(ctx, m, opts...)
}

type ValidateJobListRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateJobListRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*JobListRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *JobListRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultJobListRequestValidator = func() *ValidateJobListRequest {
	v := &ValidateJobListRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func JobListRequestValidator() db.Validator {
	return DefaultJobListRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *NamespaceListRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NamespaceListRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NamespaceListRequest) DeepCopy() *NamespaceListRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NamespaceListRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NamespaceListRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NamespaceListRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NamespaceListRequestValidator().Validate(ctx, m, opts...)
}

type ValidateNamespaceListRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNamespaceListRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NamespaceListRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NamespaceListRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNamespaceListRequestValidator = func() *ValidateNamespaceListRequest {
	v := &ValidateNamespaceListRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func NamespaceListRequestValidator() db.Validator {
	return DefaultNamespaceListRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *NodeListRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NodeListRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NodeListRequest) DeepCopy() *NodeListRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NodeListRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NodeListRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NodeListRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NodeListRequestValidator().Validate(ctx, m, opts...)
}

type ValidateNodeListRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNodeListRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NodeListRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NodeListRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNodeListRequestValidator = func() *ValidateNodeListRequest {
	v := &ValidateNodeListRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func NodeListRequestValidator() db.Validator {
	return DefaultNodeListRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *PersistentVolumeClaimListRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PersistentVolumeClaimListRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PersistentVolumeClaimListRequest) DeepCopy() *PersistentVolumeClaimListRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PersistentVolumeClaimListRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PersistentVolumeClaimListRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PersistentVolumeClaimListRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PersistentVolumeClaimListRequestValidator().Validate(ctx, m, opts...)
}

type ValidatePersistentVolumeClaimListRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePersistentVolumeClaimListRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PersistentVolumeClaimListRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PersistentVolumeClaimListRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPersistentVolumeClaimListRequestValidator = func() *ValidatePersistentVolumeClaimListRequest {
	v := &ValidatePersistentVolumeClaimListRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func PersistentVolumeClaimListRequestValidator() db.Validator {
	return DefaultPersistentVolumeClaimListRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *PersistentVolumeListRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PersistentVolumeListRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PersistentVolumeListRequest) DeepCopy() *PersistentVolumeListRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PersistentVolumeListRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PersistentVolumeListRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PersistentVolumeListRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PersistentVolumeListRequestValidator().Validate(ctx, m, opts...)
}

type ValidatePersistentVolumeListRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePersistentVolumeListRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PersistentVolumeListRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PersistentVolumeListRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPersistentVolumeListRequestValidator = func() *ValidatePersistentVolumeListRequest {
	v := &ValidatePersistentVolumeListRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func PersistentVolumeListRequestValidator() db.Validator {
	return DefaultPersistentVolumeListRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *PodListRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PodListRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PodListRequest) DeepCopy() *PodListRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PodListRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PodListRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PodListRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PodListRequestValidator().Validate(ctx, m, opts...)
}

type ValidatePodListRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePodListRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PodListRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PodListRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPodListRequestValidator = func() *ValidatePodListRequest {
	v := &ValidatePodListRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func PodListRequestValidator() db.Validator {
	return DefaultPodListRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *PodsMetricData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PodsMetricData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PodsMetricData) DeepCopy() *PodsMetricData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PodsMetricData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PodsMetricData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PodsMetricData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PodsMetricDataValidator().Validate(ctx, m, opts...)
}

type ValidatePodsMetricData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePodsMetricData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PodsMetricData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PodsMetricData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["data"]; exists {

		vOpts := append(opts, db.WithValidateField("data"))
		for idx, item := range m.GetData() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["unit"]; exists {

		vOpts := append(opts, db.WithValidateField("unit"))
		if err := fv(ctx, m.GetUnit(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPodsMetricDataValidator = func() *ValidatePodsMetricData {
	v := &ValidatePodsMetricData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func PodsMetricDataValidator() db.Validator {
	return DefaultPodsMetricDataValidator
}

// augmented methods on protoc/std generated struct

func (m *PodsMetricTypeData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PodsMetricTypeData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PodsMetricTypeData) DeepCopy() *PodsMetricTypeData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PodsMetricTypeData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PodsMetricTypeData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PodsMetricTypeData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PodsMetricTypeDataValidator().Validate(ctx, m, opts...)
}

type ValidatePodsMetricTypeData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePodsMetricTypeData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PodsMetricTypeData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PodsMetricTypeData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["labels"]; exists {

		vOpts := append(opts, db.WithValidateField("labels"))
		for key, value := range m.GetLabels() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["values"]; exists {

		vOpts := append(opts, db.WithValidateField("values"))
		for idx, item := range m.GetValues() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPodsMetricTypeDataValidator = func() *ValidatePodsMetricTypeData {
	v := &ValidatePodsMetricTypeData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func PodsMetricTypeDataValidator() db.Validator {
	return DefaultPodsMetricTypeDataValidator
}

// augmented methods on protoc/std generated struct

func (m *PodsMetricsRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PodsMetricsRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PodsMetricsRequest) DeepCopy() *PodsMetricsRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PodsMetricsRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PodsMetricsRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PodsMetricsRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PodsMetricsRequestValidator().Validate(ctx, m, opts...)
}

type ValidatePodsMetricsRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePodsMetricsRequest) MetricSelectorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(PodsMetricType)
		return int32(i)
	}
	// PodsMetricType_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, PodsMetricType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for metric_selector")
	}
	itemsValidatorFn := func(ctx context.Context, elems []PodsMetricType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for metric_selector")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]PodsMetricType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []PodsMetricType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated metric_selector")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items metric_selector")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePodsMetricsRequest) StartTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_time")
	}

	return validatorFn, nil
}

func (v *ValidatePodsMetricsRequest) EndTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_time")
	}

	return validatorFn, nil
}

func (v *ValidatePodsMetricsRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PodsMetricsRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PodsMetricsRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["filters"]; exists {

		vOpts := append(opts, db.WithValidateField("filters"))
		if err := fv(ctx, m.GetFilters(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["group_by"]; exists {

		vOpts := append(opts, db.WithValidateField("group_by"))
		for idx, item := range m.GetGroupBy() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["metric_selector"]; exists {
		vOpts := append(opts, db.WithValidateField("metric_selector"))
		if err := fv(ctx, m.GetMetricSelector(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPodsMetricsRequestValidator = func() *ValidatePodsMetricsRequest {
	v := &ValidatePodsMetricsRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMetricSelector := v.MetricSelectorValidationRuleHandler
	rulesMetricSelector := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.repeated.unique":  "true",
	}
	vFn, err = vrhMetricSelector(rulesMetricSelector)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PodsMetricsRequest.metric_selector: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metric_selector"] = vFn

	vrhStartTime := v.StartTimeValidationRuleHandler
	rulesStartTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhStartTime(rulesStartTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PodsMetricsRequest.start_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_time"] = vFn

	vrhEndTime := v.EndTimeValidationRuleHandler
	rulesEndTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhEndTime(rulesEndTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PodsMetricsRequest.end_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_time"] = vFn

	return v
}()

func PodsMetricsRequestValidator() db.Validator {
	return DefaultPodsMetricsRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *PodsMetricsResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PodsMetricsResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PodsMetricsResponse) DeepCopy() *PodsMetricsResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PodsMetricsResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PodsMetricsResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PodsMetricsResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PodsMetricsResponseValidator().Validate(ctx, m, opts...)
}

type ValidatePodsMetricsResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePodsMetricsResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PodsMetricsResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PodsMetricsResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["data"]; exists {

		vOpts := append(opts, db.WithValidateField("data"))
		for idx, item := range m.GetData() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPodsMetricsResponseValidator = func() *ValidatePodsMetricsResponse {
	v := &ValidatePodsMetricsResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func PodsMetricsResponseValidator() db.Validator {
	return DefaultPodsMetricsResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplicaSetListRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplicaSetListRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReplicaSetListRequest) DeepCopy() *ReplicaSetListRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplicaSetListRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplicaSetListRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplicaSetListRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplicaSetListRequestValidator().Validate(ctx, m, opts...)
}

type ValidateReplicaSetListRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplicaSetListRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplicaSetListRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplicaSetListRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplicaSetListRequestValidator = func() *ValidateReplicaSetListRequest {
	v := &ValidateReplicaSetListRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ReplicaSetListRequestValidator() db.Validator {
	return DefaultReplicaSetListRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *SecretListRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SecretListRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SecretListRequest) DeepCopy() *SecretListRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SecretListRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SecretListRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SecretListRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SecretListRequestValidator().Validate(ctx, m, opts...)
}

type ValidateSecretListRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSecretListRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SecretListRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SecretListRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSecretListRequestValidator = func() *ValidateSecretListRequest {
	v := &ValidateSecretListRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SecretListRequestValidator() db.Validator {
	return DefaultSecretListRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *ServiceListRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ServiceListRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ServiceListRequest) DeepCopy() *ServiceListRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ServiceListRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ServiceListRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ServiceListRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ServiceListRequestValidator().Validate(ctx, m, opts...)
}

type ValidateServiceListRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateServiceListRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ServiceListRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ServiceListRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultServiceListRequestValidator = func() *ValidateServiceListRequest {
	v := &ValidateServiceListRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ServiceListRequestValidator() db.Validator {
	return DefaultServiceListRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *StatefulSetListRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StatefulSetListRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StatefulSetListRequest) DeepCopy() *StatefulSetListRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StatefulSetListRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StatefulSetListRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StatefulSetListRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StatefulSetListRequestValidator().Validate(ctx, m, opts...)
}

type ValidateStatefulSetListRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStatefulSetListRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StatefulSetListRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StatefulSetListRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStatefulSetListRequestValidator = func() *ValidateStatefulSetListRequest {
	v := &ValidateStatefulSetListRequest{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func StatefulSetListRequestValidator() db.Validator {
	return DefaultStatefulSetListRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *VirtualMachineInstancesMetricData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VirtualMachineInstancesMetricData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VirtualMachineInstancesMetricData) DeepCopy() *VirtualMachineInstancesMetricData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VirtualMachineInstancesMetricData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VirtualMachineInstancesMetricData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VirtualMachineInstancesMetricData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VirtualMachineInstancesMetricDataValidator().Validate(ctx, m, opts...)
}

type ValidateVirtualMachineInstancesMetricData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVirtualMachineInstancesMetricData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VirtualMachineInstancesMetricData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VirtualMachineInstancesMetricData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["data"]; exists {

		vOpts := append(opts, db.WithValidateField("data"))
		for idx, item := range m.GetData() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["unit"]; exists {

		vOpts := append(opts, db.WithValidateField("unit"))
		if err := fv(ctx, m.GetUnit(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVirtualMachineInstancesMetricDataValidator = func() *ValidateVirtualMachineInstancesMetricData {
	v := &ValidateVirtualMachineInstancesMetricData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func VirtualMachineInstancesMetricDataValidator() db.Validator {
	return DefaultVirtualMachineInstancesMetricDataValidator
}

// augmented methods on protoc/std generated struct

func (m *VirtualMachineInstancesMetricTypeData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VirtualMachineInstancesMetricTypeData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VirtualMachineInstancesMetricTypeData) DeepCopy() *VirtualMachineInstancesMetricTypeData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VirtualMachineInstancesMetricTypeData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VirtualMachineInstancesMetricTypeData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VirtualMachineInstancesMetricTypeData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VirtualMachineInstancesMetricTypeDataValidator().Validate(ctx, m, opts...)
}

type ValidateVirtualMachineInstancesMetricTypeData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVirtualMachineInstancesMetricTypeData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VirtualMachineInstancesMetricTypeData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VirtualMachineInstancesMetricTypeData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["labels"]; exists {

		vOpts := append(opts, db.WithValidateField("labels"))
		for key, value := range m.GetLabels() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["values"]; exists {

		vOpts := append(opts, db.WithValidateField("values"))
		for idx, item := range m.GetValues() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVirtualMachineInstancesMetricTypeDataValidator = func() *ValidateVirtualMachineInstancesMetricTypeData {
	v := &ValidateVirtualMachineInstancesMetricTypeData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func VirtualMachineInstancesMetricTypeDataValidator() db.Validator {
	return DefaultVirtualMachineInstancesMetricTypeDataValidator
}

// augmented methods on protoc/std generated struct

func (m *VirtualMachineInstancesMetricsRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VirtualMachineInstancesMetricsRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VirtualMachineInstancesMetricsRequest) DeepCopy() *VirtualMachineInstancesMetricsRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VirtualMachineInstancesMetricsRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VirtualMachineInstancesMetricsRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VirtualMachineInstancesMetricsRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VirtualMachineInstancesMetricsRequestValidator().Validate(ctx, m, opts...)
}

type ValidateVirtualMachineInstancesMetricsRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVirtualMachineInstancesMetricsRequest) MetricSelectorValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepEnumItemRules(rules)
	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(VirtualMachineInstancesMetricType)
		return int32(i)
	}
	// VirtualMachineInstancesMetricType_name is generated in .pb.go
	itemValFn, err := db.NewEnumValidationRuleHandler(itemRules, VirtualMachineInstancesMetricType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for metric_selector")
	}
	itemsValidatorFn := func(ctx context.Context, elems []VirtualMachineInstancesMetricType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for metric_selector")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]VirtualMachineInstancesMetricType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []VirtualMachineInstancesMetricType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated metric_selector")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items metric_selector")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateVirtualMachineInstancesMetricsRequest) StartTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for start_time")
	}

	return validatorFn, nil
}

func (v *ValidateVirtualMachineInstancesMetricsRequest) EndTimeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for end_time")
	}

	return validatorFn, nil
}

func (v *ValidateVirtualMachineInstancesMetricsRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VirtualMachineInstancesMetricsRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VirtualMachineInstancesMetricsRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["end_time"]; exists {

		vOpts := append(opts, db.WithValidateField("end_time"))
		if err := fv(ctx, m.GetEndTime(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["metric_selector"]; exists {
		vOpts := append(opts, db.WithValidateField("metric_selector"))
		if err := fv(ctx, m.GetMetricSelector(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["start_time"]; exists {

		vOpts := append(opts, db.WithValidateField("start_time"))
		if err := fv(ctx, m.GetStartTime(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVirtualMachineInstancesMetricsRequestValidator = func() *ValidateVirtualMachineInstancesMetricsRequest {
	v := &ValidateVirtualMachineInstancesMetricsRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhMetricSelector := v.MetricSelectorValidationRuleHandler
	rulesMetricSelector := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.repeated.unique":  "true",
	}
	vFn, err = vrhMetricSelector(rulesMetricSelector)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VirtualMachineInstancesMetricsRequest.metric_selector: %s", err)
		panic(errMsg)
	}
	v.FldValidators["metric_selector"] = vFn

	vrhStartTime := v.StartTimeValidationRuleHandler
	rulesStartTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhStartTime(rulesStartTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VirtualMachineInstancesMetricsRequest.start_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["start_time"] = vFn

	vrhEndTime := v.EndTimeValidationRuleHandler
	rulesEndTime := map[string]string{
		"ves.io.schema.rules.string.query_time": "true",
	}
	vFn, err = vrhEndTime(rulesEndTime)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VirtualMachineInstancesMetricsRequest.end_time: %s", err)
		panic(errMsg)
	}
	v.FldValidators["end_time"] = vFn

	return v
}()

func VirtualMachineInstancesMetricsRequestValidator() db.Validator {
	return DefaultVirtualMachineInstancesMetricsRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *VirtualMachineInstancesMetricsResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VirtualMachineInstancesMetricsResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VirtualMachineInstancesMetricsResponse) DeepCopy() *VirtualMachineInstancesMetricsResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VirtualMachineInstancesMetricsResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VirtualMachineInstancesMetricsResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VirtualMachineInstancesMetricsResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VirtualMachineInstancesMetricsResponseValidator().Validate(ctx, m, opts...)
}

type ValidateVirtualMachineInstancesMetricsResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVirtualMachineInstancesMetricsResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VirtualMachineInstancesMetricsResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VirtualMachineInstancesMetricsResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["data"]; exists {

		vOpts := append(opts, db.WithValidateField("data"))
		for idx, item := range m.GetData() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVirtualMachineInstancesMetricsResponseValidator = func() *ValidateVirtualMachineInstancesMetricsResponse {
	v := &ValidateVirtualMachineInstancesMetricsResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func VirtualMachineInstancesMetricsResponseValidator() db.Validator {
	return DefaultVirtualMachineInstancesMetricsResponseValidator
}
