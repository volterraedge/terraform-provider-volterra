// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ves.io/schema/site/types.proto

package site

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	golang_proto "github.com/golang/protobuf/proto"
	schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = golang_proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SiteType
//
// x-displayName: "Site Type"
// Site Type which can either RE or CE
type SiteType int32

const (
	// x-displayName: "Invalid"
	// Invalid type of site
	INVALID SiteType = 0
	// x-displayName: "RE"
	// Regional Edge site
	REGIONAL_EDGE SiteType = 1
	// x-displayName: "CE"
	// Customer Edge site
	CUSTOMER_EDGE SiteType = 2
)

var SiteType_name = map[int32]string{
	0: "INVALID",
	1: "REGIONAL_EDGE",
	2: "CUSTOMER_EDGE",
}

var SiteType_value = map[string]int32{
	"INVALID":       0,
	"REGIONAL_EDGE": 1,
	"CUSTOMER_EDGE": 2,
}

func (SiteType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{0}
}

// SiteSubtype
//
// x-displayName: "Site Subtype"
// Sit Subtype
type SiteSubtype int32

const (
	// x-displayName: "No Subtype"
	// No Subtype
	NO_SUBTYPE SiteSubtype = 0
	// x-displayName: "ves-io USE Regional Edge"
	// Regional Edge for ves-io use only
	VES_IO_USE_RE SiteSubtype = 1
	// x-displayName: "CE running in Kubernetes"
	// CE running in Kubernetes
	VES_IO_CE_IN_K8S SiteSubtype = 2
)

var SiteSubtype_name = map[int32]string{
	0: "NO_SUBTYPE",
	1: "VES_IO_USE_RE",
	2: "VES_IO_CE_IN_K8S",
}

var SiteSubtype_value = map[string]int32{
	"NO_SUBTYPE":       0,
	"VES_IO_USE_RE":    1,
	"VES_IO_CE_IN_K8S": 2,
}

func (SiteSubtype) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{1}
}

// CeSiteMode
//
// x-displayName: "Customer Edge Site Mode"
// If Site is CE, it can be in followig modes
type CeSiteMode int32

const (
	// x-displayName: "Ingress and Egress Gateway"
	// Ingress Egress Gateway CE
	CE_SITE_MODE_INGRESS_EGRESS_GW CeSiteMode = 0
	// x-displayName: "Ingress Gateway"
	// Ingress Gateway CE
	CE_SITE_MODE_INGRESS_GW CeSiteMode = 1
	// x-displayName: "Egress Gateway"
	// Egress Gateway CE
	CE_SITE_MODE_EGRESS_GW CeSiteMode = 2
	// x-displayName: "DC Cloud Gateway"
	// DC Cloud Gateway CE
	CE_SITE_MODE_DC_CLOUD_GW CeSiteMode = 3
	// x-displayName: "CPE"
	// CPE CE
	CE_SITE_MODE_CPE CeSiteMode = 4
)

var CeSiteMode_name = map[int32]string{
	0: "CE_SITE_MODE_INGRESS_EGRESS_GW",
	1: "CE_SITE_MODE_INGRESS_GW",
	2: "CE_SITE_MODE_EGRESS_GW",
	3: "CE_SITE_MODE_DC_CLOUD_GW",
	4: "CE_SITE_MODE_CPE",
}

var CeSiteMode_value = map[string]int32{
	"CE_SITE_MODE_INGRESS_EGRESS_GW": 0,
	"CE_SITE_MODE_INGRESS_GW":        1,
	"CE_SITE_MODE_EGRESS_GW":         2,
	"CE_SITE_MODE_DC_CLOUD_GW":       3,
	"CE_SITE_MODE_CPE":               4,
}

func (CeSiteMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{2}
}

// IPSec State
//
// x-displayName: "IPSec State"
// IPSec Tunnel state connecting the site to other site
type IPSecState int32

const (
	// x-displayName: "Unknown"
	// Invalid state
	UNKNOWN_STATE IPSecState = 0
	// x-displayName: "Up"
	// Connection is up
	UP IPSecState = 1
	// x-displayName: "Down"
	// Connection is down
	DOWN IPSecState = 2
)

var IPSecState_name = map[int32]string{
	0: "UNKNOWN_STATE",
	1: "UP",
	2: "DOWN",
}

var IPSecState_value = map[string]int32{
	"UNKNOWN_STATE": 0,
	"UP":            1,
	"DOWN":          2,
}

func (IPSecState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{3}
}

// IPSecRole
//
// x-displayName: "IPSec Role"
// Role of VER in an IPSec connection
type IPSecRole int32

const (
	// x-displayName: "Unknown"
	// Invalid role
	UNKNOWN_ROLE IPSecRole = 0
	// x-displayName: "Initiator"
	// IPSec Client initiating the connection
	INITIATOR IPSecRole = 1
	// x-displayName: "Responder"
	// IPSec Server responding to the connection
	RESPONDER IPSecRole = 2
)

var IPSecRole_name = map[int32]string{
	0: "UNKNOWN_ROLE",
	1: "INITIATOR",
	2: "RESPONDER",
}

var IPSecRole_value = map[string]int32{
	"UNKNOWN_ROLE": 0,
	"INITIATOR":    1,
	"RESPONDER":    2,
}

func (IPSecRole) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{4}
}

// Tunnel State
//
// x-displayName: "Tunnel State"
// Tunnel state connecting the site to remote
type TunnelState int32

const (
	// x-displayName: "Unknown Tunnel State"
	// Invalid Tunnel state
	UNKNOWN_TUNNEL_STATE TunnelState = 0
	// x-displayName: "Tunnel Up"
	// Tunnel Connection is up
	TUNNEL_UP TunnelState = 1
	// x-displayName: "Tunnel Down"
	// Tunnel Connection is down
	TUNNEL_DOWN TunnelState = 2
	// x-displayName: "Tunnel Disabled"
	// Tunnel is disabled
	TUNNEL_DISABLED TunnelState = 3
)

var TunnelState_name = map[int32]string{
	0: "UNKNOWN_TUNNEL_STATE",
	1: "TUNNEL_UP",
	2: "TUNNEL_DOWN",
	3: "TUNNEL_DISABLED",
}

var TunnelState_value = map[string]int32{
	"UNKNOWN_TUNNEL_STATE": 0,
	"TUNNEL_UP":            1,
	"TUNNEL_DOWN":          2,
	"TUNNEL_DISABLED":      3,
}

func (TunnelState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{5}
}

// TunnelRole
//
// x-displayName: "Tunnel Role"
// Role of VER in a tunnel connection
type TunnelRole int32

const (
	// x-displayName: "Unknowni Tunnel Role"
	// Invalid role
	UNKNOWN_TUNNEL_ROLE TunnelRole = 0
	// x-displayName: "Tunnel Initiator"
	// Client initiating the connection
	TUNNEL_INITIATOR TunnelRole = 1
	// x-displayName: "Tunnel Responder"
	// Server responding to the connection
	TUNNEL_RESPONDER TunnelRole = 2
)

var TunnelRole_name = map[int32]string{
	0: "UNKNOWN_TUNNEL_ROLE",
	1: "TUNNEL_INITIATOR",
	2: "TUNNEL_RESPONDER",
}

var TunnelRole_value = map[string]int32{
	"UNKNOWN_TUNNEL_ROLE": 0,
	"TUNNEL_INITIATOR":    1,
	"TUNNEL_RESPONDER":    2,
}

func (TunnelRole) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{6}
}

// VTRPState
//
// x-displayName: "VTRP State"
// State of VTRP connection between (VER control plane)Vega & (Volterra Fabric control)Ares
type VTRPState int32

const (
	// x-displayName: "Init"
	// Connection is initialized
	INIT VTRPState = 0
	// x-displayName: "Active"
	// VTRP connection is active
	ACTIVE VTRPState = 1
	// x-displayName: "Connecting"
	// Connecting to the server
	CONNECTING VTRPState = 2
	// x-displayName: "Connected"
	// TCP connection is up
	CONNECTED VTRPState = 3
	// x-displayName: "Established"
	// VTRP session established
	ESTABLISHED VTRPState = 4
	// x-displayName: "Deleted"
	// Connection is deleted
	DELETE VTRPState = 5
)

var VTRPState_name = map[int32]string{
	0: "INIT",
	1: "ACTIVE",
	2: "CONNECTING",
	3: "CONNECTED",
	4: "ESTABLISHED",
	5: "DELETE",
}

var VTRPState_value = map[string]int32{
	"INIT":        0,
	"ACTIVE":      1,
	"CONNECTING":  2,
	"CONNECTED":   3,
	"ESTABLISHED": 4,
	"DELETE":      5,
}

func (VTRPState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{7}
}

// Active State
//
// x-displayName: "Active State"
// Active/Backup state for the interface
type ActiveState int32

const (
	// x-displayName: "Unknown State"
	// Unknown state
	STATE_UNKNOWN ActiveState = 0
	// x-displayName: "Active"
	// Interface in active state
	STATE_ACTIVE ActiveState = 1
	// x-displayName: "Backup"
	// Interface in backup state
	STATE_BACKUP ActiveState = 2
)

var ActiveState_name = map[int32]string{
	0: "STATE_UNKNOWN",
	1: "STATE_ACTIVE",
	2: "STATE_BACKUP",
}

var ActiveState_value = map[string]int32{
	"STATE_UNKNOWN": 0,
	"STATE_ACTIVE":  1,
	"STATE_BACKUP":  2,
}

func (ActiveState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{8}
}

// Link quality
//
// x-displayName: "Link quality"
// Link quality determined by VER using different probes
type LinkQuality int32

const (
	// x-displayName: "Quality unknown"
	// Unknown quality
	QUALITY_UNKNOWN LinkQuality = 0
	// x-displayName: "Good"
	// Link quality is good
	QUALITY_GOOD LinkQuality = 1
	// x-displayName: "Poor"
	// Link quality is poor
	QUALITY_POOR LinkQuality = 2
	// x-displayName: "Disabled"
	// Quality disabled
	QUALITY_DISABLED LinkQuality = 3
)

var LinkQuality_name = map[int32]string{
	0: "QUALITY_UNKNOWN",
	1: "QUALITY_GOOD",
	2: "QUALITY_POOR",
	3: "QUALITY_DISABLED",
}

var LinkQuality_value = map[string]int32{
	"QUALITY_UNKNOWN":  0,
	"QUALITY_GOOD":     1,
	"QUALITY_POOR":     2,
	"QUALITY_DISABLED": 3,
}

func (LinkQuality) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{9}
}

// Link type
//
// x-displayName: "Link type"
// Link type of interface determined operationally
type LinkType int32

const (
	// x-displayName: "Unknown link type"
	// Link type unknown
	LINK_TYPE_UNKNOWN LinkType = 0
	// x-displayName: "Ethernet"
	// Link type ethernet
	LINK_TYPE_ETHERNET LinkType = 1
	// x-displayName: "802.11ac"
	// WiFi link of type 802.11ac
	LINK_TYPE_WIFI_802_11AC LinkType = 2
	// x-displayName: "802.11bgn"
	// WiFi link of type 802.11bgn
	LINK_TYPE_WIFI_802_11BGN LinkType = 3
	// x-displayName: "4G"
	// Link type 4G
	LINK_TYPE_4G LinkType = 4
	// x-displayName: "WiFi"
	// WiFi link
	LINK_TYPE_WIFI LinkType = 5
	// x-displayName: "Wan"
	// Wan link
	LINK_TYPE_WAN LinkType = 6
)

var LinkType_name = map[int32]string{
	0: "LINK_TYPE_UNKNOWN",
	1: "LINK_TYPE_ETHERNET",
	2: "LINK_TYPE_WIFI_802_11AC",
	3: "LINK_TYPE_WIFI_802_11BGN",
	4: "LINK_TYPE_4G",
	5: "LINK_TYPE_WIFI",
	6: "LINK_TYPE_WAN",
}

var LinkType_value = map[string]int32{
	"LINK_TYPE_UNKNOWN":        0,
	"LINK_TYPE_ETHERNET":       1,
	"LINK_TYPE_WIFI_802_11AC":  2,
	"LINK_TYPE_WIFI_802_11BGN": 3,
	"LINK_TYPE_4G":             4,
	"LINK_TYPE_WIFI":           5,
	"LINK_TYPE_WAN":            6,
}

func (LinkType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{10}
}

// Interface Address Mode
//
// x-displayName: "AddressMode"
// AddressMode identifies the mode of address assignment on an interface
type AddressMode int32

const (
	// Static
	//
	// x-displayName: "Static"
	// Interface Address is assigned statically
	STATIC AddressMode = 0
	// DHCP
	//
	// x-displayName: "DHCP"
	// Interface Address is obtained via DHCP
	DHCP AddressMode = 1
)

var AddressMode_name = map[int32]string{
	0: "STATIC",
	1: "DHCP",
}

var AddressMode_value = map[string]int32{
	"STATIC": 0,
	"DHCP":   1,
}

func (AddressMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{11}
}

// SiteSoftwareOverrideType
//
// x-displayName: "Site Software Override Type"
// Decide which software version takes effect in case of conflict between site and fleet
type SiteSoftwareOverrideType int32

const (
	// x-displayName: "Site Version Overrides"
	//Software version in site will take precedence.
	SITE_SOFTWARE_OVERRIDE_SITE SiteSoftwareOverrideType = 0
	// x-displayName: "New Version Overrides"
	//Between site and fleet newer software version will take precedence.
	SITE_SOFTWARE_OVERRIDE_NEWER SiteSoftwareOverrideType = 1
	// x-displayName: "Fleet  Version Overrides"
	//Software version in fleet will take precedence.
	SITE_SOFTWARE_OVERRIDE_FLEET SiteSoftwareOverrideType = 2
)

var SiteSoftwareOverrideType_name = map[int32]string{
	0: "SITE_SOFTWARE_OVERRIDE_SITE",
	1: "SITE_SOFTWARE_OVERRIDE_NEWER",
	2: "SITE_SOFTWARE_OVERRIDE_FLEET",
}

var SiteSoftwareOverrideType_value = map[string]int32{
	"SITE_SOFTWARE_OVERRIDE_SITE":  0,
	"SITE_SOFTWARE_OVERRIDE_NEWER": 1,
	"SITE_SOFTWARE_OVERRIDE_FLEET": 2,
}

func (SiteSoftwareOverrideType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{12}
}

// SoftwareUpgradePhase
//
// x-displayName: "Software Upgrade Phase"
// State of Volterra Software or Operating System upgrade phase in site
type SoftwareUpgradePhase int32

const (
	// x-displayName: "Invalid"
	UPGRADE_INVALID SoftwareUpgradePhase = 0
	// x-displayName: "Scheduled"
	// Site Upgrade was triggered, but has not started yet
	UPGRADE_TRIGGERED SoftwareUpgradePhase = 1
	// x-displayName: "In Progress"
	// Site upgrade was fetched and it is in progress
	UPGRADE_IN_PROGRESS SoftwareUpgradePhase = 2
	// x-displayName: "Completed"
	// Site upgrade was completed
	UPGRADE_COMPLETED SoftwareUpgradePhase = 3
	// x-displayName: "Failed"
	// Site upgrade failed
	UPGRADE_FAILED SoftwareUpgradePhase = 4
)

var SoftwareUpgradePhase_name = map[int32]string{
	0: "UPGRADE_INVALID",
	1: "UPGRADE_TRIGGERED",
	2: "UPGRADE_IN_PROGRESS",
	3: "UPGRADE_COMPLETED",
	4: "UPGRADE_FAILED",
}

var SoftwareUpgradePhase_value = map[string]int32{
	"UPGRADE_INVALID":     0,
	"UPGRADE_TRIGGERED":   1,
	"UPGRADE_IN_PROGRESS": 2,
	"UPGRADE_COMPLETED":   3,
	"UPGRADE_FAILED":      4,
}

func (SoftwareUpgradePhase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{13}
}

// ScalingPhase
//
// x-displayName: "Scaling Phase"
// State of Scaling phase in site
type ScalingPhase int32

const (
	// x-displayName: "Invalid"
	// Invalid scaling phase
	SCALING_INVALID ScalingPhase = 0
	// x-displayName: "In Progress"
	// Site scaling is in progress
	SCALING_IN_PROGRESS ScalingPhase = 1
	// x-displayName: "Failed"
	// Site scaling failed
	SCALING_FAILED ScalingPhase = 2
	// x-displayName: "Done"
	// Site scaling is done. Site is in desired number of nodes
	SCALING_DONE ScalingPhase = 3
)

var ScalingPhase_name = map[int32]string{
	0: "SCALING_INVALID",
	1: "SCALING_IN_PROGRESS",
	2: "SCALING_FAILED",
	3: "SCALING_DONE",
}

var ScalingPhase_value = map[string]int32{
	"SCALING_INVALID":     0,
	"SCALING_IN_PROGRESS": 1,
	"SCALING_FAILED":      2,
	"SCALING_DONE":        3,
}

func (ScalingPhase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{14}
}

// SiteState
//
// x-displayName: "Site State"
// State of Site defines in which operational state site itself is.
type SiteState int32

const (
	// x-displayName: "Online"
	// Site is online and operational.
	ONLINE SiteState = 0
	// x-displayName: "Provisioning"
	// Site is in provisioning state. For instance during site deployment or switching to different connected Regional Edge.
	PROVISIONING SiteState = 1
	// x-displayName: "Upgrading"
	// Site is in process of upgrade. It transition to ONLINE or FAILED state.
	UPGRADING SiteState = 2
	// x-displayName: "Standby"
	// Site is in Standby before goes to ONLINE. This is mainly for Regional Edge sites to do their verification before they go to ONLINE state.
	STANDBY SiteState = 3
	// x-displayName: "Failed"
	// Site is in failed state. It failed during provisioning or upgrade phase. Site Status Objects contain more details.
	FAILED SiteState = 4
	// x-displayName: "Reregistraiton"
	// Reregistration was requested
	REREGISTRATION SiteState = 5
	// x-displayName: "Waiting for nodes"
	// Reregistration is in progress and maurice is waiting for nodes
	WAITINGNODES SiteState = 6
	// x-displayName: "Decommissioning"
	// Site deletion is in progress
	DECOMMISSIONING SiteState = 7
	// x-displayName: "Waiting for Registration"
	// Site is waiting for registration
	WAITING_FOR_REGISTRATION SiteState = 8
)

var SiteState_name = map[int32]string{
	0: "ONLINE",
	1: "PROVISIONING",
	2: "UPGRADING",
	3: "STANDBY",
	4: "FAILED",
	5: "REREGISTRATION",
	6: "WAITINGNODES",
	7: "DECOMMISSIONING",
	8: "WAITING_FOR_REGISTRATION",
}

var SiteState_value = map[string]int32{
	"ONLINE":                   0,
	"PROVISIONING":             1,
	"UPGRADING":                2,
	"STANDBY":                  3,
	"FAILED":                   4,
	"REREGISTRATION":           5,
	"WAITINGNODES":             6,
	"DECOMMISSIONING":          7,
	"WAITING_FOR_REGISTRATION": 8,
}

func (SiteState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{15}
}

// UsbType
//
// x-displayName: "USB Type"
// Type of USB device
type UsbType int32

const (
	// x-displayName: "Unknown"
	// Unknown USB device type
	UNKNOWN_USB UsbType = 0
	// x-displayName: "Internal"
	// Internal USB present in Certified HW
	INTERNAL UsbType = 1
	// x-displayName: "Registered"
	// USB device present during node registration
	REGISTERED UsbType = 2
	// x-displayName: "Configurable"
	// USB device that can be matched by USB rules
	CONFIGURABLE UsbType = 3
)

var UsbType_name = map[int32]string{
	0: "UNKNOWN_USB",
	1: "INTERNAL",
	2: "REGISTERED",
	3: "CONFIGURABLE",
}

var UsbType_value = map[string]int32{
	"UNKNOWN_USB":  0,
	"INTERNAL":     1,
	"REGISTERED":   2,
	"CONFIGURABLE": 3,
}

func (UsbType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{16}
}

// SiteStatusMetricsField
//
// x-displayName: "Site Status Metrics Field"
// Lists the fields that can queried in the site status metrics request
type SiteStatusMetricsField int32

const (
	// x-displayName: "Active Flow Count"
	SITE_ACTIVE_FLOW_COUNT SiteStatusMetricsField = 0
	// x-displayName: "Flow Setup Rate"
	SITE_FLOW_SETUP_RATE SiteStatusMetricsField = 1
	// x-displayName: "In Throughput"
	SITE_IN_THROUGHPUT SiteStatusMetricsField = 2
	// x-displayName: "Out Throughput"
	SITE_OUT_THROUGHPUT SiteStatusMetricsField = 3
	// x-displayName: "System Active Pod Count"
	SITE_SYSTEM_ACTIVE_POD_COUNT SiteStatusMetricsField = 4
	// x-displayName: "vK8s Active Pod Count"
	SITE_VK8S_ACTIVE_POD_COUNT SiteStatusMetricsField = 5
	// x-displayName: "Traffic from RE"
	SITE_RE_IN_THROUGHPUT SiteStatusMetricsField = 6
	// x-displayName: "Traffic to RE"
	SITE_RE_OUT_THROUGHPUT SiteStatusMetricsField = 7
	// x-displayName: "Traffic from other CE site"
	SITE_SITE_IN_THROUGHPUT SiteStatusMetricsField = 8
	// x-displayName: "Traffic to other CE site"
	SITE_SITE_OUT_THROUGHPUT SiteStatusMetricsField = 9
	// x-displayName: "Node CPU Usage"
	SITE_NODE_CPU_USAGE SiteStatusMetricsField = 10
	// x-displayName: "Node Memory Usage"
	SITE_NODE_MEMORY_USAGE SiteStatusMetricsField = 11
	// x-displayName: "Node Disk Usage"
	SITE_NODE_DISK_USAGE SiteStatusMetricsField = 12
	// x-displayName: "Node Active Flow Count"
	SITE_NODE_ACTIVE_FLOW_COUNT SiteStatusMetricsField = 13
	// x-displayName: "Node Flow Setup Rate"
	SITE_NODE_FLOW_SETUP_RATE SiteStatusMetricsField = 14
	// x-displayName: "Node In Throughput"
	SITE_NODE_IN_THROUGHPUT SiteStatusMetricsField = 15
	// x-displayName: "Node Out Throughput"
	SITE_NODE_OUT_THROUGHPUT SiteStatusMetricsField = 16
	// x-displayName: "Node Interface In Throughput"
	SITE_NODE_IF_IN_THROUGHPUT SiteStatusMetricsField = 17
	// x-displayName: "Node Interface Out Throughput"
	SITE_NODE_IF_OUT_THROUGHPUT SiteStatusMetricsField = 18
)

var SiteStatusMetricsField_name = map[int32]string{
	0:  "SITE_ACTIVE_FLOW_COUNT",
	1:  "SITE_FLOW_SETUP_RATE",
	2:  "SITE_IN_THROUGHPUT",
	3:  "SITE_OUT_THROUGHPUT",
	4:  "SITE_SYSTEM_ACTIVE_POD_COUNT",
	5:  "SITE_VK8S_ACTIVE_POD_COUNT",
	6:  "SITE_RE_IN_THROUGHPUT",
	7:  "SITE_RE_OUT_THROUGHPUT",
	8:  "SITE_SITE_IN_THROUGHPUT",
	9:  "SITE_SITE_OUT_THROUGHPUT",
	10: "SITE_NODE_CPU_USAGE",
	11: "SITE_NODE_MEMORY_USAGE",
	12: "SITE_NODE_DISK_USAGE",
	13: "SITE_NODE_ACTIVE_FLOW_COUNT",
	14: "SITE_NODE_FLOW_SETUP_RATE",
	15: "SITE_NODE_IN_THROUGHPUT",
	16: "SITE_NODE_OUT_THROUGHPUT",
	17: "SITE_NODE_IF_IN_THROUGHPUT",
	18: "SITE_NODE_IF_OUT_THROUGHPUT",
}

var SiteStatusMetricsField_value = map[string]int32{
	"SITE_ACTIVE_FLOW_COUNT":       0,
	"SITE_FLOW_SETUP_RATE":         1,
	"SITE_IN_THROUGHPUT":           2,
	"SITE_OUT_THROUGHPUT":          3,
	"SITE_SYSTEM_ACTIVE_POD_COUNT": 4,
	"SITE_VK8S_ACTIVE_POD_COUNT":   5,
	"SITE_RE_IN_THROUGHPUT":        6,
	"SITE_RE_OUT_THROUGHPUT":       7,
	"SITE_SITE_IN_THROUGHPUT":      8,
	"SITE_SITE_OUT_THROUGHPUT":     9,
	"SITE_NODE_CPU_USAGE":          10,
	"SITE_NODE_MEMORY_USAGE":       11,
	"SITE_NODE_DISK_USAGE":         12,
	"SITE_NODE_ACTIVE_FLOW_COUNT":  13,
	"SITE_NODE_FLOW_SETUP_RATE":    14,
	"SITE_NODE_IN_THROUGHPUT":      15,
	"SITE_NODE_OUT_THROUGHPUT":     16,
	"SITE_NODE_IF_IN_THROUGHPUT":   17,
	"SITE_NODE_IF_OUT_THROUGHPUT":  18,
}

func (SiteStatusMetricsField) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{17}
}

// Bond Interface Members
//
// x-displayName: "Bond Interface Members"
// BondMembersType represents the bond interface members  along with the corresponding link state
type BondMembersType struct {
	// Name
	// x-displayName: "Name"
	// Name of the Bond Interface Member
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Link State
	// x-displayName: "Link State"
	// Link state of Bond Interface Member
	LinkState bool `protobuf:"varint,2,opt,name=link_state,json=linkState,proto3" json:"link_state,omitempty"`
	// Link Speed
	// x-displayName: "Link Speed in Mbps"
	// Link speed of Bond Interface Member in Mbps
	LinkSpeed uint32 `protobuf:"varint,3,opt,name=link_speed,json=linkSpeed,proto3" json:"link_speed,omitempty"`
}

func (m *BondMembersType) Reset()      { *m = BondMembersType{} }
func (*BondMembersType) ProtoMessage() {}
func (*BondMembersType) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{0}
}
func (m *BondMembersType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BondMembersType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *BondMembersType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BondMembersType.Merge(m, src)
}
func (m *BondMembersType) XXX_Size() int {
	return m.Size()
}
func (m *BondMembersType) XXX_DiscardUnknown() {
	xxx_messageInfo_BondMembersType.DiscardUnknown(m)
}

var xxx_messageInfo_BondMembersType proto.InternalMessageInfo

func (m *BondMembersType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BondMembersType) GetLinkState() bool {
	if m != nil {
		return m.LinkState
	}
	return false
}

func (m *BondMembersType) GetLinkSpeed() uint32 {
	if m != nil {
		return m.LinkSpeed
	}
	return 0
}

// Site Coordinates
//
// x-displayName: "Site Coordinates"
// Coordinates of the site which provides the site physical location
type Coordinates struct {
	// latitude
	//
	// x-displayName: "Latitude"
	// Latitude of the site location
	Latitude float32 `protobuf:"fixed32,1,opt,name=latitude,proto3" json:"latitude,omitempty"`
	// longitude
	//
	// x-displayName: "Longitude"
	// longitude of site location
	Longitude float32 `protobuf:"fixed32,2,opt,name=longitude,proto3" json:"longitude,omitempty"`
}

func (m *Coordinates) Reset()      { *m = Coordinates{} }
func (*Coordinates) ProtoMessage() {}
func (*Coordinates) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{1}
}
func (m *Coordinates) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Coordinates) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Coordinates) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Coordinates.Merge(m, src)
}
func (m *Coordinates) XXX_Size() int {
	return m.Size()
}
func (m *Coordinates) XXX_DiscardUnknown() {
	xxx_messageInfo_Coordinates.DiscardUnknown(m)
}

var xxx_messageInfo_Coordinates proto.InternalMessageInfo

func (m *Coordinates) GetLatitude() float32 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *Coordinates) GetLongitude() float32 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

// K8sApiServer
//
// x-displayName: "K8s Api Server"
// Site's Physical Kubernetes API server. The location of this server is in site specification
type K8SApiServerParameters struct {
}

func (m *K8SApiServerParameters) Reset()      { *m = K8SApiServerParameters{} }
func (*K8SApiServerParameters) ProtoMessage() {}
func (*K8SApiServerParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{2}
}
func (m *K8SApiServerParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *K8SApiServerParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *K8SApiServerParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SApiServerParameters.Merge(m, src)
}
func (m *K8SApiServerParameters) XXX_Size() int {
	return m.Size()
}
func (m *K8SApiServerParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SApiServerParameters.DiscardUnknown(m)
}

var xxx_messageInfo_K8SApiServerParameters proto.InternalMessageInfo

// default_underlay_vn
//
// x-displayName: "Default Underlay Virtual Network"
// Optional, virtual network to be used as underlay for different overlay protocols (SRv6, IP-in-IP tunnels for DC Cluster Group)
// Default is site-local-outside network
type DefaultUnderlayNetworkType struct {
	// Select Virtual Network
	//
	// x-displayName: "Select Virtual Network"
	// x-required
	// Choose Virtual Network to be used as underlay for tunneling protocols
	//
	// Types that are valid to be assigned to PrivateAccessChoice:
	//	*DefaultUnderlayNetworkType_SiteLocalOutside
	//	*DefaultUnderlayNetworkType_SiteLocalInside
	PrivateAccessChoice isDefaultUnderlayNetworkType_PrivateAccessChoice `protobuf_oneof:"private_access_choice"`
}

func (m *DefaultUnderlayNetworkType) Reset()      { *m = DefaultUnderlayNetworkType{} }
func (*DefaultUnderlayNetworkType) ProtoMessage() {}
func (*DefaultUnderlayNetworkType) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{3}
}
func (m *DefaultUnderlayNetworkType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DefaultUnderlayNetworkType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DefaultUnderlayNetworkType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DefaultUnderlayNetworkType.Merge(m, src)
}
func (m *DefaultUnderlayNetworkType) XXX_Size() int {
	return m.Size()
}
func (m *DefaultUnderlayNetworkType) XXX_DiscardUnknown() {
	xxx_messageInfo_DefaultUnderlayNetworkType.DiscardUnknown(m)
}

var xxx_messageInfo_DefaultUnderlayNetworkType proto.InternalMessageInfo

type isDefaultUnderlayNetworkType_PrivateAccessChoice interface {
	isDefaultUnderlayNetworkType_PrivateAccessChoice()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type DefaultUnderlayNetworkType_SiteLocalOutside struct {
	SiteLocalOutside *schema.Empty `protobuf:"bytes,2,opt,name=site_local_outside,json=siteLocalOutside,proto3,oneof" json:"site_local_outside,omitempty"`
}
type DefaultUnderlayNetworkType_SiteLocalInside struct {
	SiteLocalInside *schema.Empty `protobuf:"bytes,3,opt,name=site_local_inside,json=siteLocalInside,proto3,oneof" json:"site_local_inside,omitempty"`
}

func (*DefaultUnderlayNetworkType_SiteLocalOutside) isDefaultUnderlayNetworkType_PrivateAccessChoice() {
}
func (*DefaultUnderlayNetworkType_SiteLocalInside) isDefaultUnderlayNetworkType_PrivateAccessChoice() {
}

func (m *DefaultUnderlayNetworkType) GetPrivateAccessChoice() isDefaultUnderlayNetworkType_PrivateAccessChoice {
	if m != nil {
		return m.PrivateAccessChoice
	}
	return nil
}

func (m *DefaultUnderlayNetworkType) GetSiteLocalOutside() *schema.Empty {
	if x, ok := m.GetPrivateAccessChoice().(*DefaultUnderlayNetworkType_SiteLocalOutside); ok {
		return x.SiteLocalOutside
	}
	return nil
}

func (m *DefaultUnderlayNetworkType) GetSiteLocalInside() *schema.Empty {
	if x, ok := m.GetPrivateAccessChoice().(*DefaultUnderlayNetworkType_SiteLocalInside); ok {
		return x.SiteLocalInside
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DefaultUnderlayNetworkType) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DefaultUnderlayNetworkType_SiteLocalOutside)(nil),
		(*DefaultUnderlayNetworkType_SiteLocalInside)(nil),
	}
}

// Publish VIP Params Per AZ
//
// x-displayName: "Publish VIP Params Per AZ"
// Per AZ parameters needed to publish VIP for publci cloud sites
type PublishVIPParamsPerAz struct {
	// Inside VIP(s)
	//
	// x-displayName: "Inside VIP(s)"
	// x-example: "192.168.0.156"
	// List of Inside VIPs for an AZ
	InsideVip []string `protobuf:"bytes,1,rep,name=inside_vip,json=insideVip,proto3" json:"inside_vip,omitempty"`
	// Outside VIP(s)
	//
	// x-displayName: "Outside VIP(s)"
	// x-example: "192.168.0.156"
	// x-required
	// List of Outside VIPs for an AZ
	OutsideVip []string `protobuf:"bytes,2,rep,name=outside_vip,json=outsideVip,proto3" json:"outside_vip,omitempty"`
	// Outside VIP CNAME
	//
	// x-displayName: "Outside VIP CNAME"
	// x-example: "test.56670-387196482.useast2.ves.io"
	// CNAME value for the outside VIP
	// These are usually public cloud generated CNAME
	OutsideVipCname string `protobuf:"bytes,3,opt,name=outside_vip_cname,json=outsideVipCname,proto3" json:"outside_vip_cname,omitempty"`
	// Inside VIP CNAME
	//
	// x-displayName: "Inside VIP CNAME"
	// x-example: "test.56670-387196482.useast2.ves.io"
	// CNAME value for the inside VIP,
	// These are usually public cloud generated CNAME
	InsideVipCname string `protobuf:"bytes,4,opt,name=inside_vip_cname,json=insideVipCname,proto3" json:"inside_vip_cname,omitempty"`
	// AZ Name
	//
	// x-displayName: "AZ Name"
	// x-example: "us-east-2a"
	// Name of the Availability zone
	AzName string `protobuf:"bytes,5,opt,name=az_name,json=azName,proto3" json:"az_name,omitempty"`
}

func (m *PublishVIPParamsPerAz) Reset()      { *m = PublishVIPParamsPerAz{} }
func (*PublishVIPParamsPerAz) ProtoMessage() {}
func (*PublishVIPParamsPerAz) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{4}
}
func (m *PublishVIPParamsPerAz) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublishVIPParamsPerAz) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *PublishVIPParamsPerAz) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishVIPParamsPerAz.Merge(m, src)
}
func (m *PublishVIPParamsPerAz) XXX_Size() int {
	return m.Size()
}
func (m *PublishVIPParamsPerAz) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishVIPParamsPerAz.DiscardUnknown(m)
}

var xxx_messageInfo_PublishVIPParamsPerAz proto.InternalMessageInfo

func (m *PublishVIPParamsPerAz) GetInsideVip() []string {
	if m != nil {
		return m.InsideVip
	}
	return nil
}

func (m *PublishVIPParamsPerAz) GetOutsideVip() []string {
	if m != nil {
		return m.OutsideVip
	}
	return nil
}

func (m *PublishVIPParamsPerAz) GetOutsideVipCname() string {
	if m != nil {
		return m.OutsideVipCname
	}
	return ""
}

func (m *PublishVIPParamsPerAz) GetInsideVipCname() string {
	if m != nil {
		return m.InsideVipCname
	}
	return ""
}

func (m *PublishVIPParamsPerAz) GetAzName() string {
	if m != nil {
		return m.AzName
	}
	return ""
}

// Global Specification
//
// x-displayName: "Specification"
// Global specification of Site object
type GlobalSpecType struct {
	// site_type
	//
	// x-displayName: "Site Type"
	// Site type which specifies whether it is RE or CE
	SiteType SiteType `protobuf:"varint,1,opt,name=site_type,json=siteType,proto3,enum=ves.io.schema.site.SiteType" json:"site_type,omitempty"`
	// site_subtype
	//
	// x-displayName: "Site Subtype"
	// Site subtype
	SiteSubtype SiteSubtype `protobuf:"varint,5,opt,name=site_subtype,json=siteSubtype,proto3,enum=ves.io.schema.site.SiteSubtype" json:"site_subtype,omitempty"`
	// address
	//
	// x-displayName: "Geographical Address"
	// x-example: "123 Street, city, country, postal code"
	// Site's geographical address that can be used determine its latitude and longitude.
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// coordinates
	//
	// x-displayName: "Co-ordinates"
	// Site longitude and latitude co-ordinates
	Coordinates *Coordinates `protobuf:"bytes,3,opt,name=coordinates,proto3" json:"coordinates,omitempty"`
	// Connected REs
	//
	// x-displayName: "Connected REs"
	// x-required
	// Following fields are only for customer edge sites
	// List of REs to which to which this CE initiates IPSec/SSL connection to
	ConnectedRe []*schema.ObjectRefType `protobuf:"bytes,103,rep,name=connected_re,json=connectedRe,proto3" json:"connected_re,omitempty"`
	// connected_re_for_config
	//
	// x-displayName: "REs for Configuration"
	// x-required
	// This field is valid only for CE site object
	// List of REs which can send config to this CE site
	ConnectedReForConfig []*schema.ObjectRefType `protobuf:"bytes,104,rep,name=connected_re_for_config,json=connectedReForConfig,proto3" json:"connected_re_for_config,omitempty"`
	// vega
	//
	// x-displayName: "Vega Parameters"
	// Parameters to connect to this site {URL, type of TLS}
	Vega *schema.ServiceParameters `protobuf:"bytes,105,opt,name=vega,proto3" json:"vega,omitempty"`
	// ares_list
	//
	// x-displayName: "Ares Services"
	// List of Ares services in an RE site. This is used to create a full mesh of Ares services across all REs.
	AresList []*schema.ServiceParameters `protobuf:"bytes,106,rep,name=ares_list,json=aresList,proto3" json:"ares_list,omitempty"`
	// rakar
	//
	// x-displayName: "Rakar Parameters"
	// Rakar in the site
	Rakar *schema.ServiceParameters `protobuf:"bytes,107,opt,name=rakar,proto3" json:"rakar,omitempty"`
	// opera
	//
	// x-displayName: "opera Parameters"
	// opera in the site
	Opera *schema.ServiceParameters `protobuf:"bytes,133,opt,name=opera,proto3" json:"opera,omitempty"`
	// static_routes
	//
	// x-displayName: "Static Routes"
	// x-example: "10.1.1.0/24"
	// x-required
	// List of Fabric VN subnets/addresses in this site
	StaticRoutes []string `protobuf:"bytes,108,rep,name=static_routes,json=staticRoutes,proto3" json:"static_routes,omitempty"`
	// k8s_api_servers
	//
	// x-displayName: "Kubernetes API Servers"
	// physical kubernetes API servers on this site.
	// The index is kubernetes API server host name
	K8SApiServers map[string]*K8SApiServerParameters `protobuf:"bytes,109,rep,name=k8s_api_servers,json=k8sApiServers,proto3" json:"k8s_api_servers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// public_ip
	//
	// x-displayName: "Public IP"
	// x-example: "1.2.3.4"
	// VIP in the Public VN used for terminating IPSec/SSL tunnels
	// The automatic tunnels between regional-edges or between regional-edge and customer-edge sites use this VIP
	// Note: Tunnels can also be configured via SiteMeshGroup. Public IP is not used for SiteMeshGroup tunnels
	PublicIp string `protobuf:"bytes,110,opt,name=public_ip,json=publicIp,proto3" json:"public_ip,omitempty"`
	// private_ip
	//
	// x-displayName: "Private IP"
	// x-example: "1.2.3.4"
	// VIP in the Private VN used for terminating IPSec/SSL tunnels
	// The automatic tunnels between regional-edges and customer-edge sites use this VIP if private access is enabled
	PrivateIp string `protobuf:"bytes,138,opt,name=private_ip,json=privateIp,proto3" json:"private_ip,omitempty"`
	// ipsec_ssl_vip_fqdn
	//
	// x-displayName: "FQDN for IPSEC/SSL VIP"
	// x-example: "re01.ves.io"
	// FQDN resolves in public ip on public network and private ip on private network
	IpsecSslVipFqdn string `protobuf:"bytes,139,opt,name=ipsec_ssl_vip_fqdn,json=ipsecSslVipFqdn,proto3" json:"ipsec_ssl_vip_fqdn,omitempty"`
	// cluster_ip
	//
	// x-displayName: "Cluster IP"
	// x-example: "1.2.3.4"
	// VIP in the Fabric VN for accessing Volterra services like Ares etc
	// constraint - used only in REs
	ClusterIp string `protobuf:"bytes,111,opt,name=cluster_ip,json=clusterIp,proto3" json:"cluster_ip,omitempty"`
	// ares_vtrp_list
	//
	// x-displayName: "Ares VTRP Services"
	// List of Ares services in an RE site for use with VTRP. This is used to choose a redundant pair of Ares services for VTRP clients.
	AresVtrpList []*schema.ServiceParameters `protobuf:"bytes,112,rep,name=ares_vtrp_list,json=aresVtrpList,proto3" json:"ares_vtrp_list,omitempty"`
	// volterra_software_version
	//
	// x-displayName: "Software Version"
	// x-example: "value"
	// Desired Volterra software version for this site, a string matching released set of software components.
	VolterraSoftwareVersion string `protobuf:"bytes,113,opt,name=volterra_software_version,json=volterraSoftwareVersion,proto3" json:"volterra_software_version,omitempty"`
	// inside_vip
	//
	// x-displayName: "Inside VIP"
	// x-example: "10.1.1.1"
	// Optional Virtual IP to be used as automatic VIP for site local inside network.
	// See documentation for "VIP" in advertise policy to see when Inside VIP is used.
	// When configured, this is used as VIP (depending on advertise policy configuration).
	// When not configured, site local inside interface ip will be used as VIP.
	InsideVip string `protobuf:"bytes,114,opt,name=inside_vip,json=insideVip,proto3" json:"inside_vip,omitempty"`
	// outside_vip
	//
	// x-displayName: "Outside VIP"
	// x-example: "10.1.1.1"
	// Optional Virtual IP to be used as automatic VIP for site local outside network.
	// See documentation for "VIP" in advertise policy to see when Outside VIP is used.
	// When configured, this is used as VIP (depending on advertise policy configuration).
	// When not configured, site local interface ip will be used as VIP.
	OutsideVip string `protobuf:"bytes,120,opt,name=outside_vip,json=outsideVip,proto3" json:"outside_vip,omitempty"`
	// vip_params_per_az
	//
	// x-displayName: "Publish VIP Params Per AZ"
	// Optional Publish VIP Parameters Per AZ for public cloud sites.
	// See documentation for "VIP" in advertise policy to see when Inside VIP or Outside VIP is used.
	// When configured, the VIP(s) defined will be used to publish to external systems like K8s, Consul
	VipParamsPerAz []*PublishVIPParamsPerAz `protobuf:"bytes,144,rep,name=vip_params_per_az,json=vipParamsPerAz,proto3" json:"vip_params_per_az,omitempty"`
	// vip_vrrp_mode
	//
	// x-displayName: "VIP Advertisement Mode"
	// Optional VIP VRRP advertisement mode. This controls the ARP behavior for "Outside VIP" and "Inside VIP"
	// addresses, when they are configured. When turned on, the Master VER would advertise gratuitous ARPs and
	// would respond to ARP queries for these addresses. When turned off, ARP responses are not given by VER.
	//
	// If BGP is configured, the Inside VIP and outside VIP addresses will be advertised by BGP. This is
	// irrespective of the vrrp mode.
	//
	// When Outside VIP / Inside VIP are configured, it is recommended to turn on vrrp and also configure BGP.
	VipVrrpMode schema.VipVrrpType `protobuf:"varint,121,opt,name=vip_vrrp_mode,json=vipVrrpMode,proto3,enum=ves.io.schema.VipVrrpType" json:"vip_vrrp_mode,omitempty"`
	// default_underlay_vn
	//
	// x-displayName: "Default Underlay Virtual Network"
	// Optional, virtual network to be used as underlay for different overlay protocols (SRv6, IP-in-IP tunnels for DC Cluster Group)
	// Default is site-local-outside network
	DefaultUnderlayNetwork *DefaultUnderlayNetworkType `protobuf:"bytes,141,opt,name=default_underlay_network,json=defaultUnderlayNetwork,proto3" json:"default_underlay_network,omitempty"`
	// site_to_site_network_type
	//
	// x-displayName: "Site To Site Network Type"
	// Optional, virtual network type to be used for site to site tunnels created with SiteMeshGroup.
	// Must be specified for CE site mesh group configuration
	SiteToSiteNetworkType schema.VirtualNetworkType `protobuf:"varint,122,opt,name=site_to_site_network_type,json=siteToSiteNetworkType,proto3,enum=ves.io.schema.VirtualNetworkType" json:"site_to_site_network_type,omitempty"`
	// site_to_site_tunnel_ip
	//
	// x-displayName: "Site To Site Tunnel IP"
	// x-example: "10.1.1.1"
	// Optionsl, VIP in the site_to_site_network_type configured above used for terminating IPSec/SSL tunnels created with SiteMeshGroup.
	SiteToSiteTunnelIp string `protobuf:"bytes,115,opt,name=site_to_site_tunnel_ip,json=siteToSiteTunnelIp,proto3" json:"site_to_site_tunnel_ip,omitempty"`
	// volterra_software_override
	//
	// x-displayName: "Site Software Version Override"
	// Policy to pick Volterra software version between verion given in site and corresponding fleet object.
	VolterraSoftwareOveride SiteSoftwareOverrideType `protobuf:"varint,116,opt,name=volterra_software_overide,json=volterraSoftwareOveride,proto3,enum=ves.io.schema.site.SiteSoftwareOverrideType" json:"volterra_software_overide,omitempty"`
	// bgp_router_id
	//
	// x-displayName: "BGP Router ID"
	// x-example: "10.1.1.1"
	// Optional bgp router id that can be used as parameter for BGP configuration when BGP is configurred to
	// fetch BGP router ID from site object. This can be used to change router id per site in a fleet.
	BgpRouterId string `protobuf:"bytes,117,opt,name=bgp_router_id,json=bgpRouterId,proto3" json:"bgp_router_id,omitempty"`
	// bgp_peer_address
	//
	// x-displayName: "BGP Peer Address"
	// x-example: "10.1.1.1"
	// Optional bgp peer address that can be used as parameter for BGP configuration when BGP is configured
	// to fetch BGP peer address from site Object. This can be used to change peer addres per site in fleet.
	BgpPeerAddress string `protobuf:"bytes,118,opt,name=bgp_peer_address,json=bgpPeerAddress,proto3" json:"bgp_peer_address,omitempty"`
	// template_parameters
	//
	// x-displayName: "Template Parameters"
	// x-example: "value"
	// Optional
	// Map of string keys and values that can be used to provide per site config parameters to various
	// configurations objects that configure features on set of sites
	// In the configuration object a key is provided and value for that key is provided in the
	// template_parameters
	TemplateParameters map[string]string `protobuf:"bytes,119,rep,name=template_parameters,json=templateParameters,proto3" json:"template_parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// inside_nameserver
	//
	// x-displayName: "DNS Server for Inside Network"
	// x-example: "10.1.1.1"
	// Optional DNS server IP to be used for name resolution in inside network
	InsideNameserver string `protobuf:"bytes,123,opt,name=inside_nameserver,json=insideNameserver,proto3" json:"inside_nameserver,omitempty"`
	// outside_nameserver
	//
	// x-displayName: "DNS Server for Outside Network"
	// x-example: "10.1.1.1"
	// Optional DNS server IP to be used for name resolution in outside network
	OutsideNameserver string `protobuf:"bytes,124,opt,name=outside_nameserver,json=outsideNameserver,proto3" json:"outside_nameserver,omitempty"`
	// desired_pool_count
	//
	// x-displayName: "Desired Pool Count"
	// x-example: "0"
	// Desired pool count represent desired number of worker(non master) nodes
	// for manual scaling of public cloud(AWS, GCP, Azure) sites. The desired count
	// must be less than or equal to the maximum size of the scaling group for a
	// given public cloud. One may also have to increase maximum scaling group size to
	// effectively increase desired pool count.
	DesiredPoolCount int32 `protobuf:"varint,125,opt,name=desired_pool_count,json=desiredPoolCount,proto3" json:"desired_pool_count,omitempty"`
	// Site to site tunnel type
	//
	// x-displayName: "Site Tunnel Type"
	// Tunnel type specifies type of tunnels enabled from this site. The tunnel type is used for automatic tunnels
	// created between regional-edge sites or between regional-edge and customer-edge sites
	//
	// A tunnel connects two sites. The tunnel types enabled for tunnel results from intersection of tunnel types
	// enabled for the two sites. IPSec gets priority over SSL when both are enabled
	//
	// Note: Tunnels can also be configured via SiteMeshGroup. Tunnel type is not used for SiteMeshGroup tunnels
	TunnelType schema.SiteToSiteTunnelType `protobuf:"varint,126,opt,name=tunnel_type,json=tunnelType,proto3,enum=ves.io.schema.SiteToSiteTunnelType" json:"tunnel_type,omitempty"`
	// site_state
	//
	// x-displayName: "Site State"
	// Site state defines its state machine and in which operational phase it is. It is for both Regional Edge
	// as well as Customer Edge. Example flow is site is in PROVISIONING then goest to STANDBY and ONLINE. In case of
	// switching to different Connected RE it goes back to PROVISIONING and ONLINE. If any of phase failes then it
	// goest to FAILED.
	SiteState SiteState `protobuf:"varint,127,opt,name=site_state,json=siteState,proto3,enum=ves.io.schema.site.SiteState" json:"site_state,omitempty"`
	// operating_system_version
	//
	// x-displayName: "Operating System Version"
	// x-example: "value"
	// Desired Operating System version for this site.
	OperatingSystemVersion string `protobuf:"bytes,128,opt,name=operating_system_version,json=operatingSystemVersion,proto3" json:"operating_system_version,omitempty"`
	// mars_list
	//
	// x-displayName: "Mars Services"
	// List of Mars services in an RE site. This is used to create a full mesh of Mars services across all REs.
	MarsList []*schema.ServiceParameters `protobuf:"bytes,129,rep,name=mars_list,json=marsList,proto3" json:"mars_list,omitempty"`
	// mars_vtrp_list
	//
	// x-displayName: "Mars VTRP Services"
	// List of Mars services in an RE site for use with VTRP. This is used to choose a redundant pair of Mars services for VTRP clients.
	MarsVtrpList []*schema.ServiceParameters `protobuf:"bytes,130,rep,name=mars_vtrp_list,json=marsVtrpList,proto3" json:"mars_vtrp_list,omitempty"`
	// tunnel_dead_timeout
	//
	// x-displayName: "Tunnel Dead Timeout (msec)"
	// x-example: "0"
	// Time interval, in millisec, within which any ipsec / ssl connection from the site going down is detected.
	// When not set (== 0), a default value of 10000 msec will be used.
	TunnelDeadTimeout uint32 `protobuf:"varint,131,opt,name=tunnel_dead_timeout,json=tunnelDeadTimeout,proto3" json:"tunnel_dead_timeout,omitempty"`
	// region
	//
	// x-displayName: "Region"
	// x-example: "east-us-2"
	// Cloud Region. A region is a set of datacenters deployed within a latency-defined perimeter and connected through a dedicated regional low-latency network
	Region string `protobuf:"bytes,132,opt,name=region,proto3" json:"region,omitempty"`
	// CE Site Mode
	//
	// x-displayName: "CE Site Mode"
	// Customer Eddge Mode. Defines how the CE is being deployed. Invalid for RE Site
	CeSiteMode CeSiteMode `protobuf:"varint,134,opt,name=ce_site_mode,json=ceSiteMode,proto3,enum=ves.io.schema.site.CeSiteMode" json:"ce_site_mode,omitempty"`
	// Disable appending tenant in vk8s namespace
	//
	// x-displayName: "vk8s ns format"
	// Disable appending tenant to vk8s namepsaces created in CE site.
	NoTenantInVk8SNs bool `protobuf:"varint,135,opt,name=no_tenant_in_vk8s_ns,json=noTenantInVk8sNs,proto3" json:"no_tenant_in_vk8s_ns,omitempty"`
	// Local K8s Cluster Access Enabled
	//
	// x-displayName: "Local K8s Cluster Access Enabled"
	// Lets user know if this site has local k8s cluster enabled via fleet configuration.
	LocalK8SAccessEnabled bool `protobuf:"varint,136,opt,name=local_k8s_access_enabled,json=localK8sAccessEnabled,proto3" json:"local_k8s_access_enabled,omitempty"`
	// k8s cluster api gateway
	//
	// x-displayName: "K8s Cluster API Gateway"
	// Internal reference to k8s cluster api gateway VH
	K8SClusterApiGw []*schema.ObjectRefType `protobuf:"bytes,137,rep,name=k8s_cluster_api_gw,json=k8sClusterApiGw,proto3" json:"k8s_cluster_api_gw,omitempty"`
	// Use Private IP
	//
	// x-displayName: "Use Private IP"
	// VER should use private IP to setup SSL/IPSEC tunnels
	UsePrivateIp bool `protobuf:"varint,140,opt,name=use_private_ip,json=usePrivateIp,proto3" json:"use_private_ip,omitempty"`
	// Tenant Index
	//
	// x-displayName: "Tenant Index"
	// object_index of an associated Tenant Index
	TenantIndex uint32 `protobuf:"varint,142,opt,name=tenant_index,json=tenantIndex,proto3" json:"tenant_index,omitempty"`
	// Piku enabled
	//
	// x-displayName: "Piku enabled"
	// Indicates that piku service is enabled
	PikuEnabled bool `protobuf:"varint,145,opt,name=piku_enabled,json=pikuEnabled,proto3" json:"piku_enabled,omitempty"`
	// Phobos enabled
	//
	// x-displayName: "Phobos enabled"
	// Indicates that phobos service is enabled
	PhobosEnabled bool `protobuf:"varint,146,opt,name=phobos_enabled,json=phobosEnabled,proto3" json:"phobos_enabled,omitempty"`
	// Srv6 enabled
	//
	// x-displayName: "Srv6 enabled"
	// Indicates that Srv6 is enabled
	Srv6Enabled bool `protobuf:"varint,147,opt,name=srv6_enabled,json=srv6Enabled,proto3" json:"srv6_enabled,omitempty"`
}

func (m *GlobalSpecType) Reset()      { *m = GlobalSpecType{} }
func (*GlobalSpecType) ProtoMessage() {}
func (*GlobalSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{5}
}
func (m *GlobalSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalSpecType.Merge(m, src)
}
func (m *GlobalSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GlobalSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalSpecType proto.InternalMessageInfo

func (m *GlobalSpecType) GetSiteType() SiteType {
	if m != nil {
		return m.SiteType
	}
	return INVALID
}

func (m *GlobalSpecType) GetSiteSubtype() SiteSubtype {
	if m != nil {
		return m.SiteSubtype
	}
	return NO_SUBTYPE
}

func (m *GlobalSpecType) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *GlobalSpecType) GetCoordinates() *Coordinates {
	if m != nil {
		return m.Coordinates
	}
	return nil
}

func (m *GlobalSpecType) GetConnectedRe() []*schema.ObjectRefType {
	if m != nil {
		return m.ConnectedRe
	}
	return nil
}

func (m *GlobalSpecType) GetConnectedReForConfig() []*schema.ObjectRefType {
	if m != nil {
		return m.ConnectedReForConfig
	}
	return nil
}

func (m *GlobalSpecType) GetVega() *schema.ServiceParameters {
	if m != nil {
		return m.Vega
	}
	return nil
}

func (m *GlobalSpecType) GetAresList() []*schema.ServiceParameters {
	if m != nil {
		return m.AresList
	}
	return nil
}

func (m *GlobalSpecType) GetRakar() *schema.ServiceParameters {
	if m != nil {
		return m.Rakar
	}
	return nil
}

func (m *GlobalSpecType) GetOpera() *schema.ServiceParameters {
	if m != nil {
		return m.Opera
	}
	return nil
}

func (m *GlobalSpecType) GetStaticRoutes() []string {
	if m != nil {
		return m.StaticRoutes
	}
	return nil
}

func (m *GlobalSpecType) GetK8SApiServers() map[string]*K8SApiServerParameters {
	if m != nil {
		return m.K8SApiServers
	}
	return nil
}

func (m *GlobalSpecType) GetPublicIp() string {
	if m != nil {
		return m.PublicIp
	}
	return ""
}

func (m *GlobalSpecType) GetPrivateIp() string {
	if m != nil {
		return m.PrivateIp
	}
	return ""
}

func (m *GlobalSpecType) GetIpsecSslVipFqdn() string {
	if m != nil {
		return m.IpsecSslVipFqdn
	}
	return ""
}

func (m *GlobalSpecType) GetClusterIp() string {
	if m != nil {
		return m.ClusterIp
	}
	return ""
}

func (m *GlobalSpecType) GetAresVtrpList() []*schema.ServiceParameters {
	if m != nil {
		return m.AresVtrpList
	}
	return nil
}

func (m *GlobalSpecType) GetVolterraSoftwareVersion() string {
	if m != nil {
		return m.VolterraSoftwareVersion
	}
	return ""
}

func (m *GlobalSpecType) GetInsideVip() string {
	if m != nil {
		return m.InsideVip
	}
	return ""
}

func (m *GlobalSpecType) GetOutsideVip() string {
	if m != nil {
		return m.OutsideVip
	}
	return ""
}

func (m *GlobalSpecType) GetVipParamsPerAz() []*PublishVIPParamsPerAz {
	if m != nil {
		return m.VipParamsPerAz
	}
	return nil
}

func (m *GlobalSpecType) GetVipVrrpMode() schema.VipVrrpType {
	if m != nil {
		return m.VipVrrpMode
	}
	return schema.VIP_VRRP_INVALID
}

func (m *GlobalSpecType) GetDefaultUnderlayNetwork() *DefaultUnderlayNetworkType {
	if m != nil {
		return m.DefaultUnderlayNetwork
	}
	return nil
}

func (m *GlobalSpecType) GetSiteToSiteNetworkType() schema.VirtualNetworkType {
	if m != nil {
		return m.SiteToSiteNetworkType
	}
	return schema.VIRTUAL_NETWORK_SITE_LOCAL
}

func (m *GlobalSpecType) GetSiteToSiteTunnelIp() string {
	if m != nil {
		return m.SiteToSiteTunnelIp
	}
	return ""
}

func (m *GlobalSpecType) GetVolterraSoftwareOveride() SiteSoftwareOverrideType {
	if m != nil {
		return m.VolterraSoftwareOveride
	}
	return SITE_SOFTWARE_OVERRIDE_SITE
}

func (m *GlobalSpecType) GetBgpRouterId() string {
	if m != nil {
		return m.BgpRouterId
	}
	return ""
}

func (m *GlobalSpecType) GetBgpPeerAddress() string {
	if m != nil {
		return m.BgpPeerAddress
	}
	return ""
}

func (m *GlobalSpecType) GetTemplateParameters() map[string]string {
	if m != nil {
		return m.TemplateParameters
	}
	return nil
}

func (m *GlobalSpecType) GetInsideNameserver() string {
	if m != nil {
		return m.InsideNameserver
	}
	return ""
}

func (m *GlobalSpecType) GetOutsideNameserver() string {
	if m != nil {
		return m.OutsideNameserver
	}
	return ""
}

func (m *GlobalSpecType) GetDesiredPoolCount() int32 {
	if m != nil {
		return m.DesiredPoolCount
	}
	return 0
}

func (m *GlobalSpecType) GetTunnelType() schema.SiteToSiteTunnelType {
	if m != nil {
		return m.TunnelType
	}
	return schema.SITE_TO_SITE_TUNNEL_IPSEC_OR_SSL
}

func (m *GlobalSpecType) GetSiteState() SiteState {
	if m != nil {
		return m.SiteState
	}
	return ONLINE
}

func (m *GlobalSpecType) GetOperatingSystemVersion() string {
	if m != nil {
		return m.OperatingSystemVersion
	}
	return ""
}

func (m *GlobalSpecType) GetMarsList() []*schema.ServiceParameters {
	if m != nil {
		return m.MarsList
	}
	return nil
}

func (m *GlobalSpecType) GetMarsVtrpList() []*schema.ServiceParameters {
	if m != nil {
		return m.MarsVtrpList
	}
	return nil
}

func (m *GlobalSpecType) GetTunnelDeadTimeout() uint32 {
	if m != nil {
		return m.TunnelDeadTimeout
	}
	return 0
}

func (m *GlobalSpecType) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *GlobalSpecType) GetCeSiteMode() CeSiteMode {
	if m != nil {
		return m.CeSiteMode
	}
	return CE_SITE_MODE_INGRESS_EGRESS_GW
}

func (m *GlobalSpecType) GetNoTenantInVk8SNs() bool {
	if m != nil {
		return m.NoTenantInVk8SNs
	}
	return false
}

func (m *GlobalSpecType) GetLocalK8SAccessEnabled() bool {
	if m != nil {
		return m.LocalK8SAccessEnabled
	}
	return false
}

func (m *GlobalSpecType) GetK8SClusterApiGw() []*schema.ObjectRefType {
	if m != nil {
		return m.K8SClusterApiGw
	}
	return nil
}

func (m *GlobalSpecType) GetUsePrivateIp() bool {
	if m != nil {
		return m.UsePrivateIp
	}
	return false
}

func (m *GlobalSpecType) GetTenantIndex() uint32 {
	if m != nil {
		return m.TenantIndex
	}
	return 0
}

func (m *GlobalSpecType) GetPikuEnabled() bool {
	if m != nil {
		return m.PikuEnabled
	}
	return false
}

func (m *GlobalSpecType) GetPhobosEnabled() bool {
	if m != nil {
		return m.PhobosEnabled
	}
	return false
}

func (m *GlobalSpecType) GetSrv6Enabled() bool {
	if m != nil {
		return m.Srv6Enabled
	}
	return false
}

// Create Site
//
// x-displayName: "Create Site"
// Sites are created automatically once user approves addition of sites in the system.
type CreateSpecType struct {
	SiteType                SiteType                    `protobuf:"varint,1,opt,name=site_type,json=siteType,proto3,enum=ves.io.schema.site.SiteType" json:"site_type,omitempty"`
	Address                 string                      `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	Coordinates             *Coordinates                `protobuf:"bytes,3,opt,name=coordinates,proto3" json:"coordinates,omitempty"`
	InsideVip               string                      `protobuf:"bytes,114,opt,name=inside_vip,json=insideVip,proto3" json:"inside_vip,omitempty"`
	OutsideVip              string                      `protobuf:"bytes,120,opt,name=outside_vip,json=outsideVip,proto3" json:"outside_vip,omitempty"`
	VipVrrpMode             schema.VipVrrpType          `protobuf:"varint,121,opt,name=vip_vrrp_mode,json=vipVrrpMode,proto3,enum=ves.io.schema.VipVrrpType" json:"vip_vrrp_mode,omitempty"`
	SiteToSiteNetworkType   schema.VirtualNetworkType   `protobuf:"varint,122,opt,name=site_to_site_network_type,json=siteToSiteNetworkType,proto3,enum=ves.io.schema.VirtualNetworkType" json:"site_to_site_network_type,omitempty"`
	SiteToSiteTunnelIp      string                      `protobuf:"bytes,115,opt,name=site_to_site_tunnel_ip,json=siteToSiteTunnelIp,proto3" json:"site_to_site_tunnel_ip,omitempty"`
	VolterraSoftwareOveride SiteSoftwareOverrideType    `protobuf:"varint,116,opt,name=volterra_software_overide,json=volterraSoftwareOveride,proto3,enum=ves.io.schema.site.SiteSoftwareOverrideType" json:"volterra_software_overide,omitempty"`
	BgpRouterId             string                      `protobuf:"bytes,117,opt,name=bgp_router_id,json=bgpRouterId,proto3" json:"bgp_router_id,omitempty"`
	BgpPeerAddress          string                      `protobuf:"bytes,118,opt,name=bgp_peer_address,json=bgpPeerAddress,proto3" json:"bgp_peer_address,omitempty"`
	InsideNameserver        string                      `protobuf:"bytes,123,opt,name=inside_nameserver,json=insideNameserver,proto3" json:"inside_nameserver,omitempty"`
	OutsideNameserver       string                      `protobuf:"bytes,124,opt,name=outside_nameserver,json=outsideNameserver,proto3" json:"outside_nameserver,omitempty"`
	DesiredPoolCount        int32                       `protobuf:"varint,125,opt,name=desired_pool_count,json=desiredPoolCount,proto3" json:"desired_pool_count,omitempty"`
	TunnelType              schema.SiteToSiteTunnelType `protobuf:"varint,126,opt,name=tunnel_type,json=tunnelType,proto3,enum=ves.io.schema.SiteToSiteTunnelType" json:"tunnel_type,omitempty"`
	OperatingSystemVersion  string                      `protobuf:"bytes,127,opt,name=operating_system_version,json=operatingSystemVersion,proto3" json:"operating_system_version,omitempty"`
	TunnelDeadTimeout       uint32                      `protobuf:"varint,129,opt,name=tunnel_dead_timeout,json=tunnelDeadTimeout,proto3" json:"tunnel_dead_timeout,omitempty"`
	Region                  string                      `protobuf:"bytes,132,opt,name=region,proto3" json:"region,omitempty"`
	CeSiteMode              CeSiteMode                  `protobuf:"varint,134,opt,name=ce_site_mode,json=ceSiteMode,proto3,enum=ves.io.schema.site.CeSiteMode" json:"ce_site_mode,omitempty"`
	DefaultUnderlayNetwork  *DefaultUnderlayNetworkType `protobuf:"bytes,141,opt,name=default_underlay_network,json=defaultUnderlayNetwork,proto3" json:"default_underlay_network,omitempty"`
}

func (m *CreateSpecType) Reset()      { *m = CreateSpecType{} }
func (*CreateSpecType) ProtoMessage() {}
func (*CreateSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{6}
}
func (m *CreateSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSpecType.Merge(m, src)
}
func (m *CreateSpecType) XXX_Size() int {
	return m.Size()
}
func (m *CreateSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSpecType proto.InternalMessageInfo

func (m *CreateSpecType) GetSiteType() SiteType {
	if m != nil {
		return m.SiteType
	}
	return INVALID
}

func (m *CreateSpecType) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *CreateSpecType) GetCoordinates() *Coordinates {
	if m != nil {
		return m.Coordinates
	}
	return nil
}

func (m *CreateSpecType) GetInsideVip() string {
	if m != nil {
		return m.InsideVip
	}
	return ""
}

func (m *CreateSpecType) GetOutsideVip() string {
	if m != nil {
		return m.OutsideVip
	}
	return ""
}

func (m *CreateSpecType) GetVipVrrpMode() schema.VipVrrpType {
	if m != nil {
		return m.VipVrrpMode
	}
	return schema.VIP_VRRP_INVALID
}

func (m *CreateSpecType) GetSiteToSiteNetworkType() schema.VirtualNetworkType {
	if m != nil {
		return m.SiteToSiteNetworkType
	}
	return schema.VIRTUAL_NETWORK_SITE_LOCAL
}

func (m *CreateSpecType) GetSiteToSiteTunnelIp() string {
	if m != nil {
		return m.SiteToSiteTunnelIp
	}
	return ""
}

func (m *CreateSpecType) GetVolterraSoftwareOveride() SiteSoftwareOverrideType {
	if m != nil {
		return m.VolterraSoftwareOveride
	}
	return SITE_SOFTWARE_OVERRIDE_SITE
}

func (m *CreateSpecType) GetBgpRouterId() string {
	if m != nil {
		return m.BgpRouterId
	}
	return ""
}

func (m *CreateSpecType) GetBgpPeerAddress() string {
	if m != nil {
		return m.BgpPeerAddress
	}
	return ""
}

func (m *CreateSpecType) GetInsideNameserver() string {
	if m != nil {
		return m.InsideNameserver
	}
	return ""
}

func (m *CreateSpecType) GetOutsideNameserver() string {
	if m != nil {
		return m.OutsideNameserver
	}
	return ""
}

func (m *CreateSpecType) GetDesiredPoolCount() int32 {
	if m != nil {
		return m.DesiredPoolCount
	}
	return 0
}

func (m *CreateSpecType) GetTunnelType() schema.SiteToSiteTunnelType {
	if m != nil {
		return m.TunnelType
	}
	return schema.SITE_TO_SITE_TUNNEL_IPSEC_OR_SSL
}

func (m *CreateSpecType) GetOperatingSystemVersion() string {
	if m != nil {
		return m.OperatingSystemVersion
	}
	return ""
}

func (m *CreateSpecType) GetTunnelDeadTimeout() uint32 {
	if m != nil {
		return m.TunnelDeadTimeout
	}
	return 0
}

func (m *CreateSpecType) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *CreateSpecType) GetCeSiteMode() CeSiteMode {
	if m != nil {
		return m.CeSiteMode
	}
	return CE_SITE_MODE_INGRESS_EGRESS_GW
}

func (m *CreateSpecType) GetDefaultUnderlayNetwork() *DefaultUnderlayNetworkType {
	if m != nil {
		return m.DefaultUnderlayNetwork
	}
	return nil
}

// Replace Site
//
// x-displayName: "Replace Site"
// Replace Site will replace address, coordinates of site
type ReplaceSpecType struct {
	Address                 string                      `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	Coordinates             *Coordinates                `protobuf:"bytes,3,opt,name=coordinates,proto3" json:"coordinates,omitempty"`
	VolterraSoftwareVersion string                      `protobuf:"bytes,4,opt,name=volterra_software_version,json=volterraSoftwareVersion,proto3" json:"volterra_software_version,omitempty"`
	InsideVip               string                      `protobuf:"bytes,114,opt,name=inside_vip,json=insideVip,proto3" json:"inside_vip,omitempty"`
	OutsideVip              string                      `protobuf:"bytes,120,opt,name=outside_vip,json=outsideVip,proto3" json:"outside_vip,omitempty"`
	VipVrrpMode             schema.VipVrrpType          `protobuf:"varint,121,opt,name=vip_vrrp_mode,json=vipVrrpMode,proto3,enum=ves.io.schema.VipVrrpType" json:"vip_vrrp_mode,omitempty"`
	SiteToSiteNetworkType   schema.VirtualNetworkType   `protobuf:"varint,122,opt,name=site_to_site_network_type,json=siteToSiteNetworkType,proto3,enum=ves.io.schema.VirtualNetworkType" json:"site_to_site_network_type,omitempty"`
	SiteToSiteTunnelIp      string                      `protobuf:"bytes,115,opt,name=site_to_site_tunnel_ip,json=siteToSiteTunnelIp,proto3" json:"site_to_site_tunnel_ip,omitempty"`
	VolterraSoftwareOveride SiteSoftwareOverrideType    `protobuf:"varint,116,opt,name=volterra_software_overide,json=volterraSoftwareOveride,proto3,enum=ves.io.schema.site.SiteSoftwareOverrideType" json:"volterra_software_overide,omitempty"`
	BgpRouterId             string                      `protobuf:"bytes,117,opt,name=bgp_router_id,json=bgpRouterId,proto3" json:"bgp_router_id,omitempty"`
	BgpPeerAddress          string                      `protobuf:"bytes,118,opt,name=bgp_peer_address,json=bgpPeerAddress,proto3" json:"bgp_peer_address,omitempty"`
	InsideNameserver        string                      `protobuf:"bytes,123,opt,name=inside_nameserver,json=insideNameserver,proto3" json:"inside_nameserver,omitempty"`
	OutsideNameserver       string                      `protobuf:"bytes,124,opt,name=outside_nameserver,json=outsideNameserver,proto3" json:"outside_nameserver,omitempty"`
	DesiredPoolCount        int32                       `protobuf:"varint,125,opt,name=desired_pool_count,json=desiredPoolCount,proto3" json:"desired_pool_count,omitempty"`
	TunnelType              schema.SiteToSiteTunnelType `protobuf:"varint,126,opt,name=tunnel_type,json=tunnelType,proto3,enum=ves.io.schema.SiteToSiteTunnelType" json:"tunnel_type,omitempty"`
	OperatingSystemVersion  string                      `protobuf:"bytes,127,opt,name=operating_system_version,json=operatingSystemVersion,proto3" json:"operating_system_version,omitempty"`
	TunnelDeadTimeout       uint32                      `protobuf:"varint,129,opt,name=tunnel_dead_timeout,json=tunnelDeadTimeout,proto3" json:"tunnel_dead_timeout,omitempty"`
	Region                  string                      `protobuf:"bytes,132,opt,name=region,proto3" json:"region,omitempty"`
	DefaultUnderlayNetwork  *DefaultUnderlayNetworkType `protobuf:"bytes,141,opt,name=default_underlay_network,json=defaultUnderlayNetwork,proto3" json:"default_underlay_network,omitempty"`
}

func (m *ReplaceSpecType) Reset()      { *m = ReplaceSpecType{} }
func (*ReplaceSpecType) ProtoMessage() {}
func (*ReplaceSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{7}
}
func (m *ReplaceSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ReplaceSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceSpecType.Merge(m, src)
}
func (m *ReplaceSpecType) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceSpecType proto.InternalMessageInfo

func (m *ReplaceSpecType) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ReplaceSpecType) GetCoordinates() *Coordinates {
	if m != nil {
		return m.Coordinates
	}
	return nil
}

func (m *ReplaceSpecType) GetVolterraSoftwareVersion() string {
	if m != nil {
		return m.VolterraSoftwareVersion
	}
	return ""
}

func (m *ReplaceSpecType) GetInsideVip() string {
	if m != nil {
		return m.InsideVip
	}
	return ""
}

func (m *ReplaceSpecType) GetOutsideVip() string {
	if m != nil {
		return m.OutsideVip
	}
	return ""
}

func (m *ReplaceSpecType) GetVipVrrpMode() schema.VipVrrpType {
	if m != nil {
		return m.VipVrrpMode
	}
	return schema.VIP_VRRP_INVALID
}

func (m *ReplaceSpecType) GetSiteToSiteNetworkType() schema.VirtualNetworkType {
	if m != nil {
		return m.SiteToSiteNetworkType
	}
	return schema.VIRTUAL_NETWORK_SITE_LOCAL
}

func (m *ReplaceSpecType) GetSiteToSiteTunnelIp() string {
	if m != nil {
		return m.SiteToSiteTunnelIp
	}
	return ""
}

func (m *ReplaceSpecType) GetVolterraSoftwareOveride() SiteSoftwareOverrideType {
	if m != nil {
		return m.VolterraSoftwareOveride
	}
	return SITE_SOFTWARE_OVERRIDE_SITE
}

func (m *ReplaceSpecType) GetBgpRouterId() string {
	if m != nil {
		return m.BgpRouterId
	}
	return ""
}

func (m *ReplaceSpecType) GetBgpPeerAddress() string {
	if m != nil {
		return m.BgpPeerAddress
	}
	return ""
}

func (m *ReplaceSpecType) GetInsideNameserver() string {
	if m != nil {
		return m.InsideNameserver
	}
	return ""
}

func (m *ReplaceSpecType) GetOutsideNameserver() string {
	if m != nil {
		return m.OutsideNameserver
	}
	return ""
}

func (m *ReplaceSpecType) GetDesiredPoolCount() int32 {
	if m != nil {
		return m.DesiredPoolCount
	}
	return 0
}

func (m *ReplaceSpecType) GetTunnelType() schema.SiteToSiteTunnelType {
	if m != nil {
		return m.TunnelType
	}
	return schema.SITE_TO_SITE_TUNNEL_IPSEC_OR_SSL
}

func (m *ReplaceSpecType) GetOperatingSystemVersion() string {
	if m != nil {
		return m.OperatingSystemVersion
	}
	return ""
}

func (m *ReplaceSpecType) GetTunnelDeadTimeout() uint32 {
	if m != nil {
		return m.TunnelDeadTimeout
	}
	return 0
}

func (m *ReplaceSpecType) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *ReplaceSpecType) GetDefaultUnderlayNetwork() *DefaultUnderlayNetworkType {
	if m != nil {
		return m.DefaultUnderlayNetwork
	}
	return nil
}

// Get Site
//
// x-displayName: "Get Site"
// Get of site
type GetSpecType struct {
	SiteType                SiteType                    `protobuf:"varint,1,opt,name=site_type,json=siteType,proto3,enum=ves.io.schema.site.SiteType" json:"site_type,omitempty"`
	Address                 string                      `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	Coordinates             *Coordinates                `protobuf:"bytes,3,opt,name=coordinates,proto3" json:"coordinates,omitempty"`
	VolterraSoftwareVersion string                      `protobuf:"bytes,4,opt,name=volterra_software_version,json=volterraSoftwareVersion,proto3" json:"volterra_software_version,omitempty"`
	ConnectedRe             []*schema.ObjectRefType     `protobuf:"bytes,103,rep,name=connected_re,json=connectedRe,proto3" json:"connected_re,omitempty"`
	ConnectedReForConfig    []*schema.ObjectRefType     `protobuf:"bytes,104,rep,name=connected_re_for_config,json=connectedReForConfig,proto3" json:"connected_re_for_config,omitempty"`
	InsideVip               string                      `protobuf:"bytes,114,opt,name=inside_vip,json=insideVip,proto3" json:"inside_vip,omitempty"`
	OutsideVip              string                      `protobuf:"bytes,120,opt,name=outside_vip,json=outsideVip,proto3" json:"outside_vip,omitempty"`
	VipParamsPerAz          []*PublishVIPParamsPerAz    `protobuf:"bytes,144,rep,name=vip_params_per_az,json=vipParamsPerAz,proto3" json:"vip_params_per_az,omitempty"`
	VipVrrpMode             schema.VipVrrpType          `protobuf:"varint,121,opt,name=vip_vrrp_mode,json=vipVrrpMode,proto3,enum=ves.io.schema.VipVrrpType" json:"vip_vrrp_mode,omitempty"`
	SiteToSiteNetworkType   schema.VirtualNetworkType   `protobuf:"varint,122,opt,name=site_to_site_network_type,json=siteToSiteNetworkType,proto3,enum=ves.io.schema.VirtualNetworkType" json:"site_to_site_network_type,omitempty"`
	SiteToSiteTunnelIp      string                      `protobuf:"bytes,115,opt,name=site_to_site_tunnel_ip,json=siteToSiteTunnelIp,proto3" json:"site_to_site_tunnel_ip,omitempty"`
	VolterraSoftwareOveride SiteSoftwareOverrideType    `protobuf:"varint,116,opt,name=volterra_software_overide,json=volterraSoftwareOveride,proto3,enum=ves.io.schema.site.SiteSoftwareOverrideType" json:"volterra_software_overide,omitempty"`
	BgpRouterId             string                      `protobuf:"bytes,117,opt,name=bgp_router_id,json=bgpRouterId,proto3" json:"bgp_router_id,omitempty"`
	BgpPeerAddress          string                      `protobuf:"bytes,118,opt,name=bgp_peer_address,json=bgpPeerAddress,proto3" json:"bgp_peer_address,omitempty"`
	InsideNameserver        string                      `protobuf:"bytes,123,opt,name=inside_nameserver,json=insideNameserver,proto3" json:"inside_nameserver,omitempty"`
	OutsideNameserver       string                      `protobuf:"bytes,124,opt,name=outside_nameserver,json=outsideNameserver,proto3" json:"outside_nameserver,omitempty"`
	DesiredPoolCount        int32                       `protobuf:"varint,125,opt,name=desired_pool_count,json=desiredPoolCount,proto3" json:"desired_pool_count,omitempty"`
	TunnelType              schema.SiteToSiteTunnelType `protobuf:"varint,126,opt,name=tunnel_type,json=tunnelType,proto3,enum=ves.io.schema.SiteToSiteTunnelType" json:"tunnel_type,omitempty"`
	OperatingSystemVersion  string                      `protobuf:"bytes,127,opt,name=operating_system_version,json=operatingSystemVersion,proto3" json:"operating_system_version,omitempty"`
	SiteState               SiteState                   `protobuf:"varint,128,opt,name=site_state,json=siteState,proto3,enum=ves.io.schema.site.SiteState" json:"site_state,omitempty"`
	TunnelDeadTimeout       uint32                      `protobuf:"varint,129,opt,name=tunnel_dead_timeout,json=tunnelDeadTimeout,proto3" json:"tunnel_dead_timeout,omitempty"`
	Region                  string                      `protobuf:"bytes,132,opt,name=region,proto3" json:"region,omitempty"`
	CeSiteMode              CeSiteMode                  `protobuf:"varint,134,opt,name=ce_site_mode,json=ceSiteMode,proto3,enum=ves.io.schema.site.CeSiteMode" json:"ce_site_mode,omitempty"`
	LocalK8SAccessEnabled   bool                        `protobuf:"varint,136,opt,name=local_k8s_access_enabled,json=localK8sAccessEnabled,proto3" json:"local_k8s_access_enabled,omitempty"`
	DefaultUnderlayNetwork  *DefaultUnderlayNetworkType `protobuf:"bytes,141,opt,name=default_underlay_network,json=defaultUnderlayNetwork,proto3" json:"default_underlay_network,omitempty"`
	LocalAccessK8SEnabled   bool                        `protobuf:"varint,142,opt,name=local_access_k8s_enabled,json=localAccessK8sEnabled,proto3" json:"local_access_k8s_enabled,omitempty"`
	GlobalAccessK8SEnabled  bool                        `protobuf:"varint,143,opt,name=global_access_k8s_enabled,json=globalAccessK8sEnabled,proto3" json:"global_access_k8s_enabled,omitempty"`
}

func (m *GetSpecType) Reset()      { *m = GetSpecType{} }
func (*GetSpecType) ProtoMessage() {}
func (*GetSpecType) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{8}
}
func (m *GetSpecType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpecType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GetSpecType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpecType.Merge(m, src)
}
func (m *GetSpecType) XXX_Size() int {
	return m.Size()
}
func (m *GetSpecType) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpecType.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpecType proto.InternalMessageInfo

func (m *GetSpecType) GetSiteType() SiteType {
	if m != nil {
		return m.SiteType
	}
	return INVALID
}

func (m *GetSpecType) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *GetSpecType) GetCoordinates() *Coordinates {
	if m != nil {
		return m.Coordinates
	}
	return nil
}

func (m *GetSpecType) GetVolterraSoftwareVersion() string {
	if m != nil {
		return m.VolterraSoftwareVersion
	}
	return ""
}

func (m *GetSpecType) GetConnectedRe() []*schema.ObjectRefType {
	if m != nil {
		return m.ConnectedRe
	}
	return nil
}

func (m *GetSpecType) GetConnectedReForConfig() []*schema.ObjectRefType {
	if m != nil {
		return m.ConnectedReForConfig
	}
	return nil
}

func (m *GetSpecType) GetInsideVip() string {
	if m != nil {
		return m.InsideVip
	}
	return ""
}

func (m *GetSpecType) GetOutsideVip() string {
	if m != nil {
		return m.OutsideVip
	}
	return ""
}

func (m *GetSpecType) GetVipParamsPerAz() []*PublishVIPParamsPerAz {
	if m != nil {
		return m.VipParamsPerAz
	}
	return nil
}

func (m *GetSpecType) GetVipVrrpMode() schema.VipVrrpType {
	if m != nil {
		return m.VipVrrpMode
	}
	return schema.VIP_VRRP_INVALID
}

func (m *GetSpecType) GetSiteToSiteNetworkType() schema.VirtualNetworkType {
	if m != nil {
		return m.SiteToSiteNetworkType
	}
	return schema.VIRTUAL_NETWORK_SITE_LOCAL
}

func (m *GetSpecType) GetSiteToSiteTunnelIp() string {
	if m != nil {
		return m.SiteToSiteTunnelIp
	}
	return ""
}

func (m *GetSpecType) GetVolterraSoftwareOveride() SiteSoftwareOverrideType {
	if m != nil {
		return m.VolterraSoftwareOveride
	}
	return SITE_SOFTWARE_OVERRIDE_SITE
}

func (m *GetSpecType) GetBgpRouterId() string {
	if m != nil {
		return m.BgpRouterId
	}
	return ""
}

func (m *GetSpecType) GetBgpPeerAddress() string {
	if m != nil {
		return m.BgpPeerAddress
	}
	return ""
}

func (m *GetSpecType) GetInsideNameserver() string {
	if m != nil {
		return m.InsideNameserver
	}
	return ""
}

func (m *GetSpecType) GetOutsideNameserver() string {
	if m != nil {
		return m.OutsideNameserver
	}
	return ""
}

func (m *GetSpecType) GetDesiredPoolCount() int32 {
	if m != nil {
		return m.DesiredPoolCount
	}
	return 0
}

func (m *GetSpecType) GetTunnelType() schema.SiteToSiteTunnelType {
	if m != nil {
		return m.TunnelType
	}
	return schema.SITE_TO_SITE_TUNNEL_IPSEC_OR_SSL
}

func (m *GetSpecType) GetOperatingSystemVersion() string {
	if m != nil {
		return m.OperatingSystemVersion
	}
	return ""
}

func (m *GetSpecType) GetSiteState() SiteState {
	if m != nil {
		return m.SiteState
	}
	return ONLINE
}

func (m *GetSpecType) GetTunnelDeadTimeout() uint32 {
	if m != nil {
		return m.TunnelDeadTimeout
	}
	return 0
}

func (m *GetSpecType) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *GetSpecType) GetCeSiteMode() CeSiteMode {
	if m != nil {
		return m.CeSiteMode
	}
	return CE_SITE_MODE_INGRESS_EGRESS_GW
}

func (m *GetSpecType) GetLocalK8SAccessEnabled() bool {
	if m != nil {
		return m.LocalK8SAccessEnabled
	}
	return false
}

func (m *GetSpecType) GetDefaultUnderlayNetwork() *DefaultUnderlayNetworkType {
	if m != nil {
		return m.DefaultUnderlayNetwork
	}
	return nil
}

func (m *GetSpecType) GetLocalAccessK8SEnabled() bool {
	if m != nil {
		return m.LocalAccessK8SEnabled
	}
	return false
}

func (m *GetSpecType) GetGlobalAccessK8SEnabled() bool {
	if m != nil {
		return m.GlobalAccessK8SEnabled
	}
	return false
}

// VerStatus
//
// x-displayName: "Ver Status"
// Ver details in the site that has generated the site status object
type VerStatusType struct {
	// ver_instance_name
	//
	// x-displayName: "VER Instance"
	// name of the ver instance that created this site status
	VerInstanceName string `protobuf:"bytes,1,opt,name=ver_instance_name,json=verInstanceName,proto3" json:"ver_instance_name,omitempty"`
	// ipsec_status
	//
	// x-displayName: "IPSec Status"
	// Status/details of every ipsec connection this Ver is terminating/originating
	IpsecStatus []*IpsecConnectionStatus `protobuf:"bytes,2,rep,name=ipsec_status,json=ipsecStatus,proto3" json:"ipsec_status,omitempty"`
	// ares_status
	//
	// x-displayName: "Ares Status"
	// Status of every Ares connections this Ver is connecting to for routes
	AresStatus []*AresConnectionStatus `protobuf:"bytes,3,rep,name=ares_status,json=aresStatus,proto3" json:"ares_status,omitempty"`
	// interface_status
	//
	// x-displayName: "Interface Status"
	// Status of every inside or outside interface present in this VER
	IntfStatus []*InterfaceStatus `protobuf:"bytes,4,rep,name=intf_status,json=intfStatus,proto3" json:"intf_status,omitempty"`
	// configured_tunnel_connection_status
	//
	// x-displayName: "Configured Tunnel Connection Status"
	// Status/details of every configured connection this Ver is originating
	ConfiguredTunnelStatus []*TunnelConnectionStatus `protobuf:"bytes,5,rep,name=configured_tunnel_status,json=configuredTunnelStatus,proto3" json:"configured_tunnel_status,omitempty"`
	// site_tunnel_status
	//
	// x-displayName: "Site Tunnel Status"
	// Status/details of every site connection this Ver is originating/ terminating
	SiteTunnelStatus []*TunnelConnectionStatus `protobuf:"bytes,6,rep,name=site_tunnel_status,json=siteTunnelStatus,proto3" json:"site_tunnel_status,omitempty"`
}

func (m *VerStatusType) Reset()      { *m = VerStatusType{} }
func (*VerStatusType) ProtoMessage() {}
func (*VerStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{9}
}
func (m *VerStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VerStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerStatusType.Merge(m, src)
}
func (m *VerStatusType) XXX_Size() int {
	return m.Size()
}
func (m *VerStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_VerStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_VerStatusType proto.InternalMessageInfo

func (m *VerStatusType) GetVerInstanceName() string {
	if m != nil {
		return m.VerInstanceName
	}
	return ""
}

func (m *VerStatusType) GetIpsecStatus() []*IpsecConnectionStatus {
	if m != nil {
		return m.IpsecStatus
	}
	return nil
}

func (m *VerStatusType) GetAresStatus() []*AresConnectionStatus {
	if m != nil {
		return m.AresStatus
	}
	return nil
}

func (m *VerStatusType) GetIntfStatus() []*InterfaceStatus {
	if m != nil {
		return m.IntfStatus
	}
	return nil
}

func (m *VerStatusType) GetConfiguredTunnelStatus() []*TunnelConnectionStatus {
	if m != nil {
		return m.ConfiguredTunnelStatus
	}
	return nil
}

func (m *VerStatusType) GetSiteTunnelStatus() []*TunnelConnectionStatus {
	if m != nil {
		return m.SiteTunnelStatus
	}
	return nil
}

// VerMasterStatus
//
// x-displayName: "Ver Master Status"
// Info of the Master Ver of the site
type VerMasterStatusType struct {
	// Master Ver Node Name
	//
	// x-displayName: "Master Ver Node Name"
	// Instance name of Master VER in the Cluster
	VerName string `protobuf:"bytes,1,opt,name=ver_name,json=verName,proto3" json:"ver_name,omitempty"`
	// Master Ver UID
	//
	// x-displayName: "Master Ver UID"
	// UID of Master VER in the Cluster
	Ver_UID string `protobuf:"bytes,2,opt,name=ver_UID,json=verUID,proto3" json:"ver_UID,omitempty"`
	// Mastership Transition TimeStamp
	//
	// x-displayName: "Mastership Transition TimeStamp"
	// Timestamp at which the VER became cluster master
	TransitionTimestamp *types.Timestamp `protobuf:"bytes,3,opt,name=transition_timestamp,json=transitionTimestamp,proto3" json:"transition_timestamp,omitempty"`
}

func (m *VerMasterStatusType) Reset()      { *m = VerMasterStatusType{} }
func (*VerMasterStatusType) ProtoMessage() {}
func (*VerMasterStatusType) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{10}
}
func (m *VerMasterStatusType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerMasterStatusType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VerMasterStatusType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerMasterStatusType.Merge(m, src)
}
func (m *VerMasterStatusType) XXX_Size() int {
	return m.Size()
}
func (m *VerMasterStatusType) XXX_DiscardUnknown() {
	xxx_messageInfo_VerMasterStatusType.DiscardUnknown(m)
}

var xxx_messageInfo_VerMasterStatusType proto.InternalMessageInfo

func (m *VerMasterStatusType) GetVerName() string {
	if m != nil {
		return m.VerName
	}
	return ""
}

func (m *VerMasterStatusType) GetVer_UID() string {
	if m != nil {
		return m.Ver_UID
	}
	return ""
}

func (m *VerMasterStatusType) GetTransitionTimestamp() *types.Timestamp {
	if m != nil {
		return m.TransitionTimestamp
	}
	return nil
}

// IPSecConnection Status
//
// x-displayName: "IPSec Connection Status"
// Status of IPSec connection that a Ver has originated / terminated
type IpsecConnectionStatus struct {
	// url
	//
	// x-displayName: "URL"
	// url identifies the other end of the Ver for IPSec tunnel origination/termination
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// state
	//
	// x-displayName: "Connection State"
	// connection state which identifies whether an IPSec connection is UP/DOWN
	State IPSecState `protobuf:"varint,2,opt,name=state,proto3,enum=ves.io.schema.site.IPSecState" json:"state,omitempty"`
	// role
	//
	// x-displayName: "Role"
	// indicates whether the ver is client/Originator or server/responder in ipsec tunnel
	Role IPSecRole `protobuf:"varint,3,opt,name=role,proto3,enum=ves.io.schema.site.IPSecRole" json:"role,omitempty"`
	// remoteAddress
	//
	// x-displayName: "Remote Address"
	// IP address of the remote end
	RemoteAddress string `protobuf:"bytes,4,opt,name=remoteAddress,proto3" json:"remoteAddress,omitempty"`
	// isLocal
	//
	// x-displayName: "Local"
	// Identifies if the ipsec connection is local to the ver node or not
	IsLocal bool `protobuf:"varint,5,opt,name=isLocal,proto3" json:"isLocal,omitempty"`
	// verNodeName
	//
	// x-displayName: "VER Node Name"
	// The VER node in the local site from which the connection is setup
	VerNodeName string `protobuf:"bytes,6,opt,name=verNodeName,proto3" json:"verNodeName,omitempty"`
}

func (m *IpsecConnectionStatus) Reset()      { *m = IpsecConnectionStatus{} }
func (*IpsecConnectionStatus) ProtoMessage() {}
func (*IpsecConnectionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{11}
}
func (m *IpsecConnectionStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpsecConnectionStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *IpsecConnectionStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpsecConnectionStatus.Merge(m, src)
}
func (m *IpsecConnectionStatus) XXX_Size() int {
	return m.Size()
}
func (m *IpsecConnectionStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_IpsecConnectionStatus.DiscardUnknown(m)
}

var xxx_messageInfo_IpsecConnectionStatus proto.InternalMessageInfo

func (m *IpsecConnectionStatus) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *IpsecConnectionStatus) GetState() IPSecState {
	if m != nil {
		return m.State
	}
	return UNKNOWN_STATE
}

func (m *IpsecConnectionStatus) GetRole() IPSecRole {
	if m != nil {
		return m.Role
	}
	return UNKNOWN_ROLE
}

func (m *IpsecConnectionStatus) GetRemoteAddress() string {
	if m != nil {
		return m.RemoteAddress
	}
	return ""
}

func (m *IpsecConnectionStatus) GetIsLocal() bool {
	if m != nil {
		return m.IsLocal
	}
	return false
}

func (m *IpsecConnectionStatus) GetVerNodeName() string {
	if m != nil {
		return m.VerNodeName
	}
	return ""
}

// Ares Connection Status
//
// x-displayName: "Ares Connection Status"
// Status of Ares Connection
type AresConnectionStatus struct {
	// url
	//
	// x-displayName: "URL"
	// url identifies the Ares server
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// state
	//
	// x-displayName: "State"
	// status of the connection to the server
	State VTRPState `protobuf:"varint,2,opt,name=state,proto3,enum=ves.io.schema.site.VTRPState" json:"state,omitempty"`
}

func (m *AresConnectionStatus) Reset()      { *m = AresConnectionStatus{} }
func (*AresConnectionStatus) ProtoMessage() {}
func (*AresConnectionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{12}
}
func (m *AresConnectionStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AresConnectionStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *AresConnectionStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AresConnectionStatus.Merge(m, src)
}
func (m *AresConnectionStatus) XXX_Size() int {
	return m.Size()
}
func (m *AresConnectionStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_AresConnectionStatus.DiscardUnknown(m)
}

var xxx_messageInfo_AresConnectionStatus proto.InternalMessageInfo

func (m *AresConnectionStatus) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *AresConnectionStatus) GetState() VTRPState {
	if m != nil {
		return m.State
	}
	return INIT
}

// Interface Status
//
// x-displayName: "Interface Status"
// Status of Interfaces in ver
type InterfaceStatus struct {
	// IP subnet
	//
	// x-displayName: "IP Subnet"
	// IP address of interface
	Ip *schema.IpSubnetType `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	// Mac Address
	//
	// x-displayName: "Mac Address"
	// Mac Address of interface
	Mac string `protobuf:"bytes,2,opt,name=mac,proto3" json:"mac,omitempty"`
	// Virtual Network Type
	//
	// x-displayName: "Virtual Network Type"
	// Virtual Network Type of interface
	NetworkType schema.VirtualNetworkType `protobuf:"varint,3,opt,name=network_type,json=networkType,proto3,enum=ves.io.schema.VirtualNetworkType" json:"network_type,omitempty"`
	// Name
	//
	// x-displayName: "Name"
	// Name of interface
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// IP Mode
	//
	// x-displayName: "IP Mode"
	// Mode of address assignment on the interface
	IpMode AddressMode `protobuf:"varint,5,opt,name=ip_mode,json=ipMode,proto3,enum=ves.io.schema.site.AddressMode" json:"ip_mode,omitempty"`
	// DHCP Server
	//
	// x-displayName: "DHCP Server"
	// Indicate if DHCP server is configured on the interface
	DhcpServer bool `protobuf:"varint,6,opt,name=dhcp_server,json=dhcpServer,proto3" json:"dhcp_server,omitempty"`
	// Virtual Network Name
	//
	// x-displayName: "Virtual Network Name"
	// Name of Virtual Network to which the interface belongs
	NetworkName string `protobuf:"bytes,8,opt,name=network_name,json=networkName,proto3" json:"network_name,omitempty"`
	// Link State
	// x-displayName: "Link State"
	// Link State for the interface
	LinkState bool `protobuf:"varint,9,opt,name=link_state,json=linkState,proto3" json:"link_state,omitempty"`
	// Active-Backup status
	// x-displayName: "Active/Backup status"
	// Active state for the interface
	ActiveState ActiveState `protobuf:"varint,10,opt,name=active_state,json=activeState,proto3,enum=ves.io.schema.site.ActiveState" json:"active_state,omitempty"`
	// Link quality status
	// x-displayName: "Link Quality"
	// Link quality for the interface
	LinkQuality LinkQuality `protobuf:"varint,11,opt,name=link_quality,json=linkQuality,proto3,enum=ves.io.schema.site.LinkQuality" json:"link_quality,omitempty"`
	// Link type
	// x-displayName: "Link type"
	// Link type for the interface
	LinkType LinkType `protobuf:"varint,12,opt,name=link_type,json=linkType,proto3,enum=ves.io.schema.site.LinkType" json:"link_type,omitempty"`
	// Bond Interface Members
	// x-displayName: "Bond Members"
	// Members of the Bond interface along with the corresponding link state
	BondMembers []*BondMembersType `protobuf:"bytes,13,rep,name=bond_members,json=bondMembers,proto3" json:"bond_members,omitempty"`
	// IPV6 subnet
	//
	// x-displayName: "IPV6 Subnet"
	// IPV6 address of interface
	Ipv6 *schema.IpSubnetType `protobuf:"bytes,14,opt,name=ipv6,proto3" json:"ipv6,omitempty"`
}

func (m *InterfaceStatus) Reset()      { *m = InterfaceStatus{} }
func (*InterfaceStatus) ProtoMessage() {}
func (*InterfaceStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{13}
}
func (m *InterfaceStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InterfaceStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *InterfaceStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InterfaceStatus.Merge(m, src)
}
func (m *InterfaceStatus) XXX_Size() int {
	return m.Size()
}
func (m *InterfaceStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_InterfaceStatus.DiscardUnknown(m)
}

var xxx_messageInfo_InterfaceStatus proto.InternalMessageInfo

func (m *InterfaceStatus) GetIp() *schema.IpSubnetType {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (m *InterfaceStatus) GetMac() string {
	if m != nil {
		return m.Mac
	}
	return ""
}

func (m *InterfaceStatus) GetNetworkType() schema.VirtualNetworkType {
	if m != nil {
		return m.NetworkType
	}
	return schema.VIRTUAL_NETWORK_SITE_LOCAL
}

func (m *InterfaceStatus) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *InterfaceStatus) GetIpMode() AddressMode {
	if m != nil {
		return m.IpMode
	}
	return STATIC
}

func (m *InterfaceStatus) GetDhcpServer() bool {
	if m != nil {
		return m.DhcpServer
	}
	return false
}

func (m *InterfaceStatus) GetNetworkName() string {
	if m != nil {
		return m.NetworkName
	}
	return ""
}

func (m *InterfaceStatus) GetLinkState() bool {
	if m != nil {
		return m.LinkState
	}
	return false
}

func (m *InterfaceStatus) GetActiveState() ActiveState {
	if m != nil {
		return m.ActiveState
	}
	return STATE_UNKNOWN
}

func (m *InterfaceStatus) GetLinkQuality() LinkQuality {
	if m != nil {
		return m.LinkQuality
	}
	return QUALITY_UNKNOWN
}

func (m *InterfaceStatus) GetLinkType() LinkType {
	if m != nil {
		return m.LinkType
	}
	return LINK_TYPE_UNKNOWN
}

func (m *InterfaceStatus) GetBondMembers() []*BondMembersType {
	if m != nil {
		return m.BondMembers
	}
	return nil
}

func (m *InterfaceStatus) GetIpv6() *schema.IpSubnetType {
	if m != nil {
		return m.Ipv6
	}
	return nil
}

// Tunnel Connection Status
//
// x-displayName: "Tunnel Connection Status"
// Status of tunnel connection that a Ver has originated / terminated
type TunnelConnectionStatus struct {
	// url
	//
	// x-displayName: "URL"
	// url identifies the other end of the Ver for tunnel origination/termination
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// state
	//
	// x-displayName: "Connection State"
	// connection state which identifies whether connection is UP/DOWN
	State TunnelState `protobuf:"varint,2,opt,name=state,proto3,enum=ves.io.schema.site.TunnelState" json:"state,omitempty"`
	// role
	//
	// x-displayName: "Role"
	// indicates whether the ver is client/Originator or server/responder in tunnel
	Role TunnelRole `protobuf:"varint,3,opt,name=role,proto3,enum=ves.io.schema.site.TunnelRole" json:"role,omitempty"`
	// remoteAddress
	//
	// x-displayName: "Remote Address"
	// IP address of the remote end
	RemoteAddress string `protobuf:"bytes,4,opt,name=remoteAddress,proto3" json:"remoteAddress,omitempty"`
	// encap
	//
	// x-displayName: "Encapsulation Type"
	// Encapsulation type of tunnel
	Encap schema.TunnelEncapsulationType `protobuf:"varint,5,opt,name=encap,proto3,enum=ves.io.schema.TunnelEncapsulationType" json:"encap,omitempty"`
	// isLocal
	//
	// x-displayName: "Local"
	// Identifies if the ipsec connection is local to the ver node or not
	IsLocal bool `protobuf:"varint,6,opt,name=isLocal,proto3" json:"isLocal,omitempty"`
	// verNodeName
	//
	// x-displayName: "VER Node Name"
	// The VER node in the local site from which the connection is setup
	VerNodeName string `protobuf:"bytes,7,opt,name=verNodeName,proto3" json:"verNodeName,omitempty"`
	// tunnelName
	//
	// x-displayName: "Tunnel Name"
	// Tunnel name
	TunnelName string `protobuf:"bytes,8,opt,name=tunnelName,proto3" json:"tunnelName,omitempty"`
}

func (m *TunnelConnectionStatus) Reset()      { *m = TunnelConnectionStatus{} }
func (*TunnelConnectionStatus) ProtoMessage() {}
func (*TunnelConnectionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{14}
}
func (m *TunnelConnectionStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunnelConnectionStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TunnelConnectionStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelConnectionStatus.Merge(m, src)
}
func (m *TunnelConnectionStatus) XXX_Size() int {
	return m.Size()
}
func (m *TunnelConnectionStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelConnectionStatus.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelConnectionStatus proto.InternalMessageInfo

func (m *TunnelConnectionStatus) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *TunnelConnectionStatus) GetState() TunnelState {
	if m != nil {
		return m.State
	}
	return UNKNOWN_TUNNEL_STATE
}

func (m *TunnelConnectionStatus) GetRole() TunnelRole {
	if m != nil {
		return m.Role
	}
	return UNKNOWN_TUNNEL_ROLE
}

func (m *TunnelConnectionStatus) GetRemoteAddress() string {
	if m != nil {
		return m.RemoteAddress
	}
	return ""
}

func (m *TunnelConnectionStatus) GetEncap() schema.TunnelEncapsulationType {
	if m != nil {
		return m.Encap
	}
	return schema.IPSEC_PKI
}

func (m *TunnelConnectionStatus) GetIsLocal() bool {
	if m != nil {
		return m.IsLocal
	}
	return false
}

func (m *TunnelConnectionStatus) GetVerNodeName() string {
	if m != nil {
		return m.VerNodeName
	}
	return ""
}

func (m *TunnelConnectionStatus) GetTunnelName() string {
	if m != nil {
		return m.TunnelName
	}
	return ""
}

// Volterra Software Status
//
// x-displayName: "Volterra Software Status"
// Volterra software version running in the site
type VolterraSoftwareStatus struct {
	// available_version
	//
	// x-displayName: "Available Version"
	// available version represent volterra software version ready to be upgraded in the site.
	AvailableVersion string `protobuf:"bytes,1,opt,name=available_version,json=availableVersion,proto3" json:"available_version,omitempty"`
	// deployment_state
	//
	// x-displayName: "Deployment State"
	// deployment state shows status of last applied deployment in the site
	DeploymentState *DeploymentState `protobuf:"bytes,2,opt,name=deployment_state,json=deploymentState,proto3" json:"deployment_state,omitempty"`
	// Nonconforming State
	//
	// x-displayName: "Nonconforming State"
	// If nonconforming state is not empty, then current deployed SW version is nonconforming. Site should be upgrade to available version.
	NonconformingState string `protobuf:"bytes,3,opt,name=nonconforming_state,json=nonconformingState,proto3" json:"nonconforming_state,omitempty"`
}

func (m *VolterraSoftwareStatus) Reset()      { *m = VolterraSoftwareStatus{} }
func (*VolterraSoftwareStatus) ProtoMessage() {}
func (*VolterraSoftwareStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{15}
}
func (m *VolterraSoftwareStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VolterraSoftwareStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *VolterraSoftwareStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolterraSoftwareStatus.Merge(m, src)
}
func (m *VolterraSoftwareStatus) XXX_Size() int {
	return m.Size()
}
func (m *VolterraSoftwareStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_VolterraSoftwareStatus.DiscardUnknown(m)
}

var xxx_messageInfo_VolterraSoftwareStatus proto.InternalMessageInfo

func (m *VolterraSoftwareStatus) GetAvailableVersion() string {
	if m != nil {
		return m.AvailableVersion
	}
	return ""
}

func (m *VolterraSoftwareStatus) GetDeploymentState() *DeploymentState {
	if m != nil {
		return m.DeploymentState
	}
	return nil
}

func (m *VolterraSoftwareStatus) GetNonconformingState() string {
	if m != nil {
		return m.NonconformingState
	}
	return ""
}

// Volterra Operating system Status
//
// x-displayName: "Volterra Operating System Status"
// Volterra operating system version running in the site
type OperatingSystemStatus struct {
	// available_version
	//
	// x-displayName: "Available Version"
	// available version represent volterra operating system version ready to be upgraded in the site.
	AvailableVersion string `protobuf:"bytes,1,opt,name=available_version,json=availableVersion,proto3" json:"available_version,omitempty"`
	// deployment_state
	//
	// x-displayName: "Deployment State"
	// deployment state shows status of last applied deployment in the site
	DeploymentState *DeploymentState `protobuf:"bytes,2,opt,name=deployment_state,json=deploymentState,proto3" json:"deployment_state,omitempty"`
	// Nonconforming State
	//
	// x-displayName: "Nonconforming State"
	// If nonconforming state is not empty, then current deployed OS version is nonconforming. Site should be upgrade to available version.
	NonconformingState string `protobuf:"bytes,3,opt,name=nonconforming_state,json=nonconformingState,proto3" json:"nonconforming_state,omitempty"`
}

func (m *OperatingSystemStatus) Reset()      { *m = OperatingSystemStatus{} }
func (*OperatingSystemStatus) ProtoMessage() {}
func (*OperatingSystemStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{16}
}
func (m *OperatingSystemStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperatingSystemStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OperatingSystemStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperatingSystemStatus.Merge(m, src)
}
func (m *OperatingSystemStatus) XXX_Size() int {
	return m.Size()
}
func (m *OperatingSystemStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_OperatingSystemStatus.DiscardUnknown(m)
}

var xxx_messageInfo_OperatingSystemStatus proto.InternalMessageInfo

func (m *OperatingSystemStatus) GetAvailableVersion() string {
	if m != nil {
		return m.AvailableVersion
	}
	return ""
}

func (m *OperatingSystemStatus) GetDeploymentState() *DeploymentState {
	if m != nil {
		return m.DeploymentState
	}
	return nil
}

func (m *OperatingSystemStatus) GetNonconformingState() string {
	if m != nil {
		return m.NonconformingState
	}
	return ""
}

// Deployment State
//
// x-displayName: "Deployment State"
// Details of Deployment
type DeploymentState struct {
	// version
	//
	// x-displayName: "Version"
	// Version name for this deployment state.
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// modification_timestamp
	//
	// x-displayName: "Modified At"
	// ModificationTimestamp is a timestamp representing the server time when deployment state was
	// last modified.
	ModificationTimestamp *types.Timestamp `protobuf:"bytes,2,opt,name=modification_timestamp,json=modificationTimestamp,proto3" json:"modification_timestamp,omitempty"`
	// result
	//
	// x-displayName: "Result"
	// Result of the deployment, one of Success, Failure, Unknown
	Result string `protobuf:"bytes,3,opt,name=result,proto3" json:"result,omitempty"`
	// message
	//
	// x-displayName: "Message"
	// A verbose human readable explanation of the reason
	Message string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	// Phase
	//
	// x-displayName: "Phase"
	// Phase of last deployment upgrade with options upgrade triggered, upgrade in-progress and upgrade completed
	Phase SoftwareUpgradePhase `protobuf:"varint,5,opt,name=phase,proto3,enum=ves.io.schema.site.SoftwareUpgradePhase" json:"phase,omitempty"`
}

func (m *DeploymentState) Reset()      { *m = DeploymentState{} }
func (*DeploymentState) ProtoMessage() {}
func (*DeploymentState) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{17}
}
func (m *DeploymentState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeploymentState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DeploymentState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeploymentState.Merge(m, src)
}
func (m *DeploymentState) XXX_Size() int {
	return m.Size()
}
func (m *DeploymentState) XXX_DiscardUnknown() {
	xxx_messageInfo_DeploymentState.DiscardUnknown(m)
}

var xxx_messageInfo_DeploymentState proto.InternalMessageInfo

func (m *DeploymentState) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *DeploymentState) GetModificationTimestamp() *types.Timestamp {
	if m != nil {
		return m.ModificationTimestamp
	}
	return nil
}

func (m *DeploymentState) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

func (m *DeploymentState) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *DeploymentState) GetPhase() SoftwareUpgradePhase {
	if m != nil {
		return m.Phase
	}
	return UPGRADE_INVALID
}

// Fleet Deployment State
//
// x-displayName: "Fleet Deployment State"
// Details of Fleet Deployment
type FleetDeploymentState struct {
	// hash
	//
	// x-displayName: "Fleet Hash"
	// Hash sum of fleet config.
	Hash string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// modification_timestamp
	//
	// x-displayName: "Modified At"
	// ModificationTimestamp is a timestamp representing the server time when deployment state was
	// last modified.
	ModificationTimestamp *types.Timestamp `protobuf:"bytes,2,opt,name=modification_timestamp,json=modificationTimestamp,proto3" json:"modification_timestamp,omitempty"`
	// result
	//
	// x-displayName: "Result"
	// Summarized result of the deployment, one of Success, Failure, Unknown
	Result string `protobuf:"bytes,3,opt,name=result,proto3" json:"result,omitempty"`
	// conditiom
	//
	// x-displayName: "Condition"
	// Map of fleet conditions
	Condition []*FleetCondition `protobuf:"bytes,4,rep,name=condition,proto3" json:"condition,omitempty"`
}

func (m *FleetDeploymentState) Reset()      { *m = FleetDeploymentState{} }
func (*FleetDeploymentState) ProtoMessage() {}
func (*FleetDeploymentState) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{18}
}
func (m *FleetDeploymentState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FleetDeploymentState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FleetDeploymentState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FleetDeploymentState.Merge(m, src)
}
func (m *FleetDeploymentState) XXX_Size() int {
	return m.Size()
}
func (m *FleetDeploymentState) XXX_DiscardUnknown() {
	xxx_messageInfo_FleetDeploymentState.DiscardUnknown(m)
}

var xxx_messageInfo_FleetDeploymentState proto.InternalMessageInfo

func (m *FleetDeploymentState) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *FleetDeploymentState) GetModificationTimestamp() *types.Timestamp {
	if m != nil {
		return m.ModificationTimestamp
	}
	return nil
}

func (m *FleetDeploymentState) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

func (m *FleetDeploymentState) GetCondition() []*FleetCondition {
	if m != nil {
		return m.Condition
	}
	return nil
}

type FleetCondition struct {
	// name
	//
	// x-displayName: "Name"
	// A name of condition
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// module_name
	//
	// x-displayName: "Module Name"
	// A name of module that produced the condition
	ModuleName string `protobuf:"bytes,2,opt,name=module_name,json=moduleName,proto3" json:"module_name,omitempty"`
	// message
	//
	// x-displayName: "Message"
	// A verbose human readable explanation of the reason
	Message string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	// result
	//
	// x-displayName: "Result"
	// Result of the condition
	Result string `protobuf:"bytes,4,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *FleetCondition) Reset()      { *m = FleetCondition{} }
func (*FleetCondition) ProtoMessage() {}
func (*FleetCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{19}
}
func (m *FleetCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FleetCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FleetCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FleetCondition.Merge(m, src)
}
func (m *FleetCondition) XXX_Size() int {
	return m.Size()
}
func (m *FleetCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_FleetCondition.DiscardUnknown(m)
}

var xxx_messageInfo_FleetCondition proto.InternalMessageInfo

func (m *FleetCondition) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FleetCondition) GetModuleName() string {
	if m != nil {
		return m.ModuleName
	}
	return ""
}

func (m *FleetCondition) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *FleetCondition) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

// Volterra Fleet Status
//
// x-displayName: "Volterra Fleet Status"
// Volterra fleet status on the node
type FleetStatus struct {
	// deployment_state
	//
	// x-displayName: "Fleet Deployment State"
	// deployment state shows status of last fleet version on the node
	DeploymentState *FleetDeploymentState `protobuf:"bytes,1,opt,name=deployment_state,json=deploymentState,proto3" json:"deployment_state,omitempty"`
}

func (m *FleetStatus) Reset()      { *m = FleetStatus{} }
func (*FleetStatus) ProtoMessage() {}
func (*FleetStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{20}
}
func (m *FleetStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FleetStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *FleetStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FleetStatus.Merge(m, src)
}
func (m *FleetStatus) XXX_Size() int {
	return m.Size()
}
func (m *FleetStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_FleetStatus.DiscardUnknown(m)
}

var xxx_messageInfo_FleetStatus proto.InternalMessageInfo

func (m *FleetStatus) GetDeploymentState() *FleetDeploymentState {
	if m != nil {
		return m.DeploymentState
	}
	return nil
}

// Scaling Status
//
// x-displayName: "Scaling Status"
// Details of Scaling
type ScalingStatus struct {
	// Scaling phase
	//
	// x-displayName: "Phase"
	// Phase of scaling action with options scaling, failed, done
	Phase ScalingPhase `protobuf:"varint,1,opt,name=phase,proto3,enum=ves.io.schema.site.ScalingPhase" json:"phase,omitempty"`
	// Message
	//
	// x-displayName: "Message"
	// provides description of scaling action, eg. "scaled to 3 nodes"
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	// Current pool node count
	//
	// x-displayName: "Current Pool Count"
	// Current number of pool nodes in cluster
	PoolNodeCountCurrent int32 `protobuf:"varint,3,opt,name=pool_node_count_current,json=poolNodeCountCurrent,proto3" json:"pool_node_count_current,omitempty"`
	// Desired pool node count
	//
	// x-displayName: "Desired Pool Count"
	// Desired pool node count defines how many nodes should be in a cluster after scaling
	PoolNodeCountTarget int32 `protobuf:"varint,4,opt,name=pool_node_count_target,json=poolNodeCountTarget,proto3" json:"pool_node_count_target,omitempty"`
}

func (m *ScalingStatus) Reset()      { *m = ScalingStatus{} }
func (*ScalingStatus) ProtoMessage() {}
func (*ScalingStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{21}
}
func (m *ScalingStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScalingStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ScalingStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScalingStatus.Merge(m, src)
}
func (m *ScalingStatus) XXX_Size() int {
	return m.Size()
}
func (m *ScalingStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ScalingStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ScalingStatus proto.InternalMessageInfo

func (m *ScalingStatus) GetPhase() ScalingPhase {
	if m != nil {
		return m.Phase
	}
	return SCALING_INVALID
}

func (m *ScalingStatus) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *ScalingStatus) GetPoolNodeCountCurrent() int32 {
	if m != nil {
		return m.PoolNodeCountCurrent
	}
	return 0
}

func (m *ScalingStatus) GetPoolNodeCountTarget() int32 {
	if m != nil {
		return m.PoolNodeCountTarget
	}
	return 0
}

type NodeInfo struct {
	// Hostname
	//
	// x-displayName: "Hostname"
	// Hostname of the node
	Hostname string `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Role
	//
	// x-displayName: "Node Role"
	// x-example: "k8s-master, k8s-minion"
	// Role of registered node. Roles are used by system to determine what control services they should enforce.
	// k8s-master represents Kubernetes Master
	Role []string `protobuf:"bytes,2,rep,name=role,proto3" json:"role,omitempty"`
}

func (m *NodeInfo) Reset()      { *m = NodeInfo{} }
func (*NodeInfo) ProtoMessage() {}
func (*NodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{22}
}
func (m *NodeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeInfo.Merge(m, src)
}
func (m *NodeInfo) XXX_Size() int {
	return m.Size()
}
func (m *NodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NodeInfo proto.InternalMessageInfo

func (m *NodeInfo) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *NodeInfo) GetRole() []string {
	if m != nil {
		return m.Role
	}
	return nil
}

// OsInfo
//
// x-displayName: "Os Info"
// OsInfo holds information about host OS and HW
type OsInfo struct {
	// os
	//
	// x-displayName: "Operating System"
	// os holds all general OS information
	Os *OS `protobuf:"bytes,1,opt,name=os,proto3" json:"os,omitempty"`
	// product
	//
	// x-displayName: "Product"
	// HW product information
	Product *Product `protobuf:"bytes,2,opt,name=product,proto3" json:"product,omitempty"`
	// board
	//
	// x-displayName: "Board"
	// HW board information
	Board *Board `protobuf:"bytes,3,opt,name=board,proto3" json:"board,omitempty"`
	// chassis
	//
	// x-displayName: "Chassis"
	// HW chassis information
	Chassis *Chassis `protobuf:"bytes,4,opt,name=chassis,proto3" json:"chassis,omitempty"`
	//  bios
	//
	// x-displayName: "BIOS"
	// Information about bios
	Bios *Bios `protobuf:"bytes,5,opt,name=bios,proto3" json:"bios,omitempty"`
	// cpu
	//
	// x-displayName: "CPU"
	// HW CPU information
	Cpu *Cpu `protobuf:"bytes,6,opt,name=cpu,proto3" json:"cpu,omitempty"`
	// memory
	//
	// x-displayName: "Memory"
	// HW memory information
	Memory *Memory `protobuf:"bytes,7,opt,name=memory,proto3" json:"memory,omitempty"`
	// storage
	//
	// x-displayName: "Storage"
	// List of storage devices in server
	Storage []*StorageDevice `protobuf:"bytes,8,rep,name=storage,proto3" json:"storage,omitempty"`
	// network
	//
	// x-displayName: "Network"
	// List of network devices in server
	Network []*NetworkDevice `protobuf:"bytes,9,rep,name=network,proto3" json:"network,omitempty"`
	// kernel
	//
	// x-displayName: "Kernel"
	// kernel information
	Kernel *Kernel `protobuf:"bytes,10,opt,name=kernel,proto3" json:"kernel,omitempty"`
	// USBDevice
	//
	// x-displayName: "USB devices"
	// List of USB devices in server
	Usb []*USBDevice `protobuf:"bytes,11,rep,name=usb,proto3" json:"usb,omitempty"`
	// GPU
	//
	// x-displayName: "GPU"
	// GPU information on server
	Gpu *GPU `protobuf:"bytes,12,opt,name=gpu,proto3" json:"gpu,omitempty"`
}

func (m *OsInfo) Reset()      { *m = OsInfo{} }
func (*OsInfo) ProtoMessage() {}
func (*OsInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{23}
}
func (m *OsInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OsInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OsInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OsInfo.Merge(m, src)
}
func (m *OsInfo) XXX_Size() int {
	return m.Size()
}
func (m *OsInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_OsInfo.DiscardUnknown(m)
}

var xxx_messageInfo_OsInfo proto.InternalMessageInfo

func (m *OsInfo) GetOs() *OS {
	if m != nil {
		return m.Os
	}
	return nil
}

func (m *OsInfo) GetProduct() *Product {
	if m != nil {
		return m.Product
	}
	return nil
}

func (m *OsInfo) GetBoard() *Board {
	if m != nil {
		return m.Board
	}
	return nil
}

func (m *OsInfo) GetChassis() *Chassis {
	if m != nil {
		return m.Chassis
	}
	return nil
}

func (m *OsInfo) GetBios() *Bios {
	if m != nil {
		return m.Bios
	}
	return nil
}

func (m *OsInfo) GetCpu() *Cpu {
	if m != nil {
		return m.Cpu
	}
	return nil
}

func (m *OsInfo) GetMemory() *Memory {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *OsInfo) GetStorage() []*StorageDevice {
	if m != nil {
		return m.Storage
	}
	return nil
}

func (m *OsInfo) GetNetwork() []*NetworkDevice {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *OsInfo) GetKernel() *Kernel {
	if m != nil {
		return m.Kernel
	}
	return nil
}

func (m *OsInfo) GetUsb() []*USBDevice {
	if m != nil {
		return m.Usb
	}
	return nil
}

func (m *OsInfo) GetGpu() *GPU {
	if m != nil {
		return m.Gpu
	}
	return nil
}

// OS
//
// x-displayName: "OS"
// Details of Operating System
type OS struct {
	// name
	//
	// x-displayName: "Name"
	// x-example: "Container Linux by CoreOS 1855.4.0 (Rhyolite)"
	// Name of OS
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// vendor
	//
	// x-displayName: "Vendor"
	// x-example: "coreos"
	// Vendor of OS
	Vendor string `protobuf:"bytes,2,opt,name=vendor,proto3" json:"vendor,omitempty"`
	// version
	//
	// x-displayName: "Version"
	// x-example: "1855.4.0"
	// Version of OS
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// release
	//
	// x-displayName: "Release"
	// x-example: "20.04"
	// Release of the OS
	Release string `protobuf:"bytes,4,opt,name=release,proto3" json:"release,omitempty"`
	// architecture
	//
	// x-displayName: "Architecture"
	// x-example: "amd64"
	// Architecture of OS
	Architecture string `protobuf:"bytes,5,opt,name=architecture,proto3" json:"architecture,omitempty"`
}

func (m *OS) Reset()      { *m = OS{} }
func (*OS) ProtoMessage() {}
func (*OS) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{24}
}
func (m *OS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OS.Merge(m, src)
}
func (m *OS) XXX_Size() int {
	return m.Size()
}
func (m *OS) XXX_DiscardUnknown() {
	xxx_messageInfo_OS.DiscardUnknown(m)
}

var xxx_messageInfo_OS proto.InternalMessageInfo

func (m *OS) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OS) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *OS) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *OS) GetRelease() string {
	if m != nil {
		return m.Release
	}
	return ""
}

func (m *OS) GetArchitecture() string {
	if m != nil {
		return m.Architecture
	}
	return ""
}

// Kernel Information
//
// x-displayName: "Kernel"
// Kernel information
type Kernel struct {
	// release
	//
	// x-displayName: "Release"
	// kernel release
	Release string `protobuf:"bytes,1,opt,name=release,proto3" json:"release,omitempty"`
	// version
	//
	// x-displayName: "Version"
	// kernel version
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// architecture
	//
	// x-displayName: "Architecture"
	// kernel architecture
	Architecture string `protobuf:"bytes,3,opt,name=architecture,proto3" json:"architecture,omitempty"`
}

func (m *Kernel) Reset()      { *m = Kernel{} }
func (*Kernel) ProtoMessage() {}
func (*Kernel) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{25}
}
func (m *Kernel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Kernel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Kernel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Kernel.Merge(m, src)
}
func (m *Kernel) XXX_Size() int {
	return m.Size()
}
func (m *Kernel) XXX_DiscardUnknown() {
	xxx_messageInfo_Kernel.DiscardUnknown(m)
}

var xxx_messageInfo_Kernel proto.InternalMessageInfo

func (m *Kernel) GetRelease() string {
	if m != nil {
		return m.Release
	}
	return ""
}

func (m *Kernel) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Kernel) GetArchitecture() string {
	if m != nil {
		return m.Architecture
	}
	return ""
}

// Product Information
//
// x-displayName: "Product Information"
// Product information
type Product struct {
	// name
	//
	// x-displayName: "Name"
	// product name, eg. for aws m5a.xlarge. Info taken from /sys/class/dmi/id/product_name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// vendor
	//
	// x-displayName: "Vendor"
	// vendor name, eg. for aws Amazon EC2. Info taken from /sys/class/dmi/id/product_vendor
	Vendor string `protobuf:"bytes,2,opt,name=vendor,proto3" json:"vendor,omitempty"`
	// version
	//
	// x-displayName: "Version"
	// version name. Info taken from /sys/class/dmi/id/product_version
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// serial
	//
	// x-displayName: "Serial Number"
	// serial number, eg. for aws ec254b6d-9676-1a51-8b10-21370dbdc3e5. Info taken from /sys/class/dmi/id/product_serial
	Serial string `protobuf:"bytes,4,opt,name=serial,proto3" json:"serial,omitempty"`
}

func (m *Product) Reset()      { *m = Product{} }
func (*Product) ProtoMessage() {}
func (*Product) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{26}
}
func (m *Product) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Product) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Product) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Product.Merge(m, src)
}
func (m *Product) XXX_Size() int {
	return m.Size()
}
func (m *Product) XXX_DiscardUnknown() {
	xxx_messageInfo_Product.DiscardUnknown(m)
}

var xxx_messageInfo_Product proto.InternalMessageInfo

func (m *Product) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Product) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *Product) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Product) GetSerial() string {
	if m != nil {
		return m.Serial
	}
	return ""
}

// Board Details
//
// x-displayName: "Board Details"
// Board information
type Board struct {
	// name
	//
	// x-displayName: "Name"
	// information from /sys/class/dmi/id/board_name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// vendor
	//
	// x-displayName: "Vendor"
	// information from /sys/class/dmi/id/board_vendor
	Vendor string `protobuf:"bytes,2,opt,name=vendor,proto3" json:"vendor,omitempty"`
	// version
	//
	// x-displayName: "Version"
	// information from /sys/class/dmi/id/board_version
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// serial
	//
	// x-displayName: "Serial Number"
	// information from /sys/class/dmi/id/board_serial
	Serial string `protobuf:"bytes,4,opt,name=serial,proto3" json:"serial,omitempty"`
	// asset_tag
	//
	// x-displayName: "Asset Tag"
	// information from /sys/class/dmi/id/board_asset_tag
	AssetTag string `protobuf:"bytes,5,opt,name=asset_tag,json=assetTag,proto3" json:"asset_tag,omitempty"`
}

func (m *Board) Reset()      { *m = Board{} }
func (*Board) ProtoMessage() {}
func (*Board) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{27}
}
func (m *Board) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Board) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Board) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Board.Merge(m, src)
}
func (m *Board) XXX_Size() int {
	return m.Size()
}
func (m *Board) XXX_DiscardUnknown() {
	xxx_messageInfo_Board.DiscardUnknown(m)
}

var xxx_messageInfo_Board proto.InternalMessageInfo

func (m *Board) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Board) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *Board) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Board) GetSerial() string {
	if m != nil {
		return m.Serial
	}
	return ""
}

func (m *Board) GetAssetTag() string {
	if m != nil {
		return m.AssetTag
	}
	return ""
}

// Chassis Details
//
// x-displayName: "Chassis Details"
// Chassis information.
type Chassis struct {
	// type
	//
	// x-displayName: "Type"
	// information from /sys/class/dmi/id/chassis_type
	Type uint32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	// vendor
	//
	// x-displayName: "Vendor"
	// information from /sys/class/dmi/id/chassis_vendor
	Vendor string `protobuf:"bytes,2,opt,name=vendor,proto3" json:"vendor,omitempty"`
	// version
	//
	// x-displayName: "Version"
	// information from /sys/class/dmi/id/chassis_version
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// serial
	//
	// x-displayName: "Serial Number"
	// information from /sys/class/dmi/id/chassis_serial
	Serial string `protobuf:"bytes,4,opt,name=serial,proto3" json:"serial,omitempty"`
	// asset_tag
	//
	// x-displayName: "Asset Tag"
	// information from /sys/class/dmi/id/chassis_asset_tag
	AssetTag string `protobuf:"bytes,5,opt,name=asset_tag,json=assetTag,proto3" json:"asset_tag,omitempty"`
}

func (m *Chassis) Reset()      { *m = Chassis{} }
func (*Chassis) ProtoMessage() {}
func (*Chassis) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{28}
}
func (m *Chassis) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Chassis) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Chassis) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Chassis.Merge(m, src)
}
func (m *Chassis) XXX_Size() int {
	return m.Size()
}
func (m *Chassis) XXX_DiscardUnknown() {
	xxx_messageInfo_Chassis.DiscardUnknown(m)
}

var xxx_messageInfo_Chassis proto.InternalMessageInfo

func (m *Chassis) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Chassis) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *Chassis) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Chassis) GetSerial() string {
	if m != nil {
		return m.Serial
	}
	return ""
}

func (m *Chassis) GetAssetTag() string {
	if m != nil {
		return m.AssetTag
	}
	return ""
}

// Bios Data
//
// x-displayName: "Bios Data"
// BIOS information.
type Bios struct {
	// vendor
	//
	// x-displayName: "Vendor"
	// information from /sys/class/dmi/id/bios_vendor
	Vendor string `protobuf:"bytes,1,opt,name=vendor,proto3" json:"vendor,omitempty"`
	// version
	//
	// x-displayName: "Version"
	// information from /sys/class/dmi/id/bios_version
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// date
	//
	// x-displayName: "Date"
	// information from /sys/class/dmi/id/bios_date
	Date string `protobuf:"bytes,3,opt,name=date,proto3" json:"date,omitempty"`
}

func (m *Bios) Reset()      { *m = Bios{} }
func (*Bios) ProtoMessage() {}
func (*Bios) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{29}
}
func (m *Bios) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Bios) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Bios) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bios.Merge(m, src)
}
func (m *Bios) XXX_Size() int {
	return m.Size()
}
func (m *Bios) XXX_DiscardUnknown() {
	xxx_messageInfo_Bios.DiscardUnknown(m)
}

var xxx_messageInfo_Bios proto.InternalMessageInfo

func (m *Bios) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *Bios) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Bios) GetDate() string {
	if m != nil {
		return m.Date
	}
	return ""
}

// Cpu information
//
// x-displayName: "Cpu Information"
// CPU information
type Cpu struct {
	// vendor
	//
	// x-displayName: "Vendor"
	// CPU vendor
	Vendor string `protobuf:"bytes,1,opt,name=vendor,proto3" json:"vendor,omitempty"`
	// model
	//
	// x-displayName: "Model"
	// CPU model
	Model string `protobuf:"bytes,2,opt,name=model,proto3" json:"model,omitempty"`
	// speed
	//
	// x-displayName: "Speed"
	// CPU clock rate in MHz
	Speed uint32 `protobuf:"varint,3,opt,name=speed,proto3" json:"speed,omitempty"`
	// cache
	//
	// x-displayName: "Cache"
	// CPU cache size in KB
	Cache uint32 `protobuf:"varint,4,opt,name=cache,proto3" json:"cache,omitempty"`
	// cpus
	//
	// x-displayName: "CPUs"
	// number of physical CPUs
	Cpus uint32 `protobuf:"varint,5,opt,name=cpus,proto3" json:"cpus,omitempty"`
	// cores
	//
	// x-displayName: "Cores"
	// number of physical CPU cores
	Cores uint32 `protobuf:"varint,6,opt,name=cores,proto3" json:"cores,omitempty"`
	// threads
	//
	// x-displayName: "Threads"
	// number of logical (HT) CPU cores
	Threads uint32 `protobuf:"varint,7,opt,name=threads,proto3" json:"threads,omitempty"`
}

func (m *Cpu) Reset()      { *m = Cpu{} }
func (*Cpu) ProtoMessage() {}
func (*Cpu) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{30}
}
func (m *Cpu) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cpu) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Cpu) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cpu.Merge(m, src)
}
func (m *Cpu) XXX_Size() int {
	return m.Size()
}
func (m *Cpu) XXX_DiscardUnknown() {
	xxx_messageInfo_Cpu.DiscardUnknown(m)
}

var xxx_messageInfo_Cpu proto.InternalMessageInfo

func (m *Cpu) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *Cpu) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *Cpu) GetSpeed() uint32 {
	if m != nil {
		return m.Speed
	}
	return 0
}

func (m *Cpu) GetCache() uint32 {
	if m != nil {
		return m.Cache
	}
	return 0
}

func (m *Cpu) GetCpus() uint32 {
	if m != nil {
		return m.Cpus
	}
	return 0
}

func (m *Cpu) GetCores() uint32 {
	if m != nil {
		return m.Cores
	}
	return 0
}

func (m *Cpu) GetThreads() uint32 {
	if m != nil {
		return m.Threads
	}
	return 0
}

// Memory Information
//
// x-displayName: "Memory Information"
// Memory information.
type Memory struct {
	// type
	//
	// x-displayName: "Type"
	// type of memory, eg. DDR4
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// speed
	//
	// x-displayName: "Speed"
	// RAM data rate in MT/s
	Speed uint32 `protobuf:"varint,2,opt,name=speed,proto3" json:"speed,omitempty"`
	// size_mb
	//
	// x-displayName: "RAM"
	// RAM size in MB
	SizeMb uint32 `protobuf:"varint,3,opt,name=size_mb,json=sizeMb,proto3" json:"size_mb,omitempty"`
}

func (m *Memory) Reset()      { *m = Memory{} }
func (*Memory) ProtoMessage() {}
func (*Memory) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{31}
}
func (m *Memory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Memory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Memory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Memory.Merge(m, src)
}
func (m *Memory) XXX_Size() int {
	return m.Size()
}
func (m *Memory) XXX_DiscardUnknown() {
	xxx_messageInfo_Memory.DiscardUnknown(m)
}

var xxx_messageInfo_Memory proto.InternalMessageInfo

func (m *Memory) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Memory) GetSpeed() uint32 {
	if m != nil {
		return m.Speed
	}
	return 0
}

func (m *Memory) GetSizeMb() uint32 {
	if m != nil {
		return m.SizeMb
	}
	return 0
}

// Storage Information
//
// x-displayName: "Storage Information"
// StorageDevice information.
type StorageDevice struct {
	// name
	//
	// x-displayName: "Name"
	// name of device, eg. nvme0n1
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// driver
	//
	// x-displayName: "Driver"
	// driver of device
	Driver string `protobuf:"bytes,2,opt,name=driver,proto3" json:"driver,omitempty"`
	// vendor
	//
	// x-displayName: "Vendor"
	// vendor of device
	Vendor string `protobuf:"bytes,3,opt,name=vendor,proto3" json:"vendor,omitempty"`
	// model
	//
	// x-displayName: "Model"
	// model of device
	Model string `protobuf:"bytes,4,opt,name=model,proto3" json:"model,omitempty"`
	// serial
	//
	// x-displayName: "Serial Number"
	// serial of device
	Serial string `protobuf:"bytes,5,opt,name=serial,proto3" json:"serial,omitempty"`
	// size_gb
	//
	// x-displayName: "Size(GB)"
	// device size in GB
	SizeGb uint32 `protobuf:"varint,6,opt,name=size_gb,json=sizeGb,proto3" json:"size_gb,omitempty"`
}

func (m *StorageDevice) Reset()      { *m = StorageDevice{} }
func (*StorageDevice) ProtoMessage() {}
func (*StorageDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{32}
}
func (m *StorageDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *StorageDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageDevice.Merge(m, src)
}
func (m *StorageDevice) XXX_Size() int {
	return m.Size()
}
func (m *StorageDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageDevice.DiscardUnknown(m)
}

var xxx_messageInfo_StorageDevice proto.InternalMessageInfo

func (m *StorageDevice) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StorageDevice) GetDriver() string {
	if m != nil {
		return m.Driver
	}
	return ""
}

func (m *StorageDevice) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *StorageDevice) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *StorageDevice) GetSerial() string {
	if m != nil {
		return m.Serial
	}
	return ""
}

func (m *StorageDevice) GetSizeGb() uint32 {
	if m != nil {
		return m.SizeGb
	}
	return 0
}

// Network Device Information
//
// x-displayName: "Network Device Information"
// NetworkDevice information.
type NetworkDevice struct {
	// name
	//
	// x-displayName: "Name"
	// name of device, eg. eth0
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// driver
	//
	// x-displayName: "Driver"
	// driver of device, eg. e1000e
	Driver string `protobuf:"bytes,2,opt,name=driver,proto3" json:"driver,omitempty"`
	// ip_address
	//
	// x-displayName: "IP Address"
	// ip address on interface
	IpAddress []string `protobuf:"bytes,3,rep,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	// mac_address
	//
	// x-displayName: "MAC Address"
	// mac address on interface
	MacAddress string `protobuf:"bytes,4,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	// port
	//
	// x-displayName: "Port"
	// used port, eg. tp
	Port string `protobuf:"bytes,5,opt,name=port,proto3" json:"port,omitempty"`
	// speed
	//
	// x-displayName: "Speed"
	// device max supported speed in Mbps
	Speed uint32 `protobuf:"varint,6,opt,name=speed,proto3" json:"speed,omitempty"`
	// Link quality status
	//
	// x-displayName: "Link Quality"
	// Link quality for the interface
	LinkQuality LinkQuality `protobuf:"varint,7,opt,name=link_quality,json=linkQuality,proto3,enum=ves.io.schema.site.LinkQuality" json:"link_quality,omitempty"`
	// Link type
	//
	// x-displayName: "Link type"
	// Link type for the interface
	LinkType LinkType `protobuf:"varint,8,opt,name=link_type,json=linkType,proto3,enum=ves.io.schema.site.LinkType" json:"link_type,omitempty"`
}

func (m *NetworkDevice) Reset()      { *m = NetworkDevice{} }
func (*NetworkDevice) ProtoMessage() {}
func (*NetworkDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{33}
}
func (m *NetworkDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *NetworkDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkDevice.Merge(m, src)
}
func (m *NetworkDevice) XXX_Size() int {
	return m.Size()
}
func (m *NetworkDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkDevice.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkDevice proto.InternalMessageInfo

func (m *NetworkDevice) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NetworkDevice) GetDriver() string {
	if m != nil {
		return m.Driver
	}
	return ""
}

func (m *NetworkDevice) GetIpAddress() []string {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *NetworkDevice) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *NetworkDevice) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

func (m *NetworkDevice) GetSpeed() uint32 {
	if m != nil {
		return m.Speed
	}
	return 0
}

func (m *NetworkDevice) GetLinkQuality() LinkQuality {
	if m != nil {
		return m.LinkQuality
	}
	return QUALITY_UNKNOWN
}

func (m *NetworkDevice) GetLinkType() LinkType {
	if m != nil {
		return m.LinkType
	}
	return LINK_TYPE_UNKNOWN
}

// USB device
//
// x-displayName: "USB Device informaton"
// Information about USB device
type USBDevice struct {
	// bus
	//
	// x-displayName: "Bus"
	// x-example: "1"
	// The bus on which the device was detected in decimal
	Bus uint32 `protobuf:"varint,1,opt,name=bus,proto3" json:"bus,omitempty"`
	// address
	//
	// x-displayName: "Address"
	// x-example: "4"
	// Address of the device on the bus in decimal
	Address uint32 `protobuf:"varint,2,opt,name=address,proto3" json:"address,omitempty"`
	// port
	//
	// x-displayName: "Port"
	// x-example: "3"
	// Port on which the device was detected in decimal
	Port uint32 `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	// description
	//
	// x-displayName: "Description"
	// x-example: "NetVista Full Width Keyboard (IBM Corp.)"
	// Device description
	Description string `protobuf:"bytes,9,opt,name=description,proto3" json:"description,omitempty"`
	// vendor_name
	//
	// x-displayName: "Vendor name"
	// x-example: "IBM Corp."
	// Vendor ID translated to name (if available)
	VendorName string `protobuf:"bytes,10,opt,name=vendor_name,json=vendorName,proto3" json:"vendor_name,omitempty"`
	// product_name
	//
	// x-displayName: "Product name"
	// x-example: "NetVista Full Width Keyboard"
	// Product ID translated to name (if available)
	ProductName string `protobuf:"bytes,11,opt,name=product_name,json=productName,proto3" json:"product_name,omitempty"`
	// i_serial_number
	//
	// x-displayName: "iSerialNumber"
	// x-example: "0000:00:14.0"
	// Index of Serial Number String Descriptor
	ISerial string `protobuf:"bytes,14,opt,name=i_serial,json=iSerial,proto3" json:"i_serial,omitempty"`
	// id_vendor
	//
	// x-displayName: "Vendor ID"
	// x-example: "0x1d6b"
	// Vendor ID (Assigned by USB Org) in hex
	IdVendor string `protobuf:"bytes,15,opt,name=id_vendor,json=idVendor,proto3" json:"id_vendor,omitempty"`
	// id_product
	//
	// x-displayName: "Product ID"
	// x-example: "0x0002"
	// Product ID (Assigned by Manufacturer) in hex
	IdProduct string `protobuf:"bytes,16,opt,name=id_product,json=idProduct,proto3" json:"id_product,omitempty"`
	// i_manufacturer
	//
	// x-displayName: "Manufacturer"
	// x-example: "Voltera"
	// Manufacturer name
	IManufacturer string `protobuf:"bytes,17,opt,name=i_manufacturer,json=iManufacturer,proto3" json:"i_manufacturer,omitempty"`
	// speed
	//
	// x-displayName: "Speed"
	// x-example: "high"
	// The negotiated operating speed for the device
	Speed string `protobuf:"bytes,18,opt,name=speed,proto3" json:"speed,omitempty"`
	// bcd_usb
	//
	// x-displayName: "BCD Spec"
	// x-example: "2.0"
	// USB Specification Release Number
	BcdUsb string `protobuf:"bytes,19,opt,name=bcd_usb,json=bcdUsb,proto3" json:"bcd_usb,omitempty"`
	// bcd_device
	//
	// x-displayName: "BCD Device"
	// x-example: "5.05"
	// The device version
	BcdDevice string `protobuf:"bytes,20,opt,name=bcd_device,json=bcdDevice,proto3" json:"bcd_device,omitempty"`
	// b_device_class
	//
	// x-displayName: "Class"
	// x-example: "hub"
	// The class of this device
	BDeviceClass string `protobuf:"bytes,21,opt,name=b_device_class,json=bDeviceClass,proto3" json:"b_device_class,omitempty"`
	// b_device_sub_class
	//
	// x-displayName: "Subclass"
	// x-example: "hub"
	// The sub-class (within the class) of this device
	BDeviceSubClass string `protobuf:"bytes,22,opt,name=b_device_sub_class,json=bDeviceSubClass,proto3" json:"b_device_sub_class,omitempty"`
	// b_device_protocol
	//
	// x-displayName: "Protocol"
	// x-example: "0002"
	// The protocol (within the sub-class) of this device
	BDeviceProtocol string `protobuf:"bytes,23,opt,name=b_device_protocol,json=bDeviceProtocol,proto3" json:"b_device_protocol,omitempty"`
	// b_max_packet_size
	//
	// x-displayName: "Max packet size"
	// x-example: "64"
	// Maximum size of the control transfer
	BMaxPacketSize uint32 `protobuf:"varint,24,opt,name=b_max_packet_size,json=bMaxPacketSize,proto3" json:"b_max_packet_size,omitempty"`
	// i_product
	//
	// x-displayName: "Device product"
	// x-example: "xHCI Host Controller"
	// Product name reported by device
	IProduct string `protobuf:"bytes,25,opt,name=i_product,json=iProduct,proto3" json:"i_product,omitempty"`
	// usb_type
	//
	// x-displayName: "USB Type"
	// x-example: "INTERNAL"
	// Type of USB device
	UsbType UsbType `protobuf:"varint,26,opt,name=usb_type,json=usbType,proto3,enum=ves.io.schema.site.UsbType" json:"usb_type,omitempty"`
}

func (m *USBDevice) Reset()      { *m = USBDevice{} }
func (*USBDevice) ProtoMessage() {}
func (*USBDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{34}
}
func (m *USBDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *USBDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *USBDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_USBDevice.Merge(m, src)
}
func (m *USBDevice) XXX_Size() int {
	return m.Size()
}
func (m *USBDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_USBDevice.DiscardUnknown(m)
}

var xxx_messageInfo_USBDevice proto.InternalMessageInfo

func (m *USBDevice) GetBus() uint32 {
	if m != nil {
		return m.Bus
	}
	return 0
}

func (m *USBDevice) GetAddress() uint32 {
	if m != nil {
		return m.Address
	}
	return 0
}

func (m *USBDevice) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *USBDevice) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *USBDevice) GetVendorName() string {
	if m != nil {
		return m.VendorName
	}
	return ""
}

func (m *USBDevice) GetProductName() string {
	if m != nil {
		return m.ProductName
	}
	return ""
}

func (m *USBDevice) GetISerial() string {
	if m != nil {
		return m.ISerial
	}
	return ""
}

func (m *USBDevice) GetIdVendor() string {
	if m != nil {
		return m.IdVendor
	}
	return ""
}

func (m *USBDevice) GetIdProduct() string {
	if m != nil {
		return m.IdProduct
	}
	return ""
}

func (m *USBDevice) GetIManufacturer() string {
	if m != nil {
		return m.IManufacturer
	}
	return ""
}

func (m *USBDevice) GetSpeed() string {
	if m != nil {
		return m.Speed
	}
	return ""
}

func (m *USBDevice) GetBcdUsb() string {
	if m != nil {
		return m.BcdUsb
	}
	return ""
}

func (m *USBDevice) GetBcdDevice() string {
	if m != nil {
		return m.BcdDevice
	}
	return ""
}

func (m *USBDevice) GetBDeviceClass() string {
	if m != nil {
		return m.BDeviceClass
	}
	return ""
}

func (m *USBDevice) GetBDeviceSubClass() string {
	if m != nil {
		return m.BDeviceSubClass
	}
	return ""
}

func (m *USBDevice) GetBDeviceProtocol() string {
	if m != nil {
		return m.BDeviceProtocol
	}
	return ""
}

func (m *USBDevice) GetBMaxPacketSize() uint32 {
	if m != nil {
		return m.BMaxPacketSize
	}
	return 0
}

func (m *USBDevice) GetIProduct() string {
	if m != nil {
		return m.IProduct
	}
	return ""
}

func (m *USBDevice) GetUsbType() UsbType {
	if m != nil {
		return m.UsbType
	}
	return UNKNOWN_USB
}

// GPU
//
// x-displayName: "GPU"
// GPU information on server
type GPU struct {
	// driverVersion
	//
	// x-displayName: "Driver Version"
	// x-example: "440.82"
	// GPU Driver Version
	DriverVersion string `protobuf:"bytes,1,opt,name=driver_version,json=driverVersion,proto3" json:"driver_version,omitempty"`
	// cudaVersion
	//
	// x-displayName: "Cuda Version"
	// x-example: "10.2"
	// GPU Cuda Version
	CudaVersion string `protobuf:"bytes,2,opt,name=cuda_version,json=cudaVersion,proto3" json:"cuda_version,omitempty"`
	// GPUDevice
	//
	// x-displayName: "GPU devices"
	// List of GPU devices in server
	GpuDevice []*GPUDevice `protobuf:"bytes,3,rep,name=gpu_device,json=gpuDevice,proto3" json:"gpu_device,omitempty"`
}

func (m *GPU) Reset()      { *m = GPU{} }
func (*GPU) ProtoMessage() {}
func (*GPU) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{35}
}
func (m *GPU) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPU) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GPU) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPU.Merge(m, src)
}
func (m *GPU) XXX_Size() int {
	return m.Size()
}
func (m *GPU) XXX_DiscardUnknown() {
	xxx_messageInfo_GPU.DiscardUnknown(m)
}

var xxx_messageInfo_GPU proto.InternalMessageInfo

func (m *GPU) GetDriverVersion() string {
	if m != nil {
		return m.DriverVersion
	}
	return ""
}

func (m *GPU) GetCudaVersion() string {
	if m != nil {
		return m.CudaVersion
	}
	return ""
}

func (m *GPU) GetGpuDevice() []*GPUDevice {
	if m != nil {
		return m.GpuDevice
	}
	return nil
}

type GPUDevice struct {
	// id
	//
	// x-displayName: "GPU ID"
	// x-example: "00000000:17:00.0"
	// GPU ID
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// productName
	//
	// x-displayName: "Product Name"
	// x-example: "Quadro P1000"
	// GPU Product Name
	ProductName string `protobuf:"bytes,2,opt,name=product_name,json=productName,proto3" json:"product_name,omitempty"`
	// processes
	//
	// x-displayName: "Processes"
	// GPU Processes
	Processes string `protobuf:"bytes,3,opt,name=processes,proto3" json:"processes,omitempty"`
}

func (m *GPUDevice) Reset()      { *m = GPUDevice{} }
func (*GPUDevice) ProtoMessage() {}
func (*GPUDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{36}
}
func (m *GPUDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GPUDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUDevice.Merge(m, src)
}
func (m *GPUDevice) XXX_Size() int {
	return m.Size()
}
func (m *GPUDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUDevice.DiscardUnknown(m)
}

var xxx_messageInfo_GPUDevice proto.InternalMessageInfo

func (m *GPUDevice) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *GPUDevice) GetProductName() string {
	if m != nil {
		return m.ProductName
	}
	return ""
}

func (m *GPUDevice) GetProcesses() string {
	if m != nil {
		return m.Processes
	}
	return ""
}

// SiteStatusMetricsFieldData
//
// x-displayName: "Site Status Metrics Field Data"
// Site Status Field Data contains key/value pair for a field
type SiteStatusMetricsFieldData struct {
	// Key
	//
	// x-displayName: "Key"
	// Key contains name/value pair.
	// For SITE_RE_IN_THROUGHPUT, the key will be "name": "<RE-name>"
	// For SITE_NODE_IF_IN_THROUGHPUT, the key will be "name": "<Interface-name>"
	Key map[string]string `protobuf:"bytes,1,rep,name=key,proto3" json:"key,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Value
	//
	// x-displayName: "Value"
	// List of metric values
	Value []*schema.MetricValue `protobuf:"bytes,2,rep,name=value,proto3" json:"value,omitempty"`
}

func (m *SiteStatusMetricsFieldData) Reset()      { *m = SiteStatusMetricsFieldData{} }
func (*SiteStatusMetricsFieldData) ProtoMessage() {}
func (*SiteStatusMetricsFieldData) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{37}
}
func (m *SiteStatusMetricsFieldData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SiteStatusMetricsFieldData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SiteStatusMetricsFieldData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SiteStatusMetricsFieldData.Merge(m, src)
}
func (m *SiteStatusMetricsFieldData) XXX_Size() int {
	return m.Size()
}
func (m *SiteStatusMetricsFieldData) XXX_DiscardUnknown() {
	xxx_messageInfo_SiteStatusMetricsFieldData.DiscardUnknown(m)
}

var xxx_messageInfo_SiteStatusMetricsFieldData proto.InternalMessageInfo

func (m *SiteStatusMetricsFieldData) GetKey() map[string]string {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *SiteStatusMetricsFieldData) GetValue() []*schema.MetricValue {
	if m != nil {
		return m.Value
	}
	return nil
}

// SiteStatusMetricsData
//
// x-displayName: "Site Status Metrics Data"
// Site Status Data contains name of the field and the corresponding data
type SiteStatusMetricsData struct {
	// Field
	//
	// x-displayName: "Field"
	// Site Status Metrics Field
	Field SiteStatusMetricsField `protobuf:"varint,1,opt,name=field,proto3,enum=ves.io.schema.site.SiteStatusMetricsField" json:"field,omitempty"`
	// Data
	//
	// x-displayName: "Data"
	// List of metric data
	Data []*SiteStatusMetricsFieldData `protobuf:"bytes,2,rep,name=data,proto3" json:"data,omitempty"`
}

func (m *SiteStatusMetricsData) Reset()      { *m = SiteStatusMetricsData{} }
func (*SiteStatusMetricsData) ProtoMessage() {}
func (*SiteStatusMetricsData) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{38}
}
func (m *SiteStatusMetricsData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SiteStatusMetricsData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SiteStatusMetricsData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SiteStatusMetricsData.Merge(m, src)
}
func (m *SiteStatusMetricsData) XXX_Size() int {
	return m.Size()
}
func (m *SiteStatusMetricsData) XXX_DiscardUnknown() {
	xxx_messageInfo_SiteStatusMetricsData.DiscardUnknown(m)
}

var xxx_messageInfo_SiteStatusMetricsData proto.InternalMessageInfo

func (m *SiteStatusMetricsData) GetField() SiteStatusMetricsField {
	if m != nil {
		return m.Field
	}
	return SITE_ACTIVE_FLOW_COUNT
}

func (m *SiteStatusMetricsData) GetData() []*SiteStatusMetricsFieldData {
	if m != nil {
		return m.Data
	}
	return nil
}

// Create Kube Config Request
//
// x-displayName: "Create Kube Config Request"
// Create kubeconfig request parameters
type CreateKubeConfigReq struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-required
	// x-example: "system"
	// K8s Cluster namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Name
	//
	// x-displayName: "Name"
	// x-required
	// x-example: "ce398"
	// K8s Cluster name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *CreateKubeConfigReq) Reset()      { *m = CreateKubeConfigReq{} }
func (*CreateKubeConfigReq) ProtoMessage() {}
func (*CreateKubeConfigReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{39}
}
func (m *CreateKubeConfigReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateKubeConfigReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateKubeConfigReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateKubeConfigReq.Merge(m, src)
}
func (m *CreateKubeConfigReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateKubeConfigReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateKubeConfigReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateKubeConfigReq proto.InternalMessageInfo

func (m *CreateKubeConfigReq) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *CreateKubeConfigReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// List Kube Config Request
//
// x-displayName: "List Kube Config Request"
// List kubeconfig request parameters
type ListKubeConfigReq struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-required
	// x-example: "system"
	// K8s Cluster namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Name
	//
	// x-displayName: "Name"
	// x-required
	// x-example: "ce398"
	// K8s Cluster name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ListKubeConfigReq) Reset()      { *m = ListKubeConfigReq{} }
func (*ListKubeConfigReq) ProtoMessage() {}
func (*ListKubeConfigReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{40}
}
func (m *ListKubeConfigReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListKubeConfigReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ListKubeConfigReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListKubeConfigReq.Merge(m, src)
}
func (m *ListKubeConfigReq) XXX_Size() int {
	return m.Size()
}
func (m *ListKubeConfigReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListKubeConfigReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListKubeConfigReq proto.InternalMessageInfo

func (m *ListKubeConfigReq) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ListKubeConfigReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// List Kube Config item
//
// x-displayName: "List Kube Config item"
// Each item of credential list request.
type ListKubeConfigRspItem struct {
	// uuid of the record
	//
	// x-displayName: "UUID"
	// x-example: "fa45979f-4e41-4f4b-8b0b-c3ab844ab0aa"
	// UUID of API credential object.
	Uid string `protobuf:"bytes,3,opt,name=uid,proto3" json:"uid,omitempty"`
	// Create timestamp
	//
	// x-displayName: "Creation Time"
	// Create time of API credential.
	CreateTimestamp *types.Timestamp `protobuf:"bytes,5,opt,name=create_timestamp,json=createTimestamp,proto3" json:"create_timestamp,omitempty"`
	// Expiry time
	//
	// x-displayName: "Expiry Time"
	// Expiry time of credential.
	ExpiryTimestamp *types.Timestamp `protobuf:"bytes,6,opt,name=expiry_timestamp,json=expiryTimestamp,proto3" json:"expiry_timestamp,omitempty"`
	// Email of user
	//
	// x-displayName: "User"
	// x-example: "admin@acmecorp.com"
	// User email of user that requested credential .
	UserEmail string `protobuf:"bytes,7,opt,name=user_email,json=userEmail,proto3" json:"user_email,omitempty"`
	// Name
	//
	// x-displayName: "Name"
	// x-example: "api-cred-x89sf"
	// Name of this credential
	Name string `protobuf:"bytes,8,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *ListKubeConfigRspItem) Reset()      { *m = ListKubeConfigRspItem{} }
func (*ListKubeConfigRspItem) ProtoMessage() {}
func (*ListKubeConfigRspItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{41}
}
func (m *ListKubeConfigRspItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListKubeConfigRspItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ListKubeConfigRspItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListKubeConfigRspItem.Merge(m, src)
}
func (m *ListKubeConfigRspItem) XXX_Size() int {
	return m.Size()
}
func (m *ListKubeConfigRspItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ListKubeConfigRspItem.DiscardUnknown(m)
}

var xxx_messageInfo_ListKubeConfigRspItem proto.InternalMessageInfo

func (m *ListKubeConfigRspItem) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *ListKubeConfigRspItem) GetCreateTimestamp() *types.Timestamp {
	if m != nil {
		return m.CreateTimestamp
	}
	return nil
}

func (m *ListKubeConfigRspItem) GetExpiryTimestamp() *types.Timestamp {
	if m != nil {
		return m.ExpiryTimestamp
	}
	return nil
}

func (m *ListKubeConfigRspItem) GetUserEmail() string {
	if m != nil {
		return m.UserEmail
	}
	return ""
}

func (m *ListKubeConfigRspItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// List Kube Config Response
//
// x-displayName: "List Kube Config Response"
// List kubeconfig response
type ListKubeConfigRsp struct {
	// List of the kubeconfigs
	//
	// x-displayName: "List of Kube Configs"
	// List of kubeconfig items.
	Items []*ListKubeConfigRspItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *ListKubeConfigRsp) Reset()      { *m = ListKubeConfigRsp{} }
func (*ListKubeConfigRsp) ProtoMessage() {}
func (*ListKubeConfigRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{42}
}
func (m *ListKubeConfigRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListKubeConfigRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ListKubeConfigRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListKubeConfigRsp.Merge(m, src)
}
func (m *ListKubeConfigRsp) XXX_Size() int {
	return m.Size()
}
func (m *ListKubeConfigRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ListKubeConfigRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ListKubeConfigRsp proto.InternalMessageInfo

func (m *ListKubeConfigRsp) GetItems() []*ListKubeConfigRspItem {
	if m != nil {
		return m.Items
	}
	return nil
}

// GlobalAccessCheckRequest
//
// x-displayName: "Check global access enabled"
// Check global access enabled
type GlobalAccessCheckRequest struct {
	// Namespace
	//
	// x-displayName: "Namespace"
	// x-required
	// x-example: "system"
	// K8s Cluster namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Name
	//
	// x-displayName: "Name"
	// x-required
	// x-example: "ce398"
	// K8s Cluster name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GlobalAccessCheckRequest) Reset()      { *m = GlobalAccessCheckRequest{} }
func (*GlobalAccessCheckRequest) ProtoMessage() {}
func (*GlobalAccessCheckRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{43}
}
func (m *GlobalAccessCheckRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalAccessCheckRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalAccessCheckRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalAccessCheckRequest.Merge(m, src)
}
func (m *GlobalAccessCheckRequest) XXX_Size() int {
	return m.Size()
}
func (m *GlobalAccessCheckRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalAccessCheckRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalAccessCheckRequest proto.InternalMessageInfo

func (m *GlobalAccessCheckRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *GlobalAccessCheckRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// GlobalAccessCheckResponse
//
// x-displayName: "Check global access enabled"
// Check global access enabled
type GlobalAccessCheckResponse struct {
	// enabled
	//
	// x-displayName: "Enabled"
	// x-example: "false"
	// Global access enabled
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
}

func (m *GlobalAccessCheckResponse) Reset()      { *m = GlobalAccessCheckResponse{} }
func (*GlobalAccessCheckResponse) ProtoMessage() {}
func (*GlobalAccessCheckResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{44}
}
func (m *GlobalAccessCheckResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalAccessCheckResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *GlobalAccessCheckResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalAccessCheckResponse.Merge(m, src)
}
func (m *GlobalAccessCheckResponse) XXX_Size() int {
	return m.Size()
}
func (m *GlobalAccessCheckResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalAccessCheckResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalAccessCheckResponse proto.InternalMessageInfo

func (m *GlobalAccessCheckResponse) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// Create Global Kube Config Request
//
// x-displayName: "Create Kube Config Request"
// Create kubeconfig request parameters
type CreateGlobalKubeConfigReq struct {
	// Site
	//
	// x-displayName: "Site"
	// x-required
	// x-example: "ce398"
	// Name of the site for which kubeconfig is being requested.
	Site string `protobuf:"bytes,1,opt,name=site,proto3" json:"site,omitempty"`
	// Expiry timestamp
	//
	// x-displayName: "Expiry timestamp"
	// x-example: "value"
	// Timestamp of kubeconfig's certificate expiry.
	ExpirationTimestamp *types.Timestamp `protobuf:"bytes,2,opt,name=expiration_timestamp,json=expirationTimestamp,proto3" json:"expiration_timestamp,omitempty"`
}

func (m *CreateGlobalKubeConfigReq) Reset()      { *m = CreateGlobalKubeConfigReq{} }
func (*CreateGlobalKubeConfigReq) ProtoMessage() {}
func (*CreateGlobalKubeConfigReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{45}
}
func (m *CreateGlobalKubeConfigReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateGlobalKubeConfigReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *CreateGlobalKubeConfigReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateGlobalKubeConfigReq.Merge(m, src)
}
func (m *CreateGlobalKubeConfigReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateGlobalKubeConfigReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateGlobalKubeConfigReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateGlobalKubeConfigReq proto.InternalMessageInfo

func (m *CreateGlobalKubeConfigReq) GetSite() string {
	if m != nil {
		return m.Site
	}
	return ""
}

func (m *CreateGlobalKubeConfigReq) GetExpirationTimestamp() *types.Timestamp {
	if m != nil {
		return m.ExpirationTimestamp
	}
	return nil
}

// List Kube Config Request
//
// x-displayName: "List Kube Config Request"
// List kubeconfig request parameters
type ListGlobalKubeConfigReq struct {
	// Site
	//
	// x-displayName: "Site"
	// x-required
	// x-example: "ce398"
	// Name of the site.
	// All global kubeconfigs created by the user under the site will be listed.
	Site string `protobuf:"bytes,1,opt,name=site,proto3" json:"site,omitempty"`
}

func (m *ListGlobalKubeConfigReq) Reset()      { *m = ListGlobalKubeConfigReq{} }
func (*ListGlobalKubeConfigReq) ProtoMessage() {}
func (*ListGlobalKubeConfigReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{46}
}
func (m *ListGlobalKubeConfigReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListGlobalKubeConfigReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *ListGlobalKubeConfigReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListGlobalKubeConfigReq.Merge(m, src)
}
func (m *ListGlobalKubeConfigReq) XXX_Size() int {
	return m.Size()
}
func (m *ListGlobalKubeConfigReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListGlobalKubeConfigReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListGlobalKubeConfigReq proto.InternalMessageInfo

func (m *ListGlobalKubeConfigReq) GetSite() string {
	if m != nil {
		return m.Site
	}
	return ""
}

// Revoke Kubeconfig request
//
// x-displayName: "Revoke Kubeconfig Request"
// Revoke kubeconfig object with a given name.
type RevokeKubeConfigReq struct {
	// Credential name
	//
	// x-displayName: "Name"
	// x-required
	// x-example: "value"
	// Name of kubeconfig resource.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *RevokeKubeConfigReq) Reset()      { *m = RevokeKubeConfigReq{} }
func (*RevokeKubeConfigReq) ProtoMessage() {}
func (*RevokeKubeConfigReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{47}
}
func (m *RevokeKubeConfigReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RevokeKubeConfigReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *RevokeKubeConfigReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RevokeKubeConfigReq.Merge(m, src)
}
func (m *RevokeKubeConfigReq) XXX_Size() int {
	return m.Size()
}
func (m *RevokeKubeConfigReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RevokeKubeConfigReq.DiscardUnknown(m)
}

var xxx_messageInfo_RevokeKubeConfigReq proto.InternalMessageInfo

func (m *RevokeKubeConfigReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Kube Config  status response
//
// x-displayName: "Kube Config status response"
// Response for operation on kube config
type KubeConfigStatusRsp struct {
	// Status
	//
	// x-displayName: "status"
	// x-example: "true"
	// Result status flag.
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *KubeConfigStatusRsp) Reset()      { *m = KubeConfigStatusRsp{} }
func (*KubeConfigStatusRsp) ProtoMessage() {}
func (*KubeConfigStatusRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b1b2598d34ae46b, []int{48}
}
func (m *KubeConfigStatusRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubeConfigStatusRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *KubeConfigStatusRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubeConfigStatusRsp.Merge(m, src)
}
func (m *KubeConfigStatusRsp) XXX_Size() int {
	return m.Size()
}
func (m *KubeConfigStatusRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_KubeConfigStatusRsp.DiscardUnknown(m)
}

var xxx_messageInfo_KubeConfigStatusRsp proto.InternalMessageInfo

func (m *KubeConfigStatusRsp) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

func init() {
	proto.RegisterEnum("ves.io.schema.site.SiteType", SiteType_name, SiteType_value)
	golang_proto.RegisterEnum("ves.io.schema.site.SiteType", SiteType_name, SiteType_value)
	proto.RegisterEnum("ves.io.schema.site.SiteSubtype", SiteSubtype_name, SiteSubtype_value)
	golang_proto.RegisterEnum("ves.io.schema.site.SiteSubtype", SiteSubtype_name, SiteSubtype_value)
	proto.RegisterEnum("ves.io.schema.site.CeSiteMode", CeSiteMode_name, CeSiteMode_value)
	golang_proto.RegisterEnum("ves.io.schema.site.CeSiteMode", CeSiteMode_name, CeSiteMode_value)
	proto.RegisterEnum("ves.io.schema.site.IPSecState", IPSecState_name, IPSecState_value)
	golang_proto.RegisterEnum("ves.io.schema.site.IPSecState", IPSecState_name, IPSecState_value)
	proto.RegisterEnum("ves.io.schema.site.IPSecRole", IPSecRole_name, IPSecRole_value)
	golang_proto.RegisterEnum("ves.io.schema.site.IPSecRole", IPSecRole_name, IPSecRole_value)
	proto.RegisterEnum("ves.io.schema.site.TunnelState", TunnelState_name, TunnelState_value)
	golang_proto.RegisterEnum("ves.io.schema.site.TunnelState", TunnelState_name, TunnelState_value)
	proto.RegisterEnum("ves.io.schema.site.TunnelRole", TunnelRole_name, TunnelRole_value)
	golang_proto.RegisterEnum("ves.io.schema.site.TunnelRole", TunnelRole_name, TunnelRole_value)
	proto.RegisterEnum("ves.io.schema.site.VTRPState", VTRPState_name, VTRPState_value)
	golang_proto.RegisterEnum("ves.io.schema.site.VTRPState", VTRPState_name, VTRPState_value)
	proto.RegisterEnum("ves.io.schema.site.ActiveState", ActiveState_name, ActiveState_value)
	golang_proto.RegisterEnum("ves.io.schema.site.ActiveState", ActiveState_name, ActiveState_value)
	proto.RegisterEnum("ves.io.schema.site.LinkQuality", LinkQuality_name, LinkQuality_value)
	golang_proto.RegisterEnum("ves.io.schema.site.LinkQuality", LinkQuality_name, LinkQuality_value)
	proto.RegisterEnum("ves.io.schema.site.LinkType", LinkType_name, LinkType_value)
	golang_proto.RegisterEnum("ves.io.schema.site.LinkType", LinkType_name, LinkType_value)
	proto.RegisterEnum("ves.io.schema.site.AddressMode", AddressMode_name, AddressMode_value)
	golang_proto.RegisterEnum("ves.io.schema.site.AddressMode", AddressMode_name, AddressMode_value)
	proto.RegisterEnum("ves.io.schema.site.SiteSoftwareOverrideType", SiteSoftwareOverrideType_name, SiteSoftwareOverrideType_value)
	golang_proto.RegisterEnum("ves.io.schema.site.SiteSoftwareOverrideType", SiteSoftwareOverrideType_name, SiteSoftwareOverrideType_value)
	proto.RegisterEnum("ves.io.schema.site.SoftwareUpgradePhase", SoftwareUpgradePhase_name, SoftwareUpgradePhase_value)
	golang_proto.RegisterEnum("ves.io.schema.site.SoftwareUpgradePhase", SoftwareUpgradePhase_name, SoftwareUpgradePhase_value)
	proto.RegisterEnum("ves.io.schema.site.ScalingPhase", ScalingPhase_name, ScalingPhase_value)
	golang_proto.RegisterEnum("ves.io.schema.site.ScalingPhase", ScalingPhase_name, ScalingPhase_value)
	proto.RegisterEnum("ves.io.schema.site.SiteState", SiteState_name, SiteState_value)
	golang_proto.RegisterEnum("ves.io.schema.site.SiteState", SiteState_name, SiteState_value)
	proto.RegisterEnum("ves.io.schema.site.UsbType", UsbType_name, UsbType_value)
	golang_proto.RegisterEnum("ves.io.schema.site.UsbType", UsbType_name, UsbType_value)
	proto.RegisterEnum("ves.io.schema.site.SiteStatusMetricsField", SiteStatusMetricsField_name, SiteStatusMetricsField_value)
	golang_proto.RegisterEnum("ves.io.schema.site.SiteStatusMetricsField", SiteStatusMetricsField_name, SiteStatusMetricsField_value)
	proto.RegisterType((*BondMembersType)(nil), "ves.io.schema.site.BondMembersType")
	golang_proto.RegisterType((*BondMembersType)(nil), "ves.io.schema.site.BondMembersType")
	proto.RegisterType((*Coordinates)(nil), "ves.io.schema.site.Coordinates")
	golang_proto.RegisterType((*Coordinates)(nil), "ves.io.schema.site.Coordinates")
	proto.RegisterType((*K8SApiServerParameters)(nil), "ves.io.schema.site.K8SApiServerParameters")
	golang_proto.RegisterType((*K8SApiServerParameters)(nil), "ves.io.schema.site.K8SApiServerParameters")
	proto.RegisterType((*DefaultUnderlayNetworkType)(nil), "ves.io.schema.site.DefaultUnderlayNetworkType")
	golang_proto.RegisterType((*DefaultUnderlayNetworkType)(nil), "ves.io.schema.site.DefaultUnderlayNetworkType")
	proto.RegisterType((*PublishVIPParamsPerAz)(nil), "ves.io.schema.site.PublishVIPParamsPerAz")
	golang_proto.RegisterType((*PublishVIPParamsPerAz)(nil), "ves.io.schema.site.PublishVIPParamsPerAz")
	proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.site.GlobalSpecType")
	golang_proto.RegisterType((*GlobalSpecType)(nil), "ves.io.schema.site.GlobalSpecType")
	proto.RegisterMapType((map[string]*K8SApiServerParameters)(nil), "ves.io.schema.site.GlobalSpecType.K8sApiServersEntry")
	golang_proto.RegisterMapType((map[string]*K8SApiServerParameters)(nil), "ves.io.schema.site.GlobalSpecType.K8sApiServersEntry")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.site.GlobalSpecType.TemplateParametersEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.site.GlobalSpecType.TemplateParametersEntry")
	proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.site.CreateSpecType")
	golang_proto.RegisterType((*CreateSpecType)(nil), "ves.io.schema.site.CreateSpecType")
	proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.site.ReplaceSpecType")
	golang_proto.RegisterType((*ReplaceSpecType)(nil), "ves.io.schema.site.ReplaceSpecType")
	proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.site.GetSpecType")
	golang_proto.RegisterType((*GetSpecType)(nil), "ves.io.schema.site.GetSpecType")
	proto.RegisterType((*VerStatusType)(nil), "ves.io.schema.site.VerStatusType")
	golang_proto.RegisterType((*VerStatusType)(nil), "ves.io.schema.site.VerStatusType")
	proto.RegisterType((*VerMasterStatusType)(nil), "ves.io.schema.site.VerMasterStatusType")
	golang_proto.RegisterType((*VerMasterStatusType)(nil), "ves.io.schema.site.VerMasterStatusType")
	proto.RegisterType((*IpsecConnectionStatus)(nil), "ves.io.schema.site.IpsecConnectionStatus")
	golang_proto.RegisterType((*IpsecConnectionStatus)(nil), "ves.io.schema.site.IpsecConnectionStatus")
	proto.RegisterType((*AresConnectionStatus)(nil), "ves.io.schema.site.AresConnectionStatus")
	golang_proto.RegisterType((*AresConnectionStatus)(nil), "ves.io.schema.site.AresConnectionStatus")
	proto.RegisterType((*InterfaceStatus)(nil), "ves.io.schema.site.InterfaceStatus")
	golang_proto.RegisterType((*InterfaceStatus)(nil), "ves.io.schema.site.InterfaceStatus")
	proto.RegisterType((*TunnelConnectionStatus)(nil), "ves.io.schema.site.TunnelConnectionStatus")
	golang_proto.RegisterType((*TunnelConnectionStatus)(nil), "ves.io.schema.site.TunnelConnectionStatus")
	proto.RegisterType((*VolterraSoftwareStatus)(nil), "ves.io.schema.site.VolterraSoftwareStatus")
	golang_proto.RegisterType((*VolterraSoftwareStatus)(nil), "ves.io.schema.site.VolterraSoftwareStatus")
	proto.RegisterType((*OperatingSystemStatus)(nil), "ves.io.schema.site.OperatingSystemStatus")
	golang_proto.RegisterType((*OperatingSystemStatus)(nil), "ves.io.schema.site.OperatingSystemStatus")
	proto.RegisterType((*DeploymentState)(nil), "ves.io.schema.site.DeploymentState")
	golang_proto.RegisterType((*DeploymentState)(nil), "ves.io.schema.site.DeploymentState")
	proto.RegisterType((*FleetDeploymentState)(nil), "ves.io.schema.site.FleetDeploymentState")
	golang_proto.RegisterType((*FleetDeploymentState)(nil), "ves.io.schema.site.FleetDeploymentState")
	proto.RegisterType((*FleetCondition)(nil), "ves.io.schema.site.FleetCondition")
	golang_proto.RegisterType((*FleetCondition)(nil), "ves.io.schema.site.FleetCondition")
	proto.RegisterType((*FleetStatus)(nil), "ves.io.schema.site.FleetStatus")
	golang_proto.RegisterType((*FleetStatus)(nil), "ves.io.schema.site.FleetStatus")
	proto.RegisterType((*ScalingStatus)(nil), "ves.io.schema.site.ScalingStatus")
	golang_proto.RegisterType((*ScalingStatus)(nil), "ves.io.schema.site.ScalingStatus")
	proto.RegisterType((*NodeInfo)(nil), "ves.io.schema.site.NodeInfo")
	golang_proto.RegisterType((*NodeInfo)(nil), "ves.io.schema.site.NodeInfo")
	proto.RegisterType((*OsInfo)(nil), "ves.io.schema.site.OsInfo")
	golang_proto.RegisterType((*OsInfo)(nil), "ves.io.schema.site.OsInfo")
	proto.RegisterType((*OS)(nil), "ves.io.schema.site.OS")
	golang_proto.RegisterType((*OS)(nil), "ves.io.schema.site.OS")
	proto.RegisterType((*Kernel)(nil), "ves.io.schema.site.Kernel")
	golang_proto.RegisterType((*Kernel)(nil), "ves.io.schema.site.Kernel")
	proto.RegisterType((*Product)(nil), "ves.io.schema.site.Product")
	golang_proto.RegisterType((*Product)(nil), "ves.io.schema.site.Product")
	proto.RegisterType((*Board)(nil), "ves.io.schema.site.Board")
	golang_proto.RegisterType((*Board)(nil), "ves.io.schema.site.Board")
	proto.RegisterType((*Chassis)(nil), "ves.io.schema.site.Chassis")
	golang_proto.RegisterType((*Chassis)(nil), "ves.io.schema.site.Chassis")
	proto.RegisterType((*Bios)(nil), "ves.io.schema.site.Bios")
	golang_proto.RegisterType((*Bios)(nil), "ves.io.schema.site.Bios")
	proto.RegisterType((*Cpu)(nil), "ves.io.schema.site.Cpu")
	golang_proto.RegisterType((*Cpu)(nil), "ves.io.schema.site.Cpu")
	proto.RegisterType((*Memory)(nil), "ves.io.schema.site.Memory")
	golang_proto.RegisterType((*Memory)(nil), "ves.io.schema.site.Memory")
	proto.RegisterType((*StorageDevice)(nil), "ves.io.schema.site.StorageDevice")
	golang_proto.RegisterType((*StorageDevice)(nil), "ves.io.schema.site.StorageDevice")
	proto.RegisterType((*NetworkDevice)(nil), "ves.io.schema.site.NetworkDevice")
	golang_proto.RegisterType((*NetworkDevice)(nil), "ves.io.schema.site.NetworkDevice")
	proto.RegisterType((*USBDevice)(nil), "ves.io.schema.site.USBDevice")
	golang_proto.RegisterType((*USBDevice)(nil), "ves.io.schema.site.USBDevice")
	proto.RegisterType((*GPU)(nil), "ves.io.schema.site.GPU")
	golang_proto.RegisterType((*GPU)(nil), "ves.io.schema.site.GPU")
	proto.RegisterType((*GPUDevice)(nil), "ves.io.schema.site.GPUDevice")
	golang_proto.RegisterType((*GPUDevice)(nil), "ves.io.schema.site.GPUDevice")
	proto.RegisterType((*SiteStatusMetricsFieldData)(nil), "ves.io.schema.site.SiteStatusMetricsFieldData")
	golang_proto.RegisterType((*SiteStatusMetricsFieldData)(nil), "ves.io.schema.site.SiteStatusMetricsFieldData")
	proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.site.SiteStatusMetricsFieldData.KeyEntry")
	golang_proto.RegisterMapType((map[string]string)(nil), "ves.io.schema.site.SiteStatusMetricsFieldData.KeyEntry")
	proto.RegisterType((*SiteStatusMetricsData)(nil), "ves.io.schema.site.SiteStatusMetricsData")
	golang_proto.RegisterType((*SiteStatusMetricsData)(nil), "ves.io.schema.site.SiteStatusMetricsData")
	proto.RegisterType((*CreateKubeConfigReq)(nil), "ves.io.schema.site.CreateKubeConfigReq")
	golang_proto.RegisterType((*CreateKubeConfigReq)(nil), "ves.io.schema.site.CreateKubeConfigReq")
	proto.RegisterType((*ListKubeConfigReq)(nil), "ves.io.schema.site.ListKubeConfigReq")
	golang_proto.RegisterType((*ListKubeConfigReq)(nil), "ves.io.schema.site.ListKubeConfigReq")
	proto.RegisterType((*ListKubeConfigRspItem)(nil), "ves.io.schema.site.ListKubeConfigRspItem")
	golang_proto.RegisterType((*ListKubeConfigRspItem)(nil), "ves.io.schema.site.ListKubeConfigRspItem")
	proto.RegisterType((*ListKubeConfigRsp)(nil), "ves.io.schema.site.ListKubeConfigRsp")
	golang_proto.RegisterType((*ListKubeConfigRsp)(nil), "ves.io.schema.site.ListKubeConfigRsp")
	proto.RegisterType((*GlobalAccessCheckRequest)(nil), "ves.io.schema.site.GlobalAccessCheckRequest")
	golang_proto.RegisterType((*GlobalAccessCheckRequest)(nil), "ves.io.schema.site.GlobalAccessCheckRequest")
	proto.RegisterType((*GlobalAccessCheckResponse)(nil), "ves.io.schema.site.GlobalAccessCheckResponse")
	golang_proto.RegisterType((*GlobalAccessCheckResponse)(nil), "ves.io.schema.site.GlobalAccessCheckResponse")
	proto.RegisterType((*CreateGlobalKubeConfigReq)(nil), "ves.io.schema.site.CreateGlobalKubeConfigReq")
	golang_proto.RegisterType((*CreateGlobalKubeConfigReq)(nil), "ves.io.schema.site.CreateGlobalKubeConfigReq")
	proto.RegisterType((*ListGlobalKubeConfigReq)(nil), "ves.io.schema.site.ListGlobalKubeConfigReq")
	golang_proto.RegisterType((*ListGlobalKubeConfigReq)(nil), "ves.io.schema.site.ListGlobalKubeConfigReq")
	proto.RegisterType((*RevokeKubeConfigReq)(nil), "ves.io.schema.site.RevokeKubeConfigReq")
	golang_proto.RegisterType((*RevokeKubeConfigReq)(nil), "ves.io.schema.site.RevokeKubeConfigReq")
	proto.RegisterType((*KubeConfigStatusRsp)(nil), "ves.io.schema.site.KubeConfigStatusRsp")
	golang_proto.RegisterType((*KubeConfigStatusRsp)(nil), "ves.io.schema.site.KubeConfigStatusRsp")
}

func init() { proto.RegisterFile("ves.io/schema/site/types.proto", fileDescriptor_3b1b2598d34ae46b) }
func init() {
	golang_proto.RegisterFile("ves.io/schema/site/types.proto", fileDescriptor_3b1b2598d34ae46b)
}

var fileDescriptor_3b1b2598d34ae46b = []byte{
	// 6303 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x7c, 0x5d, 0x6c, 0x64, 0xc7,
	0x75, 0x26, 0x6f, 0xff, 0x90, 0xdd, 0xa7, 0xf9, 0x73, 0x59, 0xc3, 0xe1, 0xf4, 0x50, 0x12, 0x67,
	0xd4, 0xf6, 0x1a, 0x23, 0x8a, 0xe4, 0x88, 0xcd, 0x99, 0xd1, 0x58, 0x96, 0xb4, 0x22, 0x9b, 0x4d,
	0x4e, 0xcf, 0x90, 0xdd, 0x54, 0x75, 0x93, 0xb3, 0xda, 0xb5, 0x71, 0xf7, 0xfe, 0x14, 0xc9, 0x6b,
	0x76, 0xf7, 0xbd, 0xba, 0x3f, 0x3d, 0x33, 0xda, 0xd5, 0x5a, 0xd6, 0x7a, 0xbd, 0xf6, 0x6e, 0xec,
	0x38, 0xca, 0x4b, 0x90, 0xc0, 0x41, 0x80, 0x18, 0x46, 0x60, 0x20, 0x2f, 0x86, 0x9f, 0x22, 0xc0,
	0x10, 0x92, 0x97, 0x20, 0x40, 0x00, 0x25, 0x41, 0x12, 0x21, 0x4f, 0xf1, 0x08, 0x70, 0x9c, 0x37,
	0x23, 0x08, 0x90, 0xbc, 0xe4, 0x07, 0xf5, 0x73, 0xfb, 0xfe, 0x74, 0xf7, 0x68, 0xc6, 0x96, 0x14,
	0x1b, 0xd0, 0xbc, 0xb0, 0xea, 0xd4, 0x77, 0x4e, 0x9d, 0x3a, 0x75, 0xea, 0xd4, 0xa9, 0xba, 0xd5,
	0x03, 0x8b, 0x3d, 0xe2, 0xae, 0x9a, 0xd6, 0x65, 0x57, 0x3f, 0x21, 0x1d, 0xf5, 0xb2, 0x6b, 0x7a,
	0xe4, 0xb2, 0x77, 0xcf, 0x26, 0xee, 0xaa, 0xed, 0x58, 0x9e, 0x85, 0x10, 0x6f, 0x5f, 0xe5, 0xed,
	0xab, 0xb4, 0x7d, 0x61, 0xe5, 0xd8, 0xf4, 0x4e, 0x7c, 0x6d, 0x55, 0xb7, 0x3a, 0x97, 0x8f, 0xad,
	0x63, 0xeb, 0x32, 0x83, 0x6a, 0xfe, 0x11, 0xab, 0xb1, 0x0a, 0x2b, 0x71, 0x11, 0x0b, 0x17, 0x8e,
	0x2d, 0xeb, 0xb8, 0x4d, 0x42, 0x94, 0x67, 0x76, 0x88, 0xeb, 0xa9, 0x1d, 0x5b, 0x00, 0xce, 0xc5,
	0x75, 0xe8, 0x12, 0x4f, 0x34, 0x3c, 0x16, 0x6f, 0xb0, 0x6c, 0xcf, 0xb4, 0xba, 0x42, 0xb3, 0x85,
	0x27, 0xe2, 0x8d, 0x76, 0xcf, 0x53, 0x22, 0x8a, 0x2f, 0x9c, 0x8f, 0x37, 0x47, 0x9b, 0x1e, 0x8f,
	0x37, 0xf5, 0xd4, 0xb6, 0x69, 0xa8, 0x1e, 0x11, 0xad, 0x17, 0x13, 0xad, 0x26, 0xb9, 0xa3, 0xc4,
	0x7a, 0x2e, 0xe9, 0x30, 0xb3, 0x69, 0x75, 0x8d, 0x3d, 0xd2, 0xd1, 0x88, 0xe3, 0xb6, 0xee, 0xd9,
	0x04, 0x21, 0xc8, 0x74, 0xd5, 0x0e, 0x29, 0x4a, 0x17, 0xa5, 0x4b, 0x79, 0xcc, 0xca, 0xe8, 0x09,
	0x80, 0xb6, 0xd9, 0x3d, 0x55, 0x5c, 0x4f, 0xf5, 0x48, 0x31, 0x75, 0x51, 0xba, 0x94, 0xc3, 0x79,
	0x4a, 0x69, 0x52, 0x42, 0xd8, 0x6c, 0x13, 0x62, 0x14, 0xd3, 0x17, 0xa5, 0x4b, 0x53, 0xa2, 0x99,
	0x12, 0x4a, 0x1d, 0x28, 0x54, 0x2c, 0xcb, 0x31, 0xcc, 0xae, 0xea, 0x11, 0x17, 0xad, 0x40, 0xae,
	0xad, 0x7a, 0xa6, 0xe7, 0x1b, 0xbc, 0x93, 0xd4, 0xe6, 0xec, 0x1f, 0xfc, 0xfd, 0x3b, 0xe9, 0x49,
	0x80, 0x27, 0xc6, 0xc6, 0x7e, 0xb0, 0xb9, 0x32, 0x36, 0xf6, 0x83, 0x3f, 0xc4, 0x7d, 0x08, 0xba,
	0x0c, 0xf9, 0xb6, 0xd5, 0x3d, 0xe6, 0xf8, 0x54, 0x12, 0x7f, 0xa5, 0xb2, 0x32, 0x36, 0x76, 0xe5,
	0x8f, 0x70, 0x88, 0x29, 0x2d, 0xc2, 0xfc, 0xad, 0xeb, 0xcd, 0x0d, 0xdb, 0x6c, 0x12, 0xa7, 0x47,
	0x9c, 0x7d, 0xd5, 0x51, 0x3b, 0xc4, 0x23, 0x8e, 0x7b, 0x33, 0x93, 0x93, 0xe4, 0x54, 0xe9, 0xaf,
	0x24, 0x58, 0xd8, 0x22, 0x47, 0xaa, 0xdf, 0xf6, 0x0e, 0xba, 0x06, 0x71, 0xda, 0xea, 0xbd, 0x3a,
	0xf1, 0xee, 0x58, 0xce, 0x29, 0x1b, 0xff, 0x16, 0x20, 0xea, 0x1a, 0x4a, 0xdb, 0xd2, 0xd5, 0xb6,
	0x62, 0xf9, 0x9e, 0x6b, 0x8a, 0x8e, 0x0b, 0xe5, 0xb9, 0xd5, 0xb8, 0x0f, 0x55, 0x3b, 0xb6, 0x77,
	0xef, 0xc6, 0x18, 0x96, 0x29, 0xc7, 0x2e, 0x65, 0x68, 0x70, 0x3c, 0xda, 0x84, 0xd9, 0x88, 0x14,
	0xb3, 0xcb, 0x84, 0xa4, 0x1f, 0x28, 0x64, 0xa6, 0x2f, 0xa4, 0xc6, 0xe0, 0x9b, 0x97, 0xe0, 0xac,
	0xed, 0x98, 0x3d, 0xd5, 0x23, 0x8a, 0xaa, 0xeb, 0xc4, 0x75, 0x15, 0xfd, 0xc4, 0x32, 0x75, 0x82,
	0x66, 0xde, 0x79, 0x5b, 0x4a, 0xbd, 0xfb, 0xb6, 0x24, 0xdd, 0x7f, 0x5b, 0x4a, 0x97, 0x97, 0xd7,
	0xc5, 0xc0, 0xde, 0x43, 0x70, 0x76, 0xdf, 0xd7, 0xda, 0xa6, 0x7b, 0x72, 0x58, 0xdb, 0x67, 0xe3,
	0x76, 0xf7, 0x89, 0xb3, 0xf1, 0x1a, 0xda, 0x00, 0xe0, 0x2a, 0x28, 0x3d, 0xd3, 0x2e, 0x4a, 0x17,
	0xd3, 0x97, 0xf2, 0x9b, 0x25, 0x6a, 0xc4, 0xfc, 0x5b, 0xd2, 0x78, 0x29, 0xe3, 0xa4, 0xee, 0x4a,
	0xb4, 0x96, 0x7d, 0x4b, 0x4a, 0xc9, 0xe9, 0xa0, 0x54, 0x94, 0x70, 0x9e, 0x73, 0x1d, 0x9a, 0x36,
	0xda, 0x83, 0x82, 0xb0, 0x05, 0x93, 0x91, 0x62, 0x32, 0x96, 0x3f, 0x48, 0x46, 0x4e, 0x8a, 0x48,
	0x03, 0x21, 0x80, 0x8a, 0xbb, 0x06, 0xb3, 0x11, 0x71, 0x8a, 0xce, 0x5c, 0x8e, 0xda, 0x27, 0xbf,
	0x09, 0x8c, 0xc5, 0x49, 0x17, 0xdf, 0x48, 0xe1, 0x99, 0x90, 0xa5, 0xc2, 0x3c, 0xf1, 0x0a, 0xc8,
	0xe1, 0x48, 0x04, 0x5b, 0x66, 0x80, 0x6d, 0xba, 0xaf, 0x37, 0xe7, 0xfa, 0xa1, 0x0c, 0x13, 0xea,
	0x6b, 0x0a, 0x43, 0x67, 0x19, 0xfa, 0x3b, 0x32, 0x85, 0xff, 0xb6, 0xec, 0xfc, 0x96, 0x8c, 0x67,
	0x54, 0x7b, 0xa5, 0x6b, 0x39, 0xde, 0x09, 0x51, 0x5d, 0x6f, 0x65, 0x4d, 0x4d, 0x12, 0xf4, 0x24,
	0xc1, 0x60, 0x04, 0xd7, 0xf2, 0xe3, 0x2c, 0x11, 0x82, 0x96, 0x24, 0xe8, 0x78, 0x8a, 0xf8, 0x2b,
	0x3a, 0xe9, 0x7a, 0x8e, 0xda, 0xa6, 0x0c, 0xb1, 0xaa, 0x16, 0xaf, 0xea, 0x18, 0x88, 0xbf, 0x72,
	0x87, 0x70, 0xd1, 0x61, 0x59, 0x8b, 0x94, 0x23, 0x98, 0xf5, 0x08, 0x66, 0x3d, 0x82, 0x59, 0xd7,
	0x31, 0xb8, 0xea, 0x4a, 0xa0, 0x62, 0x58, 0xd6, 0x22, 0x65, 0x1d, 0x83, 0xef, 0x86, 0x98, 0x7e,
	0x59, 0x8b, 0x94, 0xa3, 0x18, 0x23, 0x52, 0x26, 0x91, 0xf2, 0x51, 0x58, 0x2e, 0x47, 0xe4, 0x94,
	0x23, 0x72, 0xca, 0x5c, 0x0e, 0xd3, 0x4d, 0x60, 0x78, 0x59, 0x8b, 0x94, 0xa3, 0x18, 0x03, 0x4f,
	0xe9, 0x6a, 0xcc, 0x68, 0xd1, 0xaa, 0x16, 0xaf, 0x1a, 0xb8, 0xa0, 0x1e, 0x71, 0x93, 0x53, 0x68,
	0xa4, 0xa2, 0x45, 0x2b, 0x3a, 0x06, 0xd5, 0x0e, 0xc7, 0xdb, 0x2f, 0x6b, 0x91, 0xb2, 0x8e, 0x0b,
	0xc1, 0xec, 0x71, 0x51, 0x76, 0x54, 0x94, 0x1d, 0x8a, 0x8a, 0xfb, 0x45, 0x39, 0xe9, 0x39, 0x65,
	0x2d, 0x49, 0x18, 0x60, 0x49, 0xba, 0x52, 0x39, 0xe9, 0x4a, 0xe5, 0xa4, 0x2b, 0x95, 0x75, 0x5c,
	0x20, 0x7e, 0x44, 0xbb, 0xb0, 0xa2, 0x45, 0x2b, 0x1c, 0xc6, 0xba, 0x0a, 0x60, 0xa2, 0xa2, 0x45,
	0x2b, 0x11, 0x3f, 0x2a, 0x47, 0xfc, 0xa8, 0x1c, 0xf1, 0x23, 0xda, 0x63, 0x87, 0x44, 0x7a, 0x0c,
	0x2b, 0x5a, 0xb4, 0x12, 0x99, 0xba, 0xb5, 0xc8, 0xf4, 0xae, 0xe9, 0x58, 0x5a, 0xc3, 0x52, 0x19,
	0x4b, 0xeb, 0x78, 0x52, 0x75, 0x4d, 0xee, 0x79, 0x6b, 0x2b, 0x6a, 0xac, 0xa6, 0xc5, 0x6a, 0x7a,
	0xa4, 0x56, 0x8e, 0x21, 0xcb, 0x31, 0x64, 0x79, 0x45, 0xc7, 0xb3, 0xac, 0xd6, 0xb7, 0x29, 0x15,
	0x3c, 0x40, 0xd2, 0x06, 0x49, 0x03, 0x8c, 0xe5, 0x41, 0xc6, 0xf2, 0x20, 0xe3, 0x90, 0x1e, 0xd7,
	0x07, 0x19, 0xd7, 0x07, 0x19, 0xd7, 0x57, 0x74, 0x3c, 0xc5, 0x48, 0xcc, 0x5c, 0x54, 0xcd, 0x58,
	0x55, 0x8b, 0x57, 0x83, 0x5e, 0xfa, 0x13, 0x1f, 0x8e, 0x2b, 0x42, 0xd2, 0x06, 0x49, 0x03, 0x8c,
	0xe5, 0x41, 0xc6, 0xf2, 0x20, 0x23, 0x1d, 0xd7, 0xbc, 0xea, 0xbb, 0x74, 0x31, 0x25, 0xbb, 0x1d,
	0x4e, 0xd7, 0x46, 0xd0, 0x75, 0x3c, 0x43, 0x7c, 0xc7, 0xb2, 0x09, 0x1f, 0x3b, 0x15, 0x90, 0x20,
	0x68, 0x49, 0x82, 0x8e, 0xa7, 0x05, 0x81, 0x7a, 0x0c, 0x05, 0xc4, 0xeb, 0xc9, 0x76, 0x23, 0x56,
	0xa7, 0x03, 0x8c, 0xd7, 0xb5, 0x44, 0x3d, 0xce, 0xbf, 0x9e, 0xc0, 0xaf, 0x27, 0xf0, 0xeb, 0x09,
	0xfc, 0x95, 0x04, 0xfe, 0x4a, 0x02, 0x7f, 0x25, 0x81, 0xbf, 0x96, 0xc0, 0x5f, 0x4b, 0xe0, 0xaf,
	0xad, 0xe8, 0xf8, 0x3c, 0x1b, 0xb9, 0xda, 0x21, 0x8e, 0xa9, 0x27, 0x9c, 0x77, 0x64, 0x93, 0x36,
	0xba, 0x49, 0xc7, 0x73, 0x6c, 0x06, 0x82, 0xa6, 0x40, 0xd6, 0x30, 0xaa, 0x36, 0x94, 0xaa, 0xe3,
	0x29, 0xdf, 0x0d, 0xa2, 0x29, 0x73, 0xce, 0x68, 0x55, 0x8b, 0x57, 0x13, 0xe0, 0x30, 0xf6, 0x53,
	0x64, 0x58, 0xd6, 0x23, 0xe5, 0x70, 0xdf, 0xa0, 0xe6, 0x0c, 0xcb, 0x5a, 0xa4, 0x1c, 0x06, 0x90,
	0xb5, 0x15, 0x35, 0x52, 0xd6, 0x22, 0xe5, 0x10, 0x53, 0x8e, 0x60, 0xca, 0x11, 0x4c, 0x39, 0x82,
	0x59, 0x8f, 0x60, 0xd6, 0x23, 0x98, 0xf5, 0x08, 0xe6, 0x4a, 0x04, 0x73, 0x25, 0x82, 0xa1, 0xfa,
	0x8c, 0xab, 0xaf, 0xd5, 0xd5, 0x0e, 0x29, 0xfd, 0xcb, 0x79, 0x98, 0xde, 0x69, 0x5b, 0x9a, 0xda,
	0x6e, 0xda, 0x44, 0x67, 0x79, 0x62, 0x15, 0xf2, 0x2c, 0xc3, 0xa3, 0xe9, 0x38, 0xcb, 0x63, 0xa7,
	0xcb, 0x8f, 0xaf, 0x0e, 0x1e, 0x31, 0x56, 0x9b, 0xa6, 0x47, 0x28, 0x83, 0x48, 0x50, 0xde, 0x94,
	0x52, 0x17, 0xc7, 0x70, 0xce, 0x15, 0x54, 0xb4, 0x09, 0x93, 0x4c, 0x8c, 0xeb, 0x6b, 0x4c, 0x52,
	0x96, 0x49, 0xba, 0x30, 0x4a, 0x52, 0x93, 0xc3, 0x70, 0xc1, 0x0d, 0x2b, 0xe8, 0xd3, 0x30, 0xa1,
	0x1a, 0x86, 0x43, 0x5c, 0x97, 0xe5, 0xa9, 0xf1, 0x5c, 0x28, 0x68, 0x42, 0x1b, 0x50, 0xd0, 0xc3,
	0x34, 0x5c, 0x24, 0xa3, 0x43, 0x3b, 0x8a, 0x64, 0xeb, 0x38, 0xca, 0x83, 0x6e, 0xc0, 0xa4, 0x6e,
	0x75, 0xbb, 0x44, 0xf7, 0x88, 0xa1, 0x38, 0xa4, 0x78, 0x7c, 0x31, 0x7d, 0xa9, 0x30, 0x30, 0xec,
	0x86, 0xf6, 0x45, 0xa2, 0x7b, 0x98, 0x1c, 0xb1, 0x61, 0x4f, 0x7c, 0xef, 0xf5, 0x0c, 0x95, 0x4a,
	0x25, 0x09, 0x56, 0x4c, 0xd0, 0xe7, 0xe1, 0x5c, 0x54, 0x92, 0x72, 0x64, 0x39, 0x8a, 0x6e, 0x75,
	0x8f, 0xcc, 0xe3, 0xe2, 0xc9, 0xa3, 0x08, 0x9d, 0x8b, 0x08, 0xdd, 0xb6, 0x9c, 0x0a, 0x13, 0x81,
	0xae, 0x40, 0xa6, 0x47, 0x8e, 0xd5, 0xa2, 0xc9, 0xc6, 0x78, 0x31, 0x21, 0x8a, 0x9e, 0x0b, 0x4c,
	0x9d, 0x84, 0x07, 0x03, 0xcc, 0xd0, 0xe8, 0x05, 0xc8, 0xab, 0x0e, 0x71, 0x95, 0xb6, 0xe9, 0x7a,
	0xc5, 0x2f, 0x32, 0x2d, 0x3e, 0x98, 0x35, 0x47, 0x59, 0x76, 0x4d, 0xd7, 0x43, 0xd7, 0x20, 0xeb,
	0xa8, 0xa7, 0xaa, 0x53, 0x3c, 0x7d, 0xc8, 0x5e, 0x39, 0x1c, 0x3d, 0x0b, 0x59, 0xcb, 0x26, 0x8e,
	0x5a, 0xfc, 0x3f, 0xd2, 0xc3, 0x32, 0x32, 0x3c, 0xba, 0x02, 0x53, 0xf4, 0x40, 0x66, 0xea, 0x8a,
	0x63, 0xf9, 0x74, 0x4a, 0xdb, 0x2c, 0x29, 0x9f, 0xa1, 0x93, 0x0f, 0x6f, 0x49, 0x13, 0xa5, 0xac,
	0x93, 0xfe, 0x67, 0x49, 0xc2, 0x93, 0x1c, 0x85, 0x19, 0x08, 0x7d, 0x01, 0x66, 0x4e, 0xaf, 0xbb,
	0x8a, 0x6a, 0x9b, 0x8a, 0xcb, 0x0e, 0x48, 0x6e, 0xb1, 0xc3, 0xc6, 0x7a, 0x75, 0x98, 0x2b, 0xc4,
	0x9d, 0x7e, 0xf5, 0xd6, 0x75, 0xb7, 0x7f, 0xb0, 0x72, 0xab, 0x5d, 0xcf, 0xb9, 0x87, 0xa7, 0x4e,
	0xa3, 0x34, 0xf4, 0x19, 0xc8, 0xdb, 0xf4, 0x0c, 0xa2, 0x2b, 0xa6, 0x5d, 0xec, 0x32, 0x6f, 0xcc,
	0x53, 0x85, 0x32, 0x4e, 0xca, 0x96, 0x70, 0x8e, 0xb7, 0xd5, 0x6c, 0xf4, 0x14, 0x40, 0x70, 0xb8,
	0x31, 0xed, 0xe2, 0xff, 0x93, 0x92, 0xc8, 0xbc, 0x68, 0xad, 0xd9, 0xe8, 0x59, 0x40, 0xa6, 0xed,
	0x12, 0x5d, 0x71, 0xdd, 0x36, 0x4b, 0xfb, 0x8f, 0x5e, 0x35, 0xba, 0xc5, 0xff, 0x1f, 0x67, 0x39,
	0x91, 0xf0, 0x0c, 0x43, 0x35, 0xdd, 0xf6, 0xa1, 0x69, 0x6f, 0xbf, 0x6a, 0x74, 0xd1, 0x25, 0x00,
	0xbd, 0xed, 0xbb, 0x1e, 0x71, 0x68, 0x1f, 0xd6, 0x40, 0x17, 0xa2, 0xb1, 0x66, 0xa3, 0x6d, 0x98,
	0x66, 0x53, 0xdf, 0xf3, 0x1c, 0x9b, 0xcf, 0xbf, 0xfd, 0x90, 0xf3, 0x3f, 0x49, 0xf9, 0x0e, 0x3d,
	0xc7, 0x66, 0x3e, 0xf0, 0x1c, 0x9c, 0xef, 0x59, 0x6d, 0x8f, 0x38, 0x8e, 0xaa, 0xb8, 0xd6, 0x91,
	0x77, 0x47, 0x75, 0x88, 0x42, 0xed, 0x62, 0x5a, 0xdd, 0xe2, 0xab, 0xec, 0x44, 0x7d, 0x2e, 0x00,
	0x34, 0x45, 0xfb, 0x21, 0x6f, 0xa6, 0xda, 0x46, 0x0e, 0x69, 0xce, 0x80, 0xb6, 0xe1, 0x59, 0x6c,
	0x29, 0x7e, 0x16, 0xbb, 0x9b, 0x84, 0x46, 0x0f, 0x5a, 0x47, 0x30, 0x4b, 0x4d, 0x66, 0xb3, 0xd3,
	0xa0, 0x62, 0x13, 0x47, 0x51, 0x5f, 0x2b, 0x7e, 0x4b, 0x62, 0xa3, 0x7b, 0x6a, 0xd8, 0x8c, 0x0f,
	0x3d, 0x41, 0x86, 0x4e, 0xb5, 0x94, 0x7d, 0x66, 0x79, 0x6d, 0x79, 0x1d, 0x4f, 0xf7, 0x4c, 0x3b,
	0x7a, 0xc4, 0x7c, 0x11, 0xa6, 0x68, 0x3f, 0x3d, 0xc7, 0xb1, 0x95, 0x8e, 0x65, 0x90, 0xe2, 0x3d,
	0x16, 0xc8, 0x16, 0x12, 0x5d, 0x1c, 0x9a, 0xf6, 0xa1, 0xe3, 0xd8, 0x2d, 0x16, 0xc3, 0x7a, 0xbc,
	0xb2, 0x67, 0x19, 0x04, 0x59, 0x50, 0x34, 0xf8, 0xa1, 0x5c, 0xf1, 0xc5, 0xa9, 0x5c, 0xe9, 0xf2,
	0x63, 0x79, 0xf1, 0x1b, 0x7c, 0x61, 0xac, 0x0e, 0x53, 0x77, 0xf4, 0x49, 0x7e, 0x33, 0xf3, 0xce,
	0xdb, 0x92, 0x84, 0xe7, 0x8d, 0xa1, 0x08, 0xf4, 0xdf, 0xe0, 0x3c, 0x8f, 0xdf, 0x96, 0xc2, 0xfe,
	0x8a, 0xce, 0x78, 0x3c, 0x7f, 0x8d, 0x29, 0xff, 0xe4, 0x80, 0xf2, 0x8e, 0xe7, 0xab, 0xed, 0x48,
	0x1f, 0xf8, 0x2c, 0x0b, 0xe4, 0x16, 0x0d, 0xcd, 0xd1, 0x4b, 0x84, 0x17, 0x60, 0x3e, 0x26, 0xdc,
	0xf3, 0xbb, 0x5d, 0xd2, 0xa6, 0x5e, 0xe8, 0x26, 0x27, 0x0b, 0x85, 0x12, 0x5a, 0x0c, 0x55, 0xb3,
	0xd1, 0xc9, 0x30, 0x37, 0xb2, 0x7a, 0xc4, 0x31, 0x0d, 0x52, 0xf4, 0x98, 0x6e, 0xcb, 0x23, 0x77,
	0x08, 0x81, 0x6f, 0xf4, 0x88, 0x43, 0xf1, 0x4c, 0xcd, 0x01, 0xa7, 0x6b, 0x70, 0x61, 0x68, 0x05,
	0xa6, 0xb4, 0x63, 0x9b, 0x07, 0x10, 0x47, 0x31, 0x8d, 0xa2, 0x9f, 0xd4, 0xaf, 0xa0, 0x1d, 0xdb,
	0x2c, 0x74, 0x38, 0x35, 0x03, 0xad, 0x83, 0x4c, 0xe1, 0x36, 0xa1, 0x7e, 0x24, 0xb6, 0x9c, 0x5e,
	0x92, 0x63, 0x5a, 0x3b, 0xb6, 0xf7, 0x09, 0x71, 0x36, 0xc4, 0xc6, 0x73, 0x0a, 0x67, 0x3c, 0xd2,
	0xb1, 0xdb, 0x74, 0xad, 0xdb, 0xfd, 0x95, 0x53, 0xbc, 0xc3, 0x7c, 0xf0, 0xb9, 0x87, 0x88, 0x3a,
	0x2d, 0xc1, 0x1d, 0x2e, 0x3b, 0x1e, 0x7a, 0x90, 0x37, 0xd0, 0x80, 0xae, 0xc1, 0xac, 0x58, 0x45,
	0xf4, 0xb4, 0xcf, 0x23, 0x5c, 0xf1, 0x7f, 0x24, 0x55, 0x14, 0x97, 0x08, 0xf5, 0x3e, 0x04, 0x5d,
	0x07, 0x14, 0xac, 0xa9, 0x08, 0xe3, 0xff, 0x4c, 0x32, 0x06, 0xb7, 0x16, 0x11, 0xce, 0x4d, 0x40,
	0x06, 0x71, 0x4d, 0x87, 0x18, 0x8a, 0x6d, 0x59, 0x6d, 0x45, 0xb7, 0xfc, 0xae, 0x57, 0x7c, 0xfd,
	0xa2, 0x74, 0x29, 0xbb, 0x39, 0x47, 0x39, 0x67, 0x16, 0xa6, 0x8a, 0x2f, 0x5d, 0xfa, 0xb7, 0xe0,
	0x9f, 0x84, 0x65, 0x81, 0xdf, 0xb7, 0xac, 0x76, 0x85, 0xa2, 0xd1, 0x1d, 0x28, 0x08, 0x17, 0x61,
	0xee, 0xf7, 0xbf, 0xd8, 0x14, 0x7f, 0x2a, 0x19, 0x7c, 0x12, 0x8e, 0xc2, 0x9c, 0x7c, 0xed, 0x6f,
	0xde, 0x96, 0x2e, 0x36, 0x6b, 0xad, 0xaa, 0xd2, 0x6a, 0x28, 0xfc, 0xef, 0x41, 0xbd, 0x5e, 0xdd,
	0x55, 0x6a, 0xfb, 0xcd, 0x6a, 0x45, 0x69, 0x60, 0xa5, 0xd9, 0xdc, 0xa5, 0x5a, 0xe4, 0xde, 0x94,
	0xb2, 0x0b, 0xe9, 0x31, 0x29, 0x85, 0xc1, 0xeb, 0xb3, 0xa3, 0xe7, 0x01, 0x78, 0xfa, 0xc1, 0x6e,
	0xf6, 0xbe, 0xc4, 0xfa, 0x7d, 0x62, 0xa4, 0x6b, 0x51, 0x10, 0x66, 0x69, 0x0f, 0xbf, 0xf8, 0xfb,
	0x2c, 0x14, 0xd9, 0x56, 0xe4, 0x99, 0xdd, 0x63, 0xc5, 0xbd, 0xe7, 0x7a, 0xa4, 0xd3, 0x8f, 0x76,
	0x6f, 0xf0, 0x0b, 0xc4, 0xf9, 0x3e, 0xa0, 0xc9, 0xda, 0x83, 0x68, 0xf7, 0x22, 0xe4, 0x3b, 0xaa,
	0x23, 0x36, 0xdb, 0x2f, 0x4b, 0x0f, 0xbb, 0xdb, 0x52, 0x1e, 0x16, 0x69, 0x77, 0x60, 0x9a, 0xf1,
	0x87, 0x11, 0xfb, 0xcd, 0x87, 0x15, 0x32, 0x49, 0x19, 0xfb, 0x21, 0xfb, 0x79, 0x38, 0x23, 0x4c,
	0x6f, 0x10, 0xd5, 0x50, 0x3c, 0xb3, 0x43, 0x2c, 0xdf, 0x2b, 0xfe, 0x6f, 0xaa, 0xfe, 0xd4, 0x66,
	0x81, 0x9a, 0x6e, 0x7c, 0x29, 0x53, 0xfc, 0x9d, 0x7f, 0x05, 0x3c, 0xcb, 0x81, 0x5b, 0x44, 0x35,
	0x5a, 0x1c, 0x86, 0xce, 0xc1, 0xb8, 0x43, 0x8e, 0xe9, 0x78, 0xbf, 0xc2, 0xc7, 0x2b, 0xaa, 0x68,
	0x03, 0x26, 0x75, 0xc2, 0x17, 0x3f, 0x0b, 0x87, 0x5f, 0xe5, 0x29, 0xe2, 0xe2, 0xd0, 0x7c, 0x8b,
	0x50, 0xeb, 0xd2, 0x30, 0x88, 0x41, 0xef, 0x97, 0xd1, 0x75, 0x98, 0xeb, 0x5a, 0x8a, 0x47, 0xba,
	0x6a, 0xd7, 0x53, 0xcc, 0xae, 0xd2, 0xa3, 0xfb, 0x76, 0xd7, 0x2d, 0xfe, 0x5f, 0x2a, 0x2a, 0xb7,
	0x39, 0xf1, 0xde, 0xeb, 0xd2, 0x4f, 0x68, 0x84, 0x93, 0xbb, 0x56, 0x8b, 0x81, 0x6a, 0xdd, 0xc3,
	0xd3, 0xeb, 0x6e, 0xdd, 0x45, 0xd7, 0xa1, 0xc8, 0x2f, 0x1e, 0xd9, 0x4e, 0xcf, 0xef, 0x0e, 0x49,
	0x57, 0xd5, 0xda, 0xc4, 0x28, 0x7e, 0x8d, 0x71, 0xe3, 0xb3, 0x0c, 0x40, 0xf7, 0x73, 0xd6, 0x5c,
	0xe5, 0xad, 0xa8, 0x0d, 0x88, 0xf2, 0x04, 0xdb, 0x26, 0xcd, 0x12, 0x8e, 0xef, 0x14, 0xbf, 0x2e,
	0x3d, 0x44, 0x4e, 0x76, 0xf1, 0x7b, 0xaf, 0x4f, 0xf6, 0x78, 0x84, 0x54, 0x4e, 0x2c, 0xd7, 0x13,
	0xea, 0xf5, 0x2f, 0x05, 0x25, 0x4c, 0x13, 0x8f, 0x0a, 0x97, 0xbc, 0x61, 0x9b, 0x3b, 0x77, 0xd0,
	0x2a, 0x4c, 0xfb, 0x2e, 0x51, 0x22, 0x89, 0xc0, 0xaf, 0x24, 0xc6, 0x36, 0xe9, 0xbb, 0x64, 0xbf,
	0x9f, 0x09, 0x3c, 0x0d, 0x93, 0x7d, 0x73, 0x18, 0xe4, 0x6e, 0xf1, 0x9b, 0x7c, 0x92, 0xfa, 0xe8,
	0x82, 0x27, 0xec, 0x60, 0x90, 0xbb, 0x14, 0x6c, 0x9b, 0xa7, 0x7e, 0x7f, 0xe0, 0xbf, 0x96, 0x10,
	0x5d, 0xa0, 0xad, 0xc1, 0xb8, 0x2f, 0xc3, 0xb4, 0x7d, 0x62, 0x69, 0x56, 0x68, 0xa7, 0xb7, 0x12,
	0xf0, 0x29, 0xde, 0x1e, 0x30, 0x3c, 0x0d, 0x93, 0xae, 0xd3, 0xbb, 0xd6, 0x87, 0xff, 0x7a, 0x52,
	0x3a, 0x6d, 0x15, 0xe0, 0x85, 0x36, 0xa0, 0xc1, 0xcc, 0x09, 0xc9, 0x90, 0x3e, 0x25, 0xf7, 0xc4,
	0x45, 0x3b, 0x2d, 0xa2, 0x97, 0x20, 0xdb, 0x53, 0xdb, 0x7e, 0x70, 0xdd, 0xbc, 0x34, 0xcc, 0x59,
	0x86, 0xdf, 0x6d, 0x63, 0xce, 0xf8, 0x5c, 0xea, 0xba, 0xb4, 0x50, 0x85, 0x73, 0x23, 0x22, 0xe6,
	0x90, 0x2e, 0xe7, 0xa2, 0x5d, 0xe6, 0x23, 0x62, 0x6e, 0x66, 0x72, 0x44, 0x3e, 0xba, 0x99, 0xc9,
	0x1d, 0xc9, 0xc7, 0xa5, 0xbf, 0xc8, 0xc3, 0x74, 0xc5, 0x21, 0xaa, 0x47, 0xfa, 0xe7, 0x9f, 0xcf,
	0x3e, 0xe2, 0xf9, 0x27, 0x72, 0xe6, 0x29, 0x26, 0xce, 0x2b, 0x1f, 0xea, 0x19, 0xe5, 0xa3, 0x49,
	0xa3, 0x7e, 0xde, 0xf4, 0xe6, 0x93, 0x6c, 0xe3, 0xe3, 0xca, 0x36, 0x3e, 0xfe, 0x04, 0x60, 0x79,
	0x74, 0x02, 0x30, 0x64, 0xab, 0xdf, 0xfa, 0x59, 0xb7, 0xfa, 0xd8, 0xbe, 0x7d, 0xfd, 0x01, 0x3b,
	0xef, 0x97, 0x1e, 0xb8, 0xf1, 0x5e, 0x1e, 0xbe, 0xdf, 0x7d, 0x99, 0x85, 0xd2, 0x8f, 0x7b, 0x8b,
	0x33, 0x3f, 0xf4, 0xac, 0x7f, 0x54, 0xbe, 0xff, 0xdc, 0xec, 0x9f, 0xbc, 0x98, 0xb8, 0xc2, 0x29,
	0xbd, 0x9b, 0x87, 0x19, 0x4c, 0xec, 0xb6, 0xaa, 0x87, 0x61, 0xed, 0x23, 0x8d, 0x4d, 0x0f, 0x3c,
	0x1e, 0x66, 0xfe, 0x23, 0x8e, 0x87, 0x9f, 0xc4, 0xb5, 0x4f, 0xe2, 0xda, 0x27, 0x71, 0x2d, 0x1e,
	0xd7, 0x3e, 0xc6, 0xa0, 0x54, 0x1b, 0x08, 0x4a, 0xff, 0xf0, 0xe2, 0xd5, 0x2b, 0xcb, 0x6b, 0xe5,
	0x67, 0x97, 0xcb, 0xcb, 0xeb, 0xcb, 0x6b, 0xe5, 0xab, 0xcb, 0x6b, 0x6b, 0xb4, 0xfe, 0xcc, 0xf2,
	0x5a, 0x79, 0x6d, 0x79, 0x6d, 0xed, 0xd9, 0xe5, 0xb5, 0xb5, 0xeb, 0xcb, 0x6b, 0x65, 0xda, 0x46,
	0xe9, 0xe5, 0xe5, 0xb5, 0xf2, 0xb5, 0xe5, 0xb5, 0xb5, 0xab, 0xe2, 0x0d, 0xc0, 0xd7, 0xa7, 0xa1,
	0xb0, 0x43, 0xbc, 0x5f, 0xf8, 0x2c, 0xed, 0xe7, 0x89, 0x84, 0xbf, 0x2c, 0xb7, 0xd0, 0x1f, 0x4d,
	0xc4, 0x36, 0x3e, 0x9c, 0x0b, 0xbd, 0x29, 0x76, 0x27, 0xf0, 0x96, 0x94, 0x5d, 0x4a, 0x7f, 0x14,
	0xd7, 0x79, 0x9f, 0xec, 0x0b, 0x9f, 0xec, 0x0b, 0xbf, 0x18, 0xfb, 0xc2, 0x0b, 0xb1, 0x1b, 0xae,
	0x37, 0xa4, 0x47, 0xbc, 0xe2, 0xfa, 0x85, 0x4a, 0x97, 0x7f, 0xf6, 0x7b, 0x9d, 0x8f, 0x6f, 0x4f,
	0x0b, 0x95, 0x14, 0x0a, 0x52, 0x5d, 0x03, 0x25, 0xbf, 0x19, 0x55, 0x92, 0x6b, 0x78, 0xeb, 0x7a,
	0x5f, 0xc9, 0xe7, 0xe0, 0xfc, 0x31, 0xdb, 0x0c, 0x87, 0xb1, 0xfe, 0x2a, 0x67, 0x9d, 0xe7, 0x88,
	0x24, 0xef, 0xb0, 0xf4, 0xfe, 0xc7, 0x69, 0x98, 0x3a, 0x24, 0x0e, 0x9d, 0x47, 0x9f, 0xbf, 0x6d,
	0x5c, 0x82, 0xd9, 0x1e, 0x5d, 0x88, 0x5d, 0xd7, 0x53, 0xbb, 0x3a, 0x77, 0x7c, 0x71, 0x19, 0x32,
	0xd3, 0x23, 0x4e, 0x4d, 0xd0, 0xa9, 0xaf, 0xa3, 0x5d, 0x98, 0x14, 0x5f, 0x9d, 0x18, 0x3f, 0x7b,
	0xf1, 0x36, 0x22, 0xc2, 0xd6, 0x28, 0xae, 0xc2, 0xb7, 0x00, 0xd3, 0xea, 0xf2, 0x0e, 0x71, 0x81,
	0x7f, 0x8e, 0x62, 0x15, 0x54, 0x83, 0x02, 0xfb, 0xc0, 0x24, 0x84, 0xa5, 0x99, 0xb0, 0x4b, 0xc3,
	0x84, 0x6d, 0x38, 0xc4, 0x1d, 0x90, 0x05, 0x94, 0x59, 0x88, 0xda, 0x82, 0x82, 0xd9, 0xf5, 0x8e,
	0x02, 0x51, 0x19, 0x26, 0xea, 0x53, 0x43, 0xf5, 0xea, 0x7a, 0xc4, 0x39, 0xa2, 0xa7, 0x1b, 0x21,
	0x85, 0xf2, 0x09, 0x29, 0x06, 0x14, 0xf9, 0x4e, 0xe7, 0xd3, 0x75, 0x2c, 0x5c, 0x5c, 0x88, 0xcc,
	0x32, 0x91, 0x43, 0x6f, 0x9f, 0xf8, 0xf2, 0x1c, 0xd0, 0x6f, 0x3e, 0x94, 0xc5, 0x11, 0xa2, 0x97,
	0xff, 0x22, 0x1e, 0x53, 0xc6, 0xe5, 0x8f, 0x3f, 0xb2, 0x7c, 0xf6, 0xc0, 0x32, 0x2a, 0xf9, 0x66,
	0x26, 0x37, 0x21, 0xe7, 0x6e, 0x66, 0x72, 0x39, 0x39, 0x5f, 0xfa, 0x0d, 0x09, 0xce, 0x1c, 0x12,
	0x67, 0x4f, 0x75, 0xbd, 0xd8, 0x74, 0x9f, 0x87, 0x1c, 0x9d, 0xee, 0xc8, 0x2c, 0x4f, 0xf4, 0x88,
	0xc3, 0x66, 0xf7, 0x1c, 0xd0, 0xa2, 0x72, 0x50, 0xdb, 0x12, 0xc9, 0xcd, 0x78, 0x8f, 0x38, 0x07,
	0xb5, 0x2d, 0xb4, 0x07, 0x73, 0x9e, 0xa3, 0x76, 0x5d, 0x93, 0xf6, 0xae, 0xf4, 0xdf, 0xf7, 0x8a,
	0x24, 0x67, 0x61, 0x95, 0xbf, 0x00, 0x5e, 0x0d, 0x5e, 0x00, 0xaf, 0xb6, 0x02, 0x04, 0x3e, 0x13,
	0xf2, 0xf5, 0x89, 0xa5, 0x7f, 0x94, 0xe0, 0xec, 0x50, 0xf7, 0x40, 0x32, 0xa4, 0x7d, 0xa7, 0x1d,
	0x5c, 0xc5, 0xf9, 0x4e, 0x1b, 0x5d, 0x81, 0x6c, 0xf8, 0xc0, 0x76, 0x44, 0x60, 0xa8, 0xed, 0x37,
	0xb9, 0x4f, 0x11, 0xcc, 0xc1, 0x68, 0x0d, 0x32, 0x8e, 0xd5, 0xe6, 0x8f, 0x27, 0x47, 0x04, 0x36,
	0xc6, 0x84, 0xad, 0x36, 0xc1, 0x0c, 0x8a, 0x3e, 0x0d, 0x53, 0x0e, 0xe9, 0x58, 0x1e, 0x11, 0x7b,
	0x88, 0x48, 0xb8, 0xe2, 0x44, 0x9a, 0xff, 0x99, 0x2e, 0x7b, 0x8f, 0xca, 0x1e, 0x25, 0xe4, 0x70,
	0x50, 0x45, 0x17, 0xa1, 0x40, 0xed, 0x68, 0xf1, 0x5d, 0xa1, 0x38, 0xce, 0xb8, 0xa3, 0xa4, 0xd2,
	0x17, 0x60, 0x6e, 0x98, 0x1f, 0x0f, 0x19, 0xf4, 0x7a, 0x7c, 0xd0, 0x43, 0xf5, 0x3f, 0x6c, 0xe1,
	0xfd, 0xe8, 0x98, 0x4b, 0x5f, 0xcf, 0xc2, 0x4c, 0xc2, 0xb9, 0xd1, 0xd3, 0x90, 0x62, 0x6f, 0x5b,
	0xe9, 0x34, 0x3d, 0x96, 0x90, 0x52, 0xb3, 0x9b, 0xbe, 0xd6, 0x25, 0x1e, 0x8b, 0x5b, 0x29, 0xd3,
	0xa6, 0x7a, 0x74, 0x54, 0x5d, 0x4c, 0x3d, 0x2d, 0xa2, 0x2d, 0x98, 0x8c, 0xe5, 0x28, 0xe9, 0x87,
	0xcd, 0x51, 0x0a, 0xdd, 0x48, 0x66, 0x12, 0x3c, 0x9e, 0xce, 0x44, 0x1e, 0x4f, 0x5f, 0x87, 0x09,
	0x53, 0x24, 0x51, 0x0f, 0x78, 0xdc, 0x21, 0xac, 0xce, 0x42, 0xfe, 0xb8, 0xc9, 0x93, 0xa8, 0x0b,
	0x50, 0x30, 0x4e, 0x74, 0x5b, 0x7c, 0xa7, 0x67, 0x76, 0xce, 0x61, 0xa0, 0x24, 0x7e, 0xfd, 0x8b,
	0x9e, 0x0c, 0x95, 0x66, 0xdd, 0xe6, 0xf8, 0x4c, 0x08, 0x5a, 0x7d, 0xf0, 0xe9, 0x76, 0x3e, 0xf9,
	0x74, 0x7b, 0x13, 0x26, 0x55, 0xdd, 0x33, 0x7b, 0xc1, 0xfe, 0x08, 0x0f, 0xd0, 0x90, 0xe1, 0xf8,
	0x3c, 0x14, 0xd4, 0xb0, 0x42, 0x65, 0xb0, 0x2e, 0x5e, 0xf5, 0xd5, 0xb6, 0xe9, 0xdd, 0x2b, 0x16,
	0x46, 0xcb, 0xd8, 0x35, 0xbb, 0xa7, 0x2f, 0x73, 0x18, 0x2e, 0xb4, 0xc3, 0x0a, 0x3d, 0xa7, 0x30,
	0x19, 0xcc, 0xf6, 0x93, 0xa3, 0xcf, 0x29, 0x54, 0x00, 0x3f, 0xa7, 0xb4, 0x45, 0x09, 0x6d, 0xc3,
	0xa4, 0x66, 0x75, 0x0d, 0xa5, 0xc3, 0x1f, 0xb1, 0x17, 0xa7, 0x46, 0x07, 0xc4, 0xc4, 0x5b, 0x77,
	0x5c, 0xd0, 0x42, 0x02, 0xba, 0x0c, 0x19, 0xd3, 0xee, 0x5d, 0x2b, 0x4e, 0x7f, 0xb0, 0x0b, 0x31,
	0x20, 0x0f, 0x41, 0xa5, 0xbf, 0x4c, 0xc1, 0xfc, 0xf0, 0xa8, 0x35, 0xc4, 0xdb, 0xaf, 0xc6, 0xbd,
	0xfd, 0xc2, 0xe8, 0x10, 0x18, 0x5b, 0xe3, 0xe5, 0xd8, 0x1a, 0x5f, 0x1c, 0xcd, 0xf5, 0xc8, 0x8b,
	0xfc, 0x79, 0xc8, 0x92, 0xae, 0xae, 0xda, 0xc2, 0x35, 0x3f, 0x93, 0x10, 0xcd, 0xa5, 0x56, 0x29,
	0xc2, 0xf5, 0xdb, 0x2a, 0x8b, 0x6d, 0xd4, 0x00, 0x9c, 0x29, 0x1a, 0x22, 0xc6, 0x1f, 0x18, 0x22,
	0x26, 0x06, 0x42, 0x04, 0x5a, 0x04, 0x91, 0xdf, 0xd5, 0x43, 0xcf, 0x8d, 0x50, 0x4a, 0x7f, 0x2e,
	0xc1, 0xfc, 0x61, 0x22, 0xaf, 0xee, 0x2f, 0xf5, 0x59, 0xb5, 0xa7, 0x9a, 0x6d, 0xba, 0xf3, 0xf7,
	0xb3, 0x40, 0x6e, 0x65, 0xb9, 0xdf, 0x10, 0xe4, 0x7f, 0x75, 0x90, 0x0d, 0x62, 0xb7, 0xad, 0x7b,
	0x1d, 0xd2, 0xf5, 0x22, 0xbf, 0x60, 0x18, 0xe1, 0x22, 0x5b, 0x7d, 0x2c, 0x9f, 0x81, 0x19, 0x23,
	0x4e, 0x40, 0x9f, 0x83, 0x33, 0x5d, 0xab, 0x4b, 0xf7, 0x3b, 0xcb, 0xe9, 0xb0, 0x6c, 0x94, 0x89,
	0x1c, 0x7c, 0xbb, 0x8e, 0x62, 0x30, 0xc6, 0x5c, 0xfa, 0x33, 0x09, 0xce, 0x36, 0xe2, 0x79, 0xea,
	0x2f, 0xfd, 0x98, 0x7e, 0x2a, 0xc1, 0x4c, 0xa2, 0x07, 0xea, 0x18, 0xf1, 0x31, 0x04, 0x55, 0xf4,
	0x32, 0xcc, 0x77, 0x2c, 0xc3, 0x3c, 0x32, 0x75, 0x35, 0xb1, 0xc3, 0xa6, 0x3e, 0x70, 0x87, 0x3d,
	0x1b, 0xe5, 0xec, 0x93, 0xd1, 0x3c, 0xcd, 0xb8, 0x5d, 0xbf, 0xed, 0x71, 0x85, 0xb1, 0xa8, 0x51,
	0x25, 0x3a, 0xc4, 0x75, 0xd5, 0xe3, 0x20, 0x1e, 0x07, 0x55, 0xf4, 0x22, 0x64, 0xed, 0x13, 0xd5,
	0x0d, 0x02, 0xf2, 0xd0, 0x3c, 0x2c, 0xf0, 0xb9, 0x03, 0xfb, 0xd8, 0x51, 0x0d, 0xb2, 0x4f, 0xf1,
	0x98, 0xb3, 0x95, 0xfe, 0x5a, 0x82, 0xb9, 0xed, 0x36, 0x21, 0x5e, 0x72, 0xdc, 0x08, 0x32, 0x27,
	0xaa, 0x7b, 0x12, 0xfc, 0x78, 0x86, 0x96, 0x3f, 0xce, 0x11, 0xbf, 0x04, 0x79, 0xdd, 0xea, 0x1a,
	0x2c, 0x07, 0x11, 0x89, 0x61, 0x69, 0xd8, 0xd8, 0x98, 0xee, 0x95, 0x00, 0x89, 0x43, 0xa6, 0xd2,
	0x1d, 0x98, 0x8e, 0x37, 0x0e, 0xfd, 0x3d, 0xd0, 0x05, 0x28, 0x74, 0x2c, 0xc3, 0x6f, 0x8b, 0x0c,
	0x9a, 0x6f, 0xa3, 0xc0, 0x49, 0x6c, 0x71, 0x47, 0x4c, 0x9f, 0x8e, 0x9b, 0x3e, 0x54, 0x3d, 0x13,
	0x55, 0xbd, 0xa4, 0x41, 0x81, 0x75, 0x2c, 0x96, 0x43, 0x73, 0x88, 0x87, 0xf3, 0xbd, 0xfd, 0xd2,
	0xc8, 0x01, 0x7d, 0x90, 0x9b, 0x97, 0xfe, 0x54, 0x82, 0xa9, 0xa6, 0xae, 0xb6, 0x85, 0xeb, 0xfa,
	0xf4, 0xf0, 0x2c, 0x1c, 0x81, 0x9f, 0xc5, 0x2e, 0x0e, 0x75, 0x04, 0xce, 0x11, 0x75, 0x80, 0xe8,
	0xf8, 0x52, 0xf1, 0xf1, 0x5d, 0x85, 0x73, 0xec, 0x50, 0xdc, 0xb5, 0x0c, 0xc2, 0x4f, 0xc6, 0x8a,
	0xee, 0x3b, 0x0e, 0xe9, 0xf2, 0xb9, 0xca, 0xe2, 0x39, 0xda, 0x4c, 0xa3, 0x20, 0x3b, 0x1e, 0x57,
	0x78, 0x1b, 0x5a, 0x87, 0xf9, 0x24, 0x9b, 0xa7, 0x3a, 0xc7, 0x84, 0x9b, 0x29, 0x8b, 0xcf, 0xc4,
	0xb8, 0x5a, 0xac, 0xa9, 0xf4, 0x1c, 0xe4, 0x28, 0xa9, 0xd6, 0x3d, 0xb2, 0xd0, 0x02, 0xe4, 0x4e,
	0x2c, 0xd7, 0x8b, 0x4c, 0x55, 0xbf, 0x4e, 0xa7, 0x90, 0x6d, 0x1f, 0xec, 0x47, 0x3b, 0x7c, 0x7b,
	0x28, 0xfd, 0x38, 0x03, 0xe3, 0x0d, 0x97, 0xb1, 0x7e, 0x06, 0x52, 0x96, 0x2b, 0xac, 0x3b, 0x3f,
	0xcc, 0x02, 0x8d, 0x26, 0x4e, 0x59, 0x2e, 0xba, 0x0a, 0x13, 0xb6, 0x63, 0x19, 0xbe, 0xee, 0x09,
	0xcf, 0x7d, 0x6c, 0xe8, 0x75, 0x13, 0x87, 0xe0, 0x00, 0x8b, 0x2e, 0x43, 0x56, 0xb3, 0x54, 0xc7,
	0x10, 0x29, 0xf4, 0xf9, 0xe1, 0x1b, 0xb3, 0xea, 0x18, 0x98, 0xe3, 0x68, 0x3f, 0xfa, 0x89, 0xea,
	0xba, 0x26, 0xdf, 0xb3, 0x46, 0xf4, 0x53, 0xe1, 0x10, 0x1c, 0x60, 0xd1, 0x32, 0x64, 0x34, 0xd3,
	0x72, 0xd9, 0x9a, 0x2e, 0x94, 0x8b, 0x43, 0xbb, 0x31, 0x2d, 0x17, 0x33, 0x14, 0x7a, 0x0a, 0xd2,
	0xba, 0xed, 0xb3, 0x6d, 0xab, 0x50, 0x3e, 0x37, 0xb4, 0x03, 0xdb, 0xc7, 0x14, 0x83, 0xca, 0x30,
	0xde, 0x21, 0x1d, 0xcb, 0xb9, 0xc7, 0xb6, 0xb1, 0xc2, 0xc0, 0x25, 0x18, 0x43, 0xef, 0x31, 0x04,
	0x16, 0x48, 0xf4, 0x39, 0x98, 0x70, 0x3d, 0xcb, 0xa1, 0x0e, 0x92, 0x63, 0xeb, 0xf0, 0xc9, 0xa1,
	0xae, 0xc5, 0x21, 0x5b, 0xa4, 0x67, 0xea, 0x04, 0x07, 0x1c, 0x94, 0x39, 0x38, 0x9b, 0xe7, 0x47,
	0x33, 0x8b, 0x24, 0x34, 0x60, 0x16, 0x1c, 0x54, 0xdb, 0x53, 0xe2, 0x74, 0x49, 0x9b, 0xe5, 0x72,
	0x23, 0xb4, 0xbd, 0xc5, 0x10, 0x58, 0x20, 0xd1, 0x65, 0x48, 0xfb, 0xae, 0x56, 0x2c, 0xb0, 0xce,
	0x86, 0xa6, 0xe0, 0x07, 0xcd, 0x4d, 0xd1, 0x11, 0x45, 0x52, 0xeb, 0x1d, 0xdb, 0x3e, 0x4b, 0xd4,
	0x46, 0x58, 0x6f, 0x67, 0xff, 0x00, 0x53, 0x4c, 0xe9, 0x6b, 0x12, 0xa4, 0x1a, 0xcd, 0xa1, 0x61,
	0x64, 0x1e, 0xc6, 0x7b, 0xa4, 0x6b, 0x58, 0x4e, 0x78, 0x06, 0xa3, 0xb5, 0xe8, 0xee, 0x91, 0x8e,
	0xef, 0x1e, 0x45, 0x98, 0x70, 0x48, 0x9b, 0xd0, 0x15, 0x2b, 0x42, 0xba, 0xa8, 0xa2, 0x12, 0x4c,
	0xaa, 0x8e, 0x7e, 0x62, 0x7a, 0x44, 0xf7, 0x7c, 0x47, 0xfc, 0xcc, 0x0b, 0xc7, 0x68, 0xa5, 0xff,
	0x0e, 0xe3, 0x7c, 0xe0, 0x51, 0x39, 0x52, 0x5c, 0x4e, 0xa4, 0xef, 0x54, 0xbc, 0xef, 0x64, 0x0f,
	0xe9, 0x21, 0x3d, 0x1c, 0xc3, 0x84, 0xf0, 0xff, 0x0f, 0x69, 0xc0, 0xf3, 0x30, 0xee, 0x12, 0xc7,
	0x54, 0xdb, 0x41, 0xb8, 0xe4, 0xb5, 0xd2, 0x9b, 0x12, 0x64, 0xd9, 0xa2, 0xf9, 0x68, 0xfb, 0x41,
	0x8f, 0x41, 0x5e, 0x75, 0x5d, 0x42, 0xa3, 0xd1, 0xb1, 0xb0, 0x69, 0x8e, 0x11, 0x5a, 0xea, 0x71,
	0xe9, 0x2b, 0x12, 0x4c, 0x88, 0x65, 0x48, 0xd5, 0xe8, 0x7f, 0x63, 0x98, 0xc2, 0xac, 0xfc, 0x71,
	0xa9, 0xb1, 0x0b, 0x19, 0xba, 0xb0, 0x23, 0xdd, 0x49, 0xa3, 0xba, 0x4b, 0x4c, 0x29, 0x82, 0x8c,
	0xd1, 0x4f, 0x74, 0x30, 0x2b, 0x97, 0x7e, 0x57, 0x82, 0x74, 0xc5, 0xf6, 0x47, 0x4a, 0x9b, 0x83,
	0x2c, 0x3d, 0xcb, 0xb5, 0x83, 0x07, 0x33, 0xac, 0x42, 0xa9, 0xd1, 0x5f, 0xbf, 0xf2, 0x0a, 0xa5,
	0xea, 0xaa, 0x7e, 0xc2, 0x9d, 0x75, 0x0a, 0xf3, 0x0a, 0xed, 0x55, 0xb7, 0x7d, 0x1e, 0xa8, 0xa6,
	0x30, 0x2b, 0x33, 0xa4, 0xe5, 0x10, 0x97, 0x05, 0x24, 0x8a, 0xa4, 0x15, 0xaa, 0xb9, 0x77, 0xe2,
	0x10, 0xd5, 0x70, 0x59, 0xe8, 0x99, 0xc2, 0x41, 0xb5, 0x74, 0x0b, 0xc6, 0x79, 0xc4, 0x89, 0x19,
	0x3e, 0x2f, 0x0c, 0xdf, 0xd7, 0x26, 0x15, 0xd5, 0xe6, 0x1c, 0x4c, 0xb8, 0xe6, 0x6b, 0x44, 0xe9,
	0x68, 0x42, 0xcb, 0x71, 0x5a, 0xdd, 0xd3, 0x4a, 0xbf, 0x49, 0xf7, 0xc5, 0x68, 0x28, 0x1a, 0xe5,
	0x54, 0x86, 0x63, 0xd2, 0x83, 0xa8, 0x98, 0x4d, 0x5e, 0x8b, 0x18, 0x2a, 0x3d, 0xdc, 0x50, 0x99,
	0xa8, 0xa1, 0xc2, 0x19, 0xce, 0xc6, 0x66, 0x38, 0x50, 0xee, 0x58, 0x13, 0x26, 0x60, 0xca, 0xed,
	0x68, 0xa5, 0xef, 0xa4, 0x60, 0x2a, 0x16, 0xea, 0x1e, 0x49, 0xb9, 0x27, 0x00, 0x4c, 0xbb, 0x7f,
	0x99, 0x9e, 0x66, 0x1b, 0x60, 0xde, 0xb4, 0x83, 0xe3, 0x0f, 0x4d, 0x64, 0x54, 0xbd, 0xdf, 0x9e,
	0x11, 0x89, 0x8c, 0xaa, 0x07, 0x00, 0x04, 0x19, 0xdb, 0x72, 0x3c, 0xa1, 0x2c, 0x2b, 0x87, 0xd6,
	0x1d, 0x8f, 0x5a, 0x37, 0x79, 0x0a, 0x9e, 0xf8, 0x79, 0x4f, 0xc1, 0xb9, 0x47, 0x39, 0x05, 0x97,
	0xbe, 0x9b, 0x85, 0x7c, 0x3f, 0x48, 0xd3, 0x93, 0xa7, 0xe6, 0xbb, 0x62, 0x31, 0xd2, 0x62, 0xf2,
	0x6b, 0xde, 0x54, 0xf8, 0x35, 0x2f, 0x18, 0x22, 0xf7, 0x09, 0x3e, 0xc4, 0x8b, 0x50, 0x30, 0x88,
	0xab, 0x3b, 0x26, 0xfb, 0xb5, 0x38, 0xbb, 0x36, 0xc8, 0xe3, 0x28, 0x89, 0x5a, 0x8e, 0xcf, 0x33,
	0x4f, 0x01, 0x81, 0x5b, 0x8e, 0x93, 0x58, 0x0a, 0xf8, 0x24, 0x4c, 0x8a, 0x0c, 0x80, 0x23, 0x0a,
	0x5c, 0x86, 0xa0, 0x31, 0xc8, 0x79, 0xc8, 0xb1, 0x1f, 0x21, 0x50, 0x6f, 0x98, 0xe6, 0x2b, 0xd3,
	0x6c, 0xf6, 0x17, 0xbc, 0x69, 0x28, 0xc2, 0xaf, 0x66, 0xf8, 0x82, 0x37, 0x8d, 0x43, 0xee, 0x59,
	0x74, 0x52, 0x0d, 0x25, 0xc8, 0x45, 0x64, 0xd6, 0x9a, 0x37, 0x8d, 0x20, 0xf2, 0xfe, 0x27, 0x98,
	0x36, 0x95, 0x8e, 0xda, 0xf5, 0x8f, 0x54, 0x16, 0x95, 0x9d, 0xe2, 0x2c, 0x3f, 0xfa, 0x9a, 0x7b,
	0x11, 0x62, 0x38, 0x8d, 0x88, 0xfb, 0x67, 0x7f, 0x91, 0x68, 0xba, 0xa1, 0xd0, 0xed, 0xf0, 0x0c,
	0xf7, 0x24, 0x4d, 0x37, 0x0e, 0x5c, 0x8d, 0x76, 0x4a, 0x1b, 0x0c, 0x66, 0xe0, 0xe2, 0x1c, 0xef,
	0x54, 0xd3, 0x0d, 0x61, 0xf1, 0x4f, 0xc3, 0xb4, 0x26, 0x1a, 0x15, 0xbd, 0xad, 0xba, 0x6e, 0xf1,
	0x2c, 0xdf, 0x1f, 0x34, 0x0e, 0xa8, 0x50, 0x1a, 0x7a, 0x1a, 0x50, 0x1f, 0xe5, 0xfa, 0x9a, 0x40,
	0xce, 0xf3, 0x1b, 0x68, 0x81, 0x6c, 0xfa, 0x1a, 0x07, 0x2f, 0xc1, 0x6c, 0x1f, 0xcc, 0xce, 0x06,
	0xba, 0xd5, 0x2e, 0x9e, 0x8b, 0x61, 0xf7, 0x05, 0x19, 0x3d, 0x45, 0xb1, 0x1d, 0xf5, 0xae, 0x62,
	0xab, 0xfa, 0x29, 0xf1, 0x14, 0xba, 0x78, 0x8a, 0x45, 0x36, 0xa3, 0xd3, 0xda, 0x9e, 0x7a, 0x77,
	0x9f, 0x91, 0x9b, 0xe6, 0x6b, 0x84, 0x99, 0xb6, 0x6f, 0xbc, 0xf3, 0xc2, 0xb4, 0x81, 0xed, 0xae,
	0x41, 0xce, 0x77, 0x35, 0xee, 0x80, 0x0b, 0xcc, 0x01, 0x87, 0x26, 0x5f, 0x07, 0xae, 0xc6, 0xfc,
	0x6f, 0xc2, 0xe7, 0x85, 0x9b, 0x99, 0x5c, 0x46, 0xce, 0xde, 0xcc, 0xe4, 0xb2, 0xf2, 0xf8, 0xcd,
	0x4c, 0x6e, 0x5c, 0x9e, 0x88, 0x5e, 0xd0, 0xde, 0xcc, 0xe4, 0x26, 0xe5, 0xa9, 0x9b, 0x99, 0xdc,
	0x94, 0x3c, 0x5d, 0xfa, 0x86, 0x04, 0xe9, 0x9d, 0xfd, 0x03, 0x3a, 0x4b, 0x7c, 0x8d, 0x26, 0x4e,
	0xbb, 0x53, 0x9c, 0x1a, 0x1c, 0x75, 0x9f, 0x84, 0x49, 0xdd, 0x37, 0x54, 0x25, 0x1e, 0xc1, 0x0b,
	0x94, 0x16, 0x40, 0x9e, 0x07, 0x38, 0xb6, 0xfd, 0x60, 0x66, 0xd2, 0xa3, 0x93, 0x98, 0x9d, 0xfd,
	0x03, 0x91, 0xc4, 0xe4, 0x8f, 0x6d, 0x9f, 0x17, 0x4b, 0x9f, 0x87, 0x7c, 0x9f, 0x8e, 0xa6, 0x21,
	0x65, 0x1a, 0x42, 0x91, 0x94, 0x69, 0x0c, 0x38, 0x71, 0x6a, 0xd0, 0x89, 0x1f, 0x87, 0xbc, 0xed,
	0x58, 0x3a, 0x71, 0x5d, 0xf1, 0x29, 0x3c, 0x8f, 0x43, 0x02, 0x3d, 0xf0, 0x2f, 0x04, 0xdf, 0x95,
	0x7c, 0x77, 0x8f, 0x78, 0x8e, 0xa9, 0xbb, 0xdb, 0x26, 0x69, 0x1b, 0x5b, 0xaa, 0xa7, 0xa2, 0x5a,
	0xf0, 0x1e, 0x93, 0xea, 0xfc, 0xec, 0x83, 0x3e, 0x4a, 0x0d, 0x32, 0xaf, 0xde, 0x22, 0xf7, 0xf8,
	0x3b, 0x78, 0xf6, 0x90, 0xf3, 0x99, 0xf0, 0x21, 0x67, 0x7a, 0x48, 0xda, 0xc7, 0xb9, 0x0f, 0x29,
	0x42, 0x3c, 0xf2, 0x5c, 0xb8, 0x06, 0xb9, 0x40, 0xc4, 0xa3, 0x3c, 0x0c, 0x2d, 0x7d, 0x5b, 0x82,
	0xb3, 0x03, 0x6a, 0xb1, 0xe1, 0xbc, 0x04, 0xd9, 0x23, 0xaa, 0x9e, 0x38, 0x4e, 0x2d, 0x3d, 0xfc,
	0x80, 0x30, 0x67, 0x44, 0x9b, 0x6c, 0x47, 0x56, 0xc5, 0x20, 0x56, 0x1f, 0xcd, 0x22, 0x6c, 0x07,
	0x57, 0x4b, 0x2a, 0x9c, 0xe1, 0x6f, 0x55, 0x6f, 0xf9, 0x1a, 0xe1, 0xdf, 0xe2, 0x31, 0x79, 0x15,
	0x3d, 0x05, 0x79, 0xf6, 0xa1, 0xd3, 0x56, 0x75, 0xb1, 0x77, 0x88, 0xd7, 0xdd, 0x0e, 0x0d, 0xfb,
	0x2f, 0xe1, 0xb0, 0x15, 0x5d, 0x10, 0x3b, 0x4c, 0x6a, 0x10, 0xc5, 0x1a, 0x4a, 0x0a, 0xcc, 0xee,
	0x9a, 0xae, 0xf7, 0xd1, 0x75, 0xf0, 0x4f, 0x12, 0x9c, 0x4d, 0xf4, 0xe0, 0xda, 0x35, 0x8f, 0x74,
	0xd8, 0xa5, 0xa2, 0x69, 0x08, 0x4f, 0xa3, 0x45, 0x54, 0x05, 0x59, 0x67, 0xe3, 0x8d, 0x5c, 0x2d,
	0x64, 0x3f, 0xf0, 0x6a, 0x61, 0x86, 0xf3, 0x84, 0x97, 0x0a, 0x55, 0x90, 0xc9, 0x5d, 0xdb, 0x74,
	0xee, 0x45, 0xc4, 0x8c, 0x7f, 0xb0, 0x18, 0xce, 0x13, 0x8a, 0x79, 0x02, 0xc0, 0x77, 0x89, 0xa3,
	0x90, 0x8e, 0x6a, 0xb6, 0xc5, 0xc5, 0x5f, 0x9e, 0x52, 0xaa, 0x94, 0xd0, 0x1f, 0x79, 0x6e, 0xd4,
	0xc8, 0x5b, 0x03, 0xa6, 0x75, 0x6d, 0xf4, 0x9f, 0x21, 0x6b, 0x7a, 0xa4, 0xe3, 0x16, 0x1f, 0xf0,
	0xce, 0x61, 0xa8, 0xb9, 0x30, 0xe7, 0x2b, 0x1d, 0x41, 0x71, 0x27, 0xf2, 0xe1, 0xb0, 0x72, 0x42,
	0xf4, 0x53, 0x4c, 0x5e, 0xf5, 0x89, 0xeb, 0x7d, 0xa8, 0xf3, 0x76, 0x15, 0xce, 0x0f, 0xe9, 0xc7,
	0xb5, 0xad, 0x2e, 0x3f, 0x5b, 0x04, 0x5f, 0x33, 0xf9, 0xc7, 0xcc, 0xa0, 0x5a, 0xfa, 0xae, 0x04,
	0xe7, 0xb9, 0xcf, 0x72, 0xee, 0xb8, 0x63, 0x5d, 0x00, 0xf6, 0xcc, 0x64, 0x98, 0x6e, 0xac, 0x01,
	0x9d, 0xc0, 0x1c, 0x9b, 0x86, 0x47, 0xbe, 0x60, 0xda, 0x3c, 0xcf, 0x2e, 0xf7, 0xbe, 0x2f, 0xa5,
	0x5e, 0x62, 0x0f, 0xf5, 0xe1, 0xfb, 0xd2, 0xc4, 0xcd, 0x6c, 0xee, 0x8d, 0xbf, 0xfb, 0xca, 0x0c,
	0x3e, 0x13, 0x8a, 0x0c, 0xbf, 0x67, 0x3d, 0x07, 0xe7, 0xa8, 0x9d, 0x7f, 0x16, 0x2d, 0x4b, 0xd7,
	0xe0, 0x0c, 0x26, 0x3d, 0xeb, 0x94, 0x0c, 0xf0, 0x85, 0xe9, 0xdc, 0x30, 0x9b, 0xae, 0xc0, 0x99,
	0x90, 0x43, 0x7c, 0x10, 0x74, 0xd9, 0x25, 0x98, 0xf8, 0x9e, 0xc8, 0x8d, 0x29, 0x6a, 0x4b, 0x2f,
	0x40, 0x2e, 0x78, 0xcd, 0x84, 0x0a, 0x30, 0x51, 0xab, 0x1f, 0x6e, 0xec, 0xd6, 0xb6, 0xe4, 0x31,
	0x34, 0x0b, 0x53, 0xb8, 0xba, 0x53, 0x6b, 0xd4, 0x37, 0x76, 0x95, 0xea, 0xd6, 0x4e, 0x55, 0x96,
	0x28, 0xa9, 0x72, 0xd0, 0x6c, 0x35, 0xf6, 0xaa, 0x98, 0x93, 0x52, 0x4b, 0xdb, 0x50, 0x88, 0xfc,
	0xd0, 0x16, 0x4d, 0x03, 0xd4, 0x1b, 0x4a, 0xf3, 0x60, 0xb3, 0xf5, 0xca, 0x7e, 0x95, 0x0b, 0x39,
	0xac, 0x36, 0x95, 0x5a, 0x43, 0x39, 0x68, 0x56, 0x15, 0x4c, 0x85, 0xcc, 0x81, 0x2c, 0x48, 0x95,
	0xaa, 0x52, 0xab, 0x2b, 0xb7, 0xae, 0x37, 0xe5, 0xd4, 0xd2, 0xb7, 0x25, 0x80, 0xf0, 0x33, 0x3e,
	0x2a, 0xc1, 0x62, 0xa5, 0xca, 0x7f, 0xa0, 0xb3, 0xd7, 0xd8, 0xa2, 0xb8, 0x1d, 0x5c, 0x6d, 0x36,
	0x95, 0x2a, 0xff, 0xb3, 0x73, 0x5b, 0x1e, 0x43, 0x8f, 0xc1, 0xb9, 0xa1, 0x98, 0x9d, 0xdb, 0xb2,
	0x84, 0x16, 0x60, 0x3e, 0xd6, 0x18, 0x32, 0xa6, 0xd0, 0xe3, 0x50, 0x8c, 0xb5, 0x6d, 0x55, 0x94,
	0xca, 0x6e, 0xe3, 0x60, 0x8b, 0xb6, 0xa6, 0xa9, 0x7e, 0xb1, 0xd6, 0xca, 0x7e, 0x55, 0xce, 0x2c,
	0xad, 0x01, 0x84, 0x1f, 0x13, 0xe9, 0xb0, 0x0e, 0xea, 0xb7, 0xea, 0x8d, 0xdb, 0x75, 0xa5, 0xd9,
	0xda, 0x68, 0xd1, 0x91, 0x8e, 0x43, 0xea, 0x60, 0x5f, 0x96, 0x50, 0x0e, 0x32, 0x5b, 0x8d, 0xdb,
	0x75, 0x39, 0xb5, 0xf4, 0x39, 0xc8, 0xf7, 0x3f, 0x25, 0x22, 0x19, 0x26, 0x03, 0x0e, 0xdc, 0xd8,
	0xa5, 0x0c, 0x53, 0x90, 0xaf, 0xd5, 0x6b, 0xad, 0xda, 0x46, 0xab, 0x81, 0x65, 0x89, 0x56, 0x71,
	0xb5, 0xb9, 0xdf, 0xa8, 0x6f, 0x55, 0xb1, 0x9c, 0x5a, 0xfa, 0x3c, 0x14, 0x22, 0x5f, 0x36, 0x50,
	0x11, 0xe6, 0x02, 0x76, 0xf1, 0x83, 0xa5, 0xa0, 0xdf, 0x29, 0xc8, 0x0b, 0x0a, 0xeb, 0x7e, 0x06,
	0x0a, 0xa2, 0xca, 0xb5, 0x40, 0x67, 0x60, 0x26, 0x20, 0xd4, 0x9a, 0x1b, 0x9b, 0xbb, 0xd5, 0x2d,
	0x39, 0xbd, 0xf4, 0x32, 0x40, 0xf8, 0x05, 0x04, 0x9d, 0x83, 0x33, 0x09, 0xe1, 0x42, 0xc5, 0x39,
	0x90, 0x83, 0x9f, 0x47, 0x45, 0x34, 0x0d, 0xa9, 0x51, 0x85, 0xbf, 0x00, 0xf9, 0xfe, 0x87, 0x47,
	0x6a, 0x04, 0xca, 0x21, 0x8f, 0x21, 0x80, 0xf1, 0x8d, 0x4a, 0xab, 0x76, 0x48, 0x67, 0x7e, 0x1a,
	0xa0, 0xd2, 0xa8, 0xd7, 0xab, 0x95, 0x56, 0xad, 0xbe, 0x23, 0xa7, 0xa8, 0xea, 0xa2, 0x4e, 0x95,
	0xa2, 0xaa, 0x57, 0x9b, 0xad, 0x8d, 0xcd, 0xdd, 0x5a, 0xf3, 0x46, 0x75, 0x4b, 0xce, 0x50, 0xde,
	0xad, 0xea, 0x6e, 0xb5, 0x55, 0x95, 0xb3, 0x4b, 0x5b, 0x50, 0x88, 0x7c, 0x51, 0xa3, 0x13, 0xc0,
	0x0c, 0xa0, 0x08, 0xc5, 0xe5, 0x31, 0x6a, 0x61, 0x4e, 0xea, 0xf7, 0xd7, 0xa7, 0x6c, 0x6e, 0x54,
	0x6e, 0x1d, 0xec, 0x73, 0xab, 0x46, 0x4e, 0x13, 0xd4, 0x36, 0x2f, 0x1f, 0x6c, 0xec, 0xd6, 0x5a,
	0xaf, 0xc4, 0xe5, 0x04, 0xc4, 0x9d, 0x46, 0x63, 0x8b, 0xcb, 0x09, 0x28, 0xfb, 0x8d, 0x06, 0x96,
	0x53, 0xd4, 0x04, 0x01, 0x25, 0x62, 0xd5, 0xdf, 0x97, 0x20, 0x17, 0x9c, 0x35, 0xd0, 0x59, 0x98,
	0xdd, 0xad, 0xd5, 0x6f, 0x29, 0x74, 0x21, 0x44, 0xa4, 0xcf, 0x03, 0x0a, 0xc9, 0xd5, 0xd6, 0x8d,
	0x2a, 0xae, 0x57, 0x5b, 0xb2, 0x44, 0x9d, 0x39, 0xa4, 0xdf, 0xae, 0x6d, 0xd7, 0x94, 0xeb, 0xcf,
	0x94, 0x95, 0xb5, 0xb5, 0x8d, 0x0a, 0x77, 0xd8, 0xa1, 0x8d, 0x9b, 0x3b, 0x75, 0x39, 0x4d, 0xd5,
	0x0b, 0x5b, 0xaf, 0xec, 0xc8, 0x19, 0x84, 0x60, 0x3a, 0x8e, 0x97, 0xb3, 0xd4, 0x62, 0x11, 0xda,
	0x46, 0x5d, 0x1e, 0x5f, 0xfa, 0x14, 0x14, 0x22, 0xdf, 0x51, 0xa9, 0xb9, 0xa9, 0xb9, 0x6a, 0x15,
	0x79, 0x8c, 0x79, 0xf1, 0x8d, 0xca, 0xbe, 0x2c, 0x2d, 0x7d, 0x09, 0x8a, 0xa3, 0x5e, 0x72, 0xa1,
	0x0b, 0xf0, 0x18, 0x5b, 0x27, 0xcd, 0xc6, 0x76, 0xeb, 0xf6, 0x06, 0xae, 0x2a, 0x8d, 0xc3, 0x2a,
	0xc6, 0xb5, 0x2d, 0xbe, 0x7c, 0xe4, 0x31, 0x74, 0x11, 0x1e, 0x1f, 0x01, 0xa8, 0x57, 0x6f, 0x57,
	0xa9, 0x33, 0x8d, 0x46, 0x6c, 0xef, 0x56, 0xab, 0x2d, 0x39, 0xb5, 0xf4, 0x55, 0x09, 0xe6, 0x86,
	0x7d, 0x5d, 0xa0, 0xb3, 0x77, 0xb0, 0xbf, 0x83, 0x37, 0xd8, 0xd2, 0x0f, 0xa2, 0xd6, 0x59, 0x98,
	0x0d, 0x88, 0x2d, 0x5c, 0xdb, 0xd9, 0xa9, 0xe2, 0x2a, 0x9d, 0x42, 0xea, 0xe2, 0x7d, 0xac, 0xb2,
	0x8f, 0x1b, 0x2c, 0x1c, 0xc8, 0xa9, 0x28, 0xbe, 0xd2, 0xd8, 0xdb, 0xa7, 0xde, 0x46, 0x7d, 0x11,
	0xc1, 0x74, 0x40, 0xde, 0xde, 0xa8, 0xd1, 0xe9, 0xcd, 0x2c, 0x69, 0x30, 0x19, 0xbd, 0xdc, 0xa6,
	0xfd, 0x37, 0x2b, 0x1b, 0xbb, 0xb5, 0xfa, 0x4e, 0xa4, 0xff, 0x73, 0x70, 0x26, 0x24, 0x86, 0x1d,
	0x49, 0x54, 0x62, 0xd0, 0x20, 0x24, 0xa6, 0x98, 0x83, 0x0a, 0xda, 0x56, 0xa3, 0x5e, 0x95, 0xd3,
	0x4b, 0xdf, 0x93, 0x20, 0xdf, 0x7f, 0x58, 0x45, 0x67, 0xa4, 0x51, 0xdf, 0xad, 0xd5, 0xab, 0xdc,
	0x2d, 0xf7, 0x71, 0xe3, 0xb0, 0xd6, 0xac, 0x35, 0xea, 0x74, 0xf9, 0xb0, 0x88, 0xc1, 0x75, 0xe4,
	0xab, 0xa9, 0x00, 0x13, 0xcd, 0xd6, 0x46, 0x7d, 0x6b, 0xf3, 0x15, 0x39, 0x4d, 0x39, 0x03, 0xbd,
	0x69, 0xcf, 0xb8, 0x4a, 0x43, 0x79, 0xb3, 0x85, 0x37, 0x5a, 0xb5, 0x46, 0x5d, 0xce, 0x52, 0x69,
	0xb7, 0x37, 0x6a, 0x74, 0x1d, 0xd6, 0x1b, 0x5b, 0xd5, 0xa6, 0x3c, 0x4e, 0x47, 0xb3, 0x55, 0xad,
	0x34, 0xf6, 0xf6, 0x6a, 0xcd, 0xa0, 0x8b, 0x09, 0xea, 0x78, 0x02, 0xa6, 0x6c, 0x37, 0xb0, 0x12,
	0x13, 0x92, 0x5b, 0xba, 0x09, 0x13, 0xe2, 0x64, 0x43, 0xd7, 0x6e, 0x10, 0x42, 0x0e, 0x9a, 0x9b,
	0xf2, 0x18, 0x9a, 0x84, 0x5c, 0xad, 0xde, 0xaa, 0xe2, 0xfa, 0xc6, 0x2e, 0x5f, 0xf9, 0x9c, 0x97,
	0x4d, 0x07, 0x1b, 0x78, 0xa5, 0x51, 0xdf, 0xae, 0xed, 0x1c, 0x60, 0xba, 0x78, 0xe4, 0xf4, 0xd2,
	0x0f, 0x33, 0x30, 0x3f, 0x3c, 0x55, 0xa5, 0xa1, 0x9c, 0xb9, 0x08, 0x5f, 0xd7, 0xca, 0xf6, 0x6e,
	0xe3, 0xb6, 0x52, 0x69, 0x1c, 0xd4, 0x69, 0x78, 0x29, 0xc2, 0x1c, 0x6b, 0x63, 0xc4, 0x66, 0xb5,
	0x75, 0xb0, 0xaf, 0x60, 0x1a, 0x17, 0x25, 0xba, 0xd0, 0x58, 0x4b, 0xad, 0xae, 0xb4, 0x6e, 0xe0,
	0xc6, 0xc1, 0xce, 0x8d, 0xfd, 0x83, 0x96, 0x9c, 0x62, 0x13, 0x44, 0xe9, 0x8d, 0x83, 0x56, 0xb4,
	0x21, 0x1d, 0x7a, 0xe2, 0x2b, 0xcd, 0x56, 0x75, 0x2f, 0xe8, 0x6d, 0xbf, 0xb1, 0x25, 0x3a, 0xcb,
	0xa0, 0x45, 0x58, 0x60, 0x88, 0xc3, 0x5b, 0xd7, 0x9b, 0x83, 0xed, 0x59, 0x74, 0x1e, 0xce, 0xb2,
	0x76, 0x9c, 0xec, 0x75, 0xbc, 0x3f, 0x06, 0x3c, 0xd0, 0xf1, 0x04, 0x5d, 0xfa, 0xbc, 0xe3, 0x41,
	0x75, 0x73, 0x74, 0x06, 0xc2, 0xc6, 0x04, 0x6b, 0xbe, 0x3f, 0x98, 0x3a, 0xdf, 0xa8, 0x0e, 0x94,
	0x83, 0xe6, 0xc6, 0x4e, 0x55, 0x86, 0x7e, 0x7f, 0xac, 0x61, 0xaf, 0xba, 0xd7, 0xc0, 0xaf, 0x88,
	0xb6, 0x42, 0xdf, 0x66, 0xac, 0x6d, 0xab, 0xd6, 0xbc, 0x25, 0x5a, 0x26, 0xfb, 0xeb, 0x99, 0xb5,
	0x0c, 0x9a, 0x7b, 0x0a, 0x3d, 0x01, 0xe7, 0x43, 0x40, 0xd2, 0xe6, 0xd3, 0xfd, 0x91, 0xd4, 0xf9,
	0x76, 0x1c, 0xd5, 0x75, 0xa6, 0x3f, 0x12, 0xd6, 0x98, 0x18, 0x89, 0xdc, 0xb7, 0x2d, 0x67, 0xdd,
	0x4e, 0x70, 0xcf, 0xc6, 0x55, 0xab, 0x6d, 0x27, 0x05, 0xa0, 0xcd, 0xaf, 0x4a, 0xef, 0xfe, 0x68,
	0x71, 0xec, 0xbd, 0x1f, 0x2d, 0x8e, 0xfd, 0xf4, 0x47, 0x8b, 0xd2, 0x1b, 0xf7, 0x17, 0xa5, 0xdf,
	0xbb, 0xbf, 0x28, 0xfd, 0xf1, 0xfd, 0x45, 0xe9, 0xdd, 0xfb, 0x8b, 0xd2, 0x7b, 0xf7, 0x17, 0xa5,
	0xbf, 0xbd, 0xbf, 0x28, 0xfd, 0xe4, 0xfe, 0xe2, 0xd8, 0x4f, 0xef, 0x2f, 0x4a, 0xdf, 0x7a, 0x7f,
	0x71, 0xec, 0x9d, 0xf7, 0x17, 0xa5, 0x77, 0xdf, 0x5f, 0x1c, 0x7b, 0xef, 0xfd, 0xc5, 0xb1, 0xff,
	0x7a, 0xe3, 0xd8, 0xb2, 0x4f, 0x8f, 0x57, 0x83, 0xa7, 0xa9, 0xab, 0xbe, 0x7b, 0x99, 0x15, 0x8e,
	0x2c, 0xa7, 0xb3, 0x62, 0x3b, 0x56, 0xcf, 0x34, 0x88, 0xb3, 0x12, 0x34, 0x5f, 0xb6, 0xb5, 0x63,
	0xeb, 0x32, 0xb9, 0xeb, 0x05, 0xff, 0x7b, 0x62, 0xf8, 0x9f, 0x28, 0x6a, 0xe3, 0x2c, 0x6f, 0x5c,
	0xff, 0xf7, 0x00, 0x00, 0x00, 0xff, 0xff, 0x71, 0x79, 0xe1, 0xf4, 0x61, 0x51, 0x00, 0x00,
}

func (x SiteType) String() string {
	s, ok := SiteType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SiteSubtype) String() string {
	s, ok := SiteSubtype_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CeSiteMode) String() string {
	s, ok := CeSiteMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x IPSecState) String() string {
	s, ok := IPSecState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x IPSecRole) String() string {
	s, ok := IPSecRole_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TunnelState) String() string {
	s, ok := TunnelState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TunnelRole) String() string {
	s, ok := TunnelRole_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x VTRPState) String() string {
	s, ok := VTRPState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ActiveState) String() string {
	s, ok := ActiveState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x LinkQuality) String() string {
	s, ok := LinkQuality_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x LinkType) String() string {
	s, ok := LinkType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x AddressMode) String() string {
	s, ok := AddressMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SiteSoftwareOverrideType) String() string {
	s, ok := SiteSoftwareOverrideType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SoftwareUpgradePhase) String() string {
	s, ok := SoftwareUpgradePhase_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ScalingPhase) String() string {
	s, ok := ScalingPhase_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SiteState) String() string {
	s, ok := SiteState_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x UsbType) String() string {
	s, ok := UsbType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SiteStatusMetricsField) String() string {
	s, ok := SiteStatusMetricsField_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *BondMembersType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BondMembersType)
	if !ok {
		that2, ok := that.(BondMembersType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.LinkState != that1.LinkState {
		return false
	}
	if this.LinkSpeed != that1.LinkSpeed {
		return false
	}
	return true
}
func (this *Coordinates) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Coordinates)
	if !ok {
		that2, ok := that.(Coordinates)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Latitude != that1.Latitude {
		return false
	}
	if this.Longitude != that1.Longitude {
		return false
	}
	return true
}
func (this *K8SApiServerParameters) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*K8SApiServerParameters)
	if !ok {
		that2, ok := that.(K8SApiServerParameters)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *DefaultUnderlayNetworkType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DefaultUnderlayNetworkType)
	if !ok {
		that2, ok := that.(DefaultUnderlayNetworkType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PrivateAccessChoice == nil {
		if this.PrivateAccessChoice != nil {
			return false
		}
	} else if this.PrivateAccessChoice == nil {
		return false
	} else if !this.PrivateAccessChoice.Equal(that1.PrivateAccessChoice) {
		return false
	}
	return true
}
func (this *DefaultUnderlayNetworkType_SiteLocalOutside) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DefaultUnderlayNetworkType_SiteLocalOutside)
	if !ok {
		that2, ok := that.(DefaultUnderlayNetworkType_SiteLocalOutside)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteLocalOutside.Equal(that1.SiteLocalOutside) {
		return false
	}
	return true
}
func (this *DefaultUnderlayNetworkType_SiteLocalInside) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DefaultUnderlayNetworkType_SiteLocalInside)
	if !ok {
		that2, ok := that.(DefaultUnderlayNetworkType_SiteLocalInside)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SiteLocalInside.Equal(that1.SiteLocalInside) {
		return false
	}
	return true
}
func (this *PublishVIPParamsPerAz) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PublishVIPParamsPerAz)
	if !ok {
		that2, ok := that.(PublishVIPParamsPerAz)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.InsideVip) != len(that1.InsideVip) {
		return false
	}
	for i := range this.InsideVip {
		if this.InsideVip[i] != that1.InsideVip[i] {
			return false
		}
	}
	if len(this.OutsideVip) != len(that1.OutsideVip) {
		return false
	}
	for i := range this.OutsideVip {
		if this.OutsideVip[i] != that1.OutsideVip[i] {
			return false
		}
	}
	if this.OutsideVipCname != that1.OutsideVipCname {
		return false
	}
	if this.InsideVipCname != that1.InsideVipCname {
		return false
	}
	if this.AzName != that1.AzName {
		return false
	}
	return true
}
func (this *GlobalSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalSpecType)
	if !ok {
		that2, ok := that.(GlobalSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SiteType != that1.SiteType {
		return false
	}
	if this.SiteSubtype != that1.SiteSubtype {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if !this.Coordinates.Equal(that1.Coordinates) {
		return false
	}
	if len(this.ConnectedRe) != len(that1.ConnectedRe) {
		return false
	}
	for i := range this.ConnectedRe {
		if !this.ConnectedRe[i].Equal(that1.ConnectedRe[i]) {
			return false
		}
	}
	if len(this.ConnectedReForConfig) != len(that1.ConnectedReForConfig) {
		return false
	}
	for i := range this.ConnectedReForConfig {
		if !this.ConnectedReForConfig[i].Equal(that1.ConnectedReForConfig[i]) {
			return false
		}
	}
	if !this.Vega.Equal(that1.Vega) {
		return false
	}
	if len(this.AresList) != len(that1.AresList) {
		return false
	}
	for i := range this.AresList {
		if !this.AresList[i].Equal(that1.AresList[i]) {
			return false
		}
	}
	if !this.Rakar.Equal(that1.Rakar) {
		return false
	}
	if !this.Opera.Equal(that1.Opera) {
		return false
	}
	if len(this.StaticRoutes) != len(that1.StaticRoutes) {
		return false
	}
	for i := range this.StaticRoutes {
		if this.StaticRoutes[i] != that1.StaticRoutes[i] {
			return false
		}
	}
	if len(this.K8SApiServers) != len(that1.K8SApiServers) {
		return false
	}
	for i := range this.K8SApiServers {
		if !this.K8SApiServers[i].Equal(that1.K8SApiServers[i]) {
			return false
		}
	}
	if this.PublicIp != that1.PublicIp {
		return false
	}
	if this.PrivateIp != that1.PrivateIp {
		return false
	}
	if this.IpsecSslVipFqdn != that1.IpsecSslVipFqdn {
		return false
	}
	if this.ClusterIp != that1.ClusterIp {
		return false
	}
	if len(this.AresVtrpList) != len(that1.AresVtrpList) {
		return false
	}
	for i := range this.AresVtrpList {
		if !this.AresVtrpList[i].Equal(that1.AresVtrpList[i]) {
			return false
		}
	}
	if this.VolterraSoftwareVersion != that1.VolterraSoftwareVersion {
		return false
	}
	if this.InsideVip != that1.InsideVip {
		return false
	}
	if this.OutsideVip != that1.OutsideVip {
		return false
	}
	if len(this.VipParamsPerAz) != len(that1.VipParamsPerAz) {
		return false
	}
	for i := range this.VipParamsPerAz {
		if !this.VipParamsPerAz[i].Equal(that1.VipParamsPerAz[i]) {
			return false
		}
	}
	if this.VipVrrpMode != that1.VipVrrpMode {
		return false
	}
	if !this.DefaultUnderlayNetwork.Equal(that1.DefaultUnderlayNetwork) {
		return false
	}
	if this.SiteToSiteNetworkType != that1.SiteToSiteNetworkType {
		return false
	}
	if this.SiteToSiteTunnelIp != that1.SiteToSiteTunnelIp {
		return false
	}
	if this.VolterraSoftwareOveride != that1.VolterraSoftwareOveride {
		return false
	}
	if this.BgpRouterId != that1.BgpRouterId {
		return false
	}
	if this.BgpPeerAddress != that1.BgpPeerAddress {
		return false
	}
	if len(this.TemplateParameters) != len(that1.TemplateParameters) {
		return false
	}
	for i := range this.TemplateParameters {
		if this.TemplateParameters[i] != that1.TemplateParameters[i] {
			return false
		}
	}
	if this.InsideNameserver != that1.InsideNameserver {
		return false
	}
	if this.OutsideNameserver != that1.OutsideNameserver {
		return false
	}
	if this.DesiredPoolCount != that1.DesiredPoolCount {
		return false
	}
	if this.TunnelType != that1.TunnelType {
		return false
	}
	if this.SiteState != that1.SiteState {
		return false
	}
	if this.OperatingSystemVersion != that1.OperatingSystemVersion {
		return false
	}
	if len(this.MarsList) != len(that1.MarsList) {
		return false
	}
	for i := range this.MarsList {
		if !this.MarsList[i].Equal(that1.MarsList[i]) {
			return false
		}
	}
	if len(this.MarsVtrpList) != len(that1.MarsVtrpList) {
		return false
	}
	for i := range this.MarsVtrpList {
		if !this.MarsVtrpList[i].Equal(that1.MarsVtrpList[i]) {
			return false
		}
	}
	if this.TunnelDeadTimeout != that1.TunnelDeadTimeout {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	if this.CeSiteMode != that1.CeSiteMode {
		return false
	}
	if this.NoTenantInVk8SNs != that1.NoTenantInVk8SNs {
		return false
	}
	if this.LocalK8SAccessEnabled != that1.LocalK8SAccessEnabled {
		return false
	}
	if len(this.K8SClusterApiGw) != len(that1.K8SClusterApiGw) {
		return false
	}
	for i := range this.K8SClusterApiGw {
		if !this.K8SClusterApiGw[i].Equal(that1.K8SClusterApiGw[i]) {
			return false
		}
	}
	if this.UsePrivateIp != that1.UsePrivateIp {
		return false
	}
	if this.TenantIndex != that1.TenantIndex {
		return false
	}
	if this.PikuEnabled != that1.PikuEnabled {
		return false
	}
	if this.PhobosEnabled != that1.PhobosEnabled {
		return false
	}
	if this.Srv6Enabled != that1.Srv6Enabled {
		return false
	}
	return true
}
func (this *CreateSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSpecType)
	if !ok {
		that2, ok := that.(CreateSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SiteType != that1.SiteType {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if !this.Coordinates.Equal(that1.Coordinates) {
		return false
	}
	if this.InsideVip != that1.InsideVip {
		return false
	}
	if this.OutsideVip != that1.OutsideVip {
		return false
	}
	if this.VipVrrpMode != that1.VipVrrpMode {
		return false
	}
	if this.SiteToSiteNetworkType != that1.SiteToSiteNetworkType {
		return false
	}
	if this.SiteToSiteTunnelIp != that1.SiteToSiteTunnelIp {
		return false
	}
	if this.VolterraSoftwareOveride != that1.VolterraSoftwareOveride {
		return false
	}
	if this.BgpRouterId != that1.BgpRouterId {
		return false
	}
	if this.BgpPeerAddress != that1.BgpPeerAddress {
		return false
	}
	if this.InsideNameserver != that1.InsideNameserver {
		return false
	}
	if this.OutsideNameserver != that1.OutsideNameserver {
		return false
	}
	if this.DesiredPoolCount != that1.DesiredPoolCount {
		return false
	}
	if this.TunnelType != that1.TunnelType {
		return false
	}
	if this.OperatingSystemVersion != that1.OperatingSystemVersion {
		return false
	}
	if this.TunnelDeadTimeout != that1.TunnelDeadTimeout {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	if this.CeSiteMode != that1.CeSiteMode {
		return false
	}
	if !this.DefaultUnderlayNetwork.Equal(that1.DefaultUnderlayNetwork) {
		return false
	}
	return true
}
func (this *ReplaceSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplaceSpecType)
	if !ok {
		that2, ok := that.(ReplaceSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if !this.Coordinates.Equal(that1.Coordinates) {
		return false
	}
	if this.VolterraSoftwareVersion != that1.VolterraSoftwareVersion {
		return false
	}
	if this.InsideVip != that1.InsideVip {
		return false
	}
	if this.OutsideVip != that1.OutsideVip {
		return false
	}
	if this.VipVrrpMode != that1.VipVrrpMode {
		return false
	}
	if this.SiteToSiteNetworkType != that1.SiteToSiteNetworkType {
		return false
	}
	if this.SiteToSiteTunnelIp != that1.SiteToSiteTunnelIp {
		return false
	}
	if this.VolterraSoftwareOveride != that1.VolterraSoftwareOveride {
		return false
	}
	if this.BgpRouterId != that1.BgpRouterId {
		return false
	}
	if this.BgpPeerAddress != that1.BgpPeerAddress {
		return false
	}
	if this.InsideNameserver != that1.InsideNameserver {
		return false
	}
	if this.OutsideNameserver != that1.OutsideNameserver {
		return false
	}
	if this.DesiredPoolCount != that1.DesiredPoolCount {
		return false
	}
	if this.TunnelType != that1.TunnelType {
		return false
	}
	if this.OperatingSystemVersion != that1.OperatingSystemVersion {
		return false
	}
	if this.TunnelDeadTimeout != that1.TunnelDeadTimeout {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	if !this.DefaultUnderlayNetwork.Equal(that1.DefaultUnderlayNetwork) {
		return false
	}
	return true
}
func (this *GetSpecType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetSpecType)
	if !ok {
		that2, ok := that.(GetSpecType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SiteType != that1.SiteType {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if !this.Coordinates.Equal(that1.Coordinates) {
		return false
	}
	if this.VolterraSoftwareVersion != that1.VolterraSoftwareVersion {
		return false
	}
	if len(this.ConnectedRe) != len(that1.ConnectedRe) {
		return false
	}
	for i := range this.ConnectedRe {
		if !this.ConnectedRe[i].Equal(that1.ConnectedRe[i]) {
			return false
		}
	}
	if len(this.ConnectedReForConfig) != len(that1.ConnectedReForConfig) {
		return false
	}
	for i := range this.ConnectedReForConfig {
		if !this.ConnectedReForConfig[i].Equal(that1.ConnectedReForConfig[i]) {
			return false
		}
	}
	if this.InsideVip != that1.InsideVip {
		return false
	}
	if this.OutsideVip != that1.OutsideVip {
		return false
	}
	if len(this.VipParamsPerAz) != len(that1.VipParamsPerAz) {
		return false
	}
	for i := range this.VipParamsPerAz {
		if !this.VipParamsPerAz[i].Equal(that1.VipParamsPerAz[i]) {
			return false
		}
	}
	if this.VipVrrpMode != that1.VipVrrpMode {
		return false
	}
	if this.SiteToSiteNetworkType != that1.SiteToSiteNetworkType {
		return false
	}
	if this.SiteToSiteTunnelIp != that1.SiteToSiteTunnelIp {
		return false
	}
	if this.VolterraSoftwareOveride != that1.VolterraSoftwareOveride {
		return false
	}
	if this.BgpRouterId != that1.BgpRouterId {
		return false
	}
	if this.BgpPeerAddress != that1.BgpPeerAddress {
		return false
	}
	if this.InsideNameserver != that1.InsideNameserver {
		return false
	}
	if this.OutsideNameserver != that1.OutsideNameserver {
		return false
	}
	if this.DesiredPoolCount != that1.DesiredPoolCount {
		return false
	}
	if this.TunnelType != that1.TunnelType {
		return false
	}
	if this.OperatingSystemVersion != that1.OperatingSystemVersion {
		return false
	}
	if this.SiteState != that1.SiteState {
		return false
	}
	if this.TunnelDeadTimeout != that1.TunnelDeadTimeout {
		return false
	}
	if this.Region != that1.Region {
		return false
	}
	if this.CeSiteMode != that1.CeSiteMode {
		return false
	}
	if this.LocalK8SAccessEnabled != that1.LocalK8SAccessEnabled {
		return false
	}
	if !this.DefaultUnderlayNetwork.Equal(that1.DefaultUnderlayNetwork) {
		return false
	}
	if this.LocalAccessK8SEnabled != that1.LocalAccessK8SEnabled {
		return false
	}
	if this.GlobalAccessK8SEnabled != that1.GlobalAccessK8SEnabled {
		return false
	}
	return true
}
func (this *VerStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VerStatusType)
	if !ok {
		that2, ok := that.(VerStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VerInstanceName != that1.VerInstanceName {
		return false
	}
	if len(this.IpsecStatus) != len(that1.IpsecStatus) {
		return false
	}
	for i := range this.IpsecStatus {
		if !this.IpsecStatus[i].Equal(that1.IpsecStatus[i]) {
			return false
		}
	}
	if len(this.AresStatus) != len(that1.AresStatus) {
		return false
	}
	for i := range this.AresStatus {
		if !this.AresStatus[i].Equal(that1.AresStatus[i]) {
			return false
		}
	}
	if len(this.IntfStatus) != len(that1.IntfStatus) {
		return false
	}
	for i := range this.IntfStatus {
		if !this.IntfStatus[i].Equal(that1.IntfStatus[i]) {
			return false
		}
	}
	if len(this.ConfiguredTunnelStatus) != len(that1.ConfiguredTunnelStatus) {
		return false
	}
	for i := range this.ConfiguredTunnelStatus {
		if !this.ConfiguredTunnelStatus[i].Equal(that1.ConfiguredTunnelStatus[i]) {
			return false
		}
	}
	if len(this.SiteTunnelStatus) != len(that1.SiteTunnelStatus) {
		return false
	}
	for i := range this.SiteTunnelStatus {
		if !this.SiteTunnelStatus[i].Equal(that1.SiteTunnelStatus[i]) {
			return false
		}
	}
	return true
}
func (this *VerMasterStatusType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VerMasterStatusType)
	if !ok {
		that2, ok := that.(VerMasterStatusType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VerName != that1.VerName {
		return false
	}
	if this.Ver_UID != that1.Ver_UID {
		return false
	}
	if !this.TransitionTimestamp.Equal(that1.TransitionTimestamp) {
		return false
	}
	return true
}
func (this *IpsecConnectionStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IpsecConnectionStatus)
	if !ok {
		that2, ok := that.(IpsecConnectionStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.Role != that1.Role {
		return false
	}
	if this.RemoteAddress != that1.RemoteAddress {
		return false
	}
	if this.IsLocal != that1.IsLocal {
		return false
	}
	if this.VerNodeName != that1.VerNodeName {
		return false
	}
	return true
}
func (this *AresConnectionStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AresConnectionStatus)
	if !ok {
		that2, ok := that.(AresConnectionStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	if this.State != that1.State {
		return false
	}
	return true
}
func (this *InterfaceStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InterfaceStatus)
	if !ok {
		that2, ok := that.(InterfaceStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Ip.Equal(that1.Ip) {
		return false
	}
	if this.Mac != that1.Mac {
		return false
	}
	if this.NetworkType != that1.NetworkType {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.IpMode != that1.IpMode {
		return false
	}
	if this.DhcpServer != that1.DhcpServer {
		return false
	}
	if this.NetworkName != that1.NetworkName {
		return false
	}
	if this.LinkState != that1.LinkState {
		return false
	}
	if this.ActiveState != that1.ActiveState {
		return false
	}
	if this.LinkQuality != that1.LinkQuality {
		return false
	}
	if this.LinkType != that1.LinkType {
		return false
	}
	if len(this.BondMembers) != len(that1.BondMembers) {
		return false
	}
	for i := range this.BondMembers {
		if !this.BondMembers[i].Equal(that1.BondMembers[i]) {
			return false
		}
	}
	if !this.Ipv6.Equal(that1.Ipv6) {
		return false
	}
	return true
}
func (this *TunnelConnectionStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TunnelConnectionStatus)
	if !ok {
		that2, ok := that.(TunnelConnectionStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.Role != that1.Role {
		return false
	}
	if this.RemoteAddress != that1.RemoteAddress {
		return false
	}
	if this.Encap != that1.Encap {
		return false
	}
	if this.IsLocal != that1.IsLocal {
		return false
	}
	if this.VerNodeName != that1.VerNodeName {
		return false
	}
	if this.TunnelName != that1.TunnelName {
		return false
	}
	return true
}
func (this *VolterraSoftwareStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VolterraSoftwareStatus)
	if !ok {
		that2, ok := that.(VolterraSoftwareStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AvailableVersion != that1.AvailableVersion {
		return false
	}
	if !this.DeploymentState.Equal(that1.DeploymentState) {
		return false
	}
	if this.NonconformingState != that1.NonconformingState {
		return false
	}
	return true
}
func (this *OperatingSystemStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OperatingSystemStatus)
	if !ok {
		that2, ok := that.(OperatingSystemStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AvailableVersion != that1.AvailableVersion {
		return false
	}
	if !this.DeploymentState.Equal(that1.DeploymentState) {
		return false
	}
	if this.NonconformingState != that1.NonconformingState {
		return false
	}
	return true
}
func (this *DeploymentState) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeploymentState)
	if !ok {
		that2, ok := that.(DeploymentState)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !this.ModificationTimestamp.Equal(that1.ModificationTimestamp) {
		return false
	}
	if this.Result != that1.Result {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if this.Phase != that1.Phase {
		return false
	}
	return true
}
func (this *FleetDeploymentState) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetDeploymentState)
	if !ok {
		that2, ok := that.(FleetDeploymentState)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Hash != that1.Hash {
		return false
	}
	if !this.ModificationTimestamp.Equal(that1.ModificationTimestamp) {
		return false
	}
	if this.Result != that1.Result {
		return false
	}
	if len(this.Condition) != len(that1.Condition) {
		return false
	}
	for i := range this.Condition {
		if !this.Condition[i].Equal(that1.Condition[i]) {
			return false
		}
	}
	return true
}
func (this *FleetCondition) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetCondition)
	if !ok {
		that2, ok := that.(FleetCondition)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.ModuleName != that1.ModuleName {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if this.Result != that1.Result {
		return false
	}
	return true
}
func (this *FleetStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FleetStatus)
	if !ok {
		that2, ok := that.(FleetStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DeploymentState.Equal(that1.DeploymentState) {
		return false
	}
	return true
}
func (this *ScalingStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScalingStatus)
	if !ok {
		that2, ok := that.(ScalingStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Phase != that1.Phase {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	if this.PoolNodeCountCurrent != that1.PoolNodeCountCurrent {
		return false
	}
	if this.PoolNodeCountTarget != that1.PoolNodeCountTarget {
		return false
	}
	return true
}
func (this *NodeInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeInfo)
	if !ok {
		that2, ok := that.(NodeInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if len(this.Role) != len(that1.Role) {
		return false
	}
	for i := range this.Role {
		if this.Role[i] != that1.Role[i] {
			return false
		}
	}
	return true
}
func (this *OsInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OsInfo)
	if !ok {
		that2, ok := that.(OsInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Os.Equal(that1.Os) {
		return false
	}
	if !this.Product.Equal(that1.Product) {
		return false
	}
	if !this.Board.Equal(that1.Board) {
		return false
	}
	if !this.Chassis.Equal(that1.Chassis) {
		return false
	}
	if !this.Bios.Equal(that1.Bios) {
		return false
	}
	if !this.Cpu.Equal(that1.Cpu) {
		return false
	}
	if !this.Memory.Equal(that1.Memory) {
		return false
	}
	if len(this.Storage) != len(that1.Storage) {
		return false
	}
	for i := range this.Storage {
		if !this.Storage[i].Equal(that1.Storage[i]) {
			return false
		}
	}
	if len(this.Network) != len(that1.Network) {
		return false
	}
	for i := range this.Network {
		if !this.Network[i].Equal(that1.Network[i]) {
			return false
		}
	}
	if !this.Kernel.Equal(that1.Kernel) {
		return false
	}
	if len(this.Usb) != len(that1.Usb) {
		return false
	}
	for i := range this.Usb {
		if !this.Usb[i].Equal(that1.Usb[i]) {
			return false
		}
	}
	if !this.Gpu.Equal(that1.Gpu) {
		return false
	}
	return true
}
func (this *OS) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OS)
	if !ok {
		that2, ok := that.(OS)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Vendor != that1.Vendor {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Release != that1.Release {
		return false
	}
	if this.Architecture != that1.Architecture {
		return false
	}
	return true
}
func (this *Kernel) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Kernel)
	if !ok {
		that2, ok := that.(Kernel)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Release != that1.Release {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Architecture != that1.Architecture {
		return false
	}
	return true
}
func (this *Product) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Product)
	if !ok {
		that2, ok := that.(Product)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Vendor != that1.Vendor {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Serial != that1.Serial {
		return false
	}
	return true
}
func (this *Board) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Board)
	if !ok {
		that2, ok := that.(Board)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Vendor != that1.Vendor {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Serial != that1.Serial {
		return false
	}
	if this.AssetTag != that1.AssetTag {
		return false
	}
	return true
}
func (this *Chassis) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Chassis)
	if !ok {
		that2, ok := that.(Chassis)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Vendor != that1.Vendor {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Serial != that1.Serial {
		return false
	}
	if this.AssetTag != that1.AssetTag {
		return false
	}
	return true
}
func (this *Bios) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Bios)
	if !ok {
		that2, ok := that.(Bios)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Vendor != that1.Vendor {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Date != that1.Date {
		return false
	}
	return true
}
func (this *Cpu) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Cpu)
	if !ok {
		that2, ok := that.(Cpu)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Vendor != that1.Vendor {
		return false
	}
	if this.Model != that1.Model {
		return false
	}
	if this.Speed != that1.Speed {
		return false
	}
	if this.Cache != that1.Cache {
		return false
	}
	if this.Cpus != that1.Cpus {
		return false
	}
	if this.Cores != that1.Cores {
		return false
	}
	if this.Threads != that1.Threads {
		return false
	}
	return true
}
func (this *Memory) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Memory)
	if !ok {
		that2, ok := that.(Memory)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Speed != that1.Speed {
		return false
	}
	if this.SizeMb != that1.SizeMb {
		return false
	}
	return true
}
func (this *StorageDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDevice)
	if !ok {
		that2, ok := that.(StorageDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Driver != that1.Driver {
		return false
	}
	if this.Vendor != that1.Vendor {
		return false
	}
	if this.Model != that1.Model {
		return false
	}
	if this.Serial != that1.Serial {
		return false
	}
	if this.SizeGb != that1.SizeGb {
		return false
	}
	return true
}
func (this *NetworkDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NetworkDevice)
	if !ok {
		that2, ok := that.(NetworkDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Driver != that1.Driver {
		return false
	}
	if len(this.IpAddress) != len(that1.IpAddress) {
		return false
	}
	for i := range this.IpAddress {
		if this.IpAddress[i] != that1.IpAddress[i] {
			return false
		}
	}
	if this.MacAddress != that1.MacAddress {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.Speed != that1.Speed {
		return false
	}
	if this.LinkQuality != that1.LinkQuality {
		return false
	}
	if this.LinkType != that1.LinkType {
		return false
	}
	return true
}
func (this *USBDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*USBDevice)
	if !ok {
		that2, ok := that.(USBDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Bus != that1.Bus {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.VendorName != that1.VendorName {
		return false
	}
	if this.ProductName != that1.ProductName {
		return false
	}
	if this.ISerial != that1.ISerial {
		return false
	}
	if this.IdVendor != that1.IdVendor {
		return false
	}
	if this.IdProduct != that1.IdProduct {
		return false
	}
	if this.IManufacturer != that1.IManufacturer {
		return false
	}
	if this.Speed != that1.Speed {
		return false
	}
	if this.BcdUsb != that1.BcdUsb {
		return false
	}
	if this.BcdDevice != that1.BcdDevice {
		return false
	}
	if this.BDeviceClass != that1.BDeviceClass {
		return false
	}
	if this.BDeviceSubClass != that1.BDeviceSubClass {
		return false
	}
	if this.BDeviceProtocol != that1.BDeviceProtocol {
		return false
	}
	if this.BMaxPacketSize != that1.BMaxPacketSize {
		return false
	}
	if this.IProduct != that1.IProduct {
		return false
	}
	if this.UsbType != that1.UsbType {
		return false
	}
	return true
}
func (this *GPU) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GPU)
	if !ok {
		that2, ok := that.(GPU)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DriverVersion != that1.DriverVersion {
		return false
	}
	if this.CudaVersion != that1.CudaVersion {
		return false
	}
	if len(this.GpuDevice) != len(that1.GpuDevice) {
		return false
	}
	for i := range this.GpuDevice {
		if !this.GpuDevice[i].Equal(that1.GpuDevice[i]) {
			return false
		}
	}
	return true
}
func (this *GPUDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GPUDevice)
	if !ok {
		that2, ok := that.(GPUDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.ProductName != that1.ProductName {
		return false
	}
	if this.Processes != that1.Processes {
		return false
	}
	return true
}
func (this *SiteStatusMetricsFieldData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteStatusMetricsFieldData)
	if !ok {
		that2, ok := that.(SiteStatusMetricsFieldData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Key) != len(that1.Key) {
		return false
	}
	for i := range this.Key {
		if this.Key[i] != that1.Key[i] {
			return false
		}
	}
	if len(this.Value) != len(that1.Value) {
		return false
	}
	for i := range this.Value {
		if !this.Value[i].Equal(that1.Value[i]) {
			return false
		}
	}
	return true
}
func (this *SiteStatusMetricsData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SiteStatusMetricsData)
	if !ok {
		that2, ok := that.(SiteStatusMetricsData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Field != that1.Field {
		return false
	}
	if len(this.Data) != len(that1.Data) {
		return false
	}
	for i := range this.Data {
		if !this.Data[i].Equal(that1.Data[i]) {
			return false
		}
	}
	return true
}
func (this *CreateKubeConfigReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateKubeConfigReq)
	if !ok {
		that2, ok := that.(CreateKubeConfigReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *ListKubeConfigReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListKubeConfigReq)
	if !ok {
		that2, ok := that.(ListKubeConfigReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *ListKubeConfigRspItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListKubeConfigRspItem)
	if !ok {
		that2, ok := that.(ListKubeConfigRspItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if !this.CreateTimestamp.Equal(that1.CreateTimestamp) {
		return false
	}
	if !this.ExpiryTimestamp.Equal(that1.ExpiryTimestamp) {
		return false
	}
	if this.UserEmail != that1.UserEmail {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *ListKubeConfigRsp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListKubeConfigRsp)
	if !ok {
		that2, ok := that.(ListKubeConfigRsp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Items) != len(that1.Items) {
		return false
	}
	for i := range this.Items {
		if !this.Items[i].Equal(that1.Items[i]) {
			return false
		}
	}
	return true
}
func (this *GlobalAccessCheckRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalAccessCheckRequest)
	if !ok {
		that2, ok := that.(GlobalAccessCheckRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *GlobalAccessCheckResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalAccessCheckResponse)
	if !ok {
		that2, ok := that.(GlobalAccessCheckResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Enabled != that1.Enabled {
		return false
	}
	return true
}
func (this *CreateGlobalKubeConfigReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateGlobalKubeConfigReq)
	if !ok {
		that2, ok := that.(CreateGlobalKubeConfigReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Site != that1.Site {
		return false
	}
	if !this.ExpirationTimestamp.Equal(that1.ExpirationTimestamp) {
		return false
	}
	return true
}
func (this *ListGlobalKubeConfigReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListGlobalKubeConfigReq)
	if !ok {
		that2, ok := that.(ListGlobalKubeConfigReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Site != that1.Site {
		return false
	}
	return true
}
func (this *RevokeKubeConfigReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RevokeKubeConfigReq)
	if !ok {
		that2, ok := that.(RevokeKubeConfigReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *KubeConfigStatusRsp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*KubeConfigStatusRsp)
	if !ok {
		that2, ok := that.(KubeConfigStatusRsp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *BondMembersType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&site.BondMembersType{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "LinkState: "+fmt.Sprintf("%#v", this.LinkState)+",\n")
	s = append(s, "LinkSpeed: "+fmt.Sprintf("%#v", this.LinkSpeed)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Coordinates) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&site.Coordinates{")
	s = append(s, "Latitude: "+fmt.Sprintf("%#v", this.Latitude)+",\n")
	s = append(s, "Longitude: "+fmt.Sprintf("%#v", this.Longitude)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *K8SApiServerParameters) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&site.K8SApiServerParameters{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DefaultUnderlayNetworkType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&site.DefaultUnderlayNetworkType{")
	if this.PrivateAccessChoice != nil {
		s = append(s, "PrivateAccessChoice: "+fmt.Sprintf("%#v", this.PrivateAccessChoice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DefaultUnderlayNetworkType_SiteLocalOutside) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&site.DefaultUnderlayNetworkType_SiteLocalOutside{` +
		`SiteLocalOutside:` + fmt.Sprintf("%#v", this.SiteLocalOutside) + `}`}, ", ")
	return s
}
func (this *DefaultUnderlayNetworkType_SiteLocalInside) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&site.DefaultUnderlayNetworkType_SiteLocalInside{` +
		`SiteLocalInside:` + fmt.Sprintf("%#v", this.SiteLocalInside) + `}`}, ", ")
	return s
}
func (this *PublishVIPParamsPerAz) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&site.PublishVIPParamsPerAz{")
	s = append(s, "InsideVip: "+fmt.Sprintf("%#v", this.InsideVip)+",\n")
	s = append(s, "OutsideVip: "+fmt.Sprintf("%#v", this.OutsideVip)+",\n")
	s = append(s, "OutsideVipCname: "+fmt.Sprintf("%#v", this.OutsideVipCname)+",\n")
	s = append(s, "InsideVipCname: "+fmt.Sprintf("%#v", this.InsideVipCname)+",\n")
	s = append(s, "AzName: "+fmt.Sprintf("%#v", this.AzName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 52)
	s = append(s, "&site.GlobalSpecType{")
	s = append(s, "SiteType: "+fmt.Sprintf("%#v", this.SiteType)+",\n")
	s = append(s, "SiteSubtype: "+fmt.Sprintf("%#v", this.SiteSubtype)+",\n")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	if this.Coordinates != nil {
		s = append(s, "Coordinates: "+fmt.Sprintf("%#v", this.Coordinates)+",\n")
	}
	if this.ConnectedRe != nil {
		s = append(s, "ConnectedRe: "+fmt.Sprintf("%#v", this.ConnectedRe)+",\n")
	}
	if this.ConnectedReForConfig != nil {
		s = append(s, "ConnectedReForConfig: "+fmt.Sprintf("%#v", this.ConnectedReForConfig)+",\n")
	}
	if this.Vega != nil {
		s = append(s, "Vega: "+fmt.Sprintf("%#v", this.Vega)+",\n")
	}
	if this.AresList != nil {
		s = append(s, "AresList: "+fmt.Sprintf("%#v", this.AresList)+",\n")
	}
	if this.Rakar != nil {
		s = append(s, "Rakar: "+fmt.Sprintf("%#v", this.Rakar)+",\n")
	}
	if this.Opera != nil {
		s = append(s, "Opera: "+fmt.Sprintf("%#v", this.Opera)+",\n")
	}
	s = append(s, "StaticRoutes: "+fmt.Sprintf("%#v", this.StaticRoutes)+",\n")
	keysForK8SApiServers := make([]string, 0, len(this.K8SApiServers))
	for k, _ := range this.K8SApiServers {
		keysForK8SApiServers = append(keysForK8SApiServers, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForK8SApiServers)
	mapStringForK8SApiServers := "map[string]*K8SApiServerParameters{"
	for _, k := range keysForK8SApiServers {
		mapStringForK8SApiServers += fmt.Sprintf("%#v: %#v,", k, this.K8SApiServers[k])
	}
	mapStringForK8SApiServers += "}"
	if this.K8SApiServers != nil {
		s = append(s, "K8SApiServers: "+mapStringForK8SApiServers+",\n")
	}
	s = append(s, "PublicIp: "+fmt.Sprintf("%#v", this.PublicIp)+",\n")
	s = append(s, "PrivateIp: "+fmt.Sprintf("%#v", this.PrivateIp)+",\n")
	s = append(s, "IpsecSslVipFqdn: "+fmt.Sprintf("%#v", this.IpsecSslVipFqdn)+",\n")
	s = append(s, "ClusterIp: "+fmt.Sprintf("%#v", this.ClusterIp)+",\n")
	if this.AresVtrpList != nil {
		s = append(s, "AresVtrpList: "+fmt.Sprintf("%#v", this.AresVtrpList)+",\n")
	}
	s = append(s, "VolterraSoftwareVersion: "+fmt.Sprintf("%#v", this.VolterraSoftwareVersion)+",\n")
	s = append(s, "InsideVip: "+fmt.Sprintf("%#v", this.InsideVip)+",\n")
	s = append(s, "OutsideVip: "+fmt.Sprintf("%#v", this.OutsideVip)+",\n")
	if this.VipParamsPerAz != nil {
		s = append(s, "VipParamsPerAz: "+fmt.Sprintf("%#v", this.VipParamsPerAz)+",\n")
	}
	s = append(s, "VipVrrpMode: "+fmt.Sprintf("%#v", this.VipVrrpMode)+",\n")
	if this.DefaultUnderlayNetwork != nil {
		s = append(s, "DefaultUnderlayNetwork: "+fmt.Sprintf("%#v", this.DefaultUnderlayNetwork)+",\n")
	}
	s = append(s, "SiteToSiteNetworkType: "+fmt.Sprintf("%#v", this.SiteToSiteNetworkType)+",\n")
	s = append(s, "SiteToSiteTunnelIp: "+fmt.Sprintf("%#v", this.SiteToSiteTunnelIp)+",\n")
	s = append(s, "VolterraSoftwareOveride: "+fmt.Sprintf("%#v", this.VolterraSoftwareOveride)+",\n")
	s = append(s, "BgpRouterId: "+fmt.Sprintf("%#v", this.BgpRouterId)+",\n")
	s = append(s, "BgpPeerAddress: "+fmt.Sprintf("%#v", this.BgpPeerAddress)+",\n")
	keysForTemplateParameters := make([]string, 0, len(this.TemplateParameters))
	for k, _ := range this.TemplateParameters {
		keysForTemplateParameters = append(keysForTemplateParameters, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTemplateParameters)
	mapStringForTemplateParameters := "map[string]string{"
	for _, k := range keysForTemplateParameters {
		mapStringForTemplateParameters += fmt.Sprintf("%#v: %#v,", k, this.TemplateParameters[k])
	}
	mapStringForTemplateParameters += "}"
	if this.TemplateParameters != nil {
		s = append(s, "TemplateParameters: "+mapStringForTemplateParameters+",\n")
	}
	s = append(s, "InsideNameserver: "+fmt.Sprintf("%#v", this.InsideNameserver)+",\n")
	s = append(s, "OutsideNameserver: "+fmt.Sprintf("%#v", this.OutsideNameserver)+",\n")
	s = append(s, "DesiredPoolCount: "+fmt.Sprintf("%#v", this.DesiredPoolCount)+",\n")
	s = append(s, "TunnelType: "+fmt.Sprintf("%#v", this.TunnelType)+",\n")
	s = append(s, "SiteState: "+fmt.Sprintf("%#v", this.SiteState)+",\n")
	s = append(s, "OperatingSystemVersion: "+fmt.Sprintf("%#v", this.OperatingSystemVersion)+",\n")
	if this.MarsList != nil {
		s = append(s, "MarsList: "+fmt.Sprintf("%#v", this.MarsList)+",\n")
	}
	if this.MarsVtrpList != nil {
		s = append(s, "MarsVtrpList: "+fmt.Sprintf("%#v", this.MarsVtrpList)+",\n")
	}
	s = append(s, "TunnelDeadTimeout: "+fmt.Sprintf("%#v", this.TunnelDeadTimeout)+",\n")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	s = append(s, "CeSiteMode: "+fmt.Sprintf("%#v", this.CeSiteMode)+",\n")
	s = append(s, "NoTenantInVk8SNs: "+fmt.Sprintf("%#v", this.NoTenantInVk8SNs)+",\n")
	s = append(s, "LocalK8SAccessEnabled: "+fmt.Sprintf("%#v", this.LocalK8SAccessEnabled)+",\n")
	if this.K8SClusterApiGw != nil {
		s = append(s, "K8SClusterApiGw: "+fmt.Sprintf("%#v", this.K8SClusterApiGw)+",\n")
	}
	s = append(s, "UsePrivateIp: "+fmt.Sprintf("%#v", this.UsePrivateIp)+",\n")
	s = append(s, "TenantIndex: "+fmt.Sprintf("%#v", this.TenantIndex)+",\n")
	s = append(s, "PikuEnabled: "+fmt.Sprintf("%#v", this.PikuEnabled)+",\n")
	s = append(s, "PhobosEnabled: "+fmt.Sprintf("%#v", this.PhobosEnabled)+",\n")
	s = append(s, "Srv6Enabled: "+fmt.Sprintf("%#v", this.Srv6Enabled)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 24)
	s = append(s, "&site.CreateSpecType{")
	s = append(s, "SiteType: "+fmt.Sprintf("%#v", this.SiteType)+",\n")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	if this.Coordinates != nil {
		s = append(s, "Coordinates: "+fmt.Sprintf("%#v", this.Coordinates)+",\n")
	}
	s = append(s, "InsideVip: "+fmt.Sprintf("%#v", this.InsideVip)+",\n")
	s = append(s, "OutsideVip: "+fmt.Sprintf("%#v", this.OutsideVip)+",\n")
	s = append(s, "VipVrrpMode: "+fmt.Sprintf("%#v", this.VipVrrpMode)+",\n")
	s = append(s, "SiteToSiteNetworkType: "+fmt.Sprintf("%#v", this.SiteToSiteNetworkType)+",\n")
	s = append(s, "SiteToSiteTunnelIp: "+fmt.Sprintf("%#v", this.SiteToSiteTunnelIp)+",\n")
	s = append(s, "VolterraSoftwareOveride: "+fmt.Sprintf("%#v", this.VolterraSoftwareOveride)+",\n")
	s = append(s, "BgpRouterId: "+fmt.Sprintf("%#v", this.BgpRouterId)+",\n")
	s = append(s, "BgpPeerAddress: "+fmt.Sprintf("%#v", this.BgpPeerAddress)+",\n")
	s = append(s, "InsideNameserver: "+fmt.Sprintf("%#v", this.InsideNameserver)+",\n")
	s = append(s, "OutsideNameserver: "+fmt.Sprintf("%#v", this.OutsideNameserver)+",\n")
	s = append(s, "DesiredPoolCount: "+fmt.Sprintf("%#v", this.DesiredPoolCount)+",\n")
	s = append(s, "TunnelType: "+fmt.Sprintf("%#v", this.TunnelType)+",\n")
	s = append(s, "OperatingSystemVersion: "+fmt.Sprintf("%#v", this.OperatingSystemVersion)+",\n")
	s = append(s, "TunnelDeadTimeout: "+fmt.Sprintf("%#v", this.TunnelDeadTimeout)+",\n")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	s = append(s, "CeSiteMode: "+fmt.Sprintf("%#v", this.CeSiteMode)+",\n")
	if this.DefaultUnderlayNetwork != nil {
		s = append(s, "DefaultUnderlayNetwork: "+fmt.Sprintf("%#v", this.DefaultUnderlayNetwork)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReplaceSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 23)
	s = append(s, "&site.ReplaceSpecType{")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	if this.Coordinates != nil {
		s = append(s, "Coordinates: "+fmt.Sprintf("%#v", this.Coordinates)+",\n")
	}
	s = append(s, "VolterraSoftwareVersion: "+fmt.Sprintf("%#v", this.VolterraSoftwareVersion)+",\n")
	s = append(s, "InsideVip: "+fmt.Sprintf("%#v", this.InsideVip)+",\n")
	s = append(s, "OutsideVip: "+fmt.Sprintf("%#v", this.OutsideVip)+",\n")
	s = append(s, "VipVrrpMode: "+fmt.Sprintf("%#v", this.VipVrrpMode)+",\n")
	s = append(s, "SiteToSiteNetworkType: "+fmt.Sprintf("%#v", this.SiteToSiteNetworkType)+",\n")
	s = append(s, "SiteToSiteTunnelIp: "+fmt.Sprintf("%#v", this.SiteToSiteTunnelIp)+",\n")
	s = append(s, "VolterraSoftwareOveride: "+fmt.Sprintf("%#v", this.VolterraSoftwareOveride)+",\n")
	s = append(s, "BgpRouterId: "+fmt.Sprintf("%#v", this.BgpRouterId)+",\n")
	s = append(s, "BgpPeerAddress: "+fmt.Sprintf("%#v", this.BgpPeerAddress)+",\n")
	s = append(s, "InsideNameserver: "+fmt.Sprintf("%#v", this.InsideNameserver)+",\n")
	s = append(s, "OutsideNameserver: "+fmt.Sprintf("%#v", this.OutsideNameserver)+",\n")
	s = append(s, "DesiredPoolCount: "+fmt.Sprintf("%#v", this.DesiredPoolCount)+",\n")
	s = append(s, "TunnelType: "+fmt.Sprintf("%#v", this.TunnelType)+",\n")
	s = append(s, "OperatingSystemVersion: "+fmt.Sprintf("%#v", this.OperatingSystemVersion)+",\n")
	s = append(s, "TunnelDeadTimeout: "+fmt.Sprintf("%#v", this.TunnelDeadTimeout)+",\n")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	if this.DefaultUnderlayNetwork != nil {
		s = append(s, "DefaultUnderlayNetwork: "+fmt.Sprintf("%#v", this.DefaultUnderlayNetwork)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetSpecType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 32)
	s = append(s, "&site.GetSpecType{")
	s = append(s, "SiteType: "+fmt.Sprintf("%#v", this.SiteType)+",\n")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	if this.Coordinates != nil {
		s = append(s, "Coordinates: "+fmt.Sprintf("%#v", this.Coordinates)+",\n")
	}
	s = append(s, "VolterraSoftwareVersion: "+fmt.Sprintf("%#v", this.VolterraSoftwareVersion)+",\n")
	if this.ConnectedRe != nil {
		s = append(s, "ConnectedRe: "+fmt.Sprintf("%#v", this.ConnectedRe)+",\n")
	}
	if this.ConnectedReForConfig != nil {
		s = append(s, "ConnectedReForConfig: "+fmt.Sprintf("%#v", this.ConnectedReForConfig)+",\n")
	}
	s = append(s, "InsideVip: "+fmt.Sprintf("%#v", this.InsideVip)+",\n")
	s = append(s, "OutsideVip: "+fmt.Sprintf("%#v", this.OutsideVip)+",\n")
	if this.VipParamsPerAz != nil {
		s = append(s, "VipParamsPerAz: "+fmt.Sprintf("%#v", this.VipParamsPerAz)+",\n")
	}
	s = append(s, "VipVrrpMode: "+fmt.Sprintf("%#v", this.VipVrrpMode)+",\n")
	s = append(s, "SiteToSiteNetworkType: "+fmt.Sprintf("%#v", this.SiteToSiteNetworkType)+",\n")
	s = append(s, "SiteToSiteTunnelIp: "+fmt.Sprintf("%#v", this.SiteToSiteTunnelIp)+",\n")
	s = append(s, "VolterraSoftwareOveride: "+fmt.Sprintf("%#v", this.VolterraSoftwareOveride)+",\n")
	s = append(s, "BgpRouterId: "+fmt.Sprintf("%#v", this.BgpRouterId)+",\n")
	s = append(s, "BgpPeerAddress: "+fmt.Sprintf("%#v", this.BgpPeerAddress)+",\n")
	s = append(s, "InsideNameserver: "+fmt.Sprintf("%#v", this.InsideNameserver)+",\n")
	s = append(s, "OutsideNameserver: "+fmt.Sprintf("%#v", this.OutsideNameserver)+",\n")
	s = append(s, "DesiredPoolCount: "+fmt.Sprintf("%#v", this.DesiredPoolCount)+",\n")
	s = append(s, "TunnelType: "+fmt.Sprintf("%#v", this.TunnelType)+",\n")
	s = append(s, "OperatingSystemVersion: "+fmt.Sprintf("%#v", this.OperatingSystemVersion)+",\n")
	s = append(s, "SiteState: "+fmt.Sprintf("%#v", this.SiteState)+",\n")
	s = append(s, "TunnelDeadTimeout: "+fmt.Sprintf("%#v", this.TunnelDeadTimeout)+",\n")
	s = append(s, "Region: "+fmt.Sprintf("%#v", this.Region)+",\n")
	s = append(s, "CeSiteMode: "+fmt.Sprintf("%#v", this.CeSiteMode)+",\n")
	s = append(s, "LocalK8SAccessEnabled: "+fmt.Sprintf("%#v", this.LocalK8SAccessEnabled)+",\n")
	if this.DefaultUnderlayNetwork != nil {
		s = append(s, "DefaultUnderlayNetwork: "+fmt.Sprintf("%#v", this.DefaultUnderlayNetwork)+",\n")
	}
	s = append(s, "LocalAccessK8SEnabled: "+fmt.Sprintf("%#v", this.LocalAccessK8SEnabled)+",\n")
	s = append(s, "GlobalAccessK8SEnabled: "+fmt.Sprintf("%#v", this.GlobalAccessK8SEnabled)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VerStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&site.VerStatusType{")
	s = append(s, "VerInstanceName: "+fmt.Sprintf("%#v", this.VerInstanceName)+",\n")
	if this.IpsecStatus != nil {
		s = append(s, "IpsecStatus: "+fmt.Sprintf("%#v", this.IpsecStatus)+",\n")
	}
	if this.AresStatus != nil {
		s = append(s, "AresStatus: "+fmt.Sprintf("%#v", this.AresStatus)+",\n")
	}
	if this.IntfStatus != nil {
		s = append(s, "IntfStatus: "+fmt.Sprintf("%#v", this.IntfStatus)+",\n")
	}
	if this.ConfiguredTunnelStatus != nil {
		s = append(s, "ConfiguredTunnelStatus: "+fmt.Sprintf("%#v", this.ConfiguredTunnelStatus)+",\n")
	}
	if this.SiteTunnelStatus != nil {
		s = append(s, "SiteTunnelStatus: "+fmt.Sprintf("%#v", this.SiteTunnelStatus)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VerMasterStatusType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&site.VerMasterStatusType{")
	s = append(s, "VerName: "+fmt.Sprintf("%#v", this.VerName)+",\n")
	s = append(s, "Ver_UID: "+fmt.Sprintf("%#v", this.Ver_UID)+",\n")
	if this.TransitionTimestamp != nil {
		s = append(s, "TransitionTimestamp: "+fmt.Sprintf("%#v", this.TransitionTimestamp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IpsecConnectionStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&site.IpsecConnectionStatus{")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	s = append(s, "RemoteAddress: "+fmt.Sprintf("%#v", this.RemoteAddress)+",\n")
	s = append(s, "IsLocal: "+fmt.Sprintf("%#v", this.IsLocal)+",\n")
	s = append(s, "VerNodeName: "+fmt.Sprintf("%#v", this.VerNodeName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AresConnectionStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&site.AresConnectionStatus{")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InterfaceStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&site.InterfaceStatus{")
	if this.Ip != nil {
		s = append(s, "Ip: "+fmt.Sprintf("%#v", this.Ip)+",\n")
	}
	s = append(s, "Mac: "+fmt.Sprintf("%#v", this.Mac)+",\n")
	s = append(s, "NetworkType: "+fmt.Sprintf("%#v", this.NetworkType)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "IpMode: "+fmt.Sprintf("%#v", this.IpMode)+",\n")
	s = append(s, "DhcpServer: "+fmt.Sprintf("%#v", this.DhcpServer)+",\n")
	s = append(s, "NetworkName: "+fmt.Sprintf("%#v", this.NetworkName)+",\n")
	s = append(s, "LinkState: "+fmt.Sprintf("%#v", this.LinkState)+",\n")
	s = append(s, "ActiveState: "+fmt.Sprintf("%#v", this.ActiveState)+",\n")
	s = append(s, "LinkQuality: "+fmt.Sprintf("%#v", this.LinkQuality)+",\n")
	s = append(s, "LinkType: "+fmt.Sprintf("%#v", this.LinkType)+",\n")
	if this.BondMembers != nil {
		s = append(s, "BondMembers: "+fmt.Sprintf("%#v", this.BondMembers)+",\n")
	}
	if this.Ipv6 != nil {
		s = append(s, "Ipv6: "+fmt.Sprintf("%#v", this.Ipv6)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TunnelConnectionStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&site.TunnelConnectionStatus{")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	s = append(s, "RemoteAddress: "+fmt.Sprintf("%#v", this.RemoteAddress)+",\n")
	s = append(s, "Encap: "+fmt.Sprintf("%#v", this.Encap)+",\n")
	s = append(s, "IsLocal: "+fmt.Sprintf("%#v", this.IsLocal)+",\n")
	s = append(s, "VerNodeName: "+fmt.Sprintf("%#v", this.VerNodeName)+",\n")
	s = append(s, "TunnelName: "+fmt.Sprintf("%#v", this.TunnelName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VolterraSoftwareStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&site.VolterraSoftwareStatus{")
	s = append(s, "AvailableVersion: "+fmt.Sprintf("%#v", this.AvailableVersion)+",\n")
	if this.DeploymentState != nil {
		s = append(s, "DeploymentState: "+fmt.Sprintf("%#v", this.DeploymentState)+",\n")
	}
	s = append(s, "NonconformingState: "+fmt.Sprintf("%#v", this.NonconformingState)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OperatingSystemStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&site.OperatingSystemStatus{")
	s = append(s, "AvailableVersion: "+fmt.Sprintf("%#v", this.AvailableVersion)+",\n")
	if this.DeploymentState != nil {
		s = append(s, "DeploymentState: "+fmt.Sprintf("%#v", this.DeploymentState)+",\n")
	}
	s = append(s, "NonconformingState: "+fmt.Sprintf("%#v", this.NonconformingState)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeploymentState) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&site.DeploymentState{")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	if this.ModificationTimestamp != nil {
		s = append(s, "ModificationTimestamp: "+fmt.Sprintf("%#v", this.ModificationTimestamp)+",\n")
	}
	s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "Phase: "+fmt.Sprintf("%#v", this.Phase)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FleetDeploymentState) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&site.FleetDeploymentState{")
	s = append(s, "Hash: "+fmt.Sprintf("%#v", this.Hash)+",\n")
	if this.ModificationTimestamp != nil {
		s = append(s, "ModificationTimestamp: "+fmt.Sprintf("%#v", this.ModificationTimestamp)+",\n")
	}
	s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	if this.Condition != nil {
		s = append(s, "Condition: "+fmt.Sprintf("%#v", this.Condition)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FleetCondition) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&site.FleetCondition{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "ModuleName: "+fmt.Sprintf("%#v", this.ModuleName)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "Result: "+fmt.Sprintf("%#v", this.Result)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FleetStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&site.FleetStatus{")
	if this.DeploymentState != nil {
		s = append(s, "DeploymentState: "+fmt.Sprintf("%#v", this.DeploymentState)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ScalingStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&site.ScalingStatus{")
	s = append(s, "Phase: "+fmt.Sprintf("%#v", this.Phase)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "PoolNodeCountCurrent: "+fmt.Sprintf("%#v", this.PoolNodeCountCurrent)+",\n")
	s = append(s, "PoolNodeCountTarget: "+fmt.Sprintf("%#v", this.PoolNodeCountTarget)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NodeInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&site.NodeInfo{")
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OsInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&site.OsInfo{")
	if this.Os != nil {
		s = append(s, "Os: "+fmt.Sprintf("%#v", this.Os)+",\n")
	}
	if this.Product != nil {
		s = append(s, "Product: "+fmt.Sprintf("%#v", this.Product)+",\n")
	}
	if this.Board != nil {
		s = append(s, "Board: "+fmt.Sprintf("%#v", this.Board)+",\n")
	}
	if this.Chassis != nil {
		s = append(s, "Chassis: "+fmt.Sprintf("%#v", this.Chassis)+",\n")
	}
	if this.Bios != nil {
		s = append(s, "Bios: "+fmt.Sprintf("%#v", this.Bios)+",\n")
	}
	if this.Cpu != nil {
		s = append(s, "Cpu: "+fmt.Sprintf("%#v", this.Cpu)+",\n")
	}
	if this.Memory != nil {
		s = append(s, "Memory: "+fmt.Sprintf("%#v", this.Memory)+",\n")
	}
	if this.Storage != nil {
		s = append(s, "Storage: "+fmt.Sprintf("%#v", this.Storage)+",\n")
	}
	if this.Network != nil {
		s = append(s, "Network: "+fmt.Sprintf("%#v", this.Network)+",\n")
	}
	if this.Kernel != nil {
		s = append(s, "Kernel: "+fmt.Sprintf("%#v", this.Kernel)+",\n")
	}
	if this.Usb != nil {
		s = append(s, "Usb: "+fmt.Sprintf("%#v", this.Usb)+",\n")
	}
	if this.Gpu != nil {
		s = append(s, "Gpu: "+fmt.Sprintf("%#v", this.Gpu)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OS) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&site.OS{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Vendor: "+fmt.Sprintf("%#v", this.Vendor)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Release: "+fmt.Sprintf("%#v", this.Release)+",\n")
	s = append(s, "Architecture: "+fmt.Sprintf("%#v", this.Architecture)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Kernel) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&site.Kernel{")
	s = append(s, "Release: "+fmt.Sprintf("%#v", this.Release)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Architecture: "+fmt.Sprintf("%#v", this.Architecture)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Product) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&site.Product{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Vendor: "+fmt.Sprintf("%#v", this.Vendor)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Serial: "+fmt.Sprintf("%#v", this.Serial)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Board) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&site.Board{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Vendor: "+fmt.Sprintf("%#v", this.Vendor)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Serial: "+fmt.Sprintf("%#v", this.Serial)+",\n")
	s = append(s, "AssetTag: "+fmt.Sprintf("%#v", this.AssetTag)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Chassis) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&site.Chassis{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Vendor: "+fmt.Sprintf("%#v", this.Vendor)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Serial: "+fmt.Sprintf("%#v", this.Serial)+",\n")
	s = append(s, "AssetTag: "+fmt.Sprintf("%#v", this.AssetTag)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Bios) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&site.Bios{")
	s = append(s, "Vendor: "+fmt.Sprintf("%#v", this.Vendor)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Cpu) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&site.Cpu{")
	s = append(s, "Vendor: "+fmt.Sprintf("%#v", this.Vendor)+",\n")
	s = append(s, "Model: "+fmt.Sprintf("%#v", this.Model)+",\n")
	s = append(s, "Speed: "+fmt.Sprintf("%#v", this.Speed)+",\n")
	s = append(s, "Cache: "+fmt.Sprintf("%#v", this.Cache)+",\n")
	s = append(s, "Cpus: "+fmt.Sprintf("%#v", this.Cpus)+",\n")
	s = append(s, "Cores: "+fmt.Sprintf("%#v", this.Cores)+",\n")
	s = append(s, "Threads: "+fmt.Sprintf("%#v", this.Threads)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Memory) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&site.Memory{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Speed: "+fmt.Sprintf("%#v", this.Speed)+",\n")
	s = append(s, "SizeMb: "+fmt.Sprintf("%#v", this.SizeMb)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StorageDevice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&site.StorageDevice{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Driver: "+fmt.Sprintf("%#v", this.Driver)+",\n")
	s = append(s, "Vendor: "+fmt.Sprintf("%#v", this.Vendor)+",\n")
	s = append(s, "Model: "+fmt.Sprintf("%#v", this.Model)+",\n")
	s = append(s, "Serial: "+fmt.Sprintf("%#v", this.Serial)+",\n")
	s = append(s, "SizeGb: "+fmt.Sprintf("%#v", this.SizeGb)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NetworkDevice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&site.NetworkDevice{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Driver: "+fmt.Sprintf("%#v", this.Driver)+",\n")
	s = append(s, "IpAddress: "+fmt.Sprintf("%#v", this.IpAddress)+",\n")
	s = append(s, "MacAddress: "+fmt.Sprintf("%#v", this.MacAddress)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "Speed: "+fmt.Sprintf("%#v", this.Speed)+",\n")
	s = append(s, "LinkQuality: "+fmt.Sprintf("%#v", this.LinkQuality)+",\n")
	s = append(s, "LinkType: "+fmt.Sprintf("%#v", this.LinkType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *USBDevice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 23)
	s = append(s, "&site.USBDevice{")
	s = append(s, "Bus: "+fmt.Sprintf("%#v", this.Bus)+",\n")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "Description: "+fmt.Sprintf("%#v", this.Description)+",\n")
	s = append(s, "VendorName: "+fmt.Sprintf("%#v", this.VendorName)+",\n")
	s = append(s, "ProductName: "+fmt.Sprintf("%#v", this.ProductName)+",\n")
	s = append(s, "ISerial: "+fmt.Sprintf("%#v", this.ISerial)+",\n")
	s = append(s, "IdVendor: "+fmt.Sprintf("%#v", this.IdVendor)+",\n")
	s = append(s, "IdProduct: "+fmt.Sprintf("%#v", this.IdProduct)+",\n")
	s = append(s, "IManufacturer: "+fmt.Sprintf("%#v", this.IManufacturer)+",\n")
	s = append(s, "Speed: "+fmt.Sprintf("%#v", this.Speed)+",\n")
	s = append(s, "BcdUsb: "+fmt.Sprintf("%#v", this.BcdUsb)+",\n")
	s = append(s, "BcdDevice: "+fmt.Sprintf("%#v", this.BcdDevice)+",\n")
	s = append(s, "BDeviceClass: "+fmt.Sprintf("%#v", this.BDeviceClass)+",\n")
	s = append(s, "BDeviceSubClass: "+fmt.Sprintf("%#v", this.BDeviceSubClass)+",\n")
	s = append(s, "BDeviceProtocol: "+fmt.Sprintf("%#v", this.BDeviceProtocol)+",\n")
	s = append(s, "BMaxPacketSize: "+fmt.Sprintf("%#v", this.BMaxPacketSize)+",\n")
	s = append(s, "IProduct: "+fmt.Sprintf("%#v", this.IProduct)+",\n")
	s = append(s, "UsbType: "+fmt.Sprintf("%#v", this.UsbType)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GPU) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&site.GPU{")
	s = append(s, "DriverVersion: "+fmt.Sprintf("%#v", this.DriverVersion)+",\n")
	s = append(s, "CudaVersion: "+fmt.Sprintf("%#v", this.CudaVersion)+",\n")
	if this.GpuDevice != nil {
		s = append(s, "GpuDevice: "+fmt.Sprintf("%#v", this.GpuDevice)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GPUDevice) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&site.GPUDevice{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "ProductName: "+fmt.Sprintf("%#v", this.ProductName)+",\n")
	s = append(s, "Processes: "+fmt.Sprintf("%#v", this.Processes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteStatusMetricsFieldData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&site.SiteStatusMetricsFieldData{")
	keysForKey := make([]string, 0, len(this.Key))
	for k, _ := range this.Key {
		keysForKey = append(keysForKey, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForKey)
	mapStringForKey := "map[string]string{"
	for _, k := range keysForKey {
		mapStringForKey += fmt.Sprintf("%#v: %#v,", k, this.Key[k])
	}
	mapStringForKey += "}"
	if this.Key != nil {
		s = append(s, "Key: "+mapStringForKey+",\n")
	}
	if this.Value != nil {
		s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SiteStatusMetricsData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&site.SiteStatusMetricsData{")
	s = append(s, "Field: "+fmt.Sprintf("%#v", this.Field)+",\n")
	if this.Data != nil {
		s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateKubeConfigReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&site.CreateKubeConfigReq{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListKubeConfigReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&site.ListKubeConfigReq{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListKubeConfigRspItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&site.ListKubeConfigRspItem{")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	if this.CreateTimestamp != nil {
		s = append(s, "CreateTimestamp: "+fmt.Sprintf("%#v", this.CreateTimestamp)+",\n")
	}
	if this.ExpiryTimestamp != nil {
		s = append(s, "ExpiryTimestamp: "+fmt.Sprintf("%#v", this.ExpiryTimestamp)+",\n")
	}
	s = append(s, "UserEmail: "+fmt.Sprintf("%#v", this.UserEmail)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListKubeConfigRsp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&site.ListKubeConfigRsp{")
	if this.Items != nil {
		s = append(s, "Items: "+fmt.Sprintf("%#v", this.Items)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalAccessCheckRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&site.GlobalAccessCheckRequest{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GlobalAccessCheckResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&site.GlobalAccessCheckResponse{")
	s = append(s, "Enabled: "+fmt.Sprintf("%#v", this.Enabled)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateGlobalKubeConfigReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&site.CreateGlobalKubeConfigReq{")
	s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	if this.ExpirationTimestamp != nil {
		s = append(s, "ExpirationTimestamp: "+fmt.Sprintf("%#v", this.ExpirationTimestamp)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListGlobalKubeConfigReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&site.ListGlobalKubeConfigReq{")
	s = append(s, "Site: "+fmt.Sprintf("%#v", this.Site)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RevokeKubeConfigReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&site.RevokeKubeConfigReq{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *KubeConfigStatusRsp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&site.KubeConfigStatusRsp{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTypes(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *BondMembersType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BondMembersType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BondMembersType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LinkSpeed != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LinkSpeed))
		i--
		dAtA[i] = 0x18
	}
	if m.LinkState {
		i--
		if m.LinkState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Coordinates) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Coordinates) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Coordinates) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Longitude != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Longitude))))
		i--
		dAtA[i] = 0x15
	}
	if m.Latitude != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Latitude))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *K8SApiServerParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *K8SApiServerParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *K8SApiServerParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DefaultUnderlayNetworkType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DefaultUnderlayNetworkType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultUnderlayNetworkType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrivateAccessChoice != nil {
		{
			size := m.PrivateAccessChoice.Size()
			i -= size
			if _, err := m.PrivateAccessChoice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *DefaultUnderlayNetworkType_SiteLocalOutside) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultUnderlayNetworkType_SiteLocalOutside) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteLocalOutside != nil {
		{
			size, err := m.SiteLocalOutside.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *DefaultUnderlayNetworkType_SiteLocalInside) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DefaultUnderlayNetworkType_SiteLocalInside) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SiteLocalInside != nil {
		{
			size, err := m.SiteLocalInside.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *PublishVIPParamsPerAz) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishVIPParamsPerAz) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublishVIPParamsPerAz) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AzName) > 0 {
		i -= len(m.AzName)
		copy(dAtA[i:], m.AzName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AzName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.InsideVipCname) > 0 {
		i -= len(m.InsideVipCname)
		copy(dAtA[i:], m.InsideVipCname)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InsideVipCname)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OutsideVipCname) > 0 {
		i -= len(m.OutsideVipCname)
		copy(dAtA[i:], m.OutsideVipCname)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OutsideVipCname)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OutsideVip) > 0 {
		for iNdEx := len(m.OutsideVip) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OutsideVip[iNdEx])
			copy(dAtA[i:], m.OutsideVip[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.OutsideVip[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.InsideVip) > 0 {
		for iNdEx := len(m.InsideVip) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.InsideVip[iNdEx])
			copy(dAtA[i:], m.InsideVip[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.InsideVip[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Srv6Enabled {
		i--
		if m.Srv6Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0x98
	}
	if m.PhobosEnabled {
		i--
		if m.PhobosEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0x90
	}
	if m.PikuEnabled {
		i--
		if m.PikuEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x9
		i--
		dAtA[i] = 0x88
	}
	if len(m.VipParamsPerAz) > 0 {
		for iNdEx := len(m.VipParamsPerAz) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VipParamsPerAz[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x9
			i--
			dAtA[i] = 0x82
		}
	}
	if m.TenantIndex != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TenantIndex))
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xf0
	}
	if m.DefaultUnderlayNetwork != nil {
		{
			size, err := m.DefaultUnderlayNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xea
	}
	if m.UsePrivateIp {
		i--
		if m.UsePrivateIp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xe0
	}
	if len(m.IpsecSslVipFqdn) > 0 {
		i -= len(m.IpsecSslVipFqdn)
		copy(dAtA[i:], m.IpsecSslVipFqdn)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IpsecSslVipFqdn)))
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xda
	}
	if len(m.PrivateIp) > 0 {
		i -= len(m.PrivateIp)
		copy(dAtA[i:], m.PrivateIp)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PrivateIp)))
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xd2
	}
	if len(m.K8SClusterApiGw) > 0 {
		for iNdEx := len(m.K8SClusterApiGw) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.K8SClusterApiGw[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x8
			i--
			dAtA[i] = 0xca
		}
	}
	if m.LocalK8SAccessEnabled {
		i--
		if m.LocalK8SAccessEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xc0
	}
	if m.NoTenantInVk8SNs {
		i--
		if m.NoTenantInVk8SNs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xb8
	}
	if m.CeSiteMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CeSiteMode))
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xb0
	}
	if m.Opera != nil {
		{
			size, err := m.Opera.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xaa
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xa2
	}
	if m.TunnelDeadTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelDeadTimeout))
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0x98
	}
	if len(m.MarsVtrpList) > 0 {
		for iNdEx := len(m.MarsVtrpList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MarsVtrpList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x8
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.MarsList) > 0 {
		for iNdEx := len(m.MarsList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MarsList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x8
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.OperatingSystemVersion) > 0 {
		i -= len(m.OperatingSystemVersion)
		copy(dAtA[i:], m.OperatingSystemVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OperatingSystemVersion)))
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0x82
	}
	if m.SiteState != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteState))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xf8
	}
	if m.TunnelType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelType))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xf0
	}
	if m.DesiredPoolCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DesiredPoolCount))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xe8
	}
	if len(m.OutsideNameserver) > 0 {
		i -= len(m.OutsideNameserver)
		copy(dAtA[i:], m.OutsideNameserver)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OutsideNameserver)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xe2
	}
	if len(m.InsideNameserver) > 0 {
		i -= len(m.InsideNameserver)
		copy(dAtA[i:], m.InsideNameserver)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InsideNameserver)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xda
	}
	if m.SiteToSiteNetworkType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteToSiteNetworkType))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xd0
	}
	if m.VipVrrpMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VipVrrpMode))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xc8
	}
	if len(m.OutsideVip) > 0 {
		i -= len(m.OutsideVip)
		copy(dAtA[i:], m.OutsideVip)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OutsideVip)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xc2
	}
	if len(m.TemplateParameters) > 0 {
		keysForTemplateParameters := make([]string, 0, len(m.TemplateParameters))
		for k := range m.TemplateParameters {
			keysForTemplateParameters = append(keysForTemplateParameters, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForTemplateParameters)
		for iNdEx := len(keysForTemplateParameters) - 1; iNdEx >= 0; iNdEx-- {
			v := m.TemplateParameters[string(keysForTemplateParameters[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForTemplateParameters[iNdEx])
			copy(dAtA[i:], keysForTemplateParameters[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForTemplateParameters[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x7
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.BgpPeerAddress) > 0 {
		i -= len(m.BgpPeerAddress)
		copy(dAtA[i:], m.BgpPeerAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BgpPeerAddress)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xb2
	}
	if len(m.BgpRouterId) > 0 {
		i -= len(m.BgpRouterId)
		copy(dAtA[i:], m.BgpRouterId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BgpRouterId)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xaa
	}
	if m.VolterraSoftwareOveride != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VolterraSoftwareOveride))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xa0
	}
	if len(m.SiteToSiteTunnelIp) > 0 {
		i -= len(m.SiteToSiteTunnelIp)
		copy(dAtA[i:], m.SiteToSiteTunnelIp)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SiteToSiteTunnelIp)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x9a
	}
	if len(m.InsideVip) > 0 {
		i -= len(m.InsideVip)
		copy(dAtA[i:], m.InsideVip)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InsideVip)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x92
	}
	if len(m.VolterraSoftwareVersion) > 0 {
		i -= len(m.VolterraSoftwareVersion)
		copy(dAtA[i:], m.VolterraSoftwareVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VolterraSoftwareVersion)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x8a
	}
	if len(m.AresVtrpList) > 0 {
		for iNdEx := len(m.AresVtrpList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AresVtrpList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.ClusterIp) > 0 {
		i -= len(m.ClusterIp)
		copy(dAtA[i:], m.ClusterIp)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterIp)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xfa
	}
	if len(m.PublicIp) > 0 {
		i -= len(m.PublicIp)
		copy(dAtA[i:], m.PublicIp)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicIp)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xf2
	}
	if len(m.K8SApiServers) > 0 {
		keysForK8SApiServers := make([]string, 0, len(m.K8SApiServers))
		for k := range m.K8SApiServers {
			keysForK8SApiServers = append(keysForK8SApiServers, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForK8SApiServers)
		for iNdEx := len(keysForK8SApiServers) - 1; iNdEx >= 0; iNdEx-- {
			v := m.K8SApiServers[string(keysForK8SApiServers[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTypes(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForK8SApiServers[iNdEx])
			copy(dAtA[i:], keysForK8SApiServers[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForK8SApiServers[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xea
		}
	}
	if len(m.StaticRoutes) > 0 {
		for iNdEx := len(m.StaticRoutes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StaticRoutes[iNdEx])
			copy(dAtA[i:], m.StaticRoutes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.StaticRoutes[iNdEx])))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xe2
		}
	}
	if m.Rakar != nil {
		{
			size, err := m.Rakar.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xda
	}
	if len(m.AresList) > 0 {
		for iNdEx := len(m.AresList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AresList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xd2
		}
	}
	if m.Vega != nil {
		{
			size, err := m.Vega.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xca
	}
	if len(m.ConnectedReForConfig) > 0 {
		for iNdEx := len(m.ConnectedReForConfig) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConnectedReForConfig[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.ConnectedRe) > 0 {
		for iNdEx := len(m.ConnectedRe) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConnectedRe[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xba
		}
	}
	if m.SiteSubtype != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteSubtype))
		i--
		dAtA[i] = 0x28
	}
	if m.Coordinates != nil {
		{
			size, err := m.Coordinates.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if m.SiteType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DefaultUnderlayNetwork != nil {
		{
			size, err := m.DefaultUnderlayNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xea
	}
	if m.CeSiteMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CeSiteMode))
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xb0
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xa2
	}
	if m.TunnelDeadTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelDeadTimeout))
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0x88
	}
	if len(m.OperatingSystemVersion) > 0 {
		i -= len(m.OperatingSystemVersion)
		copy(dAtA[i:], m.OperatingSystemVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OperatingSystemVersion)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xfa
	}
	if m.TunnelType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelType))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xf0
	}
	if m.DesiredPoolCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DesiredPoolCount))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xe8
	}
	if len(m.OutsideNameserver) > 0 {
		i -= len(m.OutsideNameserver)
		copy(dAtA[i:], m.OutsideNameserver)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OutsideNameserver)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xe2
	}
	if len(m.InsideNameserver) > 0 {
		i -= len(m.InsideNameserver)
		copy(dAtA[i:], m.InsideNameserver)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InsideNameserver)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xda
	}
	if m.SiteToSiteNetworkType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteToSiteNetworkType))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xd0
	}
	if m.VipVrrpMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VipVrrpMode))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xc8
	}
	if len(m.OutsideVip) > 0 {
		i -= len(m.OutsideVip)
		copy(dAtA[i:], m.OutsideVip)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OutsideVip)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xc2
	}
	if len(m.BgpPeerAddress) > 0 {
		i -= len(m.BgpPeerAddress)
		copy(dAtA[i:], m.BgpPeerAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BgpPeerAddress)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xb2
	}
	if len(m.BgpRouterId) > 0 {
		i -= len(m.BgpRouterId)
		copy(dAtA[i:], m.BgpRouterId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BgpRouterId)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xaa
	}
	if m.VolterraSoftwareOveride != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VolterraSoftwareOveride))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xa0
	}
	if len(m.SiteToSiteTunnelIp) > 0 {
		i -= len(m.SiteToSiteTunnelIp)
		copy(dAtA[i:], m.SiteToSiteTunnelIp)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SiteToSiteTunnelIp)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x9a
	}
	if len(m.InsideVip) > 0 {
		i -= len(m.InsideVip)
		copy(dAtA[i:], m.InsideVip)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InsideVip)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x92
	}
	if m.Coordinates != nil {
		{
			size, err := m.Coordinates.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if m.SiteType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DefaultUnderlayNetwork != nil {
		{
			size, err := m.DefaultUnderlayNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xea
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xa2
	}
	if m.TunnelDeadTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelDeadTimeout))
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0x88
	}
	if len(m.OperatingSystemVersion) > 0 {
		i -= len(m.OperatingSystemVersion)
		copy(dAtA[i:], m.OperatingSystemVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OperatingSystemVersion)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xfa
	}
	if m.TunnelType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelType))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xf0
	}
	if m.DesiredPoolCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DesiredPoolCount))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xe8
	}
	if len(m.OutsideNameserver) > 0 {
		i -= len(m.OutsideNameserver)
		copy(dAtA[i:], m.OutsideNameserver)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OutsideNameserver)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xe2
	}
	if len(m.InsideNameserver) > 0 {
		i -= len(m.InsideNameserver)
		copy(dAtA[i:], m.InsideNameserver)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InsideNameserver)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xda
	}
	if m.SiteToSiteNetworkType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteToSiteNetworkType))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xd0
	}
	if m.VipVrrpMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VipVrrpMode))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xc8
	}
	if len(m.OutsideVip) > 0 {
		i -= len(m.OutsideVip)
		copy(dAtA[i:], m.OutsideVip)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OutsideVip)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xc2
	}
	if len(m.BgpPeerAddress) > 0 {
		i -= len(m.BgpPeerAddress)
		copy(dAtA[i:], m.BgpPeerAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BgpPeerAddress)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xb2
	}
	if len(m.BgpRouterId) > 0 {
		i -= len(m.BgpRouterId)
		copy(dAtA[i:], m.BgpRouterId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BgpRouterId)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xaa
	}
	if m.VolterraSoftwareOveride != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VolterraSoftwareOveride))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xa0
	}
	if len(m.SiteToSiteTunnelIp) > 0 {
		i -= len(m.SiteToSiteTunnelIp)
		copy(dAtA[i:], m.SiteToSiteTunnelIp)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SiteToSiteTunnelIp)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x9a
	}
	if len(m.InsideVip) > 0 {
		i -= len(m.InsideVip)
		copy(dAtA[i:], m.InsideVip)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InsideVip)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x92
	}
	if len(m.VolterraSoftwareVersion) > 0 {
		i -= len(m.VolterraSoftwareVersion)
		copy(dAtA[i:], m.VolterraSoftwareVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VolterraSoftwareVersion)))
		i--
		dAtA[i] = 0x22
	}
	if m.Coordinates != nil {
		{
			size, err := m.Coordinates.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *GetSpecType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpecType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpecType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VipParamsPerAz) > 0 {
		for iNdEx := len(m.VipParamsPerAz) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VipParamsPerAz[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x9
			i--
			dAtA[i] = 0x82
		}
	}
	if m.GlobalAccessK8SEnabled {
		i--
		if m.GlobalAccessK8SEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xf8
	}
	if m.LocalAccessK8SEnabled {
		i--
		if m.LocalAccessK8SEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xf0
	}
	if m.DefaultUnderlayNetwork != nil {
		{
			size, err := m.DefaultUnderlayNetwork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xea
	}
	if m.LocalK8SAccessEnabled {
		i--
		if m.LocalK8SAccessEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xc0
	}
	if m.CeSiteMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CeSiteMode))
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xb0
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0xa2
	}
	if m.TunnelDeadTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelDeadTimeout))
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0x88
	}
	if m.SiteState != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteState))
		i--
		dAtA[i] = 0x8
		i--
		dAtA[i] = 0x80
	}
	if len(m.OperatingSystemVersion) > 0 {
		i -= len(m.OperatingSystemVersion)
		copy(dAtA[i:], m.OperatingSystemVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OperatingSystemVersion)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xfa
	}
	if m.TunnelType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TunnelType))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xf0
	}
	if m.DesiredPoolCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DesiredPoolCount))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xe8
	}
	if len(m.OutsideNameserver) > 0 {
		i -= len(m.OutsideNameserver)
		copy(dAtA[i:], m.OutsideNameserver)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OutsideNameserver)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xe2
	}
	if len(m.InsideNameserver) > 0 {
		i -= len(m.InsideNameserver)
		copy(dAtA[i:], m.InsideNameserver)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InsideNameserver)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xda
	}
	if m.SiteToSiteNetworkType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteToSiteNetworkType))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xd0
	}
	if m.VipVrrpMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VipVrrpMode))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xc8
	}
	if len(m.OutsideVip) > 0 {
		i -= len(m.OutsideVip)
		copy(dAtA[i:], m.OutsideVip)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OutsideVip)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xc2
	}
	if len(m.BgpPeerAddress) > 0 {
		i -= len(m.BgpPeerAddress)
		copy(dAtA[i:], m.BgpPeerAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BgpPeerAddress)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xb2
	}
	if len(m.BgpRouterId) > 0 {
		i -= len(m.BgpRouterId)
		copy(dAtA[i:], m.BgpRouterId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BgpRouterId)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xaa
	}
	if m.VolterraSoftwareOveride != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VolterraSoftwareOveride))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0xa0
	}
	if len(m.SiteToSiteTunnelIp) > 0 {
		i -= len(m.SiteToSiteTunnelIp)
		copy(dAtA[i:], m.SiteToSiteTunnelIp)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SiteToSiteTunnelIp)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x9a
	}
	if len(m.InsideVip) > 0 {
		i -= len(m.InsideVip)
		copy(dAtA[i:], m.InsideVip)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InsideVip)))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x92
	}
	if len(m.ConnectedReForConfig) > 0 {
		for iNdEx := len(m.ConnectedReForConfig) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConnectedReForConfig[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xc2
		}
	}
	if len(m.ConnectedRe) > 0 {
		for iNdEx := len(m.ConnectedRe) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConnectedRe[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.VolterraSoftwareVersion) > 0 {
		i -= len(m.VolterraSoftwareVersion)
		copy(dAtA[i:], m.VolterraSoftwareVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VolterraSoftwareVersion)))
		i--
		dAtA[i] = 0x22
	}
	if m.Coordinates != nil {
		{
			size, err := m.Coordinates.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if m.SiteType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SiteType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VerStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SiteTunnelStatus) > 0 {
		for iNdEx := len(m.SiteTunnelStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SiteTunnelStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ConfiguredTunnelStatus) > 0 {
		for iNdEx := len(m.ConfiguredTunnelStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ConfiguredTunnelStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.IntfStatus) > 0 {
		for iNdEx := len(m.IntfStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IntfStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.AresStatus) > 0 {
		for iNdEx := len(m.AresStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AresStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.IpsecStatus) > 0 {
		for iNdEx := len(m.IpsecStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IpsecStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.VerInstanceName) > 0 {
		i -= len(m.VerInstanceName)
		copy(dAtA[i:], m.VerInstanceName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VerInstanceName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VerMasterStatusType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerMasterStatusType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerMasterStatusType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransitionTimestamp != nil {
		{
			size, err := m.TransitionTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Ver_UID) > 0 {
		i -= len(m.Ver_UID)
		copy(dAtA[i:], m.Ver_UID)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Ver_UID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.VerName) > 0 {
		i -= len(m.VerName)
		copy(dAtA[i:], m.VerName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VerName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IpsecConnectionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpsecConnectionStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpsecConnectionStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VerNodeName) > 0 {
		i -= len(m.VerNodeName)
		copy(dAtA[i:], m.VerNodeName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VerNodeName)))
		i--
		dAtA[i] = 0x32
	}
	if m.IsLocal {
		i--
		if m.IsLocal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.RemoteAddress) > 0 {
		i -= len(m.RemoteAddress)
		copy(dAtA[i:], m.RemoteAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RemoteAddress)))
		i--
		dAtA[i] = 0x22
	}
	if m.Role != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Role))
		i--
		dAtA[i] = 0x18
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AresConnectionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AresConnectionStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AresConnectionStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InterfaceStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InterfaceStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InterfaceStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ipv6 != nil {
		{
			size, err := m.Ipv6.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if len(m.BondMembers) > 0 {
		for iNdEx := len(m.BondMembers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BondMembers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.LinkType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LinkType))
		i--
		dAtA[i] = 0x60
	}
	if m.LinkQuality != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LinkQuality))
		i--
		dAtA[i] = 0x58
	}
	if m.ActiveState != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ActiveState))
		i--
		dAtA[i] = 0x50
	}
	if m.LinkState {
		i--
		if m.LinkState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.NetworkName) > 0 {
		i -= len(m.NetworkName)
		copy(dAtA[i:], m.NetworkName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NetworkName)))
		i--
		dAtA[i] = 0x42
	}
	if m.DhcpServer {
		i--
		if m.DhcpServer {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.IpMode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.IpMode))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.NetworkType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NetworkType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Mac) > 0 {
		i -= len(m.Mac)
		copy(dAtA[i:], m.Mac)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Mac)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ip != nil {
		{
			size, err := m.Ip.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TunnelConnectionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelConnectionStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelConnectionStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TunnelName) > 0 {
		i -= len(m.TunnelName)
		copy(dAtA[i:], m.TunnelName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TunnelName)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.VerNodeName) > 0 {
		i -= len(m.VerNodeName)
		copy(dAtA[i:], m.VerNodeName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VerNodeName)))
		i--
		dAtA[i] = 0x3a
	}
	if m.IsLocal {
		i--
		if m.IsLocal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Encap != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Encap))
		i--
		dAtA[i] = 0x28
	}
	if len(m.RemoteAddress) > 0 {
		i -= len(m.RemoteAddress)
		copy(dAtA[i:], m.RemoteAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RemoteAddress)))
		i--
		dAtA[i] = 0x22
	}
	if m.Role != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Role))
		i--
		dAtA[i] = 0x18
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VolterraSoftwareStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolterraSoftwareStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VolterraSoftwareStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NonconformingState) > 0 {
		i -= len(m.NonconformingState)
		copy(dAtA[i:], m.NonconformingState)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NonconformingState)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DeploymentState != nil {
		{
			size, err := m.DeploymentState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.AvailableVersion) > 0 {
		i -= len(m.AvailableVersion)
		copy(dAtA[i:], m.AvailableVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AvailableVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OperatingSystemStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperatingSystemStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperatingSystemStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NonconformingState) > 0 {
		i -= len(m.NonconformingState)
		copy(dAtA[i:], m.NonconformingState)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NonconformingState)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DeploymentState != nil {
		{
			size, err := m.DeploymentState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.AvailableVersion) > 0 {
		i -= len(m.AvailableVersion)
		copy(dAtA[i:], m.AvailableVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AvailableVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeploymentState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeploymentState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeploymentState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Phase != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Phase))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ModificationTimestamp != nil {
		{
			size, err := m.ModificationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FleetDeploymentState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FleetDeploymentState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FleetDeploymentState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Condition) > 0 {
		for iNdEx := len(m.Condition) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Condition[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ModificationTimestamp != nil {
		{
			size, err := m.ModificationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FleetCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FleetCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FleetCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ModuleName) > 0 {
		i -= len(m.ModuleName)
		copy(dAtA[i:], m.ModuleName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ModuleName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FleetStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FleetStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FleetStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeploymentState != nil {
		{
			size, err := m.DeploymentState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScalingStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScalingStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScalingStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PoolNodeCountTarget != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PoolNodeCountTarget))
		i--
		dAtA[i] = 0x20
	}
	if m.PoolNodeCountCurrent != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PoolNodeCountCurrent))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Phase != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Phase))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Role) > 0 {
		for iNdEx := len(m.Role) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Role[iNdEx])
			copy(dAtA[i:], m.Role[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Role[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OsInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OsInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OsInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Gpu != nil {
		{
			size, err := m.Gpu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.Usb) > 0 {
		for iNdEx := len(m.Usb) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Usb[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.Kernel != nil {
		{
			size, err := m.Kernel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Network) > 0 {
		for iNdEx := len(m.Network) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Network[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Storage) > 0 {
		for iNdEx := len(m.Storage) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Storage[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Memory != nil {
		{
			size, err := m.Memory.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Cpu != nil {
		{
			size, err := m.Cpu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Bios != nil {
		{
			size, err := m.Bios.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Chassis != nil {
		{
			size, err := m.Chassis.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Board != nil {
		{
			size, err := m.Board.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Product != nil {
		{
			size, err := m.Product.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Os != nil {
		{
			size, err := m.Os.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Architecture) > 0 {
		i -= len(m.Architecture)
		copy(dAtA[i:], m.Architecture)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Architecture)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Release) > 0 {
		i -= len(m.Release)
		copy(dAtA[i:], m.Release)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Release)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Vendor) > 0 {
		i -= len(m.Vendor)
		copy(dAtA[i:], m.Vendor)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Vendor)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Kernel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Kernel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Kernel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Architecture) > 0 {
		i -= len(m.Architecture)
		copy(dAtA[i:], m.Architecture)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Architecture)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Release) > 0 {
		i -= len(m.Release)
		copy(dAtA[i:], m.Release)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Release)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Product) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Product) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Product) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Serial) > 0 {
		i -= len(m.Serial)
		copy(dAtA[i:], m.Serial)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Serial)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Vendor) > 0 {
		i -= len(m.Vendor)
		copy(dAtA[i:], m.Vendor)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Vendor)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Board) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Board) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Board) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssetTag) > 0 {
		i -= len(m.AssetTag)
		copy(dAtA[i:], m.AssetTag)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AssetTag)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Serial) > 0 {
		i -= len(m.Serial)
		copy(dAtA[i:], m.Serial)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Serial)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Vendor) > 0 {
		i -= len(m.Vendor)
		copy(dAtA[i:], m.Vendor)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Vendor)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Chassis) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chassis) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Chassis) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssetTag) > 0 {
		i -= len(m.AssetTag)
		copy(dAtA[i:], m.AssetTag)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AssetTag)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Serial) > 0 {
		i -= len(m.Serial)
		copy(dAtA[i:], m.Serial)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Serial)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Vendor) > 0 {
		i -= len(m.Vendor)
		copy(dAtA[i:], m.Vendor)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Vendor)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Bios) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bios) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Bios) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Date) > 0 {
		i -= len(m.Date)
		copy(dAtA[i:], m.Date)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Date)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Vendor) > 0 {
		i -= len(m.Vendor)
		copy(dAtA[i:], m.Vendor)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Vendor)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Cpu) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cpu) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cpu) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Threads != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Threads))
		i--
		dAtA[i] = 0x38
	}
	if m.Cores != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Cores))
		i--
		dAtA[i] = 0x30
	}
	if m.Cpus != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Cpus))
		i--
		dAtA[i] = 0x28
	}
	if m.Cache != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Cache))
		i--
		dAtA[i] = 0x20
	}
	if m.Speed != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Speed))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Model) > 0 {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Vendor) > 0 {
		i -= len(m.Vendor)
		copy(dAtA[i:], m.Vendor)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Vendor)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Memory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Memory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Memory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SizeMb != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SizeMb))
		i--
		dAtA[i] = 0x18
	}
	if m.Speed != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Speed))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StorageDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SizeGb != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SizeGb))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Serial) > 0 {
		i -= len(m.Serial)
		copy(dAtA[i:], m.Serial)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Serial)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Model) > 0 {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Vendor) > 0 {
		i -= len(m.Vendor)
		copy(dAtA[i:], m.Vendor)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Vendor)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Driver) > 0 {
		i -= len(m.Driver)
		copy(dAtA[i:], m.Driver)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Driver)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NetworkDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LinkType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LinkType))
		i--
		dAtA[i] = 0x40
	}
	if m.LinkQuality != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LinkQuality))
		i--
		dAtA[i] = 0x38
	}
	if m.Speed != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Speed))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Port) > 0 {
		i -= len(m.Port)
		copy(dAtA[i:], m.Port)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Port)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.MacAddress) > 0 {
		i -= len(m.MacAddress)
		copy(dAtA[i:], m.MacAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MacAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.IpAddress) > 0 {
		for iNdEx := len(m.IpAddress) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IpAddress[iNdEx])
			copy(dAtA[i:], m.IpAddress[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.IpAddress[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Driver) > 0 {
		i -= len(m.Driver)
		copy(dAtA[i:], m.Driver)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Driver)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *USBDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *USBDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *USBDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UsbType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UsbType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if len(m.IProduct) > 0 {
		i -= len(m.IProduct)
		copy(dAtA[i:], m.IProduct)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IProduct)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.BMaxPacketSize != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BMaxPacketSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if len(m.BDeviceProtocol) > 0 {
		i -= len(m.BDeviceProtocol)
		copy(dAtA[i:], m.BDeviceProtocol)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BDeviceProtocol)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.BDeviceSubClass) > 0 {
		i -= len(m.BDeviceSubClass)
		copy(dAtA[i:], m.BDeviceSubClass)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BDeviceSubClass)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.BDeviceClass) > 0 {
		i -= len(m.BDeviceClass)
		copy(dAtA[i:], m.BDeviceClass)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BDeviceClass)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.BcdDevice) > 0 {
		i -= len(m.BcdDevice)
		copy(dAtA[i:], m.BcdDevice)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BcdDevice)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.BcdUsb) > 0 {
		i -= len(m.BcdUsb)
		copy(dAtA[i:], m.BcdUsb)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BcdUsb)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.Speed) > 0 {
		i -= len(m.Speed)
		copy(dAtA[i:], m.Speed)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Speed)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.IManufacturer) > 0 {
		i -= len(m.IManufacturer)
		copy(dAtA[i:], m.IManufacturer)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IManufacturer)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.IdProduct) > 0 {
		i -= len(m.IdProduct)
		copy(dAtA[i:], m.IdProduct)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IdProduct)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.IdVendor) > 0 {
		i -= len(m.IdVendor)
		copy(dAtA[i:], m.IdVendor)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IdVendor)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.ISerial) > 0 {
		i -= len(m.ISerial)
		copy(dAtA[i:], m.ISerial)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ISerial)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.ProductName) > 0 {
		i -= len(m.ProductName)
		copy(dAtA[i:], m.ProductName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProductName)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.VendorName) > 0 {
		i -= len(m.VendorName)
		copy(dAtA[i:], m.VendorName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VendorName)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Port != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x18
	}
	if m.Address != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Address))
		i--
		dAtA[i] = 0x10
	}
	if m.Bus != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Bus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GPU) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPU) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GPU) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GpuDevice) > 0 {
		for iNdEx := len(m.GpuDevice) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GpuDevice[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CudaVersion) > 0 {
		i -= len(m.CudaVersion)
		copy(dAtA[i:], m.CudaVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CudaVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DriverVersion) > 0 {
		i -= len(m.DriverVersion)
		copy(dAtA[i:], m.DriverVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DriverVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GPUDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GPUDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Processes) > 0 {
		i -= len(m.Processes)
		copy(dAtA[i:], m.Processes)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Processes)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ProductName) > 0 {
		i -= len(m.ProductName)
		copy(dAtA[i:], m.ProductName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProductName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SiteStatusMetricsFieldData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteStatusMetricsFieldData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteStatusMetricsFieldData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		for iNdEx := len(m.Value) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Value[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Key) > 0 {
		keysForKey := make([]string, 0, len(m.Key))
		for k := range m.Key {
			keysForKey = append(keysForKey, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForKey)
		for iNdEx := len(keysForKey) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Key[string(keysForKey[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForKey[iNdEx])
			copy(dAtA[i:], keysForKey[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(keysForKey[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SiteStatusMetricsData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SiteStatusMetricsData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SiteStatusMetricsData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Field != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Field))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateKubeConfigReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateKubeConfigReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateKubeConfigReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListKubeConfigReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListKubeConfigReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListKubeConfigReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListKubeConfigRspItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListKubeConfigRspItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListKubeConfigRspItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.UserEmail) > 0 {
		i -= len(m.UserEmail)
		copy(dAtA[i:], m.UserEmail)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UserEmail)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ExpiryTimestamp != nil {
		{
			size, err := m.ExpiryTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.CreateTimestamp != nil {
		{
			size, err := m.CreateTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *ListKubeConfigRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListKubeConfigRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListKubeConfigRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GlobalAccessCheckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalAccessCheckRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalAccessCheckRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalAccessCheckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalAccessCheckResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalAccessCheckResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateGlobalKubeConfigReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateGlobalKubeConfigReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateGlobalKubeConfigReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpirationTimestamp != nil {
		{
			size, err := m.ExpirationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Site) > 0 {
		i -= len(m.Site)
		copy(dAtA[i:], m.Site)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Site)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListGlobalKubeConfigReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListGlobalKubeConfigReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListGlobalKubeConfigReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Site) > 0 {
		i -= len(m.Site)
		copy(dAtA[i:], m.Site)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Site)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RevokeKubeConfigReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RevokeKubeConfigReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RevokeKubeConfigReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KubeConfigStatusRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubeConfigStatusRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubeConfigStatusRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BondMembersType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LinkState {
		n += 2
	}
	if m.LinkSpeed != 0 {
		n += 1 + sovTypes(uint64(m.LinkSpeed))
	}
	return n
}

func (m *Coordinates) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Latitude != 0 {
		n += 5
	}
	if m.Longitude != 0 {
		n += 5
	}
	return n
}

func (m *K8SApiServerParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DefaultUnderlayNetworkType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrivateAccessChoice != nil {
		n += m.PrivateAccessChoice.Size()
	}
	return n
}

func (m *DefaultUnderlayNetworkType_SiteLocalOutside) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteLocalOutside != nil {
		l = m.SiteLocalOutside.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *DefaultUnderlayNetworkType_SiteLocalInside) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteLocalInside != nil {
		l = m.SiteLocalInside.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *PublishVIPParamsPerAz) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.InsideVip) > 0 {
		for _, s := range m.InsideVip {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.OutsideVip) > 0 {
		for _, s := range m.OutsideVip {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.OutsideVipCname)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.InsideVipCname)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AzName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteType != 0 {
		n += 1 + sovTypes(uint64(m.SiteType))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Coordinates != nil {
		l = m.Coordinates.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SiteSubtype != 0 {
		n += 1 + sovTypes(uint64(m.SiteSubtype))
	}
	if len(m.ConnectedRe) > 0 {
		for _, e := range m.ConnectedRe {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ConnectedReForConfig) > 0 {
		for _, e := range m.ConnectedReForConfig {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.Vega != nil {
		l = m.Vega.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.AresList) > 0 {
		for _, e := range m.AresList {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.Rakar != nil {
		l = m.Rakar.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.StaticRoutes) > 0 {
		for _, s := range m.StaticRoutes {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.K8SApiServers) > 0 {
		for k, v := range m.K8SApiServers {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.PublicIp)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.ClusterIp)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.AresVtrpList) > 0 {
		for _, e := range m.AresVtrpList {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.VolterraSoftwareVersion)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.InsideVip)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.SiteToSiteTunnelIp)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.VolterraSoftwareOveride != 0 {
		n += 2 + sovTypes(uint64(m.VolterraSoftwareOveride))
	}
	l = len(m.BgpRouterId)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.BgpPeerAddress)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.TemplateParameters) > 0 {
		for k, v := range m.TemplateParameters {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 2 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.OutsideVip)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.VipVrrpMode != 0 {
		n += 2 + sovTypes(uint64(m.VipVrrpMode))
	}
	if m.SiteToSiteNetworkType != 0 {
		n += 2 + sovTypes(uint64(m.SiteToSiteNetworkType))
	}
	l = len(m.InsideNameserver)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.OutsideNameserver)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DesiredPoolCount != 0 {
		n += 2 + sovTypes(uint64(m.DesiredPoolCount))
	}
	if m.TunnelType != 0 {
		n += 2 + sovTypes(uint64(m.TunnelType))
	}
	if m.SiteState != 0 {
		n += 2 + sovTypes(uint64(m.SiteState))
	}
	l = len(m.OperatingSystemVersion)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if len(m.MarsList) > 0 {
		for _, e := range m.MarsList {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.MarsVtrpList) > 0 {
		for _, e := range m.MarsVtrpList {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.TunnelDeadTimeout != 0 {
		n += 2 + sovTypes(uint64(m.TunnelDeadTimeout))
	}
	l = len(m.Region)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.Opera != nil {
		l = m.Opera.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.CeSiteMode != 0 {
		n += 2 + sovTypes(uint64(m.CeSiteMode))
	}
	if m.NoTenantInVk8SNs {
		n += 3
	}
	if m.LocalK8SAccessEnabled {
		n += 3
	}
	if len(m.K8SClusterApiGw) > 0 {
		for _, e := range m.K8SClusterApiGw {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.PrivateIp)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.IpsecSslVipFqdn)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.UsePrivateIp {
		n += 3
	}
	if m.DefaultUnderlayNetwork != nil {
		l = m.DefaultUnderlayNetwork.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.TenantIndex != 0 {
		n += 2 + sovTypes(uint64(m.TenantIndex))
	}
	if len(m.VipParamsPerAz) > 0 {
		for _, e := range m.VipParamsPerAz {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.PikuEnabled {
		n += 3
	}
	if m.PhobosEnabled {
		n += 3
	}
	if m.Srv6Enabled {
		n += 3
	}
	return n
}

func (m *CreateSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteType != 0 {
		n += 1 + sovTypes(uint64(m.SiteType))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Coordinates != nil {
		l = m.Coordinates.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.InsideVip)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.SiteToSiteTunnelIp)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.VolterraSoftwareOveride != 0 {
		n += 2 + sovTypes(uint64(m.VolterraSoftwareOveride))
	}
	l = len(m.BgpRouterId)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.BgpPeerAddress)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.OutsideVip)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.VipVrrpMode != 0 {
		n += 2 + sovTypes(uint64(m.VipVrrpMode))
	}
	if m.SiteToSiteNetworkType != 0 {
		n += 2 + sovTypes(uint64(m.SiteToSiteNetworkType))
	}
	l = len(m.InsideNameserver)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.OutsideNameserver)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DesiredPoolCount != 0 {
		n += 2 + sovTypes(uint64(m.DesiredPoolCount))
	}
	if m.TunnelType != 0 {
		n += 2 + sovTypes(uint64(m.TunnelType))
	}
	l = len(m.OperatingSystemVersion)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.TunnelDeadTimeout != 0 {
		n += 2 + sovTypes(uint64(m.TunnelDeadTimeout))
	}
	l = len(m.Region)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.CeSiteMode != 0 {
		n += 2 + sovTypes(uint64(m.CeSiteMode))
	}
	if m.DefaultUnderlayNetwork != nil {
		l = m.DefaultUnderlayNetwork.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ReplaceSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Coordinates != nil {
		l = m.Coordinates.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VolterraSoftwareVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.InsideVip)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.SiteToSiteTunnelIp)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.VolterraSoftwareOveride != 0 {
		n += 2 + sovTypes(uint64(m.VolterraSoftwareOveride))
	}
	l = len(m.BgpRouterId)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.BgpPeerAddress)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.OutsideVip)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.VipVrrpMode != 0 {
		n += 2 + sovTypes(uint64(m.VipVrrpMode))
	}
	if m.SiteToSiteNetworkType != 0 {
		n += 2 + sovTypes(uint64(m.SiteToSiteNetworkType))
	}
	l = len(m.InsideNameserver)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.OutsideNameserver)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DesiredPoolCount != 0 {
		n += 2 + sovTypes(uint64(m.DesiredPoolCount))
	}
	if m.TunnelType != 0 {
		n += 2 + sovTypes(uint64(m.TunnelType))
	}
	l = len(m.OperatingSystemVersion)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.TunnelDeadTimeout != 0 {
		n += 2 + sovTypes(uint64(m.TunnelDeadTimeout))
	}
	l = len(m.Region)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DefaultUnderlayNetwork != nil {
		l = m.DefaultUnderlayNetwork.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GetSpecType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SiteType != 0 {
		n += 1 + sovTypes(uint64(m.SiteType))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Coordinates != nil {
		l = m.Coordinates.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VolterraSoftwareVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.ConnectedRe) > 0 {
		for _, e := range m.ConnectedRe {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ConnectedReForConfig) > 0 {
		for _, e := range m.ConnectedReForConfig {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.InsideVip)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.SiteToSiteTunnelIp)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.VolterraSoftwareOveride != 0 {
		n += 2 + sovTypes(uint64(m.VolterraSoftwareOveride))
	}
	l = len(m.BgpRouterId)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.BgpPeerAddress)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.OutsideVip)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.VipVrrpMode != 0 {
		n += 2 + sovTypes(uint64(m.VipVrrpMode))
	}
	if m.SiteToSiteNetworkType != 0 {
		n += 2 + sovTypes(uint64(m.SiteToSiteNetworkType))
	}
	l = len(m.InsideNameserver)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.OutsideNameserver)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.DesiredPoolCount != 0 {
		n += 2 + sovTypes(uint64(m.DesiredPoolCount))
	}
	if m.TunnelType != 0 {
		n += 2 + sovTypes(uint64(m.TunnelType))
	}
	l = len(m.OperatingSystemVersion)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.SiteState != 0 {
		n += 2 + sovTypes(uint64(m.SiteState))
	}
	if m.TunnelDeadTimeout != 0 {
		n += 2 + sovTypes(uint64(m.TunnelDeadTimeout))
	}
	l = len(m.Region)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.CeSiteMode != 0 {
		n += 2 + sovTypes(uint64(m.CeSiteMode))
	}
	if m.LocalK8SAccessEnabled {
		n += 3
	}
	if m.DefaultUnderlayNetwork != nil {
		l = m.DefaultUnderlayNetwork.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.LocalAccessK8SEnabled {
		n += 3
	}
	if m.GlobalAccessK8SEnabled {
		n += 3
	}
	if len(m.VipParamsPerAz) > 0 {
		for _, e := range m.VipParamsPerAz {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *VerStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VerInstanceName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.IpsecStatus) > 0 {
		for _, e := range m.IpsecStatus {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AresStatus) > 0 {
		for _, e := range m.AresStatus {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.IntfStatus) > 0 {
		for _, e := range m.IntfStatus {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ConfiguredTunnelStatus) > 0 {
		for _, e := range m.ConfiguredTunnelStatus {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.SiteTunnelStatus) > 0 {
		for _, e := range m.SiteTunnelStatus {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *VerMasterStatusType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VerName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Ver_UID)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TransitionTimestamp != nil {
		l = m.TransitionTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *IpsecConnectionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	if m.Role != 0 {
		n += 1 + sovTypes(uint64(m.Role))
	}
	l = len(m.RemoteAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IsLocal {
		n += 2
	}
	l = len(m.VerNodeName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *AresConnectionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	return n
}

func (m *InterfaceStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ip != nil {
		l = m.Ip.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Mac)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NetworkType != 0 {
		n += 1 + sovTypes(uint64(m.NetworkType))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IpMode != 0 {
		n += 1 + sovTypes(uint64(m.IpMode))
	}
	if m.DhcpServer {
		n += 2
	}
	l = len(m.NetworkName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LinkState {
		n += 2
	}
	if m.ActiveState != 0 {
		n += 1 + sovTypes(uint64(m.ActiveState))
	}
	if m.LinkQuality != 0 {
		n += 1 + sovTypes(uint64(m.LinkQuality))
	}
	if m.LinkType != 0 {
		n += 1 + sovTypes(uint64(m.LinkType))
	}
	if len(m.BondMembers) > 0 {
		for _, e := range m.BondMembers {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Ipv6 != nil {
		l = m.Ipv6.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *TunnelConnectionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	if m.Role != 0 {
		n += 1 + sovTypes(uint64(m.Role))
	}
	l = len(m.RemoteAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Encap != 0 {
		n += 1 + sovTypes(uint64(m.Encap))
	}
	if m.IsLocal {
		n += 2
	}
	l = len(m.VerNodeName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TunnelName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *VolterraSoftwareStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AvailableVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DeploymentState != nil {
		l = m.DeploymentState.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.NonconformingState)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *OperatingSystemStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AvailableVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DeploymentState != nil {
		l = m.DeploymentState.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.NonconformingState)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *DeploymentState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ModificationTimestamp != nil {
		l = m.ModificationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Phase != 0 {
		n += 1 + sovTypes(uint64(m.Phase))
	}
	return n
}

func (m *FleetDeploymentState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ModificationTimestamp != nil {
		l = m.ModificationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Condition) > 0 {
		for _, e := range m.Condition {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *FleetCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ModuleName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *FleetStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeploymentState != nil {
		l = m.DeploymentState.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ScalingStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Phase != 0 {
		n += 1 + sovTypes(uint64(m.Phase))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PoolNodeCountCurrent != 0 {
		n += 1 + sovTypes(uint64(m.PoolNodeCountCurrent))
	}
	if m.PoolNodeCountTarget != 0 {
		n += 1 + sovTypes(uint64(m.PoolNodeCountTarget))
	}
	return n
}

func (m *NodeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Role) > 0 {
		for _, s := range m.Role {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *OsInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Os != nil {
		l = m.Os.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Product != nil {
		l = m.Product.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Board != nil {
		l = m.Board.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Chassis != nil {
		l = m.Chassis.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Bios != nil {
		l = m.Bios.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Cpu != nil {
		l = m.Cpu.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Memory != nil {
		l = m.Memory.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Storage) > 0 {
		for _, e := range m.Storage {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Network) > 0 {
		for _, e := range m.Network {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Kernel != nil {
		l = m.Kernel.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Usb) > 0 {
		for _, e := range m.Usb {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Gpu != nil {
		l = m.Gpu.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *OS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Release)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Architecture)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Kernel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Release)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Architecture)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Product) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Serial)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Board) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Serial)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AssetTag)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Chassis) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Serial)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AssetTag)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Bios) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Cpu) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Speed != 0 {
		n += 1 + sovTypes(uint64(m.Speed))
	}
	if m.Cache != 0 {
		n += 1 + sovTypes(uint64(m.Cache))
	}
	if m.Cpus != 0 {
		n += 1 + sovTypes(uint64(m.Cpus))
	}
	if m.Cores != 0 {
		n += 1 + sovTypes(uint64(m.Cores))
	}
	if m.Threads != 0 {
		n += 1 + sovTypes(uint64(m.Threads))
	}
	return n
}

func (m *Memory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Speed != 0 {
		n += 1 + sovTypes(uint64(m.Speed))
	}
	if m.SizeMb != 0 {
		n += 1 + sovTypes(uint64(m.SizeMb))
	}
	return n
}

func (m *StorageDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Driver)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Serial)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SizeGb != 0 {
		n += 1 + sovTypes(uint64(m.SizeGb))
	}
	return n
}

func (m *NetworkDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Driver)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.IpAddress) > 0 {
		for _, s := range m.IpAddress {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.MacAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Port)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Speed != 0 {
		n += 1 + sovTypes(uint64(m.Speed))
	}
	if m.LinkQuality != 0 {
		n += 1 + sovTypes(uint64(m.LinkQuality))
	}
	if m.LinkType != 0 {
		n += 1 + sovTypes(uint64(m.LinkType))
	}
	return n
}

func (m *USBDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bus != 0 {
		n += 1 + sovTypes(uint64(m.Bus))
	}
	if m.Address != 0 {
		n += 1 + sovTypes(uint64(m.Address))
	}
	if m.Port != 0 {
		n += 1 + sovTypes(uint64(m.Port))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VendorName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProductName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ISerial)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.IdVendor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.IdProduct)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.IManufacturer)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.Speed)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.BcdUsb)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.BcdDevice)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.BDeviceClass)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.BDeviceSubClass)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.BDeviceProtocol)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.BMaxPacketSize != 0 {
		n += 2 + sovTypes(uint64(m.BMaxPacketSize))
	}
	l = len(m.IProduct)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.UsbType != 0 {
		n += 2 + sovTypes(uint64(m.UsbType))
	}
	return n
}

func (m *GPU) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DriverVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CudaVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.GpuDevice) > 0 {
		for _, e := range m.GpuDevice {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GPUDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProductName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Processes)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SiteStatusMetricsFieldData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Key) > 0 {
		for k, v := range m.Key {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Value) > 0 {
		for _, e := range m.Value {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *SiteStatusMetricsData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Field != 0 {
		n += 1 + sovTypes(uint64(m.Field))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CreateKubeConfigReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ListKubeConfigReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ListKubeConfigRspItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreateTimestamp != nil {
		l = m.CreateTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ExpiryTimestamp != nil {
		l = m.ExpiryTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.UserEmail)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ListKubeConfigRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *GlobalAccessCheckRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *GlobalAccessCheckResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	return n
}

func (m *CreateGlobalKubeConfigReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Site)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ExpirationTimestamp != nil {
		l = m.ExpirationTimestamp.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ListGlobalKubeConfigReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Site)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RevokeKubeConfigReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *KubeConfigStatusRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *BondMembersType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BondMembersType{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`LinkState:` + fmt.Sprintf("%v", this.LinkState) + `,`,
		`LinkSpeed:` + fmt.Sprintf("%v", this.LinkSpeed) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Coordinates) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Coordinates{`,
		`Latitude:` + fmt.Sprintf("%v", this.Latitude) + `,`,
		`Longitude:` + fmt.Sprintf("%v", this.Longitude) + `,`,
		`}`,
	}, "")
	return s
}
func (this *K8SApiServerParameters) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&K8SApiServerParameters{`,
		`}`,
	}, "")
	return s
}
func (this *DefaultUnderlayNetworkType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DefaultUnderlayNetworkType{`,
		`PrivateAccessChoice:` + fmt.Sprintf("%v", this.PrivateAccessChoice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DefaultUnderlayNetworkType_SiteLocalOutside) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DefaultUnderlayNetworkType_SiteLocalOutside{`,
		`SiteLocalOutside:` + strings.Replace(fmt.Sprintf("%v", this.SiteLocalOutside), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DefaultUnderlayNetworkType_SiteLocalInside) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DefaultUnderlayNetworkType_SiteLocalInside{`,
		`SiteLocalInside:` + strings.Replace(fmt.Sprintf("%v", this.SiteLocalInside), "Empty", "schema.Empty", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PublishVIPParamsPerAz) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PublishVIPParamsPerAz{`,
		`InsideVip:` + fmt.Sprintf("%v", this.InsideVip) + `,`,
		`OutsideVip:` + fmt.Sprintf("%v", this.OutsideVip) + `,`,
		`OutsideVipCname:` + fmt.Sprintf("%v", this.OutsideVipCname) + `,`,
		`InsideVipCname:` + fmt.Sprintf("%v", this.InsideVipCname) + `,`,
		`AzName:` + fmt.Sprintf("%v", this.AzName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConnectedRe := "[]*ObjectRefType{"
	for _, f := range this.ConnectedRe {
		repeatedStringForConnectedRe += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForConnectedRe += "}"
	repeatedStringForConnectedReForConfig := "[]*ObjectRefType{"
	for _, f := range this.ConnectedReForConfig {
		repeatedStringForConnectedReForConfig += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForConnectedReForConfig += "}"
	repeatedStringForAresList := "[]*ServiceParameters{"
	for _, f := range this.AresList {
		repeatedStringForAresList += strings.Replace(fmt.Sprintf("%v", f), "ServiceParameters", "schema.ServiceParameters", 1) + ","
	}
	repeatedStringForAresList += "}"
	repeatedStringForAresVtrpList := "[]*ServiceParameters{"
	for _, f := range this.AresVtrpList {
		repeatedStringForAresVtrpList += strings.Replace(fmt.Sprintf("%v", f), "ServiceParameters", "schema.ServiceParameters", 1) + ","
	}
	repeatedStringForAresVtrpList += "}"
	repeatedStringForMarsList := "[]*ServiceParameters{"
	for _, f := range this.MarsList {
		repeatedStringForMarsList += strings.Replace(fmt.Sprintf("%v", f), "ServiceParameters", "schema.ServiceParameters", 1) + ","
	}
	repeatedStringForMarsList += "}"
	repeatedStringForMarsVtrpList := "[]*ServiceParameters{"
	for _, f := range this.MarsVtrpList {
		repeatedStringForMarsVtrpList += strings.Replace(fmt.Sprintf("%v", f), "ServiceParameters", "schema.ServiceParameters", 1) + ","
	}
	repeatedStringForMarsVtrpList += "}"
	repeatedStringForK8SClusterApiGw := "[]*ObjectRefType{"
	for _, f := range this.K8SClusterApiGw {
		repeatedStringForK8SClusterApiGw += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForK8SClusterApiGw += "}"
	repeatedStringForVipParamsPerAz := "[]*PublishVIPParamsPerAz{"
	for _, f := range this.VipParamsPerAz {
		repeatedStringForVipParamsPerAz += strings.Replace(f.String(), "PublishVIPParamsPerAz", "PublishVIPParamsPerAz", 1) + ","
	}
	repeatedStringForVipParamsPerAz += "}"
	keysForK8SApiServers := make([]string, 0, len(this.K8SApiServers))
	for k, _ := range this.K8SApiServers {
		keysForK8SApiServers = append(keysForK8SApiServers, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForK8SApiServers)
	mapStringForK8SApiServers := "map[string]*K8SApiServerParameters{"
	for _, k := range keysForK8SApiServers {
		mapStringForK8SApiServers += fmt.Sprintf("%v: %v,", k, this.K8SApiServers[k])
	}
	mapStringForK8SApiServers += "}"
	keysForTemplateParameters := make([]string, 0, len(this.TemplateParameters))
	for k, _ := range this.TemplateParameters {
		keysForTemplateParameters = append(keysForTemplateParameters, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTemplateParameters)
	mapStringForTemplateParameters := "map[string]string{"
	for _, k := range keysForTemplateParameters {
		mapStringForTemplateParameters += fmt.Sprintf("%v: %v,", k, this.TemplateParameters[k])
	}
	mapStringForTemplateParameters += "}"
	s := strings.Join([]string{`&GlobalSpecType{`,
		`SiteType:` + fmt.Sprintf("%v", this.SiteType) + `,`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Coordinates:` + strings.Replace(this.Coordinates.String(), "Coordinates", "Coordinates", 1) + `,`,
		`SiteSubtype:` + fmt.Sprintf("%v", this.SiteSubtype) + `,`,
		`ConnectedRe:` + repeatedStringForConnectedRe + `,`,
		`ConnectedReForConfig:` + repeatedStringForConnectedReForConfig + `,`,
		`Vega:` + strings.Replace(fmt.Sprintf("%v", this.Vega), "ServiceParameters", "schema.ServiceParameters", 1) + `,`,
		`AresList:` + repeatedStringForAresList + `,`,
		`Rakar:` + strings.Replace(fmt.Sprintf("%v", this.Rakar), "ServiceParameters", "schema.ServiceParameters", 1) + `,`,
		`StaticRoutes:` + fmt.Sprintf("%v", this.StaticRoutes) + `,`,
		`K8SApiServers:` + mapStringForK8SApiServers + `,`,
		`PublicIp:` + fmt.Sprintf("%v", this.PublicIp) + `,`,
		`ClusterIp:` + fmt.Sprintf("%v", this.ClusterIp) + `,`,
		`AresVtrpList:` + repeatedStringForAresVtrpList + `,`,
		`VolterraSoftwareVersion:` + fmt.Sprintf("%v", this.VolterraSoftwareVersion) + `,`,
		`InsideVip:` + fmt.Sprintf("%v", this.InsideVip) + `,`,
		`SiteToSiteTunnelIp:` + fmt.Sprintf("%v", this.SiteToSiteTunnelIp) + `,`,
		`VolterraSoftwareOveride:` + fmt.Sprintf("%v", this.VolterraSoftwareOveride) + `,`,
		`BgpRouterId:` + fmt.Sprintf("%v", this.BgpRouterId) + `,`,
		`BgpPeerAddress:` + fmt.Sprintf("%v", this.BgpPeerAddress) + `,`,
		`TemplateParameters:` + mapStringForTemplateParameters + `,`,
		`OutsideVip:` + fmt.Sprintf("%v", this.OutsideVip) + `,`,
		`VipVrrpMode:` + fmt.Sprintf("%v", this.VipVrrpMode) + `,`,
		`SiteToSiteNetworkType:` + fmt.Sprintf("%v", this.SiteToSiteNetworkType) + `,`,
		`InsideNameserver:` + fmt.Sprintf("%v", this.InsideNameserver) + `,`,
		`OutsideNameserver:` + fmt.Sprintf("%v", this.OutsideNameserver) + `,`,
		`DesiredPoolCount:` + fmt.Sprintf("%v", this.DesiredPoolCount) + `,`,
		`TunnelType:` + fmt.Sprintf("%v", this.TunnelType) + `,`,
		`SiteState:` + fmt.Sprintf("%v", this.SiteState) + `,`,
		`OperatingSystemVersion:` + fmt.Sprintf("%v", this.OperatingSystemVersion) + `,`,
		`MarsList:` + repeatedStringForMarsList + `,`,
		`MarsVtrpList:` + repeatedStringForMarsVtrpList + `,`,
		`TunnelDeadTimeout:` + fmt.Sprintf("%v", this.TunnelDeadTimeout) + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`Opera:` + strings.Replace(fmt.Sprintf("%v", this.Opera), "ServiceParameters", "schema.ServiceParameters", 1) + `,`,
		`CeSiteMode:` + fmt.Sprintf("%v", this.CeSiteMode) + `,`,
		`NoTenantInVk8SNs:` + fmt.Sprintf("%v", this.NoTenantInVk8SNs) + `,`,
		`LocalK8SAccessEnabled:` + fmt.Sprintf("%v", this.LocalK8SAccessEnabled) + `,`,
		`K8SClusterApiGw:` + repeatedStringForK8SClusterApiGw + `,`,
		`PrivateIp:` + fmt.Sprintf("%v", this.PrivateIp) + `,`,
		`IpsecSslVipFqdn:` + fmt.Sprintf("%v", this.IpsecSslVipFqdn) + `,`,
		`UsePrivateIp:` + fmt.Sprintf("%v", this.UsePrivateIp) + `,`,
		`DefaultUnderlayNetwork:` + strings.Replace(this.DefaultUnderlayNetwork.String(), "DefaultUnderlayNetworkType", "DefaultUnderlayNetworkType", 1) + `,`,
		`TenantIndex:` + fmt.Sprintf("%v", this.TenantIndex) + `,`,
		`VipParamsPerAz:` + repeatedStringForVipParamsPerAz + `,`,
		`PikuEnabled:` + fmt.Sprintf("%v", this.PikuEnabled) + `,`,
		`PhobosEnabled:` + fmt.Sprintf("%v", this.PhobosEnabled) + `,`,
		`Srv6Enabled:` + fmt.Sprintf("%v", this.Srv6Enabled) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSpecType{`,
		`SiteType:` + fmt.Sprintf("%v", this.SiteType) + `,`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Coordinates:` + strings.Replace(this.Coordinates.String(), "Coordinates", "Coordinates", 1) + `,`,
		`InsideVip:` + fmt.Sprintf("%v", this.InsideVip) + `,`,
		`SiteToSiteTunnelIp:` + fmt.Sprintf("%v", this.SiteToSiteTunnelIp) + `,`,
		`VolterraSoftwareOveride:` + fmt.Sprintf("%v", this.VolterraSoftwareOveride) + `,`,
		`BgpRouterId:` + fmt.Sprintf("%v", this.BgpRouterId) + `,`,
		`BgpPeerAddress:` + fmt.Sprintf("%v", this.BgpPeerAddress) + `,`,
		`OutsideVip:` + fmt.Sprintf("%v", this.OutsideVip) + `,`,
		`VipVrrpMode:` + fmt.Sprintf("%v", this.VipVrrpMode) + `,`,
		`SiteToSiteNetworkType:` + fmt.Sprintf("%v", this.SiteToSiteNetworkType) + `,`,
		`InsideNameserver:` + fmt.Sprintf("%v", this.InsideNameserver) + `,`,
		`OutsideNameserver:` + fmt.Sprintf("%v", this.OutsideNameserver) + `,`,
		`DesiredPoolCount:` + fmt.Sprintf("%v", this.DesiredPoolCount) + `,`,
		`TunnelType:` + fmt.Sprintf("%v", this.TunnelType) + `,`,
		`OperatingSystemVersion:` + fmt.Sprintf("%v", this.OperatingSystemVersion) + `,`,
		`TunnelDeadTimeout:` + fmt.Sprintf("%v", this.TunnelDeadTimeout) + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`CeSiteMode:` + fmt.Sprintf("%v", this.CeSiteMode) + `,`,
		`DefaultUnderlayNetwork:` + strings.Replace(this.DefaultUnderlayNetwork.String(), "DefaultUnderlayNetworkType", "DefaultUnderlayNetworkType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceSpecType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceSpecType{`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Coordinates:` + strings.Replace(this.Coordinates.String(), "Coordinates", "Coordinates", 1) + `,`,
		`VolterraSoftwareVersion:` + fmt.Sprintf("%v", this.VolterraSoftwareVersion) + `,`,
		`InsideVip:` + fmt.Sprintf("%v", this.InsideVip) + `,`,
		`SiteToSiteTunnelIp:` + fmt.Sprintf("%v", this.SiteToSiteTunnelIp) + `,`,
		`VolterraSoftwareOveride:` + fmt.Sprintf("%v", this.VolterraSoftwareOveride) + `,`,
		`BgpRouterId:` + fmt.Sprintf("%v", this.BgpRouterId) + `,`,
		`BgpPeerAddress:` + fmt.Sprintf("%v", this.BgpPeerAddress) + `,`,
		`OutsideVip:` + fmt.Sprintf("%v", this.OutsideVip) + `,`,
		`VipVrrpMode:` + fmt.Sprintf("%v", this.VipVrrpMode) + `,`,
		`SiteToSiteNetworkType:` + fmt.Sprintf("%v", this.SiteToSiteNetworkType) + `,`,
		`InsideNameserver:` + fmt.Sprintf("%v", this.InsideNameserver) + `,`,
		`OutsideNameserver:` + fmt.Sprintf("%v", this.OutsideNameserver) + `,`,
		`DesiredPoolCount:` + fmt.Sprintf("%v", this.DesiredPoolCount) + `,`,
		`TunnelType:` + fmt.Sprintf("%v", this.TunnelType) + `,`,
		`OperatingSystemVersion:` + fmt.Sprintf("%v", this.OperatingSystemVersion) + `,`,
		`TunnelDeadTimeout:` + fmt.Sprintf("%v", this.TunnelDeadTimeout) + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`DefaultUnderlayNetwork:` + strings.Replace(this.DefaultUnderlayNetwork.String(), "DefaultUnderlayNetworkType", "DefaultUnderlayNetworkType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetSpecType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForConnectedRe := "[]*ObjectRefType{"
	for _, f := range this.ConnectedRe {
		repeatedStringForConnectedRe += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForConnectedRe += "}"
	repeatedStringForConnectedReForConfig := "[]*ObjectRefType{"
	for _, f := range this.ConnectedReForConfig {
		repeatedStringForConnectedReForConfig += strings.Replace(fmt.Sprintf("%v", f), "ObjectRefType", "schema.ObjectRefType", 1) + ","
	}
	repeatedStringForConnectedReForConfig += "}"
	repeatedStringForVipParamsPerAz := "[]*PublishVIPParamsPerAz{"
	for _, f := range this.VipParamsPerAz {
		repeatedStringForVipParamsPerAz += strings.Replace(f.String(), "PublishVIPParamsPerAz", "PublishVIPParamsPerAz", 1) + ","
	}
	repeatedStringForVipParamsPerAz += "}"
	s := strings.Join([]string{`&GetSpecType{`,
		`SiteType:` + fmt.Sprintf("%v", this.SiteType) + `,`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Coordinates:` + strings.Replace(this.Coordinates.String(), "Coordinates", "Coordinates", 1) + `,`,
		`VolterraSoftwareVersion:` + fmt.Sprintf("%v", this.VolterraSoftwareVersion) + `,`,
		`ConnectedRe:` + repeatedStringForConnectedRe + `,`,
		`ConnectedReForConfig:` + repeatedStringForConnectedReForConfig + `,`,
		`InsideVip:` + fmt.Sprintf("%v", this.InsideVip) + `,`,
		`SiteToSiteTunnelIp:` + fmt.Sprintf("%v", this.SiteToSiteTunnelIp) + `,`,
		`VolterraSoftwareOveride:` + fmt.Sprintf("%v", this.VolterraSoftwareOveride) + `,`,
		`BgpRouterId:` + fmt.Sprintf("%v", this.BgpRouterId) + `,`,
		`BgpPeerAddress:` + fmt.Sprintf("%v", this.BgpPeerAddress) + `,`,
		`OutsideVip:` + fmt.Sprintf("%v", this.OutsideVip) + `,`,
		`VipVrrpMode:` + fmt.Sprintf("%v", this.VipVrrpMode) + `,`,
		`SiteToSiteNetworkType:` + fmt.Sprintf("%v", this.SiteToSiteNetworkType) + `,`,
		`InsideNameserver:` + fmt.Sprintf("%v", this.InsideNameserver) + `,`,
		`OutsideNameserver:` + fmt.Sprintf("%v", this.OutsideNameserver) + `,`,
		`DesiredPoolCount:` + fmt.Sprintf("%v", this.DesiredPoolCount) + `,`,
		`TunnelType:` + fmt.Sprintf("%v", this.TunnelType) + `,`,
		`OperatingSystemVersion:` + fmt.Sprintf("%v", this.OperatingSystemVersion) + `,`,
		`SiteState:` + fmt.Sprintf("%v", this.SiteState) + `,`,
		`TunnelDeadTimeout:` + fmt.Sprintf("%v", this.TunnelDeadTimeout) + `,`,
		`Region:` + fmt.Sprintf("%v", this.Region) + `,`,
		`CeSiteMode:` + fmt.Sprintf("%v", this.CeSiteMode) + `,`,
		`LocalK8SAccessEnabled:` + fmt.Sprintf("%v", this.LocalK8SAccessEnabled) + `,`,
		`DefaultUnderlayNetwork:` + strings.Replace(this.DefaultUnderlayNetwork.String(), "DefaultUnderlayNetworkType", "DefaultUnderlayNetworkType", 1) + `,`,
		`LocalAccessK8SEnabled:` + fmt.Sprintf("%v", this.LocalAccessK8SEnabled) + `,`,
		`GlobalAccessK8SEnabled:` + fmt.Sprintf("%v", this.GlobalAccessK8SEnabled) + `,`,
		`VipParamsPerAz:` + repeatedStringForVipParamsPerAz + `,`,
		`}`,
	}, "")
	return s
}
func (this *VerStatusType) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForIpsecStatus := "[]*IpsecConnectionStatus{"
	for _, f := range this.IpsecStatus {
		repeatedStringForIpsecStatus += strings.Replace(f.String(), "IpsecConnectionStatus", "IpsecConnectionStatus", 1) + ","
	}
	repeatedStringForIpsecStatus += "}"
	repeatedStringForAresStatus := "[]*AresConnectionStatus{"
	for _, f := range this.AresStatus {
		repeatedStringForAresStatus += strings.Replace(f.String(), "AresConnectionStatus", "AresConnectionStatus", 1) + ","
	}
	repeatedStringForAresStatus += "}"
	repeatedStringForIntfStatus := "[]*InterfaceStatus{"
	for _, f := range this.IntfStatus {
		repeatedStringForIntfStatus += strings.Replace(f.String(), "InterfaceStatus", "InterfaceStatus", 1) + ","
	}
	repeatedStringForIntfStatus += "}"
	repeatedStringForConfiguredTunnelStatus := "[]*TunnelConnectionStatus{"
	for _, f := range this.ConfiguredTunnelStatus {
		repeatedStringForConfiguredTunnelStatus += strings.Replace(f.String(), "TunnelConnectionStatus", "TunnelConnectionStatus", 1) + ","
	}
	repeatedStringForConfiguredTunnelStatus += "}"
	repeatedStringForSiteTunnelStatus := "[]*TunnelConnectionStatus{"
	for _, f := range this.SiteTunnelStatus {
		repeatedStringForSiteTunnelStatus += strings.Replace(f.String(), "TunnelConnectionStatus", "TunnelConnectionStatus", 1) + ","
	}
	repeatedStringForSiteTunnelStatus += "}"
	s := strings.Join([]string{`&VerStatusType{`,
		`VerInstanceName:` + fmt.Sprintf("%v", this.VerInstanceName) + `,`,
		`IpsecStatus:` + repeatedStringForIpsecStatus + `,`,
		`AresStatus:` + repeatedStringForAresStatus + `,`,
		`IntfStatus:` + repeatedStringForIntfStatus + `,`,
		`ConfiguredTunnelStatus:` + repeatedStringForConfiguredTunnelStatus + `,`,
		`SiteTunnelStatus:` + repeatedStringForSiteTunnelStatus + `,`,
		`}`,
	}, "")
	return s
}
func (this *VerMasterStatusType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VerMasterStatusType{`,
		`VerName:` + fmt.Sprintf("%v", this.VerName) + `,`,
		`Ver_UID:` + fmt.Sprintf("%v", this.Ver_UID) + `,`,
		`TransitionTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.TransitionTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IpsecConnectionStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IpsecConnectionStatus{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Role:` + fmt.Sprintf("%v", this.Role) + `,`,
		`RemoteAddress:` + fmt.Sprintf("%v", this.RemoteAddress) + `,`,
		`IsLocal:` + fmt.Sprintf("%v", this.IsLocal) + `,`,
		`VerNodeName:` + fmt.Sprintf("%v", this.VerNodeName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AresConnectionStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AresConnectionStatus{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InterfaceStatus) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForBondMembers := "[]*BondMembersType{"
	for _, f := range this.BondMembers {
		repeatedStringForBondMembers += strings.Replace(f.String(), "BondMembersType", "BondMembersType", 1) + ","
	}
	repeatedStringForBondMembers += "}"
	s := strings.Join([]string{`&InterfaceStatus{`,
		`Ip:` + strings.Replace(fmt.Sprintf("%v", this.Ip), "IpSubnetType", "schema.IpSubnetType", 1) + `,`,
		`Mac:` + fmt.Sprintf("%v", this.Mac) + `,`,
		`NetworkType:` + fmt.Sprintf("%v", this.NetworkType) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`IpMode:` + fmt.Sprintf("%v", this.IpMode) + `,`,
		`DhcpServer:` + fmt.Sprintf("%v", this.DhcpServer) + `,`,
		`NetworkName:` + fmt.Sprintf("%v", this.NetworkName) + `,`,
		`LinkState:` + fmt.Sprintf("%v", this.LinkState) + `,`,
		`ActiveState:` + fmt.Sprintf("%v", this.ActiveState) + `,`,
		`LinkQuality:` + fmt.Sprintf("%v", this.LinkQuality) + `,`,
		`LinkType:` + fmt.Sprintf("%v", this.LinkType) + `,`,
		`BondMembers:` + repeatedStringForBondMembers + `,`,
		`Ipv6:` + strings.Replace(fmt.Sprintf("%v", this.Ipv6), "IpSubnetType", "schema.IpSubnetType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TunnelConnectionStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TunnelConnectionStatus{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Role:` + fmt.Sprintf("%v", this.Role) + `,`,
		`RemoteAddress:` + fmt.Sprintf("%v", this.RemoteAddress) + `,`,
		`Encap:` + fmt.Sprintf("%v", this.Encap) + `,`,
		`IsLocal:` + fmt.Sprintf("%v", this.IsLocal) + `,`,
		`VerNodeName:` + fmt.Sprintf("%v", this.VerNodeName) + `,`,
		`TunnelName:` + fmt.Sprintf("%v", this.TunnelName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VolterraSoftwareStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VolterraSoftwareStatus{`,
		`AvailableVersion:` + fmt.Sprintf("%v", this.AvailableVersion) + `,`,
		`DeploymentState:` + strings.Replace(this.DeploymentState.String(), "DeploymentState", "DeploymentState", 1) + `,`,
		`NonconformingState:` + fmt.Sprintf("%v", this.NonconformingState) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OperatingSystemStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OperatingSystemStatus{`,
		`AvailableVersion:` + fmt.Sprintf("%v", this.AvailableVersion) + `,`,
		`DeploymentState:` + strings.Replace(this.DeploymentState.String(), "DeploymentState", "DeploymentState", 1) + `,`,
		`NonconformingState:` + fmt.Sprintf("%v", this.NonconformingState) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeploymentState) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeploymentState{`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`ModificationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ModificationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`Result:` + fmt.Sprintf("%v", this.Result) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetDeploymentState) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForCondition := "[]*FleetCondition{"
	for _, f := range this.Condition {
		repeatedStringForCondition += strings.Replace(f.String(), "FleetCondition", "FleetCondition", 1) + ","
	}
	repeatedStringForCondition += "}"
	s := strings.Join([]string{`&FleetDeploymentState{`,
		`Hash:` + fmt.Sprintf("%v", this.Hash) + `,`,
		`ModificationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ModificationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`Result:` + fmt.Sprintf("%v", this.Result) + `,`,
		`Condition:` + repeatedStringForCondition + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetCondition) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetCondition{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`ModuleName:` + fmt.Sprintf("%v", this.ModuleName) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`Result:` + fmt.Sprintf("%v", this.Result) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FleetStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FleetStatus{`,
		`DeploymentState:` + strings.Replace(this.DeploymentState.String(), "FleetDeploymentState", "FleetDeploymentState", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ScalingStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ScalingStatus{`,
		`Phase:` + fmt.Sprintf("%v", this.Phase) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`PoolNodeCountCurrent:` + fmt.Sprintf("%v", this.PoolNodeCountCurrent) + `,`,
		`PoolNodeCountTarget:` + fmt.Sprintf("%v", this.PoolNodeCountTarget) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NodeInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeInfo{`,
		`Hostname:` + fmt.Sprintf("%v", this.Hostname) + `,`,
		`Role:` + fmt.Sprintf("%v", this.Role) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OsInfo) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForStorage := "[]*StorageDevice{"
	for _, f := range this.Storage {
		repeatedStringForStorage += strings.Replace(f.String(), "StorageDevice", "StorageDevice", 1) + ","
	}
	repeatedStringForStorage += "}"
	repeatedStringForNetwork := "[]*NetworkDevice{"
	for _, f := range this.Network {
		repeatedStringForNetwork += strings.Replace(f.String(), "NetworkDevice", "NetworkDevice", 1) + ","
	}
	repeatedStringForNetwork += "}"
	repeatedStringForUsb := "[]*USBDevice{"
	for _, f := range this.Usb {
		repeatedStringForUsb += strings.Replace(f.String(), "USBDevice", "USBDevice", 1) + ","
	}
	repeatedStringForUsb += "}"
	s := strings.Join([]string{`&OsInfo{`,
		`Os:` + strings.Replace(this.Os.String(), "OS", "OS", 1) + `,`,
		`Product:` + strings.Replace(this.Product.String(), "Product", "Product", 1) + `,`,
		`Board:` + strings.Replace(this.Board.String(), "Board", "Board", 1) + `,`,
		`Chassis:` + strings.Replace(this.Chassis.String(), "Chassis", "Chassis", 1) + `,`,
		`Bios:` + strings.Replace(this.Bios.String(), "Bios", "Bios", 1) + `,`,
		`Cpu:` + strings.Replace(this.Cpu.String(), "Cpu", "Cpu", 1) + `,`,
		`Memory:` + strings.Replace(this.Memory.String(), "Memory", "Memory", 1) + `,`,
		`Storage:` + repeatedStringForStorage + `,`,
		`Network:` + repeatedStringForNetwork + `,`,
		`Kernel:` + strings.Replace(this.Kernel.String(), "Kernel", "Kernel", 1) + `,`,
		`Usb:` + repeatedStringForUsb + `,`,
		`Gpu:` + strings.Replace(this.Gpu.String(), "GPU", "GPU", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OS) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OS{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Vendor:` + fmt.Sprintf("%v", this.Vendor) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Release:` + fmt.Sprintf("%v", this.Release) + `,`,
		`Architecture:` + fmt.Sprintf("%v", this.Architecture) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Kernel) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Kernel{`,
		`Release:` + fmt.Sprintf("%v", this.Release) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Architecture:` + fmt.Sprintf("%v", this.Architecture) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Product) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Product{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Vendor:` + fmt.Sprintf("%v", this.Vendor) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Serial:` + fmt.Sprintf("%v", this.Serial) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Board) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Board{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Vendor:` + fmt.Sprintf("%v", this.Vendor) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Serial:` + fmt.Sprintf("%v", this.Serial) + `,`,
		`AssetTag:` + fmt.Sprintf("%v", this.AssetTag) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Chassis) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Chassis{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Vendor:` + fmt.Sprintf("%v", this.Vendor) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Serial:` + fmt.Sprintf("%v", this.Serial) + `,`,
		`AssetTag:` + fmt.Sprintf("%v", this.AssetTag) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Bios) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Bios{`,
		`Vendor:` + fmt.Sprintf("%v", this.Vendor) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Date:` + fmt.Sprintf("%v", this.Date) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Cpu) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Cpu{`,
		`Vendor:` + fmt.Sprintf("%v", this.Vendor) + `,`,
		`Model:` + fmt.Sprintf("%v", this.Model) + `,`,
		`Speed:` + fmt.Sprintf("%v", this.Speed) + `,`,
		`Cache:` + fmt.Sprintf("%v", this.Cache) + `,`,
		`Cpus:` + fmt.Sprintf("%v", this.Cpus) + `,`,
		`Cores:` + fmt.Sprintf("%v", this.Cores) + `,`,
		`Threads:` + fmt.Sprintf("%v", this.Threads) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Memory) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Memory{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Speed:` + fmt.Sprintf("%v", this.Speed) + `,`,
		`SizeMb:` + fmt.Sprintf("%v", this.SizeMb) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StorageDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StorageDevice{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Driver:` + fmt.Sprintf("%v", this.Driver) + `,`,
		`Vendor:` + fmt.Sprintf("%v", this.Vendor) + `,`,
		`Model:` + fmt.Sprintf("%v", this.Model) + `,`,
		`Serial:` + fmt.Sprintf("%v", this.Serial) + `,`,
		`SizeGb:` + fmt.Sprintf("%v", this.SizeGb) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NetworkDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NetworkDevice{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Driver:` + fmt.Sprintf("%v", this.Driver) + `,`,
		`IpAddress:` + fmt.Sprintf("%v", this.IpAddress) + `,`,
		`MacAddress:` + fmt.Sprintf("%v", this.MacAddress) + `,`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`Speed:` + fmt.Sprintf("%v", this.Speed) + `,`,
		`LinkQuality:` + fmt.Sprintf("%v", this.LinkQuality) + `,`,
		`LinkType:` + fmt.Sprintf("%v", this.LinkType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *USBDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&USBDevice{`,
		`Bus:` + fmt.Sprintf("%v", this.Bus) + `,`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`VendorName:` + fmt.Sprintf("%v", this.VendorName) + `,`,
		`ProductName:` + fmt.Sprintf("%v", this.ProductName) + `,`,
		`ISerial:` + fmt.Sprintf("%v", this.ISerial) + `,`,
		`IdVendor:` + fmt.Sprintf("%v", this.IdVendor) + `,`,
		`IdProduct:` + fmt.Sprintf("%v", this.IdProduct) + `,`,
		`IManufacturer:` + fmt.Sprintf("%v", this.IManufacturer) + `,`,
		`Speed:` + fmt.Sprintf("%v", this.Speed) + `,`,
		`BcdUsb:` + fmt.Sprintf("%v", this.BcdUsb) + `,`,
		`BcdDevice:` + fmt.Sprintf("%v", this.BcdDevice) + `,`,
		`BDeviceClass:` + fmt.Sprintf("%v", this.BDeviceClass) + `,`,
		`BDeviceSubClass:` + fmt.Sprintf("%v", this.BDeviceSubClass) + `,`,
		`BDeviceProtocol:` + fmt.Sprintf("%v", this.BDeviceProtocol) + `,`,
		`BMaxPacketSize:` + fmt.Sprintf("%v", this.BMaxPacketSize) + `,`,
		`IProduct:` + fmt.Sprintf("%v", this.IProduct) + `,`,
		`UsbType:` + fmt.Sprintf("%v", this.UsbType) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GPU) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForGpuDevice := "[]*GPUDevice{"
	for _, f := range this.GpuDevice {
		repeatedStringForGpuDevice += strings.Replace(f.String(), "GPUDevice", "GPUDevice", 1) + ","
	}
	repeatedStringForGpuDevice += "}"
	s := strings.Join([]string{`&GPU{`,
		`DriverVersion:` + fmt.Sprintf("%v", this.DriverVersion) + `,`,
		`CudaVersion:` + fmt.Sprintf("%v", this.CudaVersion) + `,`,
		`GpuDevice:` + repeatedStringForGpuDevice + `,`,
		`}`,
	}, "")
	return s
}
func (this *GPUDevice) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GPUDevice{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`ProductName:` + fmt.Sprintf("%v", this.ProductName) + `,`,
		`Processes:` + fmt.Sprintf("%v", this.Processes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteStatusMetricsFieldData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForValue := "[]*MetricValue{"
	for _, f := range this.Value {
		repeatedStringForValue += strings.Replace(fmt.Sprintf("%v", f), "MetricValue", "schema.MetricValue", 1) + ","
	}
	repeatedStringForValue += "}"
	keysForKey := make([]string, 0, len(this.Key))
	for k, _ := range this.Key {
		keysForKey = append(keysForKey, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForKey)
	mapStringForKey := "map[string]string{"
	for _, k := range keysForKey {
		mapStringForKey += fmt.Sprintf("%v: %v,", k, this.Key[k])
	}
	mapStringForKey += "}"
	s := strings.Join([]string{`&SiteStatusMetricsFieldData{`,
		`Key:` + mapStringForKey + `,`,
		`Value:` + repeatedStringForValue + `,`,
		`}`,
	}, "")
	return s
}
func (this *SiteStatusMetricsData) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForData := "[]*SiteStatusMetricsFieldData{"
	for _, f := range this.Data {
		repeatedStringForData += strings.Replace(f.String(), "SiteStatusMetricsFieldData", "SiteStatusMetricsFieldData", 1) + ","
	}
	repeatedStringForData += "}"
	s := strings.Join([]string{`&SiteStatusMetricsData{`,
		`Field:` + fmt.Sprintf("%v", this.Field) + `,`,
		`Data:` + repeatedStringForData + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateKubeConfigReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateKubeConfigReq{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListKubeConfigReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListKubeConfigReq{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListKubeConfigRspItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListKubeConfigRspItem{`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`CreateTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.CreateTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`ExpiryTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ExpiryTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`UserEmail:` + fmt.Sprintf("%v", this.UserEmail) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListKubeConfigRsp) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForItems := "[]*ListKubeConfigRspItem{"
	for _, f := range this.Items {
		repeatedStringForItems += strings.Replace(f.String(), "ListKubeConfigRspItem", "ListKubeConfigRspItem", 1) + ","
	}
	repeatedStringForItems += "}"
	s := strings.Join([]string{`&ListKubeConfigRsp{`,
		`Items:` + repeatedStringForItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalAccessCheckRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalAccessCheckRequest{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GlobalAccessCheckResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GlobalAccessCheckResponse{`,
		`Enabled:` + fmt.Sprintf("%v", this.Enabled) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateGlobalKubeConfigReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateGlobalKubeConfigReq{`,
		`Site:` + fmt.Sprintf("%v", this.Site) + `,`,
		`ExpirationTimestamp:` + strings.Replace(fmt.Sprintf("%v", this.ExpirationTimestamp), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListGlobalKubeConfigReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListGlobalKubeConfigReq{`,
		`Site:` + fmt.Sprintf("%v", this.Site) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RevokeKubeConfigReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RevokeKubeConfigReq{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func (this *KubeConfigStatusRsp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&KubeConfigStatusRsp{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTypes(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *BondMembersType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BondMembersType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BondMembersType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LinkState = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkSpeed", wireType)
			}
			m.LinkSpeed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkSpeed |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Coordinates) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Coordinates: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Coordinates: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Latitude = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Longitude = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SApiServerParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8SApiServerParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8SApiServerParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefaultUnderlayNetworkType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefaultUnderlayNetworkType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefaultUnderlayNetworkType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteLocalOutside", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PrivateAccessChoice = &DefaultUnderlayNetworkType_SiteLocalOutside{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteLocalInside", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &schema.Empty{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PrivateAccessChoice = &DefaultUnderlayNetworkType_SiteLocalInside{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishVIPParamsPerAz) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishVIPParamsPerAz: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishVIPParamsPerAz: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideVip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideVip = append(m.InsideVip, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideVip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideVip = append(m.OutsideVip, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideVipCname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideVipCname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideVipCname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideVipCname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AzName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteType", wireType)
			}
			m.SiteType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteType |= SiteType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coordinates == nil {
				m.Coordinates = &Coordinates{}
			}
			if err := m.Coordinates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteSubtype", wireType)
			}
			m.SiteSubtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteSubtype |= SiteSubtype(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectedRe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectedRe = append(m.ConnectedRe, &schema.ObjectRefType{})
			if err := m.ConnectedRe[len(m.ConnectedRe)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 104:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectedReForConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectedReForConfig = append(m.ConnectedReForConfig, &schema.ObjectRefType{})
			if err := m.ConnectedReForConfig[len(m.ConnectedReForConfig)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 105:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vega", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vega == nil {
				m.Vega = &schema.ServiceParameters{}
			}
			if err := m.Vega.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 106:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AresList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AresList = append(m.AresList, &schema.ServiceParameters{})
			if err := m.AresList[len(m.AresList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 107:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rakar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rakar == nil {
				m.Rakar = &schema.ServiceParameters{}
			}
			if err := m.Rakar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 108:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaticRoutes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaticRoutes = append(m.StaticRoutes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 109:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SApiServers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.K8SApiServers == nil {
				m.K8SApiServers = make(map[string]*K8SApiServerParameters)
			}
			var mapkey string
			var mapvalue *K8SApiServerParameters
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &K8SApiServerParameters{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.K8SApiServers[mapkey] = mapvalue
			iNdEx = postIndex
		case 110:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 111:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 112:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AresVtrpList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AresVtrpList = append(m.AresVtrpList, &schema.ServiceParameters{})
			if err := m.AresVtrpList[len(m.AresVtrpList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 113:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolterraSoftwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 114:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideVip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideVip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 115:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteToSiteTunnelIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteToSiteTunnelIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 116:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareOveride", wireType)
			}
			m.VolterraSoftwareOveride = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolterraSoftwareOveride |= SiteSoftwareOverrideType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 117:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpRouterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpRouterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 118:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpPeerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpPeerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 119:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemplateParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TemplateParameters == nil {
				m.TemplateParameters = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TemplateParameters[mapkey] = mapvalue
			iNdEx = postIndex
		case 120:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideVip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideVip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 121:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipVrrpMode", wireType)
			}
			m.VipVrrpMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VipVrrpMode |= schema.VipVrrpType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 122:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteToSiteNetworkType", wireType)
			}
			m.SiteToSiteNetworkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteToSiteNetworkType |= schema.VirtualNetworkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 123:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideNameserver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideNameserver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 124:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideNameserver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideNameserver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 125:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredPoolCount", wireType)
			}
			m.DesiredPoolCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DesiredPoolCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 126:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelType", wireType)
			}
			m.TunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelType |= schema.SiteToSiteTunnelType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 127:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteState", wireType)
			}
			m.SiteState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteState |= SiteState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 128:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 129:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarsList = append(m.MarsList, &schema.ServiceParameters{})
			if err := m.MarsList[len(m.MarsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 130:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarsVtrpList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarsVtrpList = append(m.MarsVtrpList, &schema.ServiceParameters{})
			if err := m.MarsVtrpList[len(m.MarsVtrpList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 131:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelDeadTimeout", wireType)
			}
			m.TunnelDeadTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelDeadTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 132:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 133:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opera", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opera == nil {
				m.Opera = &schema.ServiceParameters{}
			}
			if err := m.Opera.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 134:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CeSiteMode", wireType)
			}
			m.CeSiteMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CeSiteMode |= CeSiteMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 135:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoTenantInVk8SNs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoTenantInVk8SNs = bool(v != 0)
		case 136:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalK8SAccessEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LocalK8SAccessEnabled = bool(v != 0)
		case 137:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SClusterApiGw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.K8SClusterApiGw = append(m.K8SClusterApiGw, &schema.ObjectRefType{})
			if err := m.K8SClusterApiGw[len(m.K8SClusterApiGw)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 138:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 139:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpsecSslVipFqdn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpsecSslVipFqdn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 140:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsePrivateIp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsePrivateIp = bool(v != 0)
		case 141:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultUnderlayNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultUnderlayNetwork == nil {
				m.DefaultUnderlayNetwork = &DefaultUnderlayNetworkType{}
			}
			if err := m.DefaultUnderlayNetwork.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 142:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantIndex", wireType)
			}
			m.TenantIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 144:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipParamsPerAz", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VipParamsPerAz = append(m.VipParamsPerAz, &PublishVIPParamsPerAz{})
			if err := m.VipParamsPerAz[len(m.VipParamsPerAz)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 145:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PikuEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PikuEnabled = bool(v != 0)
		case 146:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhobosEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PhobosEnabled = bool(v != 0)
		case 147:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Srv6Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Srv6Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteType", wireType)
			}
			m.SiteType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteType |= SiteType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coordinates == nil {
				m.Coordinates = &Coordinates{}
			}
			if err := m.Coordinates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 114:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideVip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideVip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 115:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteToSiteTunnelIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteToSiteTunnelIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 116:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareOveride", wireType)
			}
			m.VolterraSoftwareOveride = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolterraSoftwareOveride |= SiteSoftwareOverrideType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 117:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpRouterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpRouterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 118:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpPeerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpPeerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 120:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideVip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideVip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 121:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipVrrpMode", wireType)
			}
			m.VipVrrpMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VipVrrpMode |= schema.VipVrrpType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 122:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteToSiteNetworkType", wireType)
			}
			m.SiteToSiteNetworkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteToSiteNetworkType |= schema.VirtualNetworkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 123:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideNameserver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideNameserver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 124:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideNameserver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideNameserver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 125:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredPoolCount", wireType)
			}
			m.DesiredPoolCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DesiredPoolCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 126:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelType", wireType)
			}
			m.TunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelType |= schema.SiteToSiteTunnelType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 127:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 129:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelDeadTimeout", wireType)
			}
			m.TunnelDeadTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelDeadTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 132:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 134:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CeSiteMode", wireType)
			}
			m.CeSiteMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CeSiteMode |= CeSiteMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 141:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultUnderlayNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultUnderlayNetwork == nil {
				m.DefaultUnderlayNetwork = &DefaultUnderlayNetworkType{}
			}
			if err := m.DefaultUnderlayNetwork.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coordinates == nil {
				m.Coordinates = &Coordinates{}
			}
			if err := m.Coordinates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolterraSoftwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 114:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideVip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideVip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 115:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteToSiteTunnelIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteToSiteTunnelIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 116:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareOveride", wireType)
			}
			m.VolterraSoftwareOveride = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolterraSoftwareOveride |= SiteSoftwareOverrideType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 117:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpRouterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpRouterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 118:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpPeerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpPeerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 120:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideVip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideVip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 121:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipVrrpMode", wireType)
			}
			m.VipVrrpMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VipVrrpMode |= schema.VipVrrpType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 122:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteToSiteNetworkType", wireType)
			}
			m.SiteToSiteNetworkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteToSiteNetworkType |= schema.VirtualNetworkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 123:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideNameserver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideNameserver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 124:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideNameserver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideNameserver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 125:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredPoolCount", wireType)
			}
			m.DesiredPoolCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DesiredPoolCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 126:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelType", wireType)
			}
			m.TunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelType |= schema.SiteToSiteTunnelType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 127:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 129:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelDeadTimeout", wireType)
			}
			m.TunnelDeadTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelDeadTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 132:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 141:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultUnderlayNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultUnderlayNetwork == nil {
				m.DefaultUnderlayNetwork = &DefaultUnderlayNetworkType{}
			}
			if err := m.DefaultUnderlayNetwork.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpecType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpecType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpecType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteType", wireType)
			}
			m.SiteType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteType |= SiteType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coordinates == nil {
				m.Coordinates = &Coordinates{}
			}
			if err := m.Coordinates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolterraSoftwareVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectedRe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectedRe = append(m.ConnectedRe, &schema.ObjectRefType{})
			if err := m.ConnectedRe[len(m.ConnectedRe)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 104:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectedReForConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectedReForConfig = append(m.ConnectedReForConfig, &schema.ObjectRefType{})
			if err := m.ConnectedReForConfig[len(m.ConnectedReForConfig)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 114:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideVip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideVip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 115:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteToSiteTunnelIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteToSiteTunnelIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 116:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolterraSoftwareOveride", wireType)
			}
			m.VolterraSoftwareOveride = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolterraSoftwareOveride |= SiteSoftwareOverrideType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 117:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpRouterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpRouterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 118:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BgpPeerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BgpPeerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 120:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideVip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideVip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 121:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipVrrpMode", wireType)
			}
			m.VipVrrpMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VipVrrpMode |= schema.VipVrrpType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 122:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteToSiteNetworkType", wireType)
			}
			m.SiteToSiteNetworkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteToSiteNetworkType |= schema.VirtualNetworkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 123:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsideNameserver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InsideNameserver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 124:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutsideNameserver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutsideNameserver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 125:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredPoolCount", wireType)
			}
			m.DesiredPoolCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DesiredPoolCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 126:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelType", wireType)
			}
			m.TunnelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelType |= schema.SiteToSiteTunnelType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 127:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 128:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteState", wireType)
			}
			m.SiteState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SiteState |= SiteState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 129:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelDeadTimeout", wireType)
			}
			m.TunnelDeadTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TunnelDeadTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 132:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 134:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CeSiteMode", wireType)
			}
			m.CeSiteMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CeSiteMode |= CeSiteMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 136:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalK8SAccessEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LocalK8SAccessEnabled = bool(v != 0)
		case 141:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultUnderlayNetwork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultUnderlayNetwork == nil {
				m.DefaultUnderlayNetwork = &DefaultUnderlayNetworkType{}
			}
			if err := m.DefaultUnderlayNetwork.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 142:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAccessK8SEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LocalAccessK8SEnabled = bool(v != 0)
		case 143:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalAccessK8SEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GlobalAccessK8SEnabled = bool(v != 0)
		case 144:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipParamsPerAz", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VipParamsPerAz = append(m.VipParamsPerAz, &PublishVIPParamsPerAz{})
			if err := m.VipParamsPerAz[len(m.VipParamsPerAz)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerInstanceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerInstanceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpsecStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpsecStatus = append(m.IpsecStatus, &IpsecConnectionStatus{})
			if err := m.IpsecStatus[len(m.IpsecStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AresStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AresStatus = append(m.AresStatus, &AresConnectionStatus{})
			if err := m.AresStatus[len(m.AresStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntfStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntfStatus = append(m.IntfStatus, &InterfaceStatus{})
			if err := m.IntfStatus[len(m.IntfStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfiguredTunnelStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfiguredTunnelStatus = append(m.ConfiguredTunnelStatus, &TunnelConnectionStatus{})
			if err := m.ConfiguredTunnelStatus[len(m.ConfiguredTunnelStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteTunnelStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteTunnelStatus = append(m.SiteTunnelStatus, &TunnelConnectionStatus{})
			if err := m.SiteTunnelStatus[len(m.SiteTunnelStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerMasterStatusType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerMasterStatusType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerMasterStatusType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver_UID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ver_UID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransitionTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransitionTimestamp == nil {
				m.TransitionTimestamp = &types.Timestamp{}
			}
			if err := m.TransitionTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpsecConnectionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpsecConnectionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpsecConnectionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= IPSecState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= IPSecRole(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLocal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLocal = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerNodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerNodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AresConnectionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AresConnectionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AresConnectionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= VTRPState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InterfaceStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InterfaceStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InterfaceStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ip == nil {
				m.Ip = &schema.IpSubnetType{}
			}
			if err := m.Ip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mac = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkType", wireType)
			}
			m.NetworkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkType |= schema.VirtualNetworkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpMode", wireType)
			}
			m.IpMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpMode |= AddressMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhcpServer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DhcpServer = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LinkState = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveState", wireType)
			}
			m.ActiveState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveState |= ActiveState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkQuality", wireType)
			}
			m.LinkQuality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkQuality |= LinkQuality(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkType", wireType)
			}
			m.LinkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkType |= LinkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondMembers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondMembers = append(m.BondMembers, &BondMembersType{})
			if err := m.BondMembers[len(m.BondMembers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv6", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ipv6 == nil {
				m.Ipv6 = &schema.IpSubnetType{}
			}
			if err := m.Ipv6.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelConnectionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelConnectionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelConnectionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= TunnelState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= TunnelRole(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encap", wireType)
			}
			m.Encap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encap |= schema.TunnelEncapsulationType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLocal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLocal = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerNodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerNodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TunnelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TunnelName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolterraSoftwareStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolterraSoftwareStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolterraSoftwareStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailableVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeploymentState == nil {
				m.DeploymentState = &DeploymentState{}
			}
			if err := m.DeploymentState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonconformingState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NonconformingState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperatingSystemStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperatingSystemStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperatingSystemStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvailableVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeploymentState == nil {
				m.DeploymentState = &DeploymentState{}
			}
			if err := m.DeploymentState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonconformingState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NonconformingState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModificationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModificationTimestamp == nil {
				m.ModificationTimestamp = &types.Timestamp{}
			}
			if err := m.ModificationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= SoftwareUpgradePhase(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FleetDeploymentState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FleetDeploymentState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FleetDeploymentState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModificationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModificationTimestamp == nil {
				m.ModificationTimestamp = &types.Timestamp{}
			}
			if err := m.ModificationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Condition = append(m.Condition, &FleetCondition{})
			if err := m.Condition[len(m.Condition)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FleetCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FleetCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FleetCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FleetStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FleetStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FleetStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeploymentState == nil {
				m.DeploymentState = &FleetDeploymentState{}
			}
			if err := m.DeploymentState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScalingStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScalingStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScalingStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= ScalingPhase(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolNodeCountCurrent", wireType)
			}
			m.PoolNodeCountCurrent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolNodeCountCurrent |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolNodeCountTarget", wireType)
			}
			m.PoolNodeCountTarget = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolNodeCountTarget |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = append(m.Role, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OsInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OsInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OsInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Os == nil {
				m.Os = &OS{}
			}
			if err := m.Os.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Product == nil {
				m.Product = &Product{}
			}
			if err := m.Product.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Board", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Board == nil {
				m.Board = &Board{}
			}
			if err := m.Board.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chassis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chassis == nil {
				m.Chassis = &Chassis{}
			}
			if err := m.Chassis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bios", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bios == nil {
				m.Bios = &Bios{}
			}
			if err := m.Bios.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cpu == nil {
				m.Cpu = &Cpu{}
			}
			if err := m.Cpu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Memory == nil {
				m.Memory = &Memory{}
			}
			if err := m.Memory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Storage = append(m.Storage, &StorageDevice{})
			if err := m.Storage[len(m.Storage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = append(m.Network, &NetworkDevice{})
			if err := m.Network[len(m.Network)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kernel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kernel == nil {
				m.Kernel = &Kernel{}
			}
			if err := m.Kernel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Usb = append(m.Usb, &USBDevice{})
			if err := m.Usb[len(m.Usb)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gpu == nil {
				m.Gpu = &GPU{}
			}
			if err := m.Gpu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Release", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Release = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Architecture", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Architecture = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Kernel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Kernel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Kernel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Release", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Release = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Architecture", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Architecture = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Product) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Product: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Product: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Serial", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Serial = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Board) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Board: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Board: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Serial", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Serial = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chassis) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chassis: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chassis: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Serial", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Serial = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bios) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bios: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bios: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cpu) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cpu: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cpu: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			m.Speed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Speed |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cache", wireType)
			}
			m.Cache = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cache |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpus", wireType)
			}
			m.Cpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cpus |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cores", wireType)
			}
			m.Cores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cores |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threads", wireType)
			}
			m.Threads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threads |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Memory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Memory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Memory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			m.Speed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Speed |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeMb", wireType)
			}
			m.SizeMb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeMb |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Driver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Serial", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Serial = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeGb", wireType)
			}
			m.SizeGb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeGb |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Driver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = append(m.IpAddress, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MacAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Port = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			m.Speed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Speed |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkQuality", wireType)
			}
			m.LinkQuality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkQuality |= LinkQuality(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkType", wireType)
			}
			m.LinkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkType |= LinkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *USBDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: USBDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: USBDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bus", wireType)
			}
			m.Bus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bus |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			m.Address = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Address |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VendorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VendorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ISerial", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ISerial = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdVendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdVendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdProduct", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdProduct = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IManufacturer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IManufacturer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Speed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Speed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BcdUsb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BcdUsb = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BcdDevice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BcdDevice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BDeviceClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BDeviceClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BDeviceSubClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BDeviceSubClass = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BDeviceProtocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BDeviceProtocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BMaxPacketSize", wireType)
			}
			m.BMaxPacketSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BMaxPacketSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IProduct", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IProduct = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsbType", wireType)
			}
			m.UsbType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsbType |= UsbType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPU) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPU: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPU: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DriverVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DriverVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CudaVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CudaVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuDevice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GpuDevice = append(m.GpuDevice, &GPUDevice{})
			if err := m.GpuDevice[len(m.GpuDevice)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Processes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteStatusMetricsFieldData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteStatusMetricsFieldData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteStatusMetricsFieldData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Key == nil {
				m.Key = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Key[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, &schema.MetricValue{})
			if err := m.Value[len(m.Value)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SiteStatusMetricsData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SiteStatusMetricsData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SiteStatusMetricsData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			m.Field = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Field |= SiteStatusMetricsField(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &SiteStatusMetricsFieldData{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateKubeConfigReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateKubeConfigReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateKubeConfigReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListKubeConfigReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListKubeConfigReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListKubeConfigReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListKubeConfigRspItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListKubeConfigRspItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListKubeConfigRspItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateTimestamp == nil {
				m.CreateTimestamp = &types.Timestamp{}
			}
			if err := m.CreateTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpiryTimestamp == nil {
				m.ExpiryTimestamp = &types.Timestamp{}
			}
			if err := m.ExpiryTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserEmail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserEmail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListKubeConfigRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListKubeConfigRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListKubeConfigRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ListKubeConfigRspItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalAccessCheckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalAccessCheckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalAccessCheckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalAccessCheckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalAccessCheckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalAccessCheckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateGlobalKubeConfigReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateGlobalKubeConfigReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateGlobalKubeConfigReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpirationTimestamp == nil {
				m.ExpirationTimestamp = &types.Timestamp{}
			}
			if err := m.ExpirationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListGlobalKubeConfigReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListGlobalKubeConfigReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListGlobalKubeConfigReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Site = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RevokeKubeConfigReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RevokeKubeConfigReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RevokeKubeConfigReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubeConfigStatusRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubeConfigStatusRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubeConfigStatusRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
