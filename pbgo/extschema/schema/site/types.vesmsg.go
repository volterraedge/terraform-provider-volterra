//
// Copyright (c) 2022 F5, Inc. All rights reserved.
// Code generated by ves-gen-schema-go. DO NOT EDIT.
//
package site

import (
	"context"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/proto"

	"gopkg.volterra.us/stdlib/codec"
	"gopkg.volterra.us/stdlib/db"
	"gopkg.volterra.us/stdlib/errors"

	ves_io_schema "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema"
	ves_io_schema_views "github.com/volterraedge/terraform-provider-volterra/pbgo/extschema/schema/views"
)

var (
	// dummy imports in case file has no message with Refs
	_ db.Interface
	_ = errors.Wrap
	_ = strings.Split
)

// augmented methods on protoc/std generated struct

func (m *AresConnectionStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AresConnectionStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AresConnectionStatus) DeepCopy() *AresConnectionStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AresConnectionStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AresConnectionStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AresConnectionStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AresConnectionStatusValidator().Validate(ctx, m, opts...)
}

type ValidateAresConnectionStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAresConnectionStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AresConnectionStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AresConnectionStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["url"]; exists {

		vOpts := append(opts, db.WithValidateField("url"))
		if err := fv(ctx, m.GetUrl(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAresConnectionStatusValidator = func() *ValidateAresConnectionStatus {
	v := &ValidateAresConnectionStatus{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AresConnectionStatusValidator() db.Validator {
	return DefaultAresConnectionStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureExpressRouteCircuitStatusType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureExpressRouteCircuitStatusType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureExpressRouteCircuitStatusType) DeepCopy() *AzureExpressRouteCircuitStatusType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureExpressRouteCircuitStatusType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureExpressRouteCircuitStatusType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureExpressRouteCircuitStatusType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureExpressRouteCircuitStatusTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAzureExpressRouteCircuitStatusType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureExpressRouteCircuitStatusType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureExpressRouteCircuitStatusType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureExpressRouteCircuitStatusType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["express_route_circuit_id"]; exists {

		vOpts := append(opts, db.WithValidateField("express_route_circuit_id"))
		if err := fv(ctx, m.GetExpressRouteCircuitId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["express_route_circuit_name"]; exists {

		vOpts := append(opts, db.WithValidateField("express_route_circuit_name"))
		if err := fv(ctx, m.GetExpressRouteCircuitName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["express_route_circuit_state"]; exists {

		vOpts := append(opts, db.WithValidateField("express_route_circuit_state"))
		if err := fv(ctx, m.GetExpressRouteCircuitState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["peer"]; exists {

		vOpts := append(opts, db.WithValidateField("peer"))
		if err := fv(ctx, m.GetPeer(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureExpressRouteCircuitStatusTypeValidator = func() *ValidateAzureExpressRouteCircuitStatusType {
	v := &ValidateAzureExpressRouteCircuitStatusType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AzureExpressRouteCircuitStatusTypeValidator() db.Validator {
	return DefaultAzureExpressRouteCircuitStatusTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureExpressRouteStatusType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureExpressRouteStatusType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureExpressRouteStatusType) DeepCopy() *AzureExpressRouteStatusType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureExpressRouteStatusType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureExpressRouteStatusType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureExpressRouteStatusType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureExpressRouteStatusTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAzureExpressRouteStatusType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureExpressRouteStatusType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureExpressRouteStatusType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureExpressRouteStatusType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["propagated_routes_from_azure_express_route"]; exists {

		vOpts := append(opts, db.WithValidateField("propagated_routes_from_azure_express_route"))
		for idx, item := range m.GetPropagatedRoutesFromAzureExpressRoute() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["route_server_status"]; exists {

		vOpts := append(opts, db.WithValidateField("route_server_status"))
		if err := fv(ctx, m.GetRouteServerStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vnet_gateway_status"]; exists {

		vOpts := append(opts, db.WithValidateField("vnet_gateway_status"))
		if err := fv(ctx, m.GetVnetGatewayStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureExpressRouteStatusTypeValidator = func() *ValidateAzureExpressRouteStatusType {
	v := &ValidateAzureExpressRouteStatusType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AzureExpressRouteStatusTypeValidator() db.Validator {
	return DefaultAzureExpressRouteStatusTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureHubSpokeVnetPeeringStatusInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureHubSpokeVnetPeeringStatusInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureHubSpokeVnetPeeringStatusInfo) DeepCopy() *AzureHubSpokeVnetPeeringStatusInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureHubSpokeVnetPeeringStatusInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureHubSpokeVnetPeeringStatusInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureHubSpokeVnetPeeringStatusInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureHubSpokeVnetPeeringStatusInfoValidator().Validate(ctx, m, opts...)
}

type ValidateAzureHubSpokeVnetPeeringStatusInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureHubSpokeVnetPeeringStatusInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureHubSpokeVnetPeeringStatusInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureHubSpokeVnetPeeringStatusInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["hub_vnet"]; exists {

		vOpts := append(opts, db.WithValidateField("hub_vnet"))
		if err := fv(ctx, m.GetHubVnet(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["spoke_vnets"]; exists {

		vOpts := append(opts, db.WithValidateField("spoke_vnets"))
		for idx, item := range m.GetSpokeVnets() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureHubSpokeVnetPeeringStatusInfoValidator = func() *ValidateAzureHubSpokeVnetPeeringStatusInfo {
	v := &ValidateAzureHubSpokeVnetPeeringStatusInfo{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["hub_vnet"] = AzureVNetToVnetPeeringStatusValidator().Validate

	v.FldValidators["spoke_vnets"] = AzureVNetToVnetPeeringStatusValidator().Validate

	return v
}()

func AzureHubSpokeVnetPeeringStatusInfoValidator() db.Validator {
	return DefaultAzureHubSpokeVnetPeeringStatusInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureVNetToVnetPeeringStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureVNetToVnetPeeringStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureVNetToVnetPeeringStatus) DeepCopy() *AzureVNetToVnetPeeringStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureVNetToVnetPeeringStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureVNetToVnetPeeringStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureVNetToVnetPeeringStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureVNetToVnetPeeringStatusValidator().Validate(ctx, m, opts...)
}

type ValidateAzureVNetToVnetPeeringStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureVNetToVnetPeeringStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureVNetToVnetPeeringStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureVNetToVnetPeeringStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["peers"]; exists {

		vOpts := append(opts, db.WithValidateField("peers"))
		for idx, item := range m.GetPeers() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["route_association_state"]; exists {

		vOpts := append(opts, db.WithValidateField("route_association_state"))
		if err := fv(ctx, m.GetRouteAssociationState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vnet_info"]; exists {

		vOpts := append(opts, db.WithValidateField("vnet_info"))
		if err := fv(ctx, m.GetVnetInfo(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureVNetToVnetPeeringStatusValidator = func() *ValidateAzureVNetToVnetPeeringStatus {
	v := &ValidateAzureVNetToVnetPeeringStatus{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["vnet_info"] = ves_io_schema_views.AzureVnetTypeValidator().Validate

	return v
}()

func AzureVNetToVnetPeeringStatusValidator() db.Validator {
	return DefaultAzureVNetToVnetPeeringStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *AzureVnetPeeringStateType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *AzureVnetPeeringStateType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *AzureVnetPeeringStateType) DeepCopy() *AzureVnetPeeringStateType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &AzureVnetPeeringStateType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *AzureVnetPeeringStateType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *AzureVnetPeeringStateType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return AzureVnetPeeringStateTypeValidator().Validate(ctx, m, opts...)
}

type ValidateAzureVnetPeeringStateType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateAzureVnetPeeringStateType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*AzureVnetPeeringStateType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *AzureVnetPeeringStateType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["peering_state"]; exists {

		vOpts := append(opts, db.WithValidateField("peering_state"))
		if err := fv(ctx, m.GetPeeringState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["peering_sync_level"]; exists {

		vOpts := append(opts, db.WithValidateField("peering_sync_level"))
		if err := fv(ctx, m.GetPeeringSyncLevel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["provisioning_state"]; exists {

		vOpts := append(opts, db.WithValidateField("provisioning_state"))
		if err := fv(ctx, m.GetProvisioningState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["remote_vnet_id"]; exists {

		vOpts := append(opts, db.WithValidateField("remote_vnet_id"))
		if err := fv(ctx, m.GetRemoteVnetId(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultAzureVnetPeeringStateTypeValidator = func() *ValidateAzureVnetPeeringStateType {
	v := &ValidateAzureVnetPeeringStateType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func AzureVnetPeeringStateTypeValidator() db.Validator {
	return DefaultAzureVnetPeeringStateTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *Bios) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Bios) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Bios) DeepCopy() *Bios {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Bios{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Bios) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Bios) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BiosValidator().Validate(ctx, m, opts...)
}

type ValidateBios struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBios) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Bios)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Bios got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["date"]; exists {

		vOpts := append(opts, db.WithValidateField("date"))
		if err := fv(ctx, m.GetDate(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vendor"]; exists {

		vOpts := append(opts, db.WithValidateField("vendor"))
		if err := fv(ctx, m.GetVendor(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBiosValidator = func() *ValidateBios {
	v := &ValidateBios{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func BiosValidator() db.Validator {
	return DefaultBiosValidator
}

// augmented methods on protoc/std generated struct

func (m *Board) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Board) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Board) DeepCopy() *Board {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Board{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Board) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Board) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BoardValidator().Validate(ctx, m, opts...)
}

type ValidateBoard struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBoard) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Board)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Board got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["asset_tag"]; exists {

		vOpts := append(opts, db.WithValidateField("asset_tag"))
		if err := fv(ctx, m.GetAssetTag(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["serial"]; exists {

		vOpts := append(opts, db.WithValidateField("serial"))
		if err := fv(ctx, m.GetSerial(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vendor"]; exists {

		vOpts := append(opts, db.WithValidateField("vendor"))
		if err := fv(ctx, m.GetVendor(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBoardValidator = func() *ValidateBoard {
	v := &ValidateBoard{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func BoardValidator() db.Validator {
	return DefaultBoardValidator
}

// augmented methods on protoc/std generated struct

func (m *BondMembersType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *BondMembersType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *BondMembersType) DeepCopy() *BondMembersType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &BondMembersType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *BondMembersType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *BondMembersType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return BondMembersTypeValidator().Validate(ctx, m, opts...)
}

type ValidateBondMembersType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateBondMembersType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*BondMembersType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *BondMembersType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["link_speed"]; exists {

		vOpts := append(opts, db.WithValidateField("link_speed"))
		if err := fv(ctx, m.GetLinkSpeed(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["link_state"]; exists {

		vOpts := append(opts, db.WithValidateField("link_state"))
		if err := fv(ctx, m.GetLinkState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultBondMembersTypeValidator = func() *ValidateBondMembersType {
	v := &ValidateBondMembersType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func BondMembersTypeValidator() db.Validator {
	return DefaultBondMembersTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *Chassis) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Chassis) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Chassis) DeepCopy() *Chassis {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Chassis{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Chassis) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Chassis) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ChassisValidator().Validate(ctx, m, opts...)
}

type ValidateChassis struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateChassis) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Chassis)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Chassis got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["asset_tag"]; exists {

		vOpts := append(opts, db.WithValidateField("asset_tag"))
		if err := fv(ctx, m.GetAssetTag(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["serial"]; exists {

		vOpts := append(opts, db.WithValidateField("serial"))
		if err := fv(ctx, m.GetSerial(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vendor"]; exists {

		vOpts := append(opts, db.WithValidateField("vendor"))
		if err := fv(ctx, m.GetVendor(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultChassisValidator = func() *ValidateChassis {
	v := &ValidateChassis{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ChassisValidator() db.Validator {
	return DefaultChassisValidator
}

// augmented methods on protoc/std generated struct

func (m *Coordinates) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Coordinates) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Coordinates) DeepCopy() *Coordinates {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Coordinates{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Coordinates) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Coordinates) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CoordinatesValidator().Validate(ctx, m, opts...)
}

type ValidateCoordinates struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCoordinates) LatitudeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewFloatValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for latitude")
	}

	return validatorFn, nil
}

func (v *ValidateCoordinates) LongitudeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewFloatValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for longitude")
	}

	return validatorFn, nil
}

func (v *ValidateCoordinates) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Coordinates)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Coordinates got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["latitude"]; exists {

		vOpts := append(opts, db.WithValidateField("latitude"))
		if err := fv(ctx, m.GetLatitude(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["longitude"]; exists {

		vOpts := append(opts, db.WithValidateField("longitude"))
		if err := fv(ctx, m.GetLongitude(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCoordinatesValidator = func() *ValidateCoordinates {
	v := &ValidateCoordinates{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhLatitude := v.LatitudeValidationRuleHandler
	rulesLatitude := map[string]string{
		"ves.io.schema.rules.float.gte": "-90.0",
		"ves.io.schema.rules.float.lte": "90.0",
	}
	vFn, err = vrhLatitude(rulesLatitude)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Coordinates.latitude: %s", err)
		panic(errMsg)
	}
	v.FldValidators["latitude"] = vFn

	vrhLongitude := v.LongitudeValidationRuleHandler
	rulesLongitude := map[string]string{
		"ves.io.schema.rules.float.gte": "-180.0",
		"ves.io.schema.rules.float.lte": "180.0",
	}
	vFn, err = vrhLongitude(rulesLongitude)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for Coordinates.longitude: %s", err)
		panic(errMsg)
	}
	v.FldValidators["longitude"] = vFn

	return v
}()

func CoordinatesValidator() db.Validator {
	return DefaultCoordinatesValidator
}

// augmented methods on protoc/std generated struct

func (m *Cpu) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Cpu) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Cpu) DeepCopy() *Cpu {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Cpu{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Cpu) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Cpu) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CpuValidator().Validate(ctx, m, opts...)
}

type ValidateCpu struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCpu) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Cpu)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Cpu got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cache"]; exists {

		vOpts := append(opts, db.WithValidateField("cache"))
		if err := fv(ctx, m.GetCache(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cores"]; exists {

		vOpts := append(opts, db.WithValidateField("cores"))
		if err := fv(ctx, m.GetCores(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cpus"]; exists {

		vOpts := append(opts, db.WithValidateField("cpus"))
		if err := fv(ctx, m.GetCpus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["flags"]; exists {

		vOpts := append(opts, db.WithValidateField("flags"))
		if err := fv(ctx, m.GetFlags(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["model"]; exists {

		vOpts := append(opts, db.WithValidateField("model"))
		if err := fv(ctx, m.GetModel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["speed"]; exists {

		vOpts := append(opts, db.WithValidateField("speed"))
		if err := fv(ctx, m.GetSpeed(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["threads"]; exists {

		vOpts := append(opts, db.WithValidateField("threads"))
		if err := fv(ctx, m.GetThreads(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vendor"]; exists {

		vOpts := append(opts, db.WithValidateField("vendor"))
		if err := fv(ctx, m.GetVendor(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCpuValidator = func() *ValidateCpu {
	v := &ValidateCpu{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func CpuValidator() db.Validator {
	return DefaultCpuValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateGlobalKubeConfigReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateGlobalKubeConfigReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateGlobalKubeConfigReq) DeepCopy() *CreateGlobalKubeConfigReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateGlobalKubeConfigReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateGlobalKubeConfigReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateGlobalKubeConfigReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateGlobalKubeConfigReqValidator().Validate(ctx, m, opts...)
}

type ValidateCreateGlobalKubeConfigReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateGlobalKubeConfigReq) SiteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site")
	}

	return validatorFn, nil
}

func (v *ValidateCreateGlobalKubeConfigReq) ExpirationTimestampValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var (
		reqdValidatorFn db.ValidatorFunc
		err             error
	)

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		if reqdValidatorFn != nil {
			if err = reqdValidatorFn(ctx, val, opts...); err != nil {
				return err
			}
		}
		// TODO: lookup configured third-party type validators
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateCreateGlobalKubeConfigReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateGlobalKubeConfigReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateGlobalKubeConfigReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["expiration_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("expiration_timestamp"))
		if err := fv(ctx, m.GetExpirationTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateGlobalKubeConfigReqValidator = func() *ValidateCreateGlobalKubeConfigReq {
	v := &ValidateCreateGlobalKubeConfigReq{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSite := v.SiteValidationRuleHandler
	rulesSite := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhSite(rulesSite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateGlobalKubeConfigReq.site: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site"] = vFn

	vrhExpirationTimestamp := v.ExpirationTimestampValidationRuleHandler
	rulesExpirationTimestamp := map[string]string{
		"ves.io.schema.rules.timestamp.gt_now":         "true",
		"ves.io.schema.rules.timestamp.within.seconds": "31536000",
	}
	vFn, err = vrhExpirationTimestamp(rulesExpirationTimestamp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateGlobalKubeConfigReq.expiration_timestamp: %s", err)
		panic(errMsg)
	}
	v.FldValidators["expiration_timestamp"] = vFn

	return v
}()

func CreateGlobalKubeConfigReqValidator() db.Validator {
	return DefaultCreateGlobalKubeConfigReqValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateKubeConfigReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateKubeConfigReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateKubeConfigReq) DeepCopy() *CreateKubeConfigReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateKubeConfigReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateKubeConfigReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateKubeConfigReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateKubeConfigReqValidator().Validate(ctx, m, opts...)
}

type ValidateCreateKubeConfigReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateKubeConfigReq) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateCreateKubeConfigReq) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateCreateKubeConfigReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateKubeConfigReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateKubeConfigReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateKubeConfigReqValidator = func() *ValidateCreateKubeConfigReq {
	v := &ValidateCreateKubeConfigReq{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateKubeConfigReq.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateKubeConfigReq.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func CreateKubeConfigReqValidator() db.Validator {
	return DefaultCreateKubeConfigReqValidator
}

// augmented methods on protoc/std generated struct

func (m *CreateSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *CreateSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *CreateSpecType) DeepCopy() *CreateSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &CreateSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *CreateSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *CreateSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return CreateSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateCreateSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateCreateSpecType) SiteTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(SiteType)
		return int32(i)
	}
	// SiteType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, SiteType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_type")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) AddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) InsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) SiteToSiteTunnelIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_to_site_tunnel_ip")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) BgpRouterIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bgp_router_id")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) BgpPeerAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bgp_peer_address")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) OutsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) SiteToSiteNetworkTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.VirtualNetworkType)
		return int32(i)
	}
	// ves_io_schema.VirtualNetworkType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.VirtualNetworkType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_to_site_network_type")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) InsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) OutsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) DesiredPoolCountValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewInt32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for desired_pool_count")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) TunnelTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.SiteToSiteTunnelType)
		return int32(i)
	}
	// ves_io_schema.SiteToSiteTunnelType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.SiteToSiteTunnelType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_type")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) TunnelDeadTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_dead_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateCreateSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*CreateSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *CreateSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_peer_address"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_peer_address"))
		if err := fv(ctx, m.GetBgpPeerAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_router_id"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_router_id"))
		if err := fv(ctx, m.GetBgpRouterId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ce_site_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("ce_site_mode"))
		if err := fv(ctx, m.GetCeSiteMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["coordinates"]; exists {

		vOpts := append(opts, db.WithValidateField("coordinates"))
		if err := fv(ctx, m.GetCoordinates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_underlay_network"]; exists {

		vOpts := append(opts, db.WithValidateField("default_underlay_network"))
		if err := fv(ctx, m.GetDefaultUnderlayNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["desired_pool_count"]; exists {

		vOpts := append(opts, db.WithValidateField("desired_pool_count"))
		if err := fv(ctx, m.GetDesiredPoolCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_nameserver"))
		if err := fv(ctx, m.GetInsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_vip"))
		if err := fv(ctx, m.GetInsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operating_system_version"]; exists {

		vOpts := append(opts, db.WithValidateField("operating_system_version"))
		if err := fv(ctx, m.GetOperatingSystemVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_nameserver"))
		if err := fv(ctx, m.GetOutsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_vip"))
		if err := fv(ctx, m.GetOutsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["region"]; exists {

		vOpts := append(opts, db.WithValidateField("region"))
		if err := fv(ctx, m.GetRegion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_network_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_network_type"))
		if err := fv(ctx, m.GetSiteToSiteNetworkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_tunnel_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_tunnel_ip"))
		if err := fv(ctx, m.GetSiteToSiteTunnelIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_type"))
		if err := fv(ctx, m.GetSiteType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_dead_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_dead_timeout"))
		if err := fv(ctx, m.GetTunnelDeadTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_type"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_type"))
		if err := fv(ctx, m.GetTunnelType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vip_vrrp_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("vip_vrrp_mode"))
		if err := fv(ctx, m.GetVipVrrpMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_overide"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_overide"))
		if err := fv(ctx, m.GetVolterraSoftwareOveride(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultCreateSpecTypeValidator = func() *ValidateCreateSpecType {
	v := &ValidateCreateSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSiteType := v.SiteTypeValidationRuleHandler
	rulesSiteType := map[string]string{
		"ves.io.schema.rules.enum.not_in": "0",
	}
	vFn, err = vrhSiteType(rulesSiteType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.site_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_type"] = vFn

	vrhAddress := v.AddressValidationRuleHandler
	rulesAddress := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhAddress(rulesAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address"] = vFn

	vrhInsideVip := v.InsideVipValidationRuleHandler
	rulesInsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideVip(rulesInsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.inside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_vip"] = vFn

	vrhSiteToSiteTunnelIp := v.SiteToSiteTunnelIpValidationRuleHandler
	rulesSiteToSiteTunnelIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhSiteToSiteTunnelIp(rulesSiteToSiteTunnelIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.site_to_site_tunnel_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_to_site_tunnel_ip"] = vFn

	vrhBgpRouterId := v.BgpRouterIdValidationRuleHandler
	rulesBgpRouterId := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhBgpRouterId(rulesBgpRouterId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.bgp_router_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bgp_router_id"] = vFn

	vrhBgpPeerAddress := v.BgpPeerAddressValidationRuleHandler
	rulesBgpPeerAddress := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhBgpPeerAddress(rulesBgpPeerAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.bgp_peer_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bgp_peer_address"] = vFn

	vrhOutsideVip := v.OutsideVipValidationRuleHandler
	rulesOutsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhOutsideVip(rulesOutsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.outside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_vip"] = vFn

	vrhSiteToSiteNetworkType := v.SiteToSiteNetworkTypeValidationRuleHandler
	rulesSiteToSiteNetworkType := map[string]string{
		"ves.io.schema.rules.enum.in": "[0,1]",
	}
	vFn, err = vrhSiteToSiteNetworkType(rulesSiteToSiteNetworkType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.site_to_site_network_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_to_site_network_type"] = vFn

	vrhInsideNameserver := v.InsideNameserverValidationRuleHandler
	rulesInsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideNameserver(rulesInsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.inside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_nameserver"] = vFn

	vrhOutsideNameserver := v.OutsideNameserverValidationRuleHandler
	rulesOutsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhOutsideNameserver(rulesOutsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.outside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_nameserver"] = vFn

	vrhDesiredPoolCount := v.DesiredPoolCountValidationRuleHandler
	rulesDesiredPoolCount := map[string]string{
		"ves.io.schema.rules.int32.gte": "-1",
		"ves.io.schema.rules.int32.lte": "64",
	}
	vFn, err = vrhDesiredPoolCount(rulesDesiredPoolCount)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.desired_pool_count: %s", err)
		panic(errMsg)
	}
	v.FldValidators["desired_pool_count"] = vFn

	vrhTunnelType := v.TunnelTypeValidationRuleHandler
	rulesTunnelType := map[string]string{
		"ves.io.schema.rules.enum.in": "[0,1,2]",
	}
	vFn, err = vrhTunnelType(rulesTunnelType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.tunnel_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_type"] = vFn

	vrhTunnelDeadTimeout := v.TunnelDeadTimeoutValidationRuleHandler
	rulesTunnelDeadTimeout := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "180000",
	}
	vFn, err = vrhTunnelDeadTimeout(rulesTunnelDeadTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for CreateSpecType.tunnel_dead_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_dead_timeout"] = vFn

	v.FldValidators["coordinates"] = CoordinatesValidator().Validate

	v.FldValidators["default_underlay_network"] = DefaultUnderlayNetworkTypeValidator().Validate

	return v
}()

func CreateSpecTypeValidator() db.Validator {
	return DefaultCreateSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DefaultUnderlayNetworkType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DefaultUnderlayNetworkType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DefaultUnderlayNetworkType) DeepCopy() *DefaultUnderlayNetworkType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DefaultUnderlayNetworkType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DefaultUnderlayNetworkType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DefaultUnderlayNetworkType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DefaultUnderlayNetworkTypeValidator().Validate(ctx, m, opts...)
}

type ValidateDefaultUnderlayNetworkType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDefaultUnderlayNetworkType) PrivateAccessChoiceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {
	validatorFn, err := db.NewMessageValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for private_access_choice")
	}
	return validatorFn, nil
}

func (v *ValidateDefaultUnderlayNetworkType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DefaultUnderlayNetworkType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DefaultUnderlayNetworkType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["private_access_choice"]; exists {
		val := m.GetPrivateAccessChoice()
		vOpts := append(opts,
			db.WithValidateField("private_access_choice"),
		)
		if err := fv(ctx, val, vOpts...); err != nil {
			return err
		}
	}

	switch m.GetPrivateAccessChoice().(type) {
	case *DefaultUnderlayNetworkType_SiteLocalOutside:
		if fv, exists := v.FldValidators["private_access_choice.site_local_outside"]; exists {
			val := m.GetPrivateAccessChoice().(*DefaultUnderlayNetworkType_SiteLocalOutside).SiteLocalOutside
			vOpts := append(opts,
				db.WithValidateField("private_access_choice"),
				db.WithValidateField("site_local_outside"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *DefaultUnderlayNetworkType_SiteLocalInside:
		if fv, exists := v.FldValidators["private_access_choice.site_local_inside"]; exists {
			val := m.GetPrivateAccessChoice().(*DefaultUnderlayNetworkType_SiteLocalInside).SiteLocalInside
			vOpts := append(opts,
				db.WithValidateField("private_access_choice"),
				db.WithValidateField("site_local_inside"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDefaultUnderlayNetworkTypeValidator = func() *ValidateDefaultUnderlayNetworkType {
	v := &ValidateDefaultUnderlayNetworkType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhPrivateAccessChoice := v.PrivateAccessChoiceValidationRuleHandler
	rulesPrivateAccessChoice := map[string]string{
		"ves.io.schema.rules.message.required_oneof": "true",
	}
	vFn, err = vrhPrivateAccessChoice(rulesPrivateAccessChoice)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for DefaultUnderlayNetworkType.private_access_choice: %s", err)
		panic(errMsg)
	}
	v.FldValidators["private_access_choice"] = vFn

	return v
}()

func DefaultUnderlayNetworkTypeValidator() db.Validator {
	return DefaultDefaultUnderlayNetworkTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *DeploymentState) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DeploymentState) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DeploymentState) DeepCopy() *DeploymentState {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DeploymentState{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DeploymentState) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DeploymentState) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DeploymentStateValidator().Validate(ctx, m, opts...)
}

type ValidateDeploymentState struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDeploymentState) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DeploymentState)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DeploymentState got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["message"]; exists {

		vOpts := append(opts, db.WithValidateField("message"))
		if err := fv(ctx, m.GetMessage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["modification_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("modification_timestamp"))
		if err := fv(ctx, m.GetModificationTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["phase"]; exists {

		vOpts := append(opts, db.WithValidateField("phase"))
		if err := fv(ctx, m.GetPhase(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["result"]; exists {

		vOpts := append(opts, db.WithValidateField("result"))
		if err := fv(ctx, m.GetResult(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDeploymentStateValidator = func() *ValidateDeploymentState {
	v := &ValidateDeploymentState{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DeploymentStateValidator() db.Validator {
	return DefaultDeploymentStateValidator
}

// augmented methods on protoc/std generated struct

func (m *DirectConnectBGPPeerInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DirectConnectBGPPeerInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DirectConnectBGPPeerInfo) DeepCopy() *DirectConnectBGPPeerInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DirectConnectBGPPeerInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DirectConnectBGPPeerInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DirectConnectBGPPeerInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DirectConnectBGPPeerInfoValidator().Validate(ctx, m, opts...)
}

type ValidateDirectConnectBGPPeerInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDirectConnectBGPPeerInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DirectConnectBGPPeerInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DirectConnectBGPPeerInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address_family"]; exists {

		vOpts := append(opts, db.WithValidateField("address_family"))
		if err := fv(ctx, m.GetAddressFamily(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["amazon_address"]; exists {

		vOpts := append(opts, db.WithValidateField("amazon_address"))
		if err := fv(ctx, m.GetAmazonAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["asn"]; exists {

		vOpts := append(opts, db.WithValidateField("asn"))
		if err := fv(ctx, m.GetAsn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_peer_id"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_peer_id"))
		if err := fv(ctx, m.GetBgpPeerId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_peer_state"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_peer_state"))
		if err := fv(ctx, m.GetBgpPeerState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_status"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_status"))
		if err := fv(ctx, m.GetBgpStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["customer_address"]; exists {

		vOpts := append(opts, db.WithValidateField("customer_address"))
		if err := fv(ctx, m.GetCustomerAddress(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDirectConnectBGPPeerInfoValidator = func() *ValidateDirectConnectBGPPeerInfo {
	v := &ValidateDirectConnectBGPPeerInfo{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DirectConnectBGPPeerInfoValidator() db.Validator {
	return DefaultDirectConnectBGPPeerInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *DirectConnectStatusInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DirectConnectStatusInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DirectConnectStatusInfo) DeepCopy() *DirectConnectStatusInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DirectConnectStatusInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DirectConnectStatusInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DirectConnectStatusInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DirectConnectStatusInfoValidator().Validate(ctx, m, opts...)
}

type ValidateDirectConnectStatusInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDirectConnectStatusInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DirectConnectStatusInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DirectConnectStatusInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["direct_connect_gateway_id"]; exists {

		vOpts := append(opts, db.WithValidateField("direct_connect_gateway_id"))
		if err := fv(ctx, m.GetDirectConnectGatewayId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["direct_connect_gateway_state"]; exists {

		vOpts := append(opts, db.WithValidateField("direct_connect_gateway_state"))
		if err := fv(ctx, m.GetDirectConnectGatewayState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["direct_connect_vgw_association_state"]; exists {

		vOpts := append(opts, db.WithValidateField("direct_connect_vgw_association_state"))
		if err := fv(ctx, m.GetDirectConnectVgwAssociationState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["propagated_routes_from_direct_connect_connection"]; exists {

		vOpts := append(opts, db.WithValidateField("propagated_routes_from_direct_connect_connection"))
		for idx, item := range m.GetPropagatedRoutesFromDirectConnectConnection() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["vgw_id"]; exists {

		vOpts := append(opts, db.WithValidateField("vgw_id"))
		if err := fv(ctx, m.GetVgwId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vgw_state"]; exists {

		vOpts := append(opts, db.WithValidateField("vgw_state"))
		if err := fv(ctx, m.GetVgwState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vif_states"]; exists {

		vOpts := append(opts, db.WithValidateField("vif_states"))
		for idx, item := range m.GetVifStates() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDirectConnectStatusInfoValidator = func() *ValidateDirectConnectStatusInfo {
	v := &ValidateDirectConnectStatusInfo{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DirectConnectStatusInfoValidator() db.Validator {
	return DefaultDirectConnectStatusInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *DirectConnectVIFStateInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *DirectConnectVIFStateInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *DirectConnectVIFStateInfo) DeepCopy() *DirectConnectVIFStateInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &DirectConnectVIFStateInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *DirectConnectVIFStateInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *DirectConnectVIFStateInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return DirectConnectVIFStateInfoValidator().Validate(ctx, m, opts...)
}

type ValidateDirectConnectVIFStateInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateDirectConnectVIFStateInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*DirectConnectVIFStateInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *DirectConnectVIFStateInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["attachment_state"]; exists {

		vOpts := append(opts, db.WithValidateField("attachment_state"))
		if err := fv(ctx, m.GetAttachmentState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_peers"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_peers"))
		for idx, item := range m.GetBgpPeers() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["vif_id"]; exists {

		vOpts := append(opts, db.WithValidateField("vif_id"))
		if err := fv(ctx, m.GetVifId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vif_state"]; exists {

		vOpts := append(opts, db.WithValidateField("vif_state"))
		if err := fv(ctx, m.GetVifState(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultDirectConnectVIFStateInfoValidator = func() *ValidateDirectConnectVIFStateInfo {
	v := &ValidateDirectConnectVIFStateInfo{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func DirectConnectVIFStateInfoValidator() db.Validator {
	return DefaultDirectConnectVIFStateInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *ExpressRoutePeeringStatusType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ExpressRoutePeeringStatusType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ExpressRoutePeeringStatusType) DeepCopy() *ExpressRoutePeeringStatusType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ExpressRoutePeeringStatusType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ExpressRoutePeeringStatusType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ExpressRoutePeeringStatusType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ExpressRoutePeeringStatusTypeValidator().Validate(ctx, m, opts...)
}

type ValidateExpressRoutePeeringStatusType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateExpressRoutePeeringStatusType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ExpressRoutePeeringStatusType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ExpressRoutePeeringStatusType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["azure_asn"]; exists {

		vOpts := append(opts, db.WithValidateField("azure_asn"))
		if err := fv(ctx, m.GetAzureAsn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["peer_asn"]; exists {

		vOpts := append(opts, db.WithValidateField("peer_asn"))
		if err := fv(ctx, m.GetPeerAsn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["peering_type"]; exists {

		vOpts := append(opts, db.WithValidateField("peering_type"))
		if err := fv(ctx, m.GetPeeringType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["provisioningState"]; exists {

		vOpts := append(opts, db.WithValidateField("provisioningState"))
		if err := fv(ctx, m.GetProvisioningState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultExpressRoutePeeringStatusTypeValidator = func() *ValidateExpressRoutePeeringStatusType {
	v := &ValidateExpressRoutePeeringStatusType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ExpressRoutePeeringStatusTypeValidator() db.Validator {
	return DefaultExpressRoutePeeringStatusTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *FleetCondition) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FleetCondition) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FleetCondition) DeepCopy() *FleetCondition {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FleetCondition{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FleetCondition) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FleetCondition) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FleetConditionValidator().Validate(ctx, m, opts...)
}

type ValidateFleetCondition struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFleetCondition) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FleetCondition)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FleetCondition got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["message"]; exists {

		vOpts := append(opts, db.WithValidateField("message"))
		if err := fv(ctx, m.GetMessage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["module_name"]; exists {

		vOpts := append(opts, db.WithValidateField("module_name"))
		if err := fv(ctx, m.GetModuleName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["result"]; exists {

		vOpts := append(opts, db.WithValidateField("result"))
		if err := fv(ctx, m.GetResult(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFleetConditionValidator = func() *ValidateFleetCondition {
	v := &ValidateFleetCondition{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FleetConditionValidator() db.Validator {
	return DefaultFleetConditionValidator
}

// augmented methods on protoc/std generated struct

func (m *FleetDeploymentState) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FleetDeploymentState) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FleetDeploymentState) DeepCopy() *FleetDeploymentState {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FleetDeploymentState{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FleetDeploymentState) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FleetDeploymentState) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FleetDeploymentStateValidator().Validate(ctx, m, opts...)
}

type ValidateFleetDeploymentState struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFleetDeploymentState) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FleetDeploymentState)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FleetDeploymentState got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["condition"]; exists {

		vOpts := append(opts, db.WithValidateField("condition"))
		for idx, item := range m.GetCondition() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["hash"]; exists {

		vOpts := append(opts, db.WithValidateField("hash"))
		if err := fv(ctx, m.GetHash(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["modification_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("modification_timestamp"))
		if err := fv(ctx, m.GetModificationTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["result"]; exists {

		vOpts := append(opts, db.WithValidateField("result"))
		if err := fv(ctx, m.GetResult(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFleetDeploymentStateValidator = func() *ValidateFleetDeploymentState {
	v := &ValidateFleetDeploymentState{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FleetDeploymentStateValidator() db.Validator {
	return DefaultFleetDeploymentStateValidator
}

// augmented methods on protoc/std generated struct

func (m *FleetStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *FleetStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *FleetStatus) DeepCopy() *FleetStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &FleetStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *FleetStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *FleetStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return FleetStatusValidator().Validate(ctx, m, opts...)
}

type ValidateFleetStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateFleetStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*FleetStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *FleetStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["deployment_state"]; exists {

		vOpts := append(opts, db.WithValidateField("deployment_state"))
		if err := fv(ctx, m.GetDeploymentState(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultFleetStatusValidator = func() *ValidateFleetStatus {
	v := &ValidateFleetStatus{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func FleetStatusValidator() db.Validator {
	return DefaultFleetStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *GPU) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GPU) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GPU) DeepCopy() *GPU {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GPU{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GPU) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GPU) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GPUValidator().Validate(ctx, m, opts...)
}

type ValidateGPU struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGPU) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GPU)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GPU got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["cuda_version"]; exists {

		vOpts := append(opts, db.WithValidateField("cuda_version"))
		if err := fv(ctx, m.GetCudaVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["driver_version"]; exists {

		vOpts := append(opts, db.WithValidateField("driver_version"))
		if err := fv(ctx, m.GetDriverVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gpu_device"]; exists {

		vOpts := append(opts, db.WithValidateField("gpu_device"))
		for idx, item := range m.GetGpuDevice() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGPUValidator = func() *ValidateGPU {
	v := &ValidateGPU{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GPUValidator() db.Validator {
	return DefaultGPUValidator
}

// augmented methods on protoc/std generated struct

func (m *GPUDevice) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GPUDevice) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GPUDevice) DeepCopy() *GPUDevice {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GPUDevice{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GPUDevice) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GPUDevice) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GPUDeviceValidator().Validate(ctx, m, opts...)
}

type ValidateGPUDevice struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGPUDevice) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GPUDevice)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GPUDevice got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["id"]; exists {

		vOpts := append(opts, db.WithValidateField("id"))
		if err := fv(ctx, m.GetId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["processes"]; exists {

		vOpts := append(opts, db.WithValidateField("processes"))
		if err := fv(ctx, m.GetProcesses(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["product_name"]; exists {

		vOpts := append(opts, db.WithValidateField("product_name"))
		if err := fv(ctx, m.GetProductName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGPUDeviceValidator = func() *ValidateGPUDevice {
	v := &ValidateGPUDevice{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GPUDeviceValidator() db.Validator {
	return DefaultGPUDeviceValidator
}

// augmented methods on protoc/std generated struct

func (m *GetSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GetSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GetSpecType) DeepCopy() *GetSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GetSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GetSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GetSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GetSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GetSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetConnectedReDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetConnectedReDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetConnectedReForConfigDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetConnectedReForConfigDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *GetSpecType) GetConnectedReDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetConnectedRe()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.connected_re[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "site.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "connected_re",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetConnectedReDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetConnectedReDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: site")
	}
	for _, ref := range m.GetConnectedRe() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GetSpecType) GetConnectedReForConfigDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetConnectedReForConfig()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GetSpecType.connected_re_for_config[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "site.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "connected_re_for_config",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetConnectedReForConfigDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GetSpecType) GetConnectedReForConfigDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: site")
	}
	for _, ref := range m.GetConnectedReForConfig() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateGetSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGetSpecType) SiteTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(SiteType)
		return int32(i)
	}
	// SiteType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, SiteType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_type")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) AddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) ConnectedReValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for connected_re")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for connected_re")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated connected_re")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items connected_re")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) ConnectedReForConfigValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for connected_re_for_config")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for connected_re_for_config")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated connected_re_for_config")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items connected_re_for_config")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) InsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) SiteToSiteTunnelIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_to_site_tunnel_ip")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) BgpRouterIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bgp_router_id")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) BgpPeerAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bgp_peer_address")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) OutsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) SiteToSiteNetworkTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.VirtualNetworkType)
		return int32(i)
	}
	// ves_io_schema.VirtualNetworkType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.VirtualNetworkType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_to_site_network_type")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) InsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) OutsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) DesiredPoolCountValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewInt32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for desired_pool_count")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) TunnelTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.SiteToSiteTunnelType)
		return int32(i)
	}
	// ves_io_schema.SiteToSiteTunnelType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.SiteToSiteTunnelType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_type")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) TunnelDeadTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_dead_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) VipParamsPerAzValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for vip_params_per_az")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*PublishVIPParamsPerAz, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := PublishVIPParamsPerAzValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for vip_params_per_az")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*PublishVIPParamsPerAz)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*PublishVIPParamsPerAz, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated vip_params_per_az")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items vip_params_per_az")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) SiteToSiteIpsecConnectivityValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for site_to_site_ipsec_connectivity")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*SiteToSiteTunnelConnectivity, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := SiteToSiteTunnelConnectivityValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for site_to_site_ipsec_connectivity")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*SiteToSiteTunnelConnectivity)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*SiteToSiteTunnelConnectivity, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated site_to_site_ipsec_connectivity")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items site_to_site_ipsec_connectivity")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) IpsecSslNodesFqdnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for ipsec_ssl_nodes_fqdn")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ipsec_ssl_nodes_fqdn")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ipsec_ssl_nodes_fqdn")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ipsec_ssl_nodes_fqdn")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGetSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GetSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GetSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_peer_address"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_peer_address"))
		if err := fv(ctx, m.GetBgpPeerAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_router_id"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_router_id"))
		if err := fv(ctx, m.GetBgpRouterId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ce_site_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("ce_site_mode"))
		if err := fv(ctx, m.GetCeSiteMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["connected_re"]; exists {
		vOpts := append(opts, db.WithValidateField("connected_re"))
		if err := fv(ctx, m.GetConnectedRe(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["connected_re_for_config"]; exists {
		vOpts := append(opts, db.WithValidateField("connected_re_for_config"))
		if err := fv(ctx, m.GetConnectedReForConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["coordinates"]; exists {

		vOpts := append(opts, db.WithValidateField("coordinates"))
		if err := fv(ctx, m.GetCoordinates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_underlay_network"]; exists {

		vOpts := append(opts, db.WithValidateField("default_underlay_network"))
		if err := fv(ctx, m.GetDefaultUnderlayNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["desired_pool_count"]; exists {

		vOpts := append(opts, db.WithValidateField("desired_pool_count"))
		if err := fv(ctx, m.GetDesiredPoolCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["global_access_k8s_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("global_access_k8s_enabled"))
		if err := fv(ctx, m.GetGlobalAccessK8SEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_nameserver"))
		if err := fv(ctx, m.GetInsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_vip"))
		if err := fv(ctx, m.GetInsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ipsec_ssl_nodes_fqdn"]; exists {
		vOpts := append(opts, db.WithValidateField("ipsec_ssl_nodes_fqdn"))
		if err := fv(ctx, m.GetIpsecSslNodesFqdn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["local_access_k8s_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("local_access_k8s_enabled"))
		if err := fv(ctx, m.GetLocalAccessK8SEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["local_k8s_access_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("local_k8s_access_enabled"))
		if err := fv(ctx, m.GetLocalK8SAccessEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["multus_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("multus_enabled"))
		if err := fv(ctx, m.GetMultusEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operating_system_version"]; exists {

		vOpts := append(opts, db.WithValidateField("operating_system_version"))
		if err := fv(ctx, m.GetOperatingSystemVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_nameserver"))
		if err := fv(ctx, m.GetOutsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_vip"))
		if err := fv(ctx, m.GetOutsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["region"]; exists {

		vOpts := append(opts, db.WithValidateField("region"))
		if err := fv(ctx, m.GetRegion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_state"]; exists {

		vOpts := append(opts, db.WithValidateField("site_state"))
		if err := fv(ctx, m.GetSiteState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_subtype"]; exists {

		vOpts := append(opts, db.WithValidateField("site_subtype"))
		if err := fv(ctx, m.GetSiteSubtype(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_ipsec_connectivity"]; exists {
		vOpts := append(opts, db.WithValidateField("site_to_site_ipsec_connectivity"))
		if err := fv(ctx, m.GetSiteToSiteIpsecConnectivity(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_network_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_network_type"))
		if err := fv(ctx, m.GetSiteToSiteNetworkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_tunnel_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_tunnel_ip"))
		if err := fv(ctx, m.GetSiteToSiteTunnelIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_type"))
		if err := fv(ctx, m.GetSiteType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_dead_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_dead_timeout"))
		if err := fv(ctx, m.GetTunnelDeadTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_type"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_type"))
		if err := fv(ctx, m.GetTunnelType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vip_params_per_az"]; exists {
		vOpts := append(opts, db.WithValidateField("vip_params_per_az"))
		if err := fv(ctx, m.GetVipParamsPerAz(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vip_vrrp_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("vip_vrrp_mode"))
		if err := fv(ctx, m.GetVipVrrpMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vm_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("vm_enabled"))
		if err := fv(ctx, m.GetVmEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_overide"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_overide"))
		if err := fv(ctx, m.GetVolterraSoftwareOveride(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_version"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_version"))
		if err := fv(ctx, m.GetVolterraSoftwareVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGetSpecTypeValidator = func() *ValidateGetSpecType {
	v := &ValidateGetSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSiteType := v.SiteTypeValidationRuleHandler
	rulesSiteType := map[string]string{
		"ves.io.schema.rules.enum.not_in": "0",
	}
	vFn, err = vrhSiteType(rulesSiteType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.site_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_type"] = vFn

	vrhAddress := v.AddressValidationRuleHandler
	rulesAddress := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhAddress(rulesAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address"] = vFn

	vrhConnectedRe := v.ConnectedReValidationRuleHandler
	rulesConnectedRe := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhConnectedRe(rulesConnectedRe)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.connected_re: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connected_re"] = vFn

	vrhConnectedReForConfig := v.ConnectedReForConfigValidationRuleHandler
	rulesConnectedReForConfig := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhConnectedReForConfig(rulesConnectedReForConfig)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.connected_re_for_config: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connected_re_for_config"] = vFn

	vrhInsideVip := v.InsideVipValidationRuleHandler
	rulesInsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideVip(rulesInsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.inside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_vip"] = vFn

	vrhSiteToSiteTunnelIp := v.SiteToSiteTunnelIpValidationRuleHandler
	rulesSiteToSiteTunnelIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhSiteToSiteTunnelIp(rulesSiteToSiteTunnelIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.site_to_site_tunnel_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_to_site_tunnel_ip"] = vFn

	vrhBgpRouterId := v.BgpRouterIdValidationRuleHandler
	rulesBgpRouterId := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhBgpRouterId(rulesBgpRouterId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.bgp_router_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bgp_router_id"] = vFn

	vrhBgpPeerAddress := v.BgpPeerAddressValidationRuleHandler
	rulesBgpPeerAddress := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhBgpPeerAddress(rulesBgpPeerAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.bgp_peer_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bgp_peer_address"] = vFn

	vrhOutsideVip := v.OutsideVipValidationRuleHandler
	rulesOutsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhOutsideVip(rulesOutsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.outside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_vip"] = vFn

	vrhSiteToSiteNetworkType := v.SiteToSiteNetworkTypeValidationRuleHandler
	rulesSiteToSiteNetworkType := map[string]string{
		"ves.io.schema.rules.enum.in": "[0,1]",
	}
	vFn, err = vrhSiteToSiteNetworkType(rulesSiteToSiteNetworkType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.site_to_site_network_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_to_site_network_type"] = vFn

	vrhInsideNameserver := v.InsideNameserverValidationRuleHandler
	rulesInsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideNameserver(rulesInsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.inside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_nameserver"] = vFn

	vrhOutsideNameserver := v.OutsideNameserverValidationRuleHandler
	rulesOutsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhOutsideNameserver(rulesOutsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.outside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_nameserver"] = vFn

	vrhDesiredPoolCount := v.DesiredPoolCountValidationRuleHandler
	rulesDesiredPoolCount := map[string]string{
		"ves.io.schema.rules.int32.gte": "-1",
		"ves.io.schema.rules.int32.lte": "64",
	}
	vFn, err = vrhDesiredPoolCount(rulesDesiredPoolCount)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.desired_pool_count: %s", err)
		panic(errMsg)
	}
	v.FldValidators["desired_pool_count"] = vFn

	vrhTunnelType := v.TunnelTypeValidationRuleHandler
	rulesTunnelType := map[string]string{
		"ves.io.schema.rules.enum.in": "[0,1,2]",
	}
	vFn, err = vrhTunnelType(rulesTunnelType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.tunnel_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_type"] = vFn

	vrhTunnelDeadTimeout := v.TunnelDeadTimeoutValidationRuleHandler
	rulesTunnelDeadTimeout := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "180000",
	}
	vFn, err = vrhTunnelDeadTimeout(rulesTunnelDeadTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.tunnel_dead_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_dead_timeout"] = vFn

	vrhVipParamsPerAz := v.VipParamsPerAzValidationRuleHandler
	rulesVipParamsPerAz := map[string]string{
		"ves.io.schema.rules.repeated.num_items": "0,1,2,3",
	}
	vFn, err = vrhVipParamsPerAz(rulesVipParamsPerAz)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.vip_params_per_az: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vip_params_per_az"] = vFn

	vrhSiteToSiteIpsecConnectivity := v.SiteToSiteIpsecConnectivityValidationRuleHandler
	rulesSiteToSiteIpsecConnectivity := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "3",
	}
	vFn, err = vrhSiteToSiteIpsecConnectivity(rulesSiteToSiteIpsecConnectivity)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.site_to_site_ipsec_connectivity: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_to_site_ipsec_connectivity"] = vFn

	vrhIpsecSslNodesFqdn := v.IpsecSslNodesFqdnValidationRuleHandler
	rulesIpsecSslNodesFqdn := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
	}
	vFn, err = vrhIpsecSslNodesFqdn(rulesIpsecSslNodesFqdn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GetSpecType.ipsec_ssl_nodes_fqdn: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ipsec_ssl_nodes_fqdn"] = vFn

	v.FldValidators["coordinates"] = CoordinatesValidator().Validate

	v.FldValidators["default_underlay_network"] = DefaultUnderlayNetworkTypeValidator().Validate

	return v
}()

func GetSpecTypeValidator() db.Validator {
	return DefaultGetSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalAccessCheckRequest) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalAccessCheckRequest) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalAccessCheckRequest) DeepCopy() *GlobalAccessCheckRequest {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalAccessCheckRequest{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalAccessCheckRequest) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalAccessCheckRequest) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalAccessCheckRequestValidator().Validate(ctx, m, opts...)
}

type ValidateGlobalAccessCheckRequest struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalAccessCheckRequest) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalAccessCheckRequest) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalAccessCheckRequest) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalAccessCheckRequest)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalAccessCheckRequest got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalAccessCheckRequestValidator = func() *ValidateGlobalAccessCheckRequest {
	v := &ValidateGlobalAccessCheckRequest{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalAccessCheckRequest.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalAccessCheckRequest.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func GlobalAccessCheckRequestValidator() db.Validator {
	return DefaultGlobalAccessCheckRequestValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalAccessCheckResponse) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalAccessCheckResponse) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalAccessCheckResponse) DeepCopy() *GlobalAccessCheckResponse {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalAccessCheckResponse{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalAccessCheckResponse) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalAccessCheckResponse) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalAccessCheckResponseValidator().Validate(ctx, m, opts...)
}

type ValidateGlobalAccessCheckResponse struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalAccessCheckResponse) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalAccessCheckResponse)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalAccessCheckResponse got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("enabled"))
		if err := fv(ctx, m.GetEnabled(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalAccessCheckResponseValidator = func() *ValidateGlobalAccessCheckResponse {
	v := &ValidateGlobalAccessCheckResponse{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func GlobalAccessCheckResponseValidator() db.Validator {
	return DefaultGlobalAccessCheckResponseValidator
}

// augmented methods on protoc/std generated struct

func (m *GlobalSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *GlobalSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *GlobalSpecType) DeepCopy() *GlobalSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &GlobalSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *GlobalSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *GlobalSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return GlobalSpecTypeValidator().Validate(ctx, m, opts...)
}

func (m *GlobalSpecType) GetDRefInfo() ([]db.DRefInfo, error) {
	if m == nil {
		return nil, nil
	}

	var drInfos []db.DRefInfo
	if fdrInfos, err := m.GetConnectedReDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetConnectedReDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetConnectedReForConfigDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetConnectedReForConfigDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	if fdrInfos, err := m.GetK8SClusterApiGwDRefInfo(); err != nil {
		return nil, errors.Wrap(err, "GetK8SClusterApiGwDRefInfo() FAILED")
	} else {
		drInfos = append(drInfos, fdrInfos...)
	}

	return drInfos, nil

}

func (m *GlobalSpecType) GetConnectedReDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetConnectedRe()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.connected_re[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "site.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "connected_re",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetConnectedReDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetConnectedReDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: site")
	}
	for _, ref := range m.GetConnectedRe() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetConnectedReForConfigDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetConnectedReForConfig()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.connected_re_for_config[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "site.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "connected_re_for_config",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetConnectedReForConfigDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetConnectedReForConfigDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "site.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: site")
	}
	for _, ref := range m.GetConnectedReForConfig() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

func (m *GlobalSpecType) GetK8SClusterApiGwDRefInfo() ([]db.DRefInfo, error) {
	refs := m.GetK8SClusterApiGw()
	if len(refs) == 0 {
		return nil, nil
	}
	drInfos := make([]db.DRefInfo, 0, len(refs))
	for i, ref := range refs {
		if ref == nil {
			return nil, fmt.Errorf("GlobalSpecType.k8s_cluster_api_gw[%d] has a nil value", i)
		}
		// resolve kind to type if needed at DBObject.GetDRefInfo()
		drInfos = append(drInfos, db.DRefInfo{
			RefdType:   "virtual_host.Object",
			RefdUID:    ref.Uid,
			RefdTenant: ref.Tenant,
			RefdNS:     ref.Namespace,
			RefdName:   ref.Name,
			DRField:    "k8s_cluster_api_gw",
			Ref:        ref,
		})
	}
	return drInfos, nil

}

// GetK8SClusterApiGwDBEntries returns the db.Entry corresponding to the ObjRefType from the default Table
func (m *GlobalSpecType) GetK8SClusterApiGwDBEntries(ctx context.Context, d db.Interface) ([]db.Entry, error) {
	var entries []db.Entry
	refdType, err := d.TypeForEntryKind("", "", "virtual_host.Object")
	if err != nil {
		return nil, errors.Wrap(err, "Cannot find type for kind: virtual_host")
	}
	for _, ref := range m.GetK8SClusterApiGw() {
		refdEnt, err := d.GetReferredEntry(ctx, refdType, ref, db.WithRefOpOptions(db.OpWithReadRefFromInternalTable()))
		if err != nil {
			return nil, errors.Wrap(err, "Getting referred entry")
		}
		if refdEnt != nil {
			entries = append(entries, refdEnt)
		}
	}

	return entries, nil
}

type ValidateGlobalSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateGlobalSpecType) SiteTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(SiteType)
		return int32(i)
	}
	// SiteType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, SiteType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_type")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) AddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ConnectedReValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for connected_re")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for connected_re")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated connected_re")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items connected_re")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ConnectedReForConfigValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for connected_re_for_config")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for connected_re_for_config")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated connected_re_for_config")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items connected_re_for_config")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) StaticRoutesValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for static_routes")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for static_routes")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated static_routes")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items static_routes")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) PublicIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for public_ip")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ClusterIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for cluster_ip")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) InsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) SiteToSiteTunnelIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_to_site_tunnel_ip")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) BgpRouterIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bgp_router_id")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) BgpPeerAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bgp_peer_address")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) OutsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) SiteToSiteNetworkTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.VirtualNetworkType)
		return int32(i)
	}
	// ves_io_schema.VirtualNetworkType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.VirtualNetworkType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_to_site_network_type")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) InsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) OutsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) DesiredPoolCountValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewInt32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for desired_pool_count")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) TunnelTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.SiteToSiteTunnelType)
		return int32(i)
	}
	// ves_io_schema.SiteToSiteTunnelType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.SiteToSiteTunnelType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_type")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) TunnelDeadTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_dead_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) K8SClusterApiGwValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for k8s_cluster_api_gw")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ves_io_schema.ObjectRefType, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ves_io_schema.ObjectRefTypeValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for k8s_cluster_api_gw")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ves_io_schema.ObjectRefType)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ves_io_schema.ObjectRefType, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated k8s_cluster_api_gw")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items k8s_cluster_api_gw")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) PrivateIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for private_ip")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) IpsecSslVipFqdnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for ipsec_ssl_vip_fqdn")
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) VipParamsPerAzValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for vip_params_per_az")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*PublishVIPParamsPerAz, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := PublishVIPParamsPerAzValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for vip_params_per_az")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*PublishVIPParamsPerAz)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*PublishVIPParamsPerAz, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated vip_params_per_az")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items vip_params_per_az")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) ReMeshGroupValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for re_mesh_group")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*ReMeshGroup, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := ReMeshGroupValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for re_mesh_group")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*ReMeshGroup)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*ReMeshGroup, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated re_mesh_group")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items re_mesh_group")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) SiteToSiteIpsecConnectivityValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepMessageItemRules(rules)
	itemValFn, err := db.NewMessageValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Message ValidationRuleHandler for site_to_site_ipsec_connectivity")
	}
	itemsValidatorFn := func(ctx context.Context, elems []*SiteToSiteTunnelConnectivity, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
			if err := SiteToSiteTunnelConnectivityValidator().Validate(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for site_to_site_ipsec_connectivity")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]*SiteToSiteTunnelConnectivity)
		if !ok {
			return fmt.Errorf("Repeated validation expected []*SiteToSiteTunnelConnectivity, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal, err := codec.ToJSON(elem, codec.ToWithUseProtoFieldName())
			if err != nil {
				return errors.Wrapf(err, "Converting %v to JSON", elem)
			}
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated site_to_site_ipsec_connectivity")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items site_to_site_ipsec_connectivity")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) IpsecSslNodesFqdnValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for ipsec_ssl_nodes_fqdn")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for ipsec_ssl_nodes_fqdn")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated ipsec_ssl_nodes_fqdn")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items ipsec_ssl_nodes_fqdn")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidateGlobalSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*GlobalSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *GlobalSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ares_list"]; exists {

		vOpts := append(opts, db.WithValidateField("ares_list"))
		for idx, item := range m.GetAresList() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["ares_vtrp_list"]; exists {

		vOpts := append(opts, db.WithValidateField("ares_vtrp_list"))
		for idx, item := range m.GetAresVtrpList() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["bgp_peer_address"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_peer_address"))
		if err := fv(ctx, m.GetBgpPeerAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_router_id"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_router_id"))
		if err := fv(ctx, m.GetBgpRouterId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ce_service_labels"]; exists {

		vOpts := append(opts, db.WithValidateField("ce_service_labels"))
		for key, value := range m.GetCeServiceLabels() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["ce_site_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("ce_site_mode"))
		if err := fv(ctx, m.GetCeSiteMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cluster_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("cluster_ip"))
		if err := fv(ctx, m.GetClusterIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["connected_re"]; exists {
		vOpts := append(opts, db.WithValidateField("connected_re"))
		if err := fv(ctx, m.GetConnectedRe(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["connected_re_for_config"]; exists {
		vOpts := append(opts, db.WithValidateField("connected_re_for_config"))
		if err := fv(ctx, m.GetConnectedReForConfig(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["coordinates"]; exists {

		vOpts := append(opts, db.WithValidateField("coordinates"))
		if err := fv(ctx, m.GetCoordinates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_underlay_network"]; exists {

		vOpts := append(opts, db.WithValidateField("default_underlay_network"))
		if err := fv(ctx, m.GetDefaultUnderlayNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["desired_pool_count"]; exists {

		vOpts := append(opts, db.WithValidateField("desired_pool_count"))
		if err := fv(ctx, m.GetDesiredPoolCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["hellas_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("hellas_enabled"))
		if err := fv(ctx, m.GetHellasEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_nameserver"))
		if err := fv(ctx, m.GetInsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_vip"))
		if err := fv(ctx, m.GetInsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ipsec_ssl_nodes_fqdn"]; exists {
		vOpts := append(opts, db.WithValidateField("ipsec_ssl_nodes_fqdn"))
		if err := fv(ctx, m.GetIpsecSslNodesFqdn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ipsec_ssl_vip_fqdn"]; exists {

		vOpts := append(opts, db.WithValidateField("ipsec_ssl_vip_fqdn"))
		if err := fv(ctx, m.GetIpsecSslVipFqdn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["k8s_api_servers"]; exists {

		vOpts := append(opts, db.WithValidateField("k8s_api_servers"))
		for key, value := range m.GetK8SApiServers() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["k8s_cluster_api_gw"]; exists {
		vOpts := append(opts, db.WithValidateField("k8s_cluster_api_gw"))
		if err := fv(ctx, m.GetK8SClusterApiGw(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["launch_ike_in_namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("launch_ike_in_namespace"))
		if err := fv(ctx, m.GetLaunchIkeInNamespace(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["local_control_plane_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("local_control_plane_enabled"))
		if err := fv(ctx, m.GetLocalControlPlaneEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["local_k8s_access_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("local_k8s_access_enabled"))
		if err := fv(ctx, m.GetLocalK8SAccessEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["main_nodes"]; exists {

		vOpts := append(opts, db.WithValidateField("main_nodes"))
		for idx, item := range m.GetMainNodes() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["mars_list"]; exists {

		vOpts := append(opts, db.WithValidateField("mars_list"))
		for idx, item := range m.GetMarsList() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["mars_vtrp_list"]; exists {

		vOpts := append(opts, db.WithValidateField("mars_vtrp_list"))
		for idx, item := range m.GetMarsVtrpList() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["multus_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("multus_enabled"))
		if err := fv(ctx, m.GetMultusEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["no_tenant_in_vk8s_ns"]; exists {

		vOpts := append(opts, db.WithValidateField("no_tenant_in_vk8s_ns"))
		if err := fv(ctx, m.GetNoTenantInVk8SNs(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["obelix"]; exists {

		vOpts := append(opts, db.WithValidateField("obelix"))
		if err := fv(ctx, m.GetObelix(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["opera"]; exists {

		vOpts := append(opts, db.WithValidateField("opera"))
		if err := fv(ctx, m.GetOpera(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operating_system_version"]; exists {

		vOpts := append(opts, db.WithValidateField("operating_system_version"))
		if err := fv(ctx, m.GetOperatingSystemVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_nameserver"))
		if err := fv(ctx, m.GetOutsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_vip"))
		if err := fv(ctx, m.GetOutsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["phobos_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("phobos_enabled"))
		if err := fv(ctx, m.GetPhobosEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["phobos_list"]; exists {

		vOpts := append(opts, db.WithValidateField("phobos_list"))
		for idx, item := range m.GetPhobosList() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["piku_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("piku_enabled"))
		if err := fv(ctx, m.GetPikuEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["private_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("private_ip"))
		if err := fv(ctx, m.GetPrivateIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["public_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("public_ip"))
		if err := fv(ctx, m.GetPublicIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["rakar"]; exists {

		vOpts := append(opts, db.WithValidateField("rakar"))
		if err := fv(ctx, m.GetRakar(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["re_mesh_group"]; exists {
		vOpts := append(opts, db.WithValidateField("re_mesh_group"))
		if err := fv(ctx, m.GetReMeshGroup(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["region"]; exists {

		vOpts := append(opts, db.WithValidateField("region"))
		if err := fv(ctx, m.GetRegion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_state"]; exists {

		vOpts := append(opts, db.WithValidateField("site_state"))
		if err := fv(ctx, m.GetSiteState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_subtype"]; exists {

		vOpts := append(opts, db.WithValidateField("site_subtype"))
		if err := fv(ctx, m.GetSiteSubtype(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_ipsec_connectivity"]; exists {
		vOpts := append(opts, db.WithValidateField("site_to_site_ipsec_connectivity"))
		if err := fv(ctx, m.GetSiteToSiteIpsecConnectivity(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_network_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_network_type"))
		if err := fv(ctx, m.GetSiteToSiteNetworkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_tunnel_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_tunnel_ip"))
		if err := fv(ctx, m.GetSiteToSiteTunnelIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_type"))
		if err := fv(ctx, m.GetSiteType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["srv6_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("srv6_enabled"))
		if err := fv(ctx, m.GetSrv6Enabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["static_routes"]; exists {
		vOpts := append(opts, db.WithValidateField("static_routes"))
		if err := fv(ctx, m.GetStaticRoutes(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["template_parameters"]; exists {

		vOpts := append(opts, db.WithValidateField("template_parameters"))
		for key, value := range m.GetTemplateParameters() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["tenant_index"]; exists {

		vOpts := append(opts, db.WithValidateField("tenant_index"))
		if err := fv(ctx, m.GetTenantIndex(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_dead_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_dead_timeout"))
		if err := fv(ctx, m.GetTunnelDeadTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_type"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_type"))
		if err := fv(ctx, m.GetTunnelType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["use_private_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("use_private_ip"))
		if err := fv(ctx, m.GetUsePrivateIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vega"]; exists {

		vOpts := append(opts, db.WithValidateField("vega"))
		if err := fv(ctx, m.GetVega(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vega_cfg"]; exists {

		vOpts := append(opts, db.WithValidateField("vega_cfg"))
		if err := fv(ctx, m.GetVegaCfg(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vip_params_per_az"]; exists {
		vOpts := append(opts, db.WithValidateField("vip_params_per_az"))
		if err := fv(ctx, m.GetVipParamsPerAz(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vip_vrrp_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("vip_vrrp_mode"))
		if err := fv(ctx, m.GetVipVrrpMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vm_enabled"]; exists {

		vOpts := append(opts, db.WithValidateField("vm_enabled"))
		if err := fv(ctx, m.GetVmEnabled(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_overide"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_overide"))
		if err := fv(ctx, m.GetVolterraSoftwareOveride(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_version"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_version"))
		if err := fv(ctx, m.GetVolterraSoftwareVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultGlobalSpecTypeValidator = func() *ValidateGlobalSpecType {
	v := &ValidateGlobalSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSiteType := v.SiteTypeValidationRuleHandler
	rulesSiteType := map[string]string{
		"ves.io.schema.rules.enum.not_in": "0",
	}
	vFn, err = vrhSiteType(rulesSiteType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.site_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_type"] = vFn

	vrhAddress := v.AddressValidationRuleHandler
	rulesAddress := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhAddress(rulesAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address"] = vFn

	vrhConnectedRe := v.ConnectedReValidationRuleHandler
	rulesConnectedRe := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhConnectedRe(rulesConnectedRe)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.connected_re: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connected_re"] = vFn

	vrhConnectedReForConfig := v.ConnectedReForConfigValidationRuleHandler
	rulesConnectedReForConfig := map[string]string{
		"ves.io.schema.rules.message.required": "true",
	}
	vFn, err = vrhConnectedReForConfig(rulesConnectedReForConfig)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.connected_re_for_config: %s", err)
		panic(errMsg)
	}
	v.FldValidators["connected_re_for_config"] = vFn

	vrhStaticRoutes := v.StaticRoutesValidationRuleHandler
	rulesStaticRoutes := map[string]string{
		"ves.io.schema.rules.message.required":                  "true",
		"ves.io.schema.rules.repeated.items.string.ipv4_prefix": "true",
	}
	vFn, err = vrhStaticRoutes(rulesStaticRoutes)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.static_routes: %s", err)
		panic(errMsg)
	}
	v.FldValidators["static_routes"] = vFn

	vrhPublicIp := v.PublicIpValidationRuleHandler
	rulesPublicIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhPublicIp(rulesPublicIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.public_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["public_ip"] = vFn

	vrhClusterIp := v.ClusterIpValidationRuleHandler
	rulesClusterIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhClusterIp(rulesClusterIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.cluster_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["cluster_ip"] = vFn

	vrhInsideVip := v.InsideVipValidationRuleHandler
	rulesInsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideVip(rulesInsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.inside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_vip"] = vFn

	vrhSiteToSiteTunnelIp := v.SiteToSiteTunnelIpValidationRuleHandler
	rulesSiteToSiteTunnelIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhSiteToSiteTunnelIp(rulesSiteToSiteTunnelIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.site_to_site_tunnel_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_to_site_tunnel_ip"] = vFn

	vrhBgpRouterId := v.BgpRouterIdValidationRuleHandler
	rulesBgpRouterId := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhBgpRouterId(rulesBgpRouterId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.bgp_router_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bgp_router_id"] = vFn

	vrhBgpPeerAddress := v.BgpPeerAddressValidationRuleHandler
	rulesBgpPeerAddress := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhBgpPeerAddress(rulesBgpPeerAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.bgp_peer_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bgp_peer_address"] = vFn

	vrhOutsideVip := v.OutsideVipValidationRuleHandler
	rulesOutsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhOutsideVip(rulesOutsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.outside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_vip"] = vFn

	vrhSiteToSiteNetworkType := v.SiteToSiteNetworkTypeValidationRuleHandler
	rulesSiteToSiteNetworkType := map[string]string{
		"ves.io.schema.rules.enum.in": "[0,1]",
	}
	vFn, err = vrhSiteToSiteNetworkType(rulesSiteToSiteNetworkType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.site_to_site_network_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_to_site_network_type"] = vFn

	vrhInsideNameserver := v.InsideNameserverValidationRuleHandler
	rulesInsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideNameserver(rulesInsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.inside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_nameserver"] = vFn

	vrhOutsideNameserver := v.OutsideNameserverValidationRuleHandler
	rulesOutsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhOutsideNameserver(rulesOutsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.outside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_nameserver"] = vFn

	vrhDesiredPoolCount := v.DesiredPoolCountValidationRuleHandler
	rulesDesiredPoolCount := map[string]string{
		"ves.io.schema.rules.int32.gte": "-1",
		"ves.io.schema.rules.int32.lte": "64",
	}
	vFn, err = vrhDesiredPoolCount(rulesDesiredPoolCount)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.desired_pool_count: %s", err)
		panic(errMsg)
	}
	v.FldValidators["desired_pool_count"] = vFn

	vrhTunnelType := v.TunnelTypeValidationRuleHandler
	rulesTunnelType := map[string]string{
		"ves.io.schema.rules.enum.in": "[0,1,2]",
	}
	vFn, err = vrhTunnelType(rulesTunnelType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.tunnel_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_type"] = vFn

	vrhTunnelDeadTimeout := v.TunnelDeadTimeoutValidationRuleHandler
	rulesTunnelDeadTimeout := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "180000",
	}
	vFn, err = vrhTunnelDeadTimeout(rulesTunnelDeadTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.tunnel_dead_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_dead_timeout"] = vFn

	vrhK8SClusterApiGw := v.K8SClusterApiGwValidationRuleHandler
	rulesK8SClusterApiGw := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "1",
	}
	vFn, err = vrhK8SClusterApiGw(rulesK8SClusterApiGw)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.k8s_cluster_api_gw: %s", err)
		panic(errMsg)
	}
	v.FldValidators["k8s_cluster_api_gw"] = vFn

	vrhPrivateIp := v.PrivateIpValidationRuleHandler
	rulesPrivateIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhPrivateIp(rulesPrivateIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.private_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["private_ip"] = vFn

	vrhIpsecSslVipFqdn := v.IpsecSslVipFqdnValidationRuleHandler
	rulesIpsecSslVipFqdn := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
	}
	vFn, err = vrhIpsecSslVipFqdn(rulesIpsecSslVipFqdn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.ipsec_ssl_vip_fqdn: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ipsec_ssl_vip_fqdn"] = vFn

	vrhVipParamsPerAz := v.VipParamsPerAzValidationRuleHandler
	rulesVipParamsPerAz := map[string]string{
		"ves.io.schema.rules.repeated.num_items": "0,1,2,3",
	}
	vFn, err = vrhVipParamsPerAz(rulesVipParamsPerAz)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.vip_params_per_az: %s", err)
		panic(errMsg)
	}
	v.FldValidators["vip_params_per_az"] = vFn

	vrhReMeshGroup := v.ReMeshGroupValidationRuleHandler
	rulesReMeshGroup := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "2",
	}
	vFn, err = vrhReMeshGroup(rulesReMeshGroup)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.re_mesh_group: %s", err)
		panic(errMsg)
	}
	v.FldValidators["re_mesh_group"] = vFn

	vrhSiteToSiteIpsecConnectivity := v.SiteToSiteIpsecConnectivityValidationRuleHandler
	rulesSiteToSiteIpsecConnectivity := map[string]string{
		"ves.io.schema.rules.repeated.max_items": "3",
	}
	vFn, err = vrhSiteToSiteIpsecConnectivity(rulesSiteToSiteIpsecConnectivity)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.site_to_site_ipsec_connectivity: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_to_site_ipsec_connectivity"] = vFn

	vrhIpsecSslNodesFqdn := v.IpsecSslNodesFqdnValidationRuleHandler
	rulesIpsecSslNodesFqdn := map[string]string{
		"ves.io.schema.rules.string.hostname": "true",
	}
	vFn, err = vrhIpsecSslNodesFqdn(rulesIpsecSslNodesFqdn)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for GlobalSpecType.ipsec_ssl_nodes_fqdn: %s", err)
		panic(errMsg)
	}
	v.FldValidators["ipsec_ssl_nodes_fqdn"] = vFn

	v.FldValidators["coordinates"] = CoordinatesValidator().Validate

	v.FldValidators["default_underlay_network"] = DefaultUnderlayNetworkTypeValidator().Validate

	return v
}()

func GlobalSpecTypeValidator() db.Validator {
	return DefaultGlobalSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *InterfaceStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *InterfaceStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *InterfaceStatus) DeepCopy() *InterfaceStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &InterfaceStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *InterfaceStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *InterfaceStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return InterfaceStatusValidator().Validate(ctx, m, opts...)
}

type ValidateInterfaceStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateInterfaceStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*InterfaceStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *InterfaceStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["active_state"]; exists {

		vOpts := append(opts, db.WithValidateField("active_state"))
		if err := fv(ctx, m.GetActiveState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bond_members"]; exists {

		vOpts := append(opts, db.WithValidateField("bond_members"))
		for idx, item := range m.GetBondMembers() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["dhcp_server"]; exists {

		vOpts := append(opts, db.WithValidateField("dhcp_server"))
		if err := fv(ctx, m.GetDhcpServer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip"]; exists {

		vOpts := append(opts, db.WithValidateField("ip"))
		if err := fv(ctx, m.GetIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("ip_mode"))
		if err := fv(ctx, m.GetIpMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ipv6"]; exists {

		vOpts := append(opts, db.WithValidateField("ipv6"))
		if err := fv(ctx, m.GetIpv6(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["link_quality"]; exists {

		vOpts := append(opts, db.WithValidateField("link_quality"))
		if err := fv(ctx, m.GetLinkQuality(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["link_state"]; exists {

		vOpts := append(opts, db.WithValidateField("link_state"))
		if err := fv(ctx, m.GetLinkState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["link_type"]; exists {

		vOpts := append(opts, db.WithValidateField("link_type"))
		if err := fv(ctx, m.GetLinkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mac"]; exists {

		vOpts := append(opts, db.WithValidateField("mac"))
		if err := fv(ctx, m.GetMac(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_name"]; exists {

		vOpts := append(opts, db.WithValidateField("network_name"))
		if err := fv(ctx, m.GetNetworkName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network_type"]; exists {

		vOpts := append(opts, db.WithValidateField("network_type"))
		if err := fv(ctx, m.GetNetworkType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultInterfaceStatusValidator = func() *ValidateInterfaceStatus {
	v := &ValidateInterfaceStatus{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["ip"] = ves_io_schema.IpSubnetTypeValidator().Validate

	v.FldValidators["ipv6"] = ves_io_schema.IpSubnetTypeValidator().Validate

	return v
}()

func InterfaceStatusValidator() db.Validator {
	return DefaultInterfaceStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *K8SApiServerParameters) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *K8SApiServerParameters) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *K8SApiServerParameters) DeepCopy() *K8SApiServerParameters {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &K8SApiServerParameters{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *K8SApiServerParameters) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *K8SApiServerParameters) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return K8SApiServerParametersValidator().Validate(ctx, m, opts...)
}

type ValidateK8SApiServerParameters struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateK8SApiServerParameters) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*K8SApiServerParameters)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *K8SApiServerParameters got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultK8SApiServerParametersValidator = func() *ValidateK8SApiServerParameters {
	v := &ValidateK8SApiServerParameters{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func K8SApiServerParametersValidator() db.Validator {
	return DefaultK8SApiServerParametersValidator
}

// augmented methods on protoc/std generated struct

func (m *Kernel) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Kernel) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Kernel) DeepCopy() *Kernel {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Kernel{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Kernel) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Kernel) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return KernelValidator().Validate(ctx, m, opts...)
}

type ValidateKernel struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateKernel) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Kernel)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Kernel got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["architecture"]; exists {

		vOpts := append(opts, db.WithValidateField("architecture"))
		if err := fv(ctx, m.GetArchitecture(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["release"]; exists {

		vOpts := append(opts, db.WithValidateField("release"))
		if err := fv(ctx, m.GetRelease(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultKernelValidator = func() *ValidateKernel {
	v := &ValidateKernel{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func KernelValidator() db.Validator {
	return DefaultKernelValidator
}

// augmented methods on protoc/std generated struct

func (m *KubeConfigStatusRsp) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *KubeConfigStatusRsp) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *KubeConfigStatusRsp) DeepCopy() *KubeConfigStatusRsp {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &KubeConfigStatusRsp{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *KubeConfigStatusRsp) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *KubeConfigStatusRsp) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return KubeConfigStatusRspValidator().Validate(ctx, m, opts...)
}

type ValidateKubeConfigStatusRsp struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateKubeConfigStatusRsp) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*KubeConfigStatusRsp)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *KubeConfigStatusRsp got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["status"]; exists {

		vOpts := append(opts, db.WithValidateField("status"))
		if err := fv(ctx, m.GetStatus(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultKubeConfigStatusRspValidator = func() *ValidateKubeConfigStatusRsp {
	v := &ValidateKubeConfigStatusRsp{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func KubeConfigStatusRspValidator() db.Validator {
	return DefaultKubeConfigStatusRspValidator
}

// augmented methods on protoc/std generated struct

func (m *ListGlobalKubeConfigReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListGlobalKubeConfigReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListGlobalKubeConfigReq) DeepCopy() *ListGlobalKubeConfigReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListGlobalKubeConfigReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListGlobalKubeConfigReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListGlobalKubeConfigReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListGlobalKubeConfigReqValidator().Validate(ctx, m, opts...)
}

type ValidateListGlobalKubeConfigReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListGlobalKubeConfigReq) SiteValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site")
	}

	return validatorFn, nil
}

func (v *ValidateListGlobalKubeConfigReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListGlobalKubeConfigReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListGlobalKubeConfigReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["site"]; exists {

		vOpts := append(opts, db.WithValidateField("site"))
		if err := fv(ctx, m.GetSite(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListGlobalKubeConfigReqValidator = func() *ValidateListGlobalKubeConfigReq {
	v := &ValidateListGlobalKubeConfigReq{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhSite := v.SiteValidationRuleHandler
	rulesSite := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhSite(rulesSite)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListGlobalKubeConfigReq.site: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site"] = vFn

	return v
}()

func ListGlobalKubeConfigReqValidator() db.Validator {
	return DefaultListGlobalKubeConfigReqValidator
}

// augmented methods on protoc/std generated struct

func (m *ListKubeConfigReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListKubeConfigReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListKubeConfigReq) DeepCopy() *ListKubeConfigReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListKubeConfigReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListKubeConfigReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListKubeConfigReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListKubeConfigReqValidator().Validate(ctx, m, opts...)
}

type ValidateListKubeConfigReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListKubeConfigReq) NamespaceValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for namespace")
	}

	return validatorFn, nil
}

func (v *ValidateListKubeConfigReq) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateListKubeConfigReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListKubeConfigReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListKubeConfigReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["namespace"]; exists {

		vOpts := append(opts, db.WithValidateField("namespace"))
		if err := fv(ctx, m.GetNamespace(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListKubeConfigReqValidator = func() *ValidateListKubeConfigReq {
	v := &ValidateListKubeConfigReq{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNamespace := v.NamespaceValidationRuleHandler
	rulesNamespace := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhNamespace(rulesNamespace)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListKubeConfigReq.namespace: %s", err)
		panic(errMsg)
	}
	v.FldValidators["namespace"] = vFn

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListKubeConfigReq.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func ListKubeConfigReqValidator() db.Validator {
	return DefaultListKubeConfigReqValidator
}

// augmented methods on protoc/std generated struct

func (m *ListKubeConfigRsp) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListKubeConfigRsp) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListKubeConfigRsp) DeepCopy() *ListKubeConfigRsp {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListKubeConfigRsp{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListKubeConfigRsp) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListKubeConfigRsp) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListKubeConfigRspValidator().Validate(ctx, m, opts...)
}

type ValidateListKubeConfigRsp struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListKubeConfigRsp) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListKubeConfigRsp)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListKubeConfigRsp got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["items"]; exists {

		vOpts := append(opts, db.WithValidateField("items"))
		for idx, item := range m.GetItems() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListKubeConfigRspValidator = func() *ValidateListKubeConfigRsp {
	v := &ValidateListKubeConfigRsp{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["items"] = ListKubeConfigRspItemValidator().Validate

	return v
}()

func ListKubeConfigRspValidator() db.Validator {
	return DefaultListKubeConfigRspValidator
}

// augmented methods on protoc/std generated struct

func (m *ListKubeConfigRspItem) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ListKubeConfigRspItem) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ListKubeConfigRspItem) DeepCopy() *ListKubeConfigRspItem {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ListKubeConfigRspItem{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ListKubeConfigRspItem) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ListKubeConfigRspItem) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ListKubeConfigRspItemValidator().Validate(ctx, m, opts...)
}

type ValidateListKubeConfigRspItem struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateListKubeConfigRspItem) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateListKubeConfigRspItem) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ListKubeConfigRspItem)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ListKubeConfigRspItem got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["create_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("create_timestamp"))
		if err := fv(ctx, m.GetCreateTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["expiry_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("expiry_timestamp"))
		if err := fv(ctx, m.GetExpiryTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["uid"]; exists {

		vOpts := append(opts, db.WithValidateField("uid"))
		if err := fv(ctx, m.GetUid(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["user_email"]; exists {

		vOpts := append(opts, db.WithValidateField("user_email"))
		if err := fv(ctx, m.GetUserEmail(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultListKubeConfigRspItemValidator = func() *ValidateListKubeConfigRspItem {
	v := &ValidateListKubeConfigRspItem{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ListKubeConfigRspItem.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func ListKubeConfigRspItemValidator() db.Validator {
	return DefaultListKubeConfigRspItemValidator
}

// augmented methods on protoc/std generated struct

func (m *Memory) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Memory) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Memory) DeepCopy() *Memory {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Memory{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Memory) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Memory) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return MemoryValidator().Validate(ctx, m, opts...)
}

type ValidateMemory struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateMemory) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Memory)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Memory got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["size_mb"]; exists {

		vOpts := append(opts, db.WithValidateField("size_mb"))
		if err := fv(ctx, m.GetSizeMb(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["speed"]; exists {

		vOpts := append(opts, db.WithValidateField("speed"))
		if err := fv(ctx, m.GetSpeed(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["type"]; exists {

		vOpts := append(opts, db.WithValidateField("type"))
		if err := fv(ctx, m.GetType(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultMemoryValidator = func() *ValidateMemory {
	v := &ValidateMemory{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func MemoryValidator() db.Validator {
	return DefaultMemoryValidator
}

// augmented methods on protoc/std generated struct

func (m *NetworkDevice) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NetworkDevice) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NetworkDevice) DeepCopy() *NetworkDevice {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NetworkDevice{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NetworkDevice) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NetworkDevice) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NetworkDeviceValidator().Validate(ctx, m, opts...)
}

type ValidateNetworkDevice struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNetworkDevice) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NetworkDevice)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NetworkDevice got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["driver"]; exists {

		vOpts := append(opts, db.WithValidateField("driver"))
		if err := fv(ctx, m.GetDriver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ip_address"]; exists {

		vOpts := append(opts, db.WithValidateField("ip_address"))
		for idx, item := range m.GetIpAddress() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["link_quality"]; exists {

		vOpts := append(opts, db.WithValidateField("link_quality"))
		if err := fv(ctx, m.GetLinkQuality(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["link_type"]; exists {

		vOpts := append(opts, db.WithValidateField("link_type"))
		if err := fv(ctx, m.GetLinkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["mac_address"]; exists {

		vOpts := append(opts, db.WithValidateField("mac_address"))
		if err := fv(ctx, m.GetMacAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["port"]; exists {

		vOpts := append(opts, db.WithValidateField("port"))
		if err := fv(ctx, m.GetPort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["speed"]; exists {

		vOpts := append(opts, db.WithValidateField("speed"))
		if err := fv(ctx, m.GetSpeed(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNetworkDeviceValidator = func() *ValidateNetworkDevice {
	v := &ValidateNetworkDevice{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func NetworkDeviceValidator() db.Validator {
	return DefaultNetworkDeviceValidator
}

// augmented methods on protoc/std generated struct

func (m *Node) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Node) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Node) DeepCopy() *Node {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Node{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Node) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Node) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NodeValidator().Validate(ctx, m, opts...)
}

type ValidateNode struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNode) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Node)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Node got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["sli_address"]; exists {

		vOpts := append(opts, db.WithValidateField("sli_address"))
		if err := fv(ctx, m.GetSliAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["slo_address"]; exists {

		vOpts := append(opts, db.WithValidateField("slo_address"))
		if err := fv(ctx, m.GetSloAddress(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNodeValidator = func() *ValidateNode {
	v := &ValidateNode{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func NodeValidator() db.Validator {
	return DefaultNodeValidator
}

// augmented methods on protoc/std generated struct

func (m *NodeInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *NodeInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *NodeInfo) DeepCopy() *NodeInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &NodeInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *NodeInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *NodeInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return NodeInfoValidator().Validate(ctx, m, opts...)
}

type ValidateNodeInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateNodeInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*NodeInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *NodeInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["hostname"]; exists {

		vOpts := append(opts, db.WithValidateField("hostname"))
		if err := fv(ctx, m.GetHostname(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["role"]; exists {

		vOpts := append(opts, db.WithValidateField("role"))
		for idx, item := range m.GetRole() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultNodeInfoValidator = func() *ValidateNodeInfo {
	v := &ValidateNodeInfo{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func NodeInfoValidator() db.Validator {
	return DefaultNodeInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *OS) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OS) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OS) DeepCopy() *OS {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OS{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OS) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OS) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OSValidator().Validate(ctx, m, opts...)
}

type ValidateOS struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOS) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OS)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OS got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["architecture"]; exists {

		vOpts := append(opts, db.WithValidateField("architecture"))
		if err := fv(ctx, m.GetArchitecture(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["release"]; exists {

		vOpts := append(opts, db.WithValidateField("release"))
		if err := fv(ctx, m.GetRelease(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vendor"]; exists {

		vOpts := append(opts, db.WithValidateField("vendor"))
		if err := fv(ctx, m.GetVendor(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOSValidator = func() *ValidateOS {
	v := &ValidateOS{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func OSValidator() db.Validator {
	return DefaultOSValidator
}

// augmented methods on protoc/std generated struct

func (m *OperatingSystemStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OperatingSystemStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OperatingSystemStatus) DeepCopy() *OperatingSystemStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OperatingSystemStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OperatingSystemStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OperatingSystemStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OperatingSystemStatusValidator().Validate(ctx, m, opts...)
}

type ValidateOperatingSystemStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOperatingSystemStatus) NonconformingStateValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for nonconforming_state")
	}

	return validatorFn, nil
}

func (v *ValidateOperatingSystemStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OperatingSystemStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OperatingSystemStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["available_version"]; exists {

		vOpts := append(opts, db.WithValidateField("available_version"))
		if err := fv(ctx, m.GetAvailableVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["deployment_state"]; exists {

		vOpts := append(opts, db.WithValidateField("deployment_state"))
		if err := fv(ctx, m.GetDeploymentState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["nonconforming_state"]; exists {

		vOpts := append(opts, db.WithValidateField("nonconforming_state"))
		if err := fv(ctx, m.GetNonconformingState(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOperatingSystemStatusValidator = func() *ValidateOperatingSystemStatus {
	v := &ValidateOperatingSystemStatus{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNonconformingState := v.NonconformingStateValidationRuleHandler
	rulesNonconformingState := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhNonconformingState(rulesNonconformingState)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for OperatingSystemStatus.nonconforming_state: %s", err)
		panic(errMsg)
	}
	v.FldValidators["nonconforming_state"] = vFn

	return v
}()

func OperatingSystemStatusValidator() db.Validator {
	return DefaultOperatingSystemStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *OsInfo) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *OsInfo) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *OsInfo) DeepCopy() *OsInfo {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &OsInfo{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *OsInfo) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *OsInfo) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return OsInfoValidator().Validate(ctx, m, opts...)
}

type ValidateOsInfo struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateOsInfo) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*OsInfo)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *OsInfo got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["bios"]; exists {

		vOpts := append(opts, db.WithValidateField("bios"))
		if err := fv(ctx, m.GetBios(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["board"]; exists {

		vOpts := append(opts, db.WithValidateField("board"))
		if err := fv(ctx, m.GetBoard(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["chassis"]; exists {

		vOpts := append(opts, db.WithValidateField("chassis"))
		if err := fv(ctx, m.GetChassis(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["cpu"]; exists {

		vOpts := append(opts, db.WithValidateField("cpu"))
		if err := fv(ctx, m.GetCpu(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["gpu"]; exists {

		vOpts := append(opts, db.WithValidateField("gpu"))
		if err := fv(ctx, m.GetGpu(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["kernel"]; exists {

		vOpts := append(opts, db.WithValidateField("kernel"))
		if err := fv(ctx, m.GetKernel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["memory"]; exists {

		vOpts := append(opts, db.WithValidateField("memory"))
		if err := fv(ctx, m.GetMemory(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["network"]; exists {

		vOpts := append(opts, db.WithValidateField("network"))
		for idx, item := range m.GetNetwork() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["os"]; exists {

		vOpts := append(opts, db.WithValidateField("os"))
		if err := fv(ctx, m.GetOs(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["product"]; exists {

		vOpts := append(opts, db.WithValidateField("product"))
		if err := fv(ctx, m.GetProduct(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["storage"]; exists {

		vOpts := append(opts, db.WithValidateField("storage"))
		for idx, item := range m.GetStorage() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["usb"]; exists {

		vOpts := append(opts, db.WithValidateField("usb"))
		for idx, item := range m.GetUsb() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultOsInfoValidator = func() *ValidateOsInfo {
	v := &ValidateOsInfo{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func OsInfoValidator() db.Validator {
	return DefaultOsInfoValidator
}

// augmented methods on protoc/std generated struct

func (m *Product) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *Product) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *Product) DeepCopy() *Product {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &Product{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *Product) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *Product) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ProductValidator().Validate(ctx, m, opts...)
}

type ValidateProduct struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateProduct) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*Product)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *Product got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["serial"]; exists {

		vOpts := append(opts, db.WithValidateField("serial"))
		if err := fv(ctx, m.GetSerial(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vendor"]; exists {

		vOpts := append(opts, db.WithValidateField("vendor"))
		if err := fv(ctx, m.GetVendor(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["version"]; exists {

		vOpts := append(opts, db.WithValidateField("version"))
		if err := fv(ctx, m.GetVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultProductValidator = func() *ValidateProduct {
	v := &ValidateProduct{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ProductValidator() db.Validator {
	return DefaultProductValidator
}

// augmented methods on protoc/std generated struct

func (m *PublishVIPParamsPerAz) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *PublishVIPParamsPerAz) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *PublishVIPParamsPerAz) DeepCopy() *PublishVIPParamsPerAz {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &PublishVIPParamsPerAz{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *PublishVIPParamsPerAz) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *PublishVIPParamsPerAz) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return PublishVIPParamsPerAzValidator().Validate(ctx, m, opts...)
}

type ValidatePublishVIPParamsPerAz struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidatePublishVIPParamsPerAz) InsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for inside_vip")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for inside_vip")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated inside_vip")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items inside_vip")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePublishVIPParamsPerAz) OutsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	itemRules := db.GetRepStringItemRules(rules)
	itemValFn, err := db.NewStringValidationRuleHandler(itemRules)
	if err != nil {
		return nil, errors.Wrap(err, "Item ValidationRuleHandler for outside_vip")
	}
	itemsValidatorFn := func(ctx context.Context, elems []string, opts ...db.ValidateOpt) error {
		for i, el := range elems {
			if err := itemValFn(ctx, el, opts...); err != nil {
				return errors.Wrap(err, fmt.Sprintf("element %d", i))
			}
		}
		return nil
	}
	repValFn, err := db.NewRepeatedValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "Repeated ValidationRuleHandler for outside_vip")
	}

	validatorFn := func(ctx context.Context, val interface{}, opts ...db.ValidateOpt) error {
		elems, ok := val.([]string)
		if !ok {
			return fmt.Errorf("Repeated validation expected []string, got %T", val)
		}
		l := []string{}
		for _, elem := range elems {
			strVal := fmt.Sprintf("%v", elem)
			l = append(l, strVal)
		}
		if err := repValFn(ctx, l, opts...); err != nil {
			return errors.Wrap(err, "repeated outside_vip")
		}
		if err := itemsValidatorFn(ctx, elems, opts...); err != nil {
			return errors.Wrap(err, "items outside_vip")
		}
		return nil
	}

	return validatorFn, nil
}

func (v *ValidatePublishVIPParamsPerAz) OutsideVipCnameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_vip_cname")
	}

	return validatorFn, nil
}

func (v *ValidatePublishVIPParamsPerAz) InsideVipCnameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_vip_cname")
	}

	return validatorFn, nil
}

func (v *ValidatePublishVIPParamsPerAz) AzNameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for az_name")
	}

	return validatorFn, nil
}

func (v *ValidatePublishVIPParamsPerAz) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*PublishVIPParamsPerAz)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *PublishVIPParamsPerAz got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["az_name"]; exists {

		vOpts := append(opts, db.WithValidateField("az_name"))
		if err := fv(ctx, m.GetAzName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_vip"]; exists {
		vOpts := append(opts, db.WithValidateField("inside_vip"))
		if err := fv(ctx, m.GetInsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_vip_cname"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_vip_cname"))
		if err := fv(ctx, m.GetInsideVipCname(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_vip"]; exists {
		vOpts := append(opts, db.WithValidateField("outside_vip"))
		if err := fv(ctx, m.GetOutsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_vip_cname"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_vip_cname"))
		if err := fv(ctx, m.GetOutsideVipCname(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultPublishVIPParamsPerAzValidator = func() *ValidatePublishVIPParamsPerAz {
	v := &ValidatePublishVIPParamsPerAz{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhInsideVip := v.InsideVipValidationRuleHandler
	rulesInsideVip := map[string]string{
		"ves.io.schema.rules.repeated.items.string.ipv4": "true",
		"ves.io.schema.rules.repeated.max_items":         "3",
		"ves.io.schema.rules.repeated.unique":            "true",
	}
	vFn, err = vrhInsideVip(rulesInsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PublishVIPParamsPerAz.inside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_vip"] = vFn

	vrhOutsideVip := v.OutsideVipValidationRuleHandler
	rulesOutsideVip := map[string]string{
		"ves.io.schema.rules.message.required":           "true",
		"ves.io.schema.rules.repeated.items.string.ipv4": "true",
		"ves.io.schema.rules.repeated.max_items":         "3",
		"ves.io.schema.rules.repeated.min_items":         "1",
		"ves.io.schema.rules.repeated.unique":            "true",
	}
	vFn, err = vrhOutsideVip(rulesOutsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PublishVIPParamsPerAz.outside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_vip"] = vFn

	vrhOutsideVipCname := v.OutsideVipCnameValidationRuleHandler
	rulesOutsideVipCname := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhOutsideVipCname(rulesOutsideVipCname)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PublishVIPParamsPerAz.outside_vip_cname: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_vip_cname"] = vFn

	vrhInsideVipCname := v.InsideVipCnameValidationRuleHandler
	rulesInsideVipCname := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhInsideVipCname(rulesInsideVipCname)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PublishVIPParamsPerAz.inside_vip_cname: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_vip_cname"] = vFn

	vrhAzName := v.AzNameValidationRuleHandler
	rulesAzName := map[string]string{
		"ves.io.schema.rules.string.pattern": "^[1-5]{1}$|^AzureAlternateRegion$|^[a-z]{2}-[a-z0-9]{4,20}-[a-z0-9]{2}$|^[a-z]{4,15}-[a-z0-9]{4,20}-[a-z]{1}$",
	}
	vFn, err = vrhAzName(rulesAzName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for PublishVIPParamsPerAz.az_name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["az_name"] = vFn

	return v
}()

func PublishVIPParamsPerAzValidator() db.Validator {
	return DefaultPublishVIPParamsPerAzValidator
}

// augmented methods on protoc/std generated struct

func (m *ReMeshGroup) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReMeshGroup) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReMeshGroup) DeepCopy() *ReMeshGroup {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReMeshGroup{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReMeshGroup) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReMeshGroup) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReMeshGroupValidator().Validate(ctx, m, opts...)
}

type ValidateReMeshGroup struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReMeshGroup) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReMeshGroup)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReMeshGroup got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	switch m.GetType().(type) {
	case *ReMeshGroup_IpsecGroup:
		if fv, exists := v.FldValidators["type.ipsec_group"]; exists {
			val := m.GetType().(*ReMeshGroup_IpsecGroup).IpsecGroup
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("ipsec_group"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}
	case *ReMeshGroup_L3VpnGroup:
		if fv, exists := v.FldValidators["type.l3vpn_group"]; exists {
			val := m.GetType().(*ReMeshGroup_L3VpnGroup).L3VpnGroup
			vOpts := append(opts,
				db.WithValidateField("type"),
				db.WithValidateField("l3vpn_group"),
			)
			if err := fv(ctx, val, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReMeshGroupValidator = func() *ValidateReMeshGroup {
	v := &ValidateReMeshGroup{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ReMeshGroupValidator() db.Validator {
	return DefaultReMeshGroupValidator
}

// augmented methods on protoc/std generated struct

func (m *ReplaceSpecType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ReplaceSpecType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ReplaceSpecType) DeepCopy() *ReplaceSpecType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ReplaceSpecType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ReplaceSpecType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ReplaceSpecType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ReplaceSpecTypeValidator().Validate(ctx, m, opts...)
}

type ValidateReplaceSpecType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateReplaceSpecType) AddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for address")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) InsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) SiteToSiteTunnelIpValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_to_site_tunnel_ip")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) BgpRouterIdValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bgp_router_id")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) BgpPeerAddressValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for bgp_peer_address")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) OutsideVipValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_vip")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) SiteToSiteNetworkTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.VirtualNetworkType)
		return int32(i)
	}
	// ves_io_schema.VirtualNetworkType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.VirtualNetworkType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for site_to_site_network_type")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) InsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for inside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) OutsideNameserverValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for outside_nameserver")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) DesiredPoolCountValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewInt32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for desired_pool_count")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) TunnelTypeValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	var conv db.EnumConvFn
	conv = func(v interface{}) int32 {
		i := v.(ves_io_schema.SiteToSiteTunnelType)
		return int32(i)
	}
	// ves_io_schema.SiteToSiteTunnelType_name is generated in .pb.go
	validatorFn, err := db.NewEnumValidationRuleHandler(rules, ves_io_schema.SiteToSiteTunnelType_name, conv)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_type")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) TunnelDeadTimeoutValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewUint32ValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for tunnel_dead_timeout")
	}

	return validatorFn, nil
}

func (v *ValidateReplaceSpecType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ReplaceSpecType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ReplaceSpecType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_peer_address"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_peer_address"))
		if err := fv(ctx, m.GetBgpPeerAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bgp_router_id"]; exists {

		vOpts := append(opts, db.WithValidateField("bgp_router_id"))
		if err := fv(ctx, m.GetBgpRouterId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["coordinates"]; exists {

		vOpts := append(opts, db.WithValidateField("coordinates"))
		if err := fv(ctx, m.GetCoordinates(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["default_underlay_network"]; exists {

		vOpts := append(opts, db.WithValidateField("default_underlay_network"))
		if err := fv(ctx, m.GetDefaultUnderlayNetwork(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["desired_pool_count"]; exists {

		vOpts := append(opts, db.WithValidateField("desired_pool_count"))
		if err := fv(ctx, m.GetDesiredPoolCount(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_nameserver"))
		if err := fv(ctx, m.GetInsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["inside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("inside_vip"))
		if err := fv(ctx, m.GetInsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["operating_system_version"]; exists {

		vOpts := append(opts, db.WithValidateField("operating_system_version"))
		if err := fv(ctx, m.GetOperatingSystemVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_nameserver"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_nameserver"))
		if err := fv(ctx, m.GetOutsideNameserver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["outside_vip"]; exists {

		vOpts := append(opts, db.WithValidateField("outside_vip"))
		if err := fv(ctx, m.GetOutsideVip(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["region"]; exists {

		vOpts := append(opts, db.WithValidateField("region"))
		if err := fv(ctx, m.GetRegion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_network_type"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_network_type"))
		if err := fv(ctx, m.GetSiteToSiteNetworkType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_to_site_tunnel_ip"]; exists {

		vOpts := append(opts, db.WithValidateField("site_to_site_tunnel_ip"))
		if err := fv(ctx, m.GetSiteToSiteTunnelIp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_dead_timeout"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_dead_timeout"))
		if err := fv(ctx, m.GetTunnelDeadTimeout(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnel_type"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnel_type"))
		if err := fv(ctx, m.GetTunnelType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vip_vrrp_mode"]; exists {

		vOpts := append(opts, db.WithValidateField("vip_vrrp_mode"))
		if err := fv(ctx, m.GetVipVrrpMode(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_overide"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_overide"))
		if err := fv(ctx, m.GetVolterraSoftwareOveride(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["volterra_software_version"]; exists {

		vOpts := append(opts, db.WithValidateField("volterra_software_version"))
		if err := fv(ctx, m.GetVolterraSoftwareVersion(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultReplaceSpecTypeValidator = func() *ValidateReplaceSpecType {
	v := &ValidateReplaceSpecType{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhAddress := v.AddressValidationRuleHandler
	rulesAddress := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhAddress(rulesAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["address"] = vFn

	vrhInsideVip := v.InsideVipValidationRuleHandler
	rulesInsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideVip(rulesInsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.inside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_vip"] = vFn

	vrhSiteToSiteTunnelIp := v.SiteToSiteTunnelIpValidationRuleHandler
	rulesSiteToSiteTunnelIp := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhSiteToSiteTunnelIp(rulesSiteToSiteTunnelIp)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.site_to_site_tunnel_ip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_to_site_tunnel_ip"] = vFn

	vrhBgpRouterId := v.BgpRouterIdValidationRuleHandler
	rulesBgpRouterId := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhBgpRouterId(rulesBgpRouterId)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.bgp_router_id: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bgp_router_id"] = vFn

	vrhBgpPeerAddress := v.BgpPeerAddressValidationRuleHandler
	rulesBgpPeerAddress := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhBgpPeerAddress(rulesBgpPeerAddress)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.bgp_peer_address: %s", err)
		panic(errMsg)
	}
	v.FldValidators["bgp_peer_address"] = vFn

	vrhOutsideVip := v.OutsideVipValidationRuleHandler
	rulesOutsideVip := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhOutsideVip(rulesOutsideVip)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.outside_vip: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_vip"] = vFn

	vrhSiteToSiteNetworkType := v.SiteToSiteNetworkTypeValidationRuleHandler
	rulesSiteToSiteNetworkType := map[string]string{
		"ves.io.schema.rules.enum.in": "[0,1]",
	}
	vFn, err = vrhSiteToSiteNetworkType(rulesSiteToSiteNetworkType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.site_to_site_network_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["site_to_site_network_type"] = vFn

	vrhInsideNameserver := v.InsideNameserverValidationRuleHandler
	rulesInsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhInsideNameserver(rulesInsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.inside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["inside_nameserver"] = vFn

	vrhOutsideNameserver := v.OutsideNameserverValidationRuleHandler
	rulesOutsideNameserver := map[string]string{
		"ves.io.schema.rules.string.ip": "true",
	}
	vFn, err = vrhOutsideNameserver(rulesOutsideNameserver)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.outside_nameserver: %s", err)
		panic(errMsg)
	}
	v.FldValidators["outside_nameserver"] = vFn

	vrhDesiredPoolCount := v.DesiredPoolCountValidationRuleHandler
	rulesDesiredPoolCount := map[string]string{
		"ves.io.schema.rules.int32.gte": "-1",
		"ves.io.schema.rules.int32.lte": "64",
	}
	vFn, err = vrhDesiredPoolCount(rulesDesiredPoolCount)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.desired_pool_count: %s", err)
		panic(errMsg)
	}
	v.FldValidators["desired_pool_count"] = vFn

	vrhTunnelType := v.TunnelTypeValidationRuleHandler
	rulesTunnelType := map[string]string{
		"ves.io.schema.rules.enum.in": "[0,1,2]",
	}
	vFn, err = vrhTunnelType(rulesTunnelType)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.tunnel_type: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_type"] = vFn

	vrhTunnelDeadTimeout := v.TunnelDeadTimeoutValidationRuleHandler
	rulesTunnelDeadTimeout := map[string]string{
		"ves.io.schema.rules.uint32.gte": "0",
		"ves.io.schema.rules.uint32.lte": "180000",
	}
	vFn, err = vrhTunnelDeadTimeout(rulesTunnelDeadTimeout)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for ReplaceSpecType.tunnel_dead_timeout: %s", err)
		panic(errMsg)
	}
	v.FldValidators["tunnel_dead_timeout"] = vFn

	v.FldValidators["coordinates"] = CoordinatesValidator().Validate

	v.FldValidators["default_underlay_network"] = DefaultUnderlayNetworkTypeValidator().Validate

	return v
}()

func ReplaceSpecTypeValidator() db.Validator {
	return DefaultReplaceSpecTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *RevokeKubeConfigReq) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RevokeKubeConfigReq) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RevokeKubeConfigReq) DeepCopy() *RevokeKubeConfigReq {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RevokeKubeConfigReq{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RevokeKubeConfigReq) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RevokeKubeConfigReq) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RevokeKubeConfigReqValidator().Validate(ctx, m, opts...)
}

type ValidateRevokeKubeConfigReq struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRevokeKubeConfigReq) NameValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for name")
	}

	return validatorFn, nil
}

func (v *ValidateRevokeKubeConfigReq) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RevokeKubeConfigReq)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RevokeKubeConfigReq got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRevokeKubeConfigReqValidator = func() *ValidateRevokeKubeConfigReq {
	v := &ValidateRevokeKubeConfigReq{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhName := v.NameValidationRuleHandler
	rulesName := map[string]string{
		"ves.io.schema.rules.message.required": "true",
		"ves.io.schema.rules.string.max_bytes": "64",
		"ves.io.schema.rules.string.min_bytes": "1",
	}
	vFn, err = vrhName(rulesName)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for RevokeKubeConfigReq.name: %s", err)
		panic(errMsg)
	}
	v.FldValidators["name"] = vFn

	return v
}()

func RevokeKubeConfigReqValidator() db.Validator {
	return DefaultRevokeKubeConfigReqValidator
}

// augmented methods on protoc/std generated struct

func (m *RouteServerPeeringStatusType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RouteServerPeeringStatusType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RouteServerPeeringStatusType) DeepCopy() *RouteServerPeeringStatusType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RouteServerPeeringStatusType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RouteServerPeeringStatusType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RouteServerPeeringStatusType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RouteServerPeeringStatusTypeValidator().Validate(ctx, m, opts...)
}

type ValidateRouteServerPeeringStatusType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRouteServerPeeringStatusType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RouteServerPeeringStatusType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RouteServerPeeringStatusType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["connection_state"]; exists {

		vOpts := append(opts, db.WithValidateField("connection_state"))
		if err := fv(ctx, m.GetConnectionState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["peerIP"]; exists {

		vOpts := append(opts, db.WithValidateField("peerIP"))
		if err := fv(ctx, m.GetPeerIP(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["peer_asn"]; exists {

		vOpts := append(opts, db.WithValidateField("peer_asn"))
		if err := fv(ctx, m.GetPeerAsn(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["provisioningState"]; exists {

		vOpts := append(opts, db.WithValidateField("provisioningState"))
		if err := fv(ctx, m.GetProvisioningState(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRouteServerPeeringStatusTypeValidator = func() *ValidateRouteServerPeeringStatusType {
	v := &ValidateRouteServerPeeringStatusType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func RouteServerPeeringStatusTypeValidator() db.Validator {
	return DefaultRouteServerPeeringStatusTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *RouteServerStatusType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *RouteServerStatusType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *RouteServerStatusType) DeepCopy() *RouteServerStatusType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &RouteServerStatusType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *RouteServerStatusType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *RouteServerStatusType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return RouteServerStatusTypeValidator().Validate(ctx, m, opts...)
}

type ValidateRouteServerStatusType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateRouteServerStatusType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*RouteServerStatusType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *RouteServerStatusType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["peers"]; exists {

		vOpts := append(opts, db.WithValidateField("peers"))
		for idx, item := range m.GetPeers() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["route_server_name"]; exists {

		vOpts := append(opts, db.WithValidateField("route_server_name"))
		if err := fv(ctx, m.GetRouteServerName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultRouteServerStatusTypeValidator = func() *ValidateRouteServerStatusType {
	v := &ValidateRouteServerStatusType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func RouteServerStatusTypeValidator() db.Validator {
	return DefaultRouteServerStatusTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *ScalingStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *ScalingStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *ScalingStatus) DeepCopy() *ScalingStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &ScalingStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *ScalingStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *ScalingStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return ScalingStatusValidator().Validate(ctx, m, opts...)
}

type ValidateScalingStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateScalingStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*ScalingStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *ScalingStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["message"]; exists {

		vOpts := append(opts, db.WithValidateField("message"))
		if err := fv(ctx, m.GetMessage(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["phase"]; exists {

		vOpts := append(opts, db.WithValidateField("phase"))
		if err := fv(ctx, m.GetPhase(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["pool_node_count_current"]; exists {

		vOpts := append(opts, db.WithValidateField("pool_node_count_current"))
		if err := fv(ctx, m.GetPoolNodeCountCurrent(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["pool_node_count_target"]; exists {

		vOpts := append(opts, db.WithValidateField("pool_node_count_target"))
		if err := fv(ctx, m.GetPoolNodeCountTarget(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultScalingStatusValidator = func() *ValidateScalingStatus {
	v := &ValidateScalingStatus{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func ScalingStatusValidator() db.Validator {
	return DefaultScalingStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteStatusMetricsData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteStatusMetricsData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteStatusMetricsData) DeepCopy() *SiteStatusMetricsData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteStatusMetricsData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteStatusMetricsData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteStatusMetricsData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteStatusMetricsDataValidator().Validate(ctx, m, opts...)
}

type ValidateSiteStatusMetricsData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteStatusMetricsData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteStatusMetricsData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteStatusMetricsData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["data"]; exists {

		vOpts := append(opts, db.WithValidateField("data"))
		for idx, item := range m.GetData() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["field"]; exists {

		vOpts := append(opts, db.WithValidateField("field"))
		if err := fv(ctx, m.GetField(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteStatusMetricsDataValidator = func() *ValidateSiteStatusMetricsData {
	v := &ValidateSiteStatusMetricsData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SiteStatusMetricsDataValidator() db.Validator {
	return DefaultSiteStatusMetricsDataValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteStatusMetricsFieldData) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteStatusMetricsFieldData) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteStatusMetricsFieldData) DeepCopy() *SiteStatusMetricsFieldData {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteStatusMetricsFieldData{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteStatusMetricsFieldData) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteStatusMetricsFieldData) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteStatusMetricsFieldDataValidator().Validate(ctx, m, opts...)
}

type ValidateSiteStatusMetricsFieldData struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteStatusMetricsFieldData) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteStatusMetricsFieldData)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteStatusMetricsFieldData got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["key"]; exists {

		vOpts := append(opts, db.WithValidateField("key"))
		for key, value := range m.GetKey() {
			vOpts := append(vOpts, db.WithValidateMapKey(key))
			if err := fv(ctx, value, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["value"]; exists {

		vOpts := append(opts, db.WithValidateField("value"))
		for idx, item := range m.GetValue() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteStatusMetricsFieldDataValidator = func() *ValidateSiteStatusMetricsFieldData {
	v := &ValidateSiteStatusMetricsFieldData{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SiteStatusMetricsFieldDataValidator() db.Validator {
	return DefaultSiteStatusMetricsFieldDataValidator
}

// augmented methods on protoc/std generated struct

func (m *SiteToSiteTunnelConnectivity) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *SiteToSiteTunnelConnectivity) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *SiteToSiteTunnelConnectivity) DeepCopy() *SiteToSiteTunnelConnectivity {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &SiteToSiteTunnelConnectivity{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *SiteToSiteTunnelConnectivity) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *SiteToSiteTunnelConnectivity) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return SiteToSiteTunnelConnectivityValidator().Validate(ctx, m, opts...)
}

type ValidateSiteToSiteTunnelConnectivity struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateSiteToSiteTunnelConnectivity) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*SiteToSiteTunnelConnectivity)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *SiteToSiteTunnelConnectivity got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["destination"]; exists {

		vOpts := append(opts, db.WithValidateField("destination"))
		for idx, item := range m.GetDestination() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["port"]; exists {

		vOpts := append(opts, db.WithValidateField("port"))
		if err := fv(ctx, m.GetPort(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultSiteToSiteTunnelConnectivityValidator = func() *ValidateSiteToSiteTunnelConnectivity {
	v := &ValidateSiteToSiteTunnelConnectivity{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func SiteToSiteTunnelConnectivityValidator() db.Validator {
	return DefaultSiteToSiteTunnelConnectivityValidator
}

// augmented methods on protoc/std generated struct

func (m *StorageDevice) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *StorageDevice) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *StorageDevice) DeepCopy() *StorageDevice {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &StorageDevice{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *StorageDevice) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *StorageDevice) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return StorageDeviceValidator().Validate(ctx, m, opts...)
}

type ValidateStorageDevice struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateStorageDevice) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*StorageDevice)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *StorageDevice got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["driver"]; exists {

		vOpts := append(opts, db.WithValidateField("driver"))
		if err := fv(ctx, m.GetDriver(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["model"]; exists {

		vOpts := append(opts, db.WithValidateField("model"))
		if err := fv(ctx, m.GetModel(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["name"]; exists {

		vOpts := append(opts, db.WithValidateField("name"))
		if err := fv(ctx, m.GetName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["serial"]; exists {

		vOpts := append(opts, db.WithValidateField("serial"))
		if err := fv(ctx, m.GetSerial(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["size_gb"]; exists {

		vOpts := append(opts, db.WithValidateField("size_gb"))
		if err := fv(ctx, m.GetSizeGb(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vendor"]; exists {

		vOpts := append(opts, db.WithValidateField("vendor"))
		if err := fv(ctx, m.GetVendor(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultStorageDeviceValidator = func() *ValidateStorageDevice {
	v := &ValidateStorageDevice{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func StorageDeviceValidator() db.Validator {
	return DefaultStorageDeviceValidator
}

// augmented methods on protoc/std generated struct

func (m *TunnelConnectionStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *TunnelConnectionStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *TunnelConnectionStatus) DeepCopy() *TunnelConnectionStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &TunnelConnectionStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *TunnelConnectionStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *TunnelConnectionStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return TunnelConnectionStatusValidator().Validate(ctx, m, opts...)
}

type ValidateTunnelConnectionStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateTunnelConnectionStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*TunnelConnectionStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *TunnelConnectionStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["encap"]; exists {

		vOpts := append(opts, db.WithValidateField("encap"))
		if err := fv(ctx, m.GetEncap(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["isLocal"]; exists {

		vOpts := append(opts, db.WithValidateField("isLocal"))
		if err := fv(ctx, m.GetIsLocal(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["remoteAddress"]; exists {

		vOpts := append(opts, db.WithValidateField("remoteAddress"))
		if err := fv(ctx, m.GetRemoteAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["role"]; exists {

		vOpts := append(opts, db.WithValidateField("role"))
		if err := fv(ctx, m.GetRole(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["tunnelName"]; exists {

		vOpts := append(opts, db.WithValidateField("tunnelName"))
		if err := fv(ctx, m.GetTunnelName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["url"]; exists {

		vOpts := append(opts, db.WithValidateField("url"))
		if err := fv(ctx, m.GetUrl(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["verNodeName"]; exists {

		vOpts := append(opts, db.WithValidateField("verNodeName"))
		if err := fv(ctx, m.GetVerNodeName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultTunnelConnectionStatusValidator = func() *ValidateTunnelConnectionStatus {
	v := &ValidateTunnelConnectionStatus{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func TunnelConnectionStatusValidator() db.Validator {
	return DefaultTunnelConnectionStatusValidator
}

// augmented methods on protoc/std generated struct

func (m *USBDevice) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *USBDevice) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *USBDevice) DeepCopy() *USBDevice {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &USBDevice{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *USBDevice) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *USBDevice) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return USBDeviceValidator().Validate(ctx, m, opts...)
}

type ValidateUSBDevice struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateUSBDevice) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*USBDevice)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *USBDevice got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["address"]; exists {

		vOpts := append(opts, db.WithValidateField("address"))
		if err := fv(ctx, m.GetAddress(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["b_device_class"]; exists {

		vOpts := append(opts, db.WithValidateField("b_device_class"))
		if err := fv(ctx, m.GetBDeviceClass(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["b_device_protocol"]; exists {

		vOpts := append(opts, db.WithValidateField("b_device_protocol"))
		if err := fv(ctx, m.GetBDeviceProtocol(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["b_device_sub_class"]; exists {

		vOpts := append(opts, db.WithValidateField("b_device_sub_class"))
		if err := fv(ctx, m.GetBDeviceSubClass(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["b_max_packet_size"]; exists {

		vOpts := append(opts, db.WithValidateField("b_max_packet_size"))
		if err := fv(ctx, m.GetBMaxPacketSize(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bcd_device"]; exists {

		vOpts := append(opts, db.WithValidateField("bcd_device"))
		if err := fv(ctx, m.GetBcdDevice(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bcd_usb"]; exists {

		vOpts := append(opts, db.WithValidateField("bcd_usb"))
		if err := fv(ctx, m.GetBcdUsb(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["bus"]; exists {

		vOpts := append(opts, db.WithValidateField("bus"))
		if err := fv(ctx, m.GetBus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["i_manufacturer"]; exists {

		vOpts := append(opts, db.WithValidateField("i_manufacturer"))
		if err := fv(ctx, m.GetIManufacturer(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["i_product"]; exists {

		vOpts := append(opts, db.WithValidateField("i_product"))
		if err := fv(ctx, m.GetIProduct(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["i_serial"]; exists {

		vOpts := append(opts, db.WithValidateField("i_serial"))
		if err := fv(ctx, m.GetISerial(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["id_product"]; exists {

		vOpts := append(opts, db.WithValidateField("id_product"))
		if err := fv(ctx, m.GetIdProduct(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["id_vendor"]; exists {

		vOpts := append(opts, db.WithValidateField("id_vendor"))
		if err := fv(ctx, m.GetIdVendor(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["port"]; exists {

		vOpts := append(opts, db.WithValidateField("port"))
		if err := fv(ctx, m.GetPort(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["product_name"]; exists {

		vOpts := append(opts, db.WithValidateField("product_name"))
		if err := fv(ctx, m.GetProductName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["speed"]; exists {

		vOpts := append(opts, db.WithValidateField("speed"))
		if err := fv(ctx, m.GetSpeed(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["usb_type"]; exists {

		vOpts := append(opts, db.WithValidateField("usb_type"))
		if err := fv(ctx, m.GetUsbType(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vendor_name"]; exists {

		vOpts := append(opts, db.WithValidateField("vendor_name"))
		if err := fv(ctx, m.GetVendorName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultUSBDeviceValidator = func() *ValidateUSBDevice {
	v := &ValidateUSBDevice{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func USBDeviceValidator() db.Validator {
	return DefaultUSBDeviceValidator
}

// augmented methods on protoc/std generated struct

func (m *VerInstanceRunningStateStatusType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VerInstanceRunningStateStatusType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VerInstanceRunningStateStatusType) DeepCopy() *VerInstanceRunningStateStatusType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VerInstanceRunningStateStatusType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VerInstanceRunningStateStatusType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VerInstanceRunningStateStatusType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VerInstanceRunningStateStatusTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVerInstanceRunningStateStatusType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVerInstanceRunningStateStatusType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VerInstanceRunningStateStatusType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VerInstanceRunningStateStatusType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["description"]; exists {

		vOpts := append(opts, db.WithValidateField("description"))
		if err := fv(ctx, m.GetDescription(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["state"]; exists {

		vOpts := append(opts, db.WithValidateField("state"))
		if err := fv(ctx, m.GetState(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVerInstanceRunningStateStatusTypeValidator = func() *ValidateVerInstanceRunningStateStatusType {
	v := &ValidateVerInstanceRunningStateStatusType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func VerInstanceRunningStateStatusTypeValidator() db.Validator {
	return DefaultVerInstanceRunningStateStatusTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VerMasterStatusType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VerMasterStatusType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VerMasterStatusType) DeepCopy() *VerMasterStatusType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VerMasterStatusType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VerMasterStatusType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VerMasterStatusType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VerMasterStatusTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVerMasterStatusType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVerMasterStatusType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VerMasterStatusType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VerMasterStatusType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["transition_timestamp"]; exists {

		vOpts := append(opts, db.WithValidateField("transition_timestamp"))
		if err := fv(ctx, m.GetTransitionTimestamp(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ver_UID"]; exists {

		vOpts := append(opts, db.WithValidateField("ver_UID"))
		if err := fv(ctx, m.GetVer_UID(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["ver_name"]; exists {

		vOpts := append(opts, db.WithValidateField("ver_name"))
		if err := fv(ctx, m.GetVerName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVerMasterStatusTypeValidator = func() *ValidateVerMasterStatusType {
	v := &ValidateVerMasterStatusType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func VerMasterStatusTypeValidator() db.Validator {
	return DefaultVerMasterStatusTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VerStatusType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VerStatusType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VerStatusType) DeepCopy() *VerStatusType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VerStatusType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VerStatusType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VerStatusType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VerStatusTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVerStatusType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVerStatusType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VerStatusType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VerStatusType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["ares_status"]; exists {

		vOpts := append(opts, db.WithValidateField("ares_status"))
		for idx, item := range m.GetAresStatus() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["configured_tunnel_status"]; exists {

		vOpts := append(opts, db.WithValidateField("configured_tunnel_status"))
		for idx, item := range m.GetConfiguredTunnelStatus() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["intf_status"]; exists {

		vOpts := append(opts, db.WithValidateField("intf_status"))
		for idx, item := range m.GetIntfStatus() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["running_state_status"]; exists {

		vOpts := append(opts, db.WithValidateField("running_state_status"))
		if err := fv(ctx, m.GetRunningStateStatus(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["site_tunnel_status"]; exists {

		vOpts := append(opts, db.WithValidateField("site_tunnel_status"))
		for idx, item := range m.GetSiteTunnelStatus() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["ver_instance_name"]; exists {

		vOpts := append(opts, db.WithValidateField("ver_instance_name"))
		if err := fv(ctx, m.GetVerInstanceName(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVerStatusTypeValidator = func() *ValidateVerStatusType {
	v := &ValidateVerStatusType{FldValidators: map[string]db.ValidatorFunc{}}

	v.FldValidators["intf_status"] = InterfaceStatusValidator().Validate

	return v
}()

func VerStatusTypeValidator() db.Validator {
	return DefaultVerStatusTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VnetGatewayStatusType) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VnetGatewayStatusType) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VnetGatewayStatusType) DeepCopy() *VnetGatewayStatusType {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VnetGatewayStatusType{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VnetGatewayStatusType) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VnetGatewayStatusType) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VnetGatewayStatusTypeValidator().Validate(ctx, m, opts...)
}

type ValidateVnetGatewayStatusType struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVnetGatewayStatusType) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VnetGatewayStatusType)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VnetGatewayStatusType got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["connection_status"]; exists {

		vOpts := append(opts, db.WithValidateField("connection_status"))
		for idx, item := range m.GetConnectionStatus() {
			vOpts := append(vOpts, db.WithValidateRepItem(idx), db.WithValidateIsRepItem(true))
			if err := fv(ctx, item, vOpts...); err != nil {
				return err
			}
		}

	}

	if fv, exists := v.FldValidators["vgw_id"]; exists {

		vOpts := append(opts, db.WithValidateField("vgw_id"))
		if err := fv(ctx, m.GetVgwId(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vgw_name"]; exists {

		vOpts := append(opts, db.WithValidateField("vgw_name"))
		if err := fv(ctx, m.GetVgwName(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["vgw_state"]; exists {

		vOpts := append(opts, db.WithValidateField("vgw_state"))
		if err := fv(ctx, m.GetVgwState(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVnetGatewayStatusTypeValidator = func() *ValidateVnetGatewayStatusType {
	v := &ValidateVnetGatewayStatusType{FldValidators: map[string]db.ValidatorFunc{}}

	return v
}()

func VnetGatewayStatusTypeValidator() db.Validator {
	return DefaultVnetGatewayStatusTypeValidator
}

// augmented methods on protoc/std generated struct

func (m *VolterraSoftwareStatus) ToJSON() (string, error) {
	return codec.ToJSON(m)
}

func (m *VolterraSoftwareStatus) ToYAML() (string, error) {
	return codec.ToYAML(m)
}

func (m *VolterraSoftwareStatus) DeepCopy() *VolterraSoftwareStatus {
	if m == nil {
		return nil
	}
	ser, err := m.Marshal()
	if err != nil {
		return nil
	}
	c := &VolterraSoftwareStatus{}
	err = c.Unmarshal(ser)
	if err != nil {
		return nil
	}
	return c
}

func (m *VolterraSoftwareStatus) DeepCopyProto() proto.Message {
	if m == nil {
		return nil
	}
	return m.DeepCopy()
}

func (m *VolterraSoftwareStatus) Validate(ctx context.Context, opts ...db.ValidateOpt) error {
	return VolterraSoftwareStatusValidator().Validate(ctx, m, opts...)
}

type ValidateVolterraSoftwareStatus struct {
	FldValidators map[string]db.ValidatorFunc
}

func (v *ValidateVolterraSoftwareStatus) NonconformingStateValidationRuleHandler(rules map[string]string) (db.ValidatorFunc, error) {

	validatorFn, err := db.NewStringValidationRuleHandler(rules)
	if err != nil {
		return nil, errors.Wrap(err, "ValidationRuleHandler for nonconforming_state")
	}

	return validatorFn, nil
}

func (v *ValidateVolterraSoftwareStatus) Validate(ctx context.Context, pm interface{}, opts ...db.ValidateOpt) error {
	m, ok := pm.(*VolterraSoftwareStatus)
	if !ok {
		switch t := pm.(type) {
		case nil:
			return nil
		default:
			return fmt.Errorf("Expected type *VolterraSoftwareStatus got type %s", t)
		}
	}
	if m == nil {
		return nil
	}

	if fv, exists := v.FldValidators["available_version"]; exists {

		vOpts := append(opts, db.WithValidateField("available_version"))
		if err := fv(ctx, m.GetAvailableVersion(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["deployment_state"]; exists {

		vOpts := append(opts, db.WithValidateField("deployment_state"))
		if err := fv(ctx, m.GetDeploymentState(), vOpts...); err != nil {
			return err
		}

	}

	if fv, exists := v.FldValidators["nonconforming_state"]; exists {

		vOpts := append(opts, db.WithValidateField("nonconforming_state"))
		if err := fv(ctx, m.GetNonconformingState(), vOpts...); err != nil {
			return err
		}

	}

	return nil
}

// Well-known symbol for default validator implementation
var DefaultVolterraSoftwareStatusValidator = func() *ValidateVolterraSoftwareStatus {
	v := &ValidateVolterraSoftwareStatus{FldValidators: map[string]db.ValidatorFunc{}}

	var (
		err error
		vFn db.ValidatorFunc
	)
	_, _ = err, vFn
	vFnMap := map[string]db.ValidatorFunc{}
	_ = vFnMap

	vrhNonconformingState := v.NonconformingStateValidationRuleHandler
	rulesNonconformingState := map[string]string{
		"ves.io.schema.rules.string.max_len": "256",
	}
	vFn, err = vrhNonconformingState(rulesNonconformingState)
	if err != nil {
		errMsg := fmt.Sprintf("ValidationRuleHandler for VolterraSoftwareStatus.nonconforming_state: %s", err)
		panic(errMsg)
	}
	v.FldValidators["nonconforming_state"] = vFn

	return v
}()

func VolterraSoftwareStatusValidator() db.Validator {
	return DefaultVolterraSoftwareStatusValidator
}

func (m *CreateSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.Address = f.GetAddress()
	m.BgpPeerAddress = f.GetBgpPeerAddress()
	m.BgpRouterId = f.GetBgpRouterId()
	m.CeSiteMode = f.GetCeSiteMode()
	m.Coordinates = f.GetCoordinates()
	m.DefaultUnderlayNetwork = f.GetDefaultUnderlayNetwork()
	m.DesiredPoolCount = f.GetDesiredPoolCount()
	m.InsideNameserver = f.GetInsideNameserver()
	m.InsideVip = f.GetInsideVip()
	m.OperatingSystemVersion = f.GetOperatingSystemVersion()
	m.OutsideNameserver = f.GetOutsideNameserver()
	m.OutsideVip = f.GetOutsideVip()
	m.Region = f.GetRegion()
	m.SiteToSiteNetworkType = f.GetSiteToSiteNetworkType()
	m.SiteToSiteTunnelIp = f.GetSiteToSiteTunnelIp()
	m.SiteType = f.GetSiteType()
	m.TunnelDeadTimeout = f.GetTunnelDeadTimeout()
	m.TunnelType = f.GetTunnelType()
	m.VipVrrpMode = f.GetVipVrrpMode()
	m.VolterraSoftwareOveride = f.GetVolterraSoftwareOveride()
}

func (m *CreateSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *CreateSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *CreateSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.Address = m1.Address
	f.BgpPeerAddress = m1.BgpPeerAddress
	f.BgpRouterId = m1.BgpRouterId
	f.CeSiteMode = m1.CeSiteMode
	f.Coordinates = m1.Coordinates
	f.DefaultUnderlayNetwork = m1.DefaultUnderlayNetwork
	f.DesiredPoolCount = m1.DesiredPoolCount
	f.InsideNameserver = m1.InsideNameserver
	f.InsideVip = m1.InsideVip
	f.OperatingSystemVersion = m1.OperatingSystemVersion
	f.OutsideNameserver = m1.OutsideNameserver
	f.OutsideVip = m1.OutsideVip
	f.Region = m1.Region
	f.SiteToSiteNetworkType = m1.SiteToSiteNetworkType
	f.SiteToSiteTunnelIp = m1.SiteToSiteTunnelIp
	f.SiteType = m1.SiteType
	f.TunnelDeadTimeout = m1.TunnelDeadTimeout
	f.TunnelType = m1.TunnelType
	f.VipVrrpMode = m1.VipVrrpMode
	f.VolterraSoftwareOveride = m1.VolterraSoftwareOveride
}

func (m *CreateSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *CreateSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

func (m *GetSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.Address = f.GetAddress()
	m.BgpPeerAddress = f.GetBgpPeerAddress()
	m.BgpRouterId = f.GetBgpRouterId()
	m.CeSiteMode = f.GetCeSiteMode()
	m.ConnectedRe = f.GetConnectedRe()
	m.ConnectedReForConfig = f.GetConnectedReForConfig()
	m.Coordinates = f.GetCoordinates()
	m.DefaultUnderlayNetwork = f.GetDefaultUnderlayNetwork()
	m.DesiredPoolCount = f.GetDesiredPoolCount()

	m.InsideNameserver = f.GetInsideNameserver()
	m.InsideVip = f.GetInsideVip()
	m.IpsecSslNodesFqdn = f.GetIpsecSslNodesFqdn()

	m.LocalK8SAccessEnabled = f.GetLocalK8SAccessEnabled()
	m.MultusEnabled = f.GetMultusEnabled()
	m.OperatingSystemVersion = f.GetOperatingSystemVersion()
	m.OutsideNameserver = f.GetOutsideNameserver()
	m.OutsideVip = f.GetOutsideVip()
	m.Region = f.GetRegion()
	m.SiteState = f.GetSiteState()
	m.SiteSubtype = f.GetSiteSubtype()
	m.SiteToSiteIpsecConnectivity = f.GetSiteToSiteIpsecConnectivity()
	m.SiteToSiteNetworkType = f.GetSiteToSiteNetworkType()
	m.SiteToSiteTunnelIp = f.GetSiteToSiteTunnelIp()
	m.SiteType = f.GetSiteType()
	m.TunnelDeadTimeout = f.GetTunnelDeadTimeout()
	m.TunnelType = f.GetTunnelType()
	m.VipParamsPerAz = f.GetVipParamsPerAz()
	m.VipVrrpMode = f.GetVipVrrpMode()
	m.VmEnabled = f.GetVmEnabled()
	m.VolterraSoftwareOveride = f.GetVolterraSoftwareOveride()
	m.VolterraSoftwareVersion = f.GetVolterraSoftwareVersion()
}

func (m *GetSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *GetSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *GetSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.Address = m1.Address
	f.BgpPeerAddress = m1.BgpPeerAddress
	f.BgpRouterId = m1.BgpRouterId
	f.CeSiteMode = m1.CeSiteMode
	f.ConnectedRe = m1.ConnectedRe
	f.ConnectedReForConfig = m1.ConnectedReForConfig
	f.Coordinates = m1.Coordinates
	f.DefaultUnderlayNetwork = m1.DefaultUnderlayNetwork
	f.DesiredPoolCount = m1.DesiredPoolCount

	f.InsideNameserver = m1.InsideNameserver
	f.InsideVip = m1.InsideVip
	f.IpsecSslNodesFqdn = m1.IpsecSslNodesFqdn

	f.LocalK8SAccessEnabled = m1.LocalK8SAccessEnabled
	f.MultusEnabled = m1.MultusEnabled
	f.OperatingSystemVersion = m1.OperatingSystemVersion
	f.OutsideNameserver = m1.OutsideNameserver
	f.OutsideVip = m1.OutsideVip
	f.Region = m1.Region
	f.SiteState = m1.SiteState
	f.SiteSubtype = m1.SiteSubtype
	f.SiteToSiteIpsecConnectivity = m1.SiteToSiteIpsecConnectivity
	f.SiteToSiteNetworkType = m1.SiteToSiteNetworkType
	f.SiteToSiteTunnelIp = m1.SiteToSiteTunnelIp
	f.SiteType = m1.SiteType
	f.TunnelDeadTimeout = m1.TunnelDeadTimeout
	f.TunnelType = m1.TunnelType
	f.VipParamsPerAz = m1.VipParamsPerAz
	f.VipVrrpMode = m1.VipVrrpMode
	f.VmEnabled = m1.VmEnabled
	f.VolterraSoftwareOveride = m1.VolterraSoftwareOveride
	f.VolterraSoftwareVersion = m1.VolterraSoftwareVersion
}

func (m *GetSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *GetSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) fromGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	if f == nil {
		return
	}
	m.Address = f.GetAddress()
	m.BgpPeerAddress = f.GetBgpPeerAddress()
	m.BgpRouterId = f.GetBgpRouterId()
	m.Coordinates = f.GetCoordinates()
	m.DefaultUnderlayNetwork = f.GetDefaultUnderlayNetwork()
	m.DesiredPoolCount = f.GetDesiredPoolCount()
	m.InsideNameserver = f.GetInsideNameserver()
	m.InsideVip = f.GetInsideVip()
	m.OperatingSystemVersion = f.GetOperatingSystemVersion()
	m.OutsideNameserver = f.GetOutsideNameserver()
	m.OutsideVip = f.GetOutsideVip()
	m.Region = f.GetRegion()
	m.SiteToSiteNetworkType = f.GetSiteToSiteNetworkType()
	m.SiteToSiteTunnelIp = f.GetSiteToSiteTunnelIp()
	m.TunnelDeadTimeout = f.GetTunnelDeadTimeout()
	m.TunnelType = f.GetTunnelType()
	m.VipVrrpMode = f.GetVipVrrpMode()
	m.VolterraSoftwareOveride = f.GetVolterraSoftwareOveride()
	m.VolterraSoftwareVersion = f.GetVolterraSoftwareVersion()
}

func (m *ReplaceSpecType) FromGlobalSpecType(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) FromGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.fromGlobalSpecType(f, false)
}

func (m *ReplaceSpecType) toGlobalSpecType(f *GlobalSpecType, withDeepCopy bool) {
	m1 := m
	if withDeepCopy {
		m1 = m.DeepCopy()
	}
	_ = m1

	f.Address = m1.Address
	f.BgpPeerAddress = m1.BgpPeerAddress
	f.BgpRouterId = m1.BgpRouterId
	f.Coordinates = m1.Coordinates
	f.DefaultUnderlayNetwork = m1.DefaultUnderlayNetwork
	f.DesiredPoolCount = m1.DesiredPoolCount
	f.InsideNameserver = m1.InsideNameserver
	f.InsideVip = m1.InsideVip
	f.OperatingSystemVersion = m1.OperatingSystemVersion
	f.OutsideNameserver = m1.OutsideNameserver
	f.OutsideVip = m1.OutsideVip
	f.Region = m1.Region
	f.SiteToSiteNetworkType = m1.SiteToSiteNetworkType
	f.SiteToSiteTunnelIp = m1.SiteToSiteTunnelIp
	f.TunnelDeadTimeout = m1.TunnelDeadTimeout
	f.TunnelType = m1.TunnelType
	f.VipVrrpMode = m1.VipVrrpMode
	f.VolterraSoftwareOveride = m1.VolterraSoftwareOveride
	f.VolterraSoftwareVersion = m1.VolterraSoftwareVersion
}

func (m *ReplaceSpecType) ToGlobalSpecType(f *GlobalSpecType) {
	m.toGlobalSpecType(f, true)
}

func (m *ReplaceSpecType) ToGlobalSpecTypeWithoutDeepCopy(f *GlobalSpecType) {
	m.toGlobalSpecType(f, false)
}
